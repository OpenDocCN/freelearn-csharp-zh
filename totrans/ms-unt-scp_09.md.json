["```cs\n01 //--------------------------------------------------\n02 using UnityEngine;\n03 using System.Collections;\n04 //--------------------------------------------------\n05 public class SkyBox : MonoBehaviour \n06 {\n07 //--------------------------------------------------\n08 //Camera to follow\n09 public Camera FollowCam = null;\n10 \n11 //Rotate Speed (Degrees per second)\n12 public float RotateSpeed = 10.0f;\n13 \n14 //Transform\n15 private Transform ThisTransform = null;\n16 //--------------------------------------------------\n17 // Use this for initialization\n18 void Awake () {\n19       ThisTransform = transform;\n20 }\n21 //--------------------------------------------------\n22 // Update is called once per frame\n23 void Update () {\n24        //Update position\n25        ThisTransform.position = FollowCam.transform.position;\n26 \n27        //Update rotation\n28 ThisTransform.Rotate(new Vector3(0,RotateSpeed * Time.deltaTime,0));\n29 }\n30 //--------------------------------------------------\n31 }\n32 //--------------------------------------------------\n```", "```cs\n001 //EDITOR CLASS TO CREATE QUAD MESH WITH SPECIFIED ANCHOR\n002 //------------------------------------------------\n003 using UnityEngine;\n004 using UnityEditor;\n005 using System.IO;\n006 //------------------------------------------------\n007 //Run from unity editor\n008 public class CreateQuad : ScriptableWizard\n009 {\n010       //Anchor point for created quad\n011       public enum AnchorPoint\n012     {\n013         TopLeft,\n014         TopMiddle,\n015         TopRight,\n016         RightMiddle,\n017         BottomRight,\n018         BottomMiddle,\n019         BottomLeft,\n020         LeftMiddle,\n021         Center,\n022             Custom\n023     }\n024 \n025      //Name of Quad Asset\n026      public string MeshName = \"Quad\";\n027 \n028      //Game Object Name\n029      public string GameObjectName = \"Plane_Object\";\n030 \n031      //Name of asset folder\n032      public string AssetFolder = \"Assets\";\n033 \n034      //Width of quad in world units (pixels)\n035      public float Width = 1.0f;\n036 \n037      //Height of quad in world units (pixels)\n038      public float Height = 1.0f;\n039 \n040      //Position of Anchor\n041      public AnchorPoint Anchor = AnchorPoint.Center;\n042 \n043      //Horz Position of Anchor on Plane\n044      public float AnchorX = 0.5f;\n045 \n046     //Vert Position of Anchor on Plane\n047      public float AnchorY = 0.5f;\n048      //------------------------------------------------\n049      [MenuItem(\"GameObject/Create Other/Custom Plane\")]\n050     static void CreateWizard()\n051     {\n052         ScriptableWizard.DisplayWizard(\"Create Plane\",typeof(CreateQuad));\n053     }\n054 \n055      //------------------------------------------------\n056      //Function called when window is created\n057      void OnEnable()\n058      {\n059             //Call selection change\n060             OnSelectionChange();\n061       }\n062       //------------------------------------------------\n063       //Called 10 times per second\n064       void OnInspectorUpdate()\n065       {\n066             switch(Anchor)\n067             {\n068                   //Anchor is set to top-left\n069                   case AnchorPoint.TopLeft:\n070                         AnchorX = 0.0f * Width;\n071                         AnchorY = 1.0f * Height;\n072                   break;\n073 \n074                   //Anchor is set to top-middle\n075                   case AnchorPoint.TopMiddle:\n076                          AnchorX = 0.5f * Width;\n077                          AnchorY = 1.0f * Height;\n078                   break;\n079 \n080                   //Anchor is set to top-right\n081                   case AnchorPoint.TopRight:\n082                          AnchorX = 1.0f * Width;\n083                          AnchorY = 1.0f * Height;\n084                   break;\n085 \n086                   //Anchor is set to right-middle\n087                   case AnchorPoint.RightMiddle:\n088                         AnchorX = 1.0f * Width;\n089                         AnchorY = 0.5f * Height;\n090                   break;\n091 \n092                   //Anchor is set to Bottom-Right\n093                   case AnchorPoint.BottomRight:\n094                         AnchorX = 1.0f * Width;\n095                         AnchorY = 0.0f * Height;\n096                   break;\n097 \n098                   //Anchor is set to Bottom-Middle\n099                   case AnchorPoint.BottomMiddle:\n100                         AnchorX = 0.5f * Width;\n101                         AnchorY = 0.0f * Height;\n102                   break;\n103 \n104                   //Anchor is set to Bottom-Left\n105                   case AnchorPoint.BottomLeft:\n106                         AnchorX = 0.0f * Width;\n107                         AnchorY = 0.0f * Height;\n108                   break;\n109 \n110                   //Anchor is set to Left-Middle\n111                   case AnchorPoint.LeftMiddle:\n112                         AnchorX = 0.0f * Width;\n113                         AnchorY = 0.5f * Height;\n114                   break;\n115 \n116                   //Anchor is set to center\n117                   case AnchorPoint.Center:\n118                         AnchorX = 0.5f * Width;\n119                         AnchorY = 0.5f * Height;\n120                   break;\n121 \n122                   case AnchorPoint.Custom:\n123                   default:\n124                   break;\n125            }\n126      }\n127       //------------------------------------------------\n128       //Function called when window is updated\n129       void OnSelectionChange()\n130      {\n131             //Check user selection in editor \n132      if (Selection.objects != null && Selection.objects.Length == 1)\n133             {\n134             //Get path from selected asset\n135       AssetFolder = Path.GetDirectoryName(AssetDatabase.GetAssetPath(Selection.objects[0]));\n\n136             }\n137      }\n138      //------------------------------------------------\n139      //Function to create quad mesh\n140      void OnWizardCreate()\n141      {\n142             //Create Vertices\n143             Vector3[] Vertices = new Vector3[4];\n144 \n145             //Create UVs\n146             Vector2[] UVs = new Vector2[4];\n147 \n148             //Two triangles of quad\n149             int[] Triangles = new int[6];\n150 \n151             //Assign vertices based on pivot\n152 \n153             //Bottom-left\n154             Vertices[0].x = -AnchorX;\n155             Vertices[0].y = -AnchorY;\n156 \n157             //Bottom-right\n158             Vertices[1].x = Vertices[0].x+Width;\n159             Vertices[1].y = Vertices[0].y;\n160\n161             //Top-left\n162             Vertices[2].x = Vertices[0].x;\n163             Vertices[2].y = Vertices[0].y+Height;\n164 \n165             //Top-right\n166             Vertices[3].x = Vertices[0].x+Width;\n167             Vertices[3].y = Vertices[0].y+Height;\n168             \n169             //Assign UVs\n170             //Bottom-left\n171             UVs[0].x=0.0f;\n172             UVs[0].y=0.0f;\n173\n174             //Bottom-right\n175             UVs[1].x=1.0f;\n176             UVs[1].y=0.0f;\n177\n178             //Top-left\n179             UVs[2].x=0.0f;\n180             UVs[2].y=1.0f;\n181 \n182             //Top-right\n183             UVs[3].x=1.0f;\n184             UVs[3].y=1.0f;\n185 \n186             //Assign triangles\n187             Triangles[0]=3;\n188             Triangles[1]=1;\n189             Triangles[2]=2;\n190 \n191             Triangles[3]=2;\n192             Triangles[4]=1;\n193             Triangles[5]=0;\n194 \n195             //Generate mesh\n196             Mesh mesh = new Mesh();\n197             mesh.name = MeshName;\n198             mesh.vertices = Vertices;\n199             mesh.uv = UVs;\n200             mesh.triangles = Triangles;\n201             mesh.RecalculateNormals();\n202 \n203             //Create asset in database\n204      AssetDatabase.CreateAsset(mesh, AssetDatabase.GenerateUniqueAssetPath(AssetFolder + \"/\" + MeshName) + \".asset\");\n\n205            AssetDatabase.SaveAssets();\n206 \n207             //Create plane game object\n208             GameObject plane = new GameObject(GameObjectName);\n\n209       MeshFilter meshFilter = (MeshFilter)plane.AddComponent(typeof(MeshFilter);\n\n210             plane.AddComponent(typeof(MeshRenderer));\n211 \n212             //Assign mesh to mesh filter\n213             meshFilter.sharedMesh = mesh;\n214             mesh.RecalculateBounds();\n215 \n216             //Add a box collider component\n217             plane.AddComponent(typeof(BoxCollider));\n218      }\n219 \n220       //------------------------------------------------\n221 }\n```", "```cs\n01 //CLASS TO SCROLL TEXTURE ON PLANE. CAN BE USED FOR MOVING SKY\n02 //------------------------------------------------\n03 using UnityEngine;\n04 using System.Collections;\n05 //------------------------------------------------\n06 [RequireComponent (typeof (MeshRenderer))] \n07 public class MatScroller : MonoBehaviour\n08 {\n09 //Public variables\n10 //------------------------------------------------\n11 //Reference to Horizontal Scroll Speed\n12 public float HorizSpeed = 1.0f;\n13 \n14 //Reference to Vertical Scroll Speed\n15 public float VertSpeed = 1.0f;\n16 \n17 //Reference to Min and Max Horiz and vert\n18 public float HorizUVMin = 1.0f;\n19 public float HorizUVMax = 2.0f;\n20 \n21 public float VertUVMin = 1.0f;\n22 public float VertUVMax = 2.0f;\n23 \n24 //Private variables\n25 //------------------------------------------------\n26 //Reference to Mesh Renderer Component\n27 private MeshRenderer MeshR = null;\n28 \n29 //Methods\n30 //------------------------------------------------\n31 // Use this for initialization\n32 void Awake ()\n33 {\n34        //Get Mesh Renderer Component\n35        MeshR = GetComponent<MeshRenderer>();\n36 }\n37 //------------------------------------------------\n38 // Update is called once per frame\n39 void Update () \n40 {\n41        //Scrolls texture between min and max\n42 Vector2 Offset = new Vector2((MeshR.material.mainTextureOffset.x > HorizUVMax) ? HorizUVMin : MeshR.material.mainTextureOffset.x + Time.deltaTime * HorizSpeed,\n43 (MeshR.material.mainTextureOffset.y > VertUVMax) ? VertUVMin : MeshR.material.mainTextureOffset.y + Time.deltaTime * VertSpeed);\n\n44 \n45       //Update UV coordinates\n46       MeshR.material.mainTextureOffset = Offset;\n47 }\n48 //------------------------------------------------\n49 }\n50 //------------------------------------------------\n```", "```cs\n01 Shader \"TextureBlender\"\n02 {\n03     Properties\n04     {\n05     _Color (\"Main Color\", Color) = (1,1,1,1)\n06     _MainTex (\"Base (RGB) Trans (A)\", 2D) = \"white\" {}\n07     _BlendTex (\"Blend (RGB)\", 2D) = \"white\"\n08     }\n09     \n10     SubShader\n11     {\n12 Tags { \"Queue\"=\"Geometry-9\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"Transparent\" }\n\n13     Lighting Off\n14     LOD 200\n15     Blend SrcAlpha OneMinusSrcAlpha\n16     \n17     CGPROGRAM\n18            #pragma surface surf Lambert\n19            uniform fixed4 _Color;\n20            uniform sampler2D _MainTex;\n21            uniform sampler2D _BlendTex;\n22 \n23            struct Input \n24            {\n25              float2 uv_MainTex;\n26            };\n27 \n28            void surf (Input IN, inout SurfaceOutput o) \n29            {\n30                  fixed4 c1 = tex2D( _MainTex, IN.uv_MainTex );\n31                  fixed4 c2 = tex2D( _BlendTex, IN.uv_MainTex );\n32 \n33                  fixed4 main = c1.rgba * (1.0 - c2.a);\n34                  fixed4 blendedoutput = c2.rgba * c2.a;\n35 \n36 o.Albedo = (main.rgb + blendedoutput.rgb) * _Color;\n\n37                  o.Alpha = main.a + blendedoutput.a;\n38            }\n39     ENDCG\n40     }\n41     Fallback \"Transparent/VertexLit\"\n42 }\n```", "```cs\n001 //-----------------------------------------------------------\n002 using UnityEngine;\n003 using System.Collections;\n004 //-----------------------------------------------------------\n005 public class TexturePainter : MonoBehaviour \n006 {\n007       //Square texture with alpha\n008        public Texture2D BrushTexture = null;\n009 \n010       //Width and height of destination texture\n011       public int SurfaceTextureWidth = 512;\n012       public int SurfaceTextureHeight = 512;\n013 \n014      //Reference to painting surface texture\n015       public Texture2D SurfaceTexture = null;\n016 \n017      //Reference to material for destination texture \n018      public Material DestMat = null;\n019      //-------------------------------------------------\n020      // Use this for initialization\n021      void Start () \n022      {\n023            //Create destination texture\n024       SurfaceTexture = new Texture2D(SurfaceTextureWidth, SurfaceTextureHeight, TextureFormat.RGBA32, false);\n\n025 \n026             //Fill with black pixels (transparent; alpha=0)\n027             Color[] Pixels = SurfaceTexture.GetPixels();\n028             for(int i=0; i<Pixels.Length; i++)\n029                    Pixels[i] = new Color(0,0,0,0);\n030             SurfaceTexture.SetPixels(Pixels);\n031             SurfaceTexture.Apply();\n032 \n033            //Set as renderer main texture\n034            renderer.material.mainTexture = SurfaceTexture;\n035 \n036            //If destination material, set blend texture \n037           //Used with custom shader\n038              if(DestMat)\n039       DestMat.SetTexture(\"_BlendTex\", SurfaceTexture);\n040       }\n041       //--------------------------------------------------\n042       // Update is called once per frame\n043       void Update () \n044       {\n045            //If mouse button down, then start painting\n046            if(Input.GetMouseButtonDown(0))\n047            {\n048                   //Get hit of mouse cursor\n049                   RaycastHit hit;\n050 \n051                   //Convert screen point to ray in scene\n052      if (!Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit))\n053                          return;\n054 \n055                   //Get hit collider\n056                   Renderer renderer = hit.collider.renderer;\n057        MeshCollider Collide = hit.collider as MeshCollider;\n\n058       if (renderer == null || renderer.sharedMaterial == null || renderer.sharedMaterial.mainTexture == null || Collide == null)\n059                         return;\n060 \n061                   //Get UV Coords of hit surface\n062                   Vector2 pixelUV = hit.textureCoord;\n063       pixelUV.x *= renderer.material.mainTexture.width;\n064       pixelUV.y *= renderer.material.mainTexture.height;\n065 \n066       //Update coords to texture middle (align brush texture center to cursor)\n067                   pixelUV.x -= BrushTexture.width/2;\n068                   pixelUV.y -= BrushTexture.height/2;\n069 \n070             //Clamp pixel values between 0 and width\n071      pixelUV.x = Mathf.Clamp(pixelUV.x, 0, renderer.material.mainTexture.width);\n\n072      pixelUV.y = Mathf.Clamp(pixelUV.y, 0, renderer.material.mainTexture.height);\n073 \n074             //Paint onto destination texture\n075      PaintSourceToDestTexture(BrushTexture, renderer.material.mainTexture as Texture2D, (int)pixelUV.x, (int)pixelUV.y);\n076             }\n077      }\n078      //--------------------------------------------------\n079      //Paint source text to destination\n080      //Will paint a brush texture onto a destination texture \n081      public static void PaintSourceToDestTexture(Texture2D Source, Texture2D Dest, int Left, int Top)\n082       {\n083             //Get source pixels\n084             Color[] SourcePixels = Source.GetPixels();\n085 \n086             //Get dest pixels\n087             Color[] DestPixels = Dest.GetPixels();\n088 \n089             for(int x=0; x<Source.width; x++)\n090             {\n091                     for(int y=0; y<Source.height; y++)\n092                    {\n093                         //Get source pixel\n094      Color Pixel = GetPixelFromArray(SourcePixels, x, y, Source.width);\n\n095 \n096                          //Get offset in destination\n097                          int DestOffsetX = Left + x;\n098                          int DestOffsetY = Top + y;\n099 \n100      if(DestOffsetX < Dest.width && DestOffsetY < Dest.height)\n\n101      SetPixelInArray(DestPixels, DestOffsetX, DestOffsetY, Dest.width, Pixel, true);\n102                    }\n103            }\n104 \n105            //Update destination texture\n106            Dest.SetPixels(DestPixels);\n107            Dest.Apply();\n108      }\n109      //-------------------------------------------------------\n110       //Reads color from pixel array\n111       public static Color GetPixelFromArray(Color[] Pixels, int X, int Y, int Width)\n112       {\n113             return Pixels[X+Y*Width];\n114       }\n115       //------------------------------------------------\n116       //Sets color in pixel array\n117        public static void SetPixelInArray(Color[] Pixels, int X, int Y, int Width, Color NewColor, bool Blending=false)\n118       {\n119             if(!Blending)\n120                   Pixels[X+Y*Width] = NewColor; \n121             else\n122             {\n123      //Here we blend the color onto existing surface, preserving alpha transparency\n\n124      Color C = Pixels[X+Y*Width] * (1.0f - NewColor.a);\n\n125                   Color Blend = NewColor * NewColor.a;\n126 \n127                   Color Result = C + Blend;\n128                    float Alpha = C.a + Blend.a;\n129 \n130       Pixels[X+Y*Width] = new Color(Result.r, Result.g, Result.b, Alpha);\n\n131             }\n132      }\n133      //-------------------------------------------------\n134 }\n135 //-----------------------------------------------------------\n```"]