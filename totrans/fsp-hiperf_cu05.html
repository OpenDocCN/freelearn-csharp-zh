<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" style="font-size:1.200rem;">
<head><title>Chapter&#160;5.&#160;Advanced Concurrency Support in F#</title>
<link rel="stylesheet" href="../Styles/style0001.css" type="text/css"/>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
</head>
<body id="page">
<div class="chapter" title="Chapter&#160;5.&#160;Advanced Concurrency Support in F#"><div class="titlepage" id="aid-164MG2"><div><div><h1 class="title"><a id="ch05"></a>Chapter&#160;5.&#160;Advanced Concurrency Support in F#</h1>
</div>
</div>
</div>
<p>We now have a basic understanding of F# concurrency features, including using and implementing the best practices of F# asynchronous workflow, and combining the asynchronous workflow with .NET APM, EAP, and TAP.</p>
<p>We have seen that <code class="literal">Control.Async</code> is the basic building block of all related asynchronous workflows, in terms of using it and also carefully deciding the best practices of using a returned object, especially when we have a nice construct of Disposable pattern in the asynchronous workflow.</p>
<p>Know only that the asynchronous workflow features in F# are not unique, in that C#/VB already has them, and C#/VB's <code class="literal">async</code> construct is actually inspired by F#. We can further harness the F# advanced asynchronous workflow implementation of <code class="literal">MailboxProcessor</code>, as part of learning and leveraging the advanced concurrency support in F#.</p>
<p>Again, we will see that there are no silver bullets for all kinds of concurrency problems. We shall see this fact applies to <code class="literal">MailboxProcessor</code> usage and implementation as well.</p>
<p>This chapter describes the advanced concurrency features of F#, focusing on F# 4.0. We are also introducing an overview of best practices to implement and optimize, such as combining asynchronous and parallelism, the F# message passing agent of <code class="literal">MailboxProcessor</code>, and further interoperability with .NET TPL.</p>
<p>The introduction to concurrency in F# is covered in the following topics:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Using F# <code class="literal">MailboxProcessor</code></li>
<li class="listitem">Interoperability with .NET Task Parallel Library (TPL)</li>
<li class="listitem">Introduction to asynchronous workflows</li>
</ul>
</div>
<div class="section" title="Using F# MailboxProcessor"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec32"></a>Using F# MailboxProcessor</h1>
</div>
</div>
</div>
<p>F# has extensive features of asynchronous operations such as the way it uniquely separates and differentiates from other .NET-managed languages, such as C#/VB, Managed C++, Nemerle, IronPython, and IronRuby. But at the same time, it runs on top of .NET CLR, providing high compatibility with other languages.</p>
<p>F#'s own unique asynchronous features are not just the asynchronous workflows; it has a class that acts as a message passing agent or actor, <code class="literal">MailboxProcessor</code>. The <code class="literal">MailboxProcessor</code> feature was introduced at the same time as asynchronous workflow was released, and the implementation of <code class="literal">MailboxProcessor</code> itself is actually an implementation of a set of asynchronous workflows.</p>
<div class="section" title="Background case of having message agent"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec39"></a>Background case of having message agent</h2>
</div>
</div>
</div>
<p>The advantage of having an asynchronous model is the fact that we don't have to wait for the operation or task to be completely finished before doing something else, especially the next operations. The advantage that we don't have to wait for the completion of a task is related to the illustrations of blocking operations that we mentioned in <a class="link" title="Chapter&#160;4.&#160;Introduction to Concurrency in F#" href="fsp-hiperf_cu04.html#aid-11C3M2">Chapter 4</a>, <span class="emphasis"><em>Introduction to Concurrency in F#</em></span>.</p>
</div>
<div class="section" title="Introducing fire and forget pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec40"></a>Introducing fire and forget pattern</h2>
</div>
</div>
</div>
<p>The most common example of blocking operations is the I/O operation. This may include any network operation, including any data transfer-either incoming or outgoing. These data transfers take&#160;in many forms, ranging from a simple PING call (ICMP packets) to complex operations such as uploading files and sending emails. The operations, in most cases, are not guaranteed to have responses immediately and in many cases <span class="emphasis"><em>don't need to have replies</em></span> as well. Some of the obvious cases need responses as soon as possible since most cases have operations that need real-time responses when the operations are in session.</p>
<p>We can simply conclude that it is intuitive that asynchronous operations can be categorized further in terms&#160;of the necessity for responses:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Operations that are invoked by an external party and that don't need to have a response/reply back. In many cases, we can simply ignore the status of the completion; this is often called the <span class="emphasis"><em>fire and forget</em></span> pattern or model. Once it is fired, we can simply forget about waiting for the reply, for example, when sending emails or sending commands as messages to an external party or agents expected to execute actions based on the commands.</li>
<li class="listitem">Operations that are invoked by an external party or an internal process on your machine that needs a reply after the operations are completed, for example, when uploading files or downloading web content, the calling execution needs to be notified if the operation is completed. Another example is waiting for an elapsed event on a timer in the .NET EAP model. This is often (generally) called <span class="strong"><strong>Promises model</strong></span>, in the form of callbacks. We have already covered this in <a class="link" title="Chapter&#160;4.&#160;Introduction to Concurrency in F#" href="fsp-hiperf_cu04.html#aid-11C3M2">Chapter 4</a>, <span class="emphasis"><em>Introduction to Concurrency in F#</em></span>.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>Both of these are still categorized as asynchronous because of the simplicity of not having to wait, and it's also highly predicted to have a non-blocking behavior.</p>
<p>Examples of fire and forget pattern (from simple to complex) are as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Sending emails through SMTP.</li>
<li class="listitem">Sending network broadcast messages.</li>
<li class="listitem">Sending commands to a network printer queue server. This is different from sending a command directly to a connected network printer that has to reply, at least giving status updates of the out-of-paper status to print job completion.</li>
</ul>
</div>
<p>Not all commands sent to a printer are always fire and forget. There are many cases where sending commands to a printer, especially sending commands to a printer directly connected to our machine, are not fire and forget.</p>
<p>The operation of sending this command is usually asynchronous, with callbacks to notify the status of the finished/completed job.</p>
<p>On an OS such as Windows, sending a command to devices directly connected to our machine always requires replies or responses because it is expected that we have a response at least showing the status of the device in real time. It is normal to have this assumption as a requirement as the printer is directly connected to our machine and is also not shared. This is the reason why it is not part of fire and forget.</p>
<p>For example, on Windows, all printing operations are handled by the Windows Printing API on top of the printer's device driver. In the implementation of the Printing API, the commands sent to the printer have the requirement of the availability of any printing device installed. It does not care about how many printers are installed; it only cares about the status of any printing device available, by always querying the availability of a printing device using a Windows Message (the <code class="literal">WM_XXX</code> API) in an event of <span class="emphasis"><em>message loop</em></span>.
</p>
<div class="note" title="Note"><h3 class="title"><a id="note51"></a>Note</h3>
<p>The term <span class="emphasis"><em>message</em></span> in this message loop is different from the message in a message queue: the message is an encapsulation of a known system event to ease communication of system events. It always happens in loops and can be in the form of a looping queue (circular queue), instead of a queue in a message agent that does not operate in a loop (open ended queue).</p>
</div>
<p>For more information about the Windows message loop of Windows API, consult the MSDN Library at:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927(v=vs.85).aspx</a>
</p>
<p>It is common in Windows API to have this message loop of calling <code class="literal">GetMessage</code>, coded like this (this code is in C++):</p>
<pre class="programlisting">while(GetMessage( &amp;msg, hWnd, 0, 0) != 0) 
{  
    if (bRet == -1) 
    { 
        // handle the error and possibly exit 
    } 
    else 
    { 
        TranslateMessage(&amp;msg);  
        DispatchMessage(&amp;msg);  
    } 
} 
</pre>
<p>The preceding code will always loop by examining any incoming Windows <code class="literal">WM_XXX</code> messages. It will end the loop if there are implied errors, especially system errors. This common practice is also used in built-in Windows applets, such as the applets in the Control Panel (compiled as <code class="literal">.cpl</code>).</p>
<div class="note" title="Note"><h3 class="title"><a id="note52"></a>Note</h3>
<p>We can also implement the code of handling Win32 message loops in F#, but then, we have to hook into Win32 API calls by defining the entry point to Win32 API using P/Invoke. The P/Invoke declaration is required, but then, F# may lose HWND context if the message loop is handled within a non-UI thread. It is highly recommended to handle the Win32 message loop in a separate UI thread by explicitly executing it as invoking delegates. But interoperatibility with Win32 message API is beyond the scope of this book.</p>
</div>
<p>The queue used in this context can be a combination of an ordinary queue and the usage of round-robin, or it can be a simple queue, such as first come first served, and the incoming message is queued at the last line of the queue but the queue line itself always <span class="emphasis"><em>moves forward</em></span>.</p>
<p>
<span class="strong"><strong>Round-robin</strong></span> is one of the examples of queue handlings. But round-robin has its own overhead: it moves the pointer of the queue and also the data within the queue line. If this overhead pointer movement is executed in memory, the overhead cost might be deferred by high speed access to memory. This is why round-robin is also popular in the operating system world, from the use of the message loop to the scheduling of running processes, threads, and <span class="emphasis"><em>coroutines</em></span>.</p>
<p>The coroutine is quite common in many platforms, including .NET, Windows, and UNIX. In .NET, a sample coroutine is the yield iterator's implementation detail in C#/VB and F#. In Windows, a sample of a coroutine is the implementation of <span class="emphasis"><em>fibers</em></span> in Windows (since Windows 2000). However, fiber in Windows and coroutine in .NET are different in semantics.</p>
<p>What is coroutine? There are many definitions of coroutines but not all of them are correct in the sense of the concurrency and runtime of any managed language/platform. The cleanest and simplest definition is available from the MSDN Library. Coroutine is defined as:</p>
<div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em>Coroutine is a method that can stop in mid-execution and provide a value to the caller without returning program flow.</em></span>
</p>
</blockquote>
</div>
<p>This definition is taken from this MSDN Magazine on the MSDN Library:</p>
<p>
<a class="ulink" href="http://download.microsoft.com/download/3/a/7/3a7fa450-1f33-41f7-9e6d-3aa95b5a6aea/MSDNMagazineSeptember2003en-us.chm">http://download.microsoft.com/download/3/a/7/3a7fa450-1f33-41f7-9e6d-3aa95b5a6aea/MSDNMagazineSeptember2003en-us.chm</a>
</p>
<p>It is quite the same as yield, where yield can stop in the middle of the execution and will continue as needed. C#/VB/F# yield and Windows fibers are very good sample implementations of coroutine that can have multiple entries and exits, depending on the state we are handling.</p>
<p>For more information about fiber in Windows API, visit:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms682661(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms682661(v=vs.85).aspx</a>
</p>
<div class="note" title="Note"><h3 class="title"><a id="note53"></a>Note</h3>
<p>NOTE: We are not going to dive further into the implementation detail of coroutine in .NET, especially on yield. The implementation detail of the yield iterator may change in the future .NET versions after .NET 4.6. However, it is important to at least have a basic understanding of coroutine.</p>
</div>
<p>A simple evidence of this message loop in action, always querying printing devices, can be seen in how Windows displays the current status of a print job in the Print Management applet in Windows 8/8.1 and Windows 10.</p>
<p>The Print Management applet in the legacy Control Panel always displays the current status of any available installed and connected printers:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00293.jpeg" alt="Introducing fire and forget pattern"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>The Printing API is also a good sample of Promises in action because a reply to notify that a print job is completed; it is a promise to at least give response that a print job is either completed or failed.</p>
<p>Other samples of Promises are the same as those of TPL, .NET EAP and APM. Basically, the semantics are mostly in the form of a notification when the action is completed.</p>
<p>There is a mixture of the f<span class="emphasis"><em>ire and forget</em></span> model and the <span class="emphasis"><em>Promises</em></span> model, although the promise in this mix may not be a true promise in the implementation details.</p>
<p>For example, we want to have an asynchronous way of processing any of the incoming transactions against savings accounts, and the transactions are expected to have commenced across many kinds of savings accounts. Even in the same bank, a person can have multiple accounts that may have traffic of incoming and outgoing transfers, either scheduled or manual.
</p>
<p>It is optional to notify that the incoming transfer is successfully credited to the account. And this is also a promise, although it is not mandatory to be enforced to notify back a successful transaction. If it is mandatory, then a reply will be sent back later. But this reply can be made using an event triggered when the incoming transfer has been calculated as credited into the account. At the implementation detail, the notification on the receiving agent is not mandatory after all; the customization may be added as an event trigger.</p>
<p>In the case of online e-commerce, the response is mandatory, as the transactions of any purchase must have a reply immediately, as close to real time as possible. Then the promise is enforced, although it is not a pure promise after all, as the receiver is using an event trigger for any incoming successful transaction that it will send a notification back to inform a failed/successful transaction. The wait for any incoming transaction is continuous. It is similar to always listening to any incoming signal of an incoming operation. Therefore it is also often simply called a <span class="emphasis"><em>listener</em></span>, to always listen for any incoming transactions.</p>
<p>This difference of having a promise is illustrated in the following simplified flow:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00294.jpeg" alt="Introducing fire and forget pattern"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>In the previous illustration, the wait for an incoming transaction usually happens on an agent. In the case of a standalone message queue manager, it is also a sophisticated or standalone listener.</p>
<p>This is also a good sample of an agent to handle the transaction in the form of messages that contain the operation request to withdraw, transfer, or even receive a money transfer.</p>
<p>Consider this sample scenario of this agent:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">A data wrapper with the necessary information about the operations (any related bank account transactions) to be carried out that is then processed by a centralized process that is to be sent while waiting for any incoming data to be consumed. Usually, all of the data sent and received is stored and processed with first come first served or <span class="strong"><strong>first in first out</strong></span> (<span class="strong"><strong>FIFO</strong></span>) in a data structure: a queue.</li>
<li class="listitem">The agent must be as scalable as possible. It means it must be able to serve a large number of requests per second. The initial website is usually assumed to be able to serve 500 to 1,000 requests per second, so the initial projected maximum requests to be served is 1,000 requests.</li>
</ul>
</div>
<p>In the preceding scenario, why does it have to be a queue?</p>
<p>The agent was initially planned to serve more than 1,000+ requests at a time. There is no guarantee that the web server can serve more than 1,000 requests&#160;<span class="emphasis"><em>at a time and at the same time</em></span>. In order to do this precisely, we have to be sure that at least 1,000 requests are sent and received at the same time. This means we must have parallel I/O at the heart of the hardware side, which is very expensive and very difficult to implement and set up. Therefore, having parallel I/O to enforce this simulation is not quite scalable for the current needs, and it's also not quite feasible in terms of implementation speed (time to implement) and scalability.</p>
<p>If we are relying on the scalability of the available I/O throughput, this is not an option because pure hardware scalability has more initial expensive costs. If we rely on serving the requests optimally by increasing the number of CPU cores, this is also not an optimal solution. Web requests usually consume less on CPU and more on network (hence I/O) bandwidth. On the consumer of the requests, there can be a wait on the I/O side, and this can block the next request to be processed, although handling this can be optimized using the asynchronous workflow that we described in <a class="link" title="Chapter&#160;4.&#160;Introduction to Concurrency in F#" href="fsp-hiperf_cu04.html#aid-11C3M2">Chapter 4</a>, <span class="emphasis"><em>Introduction to Concurrency in F#</em></span>.</p>
<p>The number of requests to be processed must be processed as first come first served. This fits into the FIFO model, and the best data structure to handle this is queue. The use of queues will always ensure that the first request is always to be processed first and then there are some actions processed afterwards.</p>
<p>The process of inserting new data is called <span class="emphasis"><em>enqueue</em></span>, while removing the first item of the data is called <span class="emphasis"><em>dequeue</em></span>.</p>
<p>The following is an illustration of the incoming of requests and processing in a queue:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00295.jpeg" alt="Introducing fire and forget pattern"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>The queue of requests is usually seen as a block of data to be sent and received, and this is often called as message, because of the conceptual similarity to sending and receiving emails.</p>
<p>The one software component that is responsible for managing incoming requests as queue and sending replies when needed is usually called a message queue manager. From F# perspective, it is called a message agent, or in MSDN terms, it is often simply called an agent. It is also called an <span class="emphasis"><em>actor</em></span>, and this actor model is discussed in the next section.</p>
</div>
<div class="section" title="Overview of a message agent"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec41"></a>Overview of a message agent</h2>
</div>
</div>
</div>
<p>This agent/ manager handles every message that is sent from senders (also called <span class="emphasis"><em>producers</em></span>) and receives each message, which is then processed. The receivers can be from one to many receivers.</p>
<p>The overall main focuses in terms of the agent's operations are on:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Sending a message (including preparations before and after). Sending is simply a sending from message agent A to message agent B.</li>
<li class="listitem">Receiving a message (including storing, processing). Message agent B receives messages from message agent A.</li>
</ul>
</div>
<p>The following illustration depicts&#160;the sending of the message with the queue processing:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00296.jpeg" alt="Overview of a message agent"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>The sending and receiving operations are handled in a different context, but both sending and receiving use queues.</p>
<p>When a message agent is sending a message, these are the activities performed:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A queue is allocated. The main allocation to be considered is the available memory, then the physical storage.</li>
<li class="listitem">The message to be sent is prepared with&#160;this convention first: the format of each message must have the same format, so the message will be processed in a predictable manner.</li>
<li class="listitem">The message to be processed before sending usually comes in many forms. In the case of F# or any other lightweight agent, the message can be in the form of any object.</li>
<li class="listitem">The object is then serialized as raw strings.</li>
<li class="listitem">Serialization of the objects is then to be wrapped in a certain format. For example, the message can have headers and footers with additional information on how to process the message further.</li>
<li class="listitem">The end result of the wrapped message is ready to be sent. At this time, any additional checks may be run, such as checking the availability of the network.</li>
<li class="listitem">The agent sends the message. The transfer protocol used by the agent is the same protocol as the receiver.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>The receiving side is illustrated as shown:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00297.jpeg" alt="Overview of a message agent"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>As illustrated, a queue on the agent that receives the messages is needed because:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The incoming messages may come in close intervals; therefore, a minimum waiting time or minimal latency is expected. Also, incoming messages need to be stored before being processed, and the order of receiving is very important, as implied by FIFO.</li>
<li class="listitem">The queue can be optimized further by processing it in memory as needed, and as much as possible, as long as it matches the available memory allocation with respect to the maximum available memory of the running agent. For example, a machine with 32 GB of RAM will of course process the queue more efficiently than a machine with 16 GB of RAM.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>By default, a queue is stored on heap but using a predefined size; therefore, there is minimal overhead in accessing a queue on heap. This is also the same for the queue when it comes to&#160;sending messages as well.</p>
<p>These are the activities that happen when receiving a message:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A queue is allocated. This step is actually the same as step 1 in the sending message previously.</li>
<li class="listitem">The incoming message is checked for deserialization problems according to the agreed format from message agent A. This validation is necessary because there is no guarantee that all incoming messages are valid. This is the first difference in handling messages between sending and receiving.</li>
<li class="listitem">The receiving messages are not guaranteed to always arrive in the same sequence as they were sent. For example, it is not guaranteed that the first message sent will be received first. It is quite normal/common for the order of the message sent not to be the same as the message received. This is the second of the differences between sending and receiving messages.</li>
<li class="listitem">A valid incoming message is enqueued. The first incoming message will be processed first. This first incoming message might not be the first message sent.</li>
<li class="listitem">When it is ready to be dequeued (after a certain wait for the previous incoming message to be dequeued), the message content is waiting to be deserialized further.</li>
<li class="listitem">The content of the message is deserialized from <code class="literal">String</code> to an object, and can be processed further as resulting data.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<div class="note" title="Note"><h3 class="title"><a id="note54"></a>Note</h3>
<p>It is up to the implementer to further process the queue to be ordered by certain conditions before being dequeued and this may vary. This can be the subject of evidence of being falsely treated as synchronous because the ordering of the queue will yield some process overhead and the consumer of the message will have to wait. The handling of received messages may vary in a sense that the queues may have raw FIFO without considering the order of the time the message was sent or will try to process the received messages in time order as long as it is guaranteed to proceed using certain configurations. However, using this sequence of enforcing the order of the message received by the time they were sent will defeat the nature of the message queue agent since the message received will be forced to wait for the earlier messages to arrive.</p>
</div>
<p>This is not the same as the era of the legacy modem as the full connection on both sides is required to ensure continuous synchronous communication. If a message agent is supposed to have full real-time processing while always waiting for the result immediately, then a message agent will always be forced to wait indefinitely for incoming replies, and this will defeat the main purpose of a message agent itself: processing message asynchronously. Anything waitable, concerns (usually processes) is mostly blocking, and if the waiting is executed explicitly, then it will block the next operation or process to be executed.</p>
<div class="note" title="Note"><h3 class="title"><a id="note55"></a>Note</h3>
<p>The synchronous operations on a modem are not related to how the communication channels the transfer, either half duplex or full duplex. Many of us are mixing synchronous with half duplex/full duplex, and it is wrong. These concepts are not related at all.</p>
</div>
<p>The receiving of the message handling can also use a temporary storage to hold received messages if necessary. This is crucial if each message may contain certain operations or instructions to be processed heavily, for example, instructions to calculate the current positions of a pricing forecast.</p>
<p>The handling of the messages to be sent is processed in queues, the first message to be sent being processed first. This is the same as handling the received messages where the first message received is processed first. One of the important factors in handling the messages is <span class="strong"><strong>serialization</strong></span>. There might be overhead on the serialization and deserialization of the object in the message.</p>
<div class="section" title="Overview of serialization"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec4"></a>Overview of serialization</h3>
</div>
</div>
</div>
<p>Serialization and deserialization are often described as simply serialization. It is defined as how an object is flattened to a string of properties and values and the reverse: the construction of an object from a string of properties and values. The serialization part is actually an operation of flattening an object (or class in the type system), which is also called deconstruction of an object because the semantics of an object are translated into a string that describes the class, property, and values. The value of the properties must be serialized successfully too because we have to be able to deserialize back into the original object representation without changing the semantic value.</p>
<p>Serialization and deserialization are illustrated (simplified) in the following image:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00298.jpeg" alt="Overview of serialization"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>The simplest example of a working serialization is available in how we create our own custom serialization to translate an object's properties and its value's implementation using a basic override of the <code class="literal">ToString</code> method, which is available in <code class="literal">System.Object</code>. This <code class="literal">System.Object</code> class is inherited by all classes in .NET because <code class="literal">System.Object</code> is the parent object of all types in .NET. We can override the <code class="literal">ToString()</code> method to represent the content of the class.</p>
<p>For example, we have a <code class="literal">Person</code> class, defined as follows:</p>
<pre class="programlisting">open System 
open System.Text 
 
type Person() = 
    member val Name: String = "" with get, set 
    member val Address: String = "" with get, set 
    member val IsMarried = false with get, set 
    override this.ToString() =  
        let mutable sb = new StringBuilder() 
        sb &lt;- sb.Append("Person{").Append(this.Name).Append("|").Append(this.Address).Append("|") 
        sb &lt;- sb.Append(this.IsMarried).Append("}") 
        sb.ToString() 
 
</pre>
<p>The following are the explanations for the preceding code:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">Person</code> class overrides the <code class="literal">ToString()</code> method with the necessary <code class="literal">StringBuilder.Append</code> operations to construct a string representation of <code class="literal">Person</code>.</li>
<li class="listitem">The <code class="literal">StringBuilder</code> of <code class="literal">sb</code> is used as mutable because it is fine to have mutability in a locally scoped function/method because this symbol is not used outside the scope of the function and the side effect is still transparent. The property values are separated with <code class="literal">|</code>.</li>
<li class="listitem">The code uses the <code class="literal">val</code> keyword in the property member declaration because the property is using the auto setter and getter.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>A semantic description of the auto properties of setter-getter syntaxes for F# is beyond the scope of this book. For more information on the auto properties of F#, consult this MSDN Library page:</p>
<p>
<a class="ulink" href="https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/properties">https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/properties</a>
</p>
<div class="note" title="Note"><h3 class="title"><a id="note56"></a>Note</h3>
<p>The semantics of F# auto properties (auto setter and getter with backing fields automatically generated by compiler) are same as C#/VB auto properties. Only the internal naming of the backing properties has different implementation details, but this should not be our concern at all since we do not care about the backing field.</p>
</div>
<p>We then add the code to display the serialization representation:</p>
<pre class="programlisting">[&lt;EntryPoint&gt;] 
let main argv =  
    let anyPerson1 = new Person(Name = "John Doe", Address="Baker Street", IsMarried = false) 
    let anyPerson2 = new Person(Name="Jane Doe", Address ="Arlington Street", IsMarried = true) 
    Console.WriteLine(anyPerson1.ToString())  
    Console.WriteLine(anyPerson2.ToString()) 
</pre>
<p>Let's run the code, and we will see that it will display the output:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00299.jpeg" alt="Overview of serialization"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>The cost of serialization is usually cheaper than deserialization, as it tries to flatten the object (the attributes or properties of the object) into strings that define the property name and the values. The property value is then converted to <code class="literal">String</code> by implicitly or explicitly calling the <code class="literal">ToString()</code> method. This is actually a simplified sample that we can also write our own serializer to further optimize or to fully streamline the process.</p>
<p>Deserialization is more expensive because it tries to construct a type based on the string value, because we must maintain the semantics of the properties and the properties values from the serialized <code class="literal">String</code>.</p>
<p>The following is a simplified sample of deserialization (add this code below the <code class="literal">Person</code> type declaration):</p>
<pre class="programlisting">    static member Deserialize (serializedString:String) = 
        let mutable deserializedPerson = new Person() 
        let mutable strippedString = serializedString.Substring(7) 
        strippedString &lt;- strippedString.Substring(0,strippedString.Length-1) 
        let splitString = strippedString.Split([| "|" |], StringSplitOptions.None) 
        deserializedPerson.Name &lt;- splitString.[0] 
        deserializedPerson.Address &lt;- splitString.[1] 
        deserializedPerson.IsMarried &lt;- Boolean.Parse(splitString.[2]) 
        deserializedPerson 
</pre>
<p>To test this function, we now modify the <code class="literal">EntryPoint</code> code to test <code class="literal">Deserialize</code>:</p>
<pre class="programlisting">[&lt;EntryPoint&gt;] 
let main argv =  
    let anyPerson1 = new Person(Name = "John Doe", Address="Baker Street", IsMarried = false) 
    let anyPerson2 = new Person(Name="Jane Doe", Address ="Arlington Street", IsMarried = true) 
    Console.WriteLine(anyPerson1.ToString())  
    Console.WriteLine(anyPerson2.ToString()) 
    <span class="strong"><strong>let anyperson3 = Person.Deserialize(anyPerson1.ToString())</strong></span> 
    Console.WriteLine(anyperson3.ToString()) 
    0 // return an integer exit code 
</pre>
<p>We mark <code class="literal">Deserialize</code> as <code class="literal">static</code> because the main intention is to deserialize, not depend on the object that does the deserialization. We can test this deserialization by calling <code class="literal">Deserialize</code> with the existing serialized <code class="literal">ToString()</code> result with its parameter as demonstrated.</p>
<p>The following is the display output of the result of <code class="literal">anyperson3.ToString()</code> combined with the previous <code class="literal">anyPerson1</code> and <code class="literal">anyPerson2</code>:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00300.jpeg" alt="Overview of serialization"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>The resulting display output now has proven that we have successfully constructed the object from the serialized <code class="literal">String</code> by checking the same value of <code class="literal">anyPerson1</code> with <code class="literal">anyperson3</code>. This sample is too simple for this demonstration, but it truly demonstrates that there are certain requirements that have to be met before having successful deserializations.</p>
<p>These are the mandatory requirements for successful deserializations:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The serialized format must be agreed upon and must have the same structure format as the serializer. In terms of implementation, the type of serialization object must be the same type.</li>
<li class="listitem">The serialization and deserialization must have&#160;as simple type as possible; otherwise, complex serialization and deserialization will occur. For example, serializing the object that implements the COM object, whereas implicit marshalling will always occur and crossing the thread boundary across <span class="emphasis"><em>STA</em></span> and <span class="emphasis"><em>MTA</em></span> threads will always yield unpredictable results, often yielding errors not in the form of a thrown exception.</li>
<li class="listitem">The serialization of an object has to be a concrete object (a class); otherwise, an overhead of type check casting will occur. For example, serializing an interface is not recommended as the deserialization will always try to create an instance of a concrete class, and a runtime error will occur.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>In common/daily practice, it is recommended to use an existing serializer with an already commonly-used format such as JSON, for example, <code class="literal">DataContractJsonSerializer</code> in the WCF class libraries, under the namespace of <code class="literal">System.Runtime.Serialization.Json</code>, and the commonly used third party serializer, NewtonSoft JSON serializer.</p>
</div>
</div>
<div class="section" title="Introduction to F# MailboxProcessor"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec42"></a>Introduction to F# MailboxProcessor</h2>
</div>
</div>
</div>
<p>Now, we have the basic knowledge of what a message agent is, and we have also highlighted how this agent operates as to how it sends and receive messages. It is time to find out more about the F# message agent, F# <code class="literal">MailboxProcessor</code>. For the rest of this book, we will simply use <code class="literal">MailboxProcessor</code> as a class and as an agent.</p>
<p>The&#160;<code class="literal">MailboxProcessor</code> is actor based. It may have multiple threads spawned or just a single thread. In a sense it is an actor because as an actor, it can have its own role. In their implementation detail, the actors can act on their own without depending on other actors (although they might have the same responsibilities or same behaviors). Actors can be implemented to have the same responsibilities, such as an actor/agent to process incoming requests or to process sending requests.</p>
<p>The writer of <code class="literal">MailboxProcessor</code> can also be seen as a producer while the reader can be seen as a consumer.</p>
<p>The lightweight aspects of <code class="literal">MailboxProcessor</code> are unique. It is not just lightweight in terms of being standalone and built-in to the core F#, but also:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">It is quite easy to start using it because it operates without dependency on how the underlying operating system does asynchronous operations.</li>
<li class="listitem">It will not store the messages, so they are not persistent</li>
<li class="listitem">It can be further combined with F# asynchronous workflow</li>
<li class="listitem">It does not have an advanced infrastructure that has many configurable environment settings such as IBM Websphere MQ and MSMQ</li>
</ul>
</div>
<p>Other than those unique traits, the concept of F# <code class="literal">MailboxProcessor</code> queue agent is similar to famous message queue manager software such as IBM Websphere MQ (formerly IBM MQ Series) and Microsoft MQ (also called MSMQ). It is used to handle asynchronous message transfers.</p>
<p>For more information about IBM Websphere MQ, visit:</p>
<p>
<a class="ulink" href="http://www-03.ibm.com/software/products/en/ibm-mq">http://www-03.ibm.com/software/products/en/ibm-mq</a>
</p>
<p>For more information about MSMQ, visit:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx</a>
</p>
<p>F# <code class="literal">MailboxProcessor</code> as agent is not completely standalone (not external) because <code class="literal">MailboxProcessor</code> is part of F# core libraries, so we can use and leverage it quickly instead of having an assessment and installation setup activities before using it.</p>
<p>The disadvantages are:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">If many messages are sent or received, we must implement our own storage to store them. This means we maintain our own storage of a queue of messages as, by default, <code class="literal">MailboxProcessor</code> messages are not persistent.</li>
<li class="listitem">We must manage how we further optimize the queue operations as <code class="literal">MailboxProcessor</code>, by default, relies on operating at runtime with no offline storage feature to hold the queues.</li>
<li class="listitem">If the order of prioritization is critical, we cannot further customize how <code class="literal">MailboxProcessor</code> is going to use the thread affinity of the underlying machine on Windows because there is no way to do this. This is intentional, as the lightweight of <code class="literal">MailboxProcessor</code> always hides the implementation details of the synchronization of prioritization on the thread executions.</li>
</ul>
</div>
<p>In the realm of F#, <code class="literal">MailboxProcessor</code> has the ability to write messages to send (<span class="emphasis"><em>writer</em></span>) and to read incoming messages (<span class="emphasis"><em>reader</em></span>).</p>
<p>The writer-reader model is often mentioned in the MSDN Library on the MSDN landing page of <code class="literal">Control.MailboxProcessor</code>:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.mailboxprocessor%5b%27msg%5d-class-%5bfsharp%5d">https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.mailboxprocessor%5b%27msg%5d-class-%5bfsharp%5d</a>
</p>
<p>This reader-writer model shows that <code class="literal">MailboxProcessor</code> only focuses as an agent on writing a message and then sending it, and reading incoming messages. It may focus on one responsibility to only send, receive, or both.</p>
<p>If we set <code class="literal">MailboxProcessor</code> to have both send and receive, the sending and receiving processes cannot both be guaranteed to be at the same time.</p>
<p>Let's look at a simplified sample of <code class="literal">MailboxProcessor</code> by constructing and simulating an email message. The sample code in the landing page of F# <code class="literal">Control.MailboxProcessor</code> is actually a script file instead of a common code file because we need to evaluate and test the result immediately, a good practice for REPL interactive of F# interactive:</p>
<pre class="programlisting">open System 
open Microsoft.FSharp.Control 
 
type EmailMessage() = 
    member val From : String = "" with get, set 
    member val To : String = "" with get, set 
    member val Cc : String = "" with get, set 
    member val DateSent : DateTime = (DateTime.Now) with get 
    member val Subject : String = "" with get, set 
    member val Content : String = "" with get, set 
 
let mailbox = new MailboxProcessor&lt;EmailMessage&gt;(fun mailprocess -&gt; 
    let rec loop = 
        async { printfn "Incoming message!"  
                let! msg = mailprocess.Receive() 
                printfn "Message received. \r\nFrom: %s, \r\nDate received: %s" msg.From (msg.DateSent.ToString()) 
                printfn "Subject: %s" msg.Subject 
                printfn "Content: \r\n %s" msg.Content 
                return! loop } 
    loop)  
 
</pre>
<p>Start evaluating the previous code by pressing <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>Enter</em></span>.</p>
<p>The F# Interactive will evaluate the code sequentially, and this is the walkthrough of the semantics:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">System</code> namespace and <code class="literal">Microsoft.Fsharp.Control</code>. The <code class="literal">Microsoft.FSharp.Control</code> namespace is needed for <code class="literal">MailboxProcessor</code>. We are using <code class="literal">System</code> namespace because we are going to use <code class="literal">Console</code> to display the output later.</li>
<li class="listitem">We create <code class="literal">EmailMessage</code> type to wrap the message we are going to use. The message is simple as it contains the sender (<code class="literal">From</code>), the destination, the optional CC, subject, and the content of the message. The properties are initialized in the default constructor.</li>
<li class="listitem">All of the properties use the explicit type declaration for more clarity.</li>
<li class="listitem">The mailbox symbol is inferred as a <code class="literal">MailboxProcessor</code> instance with the parameterized type of <code class="literal">EmailMessage</code> as the message type.</li>
<li class="listitem">The constructor of <code class="literal">MailboxProcessor</code> is a lambda that contains the loop of receiving messages.</li>
<li class="listitem">This lambda contains a recursive function of loop, and it uses <code class="literal">return!</code> to signify that the returning call of loop is within the asynchronous workflow boundary. In the implementation details, <code class="literal">return!</code> is further translated to calls to <code class="literal">AsyncBuilder.Return</code>.</li>
<li class="listitem">Received messages are handled by asynchronously getting results by calling the type inferred by the parameter of the lambda, <code class="literal">inbox</code>. <code class="literal">inbox</code> is actually typed as <code class="literal">MailboxProcessor&lt;Message&gt;</code>.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>The use of <code class="literal">return!</code> is crucial because the nature of the recursive function of a loop is contained inside an asynchronous workflow. If we use only <code class="literal">return</code> instead of <code class="literal">return!</code>, it will leak the call state outside the boundary of the <code class="literal">async</code> construct, which can then yield memory leaks in crossing the context. This <code class="literal">return!</code> is translated into calls to one of the F# asynchronous workflow builders, <code class="literal">AsyncBuilder.Return</code>, before it actually returns the call of <code class="literal">loop</code>.</p>
<p>The internal implementation detail is available in the IL. Compile and start ILDASM, then if we open the compiled exe, we can examine the generated classes of loop. In one of the loops, we shall see it calls the <code class="literal">FSharp.Control.FSharpAsyncBuilder.Return</code>:</p>
<pre class="programlisting">    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1&lt;class [FSharp.Core]Microsoft.FSharp.Core.Unit&gt;  
            Invoke(class [FSharp.Core]Microsoft.FSharp.Core.Unit _arg2) cil managed 
    // SIG: 20 01 15 12 29 01 12 0D 12 0D 
    { 
      // Method begins at RVA 0x3450 
      // Code size       16 (0x10) 
      .maxstack  8 
      IL_0000:  /* 00   |                  */ nop 
      IL_0001:  /* 03   |                  */ ldarg.1 
      IL_0002:  /* 26   |                  */ pop 
      IL_0003:  /* 02   |                  */ ldarg.0 
      IL_0004:  /* 7B   | (04)00002E       */ ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder MailboxSample/'Loop@81-16'::builder@ 
      IL_0009:  /* 14   |                  */ ldnull 
      <span class="strong"><strong>IL_000a:  /* 6F   | (2B)00000A       */ callvirt   instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1&lt;!!0&gt;</strong></span> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::Return&lt;class [FSharp.Core]Microsoft.FSharp.Core.Unit&gt;(!!0) 
      IL_000f:  /* 2A   |                  */ ret 
    } // end of method 'Loop@81-16'::Invoke 
  } // end of class 'Loop@81-16' 
 
</pre>
<p>It has the <code class="literal">FSharpAsyncBuilder.Return</code> call before it actually returns to outside scope.</p>
<div class="note" title="Note"><h3 class="title"><a id="note57"></a>Note</h3>
<p>All of the F# <code class="literal">AsyncBuilder</code> is compiled under the name of <code class="literal">FSharpAsyncBuilder</code>. This is also reflected in the generated IL.</p>
</div>
<p>Then, let's see&#160;<code class="literal">MailboxProcessor</code> in action:</p>
<pre class="programlisting">let email1 = new EmailMessage ( From = "john@somemail.com", To = "clark@somemail.com", Subject = "Introduction", Content = "Hello there!") 
let email2 = new EmailMessage ( From = "janet@somemail.com", To = "abby@somemail.com", Subject = "Friendly reminder", Content = "Please send me the report today. Thanks!\r\nRegards,\r\nJanet") 
mailbox.Start() 
mailbox.Post(email1) 
mailbox.Post(email2)  
</pre>
<p>This is the output of the previous code:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00301.jpeg" alt="Introduction to F# MailboxProcessor"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>Let's dive further into the code:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The mailbox symbol is in fact an instance of <code class="literal">MailboxProcessor</code> with a default constructor of one parameter and the body of the message typed as <code class="literal">Message</code>.</li>
<li class="listitem">After we have the <code class="literal">MailboxProcessor</code> instance, we can begin to initialize the mailbox as an agent by calling the <code class="literal">Start()</code> method.</li>
<li class="listitem">We can then send messages by calling <code class="literal">Post()</code> with the message as the parameter; each call of the <code class="literal">Post()</code> method is guaranteed to be asynchronous.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>From the perspective of <code class="literal">MailboxProcessor</code>, the writer operation is represented by calling <code class="literal">Post()</code>, and this is also the sending operation; the reader is represented by calling <code class="literal">Receive()</code>, and this is also the receiving operation.</p>
<p>This is why the type name starts with <span class="emphasis"><em>Mailbox</em></span> because it is quite similar to the mailbox as a starting container to send and receive letters that contain messages in everyday life.</p>
<p>Now let's dive into <code class="literal">MailboxProcessor</code> features.
</p>
<div class="section" title="Overview of MailboxProcesor features"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec5"></a>Overview of MailboxProcesor features</h3>
</div>
</div>
</div>
<p>
<code class="literal">MailboxProcessor</code> has two constructors, the simplest constructor being the one that takes one parameter of delegate. The second one takes two parameters: a delegate and a <code class="literal">CancellationToken</code> object.</p>
<p>The following are the syntaxes of the constructors:</p>
<pre class="programlisting">// Signature: 
new MailboxProcessor : (MailboxProcessor&lt;'Msg&gt; -&gt; Async&lt;unit&gt;) * ?CancellationToken -&gt; MailboxProcessor&lt;'Msg&gt; 
 
// Usage: 
new MailboxProcessor (body) 
new MailboxProcessor (body, cancellationToken = cancellationToken) 
 
</pre>
<p>In the previous sample, we called the constructor with a delegate. This delegate is the main entry of the read loop when <code class="literal">MailboxProcessor</code> starts (as initialized by calling the <code class="literal">Start()</code> method).</p>
<p>Not all of the operations in <code class="literal">MailboxProcessor</code> are useful for all cases; that depends on the usage and the detail of the asynchronous operations we want to use. In fact, similar to the other message agents, <code class="literal">MailboxProcessor</code> does not guarantee that the sequence of the received messages will always be the same as the sequence of sent messages.</p>
<p>The following are the interesting functions/methods of <code class="literal">MailboxProcessor</code>:</p>
<div class="informaltable"><table border="1"><colgroup><col/>
<col/>
</colgroup>
<tbody><tr><td>
<p>
<span class="strong"><strong>Function</strong></span>
</p>
</td>
<td>
<p>
<span class="strong"><strong>Quick Remark</strong></span>
</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">Post</code>
</p>
</td>
<td>
<p>Posts a message to the message queue of <code class="literal">MailboxProcessor</code> asynchronously. Should not be mixed with non-F# <code class="literal">async</code> such as C#/VB <code class="literal">async</code>. The posting of a message does not mandate <code class="literal">MailboxProcessor</code> to return any success/failure status of the posting action.</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">PostAndAsyncReply</code>
</p>
</td>
<td>
<p>Posts a message to an agent and awaits a reply on the channel, asynchronously. Should not be confused with non-F# <code class="literal">async</code> such as C#/VB <code class="literal">async</code>. It requires us to always handle the reply of the message.</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">PostAndReply</code>
</p>
</td>
<td>
<p>Posts a message to an agent and awaits a reply on the channel, synchronously. The sending of the message is still asynchronous. Should not be mixed with non F# <code class="literal">async</code> such as C#/VB <code class="literal">async</code>. It requires us to always handle the reply of the message.</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">PostAndTryAsyncReply</code>
</p>
</td>
<td>
<p>Similar to <code class="literal">PostAndAsyncReply</code> but returns <code class="literal">None</code> if there is no reply within the timeout period. Should not be mixed with non-F# <code class="literal">async</code> such as C#/VB <code class="literal">async</code>. It requires us to always handle the reply of the message.</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">Receive</code>
</p>
</td>
<td>
<p>
</p>
<p>Waits for a message. This will consume the first message in the arrival order. Should not be mixed with non-F# <code class="literal">async</code> such as C#/VB <code class="literal">async</code>.</p>
<p>
</p>
<p>This <code class="literal">Receive</code> action has the same type of object as defined by the sending action.</p>
<p>
</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">Scan</code>
</p>
</td>
<td>
<p>
</p>
<p>Scans for a message by looking through messages in arrival order until the scanner returns a <code class="literal">Some</code> value. Other messages remain in the queue.</p>
<p>
</p>
<p>This scanning action will mostly block the message replies of <code class="literal">Receive</code> and <code class="literal">TryReceive</code>.</p>
<p>
</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">Start</code>
</p>
</td>
<td>
<p>Starts the agent. The start of the agent may be included within a parallel loop, such as <code class="literal">Parallel.For</code> or <code class="literal">Parallel.ForEach</code>.</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">TryPostAndReply</code>
</p>
</td>
<td>
<p>Similar to <code class="literal">PostAndReply</code> but returns <code class="literal">None</code> if there is no reply within the timeout period. Should not be mixed with non-F# <code class="literal">async</code> such as C#/VB <code class="literal">async</code>.</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">TryReceive</code>
</p>
</td>
<td>
<p>
</p>
<p>Waits for a message. This will consume the first message in the arrival order. It also enforces synchronicity instead of receiving asynchronously. Returns <code class="literal">false</code> if the receiving message fails. Should not be mixed with non-F# <code class="literal">async</code> such as C#/VB <code class="literal">async</code>.</p>
<p>
</p>
<p>The <code class="literal">Receive</code> action has the same type of object as defined by the sending action</p>
<p>
</p>
</td>
</tr>
<tr><td>
<p>
<code class="literal">TryScan</code>
</p>
</td>
<td>
<p>Scans for a message by looking through the messages in the arrival order until scanner returns a <code class="literal">Some</code> value. Other messages remain in the queue. The queue is only stored in memory.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>In the previous table, all of the standard posts and replies, such as <code class="literal">Post</code>, <code class="literal">PostAndReply</code>, and <code class="literal">PostAndAsyncReply</code>, should not be used within the C#/VB <code class="literal">async</code> construct. The post and reply operations implemented in F# have their own thread synchronizer. This F# synchronizer often has unpredictable results when used within C#/VB <code class="literal">async</code> construct; mixing this different asynchronous model will make the F# synchronizer have race condition when switching back and forth between different execution contexts.</p>
</div>
<div class="section" title="Further implementations of MailboxProcessor"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec6"></a>Further implementations of MailboxProcessor</h3>
</div>
</div>
</div>
<p>Based on the previous table, <code class="literal">MailboxProcesor</code> can also send messages and wait for replies, not just send (post) messages. The following operations that do the sending and waiting for reply immediately after sending:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">PostAndAsyncReply</code></li>
<li class="listitem"><code class="literal">PostAndReply</code></li>
<li class="listitem"><code class="literal">PostAndTryAsyncReply</code></li>
<li class="listitem"><code class="literal">TryPostAndReply</code></li>
</ul>
</div>
<p>All these send and receive operations require a handle in F#. It is called <code class="literal">AsyncReplyChannel</code>, contained in the <code class="literal">Control.AsyncReplyChannel</code> class.</p>
<p>These are the common steps for using <code class="literal">MailboxProcessor</code>:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We must plan the format of the message to be transferred and received. The format of the message has to be as simple as possible.</li>
<li class="listitem">The agent is created by instantiating it. At this stage, we have to decide whether the operation of sending and receiving messages can be canceled anytime by calling the <code class="literal">MailboxProcessor</code> constructor, which has the delegate and <code class="literal">CancellationToken</code> passed.</li>
<li class="listitem">The delegate may contain both the sending and receiving message operations, or just receiving operations.</li>
<li class="listitem">If we require it to send and wait for replies, we must carefully construct the delegate to include <code class="literal">AsyncReplyChannel</code>. It is recommended to embed this handler inside the message itself because, then, we can enforce that the reply of the sent message is closely related.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>To see this sample of sending and waiting for reply in action, we also use the F# flexible type declaration to add more flexibility when handling messages.</p>
<p>At the declarations of the message, <code class="literal">AsyncReplyChannel</code> is embedded in the message itself:</p>
<pre class="programlisting">type ComplexMessage = 
    | OrdinaryMessage of EmailMessage 
    | ForceReplyDelay of AsyncReplyChannel&lt;DateTime&gt; 
</pre>
<p>This is an excerpt of the code that creates the instance of <code class="literal">MailboxProcessor</code> and performs the receiving using handles:</p>
<pre class="programlisting">let msgManager = new MailboxProcessor&lt;ComplexMessage&gt;(fun inbox -&gt; 
    let rec loop msgReceived = 
        async { let! msg = inbox.Receive() 
                match msg with 
                | OrdinaryMessage omsg -&gt;  
                    printfn "Message received. \r\nFrom: %s, \r\nDate received: %s" omsg.From (msg.DateSent.ToString()) 
                    printfn "Subject: %s" omsg.Subject 
                    printfn "Content: \r\n %s" omsg.Content 
                    return () 
                | ForceReplyDelay replyChannel -&gt; 
                    replyChannel.Reply(msgReceived) 
                return! loop DateTime.Now 
             } 
    loop DateTime.Now 
    )  
</pre>
<p>It is also nice to know that type inference not only flows nicely not just as an inferred type declaration and inferred return type but also accommodates the d<span class="emphasis"><em>iscriminated unions</em></span> that infers the constructor of the type.</p>
<p>For example, let's see the declaration of the <code class="literal">ComplexMessage</code> type that has discriminated unions with our own previous <code class="literal">EmailMessage</code> embedded.</p>
<p>We can now combine this with pattern matching that checks for any Query as its <span class="emphasis"><em>subtype</em></span>:</p>
<pre class="programlisting">            let! message = inbox.Receive() 
                match msg with 
                | OrdinaryMessage omsg -&gt;  
                    printfn "Message received. \r\nFrom: %s, \r\nDate received: %s" omsg.From (msg.DateSent.ToString()) 
                    printfn "Subject: %s" omsg.Subject 
                    printfn "Content: \r\n %s" omsg.Content 
                    return () 
                | ForceReplyDelay replyChannel -&gt; 
                    replyChannel.Reply(msgReceived) 
</pre>
<p>It is also very nice to know that again this feature is unique to F#, as the current release of C#/VB does not have this discriminated union feature yet.</p>
<div class="note" title="Note"><h3 class="title"><a id="note58"></a>Note</h3>
<p>There are rough plans to have discriminated union supported in C#/VB, but it is still debated. Also pattern matching is due in the upcoming version of C# 7, and VB 15 does not have the same automatic type inferences as F#. Consult Microsoft's Roslyn repo on GitHub to keep up with the latest developments in C#/VB language design.</p>
</div>
<p>A detailed description of the discriminated union is beyond the scope of this book because we cannot further optimize discriminated union. For more information on F#'s discriminated union, visit:</p>
<p>
<a class="ulink" href="https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/discriminated-unions">https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/discriminated-unions</a>
</p>
<p>The pattern matching in the sample code can be further optimized. We will describe the optimizations of pattern matching as part of the F# language constructs (beside asynchronous workflow) later in <a class="link" title="Chapter&#160;7.&#160;Language Features and Constructs Optimization" href="fsp-hiperf_cu07.html#aid-1ENBI1">Chapter 7</a>, <span class="emphasis"><em>Language Features and Constructs Optimization</em></span>.</p>
<p>To test the sending and receiving in action simultaneously, we can send (post) the message while at the same time waiting to receive the message:</p>
<pre class="programlisting">let email1 = new EmailMessage ( From = "john@somemail.com", To = "clark@somemail.com", Subject = "Introduction", Content = "Hello there!") 
msgManager.Start() 
msgManager.Post(OrdinaryMessage email1) 
msgManager.PostAndReply((fun reply -&gt; ForceReplyDelay(reply)), 100) |&gt; ignore 
 
</pre>
<p>Since we have embedded the channel inside the message, we can have a quick guarantee that for each message we receive, we can always try to relate the message we receive to the message we send because we are using the same <code class="literal">AsyncReplyChannel</code>.</p>
<p>Looking back at the definition of the delegate inside the constructor of <code class="literal">marketMaker</code>, it matches the query pattern of a <code class="literal">Message</code> type, which then returns the related asset based on the message posted by <code class="literal">PostAndReply</code>.</p>
<p>Now, we have extended our understanding of <code class="literal">MailboxProcessor</code> using the sample of an order and sell transaction. It is still similar to a bank account model transaction, but we do not care how many parts or asset balances we have.</p>
</div>
</div>
</div>
</div>


<div class="section" title="Managing side effects inside MailboxProcessor and asynchronous workflows" id="aid-173721"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec33"></a>Managing side effects inside MailboxProcessor and asynchronous workflows</h1>
</div>
</div>
</div>
<p>We may have been tempted to use a <code class="literal">MailboxProcessor</code> instantiation wrapped within an asynchronous workflow. <span class="emphasis"><em>It is not recommended to have this overly complex wrapper as MailboxProcessor already has its own asynchronous context</em></span>.</p>
<p>This is also applied to interoperability with the UI thread as well as asynchronous context should not be mixed with the UI thread directly. Mixing the UI thread with asynchronous contexts will yield unpredictable results.</p>
<p>If we must use Windows forms, it is best to have asynchronous workflow and the UI coded in F#. Using WPF, we can use WPF Dispatcher to ensure we will not have cross-thread violation.</p>
<p>On managing side effects, using <code class="literal">MailboxProcessor</code> to do side effects activity must be handled carefully.</p>
<p>Consider these scenarios and the reasons:</p>
<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Upon receiving the messages inside the delegate parameter of a <code class="literal">MailboxProcessor</code> instantiation, we have calls to get web content asynchronously. These multiple asynchronous contexts are not recommended because there can be race conditions on which processes are to be finished and return the call back to the calling delegate. This added complexity will add overhead to the stack because there is no guarantee that <code class="literal">MailboxProcessor</code> will handle the asynchronous scheduling correctly.</li>
<li class="listitem">If we still want to do this, every call to get the web content must be handled using the Disposable pattern as far as possible in order to minimize the pointer leak of the call stack.</li>
<li class="listitem">The original intent of <code class="literal">MailboxProcessor</code> is to have a role as message agent. The delegate and the payload of the message should be constructed to be as simple as possible. If we want to use <code class="literal">AsyncReplyChannel</code>, it is recommended to embed it as part of the message.</li>
<li class="listitem">Wrapping <code class="literal">MailboxProcessorPost</code> and <code class="literal">Reply</code> in a parallel loop such as <code class="literal">Parallel.ForEach()</code> does not really guarantee that <code class="literal">MailboxProcessor</code> will send the message fully parallel unless the instantiation of <code class="literal">MailboxProcessor</code> itself is encoded within a parallel loop. This will ensure that there will be no breach outside the context of the <code class="literal">MailboxProcessor</code> delegate when <code class="literal">MailboxProcessor</code> starts.</li>
<li class="listitem">It is not recommended to have a nested recursive function of <code class="literal">async</code> calling another recursive <code class="literal">async</code> function. The level of unpredictability will increase by many orders of magnitude, especially as it will be considered as a long-lived object, but it will also put a burden on <code class="literal">Gen0</code> and <code class="literal">Gen1</code> of the CLR. Normally, long-lived objects should live on <code class="literal">Gen1</code>, but the asynchronous workflow might consider it as short-lived object; therefore, the burden will be put on both <code class="literal">Gen0</code> and <code class="literal">Gen1</code>.</li>
</ol>
<div style="height:10px; width: 1px"></div>
</div>
<p>We have seen from many sample cases that it's important to profile the application, especially when the code contains many asynchronous workflows, including the implied <code class="literal">MailboxProcessor</code>. The result of testing how many objects live in <code class="literal">Gen0</code> and <code class="literal">Gen1</code> will determine where and how the GC may experience unnecessary overheads of garbage collections and heap allocations.</p>
<p>There may happen to be unnecessary overheads because of an object being short-lived but profiled as long lived; the GC <code class="literal">Gen0</code> and <code class="literal">Gen1</code> profiling reports should be the basis for actually finding out where the <code class="literal">Gen0</code> and <code class="literal">Gen1</code> continues. However, premature GC will not definitely help increase the performance because if there is aggressive garbage collection at <code class="literal">Gen0</code>, then the cost of garbage collection will affect the initial run time of your code, especially when <code class="literal">GC.Collect</code> is called within a loop of <code class="literal">for</code> and <code class="literal">foreach</code>. Each time <code class="literal">GC.Collect</code> is called, any exception that might happen during the call of <code class="literal">GC.Collect</code> will also affect the state of the current stack frame and heap allocations.</p>
<p>Again, there is no single solution for uncommon implementations of your asynchronous workflow.</p>
</div>


<div class="section" title="Parallel programming with .NET TPL"><div class="titlepage" id="aid-181NK2"><div><div><h1 class="title"><a id="ch05lvl1sec34"></a>Parallel programming with .NET TPL</h1>
</div>
</div>
</div>
<p>We have a basic knowledge of asynchronous, parallel asynchronous, and interoperability of asynchronous workflows with .NET EAP and APM. We have finished discussing .NET Task based Asynchronous Programming (TAP) in the form of interoperability between F# asynchronous workflows and .NET TAP. We are now discussing more about interoperability with .NET TPL.</p>
<p>F# does not just have its own implementations of asynchronous supports and parallel asynchronous but is fully compatible with .NET BCL hence .NET TPL.</p>
<p>.NET TPL is not just an infrastructure of a combination of implied asynchronous and parallelism. It focuses on these three features:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Task-based parallelism</li>
<li class="listitem">Data parallelism</li>
<li class="listitem">PLINQ, an implementation of LINQ in parallel, also called Parallel LINQ</li>
</ul>
</div>
<p>Let's learn more&#160;.NET TPL by visiting the MSDN Library .NET TPL landing page:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd460693(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/dd460693(v=vs.110).aspx</a>
</p>
<p>According to MSDN, this is the overall high-level picture of .NET 4 TPL:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00302.jpeg" alt="Parallel programming with .NET TPL"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>On the syntactic level, .NET TPL is conceptually divided into two:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Declarative parallel queries (for example, PLINQ)</li>
<li class="listitem">Imperative parallel (for example, <code class="literal">Parallel.ForEach</code>, with an additional parameter to maintain state consistency)</li>
</ul>
</div>
<p>This picture is valid for .NET 4.5 and it is still valid for .NET 4.6/4.6.1 as it illustrates the high-level of .NET TPL that includes data flow parallelism, which starts in .NET 4.5.</p>
<p>It is also worth noting that since .NET 4.5, there are the following new features in parallelism support:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Debugging parallelism is easier with parallel debugging support.</li>
<li class="listitem">Dataflow libraries is essentially the same as F# <code class="literal">MailboxProcessor</code>.</li>
<li class="listitem">Coordinating data structures makes the existing concurrent data structures more concurrent-aware. This is essentially the same as the concurrent data structures that improve performance in .NET 4.5 and later.</li>
</ul>
</div>
<p>For more information on what's new in .NET 4.5, 4.6 and 4.6.1, visit:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/ms171868(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/ms171868(v=vs.110).aspx</a>
</p>
<p>For more information on what's new in .NET 4.5 specific to parallel programming, visit this Microsoft MSDN blog by .NET parallel team (formerly ParallelFX):</p>
<p>
<a class="ulink" href="https://blogs.msdn.microsoft.com/pfxteam/2011/09/17/whats-new-for-parallelism-in-net-4-5/">https://blogs.msdn.microsoft.com/pfxteam/2011/09/17/whats-new-for-parallelism-in-net-4-5/</a>
</p>
<p>There is a comparable message-passing agent library in .NET TPL; it is called <span class="emphasis"><em>Dataflow</em></span>. The Dataflow library is not included in the original runtime distribution of .NET runtime and SDK. It is available to be downloaded as a separate NuGet package.</p>
<p>Throughout this chapter, we are not going to discuss Dataflow libraries because we are focusing on F# <code class="literal">MailboxProcessor</code>.</p>
<div class="note" title="Note"><h3 class="title"><a id="note59"></a>Note</h3>
<p>Although .NET 4.0 is the starting release of .NET that has .NET TPL, some of the internal implementations of .NET TPL have bugs that have been fixed in .NET 4.5 and later, especially the parallel debugging support. Beginning with <a class="link" title="Chapter&#160;5.&#160;Advanced Concurrency Support in F#" href="#aid-164MG2">Chapter 5</a>, <span class="emphasis"><em>Advanced Concurrency Support in F#</em></span> all .NET TPL-related discussion should only be applied to .NET 4.5 and later.</p>
</div>
<p>In the next section, we will discuss more about the TPL, from task-based parallelism to data parallelism.</p>
<div class="section" title="Overview of task-based parallelism"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec43"></a>Overview of task-based parallelism</h2>
</div>
</div>
</div>
<p>Let's visit task-based parallelism. The term <span class="emphasis"><em>task</em></span>&#160;is actually the same concept of task as in the <span class="strong"><strong>Task based Asynchrony Pattern</strong></span> (<span class="strong"><strong>TAP</strong></span>) with one additional trait: it can run independently, as a concurrent unit. The consequence of a parallelized task as a concurrent unit is that it can run in parallel or may run as a chain of tasks some time in the future.</p>
<p>All the parallel task operations are available from the <code class="literal">System.Threading.Tasks.Parallel</code> class, under the <code class="literal">mscorlib.dll</code> assembly. This means that we can use it immediately without referencing any assembly other than <code class="literal">mscorlib.dll</code>.</p>
<p>This <code class="literal">Parallel</code> class has many <code class="literal">static</code> methods that provide support for task parallelism and data parallelism.</p>
<p>The task parallelism-related method in the <code class="literal">Parallel</code> class is the <code class="literal">Parallel.Invoke</code> method.</p>
<p>This method has the following overloaded signatures; the first signature is as follows:</p>
<pre class="programlisting">static member Invoke :  
        [&lt;ParamArrayAttribute&gt;] actions:Action[] -&gt; unit 
</pre>
<p>The second signature of <code class="literal">Parallel.Invoke</code> is as follows:</p>
<pre class="programlisting">static member Invoke :  
        parallelOptions:ParallelOptions * 
        [&lt;ParamArrayAttribute&gt;] actions:Action[] -&gt; unit 
</pre>
<p>The first signature defines <code class="literal">Invoke</code> to have one parameter-the parameter arrays of <code class="literal">Action</code> delegates. The <code class="literal">[&lt;ParamArrayAttribute&gt;]</code> is the same semantic as C#'s <code class="literal">param</code> keyword, but it has to be defined as an attribute parameter in F# to be used in a manner similar to <code class="literal">param</code> in C#.</p>
<p>The second signature defines two parameters: <code class="literal">ParallelOptions</code>, a class to further configure the behavior of the parallelism we want to run, and the parameter arrays of <code class="literal">Action</code> delegates.</p>
<p>The documentation on the <code class="literal">Parallel.Invoke</code> method is available at:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/system.threading.tasks.parallel.invoke(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/system.threading.tasks.parallel.invoke(v=vs.110).aspx</a>
</p>
<p>Using <code class="literal">Parallel.Invoke</code> in F# is quite simple. For example, we can parallelize two different processes, the first process being factorial, and the second process getting all of the running processes on your local machine.</p>
<p>The full sample code is as follows:</p>
<pre class="programlisting">open System 
open System.Diagnostics 
open System.Threading.Tasks 
 
let rec fact x =  
    match x with 
    | n when n &lt; 2 -&gt; 1 
    | _ -&gt; fact(x-1) * x 
     
let factwrap x = 
    let factresult = fact x 
    ignore 
 
let runningProcesses = fun () -&gt;  
    let processes = Process.GetProcesses() 
    let processNames =  
        processes 
        |&gt; Seq.map (fun p -&gt; p.ProcessName) 
    for name in processNames do 
        Console.WriteLine(name) 
</pre>
<p>The interesting fact about this code is how we interoperate with .NET <code class="literal">Action</code> delegate by simply instantiating a new <code class="literal">Action</code> delegate with the process we want to wrap as an <code class="literal">Action</code> delegate.</p>
<p>If we want to wrap a recursive function as an <code class="literal">Action</code> delegate, we need to wrap the function inside another function that always ignores the result, just as the <code class="literal">factwrap</code> function does. This is crucial, because <code class="literal">Action</code> delegate is a delegate that has no return value, or it returns a unit (<code class="literal">void</code> in C#).</p>
<p>We can then add the line to run <code class="literal">Parallel.Invoke</code> and our delegates of <code class="literal">factwrap</code> and <code class="literal">runningprocesses</code> in our existing <code class="literal">EntryPoint</code> of <code class="literal">main</code>:</p>
<pre class="programlisting">[&lt;EntryPoint&gt;] 
let main argv =  
    let anyPerson1 = new Person(Name = "John Doe", Address="Baker Street", IsMarried = false) 
    let anyPerson2 = new Person(Name="Jane Doe", Address ="Arlington Street", IsMarried = true) 
    Console.WriteLine(anyPerson1.ToString())  
    Console.WriteLine(anyPerson2.ToString()) 
    let anyperson3 = Person.Deserialize(anyPerson1.ToString()) 
    Console.WriteLine(anyperson3.ToString) 
    Parallel.Invoke(new Action(ParallelInvokeSample01.factwrap 5), new Action(ParallelInvokeSample01.runningProcesses)) 
    //printfn "%A" argv 
    0 // return an integer exit code 
</pre>
<p>The sample <code class="literal">Parallel.Invoke</code> contains two delegates to be parallelized. But we can add many delegates as well, more than one as implied by <code class="literal">ParamArrayAttribute</code> marking.</p>
<p>The parameter type of the array is the <code class="literal">Action[]</code> array. This means all of our functions must have a function body and return <code class="literal">void</code>, not just a result of a process. This is why the <code class="literal">fact</code> function must be wrapped into another function that runs <code class="literal">fact</code> and ignores the returning result, and the <code class="literal">runningProcesses</code> function body is explicitly contained within a lambda function that takes a unit as its parameter.</p>
<p>If we do not declare <code class="literal">runningProcesses</code> as explicitly declared within lambda, this function will be inferred to have a generic type as its parameter because F# needs an explicit declaration of the parameter type. And we will catch other compile errors because the <code class="literal">Action</code> delegate also requires a signature of a function that takes no parameter and returns nothing.</p>
<p>The following is the signature of the <code class="literal">Action</code> delegate:</p>
<pre class="programlisting">type Action =  
    delegate of unit -&gt; unit 
</pre>
<p>The <code class="literal">delegate</code> keyword in this sense is the .NET BCL delegate, not F# delegate. The delegate of F# represents an F# function, and this F# function will be compiled as an inheritance of F# <code class="literal">FastFunction</code>.</p>
<p>Let's dive into the IL of the <code class="literal">factwrap</code> function and the inside declaration of <code class="literal">Action</code>:</p>
<pre class="programlisting">.class auto ansi serializable nested assembly beforefieldinit factwrap@14&lt;a&gt; 
       extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2&lt;!a,class [FSharp.Core]Microsoft.FSharp.Core.Unit&gt; 
{ 
} // end of class factwrap@14 
</pre>
<p>We now can see that it extends <code class="literal">Microsoft.Core.FSharpFunc&lt;`T1,`T2&gt;</code>, which takes two generic type parameters. <code class="literal">T1</code> is the parameter of the delegate and <code class="literal">T2</code> is the returning type. <code class="literal">T1</code> is typed as unit and <code class="literal">T2</code> is typed as unit as well.</p>
<p>Let's visit the second overload of <code class="literal">Parallel.Invoke</code> that has <code class="literal">ParallelOptions</code> as its parameter.</p>
<p>The documentation of the <code class="literal">Parallel.Options</code> class is available at:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/system.threading.tasks.paralleloptions(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/system.threading.tasks.paralleloptions(v=vs.110).aspx</a>
</p>
<p>The <code class="literal">ParallelOptions</code> class is basically a class to configure <code class="literal">Parallel.Invoke</code> further to meet custom concurrency requirements.</p>
<p>The following are the properties of <code class="literal">ParallelOptions</code>:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">CancellationToken</code>, to pass <code class="literal">CancellationToken</code> to cancel the running of invoked actions.</li>
<li class="listitem"><code class="literal">MaxDegreeOfParallelism</code>, to get or set the maximum number of concurrent tasks enabled by this <code class="literal">ParallelOptions</code> instance.</li>
<li class="listitem"><code class="literal">TaskScheduler</code>, to get or set <code class="literal">TaskScheduler</code> associated with this <code class="literal">ParallelOptions</code> instance. Setting this property to null indicates that the current scheduler of the running thread from the current <code class="literal">threadpool</code> should be used.</li>
</ul>
</div>
<p>We can also force the parallelism context to have a maximum degree of parallelism of <code class="literal">5</code> by passing this value to the property of <code class="literal">ParallelOptions.MaxDegreeOfParallelism</code>.</p>
<p>A quick sample of this (using our existing sample delegates) is as follows:</p>
<pre class="programlisting">Parallel.Invoke(new ParallelOptions(MaxDegreeOfParallelism = 5),new Action(ParallelInvokeSample01.factwrap 5), new Action(ParallelInvokeSample01.runningProcesses)) 
</pre>
<p>We have now set the maximum degree of parallelism to <code class="literal">5</code>, and this is not a pessimistic value because we are only passing two <code class="literal">Action</code> delegates. Setting this value to <code class="literal">-1</code> will instruct <code class="literal">Parallel.Invoke</code> to run as parallelized to use available cores and available threads in the thread pool as often as possible.</p>
<p>Be careful when setting a value for the <code class="literal">MaxDegreeOfParallelism</code> property. MSDN Library has additional cautions:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">On many cores:<p>When you know that a particular algorithm you're using won't scale beyond a certain number of cores. You can set the property to avoid wasting cycles on additional cores.</p></li>
<li class="listitem">On the implementation detail of the allocation of <code class="literal">thread</code> and <code class="literal">threadpool</code> resources:<p>When you're running multiple algorithms concurrently and want to manually define how much of the system each algorithm can utilize. You can set a MaxDegreeOfParallelism value for each.</p><p>When the thread pool's heuristics are unable to determine the right number of threads to use and could end up injecting too many threads. For example, in long-running loop body iterations, the thread pool might not be able to tell the difference between reasonable progress or livelock or deadlock, and might not be able to reclaim threads that were added to improve performance. In this case, you can set the property to ensure that you don't use more than a reasonable number of threads.</p></li>
</ul>
</div>
<p>The lock in the parallel invocation (in the last bullet) implies that any global and shared state, if used inside a <code class="literal">Parallel.Invoke</code> delegate, is prone to an unpredictable state; therefore, a lock should be used. But locking objects in the middle of parallelism might bring deadlock itself because many threads are racing to modify and there is no guarantee which one will have an exclusive lock and will not block others.</p>
<p>To see further what goes on when we invoke delegates to be parallelized, we could leverage the existing parallel debugging tool in Visual Studio, available since Visual Studio 2012.</p>
<div class="section" title="Quick start-using the parallel debugging tool in Visual Studio"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec7"></a>Quick start-using the parallel debugging tool in Visual Studio</h3>
</div>
</div>
</div>
<p>Now let's use the parallel debugging capability of Visual Studio and .NET 4.5+. Put breakpoint in the line of <code class="literal">Parallel.Invoke</code> and inside <code class="literal">factwrap</code> and <code class="literal">runningProcesses</code>.</p>
<p>Press <span class="emphasis"><em>F5</em></span> to run with debugging.</p>
<p>When it stops at <code class="literal">Parallel.Invoke</code>, open the <span class="strong"><strong>Parallel Stacks</strong></span> visualizer by choosing&#160;<span class="strong"><strong>Debug</strong></span> | <span class="strong"><strong>Windows</strong></span> | <span class="strong"><strong>Parallel Stacks</strong></span>. We also open <span class="strong"><strong>Tasks</strong></span> by choosing <span class="strong"><strong>Debug</strong></span> | <span class="strong"><strong>Windows</strong></span> | <span class="strong"><strong>Tasks</strong></span>:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00303.jpeg" alt="Quick start-using the parallel debugging tool in Visual Studio"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>As visualized in the screenshot, the <span class="strong"><strong>Tasks</strong></span> window already displays the current task of the active task.</p>
<p>Press <code class="literal">F11</code> to step into the next function. At the first round, it will go through <code class="literal">factwrap</code> and a new thread is created:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00304.jpeg" alt="Quick start-using the parallel debugging tool in Visual Studio"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>As <code class="literal">factwrap</code> is calling <code class="literal">fact</code>, the <code class="literal">fact</code> function body is also debugged for the number or parameter we passed into <code class="literal">factwrap</code>, in this case it is 5, as factorial of 5.</p>
<p>This is pictured nicely in <span class="strong"><strong>Parallel Stacks</strong></span>:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00305.jpeg" alt="Quick start-using the parallel debugging tool in Visual Studio"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>In the preceding screenshot, we can nicely see that it spawns a new thread to hold the <code class="literal">runningProcesses</code> delegate. In terms of the thread pool, all of these threads are in one thread pool, so it is efficiently executed within the same context of running the thread of the code that runs <code class="literal">Parallel.Invoke</code>.</p>
<p>As we go further into the <code class="literal">fact</code> function and leave the recursive, we can also see that <span class="strong"><strong>Parallel Stacks</strong></span> displays the related call stack with the matched debug breakpoint:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00306.jpeg" alt="Quick start-using the parallel debugging tool in Visual Studio"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>After it finishes executing the <code class="literal">Parallel.Invoke</code>, the current thread will go back to our entrypoint of <code class="literal">main</code>.</p>
<p>For more information on using parallel debugging (including multithread debugging) in Visual Studio, consult the following MSDN Library page:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/ms164746.aspx">https://msdn.microsoft.com/en-us/library/ms164746.aspx</a>
</p>
<p>For more information about <span class="strong"><strong>Parallel Stacks</strong></span>, consult the following MSDN Library page:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd998398.aspx">https://msdn.microsoft.com/en-us/library/dd998398.aspx</a>
</p>
<div class="note" title="Note"><h3 class="title"><a id="note60"></a>Note</h3>
<p>The current offline documentation of the MSDN Library in Visual Studio 2015 (opened with MS Help) section of Visual Studio debugging is not updated. It is not in sync with the latest documentation of Visual Studio in the online MSDN Library. It is highly recommended to always have the offline MSDN Library installed and updated first, but we should check the online MSDN Library for the latest update.
</p>
<p>
Also, since we already know that F# documentation is open source, we should also always check the online documentation for the latest update. Starting from this chapter, more resources will be emphasized on online MSDN Library.</p>
</div>
</div>
</div>
<div class="section" title="Overview of data parallelism"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec44"></a>Overview of data parallelism</h2>
</div>
</div>
</div>
<p>Data parallelism in .NET TPL is actually a library of functions/methods that have parallel operations on certain data operations, such as enumerating data. It is can also be seen as declarative because it is very closely related to the existing language features of how F# iterates a collection (using F# <code class="literal">for</code> loop).</p>
<p>It is also clearly stated in the MSDN Library that this data parallelism is only for a collection (such as IEnumerable) and array, not for encapsulating operations to be parallelized, such as task parallelism. The main focus of data parallelism is parallelizing <code class="literal">for</code>, either <code class="literal">for</code> with counter or <code class="literal">foreach</code>, to directly iterate through the elements of the collection.</p>
<p>In F#, <code class="literal">foreach</code> is represented by the for .. in construct, and it's conceptually and contextually the same as <code class="literal">foreach</code> in C#/VB, although it is semantically different.</p>
<p>The following methods are the operations of data parallelism:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">Parallel.For</code>, to have loops with counter (it may act as a starting value when incremented), and this <code class="literal">For</code> does not run sequentially as compared with the basic for</li>
<li class="listitem"><code class="literal">Parallel.ForEach</code>, to have <code class="literal">foreach</code> in parallel when iterating elements</li>
</ul>
</div>
<p>The <code class="literal">Parallel.For</code> is related to the <code class="literal">for</code> loop of F# that has predefined from and stopping values to be counter for the loop.</p>
<p>For example, consider the following code snippet:</p>
<pre class="programlisting">open System 
open System.Threading.Tasks 
 
let function1() = 
  for i = 1 to 10 do 
    Console.WriteLine("current datetime is" + DateTime.Now.ToString()) 
  printfn "" 
 
Parallel.For(1,10, fun(iteration) -&gt; 
    Console.WriteLine("Iteration: " + iteration.ToString() + " current datetime: " + DateTime.Now.ToString()) 
    printfn "" 
    ) 
</pre>
<p>The <code class="literal">function1</code> will run sequentially from <code class="literal">1</code> to <code class="literal">10</code>, and it will always run synchronously, which means that the first iteration has to be finished first before running the next iterations. The rest of the iterations still have to wait; therefore, it is intentional and it is also trivial that the execution behavior of the first iteration blocks the next remaining iterations.</p>
<p>The <code class="literal">parallelFunction1</code> is a parallel version of <code class="literal">function1</code>. In the function body, we add the display of the current iterations by passing the counter into the output display.</p>
<p>We shall put the code as F# script, run the script inside Visual Studio <span class="strong"><strong>F# Interactive</strong></span>, and immediately see the result:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00307.jpeg" alt="Overview of data parallelism"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>Here, we can see the proof that there is no guarantee that the loop will execute sequentially. This is intentional because in parallelism, we do not care about the order of the executions, as we explored in the section,&#160;<span class="emphasis"><em>Introducing concurrency support in F# 4</em></span>&#160;in <a class="link" title="Chapter&#160;4.&#160;Introduction to Concurrency in F#" href="fsp-hiperf_cu04.html#aid-11C3M2">Chapter 4</a>, <span class="emphasis"><em>Introduction to Concurrency in F#</em></span>.</p>
<p>Now, we visit the parallel pair of the F# <code class="literal">for .. in</code> loop, and the <code class="literal">Parallel.ForEach</code> method.</p>
<p>We now start from the simple sample of iterating a collection in F# using the <code class="literal">for .. in</code> loop and put it into parallel:</p>
<pre class="programlisting">let seq1 = seq { for i in 1 .. 10 -&gt; (i, i*i) } 
for (a, asqr) in seq1 do 
  printfn "%d squared is %d" a asqr 
 
Parallel.ForEach(seq1, fun((a,asqr)) -&gt; 
  printfn "%d squared is %d" a asqr 
    ) 
</pre>
<p>Again, run the code in <span class="strong"><strong>F# Interactive</strong></span>, and we can compare the output:</p>
<p>
</p>
<div class="mediaobject"><img src="../Images/image00308.jpeg" alt="Overview of data parallelism"/></div>
<p style="clear:both; height: 1em;"> </p>
<p>
</p>
<p>Now, we have interoperability of .NET TPL's data parallelism in F#. As long as we carefully keep the process as simple as possible (without shared state), we can have a successful implementation of parallelism with a highly predictable result.</p>
<p>This is also a good example of minimizing unpredictability by keeping the side effects as minimal as possible. We can still use shared state, but then, we have to implement locking as well, and this will decrease the performance. The background reason for this decreasing performance is the same as having locks in an asynchronous workflow.</p>
</div>
<div class="section" title="Common potential pitfalls in parallel programming"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec45"></a>Common potential pitfalls in parallel programming</h2>
</div>
</div>
</div>
<p>There are common pitfalls for parallel programming in .NET, and we should pay attention to these.</p>
<p>We know that we should avoid the following:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Side effects in mutable states of an object. If a mutable state is used, a lock has to be implemented to ensure concurrency of the object state. This is also applied to shared states, because any shared state is also mutable as well.</li>
<li class="listitem">A side effect in the possibility of having an exception. If we do not catch any possible exception (especially exceptions related to blocking operations such as I/O), any exceptions thrown in the middle of any parallel processes will cancel the whole pipeline of the parallel process.</li>
<li class="listitem">COM objects, because we have to be careful when handling an object that has a different apartment model, such as COM objects.</li>
<li class="listitem">Side effects of mixing a UI thread with the current thread from a non-UI thread. In WPF, this can be mitigated by using WPF Dispatcher.</li>
</ul>
</div>
<p>Now, let's try to handle mutable states in the next section.</p>
<div class="section" title="Overview of handling mutable state"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec8"></a>Overview of handling mutable state</h3>
</div>
</div>
</div>
<p>If we want to really have a mutable state, we can enclose it in a pair of <code class="literal">Monitor.Enter</code> and <code class="literal">Monitor.Exit</code> loops.</p>
<p>For example, we can code this using a simplified sample of how the lock in C#/VB is actually implemented:</p>
<pre class="programlisting">open System.Threading 
 
let lock (lockobj:obj) anyfunction = 
  Monitor.Enter lockobj 
  try 
    anyfunction() 
  finally 
    // the code in the finally block will be executed after anyfunction is completely finishing execution.  
    // Therefore we can exit the monitor gracefully. 
    Monitor.Exit lockobj 
</pre>
<p>This watching state is the reason why .NET names the object to watch the state as <code class="literal">Monitor</code>.</p>
<p>We will not describe the <code class="literal">Monitor</code> object further because Monitor is part of an object locking mechanism that is not recommended in many cases of F# concurrency implementation. We shall focus only on the functional aspects of F# concurrency rather than dealing with mutable state, which is common for non-functional programming style code. For more information on .NET Monitor, visit the following link:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/system.threading.monitor(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/system.threading.monitor(v=vs.110).aspx</a>
</p>
<p>There is also a class in .NET BCL to allow mixing mutable state for simple operations, such as increment and decrement inside a parallel loop. The class is <code class="literal">System.Threading.Interlocked</code>, and it is also used internally in F# to implement asynchronous workflows in <code class="literal">Control.Async</code> and builders in the <code class="literal">FSharpAsyncBuilder</code> class.</p>
<p>The implementation of using <code class="literal">Interlocked</code> is not common, and we should be careful. This is why it has a limited kind of allowable operations. We can see a good sample implementation of leveraging <code class="literal">Interlocked</code> in the internal implementation of F# <code class="literal">Async.Parallel</code> code:</p>
<pre class="programlisting">       static member Parallel (l: seq&lt;Async&lt;'T&gt;&gt;) = 
            unprotectedPrimitive (fun args -&gt; 
                let tasks,result =  
                    try  
                        Seq.toArray l, None   // manually protect eval of seq 
                    with exn -&gt;  
                        let edi = ExceptionDispatchInfo.RestoreOrCapture(exn) 
                        null, Some(errorT args edi) 
 
                match result with 
                | Some r -&gt; r 
                | None -&gt; 
                if tasks.Length = 0 then args.cont [| |] else  // must not be in a 'protect' if we call cont explicitly; if cont throws, it should unwind the stack, preserving Dev10 behavior 
                protectedPrimitiveCore args (fun args -&gt; 
                    let ({ aux = aux } as args) = delimitSyncContext args  // manually resync 
                    let count = ref tasks.Length 
                    let firstExn = ref None 
                    let results = Array.zeroCreate tasks.Length 
                    // Attept to cancel the individual operations if an exception happens on any of the other threads 
                    let innerCTS = new LinkedSubSource(aux.token) 
                    let trampolineHolder = aux.trampolineHolder 
                     
                    let finishTask(remaining) =  
                        if (remaining = 0) then  
                            innerCTS.Dispose() 
                            match (!firstExn) with  
                            | None -&gt; trampolineHolder.Protect(fun () -&gt; args.cont results) 
                            | Some (Choice1Of2 exn) -&gt; trampolineHolder.Protect(fun () -&gt; aux.econt exn) 
                            | Some (Choice2Of2 cexn) -&gt; trampolineHolder.Protect(fun () -&gt; aux.ccont cexn) 
                        else 
                            FakeUnit 
 
                    // recordSuccess and recordFailure between them decrement count to 0 and  
                    // as soon as 0 is reached dispose innerCancellationSource 
                 
                    let recordSuccess i res =  
                        results.[i] &lt;- res; 
                        <span class="strong"><strong>finishTask(Interlocked.Decrement count)</strong></span>  
 
                    let recordFailure exn =  
                        // capture first exception and then decrement the counter to avoid race when 
                        // - thread 1 decremented counter and preempted by the scheduler 
                        // - thread 2 decremented counter and called finishTask 
                        // since exception is not yet captured - finishtask will fall into success branch 
                        match Interlocked.CompareExchange(firstExn, Some exn, None) with 
                        | None -&gt;  
                            // signal cancellation before decrementing the counter - this guarantees that no other thread can sneak to finishTask and dispose innerCTS 
                            // NOTE: Cancel may introduce reentrancy - i.e. when handler registered for the cancellation token invokes cancel continuation that will call 'recordFailure' 
                            // to correctly handle this we need to return decremented value, not the current value of 'count' otherwise we may invoke finishTask with value '0' several times 
                            innerCTS.Cancel() 
                        | _ -&gt; () 
                        finishTask(Interlocked.Decrement count) 
</pre>
<p>In this code, <code class="literal">Interlocked.Decrement</code> is used to maintain or keep track of the state of the counter of the number of parallelized asynchronous workflows. The code flows nicely because F# has its own parallel asynchronous operation without depending on the .NET TPL <code class="literal">Parallel</code> class.</p>
<p>In the MSDN Library, there are additional aspects of common pitfalls of parallel programming available at the following page:</p>
<p>
<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd997392(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/dd997392(v=vs.110).aspx</a>
</p>
<p>Among those points, we should pay attention to the following examples&#160;in the MSDN Library article, in addition to the many samples of asynchrony and parallelism that we explored:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Avoid over-parallelization. By using parallel loops, you incur the overhead costs of partitioning the source collection and synchronizing the worker threads. The benefits of parallelization are further limited by the number of processors and the cores on the computer. There is no speedup to be gained by running multiple compute-bound threads on just one processor. Therefore, you must be careful not to over-parallelize a loop. Also, too many parallelizations increase the overheads on the task scheduler and it may lead to a race condition on the thread affinities being obtained. Also, having overheads on a task scheduler will decrease the responsiveness of the running application.</li>
<li class="listitem">Avoid calls to non-thread-safe methods! This is extremely important, because writing to non-thread-safe instance methods from a parallel loop can lead to data corruption, which may or may not go undetected in your program. It can also lead to exceptions, for example, multiple parallel threads of calling <code class="literal">FileStream.WriteByte</code>. This point is closely related to avoiding mixing I/O operations. It is also necessary to be aware that almost all of the operations in <code class="literal">Stream</code>, <code class="literal">File</code>, and <code class="literal">System.Web</code> classes are not thread-safe at all.</li>
<li class="listitem">Avoid changing thread affinity in the middle of any parallel operation. This might yield exceptions and not just unpredictable results/behaviors.</li>
</ul>
</div>
<p>The most common scenario in which over-parallelization can occur is in nested loops. In most cases, it is best to parallelize only the outer loop unless one or more of the following conditions apply:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The inner loop is known to be very long. You are performing an <span class="emphasis"><em>expensive computation</em></span> on each order. The term expensive computation in this context means having complex calculations that will consume a lot of CPU cycles and also having a parallel computation inside a parallel computation or <span class="emphasis"><em>complex nested parallelizations</em></span>.</li>
<li class="listitem">The target system is known to have enough processors to handle the number of threads that will be produced by parallelizing the operation. Having too many degrees of parallelism, especially if the number of parallelism is higher than the number of CPU core, will enforce other processes to wait indefinitely, and this waiting will also result in a deadlock condition.</li>
</ul>
</div>
<p>We can also have a further reference to .NET parallelism from Microsoft by downloading the white paper titled <span class="emphasis"><em>Patterns for Parallel Programming: Understanding and Applying Parallel Patterns with the .NET Framework 4</em></span> from the following official download link:</p>
<p>
<a class="ulink" href="https://www.microsoft.com/en-us/download/details.aspx?id=19222">https://www.microsoft.com/en-us/download/details.aspx?id=19222</a>
</p>
</div>
</div>
</div>


<div class="section" title="Summary" id="aid-190861"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec35"></a>Summary</h1>
</div>
</div>
</div>
<p>We have explored the advanced concurrency support in F# and .NET TPL. We also have enough knowledge about how we should handle side effects and also on using asynchronous for various cases and scenarios.</p>
<p>The main conclusion when implementing the best practices of leveraging concurrency in F# is that there is no silver bullet for all concurrency needs, and this includes avoiding the assumption that parallelized code always runs faster than non-parallel code after examining cases that may bring down the performance of parallel implementation in .NET TPL. These warning cases can be applied not just in F# but also in VB/C#.</p>
<p>We have understood asynchrony and parallelism. We will use this knowledge to optimize the type providers and avoid the pitfalls of implementing them in 
<a class="link" title="Chapter&#160;6.&#160;Optimizing Type Provider" href="fsp-hiperf_cu06.html#aid-19UOO2">Chapter 6</a>, <span class="emphasis"><em>Optimizing Type Provider</em></span>
.</p>
</div>
</body>
</html>