- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Functors and Monads
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函子和单子
- en: 'Moving from higher-order functions and delegates, we step into the world of
    functors, key players in functional programming. They allow us to work with wrapped
    values, such as lists or computational outcomes, in a structured way. This chapter
    explores the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从高阶函数和委托过渡到函子，我们进入了函数式编程的世界，函子是其中的关键角色。它们允许我们以结构化的方式处理包装值，如列表或计算结果。本章探讨了以下内容：
- en: Functors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函子
- en: Functor laws
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函子法则
- en: Applicative functors and laws
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用函子和法则
- en: Monads and monad laws
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单子与单子法则
- en: As always, the following are three self-check tasks to help you understand the
    existing knowledge of functors and monads.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，以下三个自我检查任务可以帮助你理解函子和单子的现有知识。
- en: Task 1 – Functor usage
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 1 – 函子使用
- en: 'Given a `Result<List<Tower>, string>` type that represents a list of towers,
    where `Tower` is a class containing properties such as `Id`, `Name`, and `Damage`,
    the task is to use the functor concept to apply a function to each tower that
    appends “(Upgraded)” to the end of its name to indicate that the tower has been
    upgraded:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个表示塔列表的 `Result<List<Tower>, string>` 类型，其中 `Tower` 是一个包含 `Id`、`Name` 和 `Damage`
    等属性的类，任务是用函子概念将一个函数应用到每个塔上，在名称末尾添加“(升级)”以表示塔已被升级：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Task 2 – Applicative functor
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 2 – 应用函子
- en: 'Imagine you have two functions wrapped in the `Result` type: `Result<Func<Tower,
    bool>, string> ValidateDamage` checks whether a tower’s damage is within acceptable
    limits, and `Result<Func<Tower, bool>, string> ValidateName` checks whether the
    tower’s name meets certain criteria. Given a `Result<Tower, string>` representing
    a single tower, use applicative functors to apply both validation functions to
    the tower, ensuring both validations pass:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你有两个被 `Result` 类型包裹的函数：`Result<Func<Tower, bool>, string> ValidateDamage`
    检查塔的伤害是否在可接受范围内，而 `Result<Func<Tower, bool>, string> ValidateName` 检查塔的名称是否符合某些标准。给定一个表示单个塔的
    `Result<Tower, string>`，使用应用函子将这两个验证函数应用到塔上，确保两个验证都通过：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Task 3 – Monad usage
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 3 – 单子使用
- en: 'Given a sequence of operations needed to upgrade a tower—`FetchTower`, `UpgradeTower`,
    and `DeployTower`—with each potentially failing and returning `Result<Tower, string>`,
    use the monad concept to chain these operations together for a given tower ID.
    Ensure that if any step fails, the entire operation short-circuits and returns
    the error:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一系列用于升级塔的操作——`FetchTower`、`UpgradeTower` 和 `DeployTower`——每个操作都可能失败并返回 `Result<Tower,
    string>`，使用单子概念将这些操作串联起来，针对给定的塔 ID。确保如果任何步骤失败，整个操作将短路并返回错误：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you successfully wrote the solutions for all three tasks, you are awesome!
    If you struggle or don’t know how to solve the tasks now, don’t worry, you will
    be awesome after completing this chapter and solving them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你成功完成了所有三个任务，你真是太棒了！如果你现在遇到困难或者不知道如何解决这些任务，不要担心，完成这一章并解决这些问题后，你也会很棒。
- en: What’s a functor?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是函子？
- en: Julia decided to use an analogy from Steve’s game to explain the concept of
    functors.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅决定从史蒂夫的游戏中找一个类比来解释函子的概念。
- en: 'Julia: *Imagine a functor as a special upgrade station in your tower defense
    game. This station can take any tower and enhance it, but it always outputs a
    tower - just an* *improved version.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*想象函子是你的塔防游戏中的一个特殊升级站。这个站可以提升任何塔，但总是输出一个塔——只是一个* *改进版本*。
- en: 'Steve: *That makes sense. So it’s like a consistent way to transform things
    without changing their* *core nature?*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：*这很有道理。所以它就像是一种一致的方式来转换事物，而不改变它们的* *核心本质*？
- en: The term **functor** originates from category theory, a field of mathematics
    that deals with complex structures and mappings. In the world of programming,
    we adopt a simplified version of this concept to make it practical for data manipulation.
    In simple terms, functors are specialized containers that can hold data and have
    the ability to apply a function to every piece of data they hold, while keeping
    the overall structure intact. Imagine them as magic boxes that transform whatever
    is inside without altering the box itself.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**函子**起源于范畴论，这是一个处理复杂结构和映射的数学领域。在编程的世界里，我们采用这个概念的简化版本，使其适用于数据处理。简单来说，函子是特殊的容器，可以持有数据，并且能够将函数应用到它们持有的每一份数据上，同时保持整体结构不变。想象它们就像魔法盒子，可以改变里面的东西，而不会改变盒子本身。
- en: 'However, not every data container that can apply functions to its elements
    is a functor. There are two laws that a container needs to abide by in order to
    be counted as a functor:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非每个可以对其元素应用函数的数据容器都是函子。一个容器要被视为函子，需要遵守两个定律：
- en: '`identity` function to a functor should yield the same functor. In other words,
    if you map the `identity` function over a functor, the functor should remain unchanged.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将`identity`函数映射到函子应该得到相同的函子。换句话说，如果你将`identity`函数映射到一个函子上，该函子应该保持不变。
- en: '**Composition law**: Composing two functions and then mapping the resulting
    function over a functor should be the same as first mapping one function over
    the functor and then mapping the other. This means that functor mappings should
    be composable in a way that doesn’t depend on the order in which they’re applied.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合定律**：将两个函数组合起来，然后将结果函数映射到函子上，应该与首先将一个函数映射到函子上，然后映射另一个函数相同。这意味着函子映射应该是可组合的，不依赖于它们应用的顺序。'
- en: I know it may sound a bit complicated, so let’s discuss these laws in detail.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这听起来可能有点复杂，所以让我们详细讨论这些定律。
- en: Identity law
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恒等定律
- en: 'The Identity law states that the application of the `identity` function to
    our container returns the same container. The “identity function” here is a function
    that always returns its input. In code, we can represent it with the help of `Func<T,
    T>`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 恒等定律指出，将`identity`函数应用于我们的容器返回相同的容器。“恒等函数”在这里是一个总是返回其输入的函数。在代码中，我们可以用`Func<T,
    T>`来表示它：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And the usage of this function can be shown like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的使用可以展示如下：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At first glance, the identity function seems useless, but it plays a big role
    in mathematical proofs in functional programming. Returning to functors, the Identity
    law means that if we map the identity function to our container, we should return
    the same result. Let’s move on to the second law.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，`identity`函数似乎没有用，但在函数式编程中的数学证明中它起着重要作用。回到函子，恒等定律意味着如果我们将恒等函数映射到我们的容器上，我们应该得到相同的结果。让我们继续讨论第二个定律。
- en: Composition law
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合定律
- en: 'This law states that either we compose two functions and then map the result
    over our container or map these functions consequently; the result will be the
    same. To understand how it can be applied to our code, let’s first create two
    functions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定律指出，要么我们将两个函数组合起来，然后将结果映射到我们的容器上，要么依次映射这些函数；结果将是相同的。为了理解它如何应用于我们的代码，让我们首先创建两个函数：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'One function adds pages to the book and returns it; another appends a subtitle
    to the book’s title and returns the result. Quite simple, right? Now, with the
    help of these functions, we can express our Composition law in code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数向书中添加页面并返回它；另一个向书的标题添加副标题并返回结果。相当简单，对吧？现在，借助这些函数，我们可以用代码表达我们的组合定律：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can understand from the output, the resulting collections are equal, thus
    our `List<Book>` container abides by the Composition law.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从输出中可以理解的，生成的集合是相等的，因此我们的`List<Book>`容器遵守组合定律。
- en: Creating our own functor
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们自己的函子
- en: 'Note that a container doesn’t need to contain a set of elements to be considered
    a functor. Let’s recall the `Result` type we used in [*Chapter 5*](B21069_05.xhtml#_idTextAnchor221)
    and make an enhanced version of it by adding the `Map` method to be able to apply
    functions to the inner value:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一个容器不需要包含一组元素就可以被视为函子。让我们回忆一下在[*第五章*](B21069_05.xhtml#_idTextAnchor221)中使用的`Result`类型，并通过添加`Map`方法来增强它，以便能够应用于内部值：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `Map` method applies the incoming function to the value if the container
    holds a value; otherwise, no function is called and the error result is returned.
    And as the `Result` type now can apply functions to the underlying value, it starts
    to obey the two functor laws. Let’s see that with the following example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`方法在容器包含值时将传入的函数应用于该值；否则，不调用任何函数，并返回错误结果。由于`Result`类型现在可以对底层值应用函数，它开始遵守两个函子定律。让我们通过以下示例来查看：'
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Although we cannot directly retrieve the inner value for now, it can be seen
    using the debugger or the `Dump()` extension method in `LinqPad`. And as we can
    see, our `Result` type became a functor.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在不能直接检索内部值，但可以使用调试器或`LinqPad`中的`Dump()`扩展方法来查看。正如我们所看到的，我们的`Result`类型变成了一个函子。
- en: Functor benefits
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函子优势
- en: 'Transforming our `Result<TValue, TError>` type into a functor offers several
    concise advantages, enhancing error handling and operational outcomes in functional
    programming:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的`Result<TValue, TError>`类型转换为函子提供了几个简洁的优点，增强了函数式编程中的错误处理和操作结果：
- en: '**Streamlined error handling**: Integrates both success and error outcomes
    in one structure, simplifying error management'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化的错误处理**：将成功和错误结果整合到一个结构中，简化错误管理'
- en: '**Composable operations**: Facilitates chaining operations on successful results,
    with automatic error propagation, improving code reusability'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可组合的操作**：促进在成功结果上链式操作，具有自动错误传播，提高代码的可重用性'
- en: '`Map` function’s intent is clear—transform the value on success, or bypass
    an error, making the code more understandable'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map`函数的意图很明确——在成功时转换值，或在出错时跳过，使代码更易于理解'
- en: '**Type safety and clarity**: The explicit success and error states in the type
    signature enhance predictability and safety, ensuring comprehensive outcome handling'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型安全和清晰**：类型签名中的显式成功和错误状态增强了可预测性和安全性，确保全面处理结果'
- en: Sounds exciting, right? And we can make our class even better by making it an
    applicative functor.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很吸引人，对吧？我们可以通过将其制作成一个应用函子来使我们的类变得更好。
- en: Applicative functors
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用函子
- en: An **applicative functor** is a type of functor that allows for the application
    of a function encapsulated within a functor to a value that is also wrapped within
    a functor. This concept translates into enabling operations that can gracefully
    handle multiple layers of computational contexts, such as error handling or asynchronous
    operations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用函子**是一种允许将封装在函子内的函数应用于也封装在函子内的值的函子类型。这个概念可以转化为实现能够优雅地处理多层计算上下文的操作，例如错误处理或异步操作。'
- en: While functors allow us to apply a function to a wrapped value, applicative
    functors extend this capability by enabling the application of functions that
    are themselves wrapped in a context. This distinction is crucial for operations
    where the function application itself may result in a computational context, such
    as failure, delay, or uncertainty. Let’s look at the difference using the book
    publishing system example.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当函子允许我们将函数应用于封装的值时，应用函子通过允许将函数本身封装在上下文中来扩展这种能力。这种区别对于函数应用本身可能导致计算上下文（如失败、延迟或不确定性）的操作至关重要。让我们通过图书出版系统示例来看看这种区别。
- en: Consider a function that calculates royalties based on book sales and another
    function that adjusts these royalties based on market conditions. Both functions
    might fail due to various reasons, and their outputs might be wrapped in `Result`
    types to signify success or failure. Applicative functors allow us to apply these
    potentially failing functions to potentially failing inputs, orchestrating complex
    operations that gracefully handle multiple layers of potential failures.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个基于书籍销售计算版税的函数，以及另一个根据市场条件调整这些版税的函数。这两个函数可能由于各种原因而失败，它们的输出可能被封装在`Result`类型中以表示成功或失败。应用函子允许我们将这些可能失败的函数应用于可能失败的输入，协调复杂操作，优雅地处理多层潜在失败。
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, `CalculateRoyaltiesFunc` is a function that takes the number
    of sales and calculates the royalties as 10% of the sales. `AdjustRoyaltiesFunc`
    is a function that takes an initial royalty amount and adjusts it by a factor
    of `1.05` to account for market conditions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`CalculateRoyaltiesFunc`是一个函数，它接受销售数量并计算版税为销售额的10%。`AdjustRoyaltiesFunc`是一个函数，它接受一个初始版税金额，并通过乘以`1.05`的因子来调整以反映市场条件。
- en: 'Now, let’s assume we have a `Result<int, string>` representing the number of
    book sales, which could also fail:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们有一个`Result<int, string>`表示书籍销售数量，它也可能失败：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To calculate the adjusted royalties, we first apply `CalculateRoyaltiesFunc`
    to `salesResult`, and then apply `AdjustRoyaltiesFunc` to the result:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算调整后的版税，我们首先将`CalculateRoyaltiesFunc`应用于`salesResult`，然后将`AdjustRoyaltiesFunc`应用于结果：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For the sake of better understanding, let’s pretend that our first function
    returns an error:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，让我们假设我们的第一个函数返回一个错误：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we try to calculate `royaltiesResult` again, `IsSuccess` will be `false`
    and the `Error` property will contain the string `"Can't calculate royalties"`.
    The same situation will happen if the `AdjustRoyaltiesFunc` call results in an
    error. Both methods can fail; however, thanks to the `Apply` method, we can call
    them both in a safe manner. Sounds great, but what does this `Apply` method look
    like?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次尝试计算 `royaltiesResult`，`IsSuccess` 将为 `false`，并且 `Error` 属性将包含字符串 `"Can't
    calculate royalties"`。如果 `AdjustRoyaltiesFunc` 调用导致错误，也会发生相同的情况。两种方法都可能失败；然而，多亏了
    `Apply` 方法，我们可以以安全的方式调用它们。听起来很棒，但这个 `Apply` 方法看起来是什么样子呢？
- en: The Apply method implementation
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用方法实现
- en: 'To implement the applicative functor pattern, we introduced the `Apply` method.
    This method takes `Result` that contains a function and applies it to the value
    inside the current `Result` instance if both are successful. If either the function
    or the value is wrapped in a failed `Result`, the `Apply` method propagates the
    error:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现应用函子模式，我们引入了 `Apply` 方法。该方法接受包含函数的 `Result`，并在当前 `Result` 实例中的值成功的情况下将其应用于该值。如果函数或值被包装在失败的
    `Result` 中，`Apply` 方法会传播错误：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, nothing special here. First, we ensure that both the current
    container state and the incoming `Result<Func<TValue, TResult>, TError>` state
    are successful. Then, we return a new `Result<TResult, TError>`. If either of
    the `IsSuccess` properties is `false`, a corresponding error is returned. However,
    an `Apply` method is not enough for a class to be considered an applicative functor;
    it must abide by applicative functor laws.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里没有什么特别之处。首先，我们确保当前容器状态和传入的 `Result<Func<TValue, TResult>, TError>` 状态都是成功的。然后，我们返回一个新的
    `Result<TResult, TError>`。如果任一 `IsSuccess` 属性为 `false`，则返回相应的错误。然而，一个类要被认为是应用函子，不仅仅需要一个
    `Apply` 方法；它必须遵守应用函子定律。
- en: As Steve was grasping the concept of functors, Julia introduced a new challenge.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Steve 正在掌握函子的概念时，Julia 提出了一个新挑战。
- en: 'Julia: *Now, what if you wanted to apply multiple upgrades to a tower at once,
    but some upgrades might fail? This is where applicative functors come* *in handy.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Julia：*现在，如果你想要一次性应用多个升级到塔上，但有些升级可能会失败，这时应用函子就派上用场了。*
- en: 'Steve: *Multiple upgrades at once? That could really streamline my* *upgrade
    system!*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Steve：*一次性应用多个升级？这真的可以简化我的升级系统！*
- en: Applicative functor laws
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用函子定律
- en: 'There are four applicative functor laws: Identity, Homomorphism, Interchange,
    and Composition. Let’s go through each of them.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个应用函子定律：恒等、同态、交换和组合。让我们逐一介绍它们。
- en: Identity law
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恒等定律
- en: 'The Identity law states that applying the identity function to a `Result`-wrapped
    value should yield the original `Result` without any change:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 恒等定律指出，将恒等函数应用于 `Result` 包装的值应该产生没有任何变化的原始 `Result`：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Homomorphism law
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同态定律
- en: 'This law demonstrates that applying a function to a value and then wrapping
    it is equivalent to wrapping the value and then applying the function within the
    `Result`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定律表明，将一个函数应用于一个值然后包装它，与先包装值然后在该 `Result` 中应用函数是等价的：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Interchange law
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交换定律
- en: This law indicates that applying a wrapped function to a wrapped value should
    be equivalent to applying a function that applies its argument to the wrapped
    value.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定律表明，将包装的函数应用于包装的值应该等同于应用一个将它的参数应用于包装值的函数。
- en: 'For this law, we would need to extend our `Result` type to support applying
    a `Result`-wrapped function to a `Result`-wrapped value, which is not directly
    supported by the provided `Result` type structure. However, the conceptual application
    would look something like this in a system that supports it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个定律，我们需要扩展我们的 `Result` 类型以支持将一个 `Result` 包装的函数应用于一个 `Result` 包装的值，这并不是由提供的
    `Result` 类型结构直接支持的。然而，在一个支持这种功能的系统中，概念上的应用可能看起来像这样：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Composition law
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合定律
- en: The Composition law ensures that when we compose two or more functions and apply
    them to a functor, the order of function application does not affect the outcome.
    This property, known as associativity, is central to the Composition law. It ensures
    that if we have functions f, g, and h, composing them and then applying them to
    a functor F yields the same result regardless of how the functions are grouped
    during composition.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 组合定律确保当我们组合两个或更多函数并将它们应用于一个函子时，函数应用的顺序不会影响结果。这个称为结合性的属性是组合定律的核心。它确保如果我们有函数 f、g
    和 h，将它们组合并应用于函子 F 的结果，无论在组合过程中如何分组函数，都是相同的。
- en: For instance, consider two functions, f(x) = x + 1 and g(x) = x * 3\. According
    to the Composition law, composing f and g and then applying them to a value inside
    a functor should yield the same result as applying f to the functor and then g.
    Expressed mathematically, F.map(g(f(x))) is equivalent to F.map(f).map(g).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑两个函数，f(x) = x + 1 和 g(x) = x * 3。根据组合定律，将 f 和 g 组合并应用于函子内部的值应该产生与将 f 应用到函子然后
    g 相同的结果。用数学表达式来说，F.map(g(f(x))) 等价于 F.map(f).map(g)。
- en: This associative property allows us to reason about composed functions confidently,
    knowing that the grouping of function applications does not impact the final outcome
    when applied to a functor. This principle enhances the predictability and reliability
    of functional programming, allowing developers to compose complex transformations
    succinctly and safely.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结合性质允许我们自信地推理组合函数，知道函数应用分组不会影响最终结果，当应用于函子时。这一原则增强了函数式编程的可预测性和可靠性，允许开发者简洁且安全地组合复杂的转换。
- en: 'For this law, similar to the Interchange law, we need a mechanism to compose
    functions within the `Result` context, which our current `Result` type definition
    does not directly support. Conceptually, it would look like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个定律，类似于交换定律，我们需要一个机制在 `Result` 上下文中组合函数，而我们的当前 `Result` 类型定义并不直接支持。从概念上讲，它看起来像这样：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see our `Result` type abides by all these laws and can be counted
    as an applicative functor. From here, we need to take one more step to make it
    a monad.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们的 `Result` 类型遵循所有这些定律，可以被视为一个应用函子。从这里，我们需要再迈出一步，使其成为一个单子。
- en: Monads
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单子
- en: Steve was excited about functors but still struggled to see their full potential
    in his game logic. Julia knew it was time to introduce monads.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫对函子很兴奋，但仍然难以看到它们在他游戏逻辑中的全部潜力。朱莉娅知道是时候引入单子了。
- en: 'Julia: *Let’s take your game’s upgrade system a step further. Imagine a series
    of operations: checking the player’s gold, deducting the cost, and applying the
    upgrade. Each step depends on the previous one succeeding. This is where* *monads
    shine.*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Julia：*让我们将你的游戏升级系统再向前推进一步。想象一系列操作：检查玩家的金币，扣除费用，并应用升级。每一步都依赖于前一步的成功。这正是单子的优势所在。*
- en: 'Steve: *That sounds exactly like what I need for my upgrade system. How do
    monads* *handle this?*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：*这听起来正是我升级系统所需要的。单子是如何处理这个问题的？*
- en: A **monad** represents an evolution of the concepts we explored with functors
    and applicative functors. While a functor allows us to map a function over a wrapped
    value and an applicative functor enables applying wrapped functions to wrapped
    values, monads introduce the ability to chain operations in a way that handles
    the context of those operations—be it errors, lists, options, or other computational
    contexts. Thus, we can say that a monad is an applicative functor that adheres
    to some additional laws.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**单子**代表了我们对函子和应用函子概念探索的演变。虽然函子允许我们将函数映射到包装的值上，而应用函子使得我们可以将包装的函数应用于包装的值，但单子引入了以处理这些操作上下文的能力——无论是错误、列表、选项或其他计算上下文。因此，我们可以说单子是一个遵循某些额外定律的应用函子。'
- en: The essence of a monad is its ability to flatten layers of wrapping caused by
    applying functions that return wrapped values. This is crucial in avoiding deeply
    nested structures when performing multiple operations in sequence. Let’s break
    down this concept with an example from our book publishing system.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 单子的本质在于其能够展开由返回包装值的函数应用所引起的包装层。这在执行多个操作时避免深层嵌套结构至关重要。让我们用一个来自我们出版系统的例子来分解这个概念。
- en: Imagine a scenario where we need to fetch a manuscript, edit it, and then format
    it for publishing. Each of these operations might fail and return `Result<TValue,
    TError>`, leading to nested `Result<Result<...>>` types. Monads allow us to perform
    these operations sequentially in a cleaner way.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，我们需要获取一份手稿，编辑它，然后格式化它以供出版。这些操作中的每一个都可能失败并返回 `Result<TValue, TError>`，导致嵌套的
    `Result<Result<...>>` 类型。单子允许我们以更干净的方式按顺序执行这些操作。
- en: The Bind method
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Bind` 方法'
- en: 'The key to monads is the `Bind` method (often called `flatMap` or `SelectMany`
    in different languages and frameworks). This method applies a function to the
    wrapped value, which returns the same kind of wrapper, and then flattens the result:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 单子的关键在于 `Bind` 方法（在不同的语言和框架中通常被称为 `flatMap` 或 `SelectMany`）。此方法将一个函数应用于包装的值，返回相同类型的包装器，然后展开结果：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With `Bind`, we can chain operations without nesting. Let’s apply this to our
    publishing system:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Bind`，我们可以链式操作而不需要嵌套。让我们将其应用于我们的出版系统：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this pipeline, each step is applied only if the previous one succeeds, with
    any failure immediately short-circuiting the chain.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个管道中，只有前一个步骤成功时才会应用每个步骤，任何失败都会立即短路链。
- en: Monad laws
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单子法则
- en: 'As well as functors, monads must satisfy their laws to ensure consistency and
    predictability and there are three of them: Left Identity, Right Identity, and
    Associativity.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了函子，单子也必须满足其法则以确保一致性和可预测性，它们有三个：左恒等、右恒等和结合律。
- en: Left Identity
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 左恒等
- en: 'Wrapping a value and then binding with a function is the same as just applying
    the function to the value:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 包装一个值然后绑定到一个函数与直接应用该函数到值相同：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Right Identity
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 右恒等
- en: 'Binding a wrapped value with a function that simply re-wraps the value should
    yield the original wrapped value:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个简单地重新包装值的函数绑定包装的值应该产生原始的包装值：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Associativity
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结合律
- en: 'The order of binding operations should not matter:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定操作的顺序不应影响：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Utilizing monads
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用单子
- en: 'Monads shine in operations that involve sequences of computations where each
    step might fail or produce a new context. In our book publishing system, we can
    extend this pattern to handle user input validation, database transactions, or
    network calls, ensuring our code remains clean, readable, and maintainable:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 单子在涉及计算序列的操作中特别出色，其中每个步骤可能会失败或产生新的上下文。在我们的图书出版系统中，我们可以扩展这个模式来处理用户输入验证、数据库事务或网络调用，确保我们的代码保持清洁、可读和可维护：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This approach not only simplifies error handling by propagating errors automatically
    but also keeps the happy path code clear and straightforward, without the need
    for manual checks or nested conditionals.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不仅通过自动传播错误简化了错误处理，而且使快乐的路径代码保持清晰和直接，无需手动检查或嵌套条件。
- en: Monads are like smart containers that help manage a series of steps, particularly
    when you’re dealing with tricky situations such as errors or tasks that take time
    to complete. By getting a handle on functors and then leveling up to monads, you
    can make your code not only more expressive but also easier to maintain and more
    reliable. Think about how we simplified tasks in our book publishing examples;
    monads and their friends can really untangle complicated logic and make dealing
    with mistakes a lot smoother, making your whole code base friendlier and less
    daunting to work with.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 单子就像智能容器，有助于管理一系列步骤，尤其是当你处理诸如错误或需要时间完成的任务等棘手情况时。通过掌握函子并提升到单子，你可以使你的代码不仅更具表现力，而且更容易维护和更可靠。想想我们如何在我们的图书出版示例中简化任务；单子和它们的伙伴们可以真正解开复杂的逻辑，使处理错误变得更加顺畅，使整个代码库更加友好，更容易工作。
- en: Key takeaways
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键要点
- en: 'As we conclude this chapter on functors and monads, let’s take a moment to
    summarize what we’ve learned:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结关于函子和单子的这一章时，让我们花点时间总结一下我们学到了什么：
- en: '**Fundamental concept of functors**: Functors are integral to functional programming
    for data manipulation. They act as “magic boxes” that allow us to apply a function
    to the data they hold, transforming the contents while maintaining the original
    structure.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函子的基本概念**：函子对于数据处理的功能性编程至关重要。它们充当“魔法盒子”，允许我们对它们所持有的数据进行函数应用，在保持原始结构的同时转换其内容。'
- en: '**Not all containers are functors**: For a data container to be considered
    a functor, it must adhere to two critical laws: the Identity law and the Composition
    law. These laws ensure that functors operate predictably and consistently within
    their intended paradigms.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并非所有容器都是函子**：要使数据容器被视为函子，它必须遵守两个关键法则：恒等律和组合律。这些法则确保函子在其预期范式中操作时具有可预测性和一致性。'
- en: '**Identity law**: The Identity law emphasizes that mapping an identity function
    (a function that returns its input) over a functor should leave the functor unchanged.
    This law underscores the non-intrusive nature of functor transformations.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恒等律**：恒等律强调，将恒等函数（返回其输入的函数）映射到函子上应该使函子保持不变。这条法则强调了函子转换的非侵入性。'
- en: '**Composition law**: The Composition law asserts that the order in which functions
    are composed and applied to a functor does not affect the final outcome. This
    law highlights the composability and flexibility of functors in functional programming.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合律**：组合律断言，函数组合和应用于函子的顺序不会影响最终结果。这条法则突出了函数在功能性编程中的可组合性和灵活性。'
- en: '`Result<TValue, TError>` type example, we explored how functors can be practically
    implemented to enhance error handling and operational outcomes. The `Map` method
    demonstrated the application of functions to the encapsulated value within the
    functor, adhering to the functor laws.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Result<TValue, TError>`类型的示例中，我们探讨了如何实际实现函子以增强错误处理和操作结果。`Map`方法展示了函数在函子封装的值中的应用，遵循函子定律。
- en: '**Applicative functors**: The chapter also introduced the concept of applicative
    functors, which build upon basic functors by allowing the application of functions
    wrapped within a functor to values also wrapped within a functor. This capability
    enables handling multiple layers of computational contexts gracefully.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用函子**：本章还介绍了应用函子的概念，它通过允许将包裹在函子中的函数应用到也包裹在函子中的值上，在基本函子之上构建。这种能力使得优雅地处理多层计算上下文成为可能。'
- en: '**Applicative functor laws**: Applicative functors are governed by additional
    laws, including Identity, Homomorphism, Interchange, and Composition. These laws
    further ensure the reliable and predictable behavior of applicative functors in
    complex operations.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用函子定律**：应用函子受额外的定律约束，包括恒等性、同构性、交换性和结合性。这些定律进一步确保了应用函子在复杂操作中的可靠和可预测的行为。'
- en: '**Monads**: The discussion set the stage for the evolution into monads, which
    extend the concepts of functors and applicative functors by enabling the chaining
    of operations that handle the context of those operations, such as errors or asynchronous
    computations.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单子**：讨论为函子和应用函子的概念演变到单子奠定了基础，单子通过允许操作链的连接来扩展函子和应用函子的概念，这些操作处理操作的上下文，如错误或异步计算。'
- en: In closing, functors and monads are not just theoretical constructs; they are
    pragmatic tools that can transform your code from ordinary to exceptional. Embrace
    the opportunities they offer, and watch as your programming skills reach new heights
    of expressiveness and efficiency. Happy coding!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，函子和单子不仅仅是理论结构；它们是实用的工具，可以将你的代码从普通转变为卓越。拥抱它们带来的机会，看看你的编程技能如何达到新的表达性和效率的高度。编码愉快！
- en: Exercises
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: After explaining the concepts, Julia challenged Steve to apply what he’d learned.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释了这些概念之后，Julia 挑战 Steve 应用他所学的知识。
- en: 'Julia: *Now that you understand the basics, why don’t you try refactoring your
    game’s upgrade system using monads? It should make your code more robust and easier
    to* *reason about.*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Julia：*既然你已经了解了基础知识，为什么不尝试使用单子重构你的游戏升级系统呢？这应该会使你的代码更加健壮，并且更容易* *理解*。
- en: 'Steve: *That’s a great idea! I can already see how this could simplify some
    of my more complex* *game logic.*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Steve：*这是一个很好的想法！我已能看到这如何简化我的一些更复杂的* *游戏逻辑*。
- en: Exercise 1
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1
- en: 'Given a `Result<List<Tower>, string>` type that represents a list of towers,
    where `Tower` is a class containing properties such as `Id`, `Name`, and `Damage`,
    the task is to use the functor concept to apply a function to each tower that
    appends “(Upgraded)” to the end of its name to indicate that the tower has been
    upgraded:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个表示塔列表的`Result<List<Tower>, string>`类型，其中`Tower`是一个包含`Id`、`Name`和`Damage`等属性的类，任务是用函子概念将一个函数应用到每个塔上，在其名称末尾添加“(Upgraded)”以指示塔已被升级：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Exercise 2
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2
- en: 'Imagine you have two functions wrapped in the `Result` type: `Result<Func<Tower,
    bool>, string> ValidateDamage` checks whether a tower’s damage is within acceptable
    limits, and `Result<Func<Tower, bool>, string> ValidateName` checks whether the
    tower’s name meets certain criteria. Given a `Result<Tower, string>` representing
    a single tower, use applicative functors to apply both validation functions to
    the tower, ensuring both validations pass:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有两个被`Result`类型包裹的函数：`Result<Func<Tower, bool>, string> ValidateDamage`用于检查塔的伤害是否在可接受的范围内，而`Result<Func<Tower,
    bool>, string> ValidateName`用于检查塔的名称是否符合某些标准。给定一个表示单个塔的`Result<Tower, string>`，使用应用函子将这两个验证函数应用到塔上，确保两个验证都通过：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Exercise 3
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3
- en: 'Given a sequence of operations needed to upgrade a tower—`FetchTower`, `UpgradeTower`,
    and `DeployTower`—with each potentially failing and returning `Result<Tower, string>`,
    use the monad concept to chain these operations together for a given tower ID.
    Ensure that if any step fails, the entire operation short-circuits and returns
    the error:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一系列用于升级塔的操作——`FetchTower`、`UpgradeTower`和`DeployTower`——每个操作都可能失败并返回`Result<Tower,
    string>`，使用单子概念将这些操作链在一起，针对给定的塔ID。确保如果任何步骤失败，整个操作短路并返回错误：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These exercises aim to help you reinforce the concepts learned throughout this
    chapter and understand how to apply them in different scenarios.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习旨在帮助你们巩固本章学到的概念，并理解如何在不同的场景中应用它们。
- en: Solutions
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: I hope you did all the exercises and just want to check out my solutions. If
    not, don’t worry, everything comes with experience. Now, let’s look at the solutions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你们都完成了所有的练习，只是想看看我的解决方案。如果没有，不要担心，一切都会随着经验而来。现在，让我们看看解决方案。
- en: Exercise 1
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1
- en: 'Use the `Map` method to apply a function to each tower in the list that appends
    “(Upgraded)” to its name:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Map` 方法将一个函数应用到列表中的每个塔上，该函数将其名字追加 “(Upgraded)”：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This solution demonstrates how functors can encapsulate data and behavior,
    allowing for operations on contained data while preserving the context (success
    or failure) of the entire operation:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案展示了函子如何封装数据和行为，允许在包含的数据上执行操作，同时保留整个操作（成功或失败）的上下文：
- en: '`towersResult.Map(...)`: This line uses the `Map` function, which is fundamental
    to the functor pattern. It applies a given function to the contained value if
    the `Result` is successful, without affecting the outer `Result` structure.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`towersResult.Map(...)`: 这一行使用了 `Map` 函数，这是函子模式的基本功能。如果 `Result` 成功，它将应用给定的函数到包含的值上，而不影响外部的
    `Result` 结构。'
- en: '`towers.Select(tower => ...)`: Inside `Map`, a `Select` LINQ method iterates
    over each `Tower` object in the list, applying a lambda function that modifies
    the `Name` property.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`towers.Select(tower => ...)`: 在 `Map` 中，`Select` LINQ 方法遍历列表中的每个 `Tower` 对象，应用一个修改
    `Name` 属性的 lambda 函数。'
- en: '`tower.Name += " (Upgraded)"`: This operation appends `"(Upgraded)"` to the
    name of each tower, indicating that it has been upgraded.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tower.Name += " (Upgraded)"`：这个操作将 `"(Upgraded)"` 追加到每个塔的名字上，表示它已经被升级。'
- en: Exercise 2
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2
- en: 'The applicative functor pattern extends the functor’s capabilities by allowing
    functions themselves to be wrapped in a context (such as `Result`). This solution
    uses this capability to apply multiple validation functions, wrapped in `Result`
    types, to a single video also wrapped in `Result`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 应用函子模式通过允许函数本身被封装在上下文中（如 `Result`）来扩展函子的功能。这个解决方案使用这种能力将多个封装在 `Result` 类型中的验证函数应用到单个也封装在
    `Result` 中的视频上：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we handle multiple potential failure points in a composable manner, showcasing
    the power of applicative functors in functional error handling:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们以可组合的方式处理多个潜在失败点，展示了在函数式错误处理中应用函子的强大能力：
- en: '`towerResult.Apply(ValidateDamage)` and `towerResult.Apply` **(ValidateName)**:
    These lines demonstrate the applicative functor’s `Apply` method. It takes `Result`
    containing a function and applies it to another `Result` containing a value, effectively
    unwrapping both and applying the function to the value.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`towerResult.Apply(ValidateDamage)` 和 `towerResult.Apply` **(ValidateName)**：这些行展示了应用函子的
    `Apply` 方法。它接受包含函数的 `Result` 并将其应用于另一个包含值的 `Result`，有效地展开两者并将函数应用于值。'
- en: The chaining of `Bind` and `Map` ensures that if any validation fails, the entire
    validation process short-circuits and returns the failure. Otherwise, it combines
    the results of both validations into a single Boolean value.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bind` 和 `Map` 的链式调用确保了如果任何验证失败，整个验证过程将短路并返回失败。否则，它将两个验证的结果合并成一个布尔值。'
- en: Exercise 3
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3
- en: 'Monads extend the concept of applicative functors by allowing the chaining
    of operations that return a wrapped type, such as `Result<Tower, string>`, enabling
    a seamless and error-propagating sequence of operations:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 单子通过允许返回封装类型的操作链（如 `Result<Tower, string>`）来扩展应用函子的概念，实现操作的无缝和错误传播序列：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This solution shows monads’ ability to manage sequences of dependent operations
    within a context, making error handling more intuitive and linear, and thus significantly
    simplifying complex business logic:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案展示了单子管理上下文中依赖操作序列的能力，使错误处理更加直观和线性，从而显著简化了复杂业务逻辑：
- en: '`FetchTower(towerId).Bind(UpgradeTower).Bind(DeployTower)`: This line illustrates
    the essence of monads through the `Bind` method. Each function in the chain (`FetchTower`,
    `UpgradeTower`, and `DeployTower`) potentially returns a `Result<Tower, string>`,
    and `Bind` ensures that each subsequent function is only executed if the previous
    one succeeded.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FetchTower(towerId).Bind(UpgradeTower).Bind(DeployTower)`：这一行通过 `Bind` 方法展示了单子的本质。链中的每个函数（`FetchTower`、`UpgradeTower`
    和 `DeployTower`）可能返回一个 `Result<Tower, string>`，而 `Bind` 确保只有前一个函数成功时，后续的函数才会执行。'
- en: The monadic pattern here guarantees that if any step in the process fails, the
    error is immediately propagated through the chain, bypassing subsequent steps
    and returning the failure result.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里的单调模式保证了如果在过程中任何一步失败，错误会立即通过链传播，绕过后续步骤并返回失败结果。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we discussed functors and their role in functional programming.
    We started with the basics, explaining that functors are like smart containers.
    They can hold data and also apply a function to that data while keeping their
    original shape.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了函子及其在函数式编程中的作用。我们从基础知识开始，解释说函子就像智能容器。它们可以持有数据，并且可以在保持其原始形状的同时对数据进行函数应用。
- en: 'We looked at how functors work, showing how they let us run functions on the
    data they hold without needing to unpack and repack the container. We also covered
    the two main rules that functors follow: the Identity and Composition laws.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了函子的运作方式，展示了它们如何允许我们在不拆包和重新打包容器的情况下对它们持有的数据进行函数应用。我们还涵盖了函子遵循的两个主要规则：恒等性和组合律。
- en: Through examples, we saw how functors can be used in different situations, such
    as working with lists or handling errors more smoothly. We explored creating our
    own functors, which opens up new ways to tailor our code to fit exactly what we
    need. We made the full journey from functors to applicative functors and monads,
    learned about the laws that each of these “containers” adhere to, and saw them
    in some practical scenarios.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过示例，我们看到了函子可以在不同情况下使用，例如处理列表或更平滑地处理错误。我们探讨了创建自己的函子，这为定制我们的代码以适应我们的需求提供了新的方法。我们从函子到应用函子和单子的完整旅程，了解了每个这些“容器”遵循的法则，并在一些实际场景中看到了它们的应用。
- en: As we wrap up this chapter, you should have a solid foundation in using functors
    and monads in your projects. They’re a simple yet powerful tool that can make
    a big difference in how you approach coding. Next up, in [*Chapter 8*](B21069_08.xhtml#_idTextAnchor360),
    *Recursion and Tail Calls*, we’ll dive into the recursion domain, where functions
    call themselves, and look at how tail calls can make recursion more efficient.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的结束，你应该已经对在项目中使用函子和单子有了坚实的基础。它们是简单而强大的工具，可以在你处理编码方式上产生重大影响。接下来，在第[*第8章*](B21069_08.xhtml#_idTextAnchor360)中，*递归和尾调用*，我们将深入递归领域，了解函数如何调用自身，并探讨尾调用如何使递归更高效。
- en: Part 3:Practical Functional Programming
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：实用函数式编程
- en: In this part, we move from theory to practice, exploring how to apply functional
    programming concepts to real-world scenarios. We’ll start with recursion and tail
    calls, learning how to write efficient recursive functions. Then, we’ll explore
    currying and partial application, techniques that allow you to create more flexible
    and reusable functions. Finally, we’ll look at how to combine functions to create
    powerful data processing pipelines, bringing together many of the concepts learned
    throughout the book.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分中，我们从理论转向实践，探索如何将函数式编程概念应用于现实世界场景。我们将从递归和尾调用开始，学习如何编写高效的递归函数。然后，我们将探讨柯里化和部分应用，这些技术允许你创建更灵活和可重用的函数。最后，我们将探讨如何组合函数以创建强大的数据处理管道，将本书中学到的许多概念结合起来。
- en: 'This part has the following chapters:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 8*](B21069_08.xhtml#_idTextAnchor360)*, Recursion and Tail Calls*'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B21069_08.xhtml#_idTextAnchor360)*，递归和尾调用*'
- en: '[*Chapter 9*](B21069_09.xhtml#_idTextAnchor397)*, Currying and Partial Application*'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B21069_09.xhtml#_idTextAnchor397)*，柯里化和部分应用*'
- en: '[*Chapter 10*](B21069_10.xhtml#_idTextAnchor426)*, Pipelines and Composition*'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B21069_10.xhtml#_idTextAnchor426)*，管道和组合*'
