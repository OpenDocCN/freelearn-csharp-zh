- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Movement, Camera Controls, and Collisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first things a player does when starting a new game is to try out
    character movement (if, of course, the game has a moveable character) and camera
    controls. Not only is this exciting, but it lets your player know what kind of
    gameplay they can expect. The character in *Hero Born* will be a capsule object
    that can be moved and rotated using the `W`, `A`, `S`, `D`, or arrow keys, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by learning how to manipulate the player object's `Transform` component
    and then replicate the same player control scheme using applied force. This produces
    a more realistic movement effect. When we move the player, the camera will follow
    along from a position that is slightly behind and above the player, making aiming
    easier when we implement the shooting mechanic. Finally, we'll explore how collisions
    and physical interactions are handled by Unity's physics system by working with
    our item pickup Prefab.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this will come together at a playable level, albeit without any shooting
    mechanics just yet. It''s also going to give us our first taste of C# being used
    to program game features by tying together the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing player movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving the player with the `Transform` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting camera behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the Unity physics system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing player movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you're deciding on how best to move your player character around your virtual
    world, consider what's going to look the most realistic and not run your game
    into the ground with expensive computations. This is somewhat of a trade-off in
    most cases, and Unity is no different.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three most common ways of moving a `GameObject` and their results are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Option A**: Use a `GameObject`''s `Transform` component for movement and
    rotation. This is the easiest solution and the one we''ll be working with first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Option B**: Use real-world physics by attaching a **Rigidbody** component
    to a `GameObject` and apply force in code. `Rigidbody` components add simulated
    real-world physics to any `GameObject` they are attached to. This solution relies
    on Unity''s physics system to do the heavy lifting, delivering a far more realistic
    effect. We''ll update our code to use this approach later on in this chapter to
    get a feel for both methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity suggests sticking to a consistent approach when moving or rotating a `GameObject`;
    either manipulate an object's `Transform` or `Rigidbody` component, but never
    both at the same time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Option C**: Attach a ready-made Unity component or Prefab, such as Character
    Controller or First Person Controller. This cuts out the boilerplate code and
    still delivers a realistic effect while speeding up the prototyping time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find more information on the Character Controller component and its
    uses at [https://docs.unity3d.com/ScriptReference/CharacterController.html](https://docs.unity3d.com/ScriptReference/CharacterController.html).
  prefs: []
  type: TYPE_NORMAL
- en: The First Person Controller Prefab is available from the Standard Assets package,
    which you can download from [https://assetstore.unity.com/packages/essentials/asset-packs/standard-assets-32351](https://assetstore.unity.com/packages/essentials/asset-packs/standard-assets-32351).
  prefs: []
  type: TYPE_NORMAL
- en: Since you're just getting started with player movement in Unity, you'll start
    off using the player Transform component in the next section, and then move on
    to `Rigidbody` physics later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the player with the Transform component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want a third-person adventure setup for *Hero Born*, so we'll start with
    a capsule that can be controlled with keyboard input and a camera to follow the
    capsule as it moves. Even though these two GameObjects will work together in the
    game, we'll keep them and their scripts separate for better control.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can do any scripting, you'll need to add a player capsule to the scene,
    which is your next task.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a nice player capsule in just a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **+** | **3D Object** | **Capsule** from the **Hierarchy** panel and
    name it `Player`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Player` GameObject and click on **Add Component** at the bottom
    of the **Inspector** tab. Search for **Rigidbody** and hit `Enter` to add it.
    We won't use this component until later, but it's good to set things up properly
    at the beginning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expand the **Constraints** property at the bottom of the **Rigidbody** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the boxes for **Freeze Rotation** on the **X**, **Y**, and **Z** axes
    so the player can't be rotated in any way other than through the code we'll write
    later on:![](img/B17573_07_01.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 7.1: Rigidbody component'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the `Materials` folder in the **Project** panel and click on **Create**
    | **Material**. Name it `Player_Mat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Player_Mat` in the **Hierarchy**, then change the **Albedo** property
    in the **Inspector** to a bright green and drag the material to the **Player**
    object in the **Hierarchy** panel:![](img/B17573_07_02.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.2: Player material attached to capsule'
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ve created the **Player** object out of a capsule primitive, a Rigidbody
    component, and a new bright green material. Don''t worry about what the Rigidbody
    component is just yet—all you need to know right now is that it allows our capsule
    to interact with the physics system. We''ll go into more detail at the end of
    this chapter when we discuss how Unity''s physics system works. Before we get
    to that, we need to talk about a very important subject in 3D space: vectors.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a player capsule and camera set up, we can start looking at
    how to move and rotate a GameObject using its `Transform` component. The `Translate`
    and `Rotate` methods are part of the `Transform` class that Unity provides, and
    each needs a vector parameter to perform its given function.
  prefs: []
  type: TYPE_NORMAL
- en: In Unity, vectors are used to hold position and direction data in 2D and 3D
    spaces, which is why they come in two varieties—`Vector2` and `Vector3`. These
    can be used like any other variable type we've seen; they just hold different
    information. Since our game is in 3D, we'll be using `Vector3` objects, which
    means we'll need to construct them using *x*, *y*, and *z* values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For 2D vectors, only the *x* and *y* positions are required. Remember, the
    most up-to-date orientation in your 3D scene will be displayed in the upper-right
    graphic that we discussed in the previous chapter, *Chapter 6*, *Getting Your
    Hands Dirty with Unity*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Vector gizmos in Unity editor'
  prefs: []
  type: TYPE_NORMAL
- en: If you would like more information about vectors in Unity, refer to the documentation
    and scripting reference at [https://docs.unity3d.com/ScriptReference/Vector3.html](https://docs.unity3d.com/ScriptReference/Vector3.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we wanted to create a new vector to hold the origin position
    of our scene, we could use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All we've done here is created a new `Vector3` variable and initialized it with
    a `0` for the *x* position, `0` for the *y* position, and `0` for the *z* position,
    in that order. This spawns the player at the origin of the game arena. `Float`
    values can be written with or without a decimal, but they always need to end with
    a lowercase `f`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create directional vectors by using the `Vector2` or `Vector3`
    class properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Instead of holding a position, `ForwardDirection` references the forward direction
    in our scene along the *z* axis in the 3D space. The neat thing about using the
    Vector3 direction is that no matter which way we make the player look, our code
    will always know which way is forward. We'll look at using vectors later in this
    chapter, but for now just get used to thinking about 3D movement in terms of *x*,
    *y*, and *z* positions and directions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t worry if the concept of vectors is new to you—it''s a complicated topic.
    Unity''s vector cookbook is a great place to start: [https://docs.unity3d.com/Manual/VectorCookbook.html](https://docs.unity3d.com/Manual/VectorCookbook.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand vectors a bit more, you can start implementing the basics
    of moving the player capsule. For that, you'll need to gather player input from
    the keyboard, which is the topic of the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting player input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Positions and directions are useful in themselves, but they can't generate movement
    without input from the player. This is where the `Input` class comes in, which
    handles everything from keystrokes and mouse position to acceleration and gyroscopic
    data.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to be using the `W`, `A`, `S`, `D`, and arrow keys for movement
    in *Hero Born*, coupled with a script that allows the camera to follow where the
    player points the mouse. To do that, we'll need to understand how input axes work.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, go to **Edit** | **Project Settings** | **Input Manager** to open up
    the **Input Manager** tab shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_07_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Input Manager window'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity 2021 has a new input system that removes a lot of the coding work, making
    it easier to set up inputs as actions in the editor. Since this is a programming
    book, we''re going to do things from scratch. However, if you want to see how
    the new input system works, check out this great tutorial: [https://learn.unity.com/project/using-the-input-system-in-unity](https://learn.unity.com/project/using-the-input-system-in-unity).'
  prefs: []
  type: TYPE_NORMAL
- en: You'll see a long list of Unity's default inputs already configured, but let's
    take the **Horizontal** axis as an example. You can see that the **Horizontal**
    input axis has the **Positive** and **Negative** buttons set to `left` and `right`,
    and the **Alt** **Negative** and **Alt Positive** buttons set to the `a` and `d`
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever an input axis is queried from the code, its value will be between -1
    and 1\. For example, when the left arrow or `A` key is pushed down, the horizontal
    axis registers a -1 value. When those keys are released, the value returns to
    0\. Likewise, when the right arrow or `D` keys are used, the horizontal axis registers
    a value of 1\. This allows us to capture four different inputs for a single axis
    with only one line of code, as opposed to writing out a long `if-else` statement
    chain for each.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing input axes is as simple as calling `Input.GetAxis()` and specifying
    the axis we want by name, which is what we'll do with the `Horizontal` and `Vertical`
    inputs in the following sections. As a side benefit, Unity applies a smoothing
    filter, which makes the input frame rate independent.
  prefs: []
  type: TYPE_NORMAL
- en: Default inputs can be modified in any way you need, but you can also create
    custom axes by increasing the `Size` property in the input manager and renaming
    the copy that's been created for you. You have to increase the `Size` property
    in order to add a custom input.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start getting our player moving using Unity's input system and a custom
    locomotion script of our own.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the player
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you get the player moving, you''ll need to attach a script to the player
    capsule:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# script in the `Scripts` folder, name it `PlayerBehavior`, and
    drag it onto the **Player** capsule in the **Hierarchy** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and save:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the `this` keyword is optional. Visual Studio 2019 may suggest that you
    remove it to simplify the code, but I prefer leaving it in for clarity. When you
    have empty methods, such as `Start`, in this case, it's common to delete them
    for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a breakdown of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declares two public variables to be used as multipliers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MoveSpeed` for how fast we want the Player to go forward and backward'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RotateSpeed` for how fast we want the Player to rotate left and right'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Declares two private variables to hold inputs from the player; initially set
    with no value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`_vInput` will store the vertical axis input.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_hInput` will store the horizontal axis input.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Input.GetAxis("Vertical")` detects when the up arrow, down arrow, `W`, or
    `S` keys are pressed and multiplies that value by `MoveSpeed`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The up arrow and `W` keys return a value of 1, which will move the player in
    the forward (positive) direction.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The down arrow and `S` keys return -1, which moves the player backward in the
    negative direction.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Input.GetAxis("Horizontal")` detects when the left arrow, right arrow, `A`,
    and `D` keys are pressed and multiplies that value by `RotateSpeed`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The right arrow and `D` keys return a value of 1, which will rotate the capsule
    to the right.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The left arrow and `A` keys return -1, rotating the capsule to the left.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're wondering whether it's possible to do all the movement calculations
    on one line, the simple answer is yes. However, it's better to have your code
    broken down, even if you're the only one reading it.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Uses the `Translate` method, which takes in a `Vector3` parameter, to move
    the capsule''s Transform component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that the `this` keyword specifies the GameObject the current script
    is attached to, which, in this case, is the player capsule.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Vector3.forward` multiplied by `_vInput` and `Time.deltaTime` supplies the
    direction and speed the capsule needs to move forward or back along the *z* axis
    at the speed we''ve calculated.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Time.deltaTime` will always return the value in seconds since the last frame
    of the game was executed. It''s commonly used to smooth values that are captured
    or run in the `Update` method instead of letting it be determined by a device''s
    frame rate.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Uses the `Rotate` method to rotate the capsule''s Transform component relative
    to the vector we pass in as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Vector3.up` multiplied by `_hInput` and `Time.deltaTime` gives us the left/right
    rotation axis we want.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `this` keyword and `Time.deltaTime` here for the same reasons.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As we discussed earlier, using direction vectors in the `Translate` and `Rotate`
    functions is only one way to go about this. We could have created new Vector3
    variables from our axis inputs and used them as parameters just as easily.
  prefs: []
  type: TYPE_NORMAL
- en: When you click play, you'll be able to move the capsule forward and backward
    using the up/down arrow keys and the `W`/`S` keys, while rotating or turning with
    the left/right arrow keys and the `A`/`D` keys.
  prefs: []
  type: TYPE_NORMAL
- en: With these few lines of code, you've set up two separate controls that are frame
    rate independent and easily modified. However, our camera doesn't follow the capsule
    as it moves around, so let's fix that in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting camera behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to get one GameObject to follow another is to make one of them
    a child of the other. When an object is a child of another, the child object's
    position and rotation are relative to the parent. This means that any child object
    will move and rotate with the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: However, this approach means that any kind of movement or rotation that happens
    to the player capsule also affects the camera, which is something we don't necessarily
    want. We always want the camera to be positioned a set distance behind our player
    and always rotate to look at it, no matter what. Luckily, we can easily set the
    position and rotation of the camera relative to the capsule with methods from
    the `Transform` class. It's your task to script out the camera logic in the next
    challenge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want the camera behavior to be entirely separate from how the player
    moves, we''ll be controlling where the camera is positioned relative to a target
    we can set from the **Inspector** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# script in the `Scripts` folder, name it `CameraBehavior`, and
    drag it into **Main Camera** in the **Hierarchy** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and save it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s a breakdown of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declares a `Vector3` variable to store the distance we want between the **Main
    Camera** and the **Player** capsule:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll be able to manually set the *x*, *y*, and *z* positions of the camera
    offset in the **Inspector** because it's `public`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These default values are what I think looks best, but feel free to experiment.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creates a variable to hold the player capsule''s Transform information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will give us access to its position, rotation, and scale.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't want any other script to be able to change the camera's target, which
    is why it's `private`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Uses `GameObject.Find` to locate the capsule by name and retrieve its Transform
    property from the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This means the capsule's *x*, *y*, and *z* positions are updated and stored
    in the `_target` variable every frame.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding objects in the scene is a computationally expensive task, so it's good
    practice to only do it once in the `Start` method and store the reference. Never
    use `GameObject.Find` in the `Update` method, as that will try to continually
    find the object you're looking for and potentially crash the game.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LateUpdate` is a `MonoBehavior` method, like `Start` or `Update`, that executes
    after `Update`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since our `PlayerBehavior` script moves the capsule in its `Update` method,
    we want the code in `CameraBehavior` to run after the movement happens; this guarantees
    that `_target` has the most up-to-date position to reference.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sets the camera''s position to `_target.TransformPoint(CamOffset)` for every
    frame, which creates the following effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `TransformPoint` method calculates and returns a relative position in the
    world space.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, it returns the position of the `target` (our capsule) offset by
    `0` in the *x* axis, `1.2` in *the* y axis (putting the camera above the capsule),
    and `-2.6` in the *z* axis (putting the camera slightly behind the capsule).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `LookAt` method updates the capsule's rotation every frame, focusing on
    the Transform parameter we pass in, which, in this case, is `_target`:![](img/B17573_07_05.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.5: Capsule and following camera in Play mode'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This was a lot to take in, but it''s easier to process if you break it down
    into its chronological steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We created an offset position for the camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We found and stored the player capsule's position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We manually updated its position and rotation every frame so that it's always
    following at a set distance and looking at the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When using class methods that deliver platform-specific functionality, always
    remember to break things down to their most basic steps. This will help you to
    stay above water in new programming environments.
  prefs: []
  type: TYPE_NORMAL
- en: While the code you've written to manage player movement is perfectly functional,
    you might have noticed that it's a little jerky in places. To create a smoother,
    more realistic movement effect, you'll need to understand the basics of the Unity
    physics system, which you'll dive into next.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Unity physics system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we haven't talked about how the Unity engine works, or how
    it manages to create lifelike interactions and movement in a virtual space. We'll
    spend the rest of this chapter learning the basics of Unity's physics system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two main components that power Unity''s NVIDIA PhysX engine are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rigidbody** components, which allow GameObjects to be affected by gravity
    and add properties such as **Mass** and **Drag**. Rigidbody components can also
    be affected by an applied force if they have a Collider component attached, which
    generates more realistic movement:![](img/B17573_07_06.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 7.6: Rigidbody component in the Inspector pane'
  prefs: []
  type: TYPE_NORMAL
- en: '**Collider** components, which determine how and when GameObjects enter and
    exit each other''s physical space or simply collide and bounce away. While there
    should only be one Rigidbody component attached to a given GameObject, there can
    be several Collider components if you need different shapes or interactions. This
    is commonly referred to as a compound Collider setup:![](img/B17573_07_07.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 7.7: Box collider component in the Inspector pane'
  prefs: []
  type: TYPE_NORMAL
- en: When two Collider components interact with each other, the Rigidbody properties
    determine the resulting interaction. For example, if one GameObject's mass is
    higher than the other, the lighter GameObject will bounce away with more force,
    just like in real life. These two components are responsible for all physical
    interactions and simulated movement in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some caveats to using these components, which are best understood
    in terms of the types of movement Unity allows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Kinematic* movement happens when a Rigidbody component is attached to a GameObject,
    but it doesn''t register to the physics system in the scene. In other words, kinematic
    objects have physics interactions but don''t react to them, like a wall in real
    life. This is only used in certain cases and can be enabled by checking the **Is
    Kinematic** property of a Rigidbody component. Since we want our capsule to interact
    with the physics system, we won''t be using this kind of motion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Non-kinematic* movement is when a Rigidbody component is moved or rotated
    by applying force rather than manually changing a GameObject''s Transform properties.
    Our goal for this section is to update the `PlayerBehavior` script to implement
    this type of motion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The setup we have now, that is, manipulating the capsule's Transform component
    while using a Rigidbody component to interact with the physics system, was meant
    to get you thinking about movement and rotation in a 3D space. However, it's not
    meant for production and Unity suggests avoiding a mix of kinematic and non-kinematic
    movement in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Your next task is to use applied force to convert the current movement system
    into a more realistic locomotion experience.
  prefs: []
  type: TYPE_NORMAL
- en: Rigidbody components in motion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since our player has a Rigidbody component attached, we should let the physics
    engine control our movement instead of manually translating and rotating the Transform.
    There are two options when it comes to applying force:'
  prefs: []
  type: TYPE_NORMAL
- en: You can do it directly by using Rigidbody class methods such as `AddForce` and
    `AddTorque` to move and rotate an object, respectively. This approach has its
    drawbacks and often requires additional code to compensate for unexpected physics
    behavior such as unwanted torque or applied force during collisions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, you can use other Rigidbody class methods such as `MovePosition`
    and `MoveRotation`, which still use applied force.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll take the second route in the next section so that Unity takes care of
    the applied physics for us, but if you''re curious about manually applying force
    and torque to your GameObjects, then start here: [https://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html](https://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Either of these will give the player a more lifelike feel and allow us to add
    in jumping and dashing mechanics in *Chapter 8*, *Scripting Game Mechanics*.
  prefs: []
  type: TYPE_NORMAL
- en: If you're curious about what happens when a moving object without a Rigidbody
    component interacts with pieces of the environment that have them equipped, remove
    the component from the Player and run around the arena. Congratulations—you're
    a ghost and can walk through walls! Don't forget to add the Rigidbody component
    back, though!
  prefs: []
  type: TYPE_NORMAL
- en: The player capsule already has a Rigidbody component attached, which means that
    you can access and modify its properties. First, though, you'll need to find and
    store the component, which is your next challenge.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll need to access and store the Rigidbody component on our player capsule
    before modifying it. Update `PlayerBehavior` with the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a breakdown of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: Adds a private variable of type `Rigidbody` that will contain a reference to
    the capsule's Rigidbody component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Start` method fires when a script is initialized in a scene, which happens
    when you click on play, and should be used any time variables need to be set at
    the beginning of a class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `GetComponent` method checks whether the component type we''re looking
    for, in this case, `Rigidbody`, exists on the GameObject the script is attached
    to and returns it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the component isn't attached to the GameObject, the method will return `null`,
    but since we know there's one on the player, we won't worry about error checking
    right now.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Comments out the `Transform` and `Rotate` method calls in the `Update` function
    so that we won''t be running two different kinds of player controls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to keep our code that captures player input so that we can still use
    it later on.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You've initialized and stored the Rigidbody component on the player capsule
    and commented out the obsolete `Transform` code to set the stage for physics-based
    movement. The character is now ready for the next challenge, which is to add force.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following steps to move and rotate the Rigidbody component. Add in
    the following code to `PlayerBehavior` underneath the `Update` method, and then
    save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a breakdown of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any physics- or Rigidbody-related code always goes inside the `FixedUpdate`
    method, rather than `Update` or the other `MonoBehavior` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FixedUpdate` is frame rate independent and is used for all physics code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creates a new `Vector3` variable to store our left and right rotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Vector3.up * _hInput` is the same rotation vector we used with the `Rotate`
    method in the previous example.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Quaternion.Euler` takes a `Vector3` parameter and returns a rotation value
    in Euler angles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need a `Quaternion` value instead of a `Vector3` parameter to use the `MoveRotation`
    method. This is just a conversion to the rotation type that Unity prefers.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We multiply by `Time.fixedDeltaTime` for the same reason we used `Time.deltaTime`
    in `Update`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Calls `MovePosition` on our `_rb` component, which takes in a `Vector3` parameter
    and applies force accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The vector that''s used can be broken down as follows: the capsule''s `Transform`
    position in the forward direction, multiplied by the vertical inputs and `Time.fixedDeltaTime`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Rigidbody component takes care of applying movement force to satisfy our
    vector parameter.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Calls the `MoveRotation` method on the `_rb` component, which also takes in
    a `Vector3` parameter and applies the corresponding forces under the hood:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`angleRot` already has the horizontal inputs from the keyboard, so all we need
    to do is multiply the current Rigidbody rotation by `angleRot` to get the same
    left and right rotation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Be aware that `MovePosition` and `MoveRotation` work differently for non-kinematic
    game objects. You can find more information in the Rigidbody scripting reference
    at [https://docs.unity3d.com/ScriptReference/Rigidbody.html](https://docs.unity3d.com/ScriptReference/Rigidbody.html).
  prefs: []
  type: TYPE_NORMAL
- en: If you click on play now, you'll be able to move forward and backward in the
    direction you're looking, as well as rotate around the *y* axis.
  prefs: []
  type: TYPE_NORMAL
- en: Applied force produces stronger effects than translating and rotating a Transform
    component, so you may need to fine-tune the `MoveSpeed` and `RotateSpeed` variables
    in the **Inspector** pane. You've now recreated the same type of movement scheme
    as before, just with more realistic physics.
  prefs: []
  type: TYPE_NORMAL
- en: If you run up a ramp or drop off the central platform, you might see the player
    launch into the air, or slowly drop to the ground. Even though the Rigidbody component
    is set to use gravity, it's fairly weak. We'll tackle applying our gravity to
    the player in the next chapter when we implement the jump mechanic. For now, your
    job is to get comfortable with how Collider components handle collisions in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Colliders and collisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Collider components not only allow GameObjects to be recognized by Unity's physics
    system, but they also make interactions and collisions possible. Think of colliders
    as invisible force fields that surround GameObjects; they can be passed through
    or bumped into depending on their settings, and they come with a host of methods
    that execute during different interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Unity's physics system works differently for 2D and 3D games, so we will only
    be covering the 3D topics in this book. If you're interested in making 2D games,
    refer to the `Rigidbody2D` component at [https://docs.unity3d.com/Manual/class-Rigidbody2D.html](https://docs.unity3d.com/Manual/class-Rigidbody2D.html)
    and the list of available 2D colliders at [https://docs.unity3d.com/Manual/Collider2D.html](https://docs.unity3d.com/Manual/Collider2D.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot of the **Capsule** in the **Health_Pickup**
    object. If you want to see the **Capsule Collider** a little better, increase
    the **Radius** property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_07_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: Capsule collider component attached to pickup item'
  prefs: []
  type: TYPE_NORMAL
- en: The green shape around the object is the **Capsule Collider**, which can be
    moved and scaled using the **Center**, **Radius**, and **Height** properties.
  prefs: []
  type: TYPE_NORMAL
- en: When a primitive is created, the Collider matches the primitive's shape by default;
    since we created a capsule primitive, it comes with a Capsule Collider.
  prefs: []
  type: TYPE_NORMAL
- en: Colliders also come in **Box**, **Sphere**, and **Mesh** shapes and can be manually
    added from the **Component** | **Physics** menu or from the **Add Component**
    button in the **Inspector**.
  prefs: []
  type: TYPE_NORMAL
- en: When a Collider comes into contact with other components, it sends out what's
    called a message, or broadcast. Any script that adds one or more of those methods
    will receive a notification when the Collider sends out a message. This is called
    an *event*, which is a topic that we'll cover in more detail in *Chapter 14*,
    *The Journey Continues*.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when two GameObjects with colliders come into contact, both objects
    register an `OnCollisionEnter` event, complete with a reference to the object
    they ran into. Think of an event like a message being sent out – if you choose
    to listen for it you'll get notified when a collision happens in this case. This
    information can be used to track a variety of interactive events, but the simplest
    one is picking up an item. For cases where you want objects to be able to pass
    through others, you can use collision triggers, which we'll talk about in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: A complete list of Collider notifications can be found here underneath the **Messages**
    header at [https://docs.unity3d.com/ScriptReference/Collider.html](https://docs.unity3d.com/ScriptReference/Collider.html).
  prefs: []
  type: TYPE_NORMAL
- en: Collision and trigger events are only sent out when the colliding objects belong
    to a specific combination of Collider, Trigger, and RigidBody components and kinematic
    or non-kinematic motion. You can find details under the **Collision action matrix**
    section at [https://docs.unity3d.com/Manual/CollidersOverview.html](https://docs.unity3d.com/Manual/CollidersOverview.html).
  prefs: []
  type: TYPE_NORMAL
- en: The health item you previously created is a perfect place to test out how collisions
    work. You'll tackle that in the next challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Picking up an item
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To update the `Health_Pickup` object using collision logic, you need to do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script in the `Scripts` folder, name it `ItemBehavior`, and
    then drag it onto the `Health_Pickup` object in the **Hierarchy** panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any script that uses collision detection *must* be attached to a GameObject
    with a Collider component, even if it's the child of a Prefab.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select `Health_Pickup` in the **Hierarchy panel**, click the three vertical
    dots icon in the **Inspector** to the right of the **Item Behavior (Script)**
    component, and choose **Added Component** | **Apply to Prefab 'Health_Pickup'**:![](img/B17573_07_09.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.9: Applying Prefab changes to pickup item'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Replace the default code in `ItemBehavior` with the following, and then save
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on play and move the player over the capsule to pick it up!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s a breakdown of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When another object runs into the `Item` Prefab, Unity automatically calls
    the `OnCollisionEnter` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`OnCollisionEnter` comes with a parameter that stores a reference to the Collider
    that ran into it.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that the collision is of type `Collision`, not `Collider`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Collision` class has a property, called `gameObject`, which holds a reference
    to the colliding GameObject''s Collider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use this property to get the GameObject's name and use an `if` statement
    to check whether the colliding object is the player.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the colliding object is the player, we'll call the `Destroy()` method, which
    takes in a GameObject parameter and removes the object from the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It then prints out a simple log to the console that we have collected an item:![](img/B17573_07_10.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.10: Example of game objects being deleted from a scene'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We've set up `ItemBehavior` to essentially listen for any collisions with the
    `Health_Pickup` object Prefab. Whenever a collision occurs, `ItemBehavior` uses
    `OnCollisionEnter()` and checks whether the colliding object is the player and,
    if so, destroys (or collects) the item.
  prefs: []
  type: TYPE_NORMAL
- en: If you're feeling lost, think of the collision code we wrote as a receiver for
    notifications from the `Health_Pickup`; any time it's hit, the code fires.
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to understand that we could have created a similar script
    with an `OnCollisionEnter()` method, attached it to the player, and then checked
    whether the colliding object was a `Health_Pickup` Prefab. Collision logic depends
    on the perspective of the object being collided with.
  prefs: []
  type: TYPE_NORMAL
- en: Now the question is, how would you set up a collision without stopping the colliding
    objects from moving through each other? We'll tackle that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Collider triggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, Colliders are set with the `isTrigger` property unchecked, meaning
    that the physics system treats them as solid objects and will raise a Collision
    event on impact. However, in some cases, you'll want to be able to pass through
    a Collider component without it stopping your GameObject. This is where triggers
    come in. With `isTrigger` checked, a GameObject can pass through it, but the Collider
    will send out the `OnTriggerEnter`, `OnTriggerExit`, and `OnTriggerStay` notifications
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Triggers are most useful when you need to detect when a GameObject enters a
    certain area or passes a certain point. We'll use this to set up the areas around
    our enemies; if the player walks into the trigger zone, the enemies will be alerted,
    and, later on, attack the player. For now, you're going to focus just on the enemy
    logic in the following challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an enemy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the following steps to create an enemy:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new primitive using **+** | **3D Object** | **Capsule** in the **Hierarchy**
    panel and name it `Enemy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `Materials` folder, use **+** | **Material**, name it `Enemy_Mat`,
    and set its **Albedo** property to a bright red:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop `Enemy_Mat` into the `Enemy` GameObject.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With `Enemy` selected, click on **Add Component**, search for **Sphere Collider**,
    and hit `Enter` to add it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **isTrigger** property box and change the **Radius** to `8`:![](img/B17573_07_11.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 7.11: Sphere collider component attached to an enemy object'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our new **Enemy** primitive is now surrounded by an 8-unit trigger radius shaped
    like a sphere. Any time another object enters, stays inside, or exits that area,
    Unity will send out notifications that we can capture, just like we did with collisions.
    Your next challenge will be to capture that notification and act on it in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture trigger events, you''ll need to create a new script by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# script in the `Scripts` folder, name it `EnemyBehavior`, and
    then drag it into **Enemy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and save the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click play and walk over to the Enemy to set off the first notification, then
    walk away from the Enemy to set off the second notification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s a breakdown of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnTriggerEnter()` is fired whenever an object enters the Enemy Sphere Collider
    radius:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similar to `OnCollisionEnter()`, `OnTriggerEnter()` stores a reference to the
    trespassing object's Collider component.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that `other` is of type `Collider`, not `Collision`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use `other` to access the name of the colliding GameObject, and check
    whether it's the `Player` with an `if` statement. If it is, the console prints
    out a log that the `Player` is in the danger zone.![](img/B17573_07_12.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.12: Collision detection between player and enemy objects'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`OnTriggerExit()` is fired when an object leaves the Enemy Sphere Collider
    radius:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This method also has a reference to the colliding object''s Collider component:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We check the object leaving the Sphere Collider radius by name using another
    `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it's `Player`, we print out another log to the console saying that they're
    safe:![](img/B17573_07_13.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 7.13: Example of collision triggers'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Sphere Collider on our Enemy sends out notifications when its area is invaded,
    and the `EnemyBehavior` script captures two of those events. Whenever the player
    enters or exits the collision radius, a debug log appears in the console to let
    us know that the code is working. We'll continue to build on this in *Chapter
    9*, *Basic AI and Enemy Behavior*.
  prefs: []
  type: TYPE_NORMAL
- en: Unity makes use of something called the Component design pattern. Without going
    into too much detail, that's a fancy way of saying objects (and, by extension,
    their classes) should be responsible for their behavior as opposed to having all
    the code in one huge file. This is why we put separate collision scripts on the
    pickup item and enemy instead of having a single class handle everything. We'll
    discuss this further in *Chapter 14*, *The Journey Continues*.
  prefs: []
  type: TYPE_NORMAL
- en: Since this book is all about instilling as many good programming habits as possible,
    your last task for the chapter is to make sure all your core objects are converted
    into Prefabs.
  prefs: []
  type: TYPE_NORMAL
- en: Hero's trial – all the Prefabs!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get the project ready for the next chapter, go ahead and drag the `Player`
    and `Enemy` objects into the **Prefabs** folder. Remember, from now on you always
    need to right-click on the Prefab in the **Hierarchy** panel and choose **Added
    Component** | **Apply to Prefab** to solidify any changes you make to these GameObjects.
  prefs: []
  type: TYPE_NORMAL
- en: With that done, continue to the *Physics roundup* section and make sure that
    you've internalized all the major topics we've covered before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: Physics roundup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we wrap up the chapter, here are a few high-level concepts to cement
    what we''ve learned so far:'
  prefs: []
  type: TYPE_NORMAL
- en: Rigidbody components add simulated real-world physics to GameObjects they are
    attached to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Collider components interact with each other, as well as objects, using Rigidbody
    components:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a Collider component is not a trigger, it acts as a solid object.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If a Collider component is a trigger, it can be walked through.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An object is *kinematic* if it uses a Rigidbody component and has **Is Kinematic**
    checked, telling the physics system to ignore it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object is *non-kinematic* if it uses a Rigidbody component and applied force
    or torque to power its movement and rotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Colliders send out notifications based on their interactions. These notifications
    depend on whether the Collider component is set to be triggered or not. Notifications
    can be received from either colliding party, and they come with reference variables
    that hold an object's collision information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, a topic as broad and complex as the Unity physics system isn't learned
    in a day. Use what you've learned here as a springboard to launch yourself into
    more intricate topics!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This wraps up your first experience of creating independent gameplay behaviors
    and tying them all together into a cohesive, albeit simple, game prototype. You've
    used vectors and basic vector math to determine positions and angles in a 3D space,
    and you're familiar with player input and the two main methods of moving and rotating
    GameObjects. You've even gone down into the bowels of the Unity physics system
    to get comfortable with Rigidbody physics, collisions, triggers, and event notifications.
    All in all, *Hero Born* is off to a great start.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll start tackling more game mechanics, including jumping,
    dashing, shooting projectiles, and interacting with parts of the environment.
    This will give you more hands-on experience of using force with Rigidbody components,
    gathering player input, and executing logic based on the desired scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – player controls and physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What data type would you use to store 3D movement and rotation information?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What built-in Unity component allows you to track and modify player controls?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which component adds real-world physics to a GameObject?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method does Unity suggest using to execute physics-related code on GameObjects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JOIN us on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Join Now!
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code_9781801813945.png)'
  prefs: []
  type: TYPE_IMG
