- en: Best Practices in Coding C# 8
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 8编码的最佳实践
- en: When you act as a software architect on a project, it is your responsibility
    to define and/or maintain a coding standard that will direct the team for programming
    according to the company's expectations. This chapter covers some of the best
    practices in coding that will help developers like you to program safe, simple,
    and maintainable software. It also includes tips and tricks for coding in C#.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在项目中担任软件架构师时，你有责任定义和/或维护一个编码标准，这将指导团队根据公司的期望进行编程。本章涵盖了帮助你编写安全、简单和可维护软件的一些最佳编码实践。它还包括C#编码的技巧和窍门。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How the complexity of your code can affect performance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的代码复杂度如何影响性能
- en: The importance of using a version control system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用版本控制系统的必要性
- en: Writing safe code in C#
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C#中编写安全代码
- en: .NET core tips and tricks for coding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET core编码技巧和窍门
- en: Book use case – dos and don'ts in writing code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍使用案例 - 编写代码时的注意事项与禁忌
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the Visual Studio 2019 free community edition or better
    with all database tools installed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要Visual Studio 2019免费社区版或更高版本，并安装所有数据库工具。
- en: You will find the sample code of this chapter here: [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch14](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch14).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到本章的示例代码：[https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch14](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch14).
- en: The more complex your code is, the worse a programmer you are
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的代码越复杂，你的编程能力就越差
- en: For many people, a good programmer is one who writes complex code. However,
    the evolution of maturity in software development means there is a different way
    of thinking about it. The complexity does not mean a good job, it means poor code
    quality. Some incredible scientists and researchers confirm this theory and emphasize
    that professional code needs to be focused on time, of high quality, and within
    budget.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多人来说，一个好的程序员是编写复杂代码的人。然而，软件开发成熟度的演变意味着对此有不同的思考方式。复杂性并不意味着工作做得好，它意味着代码质量差。一些令人难以置信的科学家和研究人员证实了这一理论，并强调专业代码需要关注时间、高质量，并在预算内完成。
- en: So, if you want to write good code, you need to keep the focus on how to do
    it, considering you are not the only one who will read it later. This is a good
    tip that changes the way you write code. This is how we will discuss each point
    of this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想编写好的代码，你需要关注如何编写它，考虑到你不是唯一一个将来会阅读它的人。这是一个改变你编写代码方式的良好建议。这就是我们将如何讨论本章的每个要点。
- en: 'If your understanding of the importance of writing good code is aligned to
    the idea of simplicity and clarity while writing it, you should have to take a
    look at the Visual Studio tool Code Metrics:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对编写良好代码重要性的理解与编写时的简洁性和清晰性理念相一致，你应该看看Visual Studio工具代码度量：
- en: '![](img/7a548e09-2e4e-4060-8ca5-5127de261882.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a548e09-2e4e-4060-8ca5-5127de261882.png)'
- en: 'The Code Metrics tool will deliver metrics that will give you insights about
    the quality of the software you are delivering. The metrics that the tool provides
    are listed here and can be found at this link [https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '代码度量工具将提供度量值，这些度量值将为你提供关于你交付的软件质量的洞察。该工具提供的度量值列在这里，并可在以下链接中找到 [https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019):'
- en: Maintainability index
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可维护性指数
- en: Cyclomatic complexity
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圈复杂度
- en: Depth of inheritance
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承深度
- en: Class coupling
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类耦合
- en: Lines of code
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码行数
- en: The next subsections are focused on describing how they are useful in some real-life
    scenarios.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将专注于描述它们在现实生活场景中的有用性。
- en: Maintainability index
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性指数
- en: This index indicates how easy it is to maintain the code—the easier the code,
    the higher the index (limited to 100). Easy maintenance is one of the key points
    to keep software in good health. It is obvious that any software will require
    changes in the future since change is inevitable. For this reason, consider refactoring
    your code if you have low levels of maintainability. Writing classes and methods
    dedicated to a single responsibility, avoiding duplicate code, and limiting the
    number of lines of code of each method are examples of how you can improve the
    maintainability index.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指数表明了维护代码的难易程度——代码越容易维护，指数就越高（限于100）。易于维护是保持软件健康的关键点之一。显然，任何软件在未来都需要进行更改，因为变化是不可避免的。因此，如果你有低维护性，考虑重构你的代码。编写专门负责单一职责的类和方法，避免重复代码，并限制每个方法的代码行数，这些都是你可以提高维护性指数的例子。
- en: Cyclomatic complexity
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环复杂度
- en: 'The author of *Cyclomatic Complexity Metric* is Thomas J. McCabe. He defines
    the complexity of a software function according to the number of code paths available
    (graph nodes). The more paths you have, the more complex your function is. McCabe
    considers that each function must have a complexity score of less than 10\. That
    means that, if the code has more complex methods, you have to refactor it, transforming
    parts of these codes into separate methods. There are some real scenarios where
    this behavior is easily detected:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 《循环复杂度度量》一书的作者是托马斯·J·麦卡贝。他根据可用的代码路径数（图节点）来定义软件函数的复杂度。路径越多，函数越复杂。麦卡贝认为每个函数的复杂度得分必须小于10。这意味着，如果代码中有更复杂的方法，你必须重构它，将这些代码的部分转换为独立的方法。有一些真实场景中，这种行为很容易被检测到：
- en: Loops inside loops
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环嵌套循环
- en: Lots of consecutive `if`-`else`
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续的多个`if`-`else`
- en: '`switch` with code processing for each `case` inside the same method'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一方法内部对每个`case`进行代码处理的`switch`
- en: 'For instance, look at the first version of this method for processing different
    responses of a credit card transaction. As you can check, the cyclomatic complexity
    is bigger than the number considered by McCabe as a basis. The reason why this
    happens is because of the number of `if`-`else` inside each case of the main `switch`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看这个方法处理信用卡交易不同响应的第一版本。正如你可以检查的，循环复杂度大于麦卡贝作为基础的数字。这种情况发生的原因是每个主`switch`案例中的`if`-`else`的数量：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you calculate the code metrics of this code, you will find a really bad
    result when it comes to cyclomatic complexity, as you can see in the following
    screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计算这段代码的代码度量，你会发现当涉及到循环复杂度时，结果非常糟糕，就像你在下面的截图中所看到的那样：
- en: '![](img/dec95161-0d4a-4ef0-88a4-792cb2b3233b.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dec95161-0d4a-4ef0-88a4-792cb2b3233b.png)'
- en: 'The code itself makes no sense, but the point here is to show you the number
    of improvements that can be made in order to write better code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 代码本身没有意义，但这里的关键是展示你可以做出多少改进来编写更好的代码：
- en: The options from the `switch`-`case` could be written using `Enum`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch`-`case`选项可以用`Enum`来编写。'
- en: Each case processing can be done in a specific method.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个情况的处理都可以在一个特定的方法中完成。
- en: '`switch`-`case` can be substituted with `Dictionary<Enum, Method>`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch`-`case`可以用`Dictionary<Enum, Method>`来替换。'
- en: 'By refactoring this code with the preceding techniques, the result is a piece
    of code that is much easier to understand, as you can see in the following code
    snippet of its main method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用上述技术重构这段代码，结果是一段更容易理解的代码，就像你在下面的代码片段中看到的主方法一样：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The full code can be found on the GitHub of this chapter and presents how lower-complexity
    code can be achieved. The following screenshot shows these results according to
    code metrics:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在本章的GitHub上找到，展示了如何实现低复杂度的代码。下面的截图显示了根据代码度量得出的这些结果：
- en: '![](img/b0691000-1cfc-4488-a125-15c82e9c080b.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0691000-1cfc-4488-a125-15c82e9c080b.png)'
- en: As you can see in the preceding screenshot, there is a considerable reduction
    of complexity after refactoring. The key point here is that with the techniques
    applied, understanding of the code increased and the complexity decreased, proving
    the importance of cyclomatic complexity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的截图中所看到的，重构后复杂度有相当大的降低。这里的关键点是，应用了这些技术后，代码的理解性提高了，复杂度降低了，这证明了循环复杂度的重要性。
- en: Depth of inheritance
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承深度
- en: This metric represents the number of classes connected to the one that is being
    analyzed. The more classes you have inherited, the worse your code is. This is
    similar to class coupling and indicates how difficult it is to change your code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此指标表示连接到正在分析的那个类的类的数量。你继承的类越多，你的代码就越糟糕。这与类耦合类似，表明改变你的代码有多困难。
- en: 'For instance, the following screenshot has four inherited classes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下截图有四个继承的类：
- en: '![](img/828e2f8e-52f8-45a5-ac76-19070e1a90b5.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/828e2f8e-52f8-45a5-ac76-19070e1a90b5.png)'
- en: 'You can see in the following screenshot that the deeper class has the worse
    the metric, considering there are three other classes that can change its behavior:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在下面的截图看到，深度更大的类由于有三个其他类可以改变其行为，其指标更差：
- en: '![](img/f239b8f1-bc7d-4ce7-9a80-22a0f5ca5d10.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f239b8f1-bc7d-4ce7-9a80-22a0f5ca5d10.png)'
- en: Inheritance is one of the basic object-oriented analysis principles. However,
    it can sometimes be bad for your code in that it can cause dependencies. So, if
    it makes sense to do so, instead of using inheritance, consider using aggregation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是面向对象分析的基本原则之一。然而，有时它可能对你的代码不利，因为它可能引起依赖。因此，如果你这样做有意义，考虑使用聚合而不是继承。
- en: Class coupling
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类耦合
- en: 'When you connect too many classes in a single class, obviously you will get
    coupling and this can cause bad maintenance of your code. For instance, see the
    following screenshot. It shows a design where aggregation has been done a lot.
    There is no sense to the code itself:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在单个类中连接太多的类时，显然你会得到耦合，这可能导致你的代码维护不良。例如，参见下面的截图。它显示了一个进行了大量聚合的设计。代码本身没有意义：
- en: '![](img/bd79f53e-2805-4269-8c15-49258676ba77.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd79f53e-2805-4269-8c15-49258676ba77.png)'
- en: 'Once you have calculated the code metrics for the preceding design, you will
    see that the number of class coupling instances for the `ProcessData()` method,
    which calls `ExecuteTypeA()`, `ExecuteTypeB()`, and `ExecuteTypeC()`, equals three
    (`3`):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你计算了前面设计的代码指标，你就会看到调用`ExecuteTypeA()`、`ExecuteTypeB()`和`ExecuteTypeC()`的`ProcessData()`方法的类耦合实例数等于三个（`3`）：
- en: '![](img/08c80647-eb51-4e25-acc8-b4a452472021.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/08c80647-eb51-4e25-acc8-b4a452472021.png)'
- en: 'Some papers indicate that the maximum number of class coupling instances should
    be nine (`9`). With aggregation being a better practice than inheritance, the
    use of interfaces will solve class coupling problems. For instance, the same code
    with the following design will give you a better result:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一些论文指出，类耦合实例的最大数量应该是九（`9`）。由于聚合比继承是一个更好的实践，使用接口将解决类耦合问题。例如，以下设计相同的代码将给出更好的结果：
- en: '![](img/d6df17e5-e99d-4631-b42f-7660ef6121f0.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d6df17e5-e99d-4631-b42f-7660ef6121f0.png)'
- en: 'Notice that using the interface in the design will allow you the possibility
    of increasing the number of execution types without increasing the Class Coupling
    of the solution:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在设计中使用界面将允许你在不增加解决方案的类耦合的情况下增加执行类型：
- en: '![](img/18cce1ea-bacd-46e0-b3a2-3d12c7e27009.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18cce1ea-bacd-46e0-b3a2-3d12c7e27009.png)'
- en: As a software architect, you have to consider designing your solution to have
    more cohesion than coupling. The literature indicates that good software has low
    coupling and high cohesion. This is a basic principle that can guide you to a
    better architectural model.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名软件架构师，你必须考虑设计你的解决方案，使其具有比耦合更高的内聚性。文献指出，好的软件具有低耦合和高内聚。这是一个基本的原则，可以指导你到一个更好的架构模型。
- en: Lines of code
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码行数
- en: This metric is useful to make you understand the size of the code you are dealing
    with. There is no way to connect lines of code and complexity since the number
    of lines is not indicative of that. On the other hand, the lines of code show
    the software size and software design. For instance, if you have too many lines
    of code in a single class (more than 1,000 lines of code—1 KLOC), it indicates
    that it is a bad design.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此指标有助于你理解你正在处理的代码的大小。由于行数并不能表明复杂性，因此无法将代码行数与复杂性联系起来。另一方面，代码行数显示了软件的大小和软件设计。例如，如果你在一个类中有太多的代码行（超过1,000行代码—1
    KLOC），这表明这是一个糟糕的设计。
- en: Using a version control system
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用版本控制系统
- en: You may find this topic in this book a bit obvious, but many people and companies
    still do not consider having a version control system as a basic tool for software
    development! The idea of writing about it is to force you to understand it. There
    is no architectural model or best practice that can save software development
    if you do not use a version control system.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得这本书中关于这个话题的内容有点明显，但许多人和公司仍然没有将版本控制系统视为软件开发的基本工具！写这个话题的目的是强迫你理解它。如果你不使用版本控制系统，没有任何架构模型或最佳实践可以拯救软件开发。
- en: In the last few years, we have been enjoying the advantages of online version
    control systems, such as GitHub, BitBucket, and Azure DevOps. The fact is, you
    have to have a tool like that in your software development life cycle and there
    is no reason to not have it anymore since most providers offer free versions for
    small groups. Even if you develop by yourself, these tools are useful for tracking
    your changes, managing your software versions, and guaranteeing the consistency
    and integrity of your code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年里，我们一直在享受在线版本控制系统（如GitHub、BitBucket和Azure DevOps）带来的优势。事实上，在你的软件开发生命周期中必须有一个这样的工具，而且没有理由不再使用它，因为大多数提供商都为小型团队提供免费版本。即使是你自己开发，这些工具也有助于跟踪你的更改、管理你的软件版本，并保证你的代码的一致性和完整性。
- en: Dealing with version control systems in teams
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在团队中处理版本控制系统
- en: The use of a version control system tool when you are alone is quite obvious.
    You want to keep your code safe. But this kind of system was definitely developed
    to solve team problems while writing code. For this reason, some features such
    as branching and merging were introduced to keep code integrity even in scenarios
    where the number of developers is quite big.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你一个人使用版本控制系统工具时，这很显然。你希望保持你的代码安全。但这类系统肯定是为了解决编写代码时的团队问题而开发的。因此，引入了一些功能，如分支和合并，以保持代码完整性，即使在开发者数量相当大的情况下也是如此。
- en: As a software architect, you will have to decide which branch strategy you will
    conduct in your team. Azure DevOps and GitHub suggest different ways to deliver
    that, and both of them are useful in some scenarios.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名软件架构师，你将不得不决定在你的团队中采用哪种分支策略。Azure DevOps和GitHub建议不同的方法来实现这一点，并且在某些场景下它们都是很有用的。
- en: The information about how Azure DevOps team deals with it can be found here: [https://devblogs.microsoft.com/devops/release-flow-how-we-do-branching-on-the-vsts-team/](https://devblogs.microsoft.com/devops/release-flow-how-we-do-branching-on-the-vsts-team/).
    GitHub describes its process here: [https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/).
    We have no idea about which is the one that best fits your needs, but we do want
    you to understand that you need to have a strategy for controlling your code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Azure DevOps团队如何处理这个问题的信息可以在这里找到：[https://devblogs.microsoft.com/devops/release-flow-how-we-do-branching-on-the-vsts-team/](https://devblogs.microsoft.com/devops/release-flow-how-we-do-branching-on-the-vsts-team/)。GitHub在这里描述了其流程：[https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/)。我们不知道哪一个最适合你的需求，但我们确实想让你明白，你需要有一个控制代码的策略。
- en: Writing safe code in C#
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中编写安全代码
- en: C# can be considered a safe programming language by design. Unless you force
    it, there is no need for pointers, and memory release is, in most cases, managed
    by the garbage collector. Even so, some care should be taken so you can get better
    and safe results from your code. Let's have a look at them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: C#可以被认为是一种设计上安全的编程语言。除非你强制使用，否则不需要指针，并且大多数情况下，内存释放由垃圾回收器管理。即便如此，你也应该注意一些事项，以便从你的代码中获得更好的安全结果。让我们来看看它们。
- en: try-catch
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: try-catch
- en: 'Exceptions in coding are so frequent that you may have a way to manage them
    whenever they happen. `try`-`catch` statements are built to manage these exceptions
    and they are really important to keeping your code safe. There are a lot of cases
    where an application crashes and the reason for that is the lack of using `try`-`catch`.
    The following code shows an example of the lack of usageof the `try`-`catch` statement:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中的异常如此频繁，以至于你可能会找到一种方法来管理它们，无论何时发生。`try`-`catch`语句就是为了管理这些异常而构建的，它们对于保持代码安全至关重要。有很多情况下应用程序崩溃，原因就是没有使用`try`-`catch`。以下代码展示了缺少使用`try`-`catch`语句的例子：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On the other hand, bad `try`-`catch` usage can cause damage to your code too,
    especially because you will not see the correct behavior of that code and may
    misunderstand the results provided. The following code shows an example of an
    empty `try`-`catch` statement:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，错误的`try`-`catch`使用也可能对你的代码造成损害，特别是因为你将看不到该代码的正确行为，并可能误解提供的结果。以下代码展示了空`try`-`catch`语句的示例：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`try`-`catch` statements must always be connected to logging solutions, so
    that you can have a response from the system that will indicate the correct behavior
    and, at the same time, will not cause application crashes. The following code
    shows an ideal `try`-`catch` statement with logging management:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`-`catch`语句必须始终与日志解决方案相关联，这样你就可以得到系统的响应，指示正确的行为，同时不会导致应用程序崩溃。以下代码展示了带有日志管理的理想`try`-`catch`语句：'
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As a software architect, you should conduct code inspections to fix this kind
    of behavior found in the code. Instability in a system is often connected to the
    lack of try-catch statements in the code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名软件架构师，你应该进行代码审查以修复代码中发现的这类行为。系统的不稳定通常与代码中缺少try-catch语句有关。
- en: try-finally and using
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: try-finally 和 using
- en: Memory leaks can be considered one of the worst behaviors of software. They
    cause instability, bad usage of computer resources, and undesired application
    crashes. C# tries to solve this with Garbage Collector, which automatically releases objects
    from memory as soon as it realizes the object can be freed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏可以被认为是软件最糟糕的行为之一。它们导致系统不稳定，计算机资源使用不当，以及不希望的应用程序崩溃。C#试图通过垃圾回收器解决这个问题，垃圾回收器会在意识到对象可以被释放时自动释放对象。
- en: 'Objects that interact with I/O are the ones that generally are not managed
    by Garbage Collector: filesystem, sockets, and so on. The following code is a
    sample of wrong usage of `FileStream` object, because it considers the Garbage
    Collector will release the memory used, but it will not:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与 I/O 交互的对象通常不是由垃圾回收器管理的：文件系统、套接字等。以下代码是`FileStream`对象使用错误的示例，因为它认为垃圾回收器会释放使用的内存，但实际上不会：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Besides, it takes a while for Garbage Collector to interact with objects that
    need to be released and sometimes you may want to do it yourself. For both cases,
    the use of `try`-`finally` or `using` statements is the best practice:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，垃圾回收器与需要释放的对象交互需要一段时间，有时你可能想自己来做这件事。在这两种情况下，使用`try`-`finally`或`using`语句是最佳实践：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code shows exactly how to deal with objects that are not managed
    by Garbage Collector. You have both `try`-`finally` and `using` being implemented.
    As a software architect, you do need to pay attention to this kind of code. The
    lack of `try`-`finally` or `using` statements can cause huge damage to software
    behavior when it is running.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了如何处理不由垃圾回收器管理的对象。你既有`try`-`finally`也有`using`的实现。作为一名软件架构师，你需要注意这类代码。缺少`try`-`finally`或`using`语句可能导致软件在运行时出现严重问题。
- en: The IDisposable interface
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`IDisposable`接口'
- en: 'The same way you will have trouble if you do not manage objects created inside
    a method with try-finally/using statements, objects created in a class that does
    not properly implement the `IDisposable` interface may cause memory leaks in your
    application. For this reason, when you have a class that deals with and creates
    objects, you should implement the disposable pattern to guarantee the release
    of all resources created by it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你不使用 try-finally/using 语句管理在方法内部创建的对象，那么在未正确实现`IDisposable`接口的类中创建的对象可能会导致你的应用程序出现内存泄漏。因此，当你有一个处理和创建对象的类时，你应该实现可处置模式，以确保释放它创建的所有资源：
- en: '![](img/0fdb7e0f-fca3-448f-afca-b3090c577a50.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0fdb7e0f-fca3-448f-afca-b3090c577a50.png)'
- en: The good news is that Visual Studio gives you the code snippet to implement
    this interface by just indicating it in your code and right-clicking on the Quick
    Actions and refactorings option, as you can see in the preceding screenshot. Once
    you have the code inserted, you need to follow the TODO instructions so that you
    have the correct pattern implemented.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，Visual Studio 通过在代码中指示并右键单击“快速操作和重构”选项来实现此接口的代码片段，就像你在前面的截图中所看到的那样。一旦你插入了代码，你需要遵循
    TODO 指令，以确保正确实现了模式。
- en: .NET Core tips and tricks for coding
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core 编码技巧和窍门
- en: .NET Core implements some good features that help us to write better code. One
    of the most useful for having safer code is **dependency injection** (**DI**),
    which was already discussed in [Chapter 9](a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml),
    *Design Patterns and .NET Core Implementation*. There are some good reasons to
    consider this. The first one is because you will not need to worry about disposing
    of injected objects since you are not going to be the creator of them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core实现了一些有助于我们编写更好代码的良好功能。其中最有用的是**依赖注入**（**DI**），这在[第9章](a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml)，*设计模式和.NET
    Core实现*中已经讨论过。考虑这一点有几个很好的理由。第一个是因为你不需要担心注入对象的释放，因为你不是它们的创建者。
- en: 'Besides, DI enables you to inject `ILogger`, a really useful tool for debugging
    exceptions that will need to be managed by try-catch statements in your code. Furthermore,
    programming in C# with .NET Core must follow the common good practices of any
    programming language. The following list shows some of them:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，DI使你能够注入`ILogger`，这是一个非常有用的调试异常的工具，这些异常将需要在你的代码中通过try-catch语句来管理。此外，使用.NET
    Core进行C#编程必须遵循任何编程语言的通用良好实践。以下列表显示了其中的一些：
- en: '**Classes, methods, and variables should have understandable names**: The name
    should explain everything the reader needs to know. There should be no need for
    an explanatory comment.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类、方法和变量应该有可理解的名称**：名称应该解释读者需要知道的一切。不应该需要解释性注释。'
- en: '**Methods cannot have high complexity levels**: Cyclomatic complexity should
    be checked so that methods do not have too many lines of code.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法不能有高复杂度**：应该检查方法的圈复杂度，以确保方法不要有太多的代码行。'
- en: '**Duplicate code should be avoided**: There is no reason for having duplicate
    code in a high-level programming language like C#.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应避免重复代码**：在像C#这样的高级编程语言中，没有必要存在重复代码。'
- en: '**Objects should be checked before usage**: Since null objects can exist, the
    code must have null-type checking.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在使用对象之前应进行检查**：由于可能存在null对象，代码必须进行null类型检查。'
- en: '**Constants and enumerators should be used**: A good way for avoiding magic
    numbers and text inside code is transforming this information into constants and
    enumerators, which generally are more understandable.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应使用常量和枚举器**：避免代码中的魔法数字和文本的好方法是将这些信息转换为常量和枚举器，这通常更容易理解。'
- en: '**Unsafe code should be avoided**: Unless there is no other way to implement
    code, unsafe code should be avoided.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应避免不安全代码**：除非没有其他实现代码的方法，否则应避免使用不安全代码。'
- en: '**try-catch statements cannot be empty**: There is no reason for a `try`-`catch`
    statement without treatment in the `catch` area.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**try-catch语句不能为空**：在没有处理`catch`区域的`try-catch`语句中没有理由。'
- en: '**try-finally/using statements should always be used**: Even for objects where
    Garbage Collector will take care of the disposed-of object, consider disposing
    of objects that you were responsible for creating yourself.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**try-finally/using语句应该始终使用**：即使对于垃圾回收器将负责处理的对象，也应考虑处理你负责创建的对象。'
- en: '**At least public methods should be commented**: Considering that public methods
    are the ones used outside your library, they have to be explained for their correct
    external usage.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**至少公共方法应该有注释**：考虑到公共方法是用于你库外部的那些方法，它们必须被解释以正确使用。'
- en: '**switch-case statements must have a default treatment**: Since the `switch`-`case`
    statement may receive an entrance variable unknown in some cases, the default
    treatment will guarantee that the code will not break in such a situation.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**switch-case语句必须有默认处理**：由于`switch-case`语句可能接收到在某些情况下未知的人口变量，默认处理将保证在这种情况下代码不会中断。'
- en: As a software architect, a good practice is to provide your developers with
    a code pattern that will be used by all programmers as a way to keep the style
    of the code consistent. You can use a code pattern as a checklist for coding inspection,
    which will enrich software code quality.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，一个好的做法是为你的开发者提供一个所有程序员都会使用的代码模式，以此来保持代码风格的一致性。你可以将代码模式用作编码检查的清单，这将丰富软件代码的质量。
- en: WWTravelClub – dos and don'ts in writing code
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WWTravelClub – 编写代码的注意事项和禁忌
- en: As a software architect, you have to define a code standard that matches the
    needs of the company you are working for.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名软件架构师，你必须定义一个符合你所服务公司需求的代码标准。
- en: 'In the sample project of this book (check out more about the WWTravelClub project
    in [Chapter 1](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml), *Understanding the
    Importance of Software Architecture*), this is no different. The way we decided
    to present the standard for it is describing a list of dos and don''ts that we
    followed while writing the samples we produced. It is worth mentioning that the
    list is a good way to start your standard and as a software architect, you should
    discuss this list with the developers you have in the team, so you can evolve
    it in a practical and good manner:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的示例项目中（关于WWTravelClub项目的更多信息，请参阅[第1章](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml)，*理解软件架构的重要性*），情况并无不同。我们决定展示该标准的做法是描述我们在编写示例时遵循的一系列“做”和“不做”的清单。值得一提的是，这个清单是一个很好的开始标准，作为软件架构师，你应该与团队中的开发者讨论这个清单，以便以实际和良好的方式对其进行改进：
- en: DO write your code in English.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**务必**用英语编写你的代码。'
- en: DO follow C# coding standards with CamelCase.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**务必**遵循C#编码标准，使用驼峰命名法。'
- en: DO write classes, methods, and variables with understandable names.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**务必**使用易于理解的名称编写类、方法和变量。'
- en: DO comment public classes, methods, and properties.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**务必**对公共类、方法和属性进行注释。'
- en: DO use the `using` statement whenever possible.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**务必**尽可能使用`using`语句。'
- en: DO use `async` implementation whenever possible.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**务必**尽可能使用`async`实现。'
- en: DO ask for authorization before implementing unmanaged code.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**务必**在实现非托管代码之前请求授权。'
- en: DO ask for authorization before implementing threads.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**务必**在实现线程之前请求授权。'
- en: DON'T write empty `try`*-*`catch` statements.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要**编写空的`try`*-*`catch`语句。'
- en: DON'T write methods with more than a score of 10 of cyclomatic complexity.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要**编写超过10个循环复杂度的方法。'
- en: DON'T use `break` and `continue` inside `for`/`while`/`do`*-*`while`/`foreach`
    statements.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要**在`for`/`while`/`do`*-*`while`/`foreach`语句中使用`break`和`continue`。'
- en: DON'T use `goto` statements.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要**使用`goto`语句。'
- en: These dos and don'ts are simple to follow and, better than that, will yield
    great results for the code your team produces. In [Chapter 16](47fba7aa-d9c6-46ad-b16a-1719f0d906f8.xhtml), *Using
    Tools to Write Better Code*, we will discuss the tools to help you to implement
    these rules.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些“做”和“不做”的规则很容易遵循，而且，更重要的是，它们将为你的团队产生的代码带来巨大的成果。在[第16章](47fba7aa-d9c6-46ad-b16a-1719f0d906f8.xhtml)，*使用工具编写更好的代码*中，我们将讨论帮助你实施这些规则的工具。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**摘要**'
- en: We discussed during this chapter some important tips for writing safe code.
    This chapter introduced a tool for analyzing code metrics, so you can manage the
    complexity and maintainability of the software you are developing. To finish,
    we presented some good tips to guarantee your software will not crash due to memory
    leaks and exceptions. In real life, a software architect will always be asked
    to solve this kind of problem.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一些编写安全代码的重要提示。本章介绍了一个分析代码指标的工具，这样你可以管理你正在开发的软件的复杂性和可维护性。最后，我们提出了一些保证你的软件不会因为内存泄漏和异常而崩溃的好建议。在现实生活中，软件架构师总会被要求解决这类问题。
- en: In the next chapter, we will learn about some unit testing techniques, the principles
    of unit testing, and a software process model that focuses on C# test projects.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习一些单元测试技术、单元测试的原则以及一个专注于C#测试项目的软件过程模型。
- en: Questions
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**问题**'
- en: Why do we need to care about maintainability?
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们需要关注可维护性？
- en: What is cyclomatic complexity?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环复杂度是什么？
- en: List the advantages of using a version control system.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出使用版本控制系统的优点。
- en: What is the difference between `try`-`catch`, `try`-`finally`, and `try`-`catch`-`finally`?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`try`-`catch`、`try`-`finally`和`try`-`catch`-`finally`之间的区别是什么？'
- en: What is Garbage Collector?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾收集器是什么？
- en: What is the importance of implementing the `IDisposable` interface?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`IDisposable`接口的重要性是什么？
- en: What advantages do we get from .NET Core when it comes to coding?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当涉及到编码时，我们从.NET Core中获得了哪些优势？
- en: Further reading
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: 'These are some books and websites where you will find more information about
    the topics of this chapter:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些书籍和网站，你可以在其中找到更多关于本章主题的信息：
- en: '*The Art of Designing Embedded Systems* by Jack G. Ganssle. Elsevier, 1999.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《嵌入式系统设计艺术》by Jack G. Ganssle. Elsevier, 1999。
- en: '*Refactoring: Improving the Design of Existing Code* by Martin Fowler. Addison
    Wesley, 1999.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《重构：改善既有代码的设计》by Martin Fowler. Addison Wesley, 1999。
- en: '*A Complexity Measure* by Thomas J. McCabe. IEEE Trans. Software Eng. 2(4): 308-320, 1976
    ([https://dblp.uni-trier.de/db/journals/tse/tse2.html](https://dblp.uni-trier.de/db/journals/tse/tse2.html)).'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*托马斯·J·麦卡贝的复杂度度量*。IEEE 软件工程杂志，第 2 卷第 4 期，1976 年，第 308-320 页 ([https://dblp.uni-trier.de/db/journals/tse/tse2.html](https://dblp.uni-trier.de/db/journals/tse/tse2.html)).'
- en: '[https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/](https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/](https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/)'
- en: '[https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019)'
- en: '[https://github.com/](https://github.com/)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/](https://github.com/)'
- en: '[https://bitbucket.org/](https://bitbucket.org/)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bitbucket.org/](https://bitbucket.org/)'
- en: '[https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/)'
- en: '[https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/)'
- en: '[https://blogs.msdn.microsoft.com/devops/2018/04/19/release-flow-how-we-do-branching-on-the-vsts-team/](https://blogs.msdn.microsoft.com/devops/2018/04/19/release-flow-how-we-do-branching-on-the-vsts-team/)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blogs.msdn.microsoft.com/devops/2018/04/19/release-flow-how-we-do-branching-on-the-vsts-team/](https://blogs.msdn.microsoft.com/devops/2018/04/19/release-flow-how-we-do-branching-on-the-vsts-team/)'
- en: '[https://docs.microsoft.com/aspnet/core/fundamentals/logging/](https://docs.microsoft.com/aspnet/core/fundamentals/logging/)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/aspnet/core/fundamentals/logging/](https://docs.microsoft.com/aspnet/core/fundamentals/logging/)'
