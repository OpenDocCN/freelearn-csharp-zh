- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Win and Lose Conditions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 胜利和失败条件
- en: Now that we have a basic gameplay experience, it’s time to make the game end
    with the outcomes of winning or losing. One common way to implement this is through
    separated components with the responsibility of overseeing a set of objects to
    detect certain situations that need to happen, such as the player life becoming
    0 or all of the waves being cleared. We will implement this through the concept
    of **managers**, components that will manage and monitor several objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个基本的游戏体验，是时候让游戏以胜利或失败的结果结束。一种常见的实现方式是通过具有监督一组对象以检测需要发生的情况的责任的独立组件，例如玩家生命值为0或所有波次都被清除。我们将通过**管理器**的概念来实现这一点，这些组件将管理和监控多个对象。
- en: 'In this chapter, we will examine the following manager concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下管理器概念：
- en: Creating object managers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建对象管理器
- en: Creating game modes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建游戏模式
- en: Improving our code with events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件改进我们的代码
- en: With this knowledge, you will be able to not only create the victory and lose
    conditions of the game, but also do this in a properly structured way using design
    patterns such as **Singleton** and **Event Listeners**. These skills are not only
    useful for creating the winning and losing code of the game but any code in general.
    First, let’s begin by creating managers to represent concepts such as score or
    game rules.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，你不仅能够创建游戏的胜利和失败条件，而且还能以正确的方式使用设计模式如**单例**和**事件监听器**来做到这一点。这些技能不仅对创建游戏的胜利和失败代码有用，而且对任何代码都很有用。首先，让我们从创建代表如分数或游戏规则等概念的管理器开始。
- en: Creating object managers
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对象管理器
- en: 'Not every object in your Scene should be something that can be seen, heard,
    or collided with. Some objects can also exist with a conceptual meaning, not something
    tangible. For example, imagine you need to keep a count of the number of enemies:
    where do you save that? You also need someplace to save the current score of the
    player, and you may be thinking it could be on the player itself, but what happens
    if the player dies and respawns?'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 并非场景中的每个对象都应该是可以被看到、听到或与之碰撞的。一些对象也可以存在概念意义，而不是有形的东西。例如，想象你需要计算敌人的数量：你将把它保存在哪里？你还需要一个地方来保存玩家的当前分数，你可能认为它可以在玩家本身上，但如果玩家死亡并重生会发生什么呢？
- en: The data would be lost! In such scenarios, the concept of a **manager** can
    be a useful way of solving this in our first games, so let’s explore it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 数据将会丢失！在这种情况下，**管理器**的概念可以是我们最初游戏中解决问题的有用方式，让我们来探索一下。
- en: 'In this section, we are going to see the following object manager concepts:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到以下对象管理器概念：
- en: Sharing variables with the Singleton design pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单例设计模式共享变量
- en: Sharing variables in Visual Scripting
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视觉脚本中共享变量
- en: Creating managers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建管理器
- en: We will start by discussing what the Singleton design pattern is and how it
    helps us simplify the communication of objects. With it, we will create manager
    objects that allow us to centralize information about a group of objects, among
    other things. Let’s start by discussing the Singleton design pattern.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论单例设计模式是什么以及它如何帮助我们简化对象的通信。有了它，我们将创建管理对象，使我们能够集中管理一组对象的信息，以及其他事情。让我们先从讨论单例设计模式开始。
- en: Sharing variables with the Singleton design pattern
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用单例设计模式共享变量
- en: Design patterns are usually described as common solutions to common problems.
    There are several coding design decisions you will have to make while you code
    your game, but luckily, the ways to tackle the most common situations are well
    known and documented. In this section, we are going to discuss one of the most
    common design patterns, the **Singleton**, a convenient one to implement in simple
    projects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式通常被描述为对常见问题的常见解决方案。在编写游戏代码时，你将不得不做出几个编码设计决策，但幸运的是，处理最常见情况的方法是众所周知的，并且有详细的文档。在本节中，我们将讨论最常见的设计模式之一，**单例**，它在简单项目中易于实现。
- en: A Singleton pattern is used when we need a single instance of an object, meaning
    that there shouldn’t be more than one instance of a class and that we want to
    be easily accessible (not necessarily, but useful in our scenario). We have plenty
    of cases in our game where this can be applied, for example, `ScoreManager`, a
    component that will hold the current score. In this case, we will never have more
    than one score, so we can take advantage of the benefits of the Singleton manager
    here.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式用于需要对象单个实例的情况，这意味着一个类不应该有多个实例，并且我们希望它易于访问（虽然不一定是必需的，但在我们的场景中很有用）。在我们的游戏中有很多情况可以应用这种模式，例如，`ScoreManager`，一个将保存当前得分的组件。在这种情况下，我们永远不会有多于一个的得分，因此我们可以利用单例管理器的优势。
- en: One benefit is being sure that we won’t have duplicated scores, which makes
    our code less error prone. Also, so far, we have needed to create public references
    and drag objects via the editor to connect two objects, or look for them using
    `GetComponent`; with this pattern, however, we will have global access to our
    Singleton component, meaning you can just write the name of the component in your
    script and you will access it. In the end, there’s just one `ScoreManager` component,
    so specifying which one via the editor is redundant. This is similar to `Time.deltaTime`,
    the class responsible for managing time—we have just one time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好处是确保我们不会有重复的得分，这使我们的代码更不容易出错。此外，到目前为止，我们需要创建公共引用并通过编辑器拖动对象来连接两个对象，或者使用`GetComponent`来查找它们；然而，使用这种模式，我们将能够全局访问我们的单例组件，这意味着你只需在脚本中写下组件的名称，就可以访问它。最终，只有一个`ScoreManager`组件，所以通过编辑器指定哪一个是没有必要的。这类似于`Time.deltaTime`，负责管理时间的类——我们只有一个时间。
- en: If you are an advanced programmer, you may be thinking about code testing and
    dependency injection now, and you are right, but remember, we are trying to write
    simple code so far, so we will stick to this simple solution.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个高级程序员，你现在可能正在考虑代码测试和依赖注入，你是对的，但请记住，我们到目前为止一直在尝试编写简单的代码，所以我们将坚持这个简单的解决方案。
- en: 'Let’s create a **Score Manager** object, responsible for handling the score,
    to show an example of a Singleton by doing the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个**得分管理器**对象，负责处理得分，以下是如何通过单例的示例：
- en: Create an empty GameObject (**GameObject | Create Empty**) and call it `ScoreManager`;
    usually, managers are put in empty objects, separated from the rest of the scene’s
    objects.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的GameObject（**GameObject | 创建空对象**），并将其命名为`ScoreManager`；通常，管理器被放在空对象中，与场景中的其他对象分开。
- en: Add a script called `ScoreManager` to this object with an `int` field called
    `amount` that will hold the current score.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为`ScoreManager`的脚本添加到该对象中，并添加一个名为`amount`的`int`字段，该字段将保存当前得分。
- en: 'Add a field of the `ScoreManager` type called `instance`, but add the `static`
    keyword to it; this will make the variable global, meaning it can be accessed
    anywhere by just writing its name:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`instance`的`ScoreManager`类型的字段，但向它添加`static`关键字；这将使变量全局，意味着只需写下它的名称就可以在任何地方访问它：
- en: '![](img/B18585_08_01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_01.png)'
- en: 'Figure 8.1: A static field that can be accessed anywhere in the code'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：一个可以在代码的任何地方访问的静态字段
- en: In `Awake`, check whether the `instance` field is not `null`, and in that case,
    set this `ScoreManager` instance as the instance reference using the `this` reference.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Awake`方法中，检查`instance`字段是否不为`null`，如果是，则使用`this`引用将该`ScoreManager`实例设置为实例引用。
- en: 'In the `else` clause of the `null` checking `if` statement, print a message
    indicating that there’s a second `ScoreManager` instance that must be destroyed:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`null`检查`if`语句的`else`子句中，打印一条消息，指出存在第二个`ScoreManager`实例，该实例必须被销毁：
- en: '![](img/B18585_08_02.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_02.png)'
- en: 'Figure 8.2: Checking whether there’s only one Singleton instance'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：检查是否只有一个单例实例
- en: The idea is to save the reference to the only `ScoreManager` instance in the
    instance static field, but if by mistake the user creates two objects with the
    `ScoreManager` component, this `if` statement will detect it and inform the user
    of the error, asking them to take action. In this scenario, the first `ScoreManager`
    instance to execute `Awake` will find that there’s no instance set (the field
    is `null`) so it will set itself as the current instance, while the second `ScoreManager`
    instance will find the instance is already set and will print the message.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是将对唯一的 `ScoreManager` 实例的引用保存在实例静态字段中，但如果用户不小心创建了两个具有 `ScoreManager` 组件的对象，这个
    `if` 语句将检测到它，并通知用户错误，要求他们采取行动。在这种情况下，首先执行 `Awake` 的 `ScoreManager` 实例会发现没有设置实例（字段是
    `null`），因此它会将自己设置为当前实例，而第二个 `ScoreManager` 实例会发现实例已经设置，并打印出消息。
- en: Remember that `instance` is a static field, shared between all classes, unlike
    regular reference fields, where each component will have its own reference, so
    in this case, we have two `ScoreManager` instances added to the scene, and they
    will share the same instance field.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`instance` 是一个静态字段，在所有类之间共享，与常规引用字段不同，每个组件将有自己的引用，因此在这种情况下，我们向场景中添加了两个 `ScoreManager`
    实例，它们将共享相同的实例字段。
- en: 'To improve the example a little bit, it would be ideal to have a simple way
    to find the second `ScoreManager` in the game. It will be hidden somewhere in
    the Hierarchy and it may be difficult to find, but we fix this by doing the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了稍微改进一下示例，最好有一种简单的方法来在游戏中找到第二个 `ScoreManager`。它将隐藏在 Hierarchy 的某个地方，可能很难找到，但我们通过以下方式解决这个问题：
- en: 'Replace `print` with `Debug.Log`. `Debug.Log` is similar to `print` but has
    a second argument that expects an object to be highlighted when the message is
    clicked in the console. In this case, we will pass the `gameObject` reference
    to allow the console to highlight the duplicated object:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `print` 替换为 `Debug.Log`。`Debug.Log` 与 `print` 类似，但它有一个期望在控制台中点击消息时突出显示对象的第二个参数。在这种情况下，我们将传递
    `gameObject` 引用，以便控制台突出显示复制的对象：
- en: '![](img/B18585_08_03.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_03.png)'
- en: 'Figure 8.3: Printing messages in the console with Debug.Log'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：使用 Debug.Log 在控制台打印消息
- en: 'After clicking the log message, the GameObject containing the duplicated `ScoreManager`
    will be highlighted in the Hierarchy:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 点击日志消息后，包含复制的 `ScoreManager` 的 GameObject 将在 Hierarchy 中突出显示：
- en: '![](img/B18585_08_04.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_04.png)'
- en: 'Figure 8.4: The highlighted object after clicking the message'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：点击消息后突出显示的对象
- en: 'Finally, a little improvement can be made here by replacing `Debug.Log` with
    `Debug.LogError`, which will also print the message but with an error icon. In
    a real game, you will have lots of messages in the console, and highlighting the
    errors over the information messages will help us to identify them quickly:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，可以通过将 `Debug.Log` 替换为 `Debug.LogError` 来在这里进行一点小小的改进，这将打印出消息，但会显示一个错误图标。在实际游戏中，控制台会有很多消息，通过突出显示错误信息而不是信息消息，可以帮助我们快速识别它们：
- en: '![](img/B18585_08_05.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_05.png)'
- en: 'Figure 8.5: Using LogError to print an error message'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：使用 LogError 打印错误消息
- en: 'Try the code and observe the error message in the console:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试运行代码并观察控制台中的错误消息：
- en: '![](img/B18585_08_06.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_06.png)'
- en: 'Figure 8.6: An error message in the console'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：控制台中的错误消息
- en: 'The next step would be to use this Singleton somewhere, so in this case, we
    will make the enemies give points when they are killed by doing the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在某个地方使用这个 Singleton，所以在这种情况下，我们将通过以下方式让敌人被击杀时获得分数：
- en: Add a script to the `Enemy` Prefab called `ScoreOnDeath` with an `int` field
    called `amount`, which will indicate the number of points the enemy will give
    when killed. Remember to set the value to something other than `0` in the editor
    for the Prefab.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为 `ScoreOnDeath` 的脚本添加到 `Enemy` 预制件中，其中包含一个名为 `amount` 的 `int` 字段，该字段将指示敌人被击杀时将获得的分数。请记住，在编辑器中将值设置为非
    `0`，以便为预制件设置。
- en: 'Create the `OnDestroy` event function, which will be automatically called by
    Unity when this object is destroyed, in our case, the enemy:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `OnDestroy` 事件函数，当此对象被销毁时，Unity 将自动调用此函数，在我们的例子中，是敌人：
- en: '![](img/B18585_08_07.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_07.png)'
- en: 'Figure 8.7: The OnDestroy event function'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：OnDestroy 事件函数
- en: Consider that the `OnDestroy` function is also called when we change scenes
    or the game is quitting, so in this scenario, we might get points when changing
    scenes, which is not correct. So far, this is not a problem in our case, but later
    in this chapter, we will see a way to prevent this.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们在更改场景或游戏退出时，`OnDestroy` 函数也会被调用，因此在这种情况下，我们可能会在更改场景时获得分数，这是不正确的。到目前为止，在我们的案例中这不是问题，但稍后在本章中，我们将看到一种防止这种情况的方法。
- en: 'Access the Singleton reference in the `OnDestroy` function by writing `ScoreManager.instance`,
    and add the `amount` field of our script to the `amount` field of the Singleton
    to increase the score when an enemy is killed:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OnDestroy` 函数中通过编写 `ScoreManager.instance` 来访问单例引用，并将我们脚本的 `amount` 字段添加到单例的
    `amount` 字段中，以便在敌人被击杀时增加分数：
- en: '![](img/B18585_08_08.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_08_08.png)'
- en: 'Figure 8.8: Full ScoreOnDeath component class contents'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8：完整的 ScoreOnDeath 组件类内容
- en: Select the `ScoreManager` in the Hierarchy, hit **Play**, and kill some enemies
    to see the score rise with every kill. Remember to set the `amount` field of the
    `ScoreOnDeath` component of the Prefab.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级中选择 `ScoreManager`，点击 **播放**，然后消灭一些敌人以查看分数随着每次击杀而上升。请记住设置 Prefab 中 `ScoreOnDeath`
    组件的 `amount` 字段。
- en: As you can see, the Singleton simplified a lot the way to access `ScoreManager`
    and have security measures to prevent duplicates of itself, which will help us
    to reduce errors in our code. Something to take into account is that now you will
    be tempted to just make everything a Singleton, such as the player’s life or player’s
    bullets and just to make your life easier when creating gameplay mechanics such
    as power-ups.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，单例模式简化了访问 `ScoreManager` 的方式，并采取了安全措施以防止其自身的重复，这将有助于我们减少代码中的错误。需要注意的是，现在您可能会倾向于将一切事物都做成单例，例如玩家的生命或玩家的子弹，以便在创建游戏机制如升级时使生活变得更简单。
- en: While that will totally work, remember that your game will change, and I mean
    change a lot; any real project will experience constant change. Maybe today, the
    game has just one player, but maybe in the future, you want to add a second player
    or an AI companion, and you want the power-ups to affect them too, so if you abuse
    the Singleton pattern, you will have trouble handling those scenarios and many
    more. Maybe a future player companion will try to get the health pickup but the
    main player will be healed instead!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这完全可行，但请记住，您的游戏将会发生变化，我的意思是变化会很大；任何真实的项目都会经历不断的变更。也许今天，游戏只有一个玩家，但也许在未来，您想添加第二个玩家或人工智能同伴，并且希望升级能够影响他们，所以如果您过度使用单例模式，您将难以处理这些场景以及更多的情况。也许未来的玩家同伴会尝试获取生命恢复物品，但主要玩家却被治愈了！
- en: The point here is to try to use the pattern as few times as you can, in case
    you don’t have any other way to solve the problem. To be honest, there are always
    ways to solve problems without Singleton, but they are a little bit more difficult
    to implement for beginners, so I prefer to simplify your life a little bit to
    keep you motivated. With enough practice, you will reach a point where you will
    be ready to improve your coding standards.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是尽量少使用这种模式，除非您没有其他方法来解决问题。说实话，总有办法在不使用单例的情况下解决问题，但它们对初学者来说实施起来要困难一些，所以我更喜欢简化您的生活，让您保持动力。随着足够的练习，您将达到一个可以准备好提高您的编码标准的阶段。
- en: Now, let’s discuss how to achieve this in Visual Scripting, which deserves its
    own section given that it will be a little bit different. You may consider skipping
    the following section if you are not interested in the Visual Scripting side of
    these scripts.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论如何在 Visual Scripting 中实现这一点，鉴于它会有所不同，它值得拥有自己的部分。如果您对 Visual Scripting
    方面不感兴趣，可以考虑跳过下面的部分。
- en: Sharing variables with Visual Scripting
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Visual Scripting 共享变量
- en: 'Visual Scripting has a mechanism that replaces Singleton as a holder of variables
    to be shared between objects: the **scene variables**. If you check the left panel
    in the **Script Graph** editor (the window where we edit the nodes of a script)
    under the `Blackboard` panel (the panel that shows the variables of our object),
    you will notice it will have many tabs: **Graph**, **Object**, **Scene**, **App**
    and **Saved**. If you don’t see `Blackboard` panel, click the third button from
    left to right at the top-left part of the window, the button at the right of the
    **i** (information) button:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉脚本有一个机制，用**场景变量**取代单例作为对象间共享变量的持有者：**场景变量**。如果你检查**脚本图**编辑器（我们编辑脚本节点窗口）中的左侧面板（显示我们对象变量的面板），你会注意到它将有许多标签页：**图**、**对象**、**场景**、**应用**和**已保存**。如果你看不到**黑板**面板，点击窗口左上角从左数第三个按钮，即**i**（信息）按钮右侧的按钮：
- en: '![](img/B18585_08_09.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_08_09.png)'
- en: 'Figure 8.9: Blackboard (variables) editor in Script Graph'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：脚本图（变量）编辑器
- en: 'So far, when we created a variable in the **Variables** component of any object,
    we were actually creating **Object Variables**: variables that belongs to an object
    and are shared between all Visual Scripts in that one, but that’s not the only
    scope a variable can have. Here’s a list of the remaining scopes:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当我们在任何对象的**变量**组件中创建一个变量时，我们实际上是在创建**对象变量**：属于对象的变量，在同一个对象的所有视觉脚本之间共享，但变量可以拥有的作用域不止这一种。以下是一个剩余作用域的列表：
- en: '**Graph**: Variables that can only be accessed by our current graph. No other
    script can read or write that variable. This is useful to save internal state,
    like private variables in C#.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图**：只能由我们当前图访问的变量。其他脚本不能读取或写入该变量。这有助于保存内部状态，如C#中的私有变量。'
- en: '**Scene**: Variables that can be accessed by all objects in the current scene.
    When we change the scene, those variables are lost.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景**：可以被当前场景中所有对象访问的变量。当我们更改场景时，这些变量就会丢失。'
- en: '**App**: Variables that can be accessed in any part of the game at any time.
    This is useful to move values from one scene to the other. For example, you can
    increase the score in one level and keep increasing it in the next, instead of
    restarting the score from 0.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用**：可以在游戏的任何部分任何时间访问的变量。这有助于将值从一个场景移动到另一个场景。例如，你可以在一个级别中增加分数，并在下一个级别中继续增加，而不是从0重新开始分数。'
- en: '**Saved**: Variables whose values are kept between game runs. You can save
    persistent data such as the **Player Level** or **Inventory** to continue the
    quest, or simpler things such as the sound volume as set by the user in the **Options**
    menu (if you created one).'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已保存**：在游戏运行之间保持其值的变量。你可以保存持久数据，如**玩家等级**或**库存**以继续任务，或者更简单的事情，如用户在**选项**菜单中设置的音量（如果你创建了一个）。'
- en: In this case, the **Scene** scope is the one we want, as the score we intend
    to increase will be accessed by several objects in the scene (more on that later)
    and we don’t want it to persist if we reset the level to play again; it will need
    to be set again to 0 in each run of the level and game.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**场景**作用域是我们想要的，因为我们打算增加的分数将被场景中的多个对象访问（关于这一点稍后讨论），我们不希望它在重置级别以再次播放时持续存在；它需要在每个级别的每次运行和游戏中重新设置为0。
- en: To create scene variables, you can simply select the **Scene** tab in the **Blackboard**
    pane of the **Script Graph** editor, while you are editing any **Script Graph**,
    or you can also use the **Scene Variables** GameObject that was created automatically
    when you started editing any graph. That object is the one that really holds the
    variables and must not be deleted. You will notice it will have a **Variables**
    component as we have used before, but it will also have the **Scene** **Variables**
    component, indicating those variables are scene variables.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建场景变量，你可以在编辑任何**脚本图**时，简单地选择**黑板**面板中的**场景**标签页，或者你也可以使用当你开始编辑任何图时自动创建的**场景变量**GameObject。这个对象是真正持有变量的那个，不能被删除。你会注意到它将有一个**变量**组件，就像我们之前使用的那样，但它还将有一个**场景****变量**组件，表示这些变量是场景变量。
- en: In the following screenshot, you can see how we have simply added the **Score**
    variable to the **Scene Variables** tab to make it accessible in any of our Script
    Graphs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，你可以看到我们如何简单地添加了**分数**变量到**场景变量**标签页，使其在我们的任何脚本图中都可以访问。
- en: '![](img/B18585_08_10.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_08_10.png)'
- en: 'Figure 8.10: Adding scene variables to our game'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：将场景变量添加到我们的游戏中
- en: Finally, for the score-increasing behavior, we can add the following graph to
    our enemy. Remember, as usual, to have the C# or the Visual Scripting version
    of the scripts, not both.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于增加分数的行为，我们可以在我们的敌人中添加以下图表。记住，像往常一样，只保留C#或视觉脚本版本的脚本，不要两者都保留。
- en: '![](img/B18585_08_11.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_11.png)'
- en: 'Figure 8.11: Adding score when this object is destroyed'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：当此对象被销毁时增加分数
- en: At first, this script seems pretty similar to our C# version; we add our `scoreToAdd`
    variable of our object (**Object** scope) and then we add it to the whole scene’s
    `score` variable, as specified in the node. The main difference you can see is
    that here we are using the **OnDisable** event instead of **OnDestroy**. Actually,
    **OnDestroy** is the correct one, but in the current version of Visual Scripting
    there is a bug that prevents it from working properly, so I replaced it for now.
    The problem with **OnDisable** is that it executes whenever the object is disabled,
    and while the object is disabled before it is destroyed, it can also be disabled
    in other circumstances (for example, using **Object Pooling**, a way to recycle
    objects instead of destroying and instancing them constantly), but so far it is
    enough for us. Please consider trying first with **OnDestroy** when you try this
    graph to see if it runs properly in your Unity or Visual Scripting package version.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个脚本看起来与我们的C#版本非常相似；我们添加我们的对象`scoreToAdd`变量（**对象**范围）并将其添加到节点中指定的整个场景的`score`变量中。您可以看到的主要区别是，这里我们使用的是**OnDisable**事件而不是**OnDestroy**。实际上，**OnDestroy**是正确的选择，但在当前版本的视觉脚本中存在一个错误，阻止它正常工作，所以我暂时替换了它。**OnDisable**的问题在于它会在对象被禁用时执行，而对象在被销毁之前可能被禁用，也可能在其他情况下被禁用（例如，使用**Object
    Pooling**，这是一种回收对象而不是不断销毁和实例化对象的方法），但到目前为止这对我们来说已经足够了。请在尝试此图表时首先考虑使用**OnDestroy**，以查看它是否在您的Unity或视觉脚本包版本中正常运行。
- en: Something to highlight is the usage of the **Has Variable** node to check if
    the **score variable** exists. This is done because **OnDisable** can be executed
    either at the moment of the enemy being destroyed, or when the scene changes,
    which we will do later this chapter with the lose/win screens. If we try to get
    a scene variable at that moment, we risk getting an error ourselves if the **Scene
    Variables** object is destroyed before the **GameMode** object, given the change
    of scene involves destroying every object in the scene first.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，使用**Has Variable**节点来检查**分数变量**是否存在。这样做是因为**OnDisable**可以在敌人被销毁的瞬间执行，或者当场景改变时执行，我们将在本章后面的内容中通过输赢屏幕来实现这一点。如果我们试图在那个时刻获取场景变量，由于场景变化涉及首先销毁场景中的每个对象，我们可能会在**GameMode**对象之前销毁**Scene
    Variables**对象，从而风险自己遇到错误。
- en: As you may noticed by now, even if Visual Scripting is mostly extremely similar
    to C#, one has concepts to solve certain scenarios that the other doesn’t. Now
    that we know how to share variables, let’s finish some other managers that we
    will need later in the game.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在可能已经注意到的，尽管视觉脚本（Visual Scripting）在大多数情况下与C#非常相似，但有一种概念可以解决另一种无法解决的问题。现在我们知道了如何共享变量，让我们完成一些我们在游戏后期需要的其他管理器。
- en: Creating managers
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建管理器
- en: Sometimes, we need a place to put together information about a group of similar
    objects, for example, `EnemyManager`, to check the number of enemies and potentially
    access an array of them to iterate over them and do something, or maybe `MissionManager`,
    to have access to all of the active missions in our game. Again, these cases can
    be considered Singletons, single objects that won’t be repeated (in our current
    game design), so let’s create the ones we will need in our game, that is, `EnemyManager`
    and `WaveManager`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要一个地方来汇总一组相似对象的信息，例如，`EnemyManager`，用于检查敌人的数量，并可能访问它们的数组以遍历并执行某些操作，或者可能是`MissionManager`，以便访问我们游戏中的所有活动任务。再次强调，这些情况可以被视为单例（Singletons），即不会重复出现的单个对象（在我们的当前游戏设计中），因此让我们创建我们在游戏中需要的那些，即`EnemyManager`和`WaveManager`。
- en: In our game, `EnemyManager` and `WaveManager` will just be used as places to
    save an array of references to the existing enemies and waves in our game, just
    as a way to know their current amount. There are ways to search all objects of
    a certain type to calculate their count, but those functions are expensive and
    not recommended for use unless you really know what you are doing. So, having
    a Singleton with a separate updated list of references to the target object type
    will require more code but will perform better. Also, as the game features increase,
    these managers will have more functionality and helper functions to interact with
    those objects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，`EnemyManager`和`WaveManager`将仅用作保存现有敌人和波次的引用数组的存储位置，就像知道它们当前数量的方式一样。有方法可以搜索特定类型的所有对象来计算它们的数量，但这些函数成本高昂，除非你真的知道你在做什么，否则不建议使用。因此，拥有一个具有单独更新目标对象类型引用列表的单例将需要更多的代码，但性能会更好。此外，随着游戏功能的增加，这些管理器将具有更多功能以及与这些对象交互的帮助函数。
- en: 'Let’s start with the enemies manager by doing the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从敌人管理器开始，执行以下操作：
- en: Add a script called `Enemy` to the **Enemy** Prefab; this will be the script
    that will connect this object with `EnemyManager` in a moment.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向**Enemy**预设件添加一个名为`Enemy`的脚本；这将是一个将此对象与`EnemyManager`连接的脚本。
- en: Create an empty `GameObject` called `EnemyManager` and add a script to it called
    `EnemiesManager`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`EnemyManager`的空`GameObject`，并向其添加一个名为`EnemiesManager`的脚本。
- en: Create a `public` static field of the `EnemiesManager` type called `instance`
    inside the script and add the Singleton repetition check in `Awake` as we did
    in `ScoreManager`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本内部创建一个名为`instance`的`public`静态字段，类型为`EnemiesManager`，并在`Awake`中添加单例重复检查，就像我们在`ScoreManager`中做的那样。
- en: 'Create a public field of the `List<Enemy>` type called `enemies`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`enemies`的公共字段，类型为`List<Enemy>`：
- en: '![](img/B18585_08_12.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_12.png)'
- en: 'Figure 8.12: List of Enemy components'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：敌人组件列表
- en: 'A list in C# represents a dynamic array, an array capable of adding and removing
    objects. You will see that you can add and remove elements to this list in the
    editor, but keep the list empty; we will add enemies another way. Take into account
    that `List` is in the `System.Collections.Generic` namespace; you will find the
    `using` sentence at the beginning of our script. Also, consider that you can make
    the list private and expose it to the code via a getter instead of making it a
    public field; but as usual, we will make our code as simple as possible for now:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的列表表示一个动态数组，一个能够添加和删除对象的数组。你会在编辑器中看到你可以向此列表添加和删除元素，但请保持列表为空；我们将以另一种方式添加敌人。请注意，`List`位于`System.Collections.Generic`命名空间中；你将在我们脚本的开始处找到`using`语句。此外，考虑到你可以将列表设置为私有，并通过getter而不是公共字段将其暴露给代码；但像往常一样，我们现在将使代码尽可能简单：
- en: '![](img/B18585_08_13.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_13.png)'
- en: 'Figure 8.13: Using needed to use the List class'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：使用List类所需的using语句
- en: Consider that `List` is a class type, so it must be instantiated, but as this
    type has exposing support in the editor, Unity will automatically instantiate
    it. You must use the `new` keyword to instantiate it in cases where you want a
    non-editor-exposed list, such as a private one or a list in a regular non-component
    C# class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到`List`是一个类类型，因此必须实例化，但由于此类型在编辑器中具有暴露支持，Unity将自动实例化它。如果你想要一个非编辑器暴露的列表，如私有列表或常规非组件C#类中的列表，你必须使用`new`关键字来实例化它。
- en: The C# list internally is implemented as an array. If you need a linked list,
    use the `LinkedList` collection type instead.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的列表在内部实现为一个数组。如果你需要一个链表，请使用`LinkedList`集合类型代替。
- en: In the `Start` function of the `Enemy` script, access the `EnemyManager` Singleton
    and using the `Add` function of the enemies list, add this object to the list.
    This will “register” this enemy as active in the manager, so other objects can
    access the manager and check for the current enemies. The `Start` function is
    called after all of the `Awake` function calls, and this is important because
    we need to be sure that the `Awake` function of the manager is executed prior
    to the `Start` function of the enemy to ensure that there is a manager set as
    the instance.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Enemy`脚本的`Start`函数中，访问`EnemyManager`单例，并使用敌人列表的`Add`函数，将此对象添加到列表中。这将“注册”此敌人在管理器中的活动状态，以便其他对象可以访问管理器并检查当前敌人。`Start`函数在所有`Awake`函数调用之后被调用，这很重要，因为我们需要确保在敌人`Start`函数之前执行管理器的`Awake`函数，以确保已设置管理器实例。
- en: The problem we solved with the `Start` function is called a race condition,
    that is, when two pieces of code are not guaranteed to be executed in the same
    order, whereas `Awake` execution order can change due to different reasons. There
    are plenty of situations in code that this will happen, so pay attention to the
    possible race conditions in your code. Also, you might consider using more advanced
    solutions such as `lazy initialization` here, which can give you better stability,
    but again, for the sake of simplicity and exploring the Unity API, we will use
    the `Start` function approach for now.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`Start`函数解决的问题被称为竞态条件，即当两段代码不能保证按相同顺序执行时，而`Awake`的执行顺序可能会因不同原因而改变。代码中有很多情况都会发生这种情况，所以请注意你代码中可能存在的竞态条件。此外，你可能考虑在这里使用更高级的解决方案，如`懒初始化`，这可以给你更好的稳定性，但为了简单起见，以及探索Unity
    API，我们目前将使用`Start`函数的方法。
- en: 'In the `OnDestroy` function, remove the enemy from the list to keep the list
    updated with just the active ones:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnDestroy`函数中，从列表中移除敌人以保持列表只更新活跃的敌人：
- en: '![](img/B18585_08_14.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_08_14.png)'
- en: 'Figure 8.14: The enemy script to register ourselves as an active enemy'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：注册为我们自己的活跃敌人的敌人脚本
- en: 'With this, now we have a centralized place to access all of the active enemies
    in a simple but efficient way. I challenge you to do the same with the waves,
    using `WaveManager`, which will have the collection of all active waves to later
    check whether all waves finished their work to consider the game as won. Take
    some time to solve this; you will find the solution in the following screenshots,
    starting with `WavesManager`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们现在有一个集中的地方可以以简单而有效的方式访问所有活跃的敌人。我挑战你使用`WaveManager`以同样的方式来做，这将有一个所有活跃波浪的集合，以便稍后检查是否所有波浪都完成了它们的工作，以考虑游戏胜利。花些时间解决这个问题；你将在下面的截图中发现解决方案，从`WavesManager`开始：
- en: '![](img/B18585_08_15.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_08_15.png)'
- en: 'Figure 8.15: The full WavesManager script'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：完整的WavesManager脚本
- en: 'You will also need the `WaveSpawner` script:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要`WaveSpawner`脚本：
- en: '![](img/B18585_08_16.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_08_16.png)'
- en: 'Figure 8.16: The modified WaveSpawner script to support WavesManager'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16：支持WavesManager的修改后的WaveSpawner脚本
- en: As you can see, `WaveManager` is created the same way `EnemyManager` was, just
    a Singleton with a list of `WaveSpawner` references, but `WaveSpawner` is different.
    We execute the `Add` function of the list in the `Start` event of `WaveSpawner`
    to register the wave as an active one, but the `Remove` function needs more work.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`WaveManager`的创建方式与`EnemyManager`相同，只是一个带有`WaveSpawner`引用列表的单例，但`WaveSpawner`是不同的。我们在`WaveSpawner`的`Start`事件中执行列表的`Add`函数来注册波浪为活跃波浪，但`Remove`函数需要做更多的工作。
- en: The idea is to deregister the wave from the active waves list when the spawner
    finishes its work. Before this modification, we used `Invoke` to call the `CancelInvoke`
    function after a while to stop the spawning, but now we need to do more after
    the end time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是在生成器完成工作后从活跃波浪列表中注销波浪。在这次修改之前，我们使用`Invoke`在一段时间后调用`CancelInvoke`函数来停止生成，但现在我们需要在结束时间之后做更多的事情。
- en: Instead of calling `CancelInvoke` after the specified wave end time, we will
    call a custom function called `EndSpawner`, which will call `CancelInvoke` to
    stop the spawner, `Invoke Repeating`, but also will call the remove-from-`WavesManager`-list
    function to make sure the removing-from-the-list function is called exactly when
    `WaveSpawner` finishes its work.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在指定的波浪结束时间后调用`CancelInvoke`，我们将调用一个名为`EndSpawner`的自定义函数，该函数将调用`CancelInvoke`来停止生成器，`Invoke
    Repeating`，同时还会调用从`WavesManager`列表中移除的函数，以确保在`WaveSpawner`完成其工作的时候正好调用移除列表的函数。
- en: 'Regarding the Visual Scripting version, we can add two lists of GameObject
    type to the scene variables to hold the references to the existing waves and enemies
    so we can keep track of them. Just search `"List of GameObject"` in the search
    bar of the variable type selector and you will find it. In this case, the lists
    contain only GameObjects given that the Visual Scripting versions of **WaveSpawner**
    and enemy scripts are not types we can reference like C# ones. If you did both
    C# and Visual Scripting versions of these you will see you can reference the C#
    versions, but we are not going to mix C# and Visual Scripting as it is out of
    the scope of the book, so ignore them. Anyway, given how the **Variables** system
    of Visual Scripting works, we can still access variables inside if needed using
    the **GetVariable** node—remember the variables are not in the Visual Scripts
    but in the **Variables** node:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，我们可以在场景变量中添加两个GameObject类型的列表来保存现有波浪和敌人的引用，这样我们就可以跟踪它们。只需在变量类型选择器的搜索栏中搜索“GameObject列表”，你就可以找到它。在这种情况下，由于**WaveSpawner**和敌人脚本的视觉脚本版本不是我们可以像C#那样引用的类型，所以列表中只包含GameObject。如果你同时创建了这些脚本的C#和视觉脚本版本，你会看到你可以引用C#版本，但我们将不会混合C#和视觉脚本，因为这超出了本书的范围，所以忽略它们。无论如何，鉴于视觉脚本**变量**系统的工作方式，我们仍然可以使用**获取变量**节点在需要时访问变量内部——记住变量不在视觉脚本中，而是在**变量**节点中：
- en: '![](img/B18585_08_17.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_08_17.png)'
- en: 'Figure 8.17: Adding lists to the Scene variables'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17：将列表添加到场景变量
- en: 'Then, we can add the following to the **WaveSpawner** graph:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在**WaveSpawner**图表中添加以下内容：
- en: '![](img/B18585_08_18.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_08_18.png)'
- en: 'Figure 8.18: Adding elements to List'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18：向列表中添加元素
- en: 'We used the **Add List Item** node to add our GameObject to the **waves** variable.
    We did this as the first thing to do in the **On Start** event node before anything.
    And to remove that wave from the active ones you will need to make the following
    change:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**添加列表项**节点将我们的GameObject添加到**波浪**变量中。我们在**On Start**事件节点之前将其作为第一件事来做。要移除这个波浪从活动波浪中，你需要进行以下更改：
- en: '![](img/B18585_08_19.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_08_19.png)'
- en: 'Figure 8.19: Removing elements from the List'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19：从列表中移除元素
- en: We remove this spawner from the list using the **Exit** flow output pin of the
    **For Loop**, which is executed when the `for` loop finishes iterating.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**For Loop**的**Exit**流程输出引脚从列表中移除这个生成器，这是在`for`循环完成迭代时执行的。
- en: 'Finally, regarding **Enemy**, you will need to create a new **Enemy Script**
    graph that will look similar:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于**敌人**，你需要创建一个新的**敌人脚本**图表，其外观将类似：
- en: '![](img/B18585_08_20.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_08_20.png)'
- en: 'Figure 8.20: Enemy Adding and removing itself from the Lists'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20：敌人添加和从列表中移除自身
- en: As you can see, we simply add the enemy on **OnStart** and remove it in **OnDisable**.
    Remember to try first using **OnDestroy** instead of **OnDisable** due to the
    bug we mentioned previously. You can check these changes by playing the game while
    having the **Scene Variables** GameObject selected and seeing how its value changes.
    Also remember the need to use the **Has Variable** node in case we are changing
    scenes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们只是在**OnStart**时添加敌人，在**OnDisable**时移除它。记住，由于我们之前提到的错误，首先尝试使用**OnDestroy**而不是**OnDisable**。你可以通过在**场景变量**GameObject被选中时玩游戏来检查这些更改，并看到其值如何变化。还要记住，如果我们正在更改场景，需要使用**有变量**节点。
- en: Using Object managers, we now have centralized information about a group of
    objects, and we can add all sorts of object group logic here. We created the `EnemiesManager`,
    `WavesManager`, and `ScoreManager` as centralized places to store several game
    systems’ information, such as the enemies and waves present in the scene, and
    the score as well. We also saw the Visual Scripting version, centralizing that
    data in the Scene Variables object, so all Visual Scripts can read that data.
    But aside from having this information for updating the UI (which we will do in
    the next chapter), we can use this information to detect whether the victory and
    lose conditions of our game are met, creating a **Game Mode** object to detect
    that.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象管理器，我们现在可以集中管理一组对象的信息，并且可以在这里添加各种对象组逻辑。我们创建了`EnemiesManager`、`WavesManager`和`ScoreManager`作为集中存储多个游戏系统信息的中心位置，例如场景中存在的敌人和波浪，以及分数。我们还看到了视觉脚本版本，将数据集中存储在场景变量对象中，这样所有的视觉脚本都可以读取这些数据。但除了为了更新UI（我们将在下一章中这样做）而拥有这些信息之外，我们还可以使用这些信息来检测我们的游戏是否满足胜利和失败条件，创建一个**游戏模式**对象来检测。
- en: Creating Game Modes
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游戏模式
- en: We have created objects to simulate lots of gameplay aspects of our game, but
    the game needs to end sometime, whether we win or lose. As always, the question
    is where to put this logic, and that leads us to further questions. The main questions
    would be, will we always win or lose the game the same way? Will we have a special
    level with different criteria than “kill all of the waves,” such as a timed survival?
    Only you know the answer to those questions, but if right now the answer is no,
    it doesn’t mean that it won’t change later, so it is advisable to prepare our
    code to adapt seamlessly to changes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了对象来模拟游戏中的许多游戏玩法方面，但游戏总需要结束，无论我们赢或输。一如既往，问题是将这种逻辑放在哪里，这引出了更多的问题。主要问题将是，我们是否总是以相同的方式赢或输游戏？我们是否会有一个特殊的关卡，其标准不同于“消灭所有波次”，例如有时间限制的生存？只有你知道这些问题的答案，但如果现在答案是“不”，并不意味着它不会在以后改变，因此建议我们准备代码以无缝适应变化。
- en: To be honest, preparing code to adapt seamlessly to changes is almost impossible;
    there’s no way to have code that takes into account every possible case, and we
    will always need to rewrite some code sooner or later. We will try to make the
    code as adaptable as possible to changes; always doing that doesn’t consume lots
    of developing time and it’s sometimes preferable to write simple code fast than
    complex code slow that might not be necessary, and so we suggest you balance your
    time budget wisely.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，准备代码以无缝适应变化几乎是不可能的；没有一种方法可以考虑到每个可能的情况，我们迟早都需要重写一些代码。我们将尝试使代码尽可能适应变化；总是这样做不会消耗太多开发时间，有时快速编写简单的代码比慢速编写可能不必要的复杂代码更可取，因此我们建议您明智地平衡时间预算。
- en: To do this, we will separate the Victory and Lose conditions’ logic in its own
    object, which I like to call the “Game Mode” (not necessarily an industry standard).
    This will be a component that will oversee the game, checking conditions that
    need to be met in order to consider the game over. It will be like the referee
    of our game. The Game Mode will constantly check the information in the object
    managers and maybe other sources of information to detect the needed conditions.
    Having this object separated from other objects allows us to create different
    levels with different Game Modes; just use another Game Mode script in that level
    and that’s all.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将胜利和失败条件的逻辑分离到自己的对象中，我喜欢将其称为“游戏模式”（不一定是行业标准）。这将是一个将监督游戏、检查需要满足的条件以考虑游戏结束的组件。它将像我们游戏中的裁判。游戏模式将不断检查对象管理器中的信息以及可能的其他信息源，以检测所需条件。将此对象与其他对象分离，使我们能够创建具有不同游戏模式的关卡；只需在该关卡中使用另一个游戏模式脚本即可。
- en: 'In our case, we will have a single Game Mode for now, which will check whether
    the number of waves and enemies becomes 0, meaning that we have killed all of
    the possible enemies and the game is won. Also, it will check whether the life
    of the player reaches 0, considering the game as lost in that situation. Let’s
    create it by doing the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个例子中，我们现在将只有一个游戏模式，它将检查波次和敌人的数量是否变为`0`，这意味着我们已经杀死了所有可能的敌人，游戏胜利。同时，它还将检查玩家的生命值是否达到`0`，在这种情况下，将游戏视为失败。让我们通过以下步骤创建它：
- en: Create an empty `GameMode` object and add a `WavesGameMode` script to it. As
    you can see, we gave the script a descriptive name considering that we can add
    other Game Modes.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的`GameMode`对象，并向其中添加一个`WavesGameMode`脚本。正如你所见，我们给脚本起了一个描述性的名字，考虑到我们可以添加其他游戏模式。
- en: In its `Update` function, check whether the number of enemies and waves has
    reached `0` by using the `Enemy` and `Wave` managers; in that case, just `print`
    a message in the console for now. All lists have a `Count` property, which will
    tell you the number of elements stored inside.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其`Update`函数中，使用`Enemy`和`Wave`管理器检查敌人波次数量是否达到`0`；在这种情况下，目前只需在控制台`print`一条消息。所有列表都有一个`Count`属性，它将告诉你存储在内部元素的数量。
- en: Add a `public` field of the `Life` type called `PlayerLife` and drag the player
    to that one; the idea is to also detect the lose condition here.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`PlayerLife`的`public`字段，其类型为`Life`，并将玩家拖到该字段；这里的想法是也要检测失败条件。
- en: 'In `Update`, add another check to detect whether the life amount of the `playerLife`
    reference reached `0`, and in that case, `print` a lose message in the console:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update`中，添加另一个检查以检测`playerLife`引用的生命值是否达到`0`，在这种情况下，在控制台`print`一条失败消息：
- en: '![](img/B18585_08_21.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_08_21.png)'
- en: 'Figure 8.21: Win and lose condition checks in WavesGameMode'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21：WavesGameMode中的胜利和失败条件检查
- en: Play the game and test both cases, whether the player life reaches 0 or whether
    you have killed all enemies and waves.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩游戏并测试两种情况，即玩家生命值是否达到0，或者你是否已经杀死了所有敌人以及所有波次。
- en: 'Now, it is time to replace the messages with something more interesting. For
    now, we will just change the current scene to a **Win Scene** or **Lose Scene**,
    which will only have a UI with a win or lose message and a button to play again.
    In the future, you can add a Main Menu scene and have an option to get back to
    it. Let’s implement this by doing the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候用更有趣的消息替换它们了。目前，我们只是将当前场景更改为**胜利场景**或**失败场景**，这两个场景将只包含带有胜利或失败消息以及一个重新开始按钮的UI。将来，你可以添加一个主菜单场景，并有一个选项返回到它。让我们通过以下步骤来实现：
- en: Create a new scene (**File | New Scene**) and save it, calling it `WinScreen`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景（**文件 | 新场景**）并保存它，命名为`WinScreen`。
- en: Add something to indicate that this is the win screen, such as simply a sphere
    with the camera pointing to it. This way we know when we changed to the win screen.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些指示这是胜利场景的东西，比如简单地用一个摄像机指向的球体。这样我们就可以知道何时切换到胜利场景。
- en: Select the scene in the **Project View** and press *Ctrl* + *D* (*Cmd* + *D*
    on Mac) to duplicate the scene. Rename it `LoseScreen`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目视图**中选择场景，然后按*Ctrl* + *D*（在Mac上为*Cmd* + *D*）来复制场景。将其重命名为`LoseScreen`。
- en: Double-click the `LoseScreen` scene to open it and change the sphere to something
    different, maybe a cube.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`LoseScreen`场景以打开它，并将球体更改为其他东西，比如一个立方体。
- en: Go to **File | Build Settings** to open the **Scenes in Build** list inside
    this window.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**文件 | 构建设置**以打开此窗口内的**构建中的场景**列表。
- en: 'The idea is that Unity needs you to explicitly declare all scenes that must
    be included in the game. You might have test scenes or scenes that you don’t want
    to release yet, so that’s why we need to do this. In our case, our game will have
    `WinScreen`, `LoseScreen`, and the scene we have created so far with the game
    scenario, which I called `Game`, so just drag those scenes from the **Project
    View** to the list of the **Build Settings** window; we will need this to make
    the Game Mode script change between scenes properly. Also, consider that the first
    scene in this list will be the first scene to be opened when we play the game
    in its final version (known as the build), so you may want to rearrange the list
    according to that:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是Unity需要你明确声明所有必须包含在游戏中的场景。你可能有一些测试场景或你不想发布的场景，这就是为什么我们需要这样做。在我们的案例中，我们的游戏将包含`WinScreen`、`LoseScreen`以及我们迄今为止创建的带有游戏场景的场景，我将其称为`Game`，所以只需将这些场景从**项目视图**拖到**构建设置**窗口的列表中；我们需要这样做才能使游戏模式脚本在场景之间正确切换。此外，考虑到列表中的第一个场景将是我们在最终版本（称为构建）中玩游戏时首先打开的场景，所以你可能想要根据这一点重新排列列表：
- en: '![](img/B18585_08_22.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_22.png)'
- en: 'Figure 8.22: Registering the scenes to be included in the build of the game'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22：将场景注册到游戏的构建中
- en: In `WavesGameMode`, add a `using` statement for the `UnityEngine.SceneManagement`
    namespace to enable the scene changing functions in this script.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WavesGameMode`中添加对`UnityEngine.SceneManagement`命名空间的`using`语句，以启用此脚本中的场景更改功能。
- en: Replace the console `print` messages with calls to the `SceneManager.LoadScene`
    function, which will receive a string with the name of the scene to load; in this
    case, it would be `WinScreen` and `LoseScreen`. You just need the scene name,
    not the entire path to the file.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将控制台`print`消息替换为调用`SceneManager.LoadScene`函数的调用，该函数将接收一个包含要加载的场景名称的字符串；在这种情况下，将是`WinScreen`和`LoseScreen`。你只需要场景名称，而不需要文件的完整路径。
- en: 'If you want to chain different levels, you can create a `public` string field
    to allow you to specify via editor which scenes to load. Remember to have the
    scenes added to the **Build Settings**, if not, you will receive an error message
    in the console when you try to change the scenes:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想链接不同的层级，你可以创建一个`public`字符串字段，以便你通过编辑器指定要加载的场景。记住将场景添加到**构建设置**中，否则，当你尝试更改场景时，控制台将显示错误信息：
- en: '![](img/B18585_08_23.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_23.png)'
- en: 'Figure 8.23: Changing scenes with SceneManager'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23：使用SceneManager更改场景
- en: Play the game and check whether the scenes change properly.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩游戏并检查场景是否正确更改。
- en: Right now, we picked the simplest way to show whether we lost or won, but in
    the future, you may want something gentler than a sudden change of scene, such
    as maybe waiting a few moments with `Invoke` to delay that change or directly
    show the winning message inside the game without changing scenes. Bear this in
    mind when testing the game with people and checking whether they understood what
    happened when they were playing—game feedback is important to keep the player
    aware of what is happening and is not an easy task to tackle.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们选择了最简单的方式来显示我们输赢的状态，但将来，你可能想要比场景突然变化更柔和的方式，比如使用`Invoke`等待几秒钟来延迟变化，或者直接在游戏中显示获胜信息而不改变场景。在测试游戏并检查玩家在玩游戏时是否理解发生了什么时，请记住这一点——游戏反馈对于让玩家了解正在发生的事情非常重要，并且这不是一个容易解决的问题。
- en: 'Regarding the Visual Scripting version, we added a new Script Graph to a separated
    object. Let’s examine it piece by piece to see it clearly. Let’s start with the
    win condition:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，我们在一个分离的对象中添加了一个新的脚本图。让我们逐个检查它，以便更清楚地了解它。让我们从胜利条件开始：
- en: '![](img/B18585_08_24.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_08_24.png)'
- en: 'Figure 8.24: Win condition in Visual Scripting'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24：在视觉脚本中的胜利条件
- en: Here, we are getting the **Enemies** list from the scene context (**GetVariable**
    node), and knowing that it contains a List, we are using the **Count Items** node
    to check how many enemies remain in this list. Remember we have a script that
    adds the enemy to the list when it’s spawned and removes it when it is destroyed.
    We do the same for the waves, so combine the conditions with an **And** node and
    connect it with an **If** to then do something (more on that in a moment).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从场景上下文中获取**敌人**列表（**获取变量**节点），并且知道它包含一个列表，所以我们使用**计数项**节点来检查这个列表中剩余多少敌人。记住，我们有一个脚本在敌人被生成时将其添加到列表中，在它被销毁时将其移除。我们对波次也做同样的处理，所以将条件与**与**节点组合，并通过**如果**节点连接，然后执行某些操作（更多内容将在稍后讨论）。
- en: 'Now let’s examine the Lose condition:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来检查失败条件：
- en: '![](img/B18585_08_25.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_08_25.png)'
- en: 'Figure 8.25: Lose condition in Visual Scripting'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25：视觉脚本中的失败条件
- en: As the player’s life is not in the scene context (and shouldn’t be), and the
    player is a different GameObject from the one called `GameMode` (the one we created
    specifically for this script), we need a variable of type GameObject called **player**
    to reference it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于玩家的生命值不在场景上下文中（也不应该），而且玩家是一个与名为`GameMode`的对象不同的GameObject（我们专门为这个脚本创建的），我们需要一个类型为GameObject的变量**player**来引用它。
- en: As you can see, we dragged our player to it in the **Variables** component.
    Finally, we used a **GetVariable** to access our player reference in the graph,
    and then another **GetVariable** to extract the life from it. We accomplished
    that by connecting the player reference to the **GetVariable** node of the life
    variable. Then we repeated this for the player’s base.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在**变量**组件中将我们的玩家拖拽到它上面。最后，我们使用**获取变量**来访问图中的玩家引用，然后使用另一个**获取变量**来提取生命值。我们通过将玩家引用连接到生命变量的**获取变量**节点来实现这一点。然后我们对玩家的基础重复这一过程。
- en: 'Finally, we load the scenes by doing the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过以下步骤加载场景：
- en: '![](img/B18585_08_26.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_08_26.png)'
- en: 'Figure 8.26: Loading scenes in Visual Scripting'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.26：在视觉脚本中加载场景
- en: As you can see, we use the **SceneManager LoadScene (SceneName)** node to load
    the scenes. Notice how we load scenes with the postfix `_VisualScripting` given
    we have two versions of the scenes in our GitHub, the C# version and the Visual
    Scripting version.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用**场景管理器加载场景（场景名称）**节点来加载场景。注意我们如何使用后缀`_VisualScripting`来加载场景，因为我们GitHub上有两个版本的场景，一个是C#版本，另一个是视觉脚本版本。
- en: Now we have a fully functional simple game, with mechanics and win and lose
    conditions, and while this is enough to start developing other aspects of our
    game, I want to discuss some issues with our current manager approach and how
    to solve them with events.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个功能齐全的简单游戏，具有机制和胜负条件，虽然这足以开始开发我们游戏的其它方面，但我想要讨论一下我们当前管理方法中的一些问题以及如何通过事件来解决它们。
- en: Improving our code with events
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件改进我们的代码
- en: So far, we used Unity event functions to detect situations that can happen in
    the game such as `Awake` and `Update`. There are other similar functions that
    Unity uses to allow components to communicate with each other, as in the case
    of `OnTriggerEnter`, which is a way for the Rigidbody to inform other components
    in the GameObject that a collision has happened. In our case, we are using `if`
    statements inside the `Update` method to detect changes on other components, such
    as `GameMode` checking whether the number of enemies has reached 0\. But we can
    improve this if we are informed by the Enemy manager when something has changed,
    and just do the check at that moment, such as with the Rigidbody telling us when
    collisions occur instead of checking for collisions every frame.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了Unity事件函数来检测游戏中可能发生的情况，例如`Awake`和`Update`。Unity还使用其他类似函数来允许组件之间相互通信，例如`OnTriggerEnter`，这是Rigidbody通知GameObject中的其他组件发生了碰撞的一种方式。在我们的情况下，我们使用`Update`方法中的`if`语句来检测其他组件的变化，例如`GameMode`检查敌人数量是否达到0。但如果我们从敌人管理器那里得到通知，当某些事情发生变化时，我们可以在那一刻进行检查，例如，用Rigidbody告诉我们何时发生碰撞，而不是每帧检查碰撞。
- en: Also, sometimes, we rely on Unity events to execute logic, such as the score
    being given in the `OnDestroy` event, which informs us when the object is destroyed,
    but due to the nature of the event, it can be called in situations we don’t want
    to add to the score, such as when the scene is changed, or the game is closed.
    Objects are destroyed in those cases, but not because the player killed the enemy,
    leading to the score increasing when it shouldn’t. In this case, it would be great
    to have an event that tells us that life reached 0 to execute this logic, instead
    of relying on the general-purpose `OnDestroy` event.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有时我们依赖于Unity事件来执行逻辑，例如在`OnDestroy`事件中给出分数，该事件通知我们对象何时被销毁。但由于事件的本性，它可能在我们不希望添加分数的情况下被调用，例如当场景改变或游戏关闭时。在这种情况下，对象会被销毁，但这并不是因为玩家杀死了敌人，导致在不应该增加分数的情况下分数增加。在这种情况下，有一个事件告诉我们生命达到0以执行此逻辑，而不是依赖于通用的`OnDestroy`事件会很好。
- en: The idea of events is to improve the model of communication between our objects,
    with the assurance that at the exact moment something happens, the relevant parts
    in that situation are notified to react accordingly. Unity has lots of events,
    but we can create ones specific to our gameplay logic. Let’s start by applying
    this in the score scenario we discussed earlier; the idea is to make the `Life`
    component have an event to communicate to the other components that the object
    was destroyed because life reached 0\.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的想法是改进我们对象之间的通信模型，确保在某个事件发生的确切时刻，相关部分被通知并做出相应的反应。Unity有很多事件，但我们可以创建特定于我们游戏逻辑的事件。让我们先应用我们之前讨论的得分场景；想法是让`Life`组件有一个事件来通知其他组件对象被销毁是因为生命达到0。
- en: There are several ways to implement this, and we will use a little bit of a
    different approach than the **Awake** and **Update** methods; we will use the
    `UnityEvent` field type. This is a field type capable of holding references to
    functions to be executed when we want to, like C# delegates, but with other benefits,
    such as better Unity editor integration.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点有几种方法，我们将使用与`Awake`和`Update`方法略有不同的方法；我们将使用`UnityEvent`字段类型。这是一种字段类型，可以存储在需要执行时执行的函数引用，就像C#委托一样，但具有其他优点，例如更好的Unity编辑器集成。
- en: 'To implement this, do the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，请执行以下操作：
- en: 'In the `Life` component, create a `public` field of the `UnityEvent` type called
    `onDeath`. This field will represent an event where other classes can subscribe
    to it to be made aware when `Life` reaches 0:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Life`组件中，创建一个名为`onDeath`的`UnityEvent`类型的`public`字段。这个字段将代表一个事件，其他类可以订阅它，以便在`Life`达到0时得到通知：
- en: '![](img/B18585_08_27.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_27.png)'
- en: 'Figure 8.27: Creating a custom event field'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.27：创建自定义事件字段
- en: 'If you save the script and go to the editor, you can see the event in the Inspector.
    Unity events support being subscribed to methods in the editor so we can connect
    two objects together. We will use this in the UI scripting chapter, so let’s just
    ignore this for now:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你保存脚本并进入编辑器，你可以在检查器中看到事件。Unity事件支持在编辑器中订阅方法，这样我们就可以将两个对象连接起来。我们将在UI脚本章节中使用这个功能，所以现在就忽略它：
- en: '![](img/B18585_08_28.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_28.png)'
- en: 'Figure 8.28: UnityEvents showing up in the Inspector'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.28：UnityEvents在检查器中显示
- en: You can use the generic delegate action or a custom delegate to create events
    instead of using `UnityEvent`, and aside from certain performance aspects, the
    only noticeable difference is that `UnityEvent` will show up in the editor, as
    demonstrated in *step 2*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用通用委托操作或自定义委托来创建事件，而不是使用`UnityEvent`，除了某些性能方面外，唯一明显的区别是`UnityEvent`将在编辑器中显示，如*步骤2*所示。
- en: 'When life reaches `0`, call the `Invoke` function of the event. This way, we
    will be telling any script interested in the event that it has happened:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当生命值达到`0`时，调用事件的`Invoke`函数。这样，我们将告诉任何对事件感兴趣的脚本它已经发生：
- en: '![](img/B18585_08_29.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_29.png)'
- en: 'Figure 8.29: Executing the event'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.29：执行事件
- en: In `ScoreOnDeath`, rename the `OnDestroy` function to `GivePoints` or whatever
    name you prefer; the idea here is to stop giving points in the `OnDestroy` event.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ScoreOnDeath`中，将`OnDestroy`函数重命名为`GivePoints`或你喜欢的任何名称；这里的想法是在`OnDestroy`事件中停止给予分数。
- en: In the `Awake` function of the `ScoreOnDeath` script, get the `Life` component
    using `GetComponent` and save it in a local variable.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ScoreOnDeath`脚本的`Awake`函数中，使用`GetComponent`获取`Life`组件并将其保存在局部变量中。
- en: 'Call the `AddListener` function of the `onDeath` field of the `Life` reference
    and pass the `GivePoints` function as the first argument. This is known as **subscribing**
    our `listener` method `GivePoints` to the event `onDeath`. The idea is to tell
    `Life` to execute `GivePoints` when the `onDeath` event is invoked. This way,
    `Life` informs us about that situation. Remember that you don’t need to call `GivePoints`,
    but just pass the function as a field:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`Life`引用的`onDeath`字段的`AddListener`函数，并将`GivePoints`函数作为第一个参数传递。这被称为**订阅**我们的`listener`方法`GivePoints`到事件`onDeath`。想法是告诉`Life`在`onDeath`事件被调用时执行`GivePoints`。这样，`Life`就会通知我们这种情况。记住，你不需要调用`GivePoints`，只需将其作为字段传递即可：
- en: '![](img/B18585_08_30.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_30.png)'
- en: 'Figure 8.30: Subscribing to the OnDeath event to give points in that scenario'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.30：在那种情况下订阅OnDeath事件以给予分数
- en: Consider calling `RemoveListener` in `OnDestroy`; as usual, it is convenient
    to unsubscribe listeners when possible to prevent any memory leak (reference preventing
    the GC to deallocate memory). In this scenario, it is not entirely necessary because
    both the `Life` and `ScoreOnDeath` components will be destroyed at the same time,
    but try to get used to this as a good practice.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在`OnDestroy`中调用`RemoveListener`；像往常一样，在可能的情况下取消订阅监听器以防止任何内存泄漏（引用阻止GC释放内存）是方便的。在这种情况下，这并不是完全必要的，因为`Life`和`ScoreOnDeath`组件将同时被销毁，但尽量养成这种良好的习惯。
- en: Save, select `ScoreManager` in the editor, and hit **Play** to test this. Try
    deleting an enemy from the Hierarchy while in **Play** mode to check that the
    score doesn’t rise because the enemy was destroyed for a reason other than their
    life becoming 0; you must destroy an enemy by shooting at them to see the score
    increase.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存，在编辑器中选择`ScoreManager`，然后点击**播放**来测试这个功能。尝试在**播放**模式下从层次结构中删除一个敌人，以检查分数是否不会上升，因为敌人被销毁的原因不是他们的生命值变为0；你必须射击敌人以看到分数增加。
- en: 'Now that `Life` has an `onDeath` event, we can also replace the player’s `Life`
    check from the `WavesGameMode` to use the event by doing the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于`Life`有了`onDeath`事件，我们也可以通过以下步骤将玩家的`Life`检查从`WavesGameMode`替换为使用该事件：
- en: Create an `OnPlayerDied` function on the `WavesGameMode` script and move the
    loading of the `LoseScreen` scene from `Update` to this function. You will be
    removing the `if` that checks the life from the `Update` method, given that the
    event version will replace it.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WavesGameMode`脚本上创建一个`OnPlayerDied`函数，并将`LoseScreen`场景的加载从`Update`方法移动到这个函数。你将移除检查生命的`if`语句，因为事件版本将替换它。
- en: 'In `Awake`, add this new function to the `onDeath` event of the player’s `Life`
    component reference, called `playerLife` in our script:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Awake`中，将这个新函数添加到玩家`Life`组件引用的`onDeath`事件中，在我们的脚本中称为`playerLife`：
- en: '![](img/B18585_08_31.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_31.png)'
- en: 'Figure 8.31: Checking the lose condition with events'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.31：使用事件检查失败条件
- en: As you can see, creating custom events allows you to detect more specific situations
    other than the defaults in Unity, and keeps your code clean, without needing to
    constantly ask conditions in the `Update` function, which is not necessarily bad,
    but the event approach generates clearer code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，创建自定义事件允许您检测比Unity中的默认值更具体的情况，并保持您的代码整洁，无需在`Update`函数中不断询问条件，这并不一定是坏事，但事件方法生成更清晰的代码。
- en: 'Remember that we can lose our game also by the player’s base `Life` reaching
    0, so let’s create a cube that represents the object that enemies will attack
    to reduce the base `Life`. Taking this into account, I challenge you to add this
    second lose condition (player’s base life reaching 0) to our script. When you
    finish, you can check the solution in the following screenshot:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们也可以通过玩家的基础`Life`达到0来输掉游戏。因此，让我们创建一个代表敌人将攻击以减少基地`Life`的对象的立方体。考虑到这一点，我挑战你将第二个失败条件（玩家的基础生命达到0）添加到我们的脚本中。当你完成时，你可以在以下截图中检查解决方案：
- en: '![](img/B18585_08_32.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_32.png)'
- en: 'Figure 8.32: Complete WavesGameMode lose condition'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.32：完整的WavesGameMode失败条件
- en: As you can see, we just repeated the `life` event subscription, remember to
    create an object to represent the player’s base damage point, add a `Life` script
    to it, and drag that one as the player base `Life` reference of the Waves Game
    Mode. Something interesting here is that we subscribed the same function called
    `OnPlayerOrBaseDied` to both player `Life` and base `Life` `onDeath` events, given
    that we want the same result in both situations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只是重复了`life`事件订阅，请记住创建一个对象来表示玩家的基础伤害点，向其添加一个`Life`脚本，并将其拖动作为Waves游戏模式的玩家基础`Life`引用。这里有趣的是，我们订阅了名为`OnPlayerOrBaseDied`的相同函数，用于玩家的`Life`和基地`Life`的`onDeath`事件，因为我们希望在这两种情况下得到相同的结果。
- en: 'Now, let’s keep illustrating this concept by applying it to the managers to
    prevent the Game Mode from checking conditions every frame:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过将其应用于管理器来继续说明这个概念，以防止游戏模式每帧都检查条件：
- en: Add a `UnityEvent` field to `EnemyManager` called `onChanged`. This event will
    be executed whenever an enemy is added or removed from the list.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EnemyManager`中添加一个名为`onChanged`的`UnityEvent`字段。这个事件将在敌人被添加或从列表中移除时执行。
- en: Create two functions, `AddEnemy` and `RemoveEnemy`, both receiving a parameter
    of the `Enemy` type. The idea is that instead of `Enemy` adding and removing itself
    from the list directly, it should use these functions.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个函数，`AddEnemy`和`RemoveEnemy`，都接收一个`Enemy`类型的参数。想法是，而不是让`Enemy`直接从列表中添加和删除自己，它应该使用这些函数。
- en: 'Inside these two functions, invoke the `onChanged` event to inform others that
    the enemies list has been updated. The idea is that anyone who wants to add or
    remove enemies from the list needs to use these functions:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这两个函数内部，调用`onChanged`事件来通知其他人敌人列表已被更新。想法是，任何想要从列表中添加或删除敌人的人都需要使用这些函数：
- en: '![](img/B18585_08_33.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_33.png)'
- en: 'Figure 8.33: Calling events when enemies are added or removed'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.33：在添加或删除敌人时调用事件
- en: Here, we have the problem that nothing stops us from bypassing those two functions
    and using the list directly. You can solve that by making the list private and
    exposing it using the `IReadOnlyList` interface. Remember that this way, the list
    won’t be visible in the editor for debugging purposes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们没有阻止我们绕过这两个函数并直接使用列表的问题。你可以通过将列表设为私有并使用`IReadOnlyList`接口公开它来解决。记住，这样，列表在编辑器中不可见，以便进行调试。
- en: 'Change the `Enemy` script to use these functions:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Enemy`脚本更改为使用这些函数：
- en: '![](img/B18585_08_34.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_34.png)'
- en: 'Figure 8.34: Making the Enemy use the add and remove functions'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.34：使敌人使用添加和删除函数
- en: 'Repeat the same process for `WaveManager` and `WaveSpawner`, create an `onChanged`
    event, and create the `AddWave` and `RemoveWave` functions and call them in `WaveSpawner`
    instead of directly accessing the list. This way, we are sure the event is called
    when necessary as we did with `EnemyManager`. Try to solve this step by yourself
    and then check the solution in the following screenshot, starting with `WavesManager`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`WaveManager`和`WaveSpawner`重复相同的过程，创建一个`onChanged`事件，创建`AddWave`和`RemoveWave`函数，并在`WaveSpawner`中调用它们而不是直接访问列表。这样，我们就确保在需要时调用事件，就像我们对`EnemyManager`所做的那样。尝试自己解决这个问题，然后检查以下截图中的解决方案，从`WavesManager`开始：
- en: '![](img/B18585_08_35.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_35.png)'
- en: 'Figure 8.35: WaveManager OnChanged event implementation'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.35：WaveManager OnChanged事件实现
- en: 'Also, `WavesSpawner` needed the following changes:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，`WavesSpawner`也需要以下更改：
- en: '![](img/B18585_08_36.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_36.png)'
- en: 'Figure 8.36: Implementing the AddWave and RemoveWave functions'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.36：实现AddWave和RemoveWave函数
- en: 'In `WavesGameMode`, rename `Update` to `CheckWinCondition` and subscribe this
    function to the `onChanged` event of `EnemyManager` and the `onChanged` event
    of `WavesManager`. The idea is to check for the number of enemies and waves being
    changed only when necessary. Remember to do the subscription to the events in
    the `Start` function due to the Singletons being initialized in `Awake`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`WavesGameMode`中，将`Update`重命名为`CheckWinCondition`，并将其订阅到`EnemyManager`和`WavesManager`的`onChanged`事件。想法是只在必要时检查敌人和波次的数量变化。记住，由于单例在`Awake`中初始化，所以在`Start`函数中订阅事件。 '
- en: '![](img/B18585_08_37.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_37.png)'
- en: 'Figure 8.37: Checking the win condition when the enemies or waves amount is
    changed'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.37：当敌人或波次数量变化时检查胜利条件
- en: 'Regarding the Visual Scripting version, let’s start checking the lose condition
    with events, checking first some changes needed in the **Life Script Graph**:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，让我们从事件开始检查失败条件，首先检查**生命脚本图表**中需要的一些更改：
- en: '![](img/B18585_08_38.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_38.png)'
- en: 'Figure 8.38: Triggering a Custom Event in our Life graph'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.38：在我们的生命图表中触发自定义事件
- en: 'First, after destroying the object when life reaches 0, we use the **Trigger
    Custom Event** node, specifying the name of our event is `OnDeath`. This will
    tell anyone waiting for the execution of the `OnDeath` event that we did. Remember,
    this is our **Life Script Graph**. Be sure to call destroy after triggering the
    event—while most of the time the order doesn’t matter, given that the destroy
    action doesn’t actually happen until the end of the frame, sometimes it can cause
    issues, so better be safe here. In this case, Game Mode should listen to the player’s
    `OnDeath` event, so let’s make the following change in our **Game Mode Graph**:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当生命值达到0时销毁物体后，我们使用**触发自定义事件**节点，指定事件名称为`OnDeath`。这将告诉所有等待执行`OnDeath`事件的人我们已经执行了。记住，这是我们**生命脚本图表**。在触发事件后务必调用销毁操作——虽然大多数时候顺序并不重要，因为销毁动作实际上是在帧尾发生的，但有时可能会引起问题，所以在这里还是安全为好。在这种情况下，游戏模式应该监听玩家的`OnDeath`事件，所以让我们在我们的**游戏模式图表**中做出以下更改：
- en: '![](img/B18585_08_39.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_08_39.png)'
- en: 'Figure 8.39: Listening to the OnDeath event of Player in Visual Scripting'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.39：在视觉脚本中监听玩家的OnDeath事件
- en: We used the **CustomEvent** node connecting it to the player reference of our
    GameMode. This way we are specifying that if that player executes that event,
    we will execute the **Load Scene** node. Remember that the player reference is
    crucial to specify from whom we want to execute the `OnDeath` event, and remember
    that the **Life Visual Graph** will also be present in the enemies and we are
    not interested in them here. Also, remember to remove the `If` node and the condition
    nodes we used previously to detect this – the only `If` our Game Mode will have
    is the one for the win condition.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了**自定义事件**节点，将其连接到我们的游戏模式的玩家引用。这样我们指定，如果那个玩家执行该事件，我们将执行**加载场景**节点。记住，玩家引用是至关重要的，因为它指定了我们想从谁那里执行`OnDeath`事件，并且记住**生命视觉图表**也会出现在敌人中，而我们对此不感兴趣。此外，记得移除我们之前用来检测此情况的`If`节点和条件节点——我们的游戏模式将只有一个`If`，那就是胜利条件。
- en: Essentially, we made any object with the `Life` script have an `OnDeath` event,
    and we made the GameMode listen to the `OnDeath` event of the player specifically.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们让任何带有`Life`脚本的物体都有一个`OnDeath`事件，并且让游戏模式特别监听玩家的`OnDeath`事件。
- en: We could also do events for enemies and waves, but that would complicate our
    graphs somewhat, given that we don’t have `WaveManager` or `EnemyManager` in the
    Visual Scripting versions. We could certainly create those to accomplish this,
    but sometimes the point of using Visual Scripting is to create simple logic, and
    these kinds of changes tend to make a graph grow quite a bit.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为敌人和波次做事件，但这会在一定程度上使我们的图表变得复杂，因为我们视觉脚本版本中没有`WaveManager`或`EnemyManager`。我们当然可以创建这些来完成任务，但有时使用视觉脚本的目的就是创建简单的逻辑，这类改变往往会使得图表变得相当庞大。
- en: Another possible solution is to make the enemy and wave directly inform the
    Game Mode. We could use **Trigger Custom Event** in the enemies and waves, connecting
    that node to the Game Mode, to finally let the Game Mode have a **Custom Event**
    node from which to listen. The issue is that that would violate the correct dependencies
    between our objects; lower-level objects such as enemies and waves shouldn’t communicate
    with higher-level objects such as Game Mode. Essentially, Game Mode was supposed
    to be an overseer. If we apply the solution described in this paragraph, we won’t
    be able to have an enemy in another scene or game without having a Game Mode.
    So, for simplicity and code decoupling purposes, let’s keep the other conditions
    as they are—the more complex logic such as this will be probably handled in C#
    in full production projects.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的解决方案是让敌人波直接通知游戏模式。我们可以在敌人和波中使用**触发自定义事件**，将此节点连接到游戏模式，最终让游戏模式拥有一个**自定义事件**节点来监听。问题是这会违反我们对象之间的正确依赖关系；低级对象，如敌人和波，不应该与高级对象，如游戏模式，进行通信。本质上，游戏模式原本应该是一个监管者。如果我们应用本段中描述的解决方案，我们将无法在没有游戏模式的情况下在另一个场景或游戏中拥有敌人。因此，为了简单和代码解耦，让我们保持其他条件不变——更复杂的逻辑，如这个，在完整的生产项目中可能会用C#来处理。
- en: Yes, using events means that we have to write more code than before, and in
    terms of functionality, we didn’t obtain anything new, but in bigger projects,
    managing conditions through `Update` checks will lead to different kinds of problems
    as previously discussed, such as race conditions and performance issues. Having
    a scalable code base sometimes requires more code, and this is one of those cases.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，使用事件意味着我们比以前需要编写更多的代码，从功能的角度来看，我们没有获得任何新的东西，但在更大的项目中，通过`Update`检查来管理条件，正如之前讨论的那样，会导致各种问题，如竞争条件和性能问题。有时，拥有可扩展的代码库需要更多的代码，这就是其中之一。
- en: Before we finish, something to consider is that Unity events are not the only
    way to create this kind of event communication in Unity; you will find a similar
    approach called **Action**, the native C# version of events, which I recommend
    you look into if you want to see all of the options out there.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束之前，需要考虑的是，Unity事件不是在Unity中创建此类事件通信的唯一方式；你将找到一个类似的方法，称为**Action**，这是事件的本地C#版本，如果你想要查看所有选项，我建议你了解一下。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we finished an important part of the game: the ending, both
    by victory and by defeat. We discussed a simple but powerful way to separate the
    different layers of responsibilities by using managers created through Singletons,
    to guarantee that there isn’t more than one instance of every kind of manager
    and simplifying the connections between them through static access. Also, we visited
    the concept of events to streamline communication between objects to prevent problems
    and create more meaningful communication between objects.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完成了游戏的一个重要部分：无论是胜利还是失败，我们都讨论了通过使用通过单例创建的管理器来分离不同责任层的一种简单但强大的方法，以确保每种类型的经理只有一个实例，并通过静态访问简化它们之间的连接。此外，我们还探讨了事件的概念，以简化对象之间的通信，防止问题并创建更有意义的对象间通信。
- en: With this knowledge, you are now able not only to detect the victory and lose
    conditions of the game but can also do it in a better-structured way. These patterns
    can be useful to improve our game code in general, and I recommend you try to
    apply them in other relevant scenarios.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，你现在不仅能够检测游戏的胜利和失败条件，而且还能以更好的结构化方式来做。这些模式可以用来改进我们的游戏代码，我建议你在其他相关场景中尝试应用它们。
- en: In the next chapter, we are going to start *Part 3* of the book, where we are
    going to see different Unity systems to improve the graphics and audio aspects
    of our game, starting by seeing how we can create materials to modify aspects
    of our objects, and create shaders with Shader Graph.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始本书的**第三部分**，我们将看到不同的Unity系统来改进游戏的图形和音频方面，首先我们将看到如何创建材料来修改对象的一些属性，并使用Shader
    Graph创建着色器。
- en: Join us on Discord!
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord频道！
- en: Read this book alongside other users, Unity game development experts, and the
    author himself.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity游戏开发专家以及作者本人一起阅读这本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 提出问题，为其他读者提供解决方案，通过“问我任何问题”的环节与作者聊天，以及更多。
- en: Scan the QR code or visit the link to join the community.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描二维码或访问链接加入社区。
- en: '![](img/Nicolas_QR_Code.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![尼古拉斯二维码](img/Nicolas_QR_Code.png)'
- en: '[https://packt.link/handsonunity22](Chapter_8.xhtml)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/handsonunity22](Chapter_8.xhtml)'
