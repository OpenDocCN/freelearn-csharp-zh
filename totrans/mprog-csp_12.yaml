- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go Beyond Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With object-oriented languages such as C#, we can derive our types from other
    types and we can also implement contracts (interfaces) and make them fulfill that
    contract. Implementing interfaces and making an implementation fulfill these is
    really one of the great things about a type-safe language. With the compiler,
    we get everything checked to make sure we implement the contract, while at runtime,
    we can leverage the interface type to be a representation rather than having to
    know the actual implementor.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, however, the verbosity of having to implement an interface can be
    too much. It can also be limited to what you’re trying to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Method signature conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have an idea of how conventions can let
    you go beyond having to inherit from a base type or an interface and how that
    sometimes caters to a cleaner code base.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter12](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter12))
    and it builds on top of the **Fundamentals** code that is found at [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals).
  prefs: []
  type: TYPE_NORMAL
- en: Method signature conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coming up with good examples to do a home run on a topic for a book can be very
    hard. For this chapter, I’ve decided to go with something that is part of my day-to-day
    job.
  prefs: []
  type: TYPE_NORMAL
- en: I work with a platform that is centered around event-driven architecture, or
    more specifically, with event sourcing. This topic might be unfamiliar to you,
    so let’s dive into what this specifically is, to give you the context.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional **CRUD** (short for **Create, Read, Update, Delete**) systems,
    the primary focus is on the concrete data that is commonly stored in a relational
    or document database. These systems revolve around the four fundamental operations
    – creating new records, retrieving existing records, updating records, and deleting
    records.
  prefs: []
  type: TYPE_NORMAL
- en: The data in such systems represents the outcome of a user’s actions, and the
    system’s flow typically follows a one-to-one mapping from the user’s input form
    to the database. However, this approach to software development has a significant
    drawback – it only captures the effect and not the cause.
  prefs: []
  type: TYPE_NORMAL
- en: 'With event sourcing, the effect is less important, and it’s all about capturing
    what caused the effect. The cause captures how we got to the conclusion, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Capturing the cause
  prefs: []
  type: TYPE_NORMAL
- en: The cause is what is known as an event – something that happened in the system.
    We capture these by giving them a clear name, and we store them in the sequence
    in which they occur. The events are never deleted. All events are stored in what
    is referred to as an **event store**. There are technologies out there that specialize
    in this, such as the platform I’m working on, called Cratis ([https://cratis.io](https://cratis.io)),
    but you could also use any database and do this yourself.
  prefs: []
  type: TYPE_NORMAL
- en: By prioritizing the capturing of events, we gain the ability to control how
    the effects are presented. This is achieved by extracting relevant information
    from various event types as they occur and then converting it into specialized
    objects for easy access. These objects are typically stored in conventional data
    stores such as relational or document databases, which allow for the efficient
    querying of the end result.
  prefs: []
  type: TYPE_NORMAL
- en: One major advantage of this approach is that the event store becomes the source
    of truth in the system rather than relying solely on traditional data stores.
    This means that modifying how data is represented becomes significantly easier,
    as you can simply replay the relevant events when implementing changes. You can
    also decide to have multiple representations, catering to special needs within
    a system. This could then have a huge performance benefit, as well as clarity
    in code, and avoiding tension often seen in developing systems where one shares
    the same data and objects.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows an imaginary bank system with events being produced
    and how they are projected down to materialized objects, referred to as read models.
    It also shows the relationship with other systems or other microservices in a
    microservice-centric architecture by projecting to events that can be communicated
    outside of the bounds of the system-producing events.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Imaginary bank system with events produced
  prefs: []
  type: TYPE_NORMAL
- en: The observer is a key element of this architecture. They are the ones responsible
    for observing the events as they occur and creating an effect. For the most part,
    the effect comes in the form of a projection to a read model that is stored, but
    it could also perform other tasks such as sending emails or, in fact, append new
    events as the consequence of an analysis the observer performs.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s these observers that we want to bring forward as an example in this chapter.
    Let’s narrow it down to a pipeline that looks like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Logical pipeline
  prefs: []
  type: TYPE_NORMAL
- en: A command represents something the user desires, an action to be performed.
    The action typically would then decide what event, or possibly multiple events,
    it should generate. This is appended to the main event log within the event store.
    The event log is the event sequence that holds all the events in the order they
    occurred, with an incremental sequence number.
  prefs: []
  type: TYPE_NORMAL
- en: Once the event is in the event log, we want to notify all the interested observers
    that the event has been appended and they should react.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows more concretely what we want to accomplish and will
    be the basis of the example in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Concrete pipeline
  prefs: []
  type: TYPE_NORMAL
- en: In order to be able to do this, you’re going to need some infrastructure that
    will give you the conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s create a bare foundation of what’s needed for having observers that can
    respond to events being appended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a folder called **Chapter12** at the root of your repository.
    Change into this folder in your command-line interface and create a new console
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You’re going to make use of the Microsoft hosting model to get the .NET default
    service provider without spinning up a web application. To achieve this, you’ll
    need the package called **Microsoft.Extensions.Hosting**. In the terminal, you’d
    add the reference by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing you’ll need to do is to reference the **Fundamentals** project.
    In the terminal, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As I discussed in [*Chapter 4*](B19418_04.xhtml#_idTextAnchor059), *Reasoning
    about Types Using Reflection*, one of the things I do in all my code is to formalize
    types rather than use primitives. This makes the APIs much clearer and also helps
    avoid mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: You’re going to be using **ConceptAs<>** to formalize the types.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the **Chapter12** folder, create a folder dedicated to the **EventSourcing**
    infrastructure, and call this folder **EventSourcing**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the **EventSourcing** folder, create a file called **EventSourceId.cs**
    and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The **EventSourceId** concept represents the unique identifier of the source
    of events. In domain modeling, this is typically the identifier of an object,
    a noun, in your domain. An example of this could be the unique identifier of a
    bank account or the unique identifier of a person in the system. The **EventSourceId**
    code sets up **ConceptAs<>** for this and makes the inner value a string, enabling
    basically any representation of a unique identifier. It adds a convenient method
    for creating a new **EventSourceId** by leveraging **Guid**, which can then generate
    a unique identifier on the fly. You’ll be using **EventSourceId** later and it
    should become clearer why it’s needed.
  prefs: []
  type: TYPE_NORMAL
- en: When appending an event to a sequence of events, as we discussed earlier, every
    event gets a sequence number. This is an incremental number that increases by
    1 for every event added. Let’s formalize a type that represents this number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the **EventSourcing** folder, create a file called **EventSequenceNumber.cs**
    and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The code introduces a concrete type for **EventSequenceNumber** that is **ConceptAs<>**
    with its inner value of the **ulong** type. With **ulong**, you get a full 64-bit
    value and this should most likely be more than sufficient as an incremental sequence
    number. For convenience, there is also an implicit operator that can convert **ulong**
    to the encapsulated **EventSequenceNumber** type.
  prefs: []
  type: TYPE_NORMAL
- en: For the observers that you’ll be adding later, you’ll be marking them with an
    attribute to indicate they are an observer. An alternative to this would be to
    use an empty interface. The point of this is just to be able to mark a type, making
    it possible to discover.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the **EventSourcing** folder, create a file called **ObserverAttribute.cs**
    and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code introduces an attribute that can be added to classes.
  prefs: []
  type: TYPE_NORMAL
- en: For the observer methods, you typically find the information related to the
    event in addition to the actual event itself. The type of information you want
    to know is the **EventSourceId**, **EventSequenceNumber**, and when the event
    occurred. We call this **EventContext**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the **EventSourcing** folder, create a file called **EventContext.cs**
    and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The code holds **EventSourceId**, **SequenceNumber**, and **Occurred** in the
    form of **DateTimeOffset**. In a full event-sourced system, we would typically
    hold more details, but this will suffice for this example.
  prefs: []
  type: TYPE_NORMAL
- en: For the events to be discoverable and classified as events, you’re going to
    need a building block in the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the **EventSourcing** folder, create a file called **IEvent.cs** and
    make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now comes the juicy part: the code that will discover methods on a type that
    matches certain criteria.'
  prefs: []
  type: TYPE_NORMAL
- en: The convention we’re looking for is one that allows for two base method signatures
    and two variants of these, supporting both synchronous and asynchronous models.
  prefs: []
  type: TYPE_NORMAL
- en: 'The synchronous signatures are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And then the asynchronous signatures are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the convention does not care about the name of the method but
    only the parameters and return types. This gives flexibility to the developer
    in creating more precise named methods and increases the readability and maintainability
    of the code, something regular inheritance wouldn’t allow for.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a system that enables calling the methods by convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the **EventSourcing** folder, create a file called **ObserverHandler.cs**
    and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code sets up the basis for the **ObserverHandler** class. The constructor
    takes two parameters, **serviceProvider** and **targetType**. The **serviceProvider**
    parameter will be used to get instances of **targetType** representing the observer
    when an event needs to be handled. Within the constructor, the code uses reflection
    to look for instance methods, both public and non-public methods.
  prefs: []
  type: TYPE_NORMAL
- en: It then filters down the methods by those matching the signature with a method
    called **IsObservingMethod()**, which you’ll be adding next. Then it groups it
    by the first parameter on the method, which is the event type, and creates a dictionary
    enabling fast lookup.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Notice the **EventTypes** property that is added; this exposes what event types
    the handler supports, and this will come in handy later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the LINQ query, it uses the **IsObservingMethod()** method, which is a method
    that should be inside the **ObserverHandler** class. Add the following private
    method at the bottom of the **ObserverHandler** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To identify allowed signatures, the code examines **MethodInfo** and begins
    by recognizing the permitted return types, which are **Task** or **void**. If
    the return type is anything other than a valid observing method, it will be considered
    invalid. The code then proceeds to examine the parameters of the method. If the
    method has one parameter and its type implements the **IEvent** interface, it
    qualifies as an observing method. Alternatively, if the method has two parameters
    and the first parameter type implements **IEvent**, and the second parameter type
    is **EventContext**, then it is also classified as an observing method.
  prefs: []
  type: TYPE_NORMAL
- en: With the discovery part in place, all you need is a method that understands
    the convention and can invoke the method on the observer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **ObserverHandler** class, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The **OnNext()** method is responsible for doing the call to the observer; it
    does so by taking an event of any type implementing the **IEvent** interface and
    **EventContext** for the event. From this, it finds the method in **_methodsByEventType**
    populated in the constructor based on the type of event supported by the observer.
    If it is supported, it goes on to get an instance of the observer type by using
    the service provider. For each method, it invokes based on the correct signature
    for the method and if the method is asynchronous, it will await **Task** returned.
  prefs: []
  type: TYPE_NORMAL
- en: With the concrete handler that handles the invocation, you’re going to need
    a service that knows about all the observers and can call the correct ones when
    an event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the **EventSourcing** folder, create a file called **IObservers.cs**
    and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The code represents the contract for **IObservers**. The **OnNext()** method
    will be the method called by the system that knows when events have occurred.
  prefs: []
  type: TYPE_NORMAL
- en: You’re going to need an implementation of this interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the **EventSourcing** folder, create a file called **Observers.cs**
    and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The code leverages **ITypes** from fundamentals for discovery. The code scans
    through all the types and filters out those that do not have **ObserverAttribute**,
    leaving only the types that do have it. For every type that has the **ObserverAttribute**,
    it then creates an instance of **ObserverHandler** by passing in **serviceProvider**
    and the target type, which is the observer itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'For invoking the handler, you need an implementation of the **OnNext()** method.
    In the **Observers** class, add the following method at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The code filters down to only the handlers that are capable by looking at the
    **EventTypes** property of the handler, and whether it contains the type of the
    **@event** argument. It then calls the **OnNext()** method of the handler and
    collects all the **Task** instances for all the calls it made, so that it can
    wait for them all to finish.
  prefs: []
  type: TYPE_NORMAL
- en: With the observer infrastructure in place, you’ll need something that triggers
    this. We’re not going to implement a fully working event sourcing system, as that
    would be too involved. Instead, we’re going to make a few shortcuts and not save
    the events anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: In an event-sourced system, you need a place to append the events to a sequence;
    the main place you append to is called an event log. Let’s introduce this concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the **EventSourcing** folder, create a file called **IEventLog.cs**
    and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The code represents the contract for the event log with only one method in this
    version, which enables you to append an event for a specific **EventSourceId**.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need an implementation of the **IEventLog** interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the **EventSourcing** folder, create a file called **EventLog.cs** and
    make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The code represents a very simplistic implementation that takes a direct dependency
    on **IObservers** for it to call when an event has been appended. It manages internally
    the **_sequenceNumber**. As you can see, there is no persistence and the whole
    implementation is naive at best. But it serves the purpose of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have built all this nice infrastructure for invoking methods by
    the convention on observers, you’re probably eager to take it out for a spin.
  prefs: []
  type: TYPE_NORMAL
- en: Using the infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Going with the bank theme of the chapter, let’s create something that represents
    that domain. In a bank, you can open an account, deposit and withdraw money from
    it, and then possibly, and ultimately, close an account. All of these are very
    important events that happen in the lifespan of an account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the root folder of the chapter code, create a file called **Events.cs**
    and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The code holds all the events we want for now as **record** types and they all
    implement the **IEvent** interface.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In a production environment, I would recommend keeping one file per type, as
    that makes it easier to navigate and discover events in your system.
  prefs: []
  type: TYPE_NORMAL
- en: With the events in place, you can now go ahead and create observers that will
    react to the events occurring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the root folder of the chapter code, create a file called **AccountLifecycle.cs**
    and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The code adds a class called **AccountLifecycle** and adorns it with the **[Observer]**
    attribute. Its purpose is to only deal with the life cycle events of **BankAccountOpened**
    and **BankAccountClosed**. Notice that it uses the convention fully with custom
    names of the methods and also the different signatures.
  prefs: []
  type: TYPE_NORMAL
- en: For the events that affect the balance of an account, you could then separate
    that particular logic into its own observer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the root folder of the chapter code, create a file called **AccountBalance.cs**
    and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The code adds a class called **AccountBalance** and adorns it with the **[Observer]**
    attribute. Its purpose is to only deal with the balance events of **DepositPerformed**
    and **WithdrawalPerformed**.
  prefs: []
  type: TYPE_NORMAL
- en: Both observers are just logging what has happened to the console. In a real
    implementation of these, you’d probably want to store the data somewhere. The
    benefit here is that you could store the data in two different locations. For
    life cycle events, you’re only interested in the ownership and any details related
    to the account, while with the balance events, you’re only interested in what
    affects the balance and not interested in anything else. Breaking these things
    up makes it easier to choose the right technology for the job and also model each
    of these independently and create a less coupled system.
  prefs: []
  type: TYPE_NORMAL
- en: Now you want to do the last hookup and throw some events at it and verify that
    it does the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Program.cs** file and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The code sets up the necessary plumbing code to get the default .NET inversion
    of the control container going; it leverages **AddBindingsByConvention()** that
    you created in [*Chapter 10*](B19418_10.xhtml#_idTextAnchor162), *Convention over
    Configuration*, to hook up services by convention, and **AddSelfBinding()** that
    you created in [*Chapter 11*](B19418_11.xhtml#_idTextAnchor177), *Applying the*
    *Open-Closed Principle*.
  prefs: []
  type: TYPE_NORMAL
- en: With the basic infrastructure in place, you can now ask for an instance of **IEventLog**
    and start appending events to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code at the bottom of **Program.cs**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Running your program should give you a similar output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You now have the beginning of an event-sourcing component. But more importantly,
    it should give you an idea of what could be done dynamically without having to
    be tied to the strictness of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an illustration of the implication of doing this with inheritance instead,
    we would need something like an interface that defines the method for the event;
    it could look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With this interface, we could take the **AccountLifecycle** observer and do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: While using this approach can provide compile-time safety, there are several
    downsides to consider. Firstly, naming every method **Handle** can lead to ambiguity
    and confusion, both in terms of tooling and readability. It may be difficult to
    determine which method to work with without carefully examining the parameters.
    Additionally, this approach limits you to only one method handling one event,
    while the convention-based approach allows for multiple individual methods with
    specific purposes to handle different aspects of the event.
  prefs: []
  type: TYPE_NORMAL
- en: If you have an observer handling numerous events, you’d end up having to implement
    **IObserveEvent<>** for every type it handles. This can easily make your code
    less readable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: There are pros and cons to both approaches, but hopefully, the takeaway is the
    potential this gives and, hopefully, it is useful and applicable to the code bases
    you work on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conventions, like those explained in this chapter with the discovery of well-known
    signatures, can be very powerful and help clean up your code. Forcing the developer
    to implement an interface for every class supported can be tedious and make the
    code look a little strange.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of using a convention for method signatures is obviously that you
    are now at the mercy of runtime checks; there is no compiler that will help you.
    If you happen to make a little error, it won’t be noticed until you’re at runtime,
    which can be very annoying while in the zone and developing. In [*Chapter 17*](B19418_17.xhtml#_idTextAnchor299),
    *Static Code Analysis*, we will look at how we can detect errors at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to look at how automation can go further with
    conventions to put developers in the pit of success and avoid a recipe-driven
    development.
  prefs: []
  type: TYPE_NORMAL
