- en: Concurrent Programming in .NET Core
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core中的并发编程
- en: In the previous chapter ([Chapter 7](232b63cb-5006-431d-8378-b7e2ba4c1119.xhtml),
    *Implementing Design Patterns for Web Applications - Part 2*), we created a sample
    web application with the help of various patterns for the web. We adapted authorization
    and authentication mechanisms to secure a web application and discussed **Test-driven
    development** (**TDD**) to make sure that our code has been tested and is working.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章（[第7章](232b63cb-5006-431d-8378-b7e2ba4c1119.xhtml)，*实现Web应用程序的设计模式 - 第2部分*）中，我们借助各种模式创建了一个示例Web应用程序。我们调整了授权和认证机制以保护Web应用程序，并讨论了**测试驱动开发**（**TDD**）以确保我们的代码经过测试且正在运行。
- en: This chapter will discuss the best practices to adopt while performing concurrent
    programming in .NET Core. In the upcoming sections of this chapter, we will learn
    about the design patterns relevant for well-organized concurrency in C# and .NET
    Core applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论在.NET Core中进行并发编程的最佳实践。在本章的后续部分，我们将了解与C#和.NET Core应用程序中良好组织并发相关的模式。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Async/Await – Why is blocking bad?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Async/Await – 为什么阻塞是坏事？
- en: Multithreading and asynchronous programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程和异步编程
- en: Concurrent collections
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发集合
- en: Patterns and practices – TDD and Parallel LINQ
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式和实践 – TDD和Parallel LINQ
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains various code examples to explain the concepts. The code
    is kept simple and is only for demonstration purposes. Most of the examples involve
    a .NET Core console application written in C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例来解释概念。代码保持简单，仅用于演示目的。大多数示例涉及使用C#编写的.NET Core控制台应用程序。
- en: 'The complete source code is available at the following link: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter8](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter8).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可在以下链接中找到：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter8](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter8).
- en: 'To run and execute the code, you will require the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行和执行代码，您需要以下内容：
- en: Visual Studio 2019 (you can also use Visual Studio 2017)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019（您也可以使用Visual Studio 2017）
- en: Setting up .NET Core
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置.NET Core
- en: SQL Server (the Express Edition is used in this chapter)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server（本章使用的是Express版）
- en: Installing Visual Studio
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Visual Studio
- en: 'To run the code examples, you will need to install Visual Studio (preferred
    IDE). To do so, you can follow these instructions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码示例，您需要安装Visual Studio（首选IDE）。为此，您可以按照以下说明操作：
- en: 'Download Visual Studio from the download link mentioned with the installation
    instructions: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从安装说明中提到的下载链接下载Visual Studio：[https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio)。
- en: Follow the installation instructions mentioned.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照提到的安装说明进行操作。
- en: Multiple options are available for the Visual Studio installation. Here, we
    are using Visual Studio for Windows.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio安装有多种选择。在这里，我们使用的是Windows版本的Visual Studio。
- en: Setting up .NET Core
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置.NET Core
- en: 'If you do not have .NET Core installed, you will need to follow these instructions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装.NET Core，您需要遵循以下说明：
- en: Download .NET Core for Windows at [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows)下载.NET
    Core for Windows。
- en: For multiple versions and a related library, visit [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于多个版本和相关库，请访问[https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2)。
- en: Installing SQL Server
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装SQL Server
- en: 'If you do not have SQL Server installed, you can follow these instructions:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装SQL Server，可以按照以下说明操作：
- en: 'Download SQL Server from the following link: [https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695).'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载SQL Server：[https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695)。
- en: 'You can find installation instructions here: [https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017).'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在此处找到安装说明：[https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017)。
- en: 'For troubleshooting and for more information, refer to the following link:
    [https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于故障排除和更多信息，请参阅以下链接：[https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm)。
- en: Concurrency in the real world
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现实世界中的并发
- en: '**Concurrency** is a part of our life: it exists in the real world. When we
    are discussing concurrency, we are referring to multitasking.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发**是我们生活的一部分：它在现实世界中存在。当我们讨论并发时，我们指的是多任务处理。'
- en: In the real world, many of us perform multitasking frequently. For example,
    we can write a program while speaking on a mobile phone, we can watch a movie
    while having dinner, and we can sing while reading notations. There are a lot
    of examples of how we as humans can multitask. Without going into too much scientific
    detail, we can look at our brain trying to grasp new things while also commanding
    the other organs of the body to work, such as the heart or our sense of smell,
    as a form of multitasking.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，我们中的许多人经常进行多任务处理。例如，我们可以在打电话的同时编写程序，我们可以在吃饭的同时看电影，我们可以在阅读乐谱的同时唱歌。有很多例子说明我们作为人类可以进行多任务处理。不必深入科学细节，我们可以将我们的大脑试图理解新事物的同时指挥身体的其他器官工作，如心脏或我们的嗅觉，视为一种多任务处理的形式。
- en: The same approach applies to our systems (computers). If we think about today's
    computers, every computer that is available has a CPU of multiple cores (more
    than one core). This is to allow multiple instructions simultaneously, and let
    us perform multiple tasks at once.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方法适用于我们的系统（计算机）。如果我们考虑今天的计算机，每台可用的计算机都有一个多核心的CPU（超过一个核心）。这是为了允许同时执行多个指令，并让我们能够同时执行多个任务。
- en: 'True parallelism is not possible on a single CPU machine because tasks are
    not switchable, as the CPU has a single core. It is only possible on a machine
    with multiple CPUs (multiple cores). In simple terms, concurrent programming involves
    two things:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在单CPU机器上实现真正的并行是不可能的，因为任务是不可切换的，因为CPU只有一个核心。只有在具有多个CPU（多个核心）的机器上才可能实现。简单来说，并发编程涉及两个方面：
- en: '**Task management**: Managing/distributing work units to available threads.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务管理**：管理/分配工作单元到可用的线程。'
- en: '**Communication**: This sets up the initial parameter of the task and gets
    the results.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通信**：这设置了任务的初始参数并获取结果。'
- en: Whenever things/tasks are happening at the same time, we call this *concurrency*.
    In our programming language, whenever any parts of our program run at the same
    time, this is called concurrent programming. You can also use **parallel programming**
    as a synonym for concurrent programming.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当事物/任务同时发生时，我们称之为*并发*。在我们的编程语言中，当我们的程序中的任何部分同时运行时，这被称为并发编程。您也可以将**并行编程**作为并发编程的同义词。
- en: 'As an example, imagine a big conference that you need a ticket for, to gain
    entry into a specific conference hall. At the gate of a conference hall, you have
    to buy a ticket, making a payment with cash or by card. While you''re making a
    payment, the counter assistant could enter your details into the system, print
    an invoice, and provide you with the ticket. Now consider that there are more
    people who want to buy a ticket. Each person has to perform the required activities
    to collect the ticket from the ticket counter. In this case, only one person can
    be served at a time from one counter, and the rest of the people wait for their
    turn. Let''s assume that one person takes two minutes to collect their ticket
    from the counter; the next person, therefore, needs to wait for two minutes for
    their turn. Consider the wait time of the last person in line if it is a queue
    of 50 people. Things can be changed here. If there were two more ticket counters
    and every counter is performing the tasks in two minutes, this means that every
    two minutes, three people will be able to collect three tickets—or three counters
    are selling two tickets every two minutes. In other words, every ticket counter
    is performing the same task (that is, ticket selling) at the same point in time.
    This means all counters are served in parallel; therefore, they are concurrent.
    This is depicted in the following diagram:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下你需要购票才能进入一个大型会议的特定会议厅。在会议厅门口，你必须购票，用现金或卡支付。在你支付的时候，柜台助手可以将你的详细信息输入系统，打印发票，并为你提供门票。现在考虑有更多的人想要购票。每个人都必须完成必要的活动才能从柜台领取门票。在这种情况下，每次只能从柜台服务一个人，其余的人则等待他们的轮次。假设一个人从柜台领取门票需要两分钟；因此，下一个人需要等待两分钟才能轮到他们。考虑队伍中最后一个人的等待时间，如果队伍有50人。这里可以有所改变。如果有两个额外的售票柜台，并且每个柜台每两分钟完成一次任务，这意味着每两分钟，将有三个人能够领取三张门票——或者说三个柜台每两分钟卖出两张门票。换句话说，每个售票柜台都在同一时间点执行相同的任务（即售票）。这意味着所有柜台都在并行服务；因此，它们是并发的。这在上面的图中有所展示：
- en: '![](img/3375a9cf-5b1e-4100-bbe2-078e2b0da4a3.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3375a9cf-5b1e-4100-bbe2-078e2b0da4a3.png)'
- en: In the preceding diagram, it is clearly shown that every person who is in the
    queue is either in the wait position or is active at the counter, and there are
    three queues in which tasks are happening in a sequence. All three counters (`CounterA`,
    `CounterB`, and `CounterC`) are performing tasks at the same point in time—they
    are doing the activities in parallel.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，可以清楚地看到，队伍中的每个人要么处于等待位置，要么在柜台处活跃，有三个队列中正在按顺序发生任务。所有三个柜台（`CounterA`、`CounterB`和`CounterC`）都在同一时间点执行任务——它们在并行地进行活动。
- en: '**Concurrency** is when two or more tasks start, run, and complete in overlapping
    time periods.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发性**是指两个或更多任务在重叠的时间段内开始、运行和完成。'
- en: '**Parallelism** is when two or more tasks run at the same time.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**并行性**是指两个或更多任务同时运行。'
- en: These are concurrent activities, but think of a scenario in which a huge amount
    of people are in the queue (for example, 10,000 people); there is no use in performing
    parallelism here, as this would not resolve the issue of a likely bottleneck in
    this operation. On the other hand, you can increase the number of counters to
    50\. Will they resolve this problem? These kinds of problems would occur while
    we work with any software. This is an issue that is related to blocking. In the
    upcoming sections, we will discuss concurrent programming in more detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是并发活动，但想象一下这样一个场景：有成千上万的人排着长队（例如，10,000人）；在这里执行并行操作是没有用的，因为这不会解决这个操作中可能出现的瓶颈问题。另一方面，你可以将计数器的数量增加到50个。这将解决这个问题吗？在我们使用任何软件时，这类问题都可能会发生。这是一个与阻塞相关的问题。在接下来的章节中，我们将更详细地讨论并发编程。
- en: Multithreading and asynchronous programming
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程和异步编程
- en: To put it simply, we can say that multithreading means that a program is running
    parallel on multiple threads. In asynchronous programming, a unit of work runs
    separately from the main application thread, and it tells the calling thread that
    the task has completed, failed, or is in progress. The interesting issues to consider
    around asynchronous programming are when we should use it and what its benefits
    are.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，我们可以这样说，多线程意味着程序在多个线程上并行运行。在异步编程中，一个工作单元独立于主应用程序线程运行，并通知调用线程任务已完成、失败或正在进行。关于异步编程需要考虑的有趣问题是何时应该使用它以及它的好处是什么。
- en: The potential for more than one thread to access the same shared data and update
    it with unpredictable results can be referred to as a **race condition**. We have
    already discussed race condition in [Chapter 4](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml),
    *Implementing Design Patterns - Basics Part 2*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 多个线程访问同一共享数据并更新它以产生不可预测结果的可能性可以被称为**竞态条件**。我们已经在[第4章](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml)，*实现设计模式
    - 基础部分2*中讨论了竞态条件。
- en: 'Consider the scenario we discussed in the previous section, in which people
    from a queue are collecting their tickets. Let''s try to capture this scenario
    in a multithreading program:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们在上一节中讨论的场景，其中排队的人正在领取他们的票。让我们尝试在多线程程序中捕捉这个场景：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we have a `TicketCounter` class that represents our whole set up of ticket
    collecting counters (we discussed these in the previous section). The three methods:
    `CounterA()`, `CounterB()`, and `CounterC()` represent an individual ticket collection
    counter. These methods are simply writing a message to the console, as shown in
    the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个`TicketCounter`类，它代表我们整个票务收集计数器的设置（我们在上一节中讨论了这些）。三个方法：`CounterA()`，`CounterB()`，和`CounterC()`代表一个单独的票务收集计数器。这些方法只是将消息写入控制台，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code is our `Program` class that is initiating the activities
    from within the `Main` method. Here, we declared and started three threads for
    all the counters. Note that we have started these threads in a sequence/order.
    As we are expect that these threads will execute in the same sequence, let''s
    run the program and see the output, as shown in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是我们的`Program`类，它从`Main`方法内部启动活动。在这里，我们为所有计数器声明并启动了三个线程。请注意，我们是按照顺序/顺序启动这些线程的。因为我们预计这些线程将以相同的顺序执行，所以让我们运行程序并查看输出，如下面的截图所示：
- en: '![](img/fa77cf94-ea4a-42d7-bc79-a195f4d235f4.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/fa77cf94-ea4a-42d7-bc79-a195f4d235f4.png)'
- en: 'The preceding program is not executed as per the given sequence in the code.
    As per our code, the execution sequence should be as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序没有按照代码中给出的顺序执行。根据我们的代码，执行顺序应该是这样的：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is due to threads, and these threads are working simultaneously without
    the guarantee that these should execute in the order/sequence that they have been
    declared/started in.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为线程，这些线程在没有任何保证它们应该按照它们被声明/启动的顺序/序列执行的情况下同时工作。
- en: 'Once again, run the program and see whether we get the same output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行程序并查看我们是否得到相同的输出：
- en: '![](img/90eeaf02-4eb6-48ac-9280-ebae4931624c.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/90eeaf02-4eb6-48ac-9280-ebae4931624c.png)'
- en: 'The preceding snapshot is showing a different output from the previous results,
    so now we have the output in sequence/order:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的快照显示了与之前结果不同的输出，因此现在我们按顺序/顺序有了输出：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, the threads are working, but not in the sequence we defined them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，线程正在工作，但不是我们定义的顺序。
- en: 'You can set the priorities of threads like this: `counterC.Priority = ThreadPriority.Highest;`,
    `counterB.Priority = ThreadPriority.Normal;`, and `counterA.Priority = ThreadPriority.Lowest;`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样设置线程的优先级：`counterC.Priority = ThreadPriority.Highest;`，`counterB.Priority
    = ThreadPriority.Normal;`，和`counterA.Priority = ThreadPriority.Lowest;`。
- en: 'To run the threads in a synchronized way, let''s modify our code as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要以同步方式运行线程，让我们修改我们的代码如下：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We created a new `SynchronizedTicketCounter` class with the `ShowMessage()`
    method; please note the `lock(this){...}` in the preceding code. Run the program
    and check the output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`SynchronizedTicketCounter`类，其中包含`ShowMessage()`方法；请注意前面的代码中的`lock(this){...}`。运行程序并检查输出：
- en: '![](img/485977ff-b745-40fa-9d36-b62b53858573.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/485977ff-b745-40fa-9d36-b62b53858573.png)'
- en: We have the output we expected now that our counters are serving in the right
    sequence/order.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们计数器按正确的顺序/顺序服务，我们得到了预期的输出。
- en: Async/Await – why is blocking bad?
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Async/Await –为什么阻塞是坏的？
- en: 'Asynchronous programming is very helpful in cases where we are expecting various
    activities at the same point in time. With the `async` keyword, we define our
    method/operation as asynchronous. Consider the following code snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程在期望同时进行各种活动的情况下非常有用。使用`async`关键字，我们定义我们的方法/操作为异步。考虑以下代码片段：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we have a `AsyncAwait` class with an `async` method, `ShowMessage()`.
    This method is simply printing a message that would show in the console window.
    Now, whenever we call/consume this method in another code, that part of the code
    could wait/hold/block the operation until the `ShowMessage()` method executes
    and completes its task. Refer to the following snapshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`AsyncAwait`类，它有一个`async`方法，`ShowMessage()`。这个方法只是简单地打印出将在控制台窗口中显示的消息。现在，无论何时我们在其他代码中调用/消费这个方法，该部分的代码可能会等待/保持/阻塞操作，直到`ShowMessage()`方法执行并完成任务。请参见以下快照：
- en: '![](img/664b9a37-4b9d-492a-9c5c-5bf10071d809.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/664b9a37-4b9d-492a-9c5c-5bf10071d809.png)'
- en: 'Our previous screenshot says that we have set a delay of 1,000 milliseconds
    for our `ShowMessage()` method. Here, we instructed the program to complete after
    1,000 milliseconds. If we try to remove `await` from the previous code, Visual
    Studio will immediately give the warning to put `await` back in; see the following
    snapshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的截图显示，我们已经为`ShowMessage()`方法设置了1,000毫秒的延迟。在这里，我们指示程序在1,000毫秒后完成。如果我们尝试从之前的代码中移除`await`，Visual
    Studio将立即给出警告，要求将`await`放回；请参见以下快照：
- en: '![](img/90f87239-59f6-4cac-9693-651c66c8facd.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90f87239-59f6-4cac-9693-651c66c8facd.png)'
- en: 'With the help of the `await` operator, we are using non-blocking API calls.
    Run the program and see the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`await`操作符的帮助下，我们使用了非阻塞的API调用。运行程序并查看以下输出：
- en: '![](img/773d415b-b503-4812-b93d-36d7d3aeb4ed.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/773d415b-b503-4812-b93d-36d7d3aeb4ed.png)'
- en: We will get the output that is shown in the preceding snapshot.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到前面快照中显示的输出。
- en: Concurrent collections
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发集合
- en: 'The .NET Core framework provides a variety of collections with which we can
    use LINQ queries. As a developer, there are far fewer options when looking for
    thread-safe collections. Without thread-safe collections, it can become difficult
    for developers when they have to perform multiple operations. In this case, we
    would meet the race condition that we have already discussed in [Chapter 4](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml),
    *Implementing Design Patterns - Basics Part 2*. To overcome such situations, we
    need to use the `lock` statement, as we have used in the previous section. For
    example, we can write a code of a simplified implementation of the `lock` statement—refer
    to the following code snippet, where we have used the `lock` statement and collection
    class, `Dictionary`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core框架提供了各种集合，我们可以使用LINQ查询。作为一个开发者，在寻找线程安全集合时，可用的选项要少得多。如果没有线程安全集合，当开发者必须执行多个操作时，可能会变得困难。在这种情况下，我们将遇到我们已经在[第4章](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml)，“实现设计模式
    - 基础部分2”中讨论过的竞争条件。为了克服这种情况，我们需要使用`lock`语句，就像我们在前面的部分中使用的那样。例如，我们可以编写一个简化`lock`语句实现的代码——请参见以下代码片段，其中我们使用了`lock`语句和集合类`Dictionary`：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code is from `InventoryContext`; in this code, we are blocking
    other threads from locking the operation in which we are trying to update the
    quantity.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码来自`InventoryContext`；在这个代码中，我们正在阻止其他线程锁定我们试图更新的数量的操作。
- en: The main drawback of the `Dictionary` collection class is that it is not thread-safe.
    We have to use this in the `lock` statement while we're using `Dictionary` with
    multiple threads. To make our code thread-safe, we can use the `ConcurrentDictionary`
    collection class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dictionary`集合类的最大缺点是它不是线程安全的。当我们使用`Dictionary`时，我们必须在多个线程中使用`lock`语句。为了使我们的代码线程安全，我们可以使用`ConcurrentDictionary`集合类。'
- en: '`ConcurrentDictionary` is a thread-safe collection class and stores key-value
    pairs. This class has the implementation for the `lock` statement and provides
    a thread-safe class. Consider the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentDictionary`是一个线程安全的集合类，用于存储键值对。这个类实现了`lock`语句，并提供了一个线程安全的类。考虑以下代码：'
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code snippet is from the `InventoryContext` class of our FlixOne
    console application. In this code, we have the `_books` field, and it is initialized
    as a `ConcurrentDictionary` collection class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段来自我们的FlixOne控制台应用程序的`InventoryContext`类。在这个代码中，我们有`_books`字段，它被初始化为一个`ConcurrentDictionary`集合类。
- en: As we are using the `UpdateQuantity()` method of the `InventoryContext` class
    in multithreads, there is a chance that one thread adds the quantity, while the
    other thread resets the quantity to its initial level. This happens because our
    object is from a single collection, and any changes to the collection in one thread
    are not visible to the other threads. All threads are referencing the original
    unmodified collection, and, in simple terms, our method is not thread-safe, unless
    we use the `lock` statement or the `ConcurretDictionary` collection class.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用 `InventoryContext` 类的 `UpdateQuantity()` 方法进行多线程操作，所以有可能一个线程增加数量，而另一个线程将数量重置为其初始水平。这是因为我们的对象来自单个集合，一个线程对集合的任何更改对其他线程都是不可见的。所有线程都在引用原始未修改的集合，简单来说，我们的方法不是线程安全的，除非我们使用
    `lock` 语句或 `ConcurretDictionary` 集合类。
- en: Patterns and practices – TDD and Parallel LINQ
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式和实践 - TDD 和 Parallel LINQ
- en: While we work with multithreading, we should follow best practices to write
    a **smooth code**. A smooth code is where a developer doesn't face deadlock. In
    other words, multithreading requires a lot of care during the writing process.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理多线程时，我们应该遵循最佳实践来编写**流畅的代码**。流畅的代码是指开发者不会遇到死锁。换句话说，多线程在编写过程中需要非常小心。
- en: While multiple threads are running in a class/program, deadlock occurs when
    each thread approaches the object or resource written under a `lock` statement.
    The actual deadlock occurs when each thread approaches to lock an object/resource
    that is already locked by another thread.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个线程在一个类/程序中运行时，如果每个线程都接近在 `lock` 语句下编写的对象或资源，就会发生死锁。实际的死锁发生在每个线程都试图锁定已被其他线程锁定的对象/资源。
- en: A small mistake can result in developers having to tackle unknown bugs that
    occur due to threads that are blocked. In addition to this, a bad implementation
    of a few words in the code can impact 100 lines of code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小小的错误可能会导致开发者不得不解决由于线程阻塞而发生的未知错误。此外，代码中几个词的糟糕实现可能会影响 100 行代码。
- en: 'Let''s go back to our example of conference tickets, which we discussed at
    the beginning of this chapter. What would happen if ticket counters are unable
    to serve their purpose and distribute tickets? In this scenario, each person would
    try to reach a ticket counter and obtain a ticket, which could jam the ticket
    counter. This could cause the ticket counter to become blocked. The same logic
    applies to our program. We''d meet a deadlock situation in which multiple threads
    would try to lock our object/resource. The best practice to use to avoid such
    a condition is using a mechanism that synchronizes access to the object/resource.
    The .NET Core framework provides a `Monitor` class to achieve this. I have rewritten
    our old code to avoid a deadlock situation—see the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到本章开头讨论的会议票务示例。如果售票窗口无法履行其职责分发票务，会发生什么？在这种情况下，每个人都会试图到达售票窗口并获取一张票，这可能会导致售票窗口拥堵。这可能会使售票窗口阻塞。同样的逻辑也适用于我们的程序。我们可能会遇到死锁情况，其中多个线程会尝试锁定我们的对象/资源。避免这种状况的最佳实践是使用一种同步访问对象/资源的机制。.NET
    Core 框架提供了一个 `Monitor` 类来实现这一点。我已经重写了我们的旧代码以避免死锁情况——请参阅以下代码：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we have the `ProcessTicket` method; it starts three threads (each thread
    represents each ticket counter). Every thread is reaching to `ShowMessage` of
    the `TicketCounter` class. There will be a problem of deadlock if our `ShowMessage`
    method is not written well to handle this situation. All three threads will try
    to acquire a lock for the respective object/resource related to the `ShowMessage`
    method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有 `ProcessTicket` 方法；它启动了三个线程（每个线程代表一个售票窗口）。每个线程都会尝试访问 `TicketCounter`
    类的 `ShowMessage` 方法。如果我们的 `ShowMessage` 方法没有很好地编写以处理这种情况，将会出现死锁问题。所有三个线程都会尝试获取与
    `ShowMessage` 方法相关的对象/资源的锁。
- en: 'The following code is the implementation of the `ShowMessage` method, and I
    have written this code to handle a deadlock situation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是 `ShowMessage` 方法的实现，我编写了这段代码来处理死锁情况：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding is the `ShowMessage()` method of our `TicketCounter` class. In
    this method, whenever a thread will try to lock `Object`, if `Object` is already
    locked, it tries for 300 milliseconds. The `Monitor` class handles this situation
    automatically. When using the `Monitor` class, the developer does not need to
    worry about a situation in which multiple threads are running, and each of these
    threads is trying to acquire the lock. Run the program to see the following output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的是我们的`TicketCounter`类的`ShowMessage()`方法。在这个方法中，每当一个线程尝试锁定`Object`时，如果`Object`已经被锁定，它会尝试300毫秒。`Monitor`类会自动处理这种情况。当使用`Monitor`类时，开发者不需要担心多个线程正在运行，并且每个线程都在尝试获取锁的情况。运行程序以查看以下输出：
- en: '![](img/b5992517-e5e5-490e-bb0a-ef9d708e0994.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b5992517-e5e5-490e-bb0a-ef9d708e0994.png)'
- en: 'In the preceding snapshot, you will notice that after `counterA`, `counterC`
    is serving and then `counter B`. This means that after `thread A`, `thread C`
    was initiated, and then `thread B`. In other words, `thread A` acquires the lock
    first, and after 300 milliseconds, `thread C` tries to lock, and then `thread
    B` tries to lock the object. If you want to set the order or priorities of the
    thread, you can add the following lines of code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的快照中，你会注意到在`counterA`之后，`counterC`提供服务，然后是`counter B`。这意味着在`thread A`之后，`thread
    C`被启动，然后是`thread B`。换句话说，`thread A`首先获取锁，然后300毫秒后，`thread C`尝试获取锁，然后`thread B`尝试获取锁。如果你想设置线程的顺序或优先级，你可以添加以下代码行：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When you add the preceding lines to the `ProcessTickets` method, all the threads
    will work: first `Thread C`, then `Thread B`, and, finally, `Thread A`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将前面的行添加到`ProcessTickets`方法中时，所有线程都将工作：首先是`Thread C`，然后是`Thread B`，最后是`Thread
    A`。
- en: 'Thread priorities are an enum that tells us how to schedule the thread and
    `System.Threading.ThreadPriority` with the following values:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 线程优先级是一个枚举，它告诉我们如何调度线程，以及`System.Threading.ThreadPriority`具有以下值：
- en: '**Lowest**: This is the least priority, which means threads with the `Lowest`
    priority can be scheduled after the threads of any other priority.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lowest**：这是最低优先级，这意味着具有`Lowest`优先级的线程可以在具有任何其他优先级的线程之后调度。'
- en: '**BelowNormal**: Threads with a `BelowNormal` priority can be scheduled after
    threads having a `Normal` priority, but before threads having the `Lowest` priority.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BelowNormal**：具有`BelowNormal`优先级的线程可以在具有`Normal`优先级的线程之后调度，但在具有`Lowest`优先级的线程之前。'
- en: '**Normal**: All threads are having the default priority as `Normal`. Threads
    with a `Normal` priority can be scheduled after threads having an `AboveNormal`
    priority, but before those threads that have a `BelowNormal` priority.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Normal**：所有线程都默认具有`Normal`优先级。具有`Normal`优先级的线程可以在具有`AboveNormal`优先级的线程之后调度，但在具有`BelowNormal`优先级的线程之前。'
- en: '**AboveNormal**: Threads with an `AboveNormal` priority can be scheduled before
    threads having a `Normal` priority, but after threads having the `Highest` priority.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AboveNormal**：具有`AboveNormal`优先级的线程可以在具有`Normal`优先级的线程之前调度，但在具有`Highest`优先级的线程之后。'
- en: '**Highest**: This is the top-most priority level of threads. Threads with the
    `Highest` priority can be scheduled before threads having any other priority.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Highest**：这是线程的最高优先级。具有`Highest`优先级的线程可以在具有任何其他优先级的线程之前调度。'
- en: 'After setting a priority level for the threads, execute the program and see
    the following output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在为线程设置优先级后，执行程序并查看以下输出：
- en: '![](img/ceaf2e4f-1185-4ac0-aa88-bf90055500bf.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ceaf2e4f-1185-4ac0-aa88-bf90055500bf.png)'
- en: As per the preceding snapshot, after setting the priority, the counters are
    serving in the order `C`, `B`, and `A`. With a little caution and simple implementation,
    we can handle a deadlock situation as well as schedule our threads to be served
    in a specific order/priority.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的快照，在设置优先级后，计数器按顺序`C`、`B`和`A`提供服务。只要稍加小心和简单的实现，我们就可以处理死锁情况，并按特定的顺序/优先级调度线程。
- en: The .Net Core framework also provides a **Task Parallel Library** (**TPL**)
    that is a set of public APIs that belong to the `System.Threading` and `System.Threading.Tasks`
    namespaces. With the help of TPL, developers can make applications concurrent
    by adapting its simplification implementation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: .Net Core框架还提供了一个**任务并行库（TPL**），它是一组属于`System.Threading`和`System.Threading.Tasks`命名空间的公共API。借助TPL，开发者可以通过采用其简化实现来使应用程序并发。
- en: 'Considering the following code, we can see the simplest implementation of a
    TPL:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，我们可以看到TPL的最简单实现：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding is a simple `ForEach` loop using a `Parallel` keyword. In the
    preceding code, we are just iterating a collection of `books` and processing it
    with the use of the `Process` method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上述是一个简单的`ForEach`循环，使用了`Parallel`关键字。在上述代码中，我们只是在迭代一个`books`集合，并使用`Process`方法来处理它：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code is our `Process` method (again, the simplest one), and it
    prints the details of the `books`. As per their requirement, users can perform
    as many actions as they want:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是我们的`Process`方法（再次，这是最简单的一个），它打印出`books`的详细信息。根据他们的要求，用户可以执行他们想要的任何操作：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, we have the `ParallelismExample` method, and it generates the
    book list and processes the books by executing the `PallelVersion` method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有一个`ParallelismExample`方法，它生成书籍列表并通过执行`PallelVersion`方法来处理书籍。
- en: 'Before you execute the program to see the following output, first consider
    the following code snippet of sequential implementation:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在你执行程序以查看以下输出之前，首先考虑以下顺序实现的代码片段：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code is a `Sequential` method; it uses a simple `foreach` loop
    to process the book collections. Execute the program and see the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个`Sequential`方法；它使用一个简单的`foreach`循环来处理书籍集合。运行程序并查看以下输出：
- en: '![](img/fcc24a14-5414-42e8-b803-a9dc83c0429f.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fcc24a14-5414-42e8-b803-a9dc83c0429f.png)'
- en: 'Take note of the preceding snapshot. First, there are four processes running
    in the system on which I am running this demo. The second iterated collection
    is in a sequence/order from 1 to 19\. The program does not divide the tasks into
    different processes running on the machine. Press any key to exit from the current
    process, execute the program for the `ParallelismVersion` method, and see the
    following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上述快照。首先，在我运行此演示的系统上有四个进程正在运行。第二个迭代的集合是从1到19的顺序/顺序。程序不会将任务划分到机器上运行的不同进程中。按任意键退出当前进程，执行`ParallelismVersion`方法的程序，并查看以下输出：
- en: '![](img/a2119c1f-765c-4c1f-8350-971f9b585cab.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a2119c1f-765c-4c1f-8350-971f9b585cab.png)'
- en: The preceding screenshot is of an output from a parallel code; you may notice
    that the code is not processed in sequence and the IDs are not coming through
    in sequence/order, as we can see `Id` `13` comes after `9` but before `10`. If
    these were running in sequence, then the order of the `Id`s would be `9`, `10`,
    and then `13`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图是并行代码的输出；你可能注意到代码不是按顺序处理的，ID也不是按顺序出现的，正如我们所看到的`Id` `13`在`9`之后但在`10`之前。如果这些是按顺序运行的，那么`Id`的顺序将是`9`，`10`，然后是`13`。
- en: LINQ was in the .NET world a long time before the birth of .NET Core. `LINQ-to-Objects`
    allows us to perform in-memory query operations by using arbitrary sequences of
    objects. `LINQ-to-Objects` is a collection of extension methods on top of `IEnumerable<T>`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ在.NET Core诞生之前就在.NET世界中存在很长时间了。`LINQ-to-Objects`允许我们通过使用任意对象的序列来执行内存查询操作。`LINQ-to-Objects`是`IEnumerable<T>`上的扩展方法集合。
- en: '**Deferred execution** means execution happens once the data is enumerated.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**延迟执行**意味着数据被枚举后才会执行。'
- en: 'PLINQ can be used as an alternative to TPL. It is a parallel implementation
    of LINQ. The PLINQ query operates on in-memory `IEnumerable` or `IEnumerable<T>`
    data sources. Also, it has a deferred execution. The LINQ query performs operations
    in sequence, while PLINQ executes operations in parallel and makes full use of
    all the processors on the machine. Consider the following code to see the implementation
    of PLINQ:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ可以用作TPL的替代品。它是LINQ的并行实现。PLINQ查询在内存中的`IEnumerable`或`IEnumerable<T>`数据源上操作。它还具有延迟执行。LINQ查询按顺序执行操作，而PLINQ并行执行操作并充分利用机器上的所有处理器。考虑以下代码以查看PLINQ的实现：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code is the process method of our PLINQ class. Here, we are using
    PLINQ to query any books in stock with a quantity of more than `12250`. Execute
    the code to see this output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是我们PLINQ类的处理方法。在这里，我们使用PLINQ查询库存中数量超过`12250`的任何书籍。运行代码以查看此输出：
- en: '![](img/e1c27ddb-a490-46ce-8df1-1ade2ec4f248.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e1c27ddb-a490-46ce-8df1-1ade2ec4f248.png)'
- en: 'PLINQ uses all the processors of a machine, but we can limit the processors
    in PLINQ by using the `WithDegreeOfParallelism()` method. We can use the following
    code in our `Process ()` method of the `Linq` class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ使用机器上的所有处理器，但我们可以通过使用`WithDegreeOfParallelism()`方法来限制PLINQ中的处理器数量。我们可以在`Linq`类的`Process()`方法中使用以下代码：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code will use only three processors of the machine. Execute them,
    and you'll find that you get the same output as in the case of the previous code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将仅使用机器的三个处理器。执行它们，你会发现你得到的输出与之前代码的情况相同。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed concurrent programming and concurrency in the
    real world. We looked at how we can handle various scenarios related to concurrency
    in our day-to-day life. We looked at collecting conference tickets from serving
    counters, and we understood what parallel programming and concurrent programming
    are. We have also covered multithreading, `Async`/`Await`, `Concurrent` collection,
    and PLINQ.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了并发编程和现实世界中的并发。我们探讨了如何在日常生活中处理与并发相关的各种场景。我们研究了从服务台收集会议门票的情况，并理解了并行编程和并发编程是什么。我们还涵盖了多线程、`Async`/`Await`、`Concurrent`集合和PLINQ。
- en: In the upcoming chapter, we will get a taste of functional programming using
    the C# language. We will dive deeper into the concepts that show us how to use
    C# in .NET Core to perform functional programming.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将通过使用C#语言来体验函数式编程。我们将更深入地探讨那些展示我们如何在.NET Core中使用C#进行函数式编程的概念。
- en: Questions
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助你巩固本章包含的信息：
- en: What is concurrent programming?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是并发编程？
- en: How does true parallelism happen?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真正的并行是如何发生的？
- en: What is the race condition?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是竞态条件？
- en: Why should we use a concurrent dictionary?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们应该使用并发字典？
- en: Further reading
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following book will help you learn more about the topics that have been
    covered in this chapter:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下书籍将帮助你了解更多关于本章所涵盖的主题：
- en: '*Concurrent Patterns and Best Practices*, by *Atul S Khot*, published by *Packt
    Publishing*: [https://www.packtpub.com/in/application-development/concurrent-patterns-and-best-practices](https://www.packtpub.com/in/application-development/concurrent-patterns-and-best-practices)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《并发模式和最佳实践》*，作者*Atul S Khot*，由*Packt Publishing*出版：[https://www.packtpub.com/in/application-development/concurrent-patterns-and-best-practices](https://www.packtpub.com/in/application-development/concurrent-patterns-and-best-practices)'
