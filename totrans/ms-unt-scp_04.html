<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Event-driven Programming</h1></div></div></div><p>The <code class="literal">Update</code> events for <code class="literal">MonoBehaviour</code> objects seem to offer a convenient place for executing code that should perform regularly over time, spanning multiple frames, and possibly multiple scenes. When creating sustained behaviors over time, such as artificial intelligence for enemies or continuous motion, it may seem that there are almost no alternatives to filling an <code class="literal">Update</code> function with many <code class="literal">if</code> and <code class="literal">switch</code> statements, branching your code in different directions depending on what your objects need to do at the current time. But, when the <code class="literal">Update</code> events are seen this way, as a default place to implement prolonged behaviors, it can lead to severe performance problems for larger and more complex games. On deeper analysis, it's not difficult to see why this would be the case. Typically, games are full of so many behaviors, and there are so many things happening at once in any one scene that implementing them all through the <code class="literal">Update</code> functions is simply unfeasible. Consider the enemy characters alone, they need to know when the player enters and leaves their line of sight, when their health is low, when their ammo has expired, when they're standing on harmful terrain, when they're taking damage, when they're moving or not, and lots more. On thinking initially about this range of behaviors, it seems that all of them require constant and continuous attention because enemies should always know, instantly, when changes in these properties occur as a result of the player input. That is, perhaps, the main reason why the <code class="literal">Update</code> function seems to be the most suitable place in these situations but there are better alternatives, namely, event-driven programming. By seeing your game and your application in terms of events, you can make considerable savings in performance. This chapter then considers the issue of events and how to manage them game wide.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec48"/>Events</h1></div></div></div><p>Game worlds are fully deterministic systems; in Unity, the scene represents a shared 3D Cartesian space and timeline inside which finite <code class="literal">GameObjects</code> exist. Things only happen within this space when the<a id="id296" class="indexterm"/> game logic and code permits them to. For example, objects can only move when there is code somewhere that tells them to do so, and under specific conditions, such as when the player presses specific buttons on the keyboard. Notice from the example that behaviors are not simply random but are interconnected; objects move only when keyboard events occur. There is an important connection established between the actions, where one action entails another. These connections or linkages are referred to as events; each unique connection being a single event. Events are not active but passive; they represent moments of opportunity but not action in themselves, such as a key press, a mouse click, an object entering a collider volume, the player being attacked, and so on. These are examples of events and none of them say what the program should actually do, but only the kind of scenario that just happened. Event-driven programming starts with the recognition of events as a general concept and comes to see almost every circumstance in a game as an instantiation of an event; that is, as an event situated in time, not just an event concept but as a specific event that happens at a specific time. Understanding game events like these is helpful because all actions in a game can then be seen as direct responses to events as and when they happen. Specifically, events are connected to responses; an event happens and triggers a response. Further, the response can go on to become an event that triggers further responses and so on. In other words, the game world is a complete, integrated system of events and responses. Once<a id="id297" class="indexterm"/> the world is seen this way, the question then arises as to how it can help us improve performance over simply relying on the <code class="literal">Update</code> functions to move behaviors forward on every frame. And the method is simply by finding ways to reduce the frequency of events. Now, stated in this way, it may sound a crude strategy, but it's important. To illustrate, let's consider the example of an enemy character firing a weapon at the player during combat.</p><p>Throughout the gameplay, the enemy will need to keep track of many properties. Firstly, their health, because when it runs low the enemy should seek out medical kits and aids to restore their health again. Secondly, their ammo, because when it runs low the enemy should seek to collect more and also the enemy will need to make reasoned judgments about when to fire at the player, such as only when they have a clear line of sight. Now, by simply thinking about this scenario, we've already identified some connections between actions that might be identified as events. But before taking this consideration further, let's see how we might implement this behavior using an <code class="literal">Update</code> function, as shown in the following code sample 4-1. Then, we'll look at how events can help us improve on that implementation:</p><div><pre class="programlisting"> // Update is called once per frame
 void Update () 
 {
    //Check enemy health
    //Are we dead?
    if(Health &lt;= 0)
    {
          //Then perform die behaviour
          Die();
          return;
    }
 
    //Check for health low
    if(health &lt;= 20)
    {
          //Health is low, so find first-aid
          RunAndFindHealthRestore();
          return;
    }
 
    //Check ammo
 
    //Have we run out of ammo?
    if(Ammo &lt;= 0)
    {
          //Then find more
          SearchMore();
          return;
    }
 
    //Health and ammo are fine. Can we see player? If so, shoot
    if(HaveLineOfSight)
    {
            FireAtPlayer();
   }
 }</pre></div><p>The preceding code sample 4-1 shows a heavy <code class="literal">Update</code> function filled with lots of condition checking and responses. In essence, the <code class="literal">Update</code> function attempts to merge event handling and response behaviors into one and the results in an unnecessarily expensive process. If we think about the event connections between these different processes (the health and ammo check), we see how the code could be refactored more neatly. For example, ammo only changes on two occasions: when a weapon is fired or when new ammo is <a id="id298" class="indexterm"/>collected. Similarly, health only changes on two occasions: when an enemy is successfully attacked by the player or when an enemy collects a first-aid kit. In the first case, there is a reduction, and in the latter case, an increase.</p><p>Since these are the only times when the properties change (the events), these are the only points where their values need to be validated. See the following code sample 4-2 for a refactored enemy, which includes C# properties and a much reduced <code class="literal">Update</code> function:</p><div><pre class="programlisting"> using UnityEngine;
 using System.Collections;
 
 public class EnemyObject : MonoBehaviour 
 {
    //-------------------------------------------------------
    //C# accessors for private variables
<strong>    public int Health</strong>
    {
          get{return _health;}
          set
          {
                //Clamp health between 0-100
               _health = Mathf.Clamp(value, 0, 100);
 
                //Check if dead
                if(_health &lt;= 0)
                {
                      OnDead();
                      return;
                }
 
                //Check health and raise event if required
                if(_health &lt;= 20)
                {
                      OnHealthLow();
                      return;
                }
          }
    }
    //-------------------------------------------------------
<strong>    public int Ammo</strong>
    {
          get{return _ammo;}
          set
          {
               //Clamp ammo between 0-50
              _ammo = Mathf.Clamp(value,0,50);
                //Check if ammo empty
                if(_ammo &lt;= 0)
                {
                      //Call expired event
                      OnAmmoExpired();
                      return;
                }
          }
    }
    //-------------------------------------------------------
   //Internal variables for health and ammo
<strong>    private int _health = 100;</strong>
<strong>    private int _ammo = 50;</strong>
    //-------------------------------------------------------
    // Update is called once per frame
    void Update () 
    {
    }
    //-------------------------------------------------------
    //This event is called when health is low
   <strong>void OnHealthLow()</strong>
    {
          //Handle event response here
    }
    //-------------------------------------------------------
    //This event is called when enemy is dead
<strong>    void OnDead()</strong>
    {
        //Handle event response here
    }
    //-------------------------------------------------------
    //Ammo run out event
<strong>    void OnAmmoExpired()</strong>
    {
        //Handle event response here
    }
    //-------------------------------------------------------
 }</pre></div><p>The enemy class in the code sample 4-2 has been refactored to an event-driven design, where properties such as <code class="literal">Ammo</code> and <code class="literal">Health</code> are validated not inside the <code class="literal">Update</code> function but on assignment. From here, events are raised wherever appropriate based on the newly assigned values. By adopting an event-driven design, we introduce performance optimization and <a id="id299" class="indexterm"/>cleanness into our code; we reduce the excess baggage and value checks as found with the <code class="literal">Update</code> function in the code sample 4-1, and instead we only allow value-specific events to drive our code, knowing they'll be invoked only at the relevant times.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec49"/>Event management</h1></div></div></div><p>Event-driven programming can make our lives a lot easier. But no sooner than we accept events into the design <a id="id300" class="indexterm"/>do we come across a string of new problems that require a thoroughgoing resolution. Specifically, we saw in the code sample 4-2 how C# properties for health and ammo are used to validate and detect for relevant changes and then to raise events (such as <code class="literal">OnDead</code>) where appropriate. This works fine in principle, at least when the enemy must be notified about events that happen to itself. However, what if an enemy needed to know about the death of another enemy or needed to know when a specified number of other enemies had been killed? Now, of course, thinking about this specific case, we could go back to the enemy class in the code sample 4-2 and amend it to call an <code class="literal">OnDead</code> event not just for the current instance but for all other enemies using functions such as <code class="literal">SendMessage</code>, as we've seen in the previous chapters. But this doesn't really solve our problem in the general sense. In fact, let's state the ideal case straight away; we want every object to optionally listen for every type of event and to be notified about them as and when they happen, just as easily as if the event had happened to them. So the question that we face now is about how to code an optimized system to<a id="id301" class="indexterm"/> allow easy event management like this. In short, we need an <code class="literal">EventManager</code> class that allows objects to listen to specific events. This system relies on three central concepts, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">EventListener</code>: A listener refers to any object that wants to be notified about an event when it happens, even its own events. In practice, almost every object will be a listener for<a id="id302" class="indexterm"/> at least one event. An<a id="id303" class="indexterm"/> enemy, for example, may want notifications about low health and low ammo among others. In this case, it's a listener for at least two separate events. Thus, whenever an object expects to be told when an event happens, it becomes a listener.</li><li class="listitem" style="list-style-type: disc"><code class="literal">EventPoster</code>: In contrast to listeners, when an object detects that an event has occurred, it must<a id="id304" class="indexterm"/> announce or post a public notification about it that allows all other listeners to be notified. In the code sample 4-2, the <a id="id305" class="indexterm"/>enemy class detects the <code class="literal">Ammo</code> and <code class="literal">Health</code> events using properties and then calls the internal events, if required. But to be a true poster in this sense, we require that the object must raise events at a global level.</li><li class="listitem" style="list-style-type: disc"><code class="literal">EventManager</code>: Finally, there's an overarching singleton <code class="literal">EventManager</code> object that persists <a id="id306" class="indexterm"/>across levels and is globally accessible. This <a id="id307" class="indexterm"/>object effectively links listeners to posters. It accepts notifications of events sent by posters and then immediately dispatches the notifications to all appropriate listeners in the form of events.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec25"/>Starting event management with interfaces</h2></div></div></div><p>The first or original <a id="id308" class="indexterm"/>entity in the event handling system is the listener—the thing that should be notified about specific events as and when they happen. Potentially, a listener could be any kind of object <a id="id309" class="indexterm"/>or any kind of class; it simply expects to be notified about specific events. In short, the listener will need to register itself with the <code class="literal">EventManager</code> as a listener for one or more specific events. Then, when the event actually occurs, the listener should be notified directly by a function call. So, technically, the listener raises a type-specificity issue for the <code class="literal">EventManager</code> about how the manager should invoke an event on the listener if the listener could potentially be an object of any type. Of course, this issue can be worked around, as we've seen, using either <code class="literal">SendMessage</code> or <code class="literal">BroadcastMessage</code>. Indeed, there are event handling systems freely available online, such as <code class="literal">NotificationCenter</code> that rely on these functions. However, in this chapter, we'll avoid them using<a id="id310" class="indexterm"/> interfaces and use polymorphism instead, as both <code class="literal">SendMessage</code> and <code class="literal">BroadcastMessage</code> rely heavily on reflection (information <a id="id311" class="indexterm"/>on reflection is covered later in <a class="link" href="ch08.html" title="Chapter 8. Customizing the Unity Editor">Chapter 8</a>, <em>Customizing the Unity Editor</em>). Specifically, we'll create an interface from which all listener objects derive.</p><div><div><h3 class="title"><a id="tip22"/>Tip</h3><p>More information on the freely available <code class="literal">NotificationCenter</code> (C# version) is available from the Unity wiki at <a class="ulink" href="http://wiki.unity3d.com/index.php?title=CSharpNotificationCenter">http://wiki.unity3d.com/index.php?title=CSharpNotificationCenter</a>.</p></div></div><p>In C#, an interface is like a hollow abstract base class. Like a class, an interface brings together a collection of methods and functions into a single template-like unit. But, unlike a class, an interface only allows you to define function prototypes such as the name, return type, and arguments for a function. It doesn't let you define a function body. The reason being that an interface simply defines the total set of functions that a derived class will have. The derived class may implement the functions however necessary, and the interface simply exists so that other objects can invoke the functions via polymorphism without knowing the specific type of each derived class. This makes interfaces a suitable candidate to create a <code class="literal">Listener</code> object. By defining a <code class="literal">Listener</code> interface from which all objects will be derived, every object has the ability to be a listener for events.</p><p>The following code sample 4-3 demonstrates a sample <code class="literal">Listener</code> interface:</p><div><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 //-----------------------------------------------------------
04 //Enum defining all possible game events
05 //More events should be added to the list
<strong>06 public enum EVENT_TYPE {GAME_INIT, </strong>
<strong>07                                 GAME_END,</strong>
<strong>08                                 AMMO_EMPTY,</strong>
<strong>09                                 HEALTH_CHANGE,</strong>
<strong>10                                 DEAD};</strong>
11 //-----------------------------------------------------------
12 //Listener interface to be implemented on Listener classes
<strong>13 public interface IListener</strong>
14 {
15 //Notification function invoked when events happen
<strong>16 void OnEvent(EVENT_TYPE Event_Type, Component Sender, Object Param = null);</strong>

17 }
18 //-----------------------------------------------------------</pre></div><p>The following are the comments on the code sample 4-3:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Lines 06-10</strong>: This enumeration should define a complete list of all possible game events that could be raised. The sample code lists only five game events: <code class="literal">GAME_INIT</code>, <code class="literal">GAME_END</code>, <code class="literal">AMMO_EMPTY</code>, <code class="literal">HEALTH_CHANGE</code>, and <code class="literal">DEAD</code>. Your game will presumably have many more. You don't actually need to use enumerations for encoding events; you could just use integers. But I've used enumerations to improve event readability in code.</li><li class="listitem" style="list-style-type: disc"><strong>Lines 13-17</strong>: The <code class="literal">Listener</code> interface is defined as <code class="literal">IListener</code> using the C# interfaces. It supports just one event, namely <code class="literal">OnEvent</code>. This function will be inherited by <a id="id312" class="indexterm"/>all derived classes and will be invoked by the manager whenever an event occurs for which the listener is registered. Notice that <code class="literal">OnEvent</code> is simply a function prototype; it has no body.<div><div><h3 class="title"><a id="tip23"/>Tip</h3><p>More information on C# interfaces can be found at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/ms173156.aspx">http://msdn.microsoft.com/en-us/library/ms173156.aspx</a>.</p></div></div></li></ul></div><p>Using the <code class="literal">IListener</code> interface, we now have the ability to make a listener from any object using only class inheritance; that is, any object can now declare itself as a listener and potentially receive events. For example, a new <code class="literal">MonoBehaviour</code> component can be turned into a listener<a id="id313" class="indexterm"/> with the following code sample 4-4. This code, as in the previous chapters, uses multiple inheritance, that is, it inherits from two classes. More information on multiple inheritance can be found at <a class="ulink" href="http://www.dotnetfunda.com/articles/show/1185/multiple-inheritance-in-csharp">http://www.dotnetfunda.com/articles/show/1185/multiple-inheritance-in-csharp</a>:</p><div><pre class="programlisting">using UnityEngine;
 using System.Collections;
 
 public class MyCustomListener : MonoBehaviour, IListener
 {
    // Use this for initialization
    void Start () {}
    // Update is called once per frame
    void Update () {}
    //---------------------------------------
    //Implement OnEvent function to receive Events 
<strong>    public void OnEvent(EVENT_TYPE Event_Type, Component Sender, Object Param = null)</strong>
    {
    }
    //---------------------------------------
 }</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec26"/>Creating an EventManager</h2></div></div></div><p>Any object can now be turned into a listener, as we've seen. But still the listeners must register themselves <a id="id314" class="indexterm"/>with a manager object of some kind. Thus, it is the duty of the manager to call the events on the listeners when the events actually happen. Let's now turn to the manager itself and its implementation details. The <a id="id315" class="indexterm"/>manager class will be called <code class="literal">EventManager</code>, as shown in the following code sample 4-5. This class, being a persistent singleton object, should be attached to an empty <code class="literal">GameObject</code> in the scene where it will be directly accessible to every other object through a static instance property. More on this class and its usage is considered in the subsequent comments:</p><div><pre class="programlisting">001 using UnityEngine;
002 using System.Collections;
<strong>003 using System.Collections.Generic;</strong>
004 //-----------------------------------
005 //Singleton EventManager to send events to listeners
006 //Works with IListener implementations
007 public class EventManager : MonoBehaviour
008 {
009      #region C# properties
010 //-----------------------------------
011     //Public access to instance
012     public static EventManager Instance
013       {
014             get{return instance;}
015             set{}
016       }
017    #endregion
018 
019    #region variables
020       // Notifications Manager instance (singleton design pattern)
021    private static EventManager instance = null;
022 
023      //Array of listeners (all objects registered for events)
<strong>024      private Dictionary&lt;EVENT_TYPE, List&lt;IListener&gt;&gt; Listeners = new Dictionary&lt;EVENT_TYPE, List&lt;IListener&gt;&gt;();</strong>

025     #endregion
026 //-----------------------------------------------------------
027     #region methods
028      //Called at start-up to initialize
029     void Awake()
030     {
031             //If no instance exists, then assign this instance
032             if(instance == null)
033            {
034                   instance = this;
035                   DontDestroyOnLoad(gameObject); 
036            }
037             else
038                   DestroyImmediate(this);
039      }
040//-----------------------------------------------------------
041      /// &lt;summary&gt;
042      /// Function to add listener to array of listeners
043      /// &lt;/summary&gt;
044      /// &lt;param name="Event_Type"&gt;Event to Listen for&lt;/param&gt;
045     /// &lt;param name="Listener"&gt;Object to listen for event&lt;/param&gt;
<strong>046     public void AddListener(EVENT_TYPE Event_Type, IListener Listener)</strong>
047     {
048            //List of listeners for this event
049            List&lt;IListener&gt; ListenList = null;
050 
051            // Check existing event type key. If exists, add to list
052            if(Listeners.TryGetValue(Event_Type, out ListenList))
053            {
054                   //List exists, so add new item
055                   ListenList.Add(Listener);
056                   return;
057            }
058 
059            //Otherwise create new list as dictionary key
060            ListenList = new List&lt;IListener&gt;();
061            ListenList.Add(Listener);
062            Listeners.Add(Event_Type, ListenList); 
063      }
064 //-----------------------------------------------------------
065       /// &lt;summary&gt;
066       /// Function to post event to listeners
067       /// &lt;/summary&gt;
068       /// &lt;param name="Event_Type"&gt;Event to invoke&lt;/param&gt;
069       /// &lt;param name="Sender"&gt;Object invoking event&lt;/param&gt;
070       /// &lt;param name="Param"&gt;Optional argument&lt;/param&gt;
<strong>071       public void PostNotification(EVENT_TYPE Event_Type, Component Sender, Object Param = null)</strong>

072       {
073            //Notify all listeners of an event
074 
075            //List of listeners for this event only
076            List&lt;IListener&gt; ListenList = null;
077 
078            //If no event exists, then exit 
079            if(!Listeners.TryGetValue(Event_Type, out ListenList))
080                    return;
081 
082             //Entry exists. Now notify appropriate listeners
083             for(int i=0; i&lt;ListenList.Count; i++)
084             {
085                   if(!ListenList[i].Equals(null)) 
<strong>086                   </strong>
<strong>ListenList[i].OnEvent(Event_Type, Sender, Param);</strong>
087             }
088      }
089 //-----------------------------------------------------------
090      //Remove event from dictionary, including all listeners
091      public void RemoveEvent(EVENT_TYPE Event_Type)
092      {
093            //Remove entry from dictionary
094            Listeners.Remove(Event_Type);
095      }
096 //-----------------------------------------------------------
097       //Remove all redundant entries from the Dictionary
098      public void RemoveRedundancies()
099      {
100             //Create new dictionary
101             Dictionary&lt;EVENT_TYPE, List&lt;IListener&gt;&gt; TmpListeners = new Dictionary&lt;EVENT_TYPE, List&lt;IListener&gt;&gt;();

102 
103             //Cycle through all dictionary entries
104             foreach(KeyValuePair&lt;EVENT_TYPE, List&lt;IListener&gt;&gt; Item in Listeners)

105             {
106                   //Cycle all listeners, remove null objects
107                   for(int i = Item.Value.Count-1; i&gt;=0; i--)
108                   {
109                         //If null, then remove item
110                         if(Item.Value[i].Equals(null))
111                                 Item.Value.RemoveAt(i);
112                   }
113 
114            //If items remain in list, then add to tmp dictionary
115                    if(Item.Value.Count &gt; 0)
116                          TmpListeners.Add (Item.Key, Item.Value);
117             }
118 
119             //Replace listeners object with new dictionary
120             Listeners = TmpListeners;
121       }
122 //-----------------------------------------------------------
123       //Called on scene change. Clean up dictionary
124       void OnLevelWasLoaded()
125       {
126            RemoveRedundancies();
127       }
128 //-----------------------------------------------------------
129      #endregion
130 }</pre></div><div><div><h3 class="title"><a id="tip24"/>Tip</h3><p>More information on the<a id="id316" class="indexterm"/> <code class="literal">OnLevelWasLoaded</code> event can be found at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnLevelWasLoaded.html">http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnLevelWasLoaded.html</a>.</p></div></div><p>The following are<a id="id317" class="indexterm"/> the comments on the code sample 4-5:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Line 003</strong>: Notice the addition of the <code class="literal">System.Collections.Generic</code> namespace giving us access<a id="id318" class="indexterm"/> to additional mono classes, including the <code class="literal">Dictionary</code> class. This class will be used throughout the <code class="literal">EventManager</code> class. More information on mono and its classes are explained later in <a class="link" href="ch06.html" title="Chapter 6. Working with Mono">Chapter 6</a>, <em>Working with Mono</em>. In short, the <code class="literal">Dictionary</code> class is a special kind of 2D array that allows us to store a database of values based on key-value pairing. More information on the <code class="literal">Dictionary</code> class <a id="id319" class="indexterm"/>can be found at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx">http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx</a>.</li><li class="listitem" style="list-style-type: disc"><strong>Line 007</strong>: The <code class="literal">EventManager</code> class is derived from <code class="literal">MonoBehaviour</code> and should be attached to an empty <code class="literal">GameObject</code> in the scene where it will exist as a persistent singleton.</li><li class="listitem" style="list-style-type: disc"><strong>Line 024</strong>: A private member variable <code class="literal">Listeners</code> is declared using a <code class="literal">Dictionary</code> class. This structure maintains a hash-table array of key-value pairs, which can be looked up and searched like a database. The key-value pairing for the <code class="literal">EventManager</code> class takes the form of <code class="literal">EVENT_TYPE</code> and <code class="literal">List&lt;Component&gt;</code>. In short, this means that a list of event types can be stored (such as <code class="literal">HEALTH_CHANGE</code>), and for each type there could be none, one, or more components that are listening and which should be notified when the event occurs. In effect, the <code class="literal">Listeners</code> member is the primary data structure on which the <code class="literal">EventManager</code> relies to maintain who is listening for what. For more detailed<a id="id320" class="indexterm"/> information on the Mono Framework and common classes within it, refer to <a class="link" href="ch06.html" title="Chapter 6. Working with Mono">Chapter 6</a>, <em>Working with Mono</em>.</li><li class="listitem" style="list-style-type: disc"><strong>Lines 029-039</strong>: The <code class="literal">Awake</code> function is responsible for the singleton functionality, that is, to make the <code class="literal">EventManager</code> class into a singleton object that persists across scenes. For more information on persistent singletons, refer to <a class="link" href="ch03.html" title="Chapter 3. Singletons, Statics, GameObjects, and the World">Chapter 3</a>, <em>Singletons, Statics, GameObjects, and the World</em>.</li><li class="listitem" style="list-style-type: disc"><strong>Lines 046-063</strong>: The <code class="literal">AddListener</code> method of <code class="literal">EventManager</code> should be called by a <code class="literal">Listener</code> object once for each event for which it should listen. The method accepts two arguments: the event to listen for (<code class="literal">Event_Type</code>) and a reference to the listener object itself (derived from <code class="literal">IListener</code>), which should be <a id="id321" class="indexterm"/>notified if and when the event happens. The <code class="literal">AddListener</code> function is responsible for accessing the <code class="literal">Listeners</code> dictionary and generating a new key-value pair to store the connection between the event and the listener.</li><li class="listitem" style="list-style-type: disc"><strong>Lines 071-088</strong>: The <a id="id322" class="indexterm"/><code class="literal">PostNotification</code> function can be called by any object, whether a listener or not, whenever an event is detected. When called, the <code class="literal">EventManager</code> cycles all matching entries in the dictionary, searching for all listeners connected to the current event, and notifies them by invoking the <code class="literal">OnEvent</code> method through the <code class="literal">IListener</code> interface.</li><li class="listitem" style="list-style-type: disc"><strong>Lines 098-127</strong>: The final methods for the <code class="literal">EventManager</code> class are responsible for maintaining data integrity of the <code class="literal">Listeners</code> structure when a scene change occurs and the <code class="literal">EventManager</code> class persists. Although the <code class="literal">EventManager</code> class persists across scenes, the listener objects themselves in the <code class="literal">Listeners</code> variable may not do so. They may get destroyed on scene changes. If so, scene changes will invalidate some listeners, leaving the <code class="literal">EventManager</code> with invalid entries. Thus, the <code class="literal">RemoveRedundancies</code> method is called to find and eliminate all invalid entries. The <code class="literal">OnLevelWasLoaded</code> event is invoked automatically by Unity whenever a scene change occurs.</li></ul></div><div><div><h3 class="title"><a id="note22"/>Note</h3><p>
<strong>Dictionaries</strong>
</p><p>The great thing about<a id="id323" class="indexterm"/> dictionaries is not just their access speed as a dynamic array (which is comparatively fast) but also the way you work with them through object types and the array subscript operator. In a typical array, every element must be <a id="id324" class="indexterm"/>accessed by its numerical and integer index, such as <code class="literal">MyArray[0]</code> and <code class="literal">MyArray[1]</code>. But with dictionaries, the<a id="id325" class="indexterm"/> case is different. Specifically, you can access elements using objects of <code class="literal">EVENT_TYPE</code>, which represents the key part of the key-value pair, for example, <code class="literal">MyArray[EVENT_TYPE.HEALTH_CHANGE]</code>. For more information on dictionaries, see the<a id="id326" class="indexterm"/> official Microsoft documentation at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx">http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx</a>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec50"/>Code folding in MonoDevelop with #region and #endregion</h1></div></div></div><p>The two preprocessor <a id="id327" class="indexterm"/>directives <code class="literal">#region</code> and <code class="literal">#endregion</code> (in combination with the code folding feature) can be highly useful for improving the readability<a id="id328" class="indexterm"/> of your code and also for improving the speed<a id="id329" class="indexterm"/> with which<a id="id330" class="indexterm"/> you can navigate the source file. They add organization and structure to your source code without affecting its<a id="id331" class="indexterm"/> validity or execution. Effectively, <code class="literal">#region</code> marks the top of a code block and <code class="literal">#endregion</code> marks<a id="id332" class="indexterm"/> the end. Once a region is marked, it becomes foldable, that is, it becomes<a id="id333" class="indexterm"/> collapsible using the <code class="literal">MonoDevelop</code> code editor, provided the code folding feature is enabled. Collapsing a region of code is useful for hiding it from view, which allows you to concentrate on reading other areas relevant to your needs, as shown in the following screenshot:</p><div><img src="img/0655OT_04_01.jpg" alt="Code folding in MonoDevelop with #region and #endregion"/><div><p>Enabling code folding in MonoDevelop</p></div></div><div><div><h3 class="title"><a id="tip25"/>Tip</h3><p>To enable <a id="id334" class="indexterm"/>code folding in <code class="literal">MonoDevelop</code>, select <strong>Options</strong> in <strong>Tools</strong> from the application menu. This displays the <strong>Options</strong> window. From<a id="id335" class="indexterm"/> here, choose the <a id="id336" class="indexterm"/>
<strong>General</strong> tab in<a id="id337" class="indexterm"/> the <strong>Text Editor</strong> option and<a id="id338" class="indexterm"/> click on<a id="id339" class="indexterm"/> <strong>Enable code folding</strong> as well as <strong>Fold #regions by default</strong>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec27"/>Using EventManager</h2></div></div></div><p>Now, let's see how to put the <code class="literal">EventManager</code> class to work in a practical context from the perspective of listeners and posters in a single scene. First, to listen for an event (any event) a listener must<a id="id340" class="indexterm"/> register itself with the <code class="literal">EventManager</code> singleton instance. Typically, this will happen once and at the earliest opportunity, such as the <code class="literal">Start</code> function. Do not use the <code class="literal">Awake</code> function; this is reserved for an object's internal initialization as opposed to the functionality that reaches out beyond the <a id="id341" class="indexterm"/>current object to the states and setup of others. See the following code sample 4-6 and notice that it relies on the <code class="literal">Instance</code> static property to retrieve a reference to the active <code class="literal">EventManager</code> singleton:</p><div><pre class="programlisting">//Called at start-up
void Start()
{
//Add myself as listener for health change events
<strong>EventManager.Instance.AddListener(EVENT_TYPE.HEALTH_CHANGE, this);</strong>
}</pre></div><p>Having registered listeners for one or more events, objects can then post notifications to <code class="literal">EventManager</code> as<a id="id342" class="indexterm"/> events are detected, as shown in the <a id="id343" class="indexterm"/>following code sample 4-7:</p><div><pre class="programlisting">public int Health
{
get{return _health;}
set
{
   //Clamp health between 0-100
   _health = Mathf.Clamp(value, 0, 100);

   //Post notification - health has been changed <strong>EventManager.Instance.PostNotification(EVENT_TYPE.HEALTH_CHANGE, this, _health);</strong>
}
}</pre></div><p>Finally, after a notification is posted for an event, all the associated listeners are updated automatically through <code class="literal">EventManager</code>. Specifically, <code class="literal">EventManager</code> will call the <code class="literal">OnEvent</code> function of each listener, giving listeners the opportunity to parse event data and respond where needed, as shown in the following code sample 4-8:</p><div><pre class="programlisting">//Called when events happen
public void OnEvent(EVENT_TYPE Event_Type, Component Sender, object Param = null)
{
//Detect event type
switch(Event_Type)
{
    case EVENT_TYPE.HEALTH_CHANGE:
         OnHealthChange(Sender, (int)Param);
    break;
}
}</pre></div><div><div><h3 class="title"><a id="tip26"/>Tip</h3><p>For a demonstration on using <code class="literal">EventManager</code>, see the <code class="literal">events</code> folder project in the code bundle of this chapter.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec28"/>Alternative with delegates</h2></div></div></div><p>Interfaces are an efficient and trim way of implementing an event handling system, but they are not the only way. We can also use a C# feature, known as delegates. Essentially, we can create a function and store a<a id="id344" class="indexterm"/> reference to it inside a variable. This variable allows you to treat functions as a reference type variable. That is, with delegates, you<a id="id345" class="indexterm"/> can store references to functions, which can then be used later to invoke the function itself. Other languages, such as C++, offer a similar behavior through function pointers. By implementing the event system using delegates, we eliminate the need for interfaces. Consider the following code sample 4-7, which is an alternative implementation of <code class="literal">EventManager</code> using delegates. Relevant code changes are highlighted to help illustrate the differences between the interface and delegate implementations. Apart from minor changes to accommodate the delegate types, all other functions remained unchanged, as shown here:</p><div><pre class="programlisting">001 using UnityEngine;
002 using System.Collections;
003 using System.Collections.Generic;
004 //-----------------------------------------------------------
<strong>005 //Enum defining all possible game events</strong>
<strong>006 //More events should be added to the list</strong>
<strong>007 public enum EVENT_TYPE {GAME_INIT, </strong>
<strong>008       GAME_END,</strong>
<strong>009       AMMO_CHANGE,</strong>
<strong>010        HEALTH_CHANGE,</strong>
<strong>011        DEAD};</strong>
012 //-----------------------------------------------------------
013 //Singleton EventManager to send events to listeners
014 //Works with delegate implementations
015 public class EventManager : MonoBehaviour
016 {
017       #region C# properties
018 //-----------------------------------------------------------
019      //Public access to instance
020      public static EventManager Instance
021      {
022             get{return instance;}
023             set{}
024      }
025      #endregion
026 
027      #region variables
028      //Notifications Manager instance (singleton design pattern)
029      private static EventManager instance = null;
030 
031      // Declare a delegate type for events
<strong>032      public delegate void OnEvent(EVENT_TYPE Event_Type, Component Sender, object Param = null);</strong>

033 
034       //Array of listener objects
035       private Dictionary&lt;EVENT_TYPE, List&lt;<strong>OnEvent</strong>&gt;&gt; Listeners = new Dictionary&lt;EVENT_TYPE, List&lt;<strong>OnEvent</strong>&gt;&gt;();

036       #endregion
037 //-----------------------------------------------------------
038      #region methods
039      //Called at start-up to initialize
040      void Awake()
041      {
042            //If no instance exists, then assign this instance
043           if(instance == null)
044            {
045                   instance = this;
046                   DontDestroyOnLoad(gameObject); 
047            }
048            else
049                   DestroyImmediate(this);
050      }
051 //-----------------------------------------------------------
052      /// &lt;summary&gt;
053      /// Add listener-object to array of listeners
054      /// &lt;/summary&gt;
055      /// &lt;param name="Event_Type"&gt;Event to Listen for&lt;/param&gt;
056      /// &lt;param name="Listener"&gt;Object to listen for event&lt;/param&gt;
057     public void AddListener(EVENT_TYPE Event_Type, OnEvent Listener)

058     {
059             //List of listeners for this event
060             List&lt;<strong>OnEvent</strong>&gt; ListenList = null;
061 
062            // Check existing event. If one exists, add to list
063           if(Listeners.TryGetValue(Event_Type, out ListenList))
064            {
065                   //List exists, so add new item
066                   ListenList.Add(Listener);
067                   return;
068             }
069 
070            //Otherwise create new list as dictionary key
071            ListenList = new List&lt;OnEvent&gt;();
072            ListenList.Add(Listener);
073            Listeners.Add(Event_Type, ListenList); 
074      }
075 //-----------------------------------------------------------
076       /// &lt;summary&gt;
077       /// Function to post event to listeners
078       /// &lt;/summary&gt;
079       /// &lt;param name="Event_Type"&gt;Event to invoke&lt;/param&gt;
080       /// &lt;param name="Sender"&gt;Object invoking event&lt;/param&gt;
081       /// &lt;param name="Param"&gt;Optional argument&lt;/param&gt;
082       public void PostNotification(EVENT_TYPE Event_Type, Component Sender, object Param = null)

083       {
084             //Notify all listeners of an event
085 
086             //List of listeners for this event only
087             List&lt;<strong>OnEvent</strong>&gt; ListenList = null;
088 
089             //If no entry exists, then exit 
090            if(!Listeners.TryGetValue(Event_Type, out ListenList))
091                   return;
092 
093            //Entry exists. Now notify appropriate listeners
094            for(int i=0; i&lt;ListenList.Count; i++)
095             {
096                 if(!ListenList[i].Equals(null)) 
097                         <strong>ListenList[i](Event_Type, Sender, Param);</strong>
098            }
099      }
100 //-----------------------------------------------------------
101       //Remove event from dictionary, including all listeners
102       public void RemoveEvent(EVENT_TYPE Event_Type)
103       {
104            //Remove entry from dictionary
105            Listeners.Remove(Event_Type);
106       }
107 //-----------------------------------------------------------
108       //Remove all redundant entries from the Dictionary
109       public void RemoveRedundancies()
110       {
111             //Create new dictionary
112             Dictionary&lt;EVENT_TYPE, List&lt;OnEvent&gt;&gt; TmpListeners = new Dictionary&lt;EVENT_TYPE, List&lt;<strong>OnEvent</strong>&gt;&gt;();

113 
114            //Cycle through all dictionary entries
115            foreach(KeyValuePair&lt;EVENT_TYPE, List&lt;<strong>OnEvent</strong>&gt;&gt; Item in Listeners)

116            {
117                   //Cycle through all listeners
118                   for(int i = Item.Value.Count-1; i&gt;=0; i--)
119                   {
120                        //If null, then remove item
121                       if(Item.Value[i].Equals(null))
122                            Item.Value.RemoveAt(i);
123                   }
124 
125                  //If items remain, then add to tmp dictionary
126                  if(Item.Value.Count &gt; 0)
127                       TmpListeners.Add (Item.Key, Item.Value);
128            }
129 
130            //Replace listeners with new dictionary
131            Listeners = TmpListeners;
132      }
133 //-----------------------------------------------------------
134      //Called on scene change. Clean up dictionary
135      void OnLevelWasLoaded()
136      {
137              RemoveRedundancies();
138      }
139 //-----------------------------------------------------------
140       #endregion
141 }</pre></div><div><div><h3 class="title"><a id="tip27"/>Tip</h3><p>More information on <a id="id346" class="indexterm"/>C# delegates can be found in the Microsoft documentation at <a class="ulink" href="http://msdn.microsoft.com/en-gb/library/aa288459%28v=vs.71%29.aspx">http://msdn.microsoft.com/en-gb/library/aa288459%28v=vs.71%29.aspx</a>.</p></div></div><p>The following are<a id="id347" class="indexterm"/> the comments on the code sample 4-7:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Lines 005-011</strong>: Here, the event type enumeration has been shifted into the <code class="literal">EventManager</code> file from the original <code class="literal">IListener</code> class. Since the delegate implementation avoids the need for interfaces and for <code class="literal">IListener</code> specifically, the enumeration can be shifted to the manager source file.</li><li class="listitem" style="list-style-type: disc"><strong>Line 032</strong>: The public member <code class="literal">OnEvent</code> is declared as a delegate type. Notice that the declaration is hybrid insofar as it combines variable declaration style with a function prototype. This specifies the function prototype that may be assigned to the delegate variable; any function with that structure can be assigned from any class or any script file. Thus, the <code class="literal">OnEvent</code> function becomes a delegate type, and this is used in the next statement creating the internal dictionary.</li><li class="listitem" style="list-style-type: disc"><strong>Line 035</strong>: The<a id="id348" class="indexterm"/> private dictionary listeners is declared, and for each event type, an array of delegates (instead of interfaces) is stored; each delegate refers to a function that should be invoked when the event occurs.</li><li class="listitem" style="list-style-type: disc"><strong>Line 097</strong>: Critically, the<a id="id349" class="indexterm"/> <code class="literal">PostNotification</code> function is called on <code class="literal">EventManager</code> to invoke all the delegates (listener functions) when an event occurs. This happens at line 097 with the statement <code class="literal">ListenList[i](Event_Type, Sender, Param);</code>. This invokes the delegate just like a function, as shown in the following screenshot:<div><img src="img/0655OT_04_02.jpg" alt="Alternative with delegates"/><div><p>Exploring the EventManager projects</p></div></div></li></ul></div><p>The preceding screenshot shows the <code class="literal">EventManager</code> projects.</p><div><div><h3 class="title"><a id="tip28"/>Tip</h3><p>To see the <code class="literal">EventManager</code> delegate implementation in action, see the <code class="literal">events_delgateversion</code> folder project in code bundle of this chapter.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec29"/>MonoBehaviour events</h2></div></div></div><p>To close this chapter, let's consider some of the events Unity offers us already for working with event-driven programming. The <code class="literal">MonoBehaviour</code> class already exposes a wide range of events that are<a id="id350" class="indexterm"/> called automatically under <a id="id351" class="indexterm"/>specific conditions. These functions or events begin with the prefix <code class="literal">On</code> and include events such as <code class="literal">OnGUI</code>, <code class="literal">OnMouseEnter</code>, <code class="literal">OnMouseDown</code>, <code class="literal">OnParticleCollision</code>, and others. This section considers some details for common event types.</p><div><div><h3 class="title"><a id="tip29"/>Tip</h3><p>The full list of <code class="literal">MonoBehaviour</code> events <a id="id352" class="indexterm"/>can be found in the Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.html">http://docs.unity3d.com/ScriptReference/MonoBehaviour.html</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec30"/>Mouse and tap events</h2></div></div></div><p>One set of useful<a id="id353" class="indexterm"/> events is the mouse-input and touch-input set of events. These include<a id="id354" class="indexterm"/> <code class="literal">OnMouseDown</code>, <code class="literal">OnMouseEnter</code>, and <code class="literal">OnMouseExit</code>. In the earlier versions of Unity, these events were only triggered for mouse-specific events and not touch input. But more recently, touch input has been mapped to<a id="id355" class="indexterm"/> them; meaning that a tap will now<a id="id356" class="indexterm"/> register by default as a mouse event. To clarify, <code class="literal">OnMouseDown</code> is called once when a mouse button is pressed down while the cursor is hovering on an<a id="id357" class="indexterm"/> object. The event is not, however, called repeatedly until the button is released. Likewise, <code class="literal">OnMouseEnter</code> is called once when a cursor first hovers over an object without having exited and <code class="literal">OnMouseExit</code> is called when the cursor hovers away from an object it has previously entered. The success of these events depends on an object having a collider component attached to approximate its volume within which mouse events are detected. This means that none of the mouse events will fire without a collider attached to the object.</p><p>However, there are occasions when <code class="literal">MouseEvents</code> will not fire, even with a collider attached, because other objects (with colliders) are obscuring the objects you need to click on based on the current view from the active camera. That is, the clickable objects are in the background. You can, of course, solve the issue (at least in many cases) by simply assigning the foreground objects to an <code class="literal">IgnoreRaycast</code> layer making them immune from physics raycast operations.</p><p>To assign an object to an <code class="literal">IgnoreRaycast</code> layer, just select the object in the scene and then click on the <strong>Layer</strong> dropdown in the Object Inspector, assigning the object to the <strong>Ignore Raycast</strong> layer, as shown in the following screenshot:</p><div><img src="img/0655OT_04_03.jpg" alt="Mouse and tap events"/><div><p>Assigning objects to the Ignore Raycast layer</p></div></div><p>But even this just isn't feasible sometimes. Often you'll need multiple cameras and many objects with colliders, and they'll sometimes obscure objects you want to select or adjust according to mouse<a id="id358" class="indexterm"/>  input events. In these cases, you may need to manually handle mouse input events. The following code sample 4-8 achieves these,<a id="id359" class="indexterm"/> invoking specific mouse events manually on the basis of input. In essence, this code uses the <code class="literal">Raycast</code> system to redirect manually detected input events to the <code class="literal">MonoBehaviour</code> mouse events. This code uses<a id="id360" class="indexterm"/> <strong>Coroutines</strong> too; considered after the code sample:</p><div><pre class="programlisting">using UnityEngine;
 using System.Collections;
 //---------------------
 public class ManualMouse : MonoBehaviour
 {
    //---------------------
    //Get collider attached to this object
    private Collider Col = null;
    //---------------------
    //Awake function - called at start up
    void Awake()
    {
         //Get collider
         Col = GetComponent&lt;Collider&gt;();
    }
    //---------------------
    //Start Coroutine
    void Start()
    {
          StartCoroutine(UpdateMouse());
   }
   //---------------------
   public IEnumerator UpdateMouse()
   {
         //Are we being intersected
         bool bIntersected = false;
 
         //Is button down or up
         bool bButtonDown = false;
 
         //Loop forever
         while(true)
         {
         //Get mouse screen position in terms of X and Y
         //You may need to use a different camera Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
         RaycastHit hit;
 
               //Test ray for collision against this collider
               if (Col.Raycast(ray, out hit, Mathf.Infinity))
               {
   //Object was interesected  if(!bIntersected) SendMessage("OnMouseEnter", SendMessageOptions.DontRequireReceiver);
 
                       bIntersected = true;
 
               //Test for mouse events
               if(!bButtonDown &amp;&amp; Input.GetMouseButton(0))
{
bButtonDown = true; SendMessage("OnMouseDown", SendMessageOptions.DontRequireReceiver);
}

                if(bButtonDown &amp;&amp; !Input.GetMouseButton(0))
{
bButtonDown = false; SendMessage("OnMouseUp", SendMessageOptions.DontRequireReceiver);
}
                }
                else
                {
                      //Was previously entered and now leaving
                      if(bIntersected) SendMessage("OnMouseExit", SendMessageOptions.DontRequireReceiver);
 
                      bIntersected = false;
                      bButtonDown = false;
                }
 
                //Wait until next frame
                yield return null;
           }
    }
    //---------------------
 }
 //---------------------</pre></div><div><div><h3 class="title"><a id="note23"/>Note</h3><p>
<strong>Coroutines</strong>
</p><p>Coroutines are a special kind of function. They behave like threads insofar as they appear to run in<a id="id361" class="indexterm"/> parallel or asynchronously to the main game loop, that is, once you execute them, they seem to run in the background. Execution doesn't pause or wait until the function is completed as it does with traditional functions. This makes<a id="id362" class="indexterm"/> Coroutines great for creating asynchronous-looking behaviors. Technically, all Coroutines must return a type of <code class="literal">IEnumerator</code>, contain at least one yield statement in their body, and must<a id="id363" class="indexterm"/> be launched with the <code class="literal">StartCoroutine</code> function. The yield statement is a special statement that suspends execution of the Coroutine until its condition is met. The statement yield return new <code class="literal">WaitForSeconds(x)</code> will pause execution for <code class="literal">x</code> seconds, resuming after the interval at the next line. In contrast, the statement yield returned <code class="literal">null</code> will suspend execution for the current frame, resuming execution at the next line on the next frame. More information<a id="id364" class="indexterm"/> on Coroutines and their use can be found in the Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/Coroutines.html">http://docs.unity3d.com/Manual/Coroutines.html</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Application focus and pausing</h2></div></div></div><p>Three additional <code class="literal">MonoBehaviour</code> events are notable for causing confusion or surprise about their operation. They are: <code class="literal">OnApplicationPause</code>, <code class="literal">OnApplicationFocus</code>, and <code class="literal">OnApplicationQuit</code>.</p><p>
<code class="literal">OnApplicationQuit</code> is sent<a id="id365" class="indexterm"/> to all objects in the scene just before the game exits but<a id="id366" class="indexterm"/> before the scene and its<a id="id367" class="indexterm"/> contents are effectively destroyed. If the game is being tested in the editor, then <a id="id368" class="indexterm"/>
<code class="literal">OnApplicationQuit</code> is called when playback is stopped. Significantly, however, <code class="literal">OnApplicationQuit</code> may not be called for iOS devices, which usually don't quit or exit applications but rather suspend them while<a id="id369" class="indexterm"/> users do other things, which allows them to return and resume from where they left off. If you need or want to receive <code class="literal">OnApplicationQuit</code> events on suspension, you'll need to enable the relevant option from the <strong>Player Settings</strong> window. To access this, navigate to <strong>Edit</strong> | <strong>Project Settings</strong> | <strong>Player</strong> from the application menu and then from the Object Inspector, expand the <strong>Other Settings</strong> tab for the iOS builds and enable the <strong>Exit on Suspend</strong> checkbox, as shown in the following screenshot:</p><div><img src="img/0655OT_04_04.jpg" alt="Application focus and pausing"/><div><p>Enabling the exit on suspend option for iOS</p></div></div><p>
<code class="literal">OnApplicationFocus</code> is an event sent to all objects in the scene when the game loses focus, typically when the<a id="id370" class="indexterm"/> game window is deactivated on desktop computers during multitask operations. This can be a significant in-game <a id="id371" class="indexterm"/>event, especially for multiplayer games where action and events in a shared world continue, even when one or more of the players are not actively participating. In these cases, you may need to pause or resume specific behaviors or fade-in or fade-out game music.</p><p>
<code class="literal">OnApplicationPause</code> is an<a id="id372" class="indexterm"/> ambiguous event<a id="id373" class="indexterm"/> because the concept of a pause in Unity is not clearly defined. There<a id="id374" class="indexterm"/> are, I believe, two distinct kinds of pauses, namely, an ultimate and relative pause. The ultimate kind is where every activity and every event in a game is totally suspended; in this state, there is no passing of time and nothing can move forward. The relative kind, in contrast, is the most common. Here, the game is self-conscious or aware of being in a paused state; it halts some events, such as in-world events, but allows other events to continue such as GUI interaction and user input, which can unpause the game. The <code class="literal">OnApplicationPause</code> event refers to the first kind of pause and not the latter. This event will be called when several conditions are met. These are considered in the next sections.</p><p>First, <code class="literal">OnApplicationPause</code> will only be called on the desktop if the <strong>Run In Background</strong> option is not enabled in the <strong>Player Settings</strong> tab, under the <strong>Resolution</strong> group, as shown in the following screenshot. This option, when disabled, will automatically pause a desktop game whenever the window focus is lost. This means <code class="literal">OnApplicationPause</code> will follow an <code class="literal">OnApplicationFocus</code> event.</p><div><img src="img/0655OT_04_05.jpg" alt="Application focus and pausing"/><div><p>Disabling the Run In Background option</p></div></div><p>In iOS, <code class="literal">OnApplicationPause</code> <a id="id375" class="indexterm"/>will be called whenever the application is minimized or pushed into the background.</p><div><div><h3 class="title"><a id="tip30"/>Tip</h3><p>Do not rely on the <code class="literal">OnApplicationPause</code> event for creating your own relative pause functionality. To achieve this, use the <code class="literal">Time.timeScale</code> variable or code a more comprehensive system in which you have selective control over which elements are paused.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec51"/>Summary</h1></div></div></div><p>This chapter focused on the manifold benefits available for your applications by adopting an event-driven framework consistently through the <code class="literal">EventManager</code> class. In implementing such a manager, we were able to rely on either interfaces or delegates, and either method is powerful and extensible. Specifically, we saw how it's easy to add more and more functionality into an <code class="literal">Update</code> function but how doing this can lead to severe performance issues. Better is to analyze the connections between your functionality to refactor it into an event-driven framework. Essentially, events are the raw material of event-driven systems. They represent a necessary connection between one action (the cause) and another (the response). To manage events, we created the <code class="literal">EventManager</code> class—an integrated class or system that links posters to listeners. It receives notifications from posters about events as and when they happen and then immediately dispatches a function call to all listeners for the event. In the next chapter, we'll examine cameras and rendering.</p></div></body></html>