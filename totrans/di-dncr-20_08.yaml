- en: Patterns - Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml), *Interception*,
    we completed our journey in exploring the pillars of **Dependency Injection**
    (**DI**). Now, it's time to learn the principles behind Dependency Injection and
    explore how to apply different techniques to implement those principles to acquire
    a loosely coupled architecture. There are different techniques to implement DI,
    but if you are not choosing an appropriate one while you code, you will become
    a troublemaker for the project.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss different techniques, also known as **Patterns of
    Dependency Injection** with proper illustrations. I will shed light on use cases,
    and pros and the cons so that it will be easy for you to visualize the problems
    which you currently see in your application. That will eventually persuade you
    to adapt to these patterns in your app resulting in a better architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor Injection is the most important one among all these patterns. However,
    as developers, we should understand every available pattern. It's always recommended
    to use the best fit pattern for a particular scenario by analyzing the frequency
    and cases of using the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: While most of these patterns address some specific context, always remember
    Constructor Injection is the simplest and can be opted without any confusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics would be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Inversion Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inversion of Control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DI patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The proper way to implement patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pros and cons of each pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adoption and examples in .NET Core 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency Inversion Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The SOLID principles have a D in it, which is called the **Dependency Inversion
    Principle** (**DIP**). The following statement is by Robert C. Martin on DIP:'
  prefs: []
  type: TYPE_NORMAL
- en: '"High-level modules should not depend on low-level modules. Both should depend
    on abstractions."'
  prefs: []
  type: TYPE_NORMAL
- en: You can consider a High-level Module as a Business Module of one application
    comprising the complex logic of the application, and a Low-level Module as the
    classes that actually perform the basic or primary functions such as writing to
    disks, interaction with the database, and so on, with the commands received from
    the Business Module.
  prefs: []
  type: TYPE_NORMAL
- en: When objects of a High-level Module interact with objects of a Low-level Module,
    they generate a coupling. This happens because you have to refer to the classes
    of Low-level Modules in order to access them for instantiation. However, the DIP
    does not recommend this. The principle encourages us to reduce the coupling so
    that the modules live isolated. It also explains how this can be done through
    abstractions. Both should commit themselves to abstractions instead of directly
    depending on each other. Let's understand this point with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider one class called `FeedbackService` that is saving one `Feedback` details
    in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The principal method here is `SaveFeedback`, which not only saves the feedback
    but also sends a notification. It takes the `Feedback` object and notifies type
    as parameters. When feedback is saved, usually one notification is sent to the
    customer and admin.
  prefs: []
  type: TYPE_NORMAL
- en: '`FeedbackService` implements an interface which can be coded like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`INotifier` is an interface which is implemented by all the notifier types.
    Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that I have not defined the body of the methods since they are here in
    the book for illustration. You can write logic and implement yours.
  prefs: []
  type: TYPE_NORMAL
- en: Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The approach seems correct, but it is not recommended and does not respect
    software design principles which are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, we are violating the Single Responsibility Principle with this approach. `FeedbackService`
    is taking the responsibility to save a feedback as well as sending notifications
    after success.
  prefs: []
  type: TYPE_NORMAL
- en: Tight coupling exists with the concrete classes `Feedback` and other `Notifier`
    classes such as `EmailNotifier`, `SmsNotifier`, and `VoiceNotifier`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our most popular, the `new` keyword is used inside the `SendNotification` of
    the `FeedbackService` class to decide which `Notifier` instance to create according
    to the input `notify` of type `enum`, which can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The solution should address all the issues with the preceding approach, so that
    the resulting architecture becomes loosely coupled. Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing is to separate the responsibilities from the `FeedbackService`
    class. This can be easily be done by transferring the `SendNotification` responsibility
    to the notifier instead of having it inside the class.
  prefs: []
  type: TYPE_NORMAL
- en: So, we can inject the `INotifier` type dependency inside the constructor. Thus,
    we can do `_notifier.SendNotification()` to send an injected type notification.
    Also, we changed the signature of `SaveFeedback`, which now accepts the `IFeedback`
    type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '`FeedbackService` can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `Service` does not depend upon the concrete implementations, and we
    eliminated the `if...else...if` clumsy codes from the class to decide which notification
    to send. The decision of notification type is now with the composer of the `Service`
    class instance. That can be done inside the Composition Root, something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Inversion of Control (IoC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Inversion of Control** (**IoC**) is a Software Design Pattern which supports
    the **Dependency Inversion Principle** (**DIP**). There is a lot of confusion
    between these two terms, but if you closely observe, the names will clarify the
    doubts themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: The DIP is a principle or set of rules kind of theory. On the other hand, Inversion
    of Control is a pattern of well-defined steps we can follow to make our code DIP
    friendly. You have already experienced the steps of IoC, haven't you?
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the steps we followed to take away the control of object creations from
    the `FeedbackService` class to an external location, which can be considered as
    a Composition Root. We did the following to be precise:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduce interfaces for the concrete dependency: `INotifier` and `IFeedback`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update concrete dependencies to implement from interface: `EmailNotifier`, `SmsNotifier`,
    and `VoiceNotifier`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provide dependency to the constructor and store in a `private readonly `member:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the private member, we can call the method of the dependency class directly: 
    `_notifier.SendNotification(feedback);`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Instantiate `Service` with dependency in the Composition Root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`var feedbackService = new FeedbackService(new SmsNotifier());`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, someone else is now trying to manage the object creation and lifetime. Before
    we executed those steps, the class itself was instantiating all its dependencies
    inside it using the `new` keyword. Therefore, we inverted the controls, and flow
    of management of objects is done in reverse through someone else, isn't it! That's
    it, this is what IoC is trying to express.
  prefs: []
  type: TYPE_NORMAL
- en: The last step involves injecting the dependency object into the constructor
    of `Service`, and the pattern is known as the **Constructor Injection Pattern**.
    Let's explore this pattern with other important ones in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the diagram representing the DIP and non-DIP implementations.
    Notice the arrows. In non-DIP, dependencies are managed by the class itself so,
    arrows pointing to concrete class objects, whereas, in DIP, an arrow is coming
    into the class, as the dependency objects are sent by someone else:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6784d17-712d-41e5-a556-ff8a8142d1a6.png)'
  prefs: []
  type: TYPE_IMG
- en: When a class manages all its dependencies itself, it is regarded as a **Control
    Freak**, which is an anti-pattern. We will discuss more about this anti-pattern
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the four important patterns by which we can implement Dependency
    Injection:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor Injection Pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property Injection Pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method Injection Pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ambient Context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore one by one with illustrations, the advantages, and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor Injection pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, Injection will take the help of the constructor. In other
    words, the constructor is the target of injection. Injection is performed by supplying
    the dependency to the constructor as an argument. This is the most common technique
    to inject dependencies into classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client calls the constructor to create the object and during the instantiation,
    the dependency gets injected, which is depicted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/923d38e0-dcca-4797-a364-e90566508b8b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, a company, initially, was set up with only one department called
    Engineering. Let''s design the `Employee` class for this company as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a constructor which takes `id` and `name` as parameters and initialises
    an `Employee` object. As I told you, the company started only with Engineering
    as a department, so it''s obvious that we assign `EmployeeDept` with a new object
    of the `Engineering` class. `Engineering` and `Department` classes would look
    something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you foresee a complex issue in this design? What if the company grows and
    builds another department like marketing? How would we incorporate this new department
    into the `Employee` class? How to say a particular employee belongs to the marketing
    department?
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there is no way to do this here, as the `Employee` class is tightly
    coupled with the `Engineering` class. This not only leads to a bad design, but
    developers also face hurdles for unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: The solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what is the solution? We just need a `Department` object when we instantiate
    with `Employee`. How about providing the required type of `Department` (engineering/marketing)
    reference directly to the `Employee` class?
  prefs: []
  type: TYPE_NORMAL
- en: That's super easy. Let's have a look at the modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, design an interface `IDepartment` which can be implemented by the `Department`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Instead of having a property of `Department` type, now we will have that of
    type `IDepartment`. Basically, we can now allow different types of departments
    with this technique. We will see this in action in a while. Also, see how this
    property is initialized inside the constructor using the param `dept` of type
    `IDepartment`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now have a look at the classes for different departments. They inherit from
    `Department`, thereby implementing `IDepartment`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating employees with a different department is easy now. If we create such
    objects inside the `main` method, we can do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can see how a particular `Department` object is passed to the `Employee`
    constructor to create different employees who belong to different departments.
    That is the injection we did. We injected objects of type `IDepartment` (`Engineering`
    and `Marketing`) into the `Employee` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/192956cf-7f83-4a52-95ee-0a24461d5e0d.png)'
  prefs: []
  type: TYPE_IMG
- en: Curveball
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You must be thinking everything in the preceding was perfect. But it is not.
    Let''s analyze it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can see I created an object with employee department as `Engineering`. Then
    in the next line, we can easily change the department by assigning a `Marketing`
    object to it. This should be completely avoided.
  prefs: []
  type: TYPE_NORMAL
- en: To do that, the field must be marked as `private` and `readonly`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It's not strictly recommended, but we should definitely follow this so that
    developers can't unnecessary hijack the actual values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, the constructor does not handle the case where the dependent instance
    is received as `null`. The constructor can be altered as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now here is the important thing, the constructor not only does the job of pushing
    the dependent instance to a `private` property, but also inserts values to other
    member variables such as `EmployeeId` and `EmployeeName`. This is against the
    Single Responsibility Principle. Therefore, we should have the constructor only
    handling the dependency thing and nothing else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Also, writing like this would guarantee that when an object is created, it will
    contain the dependency within it. At the same time, this will be valued only if
    the class is fully dependent on the dependency henceforth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me summarise the points quickly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The class which is dependent must expose a `public` constructor where the dependency
    can be injected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If more than one dependency is required, then we can add more arguments to the
    constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dependent class should mark the member variable as `private readonly` where
    dependency instance will be assigned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dependent class constructor should only do the job of managing the dependency
    and nothing else
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting with .NET Core 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw every example previously, where we initialised using the `new` keyword.
    However, we should use the .NET Core 2.0 way of resolving the dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We use the `ServiceCollection` object to register the interfaces with the type
    we expect when it is resolved. When we do `serviceProvider.GetService();`, it
    returns an employee object with the department as `Engineering` since we registered
    `IDepartment` as `Engineering` in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation inside ASP.NET Core 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's have a closer look at ASP.NET Core 2.0 internal codes for `ControllerActivatorProvider.cs`
    inside `Microsoft.AspNetCore.Mvc.Core` `Controllers` to understand how Constructor
    Injection is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: ControllerActivatorProvider.cs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I will show a screenshot of the class where the constructor is written:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91b877ef-c090-4344-a6c7-592199f1c23f.png)'
  prefs: []
  type: TYPE_IMG
- en: '`IControllerActivator` is the dependency which is injected into the constructor
    of this class. Then, it is using the instance to do some operation inside the
    class. We can easily find more of such kind of examples in .NET Core 2.0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this dependency is resolved, we can check the method `AddMvcCoreServices` of
    the `MvcCoreServiceCollectionExtensions.cs` class inside the `Microsoft.AspNetCore.Mvc.Core`
    `DependencyInjection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84f0c2b9-30ec-40f1-8bbc-5edd42b9bdd4.png)'
  prefs: []
  type: TYPE_IMG
- en: Importance of the Constructor Injection pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the injection is tied to the constructor, this means whenever you try to
    instantiate a particular class, we are 100% sure that the dependency is shipped
    or tied with the object created. The guarantee of having the dependency is ensured
    by the Guard Clause, which verifies the dependency as not `null` before assigning
    that to the `private readonly` data member. Otherwise, the construction of class
    throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: There is no possibility of having one object of such class without injecting
    the dependency. Thus, the state of the object is always valid with no discrepancies.
    Unit testing with mocks becomes easy with this approach. Let's have a look at
    the pros and cons too.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of the Constructor Injection pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the most preferable way of respecting the concept of DI. Most DI containers
    target the constructors. It is also the most common and more widely used pattern
    for DI. The injected component can be used anywhere in the class because when
    you create the object, the injected dependency comes into the class automatically
    and stays in some variable.
  prefs: []
  type: TYPE_NORMAL
- en: Developers prefer this technique when classes require some external dependency
    to initiate all other operations. As a constructor is involved, an object becomes
    ready with the dependent object once it is instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of the Constructor Injection pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is not so easy to implement when the class contains many constructors.
    Moreover, when the number of dependencies increases for a class, updating the
    constructor each time is not a feasible task.
  prefs: []
  type: TYPE_NORMAL
- en: When you have a number of arguments for a constructor by adding the dependency
    ones with the existing ones, the class will look messy.
  prefs: []
  type: TYPE_NORMAL
- en: Property Injection pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this technique, instead of asking the constructor to support the injection,
    we will directly inject to the property of the class. Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts one property `EmployeeDept`, which can be injected
    directly with an `IDepartment` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f37e69e5-b4e1-40e3-8395-a2b7c24b106b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Employee` class without the constructor argument for `IDepartment` and
    a new setter property will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We just removed the `IDepartment` argument from the constructor because we
    are going to directly assign an `IDepartment` type object to the property `EmployeeDept`.
    This can be done while creating the `Employee` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Thus, by doing `emp.EmployeeDept = new Engineering();`, we are directly pushing
    the `Engineering` object into the property `EmployeeDept`. The same thing is done
    for `emp1` too.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this code won''t compile. We are missing something important here.
    Consider the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbb64f95-24c4-4dc0-bb7b-b52175be846e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The error is totally self-explanatory. We forgot to include the Getter block
    as we wanted to print the department name. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are good. When you run it, you will see the same output as we got in
    the case of Constructor Injection.
  prefs: []
  type: TYPE_NORMAL
- en: Property Injection is preferred when there is an optional dependency required
    for the class. What that means is, if you don't supply the value, the class won't
    mind as it can run without this dependency. If the developer forgets to assign
    the dependency, it should not affect the flow of the app.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in our example, if you don't do anything with the property `EmployeeDept`,
    the class will behave as usual as long as you are not reading the property. In
    the next section, I will tell you how to beautify the code because the code is
    not yet perfect.
  prefs: []
  type: TYPE_NORMAL
- en: Curveball
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The problems with the approach which we have taken can be any one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If you don't assign anything to the property (as we developers forget sometimes
    being lazy), the output won't return you anything when you print.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can assign null to the property as simply as `emp.EmployeeDept = null;`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you assign a dependency to a property, you can easily assign another dependency
    easily, which might be a problem. This might happen accidentally, however, it
    will create side effects for the whole system at some point in time. Imagine a
    situation where you initialized the property with engineering and then changed
    that to marketing, which is wrong.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To handle all these situations, we should introduce more protection to the
    property. Let''s do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Inside the setter, we check for `null` and throw an exception. Then, we again
    investigate whether it is already there and throw an `InvalidOperationException`.
    Likewise, in the Getter, we are assigning a default value as engineering when
    passed `null`. Thus, we guarded our property for all such difficult situations,
    as previously discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Property Injection is not supported by the .NET Core built-in DI or IoC Container
    out of the box. Also, there is no such plan to bring this into the default container
    as of now. You have to use an external container such as Autofac to support this
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of the Property Injection Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can see the following advantages of having a Setter Injection Pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: It does not require adding a new constructor or modifying an existing constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern comes in handy if the class has multiple dependencies of different
    types. Suppose there is a class which will use different types of logging such
    as logging, to text or logging to the database at the same time in different conditions,
    then having two setter properties where we can simply inject the required logger
    to do our task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of the Property Injection Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setters are not easy to identify in a particular design to inject some external
    dependency. Still, they are preferred in some situations. However, we should be
    careful while using the property which is injected because that might be `null`.
    There should be an extra check for `null`, everywhere where you want to use it.
    As we already discussed, protection must be provided to the property to avoid
    the inconsistent behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Property Injection is considered as bad practice in most of the cases because
    it hides the dependencies. When the class is instantiated, there is no guarantee
    that the dependency object will be available for the class to do any operation,
    unlike Constructor Injection, where the dependency makes its way through during
    instantiation itself.
  prefs: []
  type: TYPE_NORMAL
- en: Method Injection Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, we will inject the dependency into a method like we did
    in the case of the constructor. This comes in handy when we want different types
    of dependency in different methods of a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following diagram, which tells us about the `AssignDepartment(IDepartment)`
    method taking `IDepartment` as a dependency inside the `Employee` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '>![](img/c4d5974f-df2b-4a27-b678-d84fa27f333f.png)'
  prefs: []
  type: TYPE_NORMAL
- en: The client can create an object of the `Employee` class and then fire `AssignDepartment`
    with the appropriate implementation of `IDepartment`, so that dependency is provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how the `Employee` class can be coded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this particular scenario, we have a method `AssignDepartment`, which takes
    one `IDepartment` type argument and then assigns that to the property. An `Employee`
    object can be created accordingly. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It also produces the same output as what we have already seen.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is useful when we require some dependency, only for some particular
    operation in a method and not for the whole class. Sometimes, the situation demands
    a small change which might be an edge case. To accommodate a small change, the
    simplest way would be to create a method and do whatever you want inside that
    (using dependencies passed in as arguments) instead of touching the constructors
    or properties.
  prefs: []
  type: TYPE_NORMAL
- en: Curveball
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the case of Method Injection, by convention, we should also take care of
    null check to ensure that the dependency is available before using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Injecting with .NET Core 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we did in previous patterns, we will get the instance using the `GetService`
    method and then call the required method by injecting the dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing you will see is the following as the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/055312b3-271d-43f1-8df4-7710be1f7737.png)'
  prefs: []
  type: TYPE_IMG
- en: This happened because we have a constructor which is taking `integer` and `string`
    params. The provider is not aware of the process to resolve them, therefore, it
    throws an exception. The solution is to provide a default constructor, as the
    service provider is looking for it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Implementation inside .NET Core 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can get many instances of Method Injection Pattern usage inside the .NET
    Core 2.0\. One of them is inside the simplest and frequently used class `MvcServiceCollectionExtensions.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: MvcServiceCollectionExtensions.cs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `MvcServiceCollectionExtensions.cs` class contains the method `AddMvcCore`,
    which is an example of Method Injection. The following screenshot shows the method
    at a glance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ee3d342-6b6d-4060-8b90-980db41fb1f6.png)'
  prefs: []
  type: TYPE_IMG
- en: '`IServiceCollection` is injected into the `AddMvcCore` method. After it has
    been verified as not `null`, the service collection is processed further. I am
    only showing a screenshot of the relevant codes to understand the concept. You
    can definitely find such examples in other classes.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Interface Injection Pattern** is something which we have already discussed
    in other patterns, where we injected the implementations such as  `IDepartment`
    which is an interface, into the constructor, property or a method. It's recommended
    to inject the implementation instead of the concrete class to avoid tight coupling.
    Interface injection allows us to achieve loose coupling along with abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Ambient context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ambient is an adjective meaning completely surrounding or encompassing. This
    means when we say Ambient context, it denotes some context, which would pertain
    its existence and behavior in the background or surrounding.
  prefs: []
  type: TYPE_NORMAL
- en: When many classes require the same dependency, we should follow some technique
    to make it available to every such client.
  prefs: []
  type: TYPE_NORMAL
- en: The patterns we discussed are not appropriate for such a scenario. If you try
    to make this possible using Constructor Injection, for example, you would end
    up adding a constructor for every class, having the same dependency injected to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Sounds more like a Cross-cutting Concern, doesn't it? To achieve this, we can
    simply add a static accessor for the dependency. This will make sure that the
    dependency is reachable to all the clients demanding it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept can be visualized in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e94dcddc-982d-4c55-8bbb-3f7a0f95a6ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s consider an example to get a better understanding of the implementation.
    An abstract class `DepartmentProvider` can be designed to provide a static accessor
    called `Current`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We marked the class as `abstract` and there is a `virtual` property called `Department`,
    which will be accessed by any class requiring that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can use the `Current` property. The following code uses the
    class `MarketingProvider` instance which is a derived class of  `DepartmentProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'See how we can register `MarketingProvider` using the built-in DI container.
    Then we assigned that to the `Current` property by which we are able to get the
    value as marketing when we read `DepartmentProvider.Current.Department`. `MarketingProvider`
    is a child class of `DepartmentProvider`, which returns a `Marketing` object.
    Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So, we made a conclusion here. We can use the `static` property wherever we
    need inside the app and the value will be the same, unless you set it differently
    in-between.
  prefs: []
  type: TYPE_NORMAL
- en: Curveball
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A following are a few important points to remember while implementing an Ambient
    Context:'
  prefs: []
  type: TYPE_NORMAL
- en: This should be used only if it is really necessary. Constructor Injection or
    Property Injection should be the first choice before deciding to use Ambient Context.
    If you can't decide, just choose other DI patterns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Service Locator anti-pattern is quite similar to this pattern in the way
    it provides the dependency. However, there is a difference and that is Ambient
    Context supplies a single dependency, whereas Service Locator is responsible for
    providing all requested dependencies. We will discuss more on Service Locator
    in [Chapter 9](58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml), *Anti-Patterns and
    Misconceptions on Dependency Injection*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you don't correctly implement Ambient Context, it will have side effects.
    Suppose you initiate using one context or provider and during the process, you
    change it due to some reason. Now, when you read the value, it will provide you
    with the changed value instead of the first one because of static. That means
    you need to be very careful while implementing this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the implementation we discussed, you can easily set `null` to the `Current`
    property `DepartmentProvider.Current = null;`. Therefore, we have to protect it
    by using a guard clause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code represents a simple guard clause inside getter and setter
    blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We did a null check both in getter and setter and used a backup provider called
    `DefaultDepartmentProvider` to overcome the situation of mishandling the context.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation inside .NET Core 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `corefx` library has a  `CurrentPrincipal` `static` property inside the
    partial class `Thread` under  `System.Threading` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage can be seen in a method `Demand()` of the class `PrincipalPermission`
    under the namespace `System.Security.Permissions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18fdc3f9-c8d6-4b42-81ca-435b2c7dc3ff.png)'
  prefs: []
  type: TYPE_IMG
- en: The advantages of the Ambient Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ambient Context is definitely a savior when an app demands the same dependency
    multiple times during the app execution. It's very hard to realise the fact that
    while we write codes for injecting dependencies, there are many such instances
    of asking the same dependency repeatedly within the app. This is the time where
    we should take the help of the Ambient Context Pattern, and with just a simple
    `static` accessor, we will be able to get the dependency. This not only reduces
    code but also imposes the DRY principle.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantages of the Ambient Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ambient Context is not easy to implement and needs careful attention while using
    it. By just looking at a class, we can't tell whether it implements the Ambient
    Context Pattern or not. If the context changes in between execution, the outcome
    will be different, resulting in side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While implementing DI, we should definitely learn the techniques associated
    with it. These techniques, otherwise called DI patterns, play a vital role in
    the application architecture. So, deciding which pattern to use when is the most
    important factor in the case of injecting dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor Injection is the most widely used, is easy, and should always be
    your first choice. However, there are scenarios where you might opt for another
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: When you see there are multiple dependencies required for different operations
    of a class, choose the Method Injection Pattern as it allows you the flexibility
    to inject dependency as you require.
  prefs: []
  type: TYPE_NORMAL
- en: Another beautiful design case reveals itself while you land on a situation where
    you need certain dependency at many places in your app. It looks like a Cross-Cutting
    Concern, however, you expect a certain return type, which is the dependency. For
    that, you need to use Ambient Context and can't rely on interceptors. This is
    because you need the returned dependency to do some operation in your class.
  prefs: []
  type: TYPE_NORMAL
- en: Property Injection is something which allows you to inject optional dependency.
    This means it relies upon a Local Default for sure, otherwise, we might end up
    in an exception while requesting it.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml), *Anti-Patterns and
    Misconceptions on Dependency Injection*, we will explore bad practices while implementing
    DI, which are denoted as anti-patterns.
  prefs: []
  type: TYPE_NORMAL
