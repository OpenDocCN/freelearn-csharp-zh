- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data Access in ASP.NET Core (Part 1: Entity Framework Core Fundamentals)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18971_02.xhtml#_idTextAnchor068), we introduced a simple ASP.NET
    Core application to manage blog posts, which uses a static field to store the
    data in memory. In many real-world applications, the data is persisted in databases
    – such as SQL Server, MySQL, SQLite, PostgreSQL, and so on – so we will need to
    access the database to implement the CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about data access in ASP.NET Core. There are
    many ways to access the database in ASP.NET Core, such as through ADO.NET, Entity
    Framework Core, and Dapper, among others. In this chapter, we will focus on Entity
    Framework Core, which is the most popular **object-relational mapping** (**ORM**)
    framework in .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: '**Entity Framework Core**, or **EF Core** for short, is an open-source ORM
    framework that allows us to create and manage mapping configurations between the
    database schema and the object models. It provides a set of APIs to perform CRUD
    operations using LINQ methods, which is like operating the objects in memory.
    EF Core supports many database providers, such as SQL Server, SQLite, PostgreSQL,
    MySQL, and so on. It also supports many other features, such as migrations, change
    tracking, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why use ORM?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the DbContext class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing CRUD controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic LINQ queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the mapping between models and database tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to use EF Core to access the database
    in ASP.NET Core applications and perform basic CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code example in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter5/](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter5/).
    You can use VS 2022 or VS Code to open the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are expected to have basic knowledge of SQL queries and LINQ. If you are
    not familiar with them, you can refer to the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL queries: [https://www.w3schools.com/sql/](https://www.w3schools.com/sql/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LINQ: [https://learn.microsoft.com/en-us/dotnet/csharp/linq/](https://learn.microsoft.com/en-us/dotnet/csharp/linq/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why use ORM?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To operate the data in relational databases, we need to write SQL statements.
    However, SQL statements are not easy to maintain and are not type-safe. Every
    time you update the database schema, you need to update the SQL statements as
    well, which is error-prone. In many traditional applications, the logic is tightly
    coupled with the database. For example, the logic could be defined in a SQL database
    directly, such as stored procedures, triggers, and so on. This makes the application
    hard to maintain and extend.
  prefs: []
  type: TYPE_NORMAL
- en: ORM helps us to map the database schema to the object model, so we can operate
    the data in the database just like we operate the objects in memory. ORM can translate
    the CRUD operations to SQL statements, which means it is like an abstract layer
    between the application and the database. The data access logic is decoupled from
    the database, so we can easily change the database without changing the code.
    Also, it provides strong type safety, so we can avoid runtime errors caused by
    type mismatch.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that we are not saying that ORM is the best solution for all scenarios.
    Sometimes, we need to write SQL statements directly to achieve the best performance.
    For example, if we need to generate a complex data report, we may need to write
    SQL statements to optimize the performance of the query. However, for most scenarios,
    ORM provides more benefits than drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ORM frameworks in .NET. In this book, we will use EF Core, which
    is the most popular ORM framework in .NET Core. The following are the reasons
    why we chose EF Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Open-source**: EF Core is an open-source project and is mainly maintained
    by Microsoft, so it is well-supported. The contribution is also very active.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple database support**: EF Core supports many database providers, such
    as SQL Server, SQLite, PostgreSQL, MySQL and so on. Developers can use the same
    APIs to access different databases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Migration**: EF Core supports database migrations, which allows us to update
    the database schema easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LINQ support**: EF Core provides support for LINQ, which allows us to use
    a familiar syntax to query the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code-first approach**: EF Core supports the code-first approach, which means
    we can define the database schema using C# code, and EF Core will generate the
    database schema automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: EF Core is designed to be lightweight and performant. It supports
    query caching and lazy loading to help improve performance. Also, EF Core provides
    asynchronous APIs, which allows us to perform database operations asynchronously
    to improve the scalability of the application. In addition, EF Core supports raw
    SQL queries, enabling us to write SQL statements directly to achieve the best
    performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, EF Core is a good choice for most scenarios if you are using .NET Core.
    So, in this book, we will be using EF Core as the ORM framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the .NET Core CLI to perform EF Core-related tasks, we first need to
    install the `dotnet-ef` tool. You can install it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is recommended to install the tool as a global tool, so you can use it in
    any project for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new web API project using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, navigate to the project folder and run the following command to install
    EF Core packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first package is the database provider, which is used to connect the application
    to a SQL Server database. For this demo application, we will use **LocalDB**,
    which is a lightweight version of SQL Server. The second package contains shared
    design-time components for EF Core tools, which are required to perform database
    migrations.
  prefs: []
  type: TYPE_NORMAL
- en: What is LocalDB?
  prefs: []
  type: TYPE_NORMAL
- en: LocalDB is designed to be used as a substitute for the full version of SQL Server;
    it is suitable for development and testing, but not for production use. We can
    use LocalDB for development and replace the connection string when we deploy the
    application to production. LocalDB is installed with VS 2022\. If you do not have
    VS 2022 by default, you can find the installation package at [https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb](https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb).
  prefs: []
  type: TYPE_NORMAL
- en: LocalDB is supported by Windows only. If you use macOS or Linux, you can use
    SQLite instead of LocalDB, or use a Docker container to run SQL Server. For more
    information about SQLite, please refer to [https://docs.microsoft.com/en-us/ef/core/providers/sqlite/](https://docs.microsoft.com/en-us/ef/core/providers/sqlite/).
  prefs: []
  type: TYPE_NORMAL
- en: For more information about SQL Server on Docker, please refer to [https://learn.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker](https://learn.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker).
    Note that there are many other database providers, such as SQLite, PostgreSQL,
    MySQL, and so on. You can find the full list of database providers at [https://docs.microsoft.com/en-us/ef/core/providers/](https://docs.microsoft.com/en-us/ef/core/providers/).
    Some providers are not maintained by Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s explore how to use EF Core to access the database.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the DbContext class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To represent the database, EF Core uses the `DbContext` class, which allows
    us to query and save data. An instance of the `DbContext` class maintains the
    database connection and maps the database schema to the object model. It also
    tracks the changes in objects and manages the transactions. If you are familiar
    with OOP, you can think of the `DbContext` class as a bridge between the database
    and the object model, just like an interface. When you query or save data, you
    operate the objects through the `DbContext` class, and EF Core will translate
    the operations to the corresponding SQL statements.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will develop a simple application to manage invoices. This
    application will be used to demonstrate how to use EF Core to access the database,
    including how to define the database schema, how to perform CRUD operations, and
    how to use migrations to update the database schema.
  prefs: []
  type: TYPE_NORMAL
- en: You can follow [*Chapter 1*](B18971_01.xhtml#_idTextAnchor012) to define the
    API contract first. The API contract defines the endpoints and the request/response
    models. When we define the API contract, note that we need to consult stakeholders
    to understand the requirements. For example, we need to know the fields of the
    invoice, the data types of the fields, and so on. We also need to understand the
    business rules, such as *the invoice number should be unique*, and *the invoice
    amount should be greater than 0*, for example. That means we will spend lots of
    time on the API design phase. Here, we assume that we have already defined the
    API contract, and we can start to develop the application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to define the models. A model, also known as an entity, is
    a class that represents an object in the real world, which will be mapped to a
    table (or multiple tables) in the database. In this demo application, we need
    to define the `Invoice` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'An invoice can be defined as the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`InvoiceStatus` is a custom enum type, which is defined as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can create a file named `Invoice.cs` in the `Models` folder and copy the
    `Invoice` class code into the file.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We use the `Guid` type for the `Id` property, which is the unique identifier
    for the invoice. You can also use `int` or `long` as the identifier. Either way
    has its pros and cons. For example, `int` is more efficient than `Guid`, but it
    is not unique across databases. When the database grows, you may need to split
    the data into multiple databases, which means the `int` identifier may not be
    unique anymore. On the other hand, `Guid` is unique no matter how many databases
    you have, but it is more expensive to store, insert, query, and sort the records
    than using `int` or `long`. The `Guid` primary key with the cluster index may
    cause poor performance in some scenarios. In this demo application, we use `Guid`
    as the identifier for now. We will discuss more about the techniques to optimize
    the application performance in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We also use the `DateTimeOffset` type for the `InvoiceDate` and `DueDate` properties,
    which is the recommended type for date and time in .NET Core. You can also use
    the `DateTime` type if you do not care about the time zone. `DateTimeOffset` includes
    a time zone offset from UTC time, and it is supported by both .NET type and SQL
    Server. This is helpful if you want to avoid the time zone issues.
  prefs: []
  type: TYPE_NORMAL
- en: We may need more properties in the future, such as contact information, invoice
    items, and so on, but we will add them later. Let’s focus on only the model for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and configuring the DbContext class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will create a `DbContext` class to represent the database. Create
    a file named `InvoiceDbContext.cs` in the `Data` folder and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Inherited the `DbContext` class and defined the `InvoiceDbContext` class, which
    represents the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defined the `Invoices` property, which is a `DbSet<Invoice>` type. It is used
    to represent the `Invoices` table in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Why we do not use `public DbSet<Invoice> Invoices { get; set; }` here? The reason
    is that if the `DbSet<T>` properties are not initialized, the compiler will emit
    warnings from them because the nullable reference type feature is enabled by default.
    So we can use a `Set<TEntity>()` method to initialize the property to eliminate
    the warning. Another way to fix that is to use the null-forgiving operator, `!`,
    which forces the silencing of the compiler warnings. The `DbContext` base constructor
    will initialize the `DbSet<T>` properties for us, so it is safe to use `!` for
    this case. If you do not mind seeing the warnings, using `public DbSet<Invoice>
    Invoices { get; set; }` also works. You can use either method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s configure the database connection string. Open the `appsettings.json`
    file and add the following code to the `ConnectionStrings` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can use other databases, such as SQLite or PostgreSQL, but you need to install
    the corresponding database provider and change the connection string accordingly.
    To learn more about connection strings, please refer to [https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/connection-string-syntax](https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/connection-string-syntax).
    There is a website called [https://connectionstrings.com/](https://connectionstrings.com/)
    that can generate connection strings for different database providers.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding connection string, we use `Server=(localdb)\\mssqllocaldb`
    to specify the server as a LocalDB instance, and `Database=BasicEfCoreDemoDb`
    to specify the name of the database. You can change the database name to whatever
    you want. The `Trusted_Connection=True` option specifies that the connection is
    trusted, which means you do not need to provide the username and password. The
    `MultipleActiveResultSets=true` option specifies that the connection can have
    `Include()` method in EF Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Program.cs` file and add the following code after `builder` is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code registers the `InvoiceDbContext` class to the dependency
    injection container. The `AddDbContext<TContext>()` method is an extension method
    that accepts a `DbContextOptionsBuilder` parameter, which calls the `UseSqlServer()`
    method to configure the database provider to use SQL Server or LocalDB. Note that
    we use the `UseSqlServer()` method for both SQL Server and LocalDB. The difference
    is that LocalDB has a `(localdb)\\mssqllocaldb` server name by default. We also
    pass the database connection string to the `UseSqlServer()` method, which should
    be the same as the name we defined in the `appsettings.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, this code just registers the `InvoiceDbContext` class to the dependency
    injection container, but we have not created the database yet. Next, we will create
    the database using the `dotnet` `ef` command.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have defined the `InvoiceDbContext` class, and the instance of `InvoiceDbContext`
    is added to the dependency injection container. Next, we need to create the database
    and the `Invoices` table before we can use it. To create the database and the
    `Invoices` table, we need to run the following command to apply the database migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `InitialDb` parameter is the migration name. You can use any name you like
    as long as it is a valid C# identifier. It is recommended to use a meaningful
    name, such as `InitialDb`, `AddInvoiceTable`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command creates a couple of migration files, such as `<timestamp>_InitialDb.cs`
    and `<timestamp>_InitialDb.Designer.cs`, which are stored in the `Migrations`
    folder. The `<timestamp>_InitialDb.cs` migration file contains an `Up()` method
    to create the database and the tables. It also has a `Down()` method to roll back
    the changes. Note that this command does not create the database; it just creates
    the migration files. Please do not manually modify or delete the migration files
    as they are required to apply or roll back the database changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample of the migration files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Up()` method creates the table, columns, and constraints.
    The `Down()` method drops the table. You can use `dotnet ef migrations remove`
    to remove the migration files.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'You may see a warning message like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microsoft.EntityFrameworkCore.Model.Validation[30000]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**No store type was specified for the decimal property ‘Amount’ on entity type
    ‘Invoice’. This will cause > values to be silently truncated if they do not fit
    in the default precision and scale. Explicitly > specify the SQL server column
    type that can accommodate all the values in ‘OnModelCreating’ using > ‘HasColumnType’,
    specify precision and scale using ‘HasPrecision’, or configure a value converter
    using > ‘****HasConversion’.**'
  prefs: []
  type: TYPE_NORMAL
- en: This is because we did not specify the precision and scale for the `Amount`
    property. We will fix it later. Currently, EF Core will use the default precision
    and scale for the `decimal` type, which is `decimal(18,2)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The migration file has been created, but it has not been applied to the database
    yet. Next, run the following command to create the database and the `Invoices`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If the command is successful, we should find the database file in your user
    folder, such as `C:\Users\{username}\BasicEfCoreDemoDb.mdf` if you use Windows.
    You can use `%USERPROFILE%` to get the user folder path.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'You may encounter an error `System.Globalization.CultureNotFoundException`:
    Only the invariant culture is supported in globalizati[on-invarian](https://aka)t
    mode. See https://aka`.ms/GlobalizationInvariantMode` for more information. `(Parameter
    ''name'')`. This is because starting in .NET 6, the globalization invariant mode
    is enabled by default. You can disable it by setting the `InvariantGlobalization`
    property to `false` in the `csproj` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several tools you can use to open the LocalDB database file – for
    example, **SQL Server Management Studio** (**SSMS**), which is supported by Microsoft.
    Yo[u can downloa](https://learn)d it here: [https://learn.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms](https://learn.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms).
    You can also use other [tools, such as](https://dbeaver) Dbeaver ([https://dbeaver.io/](https://dbeaver.io/)),
    a free, universal database tool, [or JetBrai](https://www)ns DataGrip ([https://www.jetbrains.com/datagrip/](https://www.jetbrains.com/datagrip/)),
    a powerful database IDE. We’ll be using SSMS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the database file in SSMS, and you will see that the `BasicEfCoreDemoDb`
    database has been created. It will have two tables – `Invoices` and `__EFMigrationsHistory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The database created by EF Core migration](img/B18971_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The database created by EF Core migration
  prefs: []
  type: TYPE_NORMAL
- en: The `__EFMigrationsHistory` table is used to track the migrations. It is created
    automatically by EF Core. Do not manually modify it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created the database and the `Invoices` table. Next,let’s add
    some seed data to the table.
  prefs: []
  type: TYPE_NORMAL
- en: Adding seed data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `InvoiceDbContext.cs` file and add the following code to the `OnModelCreating()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to create a new database migration to apply the changes to the database.
    Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you check the database in SSMS, you will see that the seed data is added
    to the `Invoices` table.
  prefs: []
  type: TYPE_NORMAL
- en: The data is ready. Next, we will create the controllers to handle the HTTP requests
    and operate the data with the database.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing CRUD controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement the controllers to handle the HTTP requests,
    which are the `GET`, `POST`, `PUT`, and `DELETE` operations that are used to retrieve,
    create, update, and delete data, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have installed the `dotnet aspnet-codegenerator` tool following [*Chapter
    2*](B18971_02.xhtml#_idTextAnchor068), you can use the following command to create
    a controller with the specific `DbContext`. Do not forget to install the `Microsoft.VisualStudio.Web.CodeGeneration.Design`
    NuGet package, which is required by the `dotnet` `aspnet-codegenerator` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command has some parameters as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-name`: The name of the controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-api`: Indicates that the controller is an API controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-outDir`: The output directory of the controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--model`: The model class name. In this case, it is the `Invoice` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--dataContext`: The `DbContext` class name. In this case, it is the `InvoiceDbContext`
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-async`: Indicates that the actions of the controller are asynchronous.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information about the `dotnet` [`aspnet-codeg`](https://learn)`enerator`
    tool, see [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/tools/dotnet-aspnet-codegenerator](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/tools/dotnet-aspnet-codegenerator).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dotnet aspnet-codegenerator` tool will create a controller with the following
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is so easy! The `dotnet aspnet-codegenerator` tool has generated the controller
    with basic CRUD operations. You can run the application and test the API endpoints
    with the Swagger UI. We will explain the code of the controller in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How controllers work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18971_02.xhtml#_idTextAnchor068) and[*Chapter 3*](B18971_03.xhtml#_idTextAnchor130),
    we introduced how HTTP requests are mapped to the controller actions. In this
    chapter, we focus on data access and database operations.
  prefs: []
  type: TYPE_NORMAL
- en: First, we use DI to inject the `InvoiceDbContext` instance into the controller,
    which handles the database operations. As developers, normally, we do not need
    to worry about the database connection. `InvoiceDbContext` is registered as scoped,
    which means that each HTTP request will create a new `InvoiceDbContext` instance,
    and the instance will be disposed of after the request is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Once we get the `InvoiceDbContext` instance, we can use the `DbSet` property
    to access the entity set. The `DbSet<Invoice>` property represents a collection
    of the `Invoice` model class, which is mapped to the `Invoices` table in the database.
    We can use `FindAsync()`, `Add()`, `Remove()`, and `Update()`, to retrieve, add,
    remove, and update the entity in the database, respectively. The `SaveChangesAsync()`
    method is used to save the changes to the database. In this way, we operate the
    database through .NET objects, which is much easier than using SQL statements.
    That is the power of ORMs.
  prefs: []
  type: TYPE_NORMAL
- en: What is LINQ?
  prefs: []
  type: TYPE_NORMAL
- en: '**Language-Integrated Query** (**LINQ**) is a set of features in .NET that
    provide a consistent and expressive way to query and manipulate data from various
    data sources, such as a database, XML, and in-memory collections. With LINQ, you
    can write queries in a declarative way, which is much easier than using SQL statements.
    We will show you some basic LINQ queries in the next section. [For more info](https://lear)rmation
    about LINQ, see [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the generated SQL statements. Use `dotnet run` to start the
    application and test the `api/Invoices` API endpoint with the Swagger UI or any
    tool you like. You can see the following SQL statements in the **Debug** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The logs are helpful for understanding the SQL statements generated by EF Core.
    EF Core executes the SQL query and then maps the result to the models. It significantly
    simplifies data access and database operations.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us learn how to query data using LINQ in controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Basic LINQ queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This book is not intended to be a LINQ handbook. However, we will show you
    some basic LINQ queries in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Querying the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paging the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `DbSet<Invoice> Invoices` property in the `InvoiceDbContext` class represents
    a collection of the `Invoice` entity. We can use LINQ methods to query the data.
    For example, we can use the `ToListAsync()` method to retrieve all the invoices
    from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That is how the `GetInvoices` action method works.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find a specific invoice, we can use the `FindAsync()` method, as shown in
    the `GetInvoice()` action method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FindAsync()` method accepts the primary key value as the parameter. EF
    Core will translate the `FindAsync()` method to the SQL `SELECT` statement, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use `Single()` or `SingleOrDefault()` methods to find a specific
    entity. For example, we can use the `SingleAsync()` method to find the invoice
    with the specified ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that we use `SingleAsync()` instead of `Single()` in the code.
    Many methods of EF Core have both synchronous and asynchronous versions. The asynchronous
    versions are suffixed with `Async`. It is recommended to use the asynchronous
    versions in the controller actions because they are non-blocking and can improve
    the performance of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have LINQ experience, you may know there are other methods – such as
    `First()`, `FirstOrDefault()`, and so on – that can be used to find a specific
    entity. The differences are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Find()` or `FindAsync()` is used to find an entity by the primary key value.
    If the entity is not found, it returns `null`. Note that these two methods are
    related to the tracking state of the entity. If the entity is already tracked
    by `DbContext`, the `Find()` and `FindAsync()` methods will return the tracked
    entity immediately without querying the database. Otherwise, they will execute
    the SQL `SELECT` statement to retrieve the entity from the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Single()` or `SingleAsync()` can accept a predicate as the parameter. It returns
    the *single* entity that satisfies the predicate and throws an exception if the
    entity is not found or more than one entity satisfies the condition. If it is
    called without a predicate, it returns the only entity of the collection and throws
    an exception if more than one entity exists in the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SingleOrDefault()` or `SingleOrDefaultAsync()` can accept a predicate as the
    parameter. It also returns the *single* entity that satisfies the predicate and
    throws an exception if more than one entity satisfies the condition but returns
    a default value if the entity is not found. If it is called without a predicate,
    it returns a default value (or a specified default value) if the collection is
    empty and throws an exception if more than one entity exists in the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`First()` or `FirstAsync()` can accept a predicate as the parameter. It returns
    the *first* entity that satisfies the predicate and throws an exception if the
    entity is not found or the collection is null or empty. If it is called without
    a predicate, it returns the first entity of the collection and throws an exception
    if the collection is null or empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FirstOrDefault()` or `FirstOrDefaultAsync()` can accept a predicate as the
    parameter. It also returns the *first* entity that satisfies the predicate. If
    the entity is not found or the collection is empty, it returns a default value
    (or a specified default value). If it is called without a predicate, it returns
    the first entity if the collection is not empty; otherwise, it returns a default
    value (or a specified default value). If the collection is null, it throws an
    exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These methods are kind of confusing. The recommended practice is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to find an entity by the primary key value and leverage the tracking
    state to improve the performance, use `Find()` or `FindAsync()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are sure that the entity exists and only one entity satisfies the condition,
    use `Single()` or `SingleAsync()`. If you would like to specify a default value
    when the entity is not found, use `SingleOrDefault()` or `SingleOrDefaultAsync()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are not sure whether the entity exists, or there may be more than one
    entity that satisfies the condition, use `First()` or `FirstAsync()`. If you would
    like to specify a default value when the entity is not found, use `FirstOrDefault()`
    or `FirstOrDefaultAsync()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not forget to check whether the result is `null` if you use `Find()`, `FindAsync()`,
    `SingleOrDefault()`, `SingleOrDefaultAsync()`, `FirstOrDefault()`, and `FirstOrDefaultAsync()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the table contains a lot of records, we may want to filter the data based
    on some conditions, instead of returning all of them. We can use the `Where()`
    method to filter the invoices by status. Update the `GetInvoices` action method
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `Where()` method accepts a lambda expression as the parameter. A lambda
    expression is a concise way to define a delegate method inline, which is widely
    used in LINQ queries to define filtering, sorting, and projection operations.
    In the preceding example, the `x => status == null || x.Status == status` lambda
    expression means that the `Status` property of the `Invoice` entity is equal to
    the `status` parameter if the `status` parameter is not `null`. EF Core will translate
    the lambda expression to the SQL `WHERE` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application and check the Swagger UI. You will find the `/api/Invoices`
    endpoint now has a `status` parameter. You can use the parameter to filter the
    invoices by status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Filtering the invoices by status](img/B18971_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Filtering the invoices by status
  prefs: []
  type: TYPE_NORMAL
- en: 'Send a request with a status parameter to the `/api/Invoices` endpoint. You
    will get the invoices with the specified status. The SQL query is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the `Where()` method is translated to the SQL `WHERE` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and paging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is not always enough to filter the data. We may also want to sort the data
    based on some properties and return a subset of the data using paging. We can
    use some methods, such as `OrderBy()`, `OrderByDescending()`, `Skip()`, `Take()`,
    and so on, to sort and page the data. Update the `GetInvoices` action method as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the `AsQueryable()` method to convert the `DbSet<Invoice>`
    to `IQueryable<Invoice>`. We can use `IQueryable` to build a query. The `Where()`
    and `OrderByDescending()` methods return a new `IQueryable` object. So, we can
    chain the LINQ methods to build a new query. The `Where()` method is used to filter
    the data, the `OrderByDescending()` method is used to sort the data based on the
    `InvoiceDate` property in descending order, and the `Skip()` and `Take()` methods
    are used to page the data. The `Skip()` method skips the first `pageSize * (page
    - 1)` records, and the `Take()` method returns the next `pageSize` records. At
    the end of the statement, the `ToListAsync()` method executes the query and returns
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the `AsQueryable()` method is not required here because the `DbSet<TEntity>`
    class implements the `IQueryble<TEntity>` interface, which means the `DbSet<Invoice>`
    property is already an `IQueryable` object. We can chain the LINQ methods directly.
  prefs: []
  type: TYPE_NORMAL
- en: What is IQueryable?
  prefs: []
  type: TYPE_NORMAL
- en: When we use some LINQ methods, such as `Where()`, `OrderBy()`, `Skip()`, and
    `Take()`, EF Core will not execute the query immediately. It will build a query
    and return a new `IQueryable` object. `IQueryable` is an interface in the `System.Linq`
    namespace that represents a queryable collection of entities that can be used
    to compose a query against a specific data source, such as a database. It allows
    us to build complex queries by chaining the LINQ methods, but it postpones the
    query execution until the very last moment when the result is needed. Generally,
    when we call the `ToListAsync()` method, the query will be translated to a server-specific
    query language, such as SQL, and executed against the database. This can improve
    the performance of the application because we do not need to fetch all the data
    from the database before we can filter and sort the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `dotnet run` and check the Swagger UI, you will see
    the `page` and `pageSize` parameters are added to the `/api/Invoices` endpoint.
    You can use the parameters to page the invoices as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Sorting and paging the invoices](img/B18971_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Sorting and paging the invoices
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated SQL query is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that the SQL statement uses the `OFFSET/FETCH` clause to page the data.
    These keywords are supported by SQL Server but may not be supported by other databases.
    For example, MySQL uses the `LIMIT` clause to page the data. EF Core can eliminate
    the differences between different databases. It will translate the LINQ query
    to the correct SQL statement for the database. In this way, developers can focus
    on writing the LINQ query in a database-agnostic way. That is the beauty of EF
    Core.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an entity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let’s see how to create a new invoice. Check the code of the `PostInvoice`
    action method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '}The `PostInvoice` action method accepts an `Invoice` object as the request
    body. It uses the `Add()` method to add the invoice to the `Invoices` entity set.
    Note that this change occurs in the memory. The data will not be added to the
    database until the `SaveChangesAsync()` method is called to save the changes to
    the database. The `CreatedAtAction()` method returns a `201 Created` response
    with the location of the newly created invoice. You can return a `200 OK` response
    instead but it is recommended to return a `201 Created` response for the creation
    of a new resource.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can send a `POST` request to the `/api/invoices` endpoint to create a new
    invoice and see how the SQL statement is generated from the logs. It should be
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The JSON body for the `POST` action does not need to contain the `Id` property.
    EF Core will generate a new `Guid` value for the `Id` property.
  prefs: []
  type: TYPE_NORMAL
- en: Updating an entity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To update an entity, we use the `Put` request. The code of the `PutInvoice`
    action method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `PutInvoice` action method accepts the `id` parameter and the `Invoice`
    object as the request body. If you check the Swagger UI, you will see the `id`
    parameter is defined in the URL but the `Invoice` object is defined in the request
    body. This is because `Invoice` is not a primitive type, so ASP.NET Core can only
    get it from the request body. We discussed this in the *Binding source attributes*
    section in [*Chapter 3*](B18971_03.xhtml#_idTextAnchor130).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the `_context.Entry()` method to get the `EntityEntry` object of
    the invoice. Then, we set the `State` property to `EntityState.Modified`. It seems
    that the `EntityState` enum plays an important role here. What is the `EntityState`
    enum?
  prefs: []
  type: TYPE_NORMAL
- en: In EF Core, each instance of `DbContext` has a `ChangeTracker` to track the
    changes in the entities, which is a powerful feature of EF Core. In other words,
    EF Core knows the state of each entity – whether it is added, deleted, or modified.
    When we update the entity, we just update the entity in the memory. EF Core can
    track the changes. When the `SaveChangesAsync()` method is called, it will generate
    the SQL statement to update the data in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EntityState` enum can have the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Detached`: The entity is not being tracked by the context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unchanged`: The entity is being tracked by the context, but the values are
    not changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Deleted`: The entity is being tracked and exists in the database, but it has
    been marked for deletion. So, when the `SaveChangesAsync()` method is called,
    EF Core will generate the SQL statement to delete the entity from the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Modified`: The entity is being tracked and exists in the database, and the
    values have been modified in `DbContext`. When the `SaveChangesAsync()` method
    is called, EF Core will generate the SQL statement to update the entity in the
    database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Added`: The entity is being tracked but it does not exist in the database.
    When the `SaveChangesAsync()` method is called, EF Core will generate the SQL
    statement to insert the entity into the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the *Creating an entity* section, we used the `Add()` method to add the
    entity to the entity set. This is equivalent to setting the `State` property to
    `Added`, such as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `Add()` method, changing the state of the entity does not modify
    the data in the database. You must call the `SaveChangesAsync()` method to save
    the changes to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to call the `PutInvoice` action method to update an invoice. Send
    a `PUT` request to the `/api/invoices/{id}` endpoint in the Swagger UI. The request
    body is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Please update the JSON body to change the `contactName` property only. The
    SQL statement generated by EF Core is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can see EF Core omits the `Id` column in the `UPDATE` statement. This is
    because the `Id` column is the primary key of the `Invoices` table. EF Core knows
    that it does not need to update the `Id` column. But EF Core will update the other
    properties irrespective of whether the values are changed or not because the `EntityState`
    of the entity is `Modified`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we want to update only the changed properties. For example, if we
    just want to update the `Status` property, the SQL statement should not have to
    update other columns. To do this, we can find the entity that needs to be updated,
    and then update the properties explicitly. Let us update the `PutInvoice` action
    method to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we first find the entity by the `FindAsync()` method. Then,
    we update the `Status` property. EF Core will mark the `Status` property as modified.
    Finally, we call the `SaveChangesAsync()` method to save the changes to the database.
    You can see the generated SQL statement only updates the `Status` property, which
    is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in an actual scenario, normally, the endpoint will receive the whole
    entity, not just the changed properties. We may not know which properties are
    changed. In this case, we can just update all the properties in the code. EF Core
    can track the state of the entity, so it is smart enough to determine which properties
    are changed. Let us update the `PutInvoice` action method to explicitly update
    all the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Send a `PUT` request to the `/api/Invoices/{id}` endpoint and attach a JSON
    body to the request. If you just update the `Status` and `Description` properties,
    the SQL statement will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding SQL statement slightly improves the performance because it only
    updates the changed properties. It might not be a big deal for a small table,
    but if you have a large table that has many columns, it will be a good practice.
    However, it needs a `SELECT` statement to get the entity first. Choose the way
    that suits your scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an issue in the preceding code. If the entity has many properties,
    it will be tedious to update all the properties one by one. In this case, we can
    use the `Entry` method to get the `EntityEntry` object and then set the `CurrentValues`
    property to the new values. Let us update the `PutInvoice` action method to use
    the `Entry` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `SetValues()` method will set all the properties of the entity to the new
    values. EF Core can detect the changes and mark the properties that have changed
    as `Modified`. So, we do not need to manually set each property. This way is a
    good practice when updating an entity that has many properties. Also, the object
    used to update the properties does not have to be the same type as the entity.
    It is useful in a layered application. For example, the entity received from the
    client is a **Data Transfer Object** (**DTO**) object, and the entity in the database
    is a domain object. In this case, EF Core will update the properties that match
    the names of the properties in the DTO object.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `SetValues()` method only updates the simple properties, such
    as `string`, `int`, `decimal`, `DateTime`, and so on. If the entity has a navigation
    property, the `SetValues()` method will not update the navigation property. In
    this case, we need to update the properties explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Test the `/api/Invoices/{id}` endpoint by sending a `PUT` request again. You
    can see the generated SQL statement is similar to the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an entity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the generated code of the `DeleteInvoice` action method, we can see the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic is to find the entity first, and then remove it from `DbSet` using
    the `Remove()` method. Finally, we call the `SaveChangesAsync()` method to save
    the changes to the database. If you understand `EntityState` already, you might
    know that the `Remove()` method is equivalent to setting `EntityState` to `Deleted`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated SQL statement is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, EF Core generates two SQL statements, which seems a little
    bit unnecessary to find the entity first. When we delete an entity, the only thing
    we need is the primary key. So, we can update the `DeleteInvoice()` action like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the SQL statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It is much simpler than the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: 'From EF Core 7.0, we have a new method called `ExecuteDeleteAsync()` that can
    be used to delete an entity without loading it first. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `ExecuteDeleteAsync()` method does not involve the change tracker, so it
    will execute the SQL statement immediately to the database. It does not need to
    call the `SaveChangesAsync()` method at the end. It is a recommended way to delete
    one entity (or more) from EF Core 7.0 and later versions. However, if the entity
    already exists in `DbContext` and is tracked by the change tracker, executing
    the SQL statement directly may cause the data in `DbContext` and the database
    to be inconsistent. In this case, you may need to use the `Remove()` method or
    set the `EntityState` property to `Deleted` to delete the entity from `DbContext`.
    Please consider your scenario carefully before using the `ExecuteDeleteAsync()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: You must be wondering how EF Core knows the names of columns and tables in the
    database. We will talk about the configuration and see how EF Core maps the models
    to the database next.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the mapping between models and database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ORM, as the name suggests, is used to map the objects to the relational database.
    EF Core uses the mapping configuration to map the models to the database. In the
    previous section, we saw that we did not configure any mappings; however, EF Core
    could still map the models to the database automatically. This is because EF Core
    has a set of built-in conventions to configure the mappings. We can also explicitly
    customize the configuration to meet our needs. In this section, we will discuss
    the configuration in EF Core, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fluent API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some conventions in EF Core for mapping the models to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: The database uses the `dbo` schema by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The table name is the plural form of the model name. For example, we have a
    `DbSet<Invoice> Invoices` property in the `InvoiceDbContext` class, so the table
    name is `Invoices`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The column name is the property name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The data type of the column is based on the property type and the database
    providers. Here is a list of the default mapping for some common C# types in SQL
    Server:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **.****NET type** | **SQL Server** **data type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | `int` |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | `bigint` |'
  prefs: []
  type: TYPE_TB
- en: '| `string` | `nvarchar(max)` |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `bit` |'
  prefs: []
  type: TYPE_TB
- en: '| `datetime` | `datetime` |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | `float` |'
  prefs: []
  type: TYPE_TB
- en: '| `decimal` | `decimal(18,2)` |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | `tinyint` |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | `smallint` |'
  prefs: []
  type: TYPE_TB
- en: '| `byte[]` | `varbinary(max)` |'
  prefs: []
  type: TYPE_TB
- en: Table 5.1 – Default mapping for some common C# types in SQL Server
  prefs: []
  type: TYPE_NORMAL
- en: If a property is named `Id` or `<entity name>Id`, EF Core will map it to the
    primary key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If EF Core detects that the relationship between two models is one-to-many,
    it will map the navigation property to a foreign key column in the database automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a column is a primary key, EF Core will create a clustered index for it automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a column is a foreign key, EF Core will create a non-clustered index for
    it automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `enum` type is mapped to the underlying type of the enum. For example, the
    `InvoiceStatus` enum is mapped to the `int` type in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, sometimes we need to refine the mapping. For example, we may want to
    use the `varchar(100)` column instead of the `nvarchar(max)` column for a `string`
    property. We may also want to save enums as strings in the database instead of
    `int` values. In such cases, we can override the default conventions to customize
    the mapping based on our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to explicitly configure the mapping between the models and
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: Data annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fluent API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us see how to use data annotations and Fluent API to customize the mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Data annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Data annotations are attributes that you can apply to the model classes to
    customize the mapping. For example, you can use the `Table` attribute to specify
    the table name and use the `Column` attribute to specify the column name. The
    following code shows how to use data annotations to customize the mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, each property has one or more data annotations. These
    data annotations are attributes that you can apply to the model classes to customize
    the mapping. You can specify some mapping information, such as the table name,
    column name, column data type, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the most commonly used data annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Table` | The table name that the model class is mapped to. |'
  prefs: []
  type: TYPE_TB
- en: '| `Column` | The column name in the table that a property is mapped to. You
    can also specify the column data type using the `TypeName` property. |'
  prefs: []
  type: TYPE_TB
- en: '| `Key` | Specifies the property as a key. |'
  prefs: []
  type: TYPE_TB
- en: '| `ForeignKey` | Specifies the property as a foreign key. |'
  prefs: []
  type: TYPE_TB
- en: '| `NotMapped` | The model or property is not mapped to the database. |'
  prefs: []
  type: TYPE_TB
- en: '| `Required` | The value of the property is required. |'
  prefs: []
  type: TYPE_TB
- en: '| `MaxLength` | Specifies the maximum length of the value in the database.
    Applied to string or array values only. |'
  prefs: []
  type: TYPE_TB
- en: '| `Index` | Creates an index on the column that the property is mapped to.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Precision` | Specifies the precision and scale of the property if the database
    supports precision and scale facets. |'
  prefs: []
  type: TYPE_TB
- en: '| `DatabaseGenerated` | Specifies how the database should generate the values
    for the property. If you use `int` or `long` as the primary key for an entity,
    you can use this attribute and set `DatabaseGeneratedOption` as `Identity`, such
    as `[DatabaseGenerated(DatabaseGeneratedOption.Identity)]`. |'
  prefs: []
  type: TYPE_TB
- en: '| `TimeStamp` | Specifies the property is used for concurrency management.
    The property will map to a `rowversion` type in SQL Server. The implementation
    may vary in different database providers. |'
  prefs: []
  type: TYPE_TB
- en: Table 5.2 – Commonly used data annotations
  prefs: []
  type: TYPE_NORMAL
- en: In this way, the mapping configuration is embedded in the model classes. It
    is easy to understand, but it is a little bit intrusive, which means the model
    classes are polluted with the database-related configuration. To decouple the
    model classes from the database mapping configuration, we can use Fluent API.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Every time the mapping is changed, you need to run the `dotnet ef migrations
    add <migration name>` command to generate a new migration. Then, run the `dotnet
    ef database update` command to update the database.
  prefs: []
  type: TYPE_NORMAL
- en: Fluent API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fluent API is a set of extension methods that you can use to configure the mappings
    gracefully. It is the most flexible and powerful way to apply the mapping configuration
    without polluting the model classes. Another important thing to note is that Fluent
    API has a higher priority than data annotations. If you configure the same property
    in both data annotations and Fluent API, Fluent API will override the data annotations.
    So, Fluent API is the recommended way to configure the mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Fluent API is applied in the order of the method calls. If there are two calls
    to configure the same property, the latest call will override the previous configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Fluent API, we need to override the `OnModelCreating()` method in the
    derived `DbContext` class. The following code shows how to use Fluent API to configure
    the mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the `Entity()` method to configure the `Invoice`
    entity. This method accepts an `Action<EntityTypeBuilder<TEntity>>` parameter
    to specify the mappings. The `EntityTypeBuilder<TEntity>` class has a lot of methods
    to configure the entity, such as table name, column name, column data type, and
    so on. You can chain these methods in a fluent way to configure the entity, so
    it is called Fluent API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the most commonly used Fluent API methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** | **Equivalent** **data annotation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `HasDefaultSchema()` | Specifies the database schema. The default schema
    is `dbo`. | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| `ToTable()` | The table name that the model class is mapped to. | `Table`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `HasColumnName()` | The column name in the table that a property is mapped
    to. | `Column` |'
  prefs: []
  type: TYPE_TB
- en: '| `HasKey()` | Specifies the property as a key. | `Key` |'
  prefs: []
  type: TYPE_TB
- en: '| `Ignore()` | Ignores a model or a property from the mapping. This method
    can be applied on an entity level or a property level. | `NotMapped` |'
  prefs: []
  type: TYPE_TB
- en: '| `IsRequired()` | The value of the property is required. | `Required` |'
  prefs: []
  type: TYPE_TB
- en: '| `HasColumnType()` | Specifies the data type of the column that the property
    is mapped to. | `Column` with the `TypeName` property |'
  prefs: []
  type: TYPE_TB
- en: '| `HasMaxLength()` | Specifies the maximum length of the value in the database.
    Applied to a string or array only. | `MaxLength` |'
  prefs: []
  type: TYPE_TB
- en: '| `HasIndex()` | Creates an index on the specific property. | `Index` |'
  prefs: []
  type: TYPE_TB
- en: '| `IsRowVersion()` | Specifies the property is used for concurrency management.
    The property will map to a `rowversion` type in SQL Server. The implementation
    may vary in different database providers. | `TimeStamp` |'
  prefs: []
  type: TYPE_TB
- en: '| `HasDefaultValue()` | Specifies a default value for a column. The value must
    be a constant. | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| `HasDefaultValueSql()` | Specifies a SQL expression to generate the default
    value for a column, such as `GetUtcDate()`. | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| `HasConversion()` | Defines a value converter to map the property to the
    column data type. It contains two `Func` expressions to convert the values. |
    N/A |'
  prefs: []
  type: TYPE_TB
- en: '| `ValueGeneratedOnAdd()` | Specifies the value of the property to be generated
    by the database when a new entity is added. EF Core will ignore this property
    when inserting a record. | `DatabaseGenerated` with the `DatabaseGeneratedOption.Identity`
    option |'
  prefs: []
  type: TYPE_TB
- en: Table 5.3 – Commonly used Fluent API methods
  prefs: []
  type: TYPE_NORMAL
- en: There are some other methods to configure the relationships using Fluent API,
    such as `HasOne()`, `HasMany()`, `WithOne()`, `WithMany()`, and so on. We will
    cover them in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Separating the mapping configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a large project, there may be a lot of model classes. If we put all the mapping
    configurations in the `OnModelCreating()` method, the method will be very long
    and hard to maintain. To make the code more readable and maintainable, we can
    extract the mapping configuration to one class or a couple of separate classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to do this is to create an extension method for the `ModelBuilder`
    class. Create a new class named `InvoiceModelCreatingExtensions` in the `Data`
    folder. Then, add the following code to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `OnModelCreating()` method, call the extension method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `OnModelCreating()` method is much cleaner and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to separate the mapping configurations is to implement the `IEntityTypeConfiguration<TEntity>`
    interface. Create a new class named `InvoiceConfiguration` in the `Data` folder.
    Then, add the following code to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `OnModelCreating()` method, there are two ways to apply the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use the `ApplyConfiguration()` method, add the following code to the
    `OnModelCreating()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or you can call the `Configure()` method directly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As the project grows, it might be a little bit tedious to call the mapping
    configuration for each entity. In this case, EF Core has a method called `ApplyConfigurationsFromAssembly()`
    to apply all the configurations in the assembly, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You can choose the one that fits your project best. One reminder is that if
    you use the `ApplyConfigurationsFromAssembly()` method, you need to make sure
    that all the configuration classes are in the same assembly as the `DbContext`
    class. Also, you cannot control the order of the configurations. If the order
    matters, you need to call each configuration explicitly in the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you run the `dotnet ef migrations add <migration name>` command, you
    can find that the generated migration file has the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet shows that the `Status` property is changed from `int`
    to `varchar(16)`, and the `InvoiceNumber` property is changed from `nvarchar(max)`
    to `varchar(32)`. Then, you can run the `dotnet ef database update` command to
    update the database. You will see the `Status` column is stored as strings.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: During the migration, the data may get lost if the data type is changed. For
    example, if the data type is changed from `nvarchar(max)` to `varchar(32)`, the
    original data will be truncated to 32 characters. Please make sure you understand
    the data type change before you run the migration.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to explicitly configure the mapping for each entity in order
    to ensure optimal performance. For example, `nvarchar(max)` requires more storage
    space than `varchar`, so the default mapping configuration may not be the most
    efficient. Additionally, the default `dbo` database schema may not be suitable
    for your particular scenario. Therefore, explicitly configuring the mapping is
    a recommended practice.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to access the database using EF Core. We implemented
    CRUD operations using the `DbContext` class. We introduced some basic LINQ queries,
    such as query, filter, sort, create, update, and delete. We also learned how to
    configure the mapping using data annotations and Fluent API. With the knowledge
    gained in this chapter, you can build a simple application to access the database.
  prefs: []
  type: TYPE_NORMAL
- en: However, the application we built in this chapter is quite basic and only has
    one entity. In a real-world project, there are usually multiple entities and relationships
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to configure relationshiseps between
    entities using EF Core.
  prefs: []
  type: TYPE_NORMAL
