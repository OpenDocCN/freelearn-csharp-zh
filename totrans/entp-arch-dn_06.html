<html><head></head><body>
<div id="_idContainer057">
<h1 class="chapter-number" id="_idParaDest-128"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-129"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.2.1">SOLID Principles, from Code to Systems</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Starting from this chapter, we are going to step away from the theoretical part and, while we are not yet starting to code (this will start in </span><a href="B21293_13.xhtml#_idTextAnchor470"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.5.1">), we will start applying the theory to designing a small information system made of several applications. </span><span class="koboSpan" id="kobo.5.2">We will decompose the different functions, show how they help produce business process outcomes and create the software behind these functions. </span><span class="koboSpan" id="kobo.5.3">To do so, we will design the different components and the API contracts for the services involved, and think of how the data should be designed and governed. </span><span class="koboSpan" id="kobo.5.4">And in </span><a href="B21293_13.xhtml#_idTextAnchor470"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.7.1">, we will use all of this design phase to actually implement the sample </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">information system.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">Of course, this information system will be reduced in perimeter and complexity, but the exercise has been designed to include most of the important decisions that should be made. </span><span class="koboSpan" id="kobo.9.2">You will find strict responsibility separation, nice separation between processes and functions, decoupling of the service through APIs, standardization of the contracts, best-of-breed approach, adapting the software stack to the functions desired, independence between the software and the hardware, and lots of </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">other principles.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we will start designing our demonstration system by thinking of the functions it should expose. </span><span class="koboSpan" id="kobo.11.2">To do so, we will </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.12.1">use the </span><strong class="bold"><span class="koboSpan" id="kobo.13.1">SOLID principles</span></strong><span class="koboSpan" id="kobo.14.1">, extending them to information systems. </span><span class="koboSpan" id="kobo.14.2">SOLID is the acronym composed of the first letters of the five essential principles of software development, which are </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.16.1">Single responsibility</span></strong><span class="koboSpan" id="kobo.17.1"> states that one module should only do </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">one thing</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.19.1">Open/closed</span></strong><span class="koboSpan" id="kobo.20.1"> differentiates between open to evolution and closed </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">to modification</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.22.1">Liskov’s</span></strong><span class="koboSpan" id="kobo.23.1"> principle explains how substitution </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">should work</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.25.1">Interface segregation</span></strong><span class="koboSpan" id="kobo.26.1"> follows with how contracts should be strongly aligned to </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">business functions</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">Finally, </span><strong class="bold"><span class="koboSpan" id="kobo.29.1">dependency inversion</span></strong><span class="koboSpan" id="kobo.30.1"> deals with coupling and how it should be done, at the inverse of what seems natural in </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">most cases</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.32.1">It happens that these </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.33.1">principles, often applied to software applications, actually apply to every software system and constitute a great way to design their different modules. </span><span class="koboSpan" id="kobo.33.2">We will thus use them to design our sample information system. </span><span class="koboSpan" id="kobo.33.3">But first, we need to describe the business requirements for </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">this system</span><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.35.1">.</span></span></p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.36.1">Describing the sample information system requirements</span></h1>
<p><span class="koboSpan" id="kobo.37.1">Before any</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.38.1"> kind of analysis, we will imagine what the system owner would want from it. </span><span class="koboSpan" id="kobo.38.2">Of course, as we explained, time is a very important constraint in information systems design, which has a long life, and we will simulate the fact that we do not know everything about the requirements at first. </span><span class="koboSpan" id="kobo.38.3">In particular, the last chapters of the book will simulate the fact that new requirements arise for the imaginary company owning the information system, and explain how the system will adapt to it. </span><span class="koboSpan" id="kobo.38.4">This point is particularly important because the main goal of this book is to show how a system should be created or adapted so that its evolution is simpler </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">in time.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">To make the exercise as realistic as possible, while keeping it simple for it to be contained in a single book, we will imagine the company, the users of the information system, their business, the data they manipulate, and so on. </span><span class="koboSpan" id="kobo.40.2">This is what we are going to do in this </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">first sectio</span><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.42.1">n.</span></span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.43.1">The company and its business</span></h2>
<p><span class="koboSpan" id="kobo.44.1">The </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.45.1">company, which we will call </span><strong class="bold"><span class="koboSpan" id="kobo.46.1">DemoEditor</span></strong><span class="koboSpan" id="kobo.47.1"> for this</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.48.1"> purpose, would be an editing company that contracts with individual authors for the writing of books and then sells these books. </span><span class="koboSpan" id="kobo.48.2">We will imagine that this is quite a small company (less than 50 persons) and that its current information system is extremely reduced, mostly composed of a standard Office 365 organization providing them with email capability, basic SharePoint document management, an externalized website, and lots of internal functions being implemented through </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">Excel workbooks.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">While this remains a comfortable situation, because the information system has not turned into a spaghetti dish due to a long accumulation of point-to-point interoperations, degradation of legacy software applications, and so on, it still shows signs of inefficacy. </span><span class="koboSpan" id="kobo.50.2">The multiple copies of the Excel workbooks make it difficult for the employees</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.51.1"> to have a clear view of the pool of authors and the state of the writing of the books. </span><span class="koboSpan" id="kobo.51.2">Also, as the process of writing is not uniform, the director of the company complains about not being able to find clear statistics about global advances or delays in </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">book delivery.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">The business is mostly about finding the right subjects for the market, choosing the right author, following up on the writing of the books, and organizing the right </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">sales pro</span><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.55.1">cess.</span></span></p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.56.1">The users and actors of the information system</span></h2>
<p><span class="koboSpan" id="kobo.57.1">The</span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.58.1"> 50 persons are, mostly, book editors. </span><span class="koboSpan" id="kobo.58.2">Then come the sales team, a bit of administration, and the director. </span><span class="koboSpan" id="kobo.58.3">For this simple example, we will consider that all the printing and distribution of the books is outsourced to another company and that DemoEditor concentrates only on the </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">editing process.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">The book editors’ job is to find authors, find book subjects, and match the right author to the right book. </span><span class="koboSpan" id="kobo.60.2">Then, they follow the writing process and make sure that the quality </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">is there.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">Then, it is up to the sales team and their job is to find indirect customers, which means libraries or book-selling organizations, as DemoEditor does not sell directly to readers. </span><span class="koboSpan" id="kobo.62.2">This means that commercial people actually sell the books by numbers, and not by units. </span><span class="koboSpan" id="kobo.62.3">Though we will not deal much with this part in our demo software system, it would be important in a </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">real situation.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">Finally, the director needs to keep numbers in check through reporting and statistics coming from the sales team and the editors. </span><span class="koboSpan" id="kobo.64.2">The smooth running of the company heavily depends on the right deadlines for the book as much as the quality of the writing, the match between the subject and the author, and the expectations of readers and book-selling companies. </span><span class="koboSpan" id="kobo.64.3">This means that the director has to measure all of these indicators, and the information system is of course expected to provide them. </span><span class="koboSpan" id="kobo.64.4">Asking editors or salespersons to fill in Excel sheets every week does not make sense, as this is time lost for their </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">real</span><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.66.1"> jobs.</span></span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.67.1">Data manipulation</span></h2>
<p><span class="koboSpan" id="kobo.68.1">As</span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.69.1"> you may have imagined, DemoEditor’s information system will have to manipulate data about authors, books, and sales, plus some additional statistics drawn from these primary data. </span><span class="koboSpan" id="kobo.69.2">The author will be known by their identity, a little contact information, maybe their bank coordinates to pay them royalties, and certainly information on their skills. </span><span class="koboSpan" id="kobo.69.3">Books will be registered with business-wide reference numbers, their titles, their summaries, and other information about the content. </span><span class="koboSpan" id="kobo.69.4">Sales will basically be the number of books sold to booksellers, with the associated date and maybe </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">sales conditions.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">Reporting data will be everything that can be used to apply business intelligence by the director on sales, authors, and books: how many books are sold for each category, what the time trend of selling them is, how many editions authors can work on for a given book before sales slow down and the novelty effect does not work anymore, who is their best salesperson, which bookseller returns the least number of books or reorders some the quickest, and so on. </span><span class="koboSpan" id="kobo.71.2">The reporting data is definitely bound to time, and not only by the fact that reports evolve in time, but also by the fact that reports should show the movements of business in time as well </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">as geograph</span><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.73.1">ically.</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.74.1">The stakes of the information system for the company</span></h2>
<p><span class="koboSpan" id="kobo.75.1">DemoEditor is a</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.76.1"> small company, which means that employees can “fill the gaps” and do a little bit of everything. </span><span class="koboSpan" id="kobo.76.2">While this is an advantage in some cases, meaning that they are agile and adaptive, it also means that they do not tend to do things in an industrial, repeatable way. </span><span class="koboSpan" id="kobo.76.3">Excel spreadsheets may be copied over and spread out in different versions all over the company instead of a unique, reference version being kept on the network. </span><span class="koboSpan" id="kobo.76.4">Also, data sales are spread around the different salespersons because they tend to be competitive toward each other and it is thus difficult to homogenize quantity discounts (the price is fixed) as well as </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">customer listings.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">As the commercial pipe is not very formal, some leads become prospects and then customers without the salesperson being able to really give statistics on how long and how much effort this takes them. </span><span class="koboSpan" id="kobo.78.2">The director really has a hard time knowing whether the company would sell more if they hired more salespersons. </span><span class="koboSpan" id="kobo.78.3">The choice of authors for the right books is also an issue. </span><span class="koboSpan" id="kobo.78.4">Generally, the editors have a good grasp on the market and know quite well which subjects should be written about. </span><span class="koboSpan" id="kobo.78.5">But the pool of competent authors is quite restricted and the authors are mostly known for the books they have already written. </span><span class="koboSpan" id="kobo.78.6">Most of the time, the editors do not know which other technologies these experts know about and there have been times when a book has been contracted to a new </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.79.1">author, after taking a lot of time to find them, only for the editor to realize a few weeks later that one of the good authors who’s already written several books for DemoEditor actually had the right skills for the new project. </span><span class="koboSpan" id="kobo.79.2">An updated, shared, and efficient knowledge of author competencies is important </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">for De</span><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.81.1">moEditor.</span></span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.82.1">The situation as seen by the person put in charge of improving the system</span></h2>
<p><span class="koboSpan" id="kobo.83.1">You are</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.84.1"> asked by the director to come and help with the information system. </span><span class="koboSpan" id="kobo.84.2">Everyone in the company knows IT could be more efficient and help them better but, as they say, they are not specialists in it. </span><span class="koboSpan" id="kobo.84.3">Since there was no internal IT guy, they did as best as they could, but they realized the “do it yourself” spirit of a small company can only go so far, and they had to get someone to give some structure. </span><span class="koboSpan" id="kobo.84.4">The director is also anxious about increasing the size of the company before this effort is done; otherwise, it may add more problems </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">than growth.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">As the business processes go on and the budget is not extensible, you are tasked with “</span><em class="italic"><span class="koboSpan" id="kobo.87.1">changing the wheel while the car is running</span></em><span class="koboSpan" id="kobo.88.1">.” </span><span class="koboSpan" id="kobo.88.2">There may be some small stops in the IT system, but not for long periods. </span><span class="koboSpan" id="kobo.88.3">The data has got to be cleaned but the databases of authors and books have got to remain available along the way since they are everyday tools for most of the company’s employees. </span><span class="koboSpan" id="kobo.88.4">The director does not care much about its reporting being unavailable, or even destroyed, since it is not very useful at the moment and most of the numbers were </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">false anyway.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">In the next chapters, we will put ourselves in the skin of an engineer asked to carry out this foundational task and design the different components of the renewed IT system, and decide how its services should operate and what business domains should be designed. </span><span class="koboSpan" id="kobo.90.2">After that, we will implement all this and progressively transform the information system. </span><span class="koboSpan" id="kobo.90.3">But for now, we have to transform the theory learned in the previous chapters into principles that will guide us along the way. </span><span class="koboSpan" id="kobo.90.4">SOLID principles are a great set of principles that </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">apply </span><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.92.1">perfectly.</span></span></p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.93.1">SOLID principles and application to systems of whatever scale</span></h1>
<p><span class="koboSpan" id="kobo.94.1">SOLID principles</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.95.1"> are important principles that apply to software applications, but they happen to also apply very well to software systems in general, so we will be able to use them to structure our project. </span><span class="koboSpan" id="kobo.95.2">We are going to explain the five principles one by one, together with how they apply to the transformation requested by DemoEditor and the design of its new information system. </span><span class="koboSpan" id="kobo.95.3">As this is a book about information systems and not software development, even though we will eventually build some implementations, I will not describe the principles from the coding point of view, but only briefly their main idea and, with more details, their translation into </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">syst</span><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.97.1">ems design.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.98.1">Single responsibility principle</span></h2>
<p><span class="koboSpan" id="kobo.99.1">This</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.100.1"> principle states that a class, or in our case, a module of an information system, should do one and only one thing. </span><span class="koboSpan" id="kobo.100.2">This is quite wide as a definition but it can be narrowed down a bit by stating that an entity should have only one business reason to change. </span><span class="koboSpan" id="kobo.100.3">If the same class should be upgraded when there are changes in the author’s management and the book’s management, there is a problem regarding this single responsibility principle and the class should be decomposed into at least two </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">smaller ones.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">This principle is obviously easy to translate into an information system where it applies directly to modules, whether they are services, components, or other grains of entire systems (we will come back to the management of granularity in the next chapter). </span><span class="koboSpan" id="kobo.102.2">Each entity in the system should do one thing and only one. </span><span class="koboSpan" id="kobo.102.3">If this is observed from the point of view of the software applications composing the system, that means that each application should be in charge of only one business domain of the system. </span><span class="koboSpan" id="kobo.102.4">Since we manage authors, books, sales, and so on, we should indeed find one application for each of these. </span><span class="koboSpan" id="kobo.102.5">This notion of a business domain is not very precise for now but again, we will come to this in a future chapter, namely </span><a href="B21293_09.xhtml#_idTextAnchor318"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.103.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.104.1">, detailing the </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">domain-driven design</span></strong><span class="koboSpan" id="kobo.106.1"> approach </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.107.1">and the concepts of domain and </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">bounded context.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">For now, let’s just agree that a business domain needs its own application. </span><span class="koboSpan" id="kobo.109.2">If you are thinking microservices, yes, this is the track we are going to follow but bear with me, as this “micro” qualification is not always necessary and we would rather talk about “services” (with a clearer definition in </span><a href="B21293_08.xhtml#_idTextAnchor271"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.110.1">Chapter 8</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.111.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">This</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.113.1"> first principle may sound very simple (and it is in its expression), but its implication can be very profound. </span><span class="koboSpan" id="kobo.113.2">To give just one example of the complexities we will have to deal with in our sample application, let’s unroll the case where a service depends on another, like in the case of the relationship of the “author of a book.” </span><span class="koboSpan" id="kobo.113.3">As said before, author and book management are two separate responsibilities. </span><span class="koboSpan" id="kobo.113.4">But how should we deal with the relationships between both? </span><span class="koboSpan" id="kobo.113.5">Is it another service? </span><span class="koboSpan" id="kobo.113.6">In any case, when someone reads a book entity from the service, how should the author of the book be retrieved and displayed? </span><span class="koboSpan" id="kobo.113.7">We can ask the same question the other way around: if someone calls the API on a given author, how should we display the list of books this author has participated </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">in writing?</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">Diving into this last scenario is useful to get a better grasp of the concept of responsibility. </span><span class="koboSpan" id="kobo.115.2">Imagine that there are two separate services, each with its own database since they are supposed to be independent. </span><span class="koboSpan" id="kobo.115.3">Now, a user calls the API with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">GET</span></strong><span class="koboSpan" id="kobo.117.1"> word on a particular book, let’s say </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">https://demoeditor.org/api/books/123456</span></strong><span class="koboSpan" id="kobo.119.1">. </span><span class="koboSpan" id="kobo.119.2">The module is indeed responsible for sending the book title, ISBN/EAN number, and some other attributes of the book. </span><span class="koboSpan" id="kobo.119.3">How about the information about the author? </span><span class="koboSpan" id="kobo.119.4">This is where the principle of responsibility helps to draw the line. </span><span class="koboSpan" id="kobo.119.5">The editors would tell you that, most of the time, when they get the information about the book, they need to know the author, but only by their identifier and some main data, such as their first and last name. </span><span class="koboSpan" id="kobo.119.6">This is the responsibility of the book service. </span><span class="koboSpan" id="kobo.119.7">And if you ask your product owners again (the editors, as they are the ones who will be using the information system), and they need some more data, they will turn to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">/api/authors</span></strong><span class="koboSpan" id="kobo.121.1"> service to get it, using, of course, the identifier provided by the initial answer from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">/api/books</span></strong><span class="koboSpan" id="kobo.123.1"> service. </span><span class="koboSpan" id="kobo.123.2">Thus, that data is the only responsibility of the </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">second service.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">Each reader who knows about the principles of good database design is certainly suffocating already, considering that this approach necessitates data duplication. </span><span class="koboSpan" id="kobo.125.2">Indeed, since </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">/api/authors</span></strong><span class="koboSpan" id="kobo.127.1"> is responsible for the whole data for the authors, including of course their first name and last name, that means that, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">/api/books</span></strong><span class="koboSpan" id="kobo.129.1"> is responsible for providing, upon request, the identifier, first name, and last name of the author of the given book, the rule of non-duplication is broken! </span><span class="koboSpan" id="kobo.129.2">And this is where the concept of responsibility is interesting and should be dug into deeper. </span><span class="koboSpan" id="kobo.129.3">How about considering the following share </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">of responsibilities?</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">/api/authors</span></strong><span class="koboSpan" id="kobo.133.1"> service is responsible for providing always up-to-date data about an author, including their first name and last name. </span><span class="koboSpan" id="kobo.133.2">This means that it is the reference source of truth for the authors: anyone who needs the latest, best-so-far information about an</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.134.1"> author should turn to this service, which will be responsible for providing it on time. </span><span class="koboSpan" id="kobo.134.2">Since it is the reference for this data, the service would certainly provide it with a value date, as the data may change over time. </span><span class="koboSpan" id="kobo.134.3">For example, an author could change their last name after getting married; this should be tracked by the author service, as it is responsible for the data about authors and </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">their integrity.</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">/api/books</span></strong><span class="koboSpan" id="kobo.138.1"> service is responsible for providing the same service for books, which means the same level of engagement on the book title, identifiers, and so on. </span><span class="koboSpan" id="kobo.138.2">But when talking about the author of a book, this is a relationship to another reference service, so the only data it is responsible for in terms of service is to point at the right entity in the other service. </span><span class="koboSpan" id="kobo.138.3">And this raises two </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">interesting questions.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">The first one is functional: is the link supposed to simply point to a given author, or is it supposed to point to the value of an author </span><em class="italic"><span class="koboSpan" id="kobo.141.1">at a given point in time</span></em><span class="koboSpan" id="kobo.142.1">? </span><span class="koboSpan" id="kobo.142.2">This necessitates answering some business rules: if an author gets married between the first and second editions of a book, should the author’s name as it appears on the book change? </span><span class="koboSpan" id="kobo.142.3">And if so, how should the registered copyright be adjusted? </span><span class="koboSpan" id="kobo.142.4">And is the same true for a simple reprint of the original edition of </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">the book?</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">The second one is more technical: if the book service stores the link to the author service and the latter is not available when needed, what happens? </span><span class="koboSpan" id="kobo.144.2">If a copy of the “usual” data (first name and last name) has been stored in the book service, no problem since it is now </span><em class="italic"><span class="koboSpan" id="kobo.145.1">independent</span></em><span class="koboSpan" id="kobo.146.1"> of the second one. </span><span class="koboSpan" id="kobo.146.2">But this comes back to the functional question again: if the name should not be changed on the book after an author gets married, no problem, and it is even better, as the local copy will prevent the difficulty of reaching the author’s service with the date of value to retrieve the “old” data. </span><span class="koboSpan" id="kobo.146.3">And if the name should evolve, it may be better to temporarily fall back on the old one rather than providing just the machine-readable identifier; only editors </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">would know…</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">I hope this example, though complex, has shown you what we mean by the word </span><em class="italic"><span class="koboSpan" id="kobo.149.1">responsibility</span></em><span class="koboSpan" id="kobo.150.1">. </span><span class="koboSpan" id="kobo.150.2">It is admittedly complex but, remember, everything we talked about was linked to business complexity and is not accidental. </span><span class="koboSpan" id="kobo.150.3">Indeed, talking about value date and the importance of history in reference to data management may sound overly complex because it is not very often dealt with in current information systems. </span><span class="koboSpan" id="kobo.150.4">But this is a real problem and this lack of reflecting on the actual functional reality is a problem as it prevents reflecting all business rules! </span><span class="koboSpan" id="kobo.150.5">That does not mean that the software that will be constructed based on this reflection will take all this complexity into account. </span><span class="koboSpan" id="kobo.150.6">In a true Agile way, you will certainly start with something very simple. </span><span class="koboSpan" id="kobo.150.7">But this deep understanding </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.151.1">of the functional complexity ensures that the software will be easy to evolve in the future and that you will not be stuck at some point of implementation because the software is not aligned wi</span><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.152.1">th </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">the business.</span></span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.154.1">Open/closed principle</span></h2>
<p><span class="koboSpan" id="kobo.155.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.156.1">open/closed principle</span></strong><span class="koboSpan" id="kobo.157.1"> starts </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.158.1">with a paradox in</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.159.1"> its very expression, which makes it strange at first sight: how can a module be open and closed at the same time? </span><span class="koboSpan" id="kobo.159.2">The comprehension of this principle is very important to create systems that will evolve because it states what should remain closed and what should be open to change for this evolution to work as smoothly </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">as possible.</span></span></p>
<p><span class="koboSpan" id="kobo.161.1">When applied to object-oriented programming, the open/closed principle states that a class should be open to extension, but closed to modification. </span><span class="koboSpan" id="kobo.161.2">Encapsulation and private members are used to prevent any instance in the program from modifying directly the state of another instance; otherwise, it would be very difficult to follow what happens when executing the program. </span><span class="koboSpan" id="kobo.161.3">Even debugging would be complicated if there is no way to track what class modifies the state of another one. </span><span class="koboSpan" id="kobo.161.4">This is why a class keeps its members private and only opens some public functions to allow only some changes in its state, in a way that is controlled by its own code, following its own rules. </span><span class="koboSpan" id="kobo.161.5">This is the closed part of </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">the principle.</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">But a class, in general, is not marked as </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">final</span></strong><span class="koboSpan" id="kobo.165.1"> to let another class inherit from it and specialize the functions that are marked as </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">virtual</span></strong><span class="koboSpan" id="kobo.167.1">. </span><span class="koboSpan" id="kobo.167.2">The inheriting class can also add some data members, in addition to accessing the one from the inherited class that is marked as </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">protected</span></strong><span class="koboSpan" id="kobo.169.1"> (or, of course, </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">public</span></strong><span class="koboSpan" id="kobo.171.1">). </span><span class="koboSpan" id="kobo.171.2">Again, the class controls what can be overridden and what cannot, but at least it is open to an extension of its behavior by another class. </span><span class="koboSpan" id="kobo.171.3">This is the open part of </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">the principle.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">Applying this principle to information systems does not imply a big change in reflection, as the services replace the classes, and the techniques to extend or protect only vary from the practical point of view. </span><span class="koboSpan" id="kobo.173.2">If we continue with examples where services are REST APIs, we can draw a parallel between the members of a class and the data that is persisted by the implementation of an API contract: nothing but the service can modify this data, as only the implementation has access to the persistence used (a database or anything else). </span><span class="koboSpan" id="kobo.173.3">Of course, some API methods may allow some specific modifications to be carried from </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.174.1">the API clients, but the API implementation controls this and applies business rules to ensure the modification is carried as it wants (or maybe rejected, by the way). </span><span class="koboSpan" id="kobo.174.2">This is </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.175.1">the closed part of the principle applied to a module of information systems, and it is quite obvious in its resemblance to the application in </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">a class.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">The implementation of the open part of the principle on an API is trickier, as the behavior of an API can be extended in </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">many ways:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.179.1">One of the ways to do so is to create an API that will extend the initial API contract. </span><span class="koboSpan" id="kobo.179.2">Mechanisms exist in the OpenAPI grammar to implement polymorphism and it is also possible to aggregate types in such a way that the new one contains the initial type and all </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">its content.</span></span></li>
<li><span class="koboSpan" id="kobo.181.1">Another way is to create an API that replaces the exposition of the old implementation, but still relies on it for all the standard data, and then provides its own data in addition. </span><span class="koboSpan" id="kobo.181.2">If done carefully, the extended API may even be fully compatible with the initial API contract, since it only adds new data (and if it just passes the initial data without changing any behavior, it even complies with the Liskov substitution principle, which we will </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">see shortly).</span></span></li>
<li><span class="koboSpan" id="kobo.183.1">A third option is to use an API gateway to expose the updated contract and implement the mixing of data coming from the original API and the additional data coming from another service dedicated to its storing and manipulation. </span><span class="koboSpan" id="kobo.183.2">This approach is a bit closer to the principle </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">of inheritance.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.185.1">These three approaches are schematized </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.187.1"><img alt="Figure 6.1 – Open/closed﻿ approaches to APIs" src="image/Figure_6.1_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.188.1">Figure 6.1 – Open/closed</span><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.189.1"> approaches to APIs</span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.190.1">Liskov substitution principle</span></h2>
<p><span class="koboSpan" id="kobo.191.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.192.1">Liskov substitution principle</span></strong><span class="koboSpan" id="kobo.193.1"> requires that, when an entity is replaced by another one</span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.194.1"> that enriches or specializes</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.195.1"> its behavior, it should do so in a way that is compatible with the way the base entity functions. </span><span class="koboSpan" id="kobo.195.2">I have found that the easiest way to explain this is through the following example. </span><span class="koboSpan" id="kobo.195.3">Imagine an object class, that we will call </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">Display</span></strong><span class="koboSpan" id="kobo.197.1">, that would implement a </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">print</span></strong><span class="koboSpan" id="kobo.199.1"> function that sends black text on a white paper (through a printer, a screen, or anything else; no importance here). </span><span class="koboSpan" id="kobo.199.2">Let’s now suppose that a class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">ColorDisplay</span></strong><span class="koboSpan" id="kobo.201.1"> specializes in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">Display</span></strong><span class="koboSpan" id="kobo.203.1"> class and proposes a new function signature called </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">print</span></strong><span class="koboSpan" id="kobo.205.1"> again, but accepts a parameter named </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">color</span></strong><span class="koboSpan" id="kobo.207.1"> that allows the user to specify any color they want. </span><span class="koboSpan" id="kobo.207.2">How should the parameterless </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">print</span></strong><span class="koboSpan" id="kobo.209.1"> function behave? </span><span class="koboSpan" id="kobo.209.2">The inheriting class will certainly point to its new and improved </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">print</span></strong><span class="koboSpan" id="kobo.211.1"> function. </span><span class="koboSpan" id="kobo.211.2">And in this case, what should be the default color passed to this function? </span><span class="koboSpan" id="kobo.211.3">If you answer “black, of course,” you know what the Liskov substitution principle is about not surprising the user of a class, and ensuring them that the behavior is </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">as expected.</span></span></p>
<p><span class="koboSpan" id="kobo.213.1">The same goes</span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.214.1"> for services inside a modular information system. </span><span class="koboSpan" id="kobo.214.2">Again, we will use APIs, as this is the standard way to decompose modules in such a system. </span><span class="koboSpan" id="kobo.214.3">When an API contract is provided to you, it states what method can be called, with which verbs, and through which URL; it also states the exact name of the attributes that you can send or that you will receive. </span><span class="koboSpan" id="kobo.214.4">But you may very well respect the letter of the contract API without respecting its spirit and this is what the Liskov substitution principle </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">is about.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">Let’s</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.217.1"> translate our previous example from object-oriented programming into API services, and imagine one can use version 1.0 of </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">/api/print</span></strong><span class="koboSpan" id="kobo.219.1"> to process some text that will be sent to the device in black color. </span><span class="koboSpan" id="kobo.219.2">If using version 1.1 of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">/api/print</span></strong><span class="koboSpan" id="kobo.221.1"> API, with the support of </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">/api/print?color=[HEX-VALUE]</span></strong><span class="koboSpan" id="kobo.223.1">, we will definitely expect that pointing our old client to the new API results in the production of black text. </span><span class="koboSpan" id="kobo.223.2">In terms of the stream between the API contract and its implementation, this can be pictured as </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.225.1"><img alt="Figure 6.2﻿ – Liskov substitution" src="image/Figure_6.2_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.226.1">Figure 6.2</span><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.227.1"> – Liskov substitution</span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.228.1">Interface segregation principle</span></h2>
<p><span class="koboSpan" id="kobo.229.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.230.1">interface segregation principle</span></strong><span class="koboSpan" id="kobo.231.1"> recommends splitting the interfaces in such a way that an </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.232.1">implementing class does not have to</span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.233.1"> implement a behavior that it will not use. </span><span class="koboSpan" id="kobo.233.2">Again, as the goal is not to dive into object-oriented programming but just to draw a parallel with information systems, we will only give an example to explain this approach. </span><span class="koboSpan" id="kobo.233.3">Let’s imagine that a </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">Rectangle</span></strong><span class="koboSpan" id="kobo.235.1"> class implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">IShape</span></strong><span class="koboSpan" id="kobo.237.1"> interface. </span><span class="koboSpan" id="kobo.237.2">This means that </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">Rectangle</span></strong><span class="koboSpan" id="kobo.239.1"> would have to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">getSurface</span></strong><span class="koboSpan" id="kobo.241.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">getPerimeter</span></strong><span class="koboSpan" id="kobo.243.1"> methods but also some methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">drawShape</span></strong><span class="koboSpan" id="kobo.245.1"> and so on. </span><span class="koboSpan" id="kobo.245.2">If the only interesting thing in the program is to compute the mathematical characteristics of shapes, then the right approach would be to split </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">IShape</span></strong><span class="koboSpan" id="kobo.247.1"> into </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">IGeometricalShape</span></strong><span class="koboSpan" id="kobo.249.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">IDrawableShape</span></strong><span class="koboSpan" id="kobo.251.1"> (i.e., segregate the interfaces) for the classes to implement only the interface </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">they need.</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">The same goes </span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.254.1">for API contracts. </span><span class="koboSpan" id="kobo.254.2">To come back to our book service, it is better to separate two contracts, one for the book characteristics and one for the book sales characteristics, even if the same implementation will expose the two interfaces, one behind </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">/api/books</span></strong><span class="koboSpan" id="kobo.256.1"> and the other behind </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">/api/books/sales</span></strong><span class="koboSpan" id="kobo.258.1">, rather than force the implementation of all functions by the use of only </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">one contract.</span></span></p>
<p><span class="koboSpan" id="kobo.260.1">Though it is </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.261.1">always possible (and more acceptable in an API than in a class) to respond with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">NotImplemented</span></strong><span class="koboSpan" id="kobo.263.1"> message, the separation into two interfaces also makes it easier to introduce versions. </span><span class="koboSpan" id="kobo.263.2">If the sales interface was not correctly defined in version 1.0 and a major, backward-compatible rewrite is necessary, it will be possible to continue exposing the book’s characteristics (potentially used by most of the clients) without </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">any change.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.265.1">Note</span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.266.1">Backward compatibility</span></strong><span class="koboSpan" id="kobo.267.1"> is the </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.268.1">quality of a new version of an API where all calls used in the previous version work exactly with the same result on the </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">new one.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">The interface segregation even makes it possible (and easy) to expose three API contracts, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">/api/books</span></strong><span class="koboSpan" id="kobo.272.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">/api/books/sales</span></strong><span class="koboSpan" id="kobo.274.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">/api/books/sales/v2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.278.1"><img alt="Figure 6.3 – Interface segregation" src="image/Figure_6.3_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.279.1">Figure 6.3 – Interface segregation</span></p>
<p><span class="koboSpan" id="kobo.280.1">Though quite obvious in the explanation, this principle is sadly often forgotten in existing APIs. </span><span class="koboSpan" id="kobo.280.2">This is particularly so because editors tend to provide functions in the frameworks that generate the OpenAPI contract from the implementation, instead of following the contract-first approach (which is admittedly more complicated, but the only one that leads to proper, business-aligned APIs). </span><span class="koboSpan" id="kobo.280.3">Since the contract is automatically generated from the whole source code, the generators do not make any difference between the different methods and resources and produce a single, monolithic contract that does not respect the interf</span><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.281.1">ace </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">segregation principle.</span></span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.283.1">Dependency inversion approach</span></h2>
<p><span class="koboSpan" id="kobo.284.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.285.1">dependency inversion approach</span></strong><span class="koboSpan" id="kobo.286.1"> is named as such because it goes against the usual way of</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.287.1"> thinking about dependency. </span><span class="koboSpan" id="kobo.287.2">Imagine </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.288.1">that we have a reporting module and another module that provides the data to be used for reporting purposes. </span><span class="koboSpan" id="kobo.288.2">Naturally, we tend to think that the reporting module should depend on the data module in technical terms because this is how it works from the functional point of view. </span><span class="koboSpan" id="kobo.288.3">This is a rare case where aligning the technical design directly with the functional concepts is not good enough. </span><span class="koboSpan" id="kobo.288.4">If we want to ensure low coupling, we have to make one more step and add some indirection to a common interface that both of the services will </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">depend on:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.290.1">Just like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">Data</span></strong><span class="koboSpan" id="kobo.292.1"> class would implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">IData</span></strong><span class="koboSpan" id="kobo.294.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">/api/data</span></strong><span class="koboSpan" id="kobo.296.1"> service should implement the API contract defined in the data </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">OpenAPI file.</span></span></li>
<li><span class="koboSpan" id="kobo.298.1">And like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">Reporting</span></strong><span class="koboSpan" id="kobo.300.1"> class would use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">IData</span></strong><span class="koboSpan" id="kobo.302.1"> source (and not directly the </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">Data</span></strong><span class="koboSpan" id="kobo.304.1"> implementation) to prevent hard coupling, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">/api/reporting</span></strong><span class="koboSpan" id="kobo.306.1"> service would not directly call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">/api/data</span></strong><span class="koboSpan" id="kobo.308.1"> service but the URL provided to it by configuration, providing that it implements the data OpenAPI contract. </span><span class="koboSpan" id="kobo.308.2">In object-oriented programming, this will typically be done by injection. </span><span class="koboSpan" id="kobo.308.3">In a service, depending on the orchestration mechanism, this can be realized through an API gateway, the ingress exposition, or even a (more complicated) </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">service mesh.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.310.1">The following diagram has already been used in </span><a href="B21293_03.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.311.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.312.1">, but it is particularly relevant here, as it shows visually the dependency inversion principle in information systems: instead of a dependency of one software module on another, each of the two modules working together points at the same business contract definition (which is purely functional), one to implement it, the other to </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">consume it:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.314.1"><img alt="Figure 6.4 – Coupling on the four layers diagram" src="image/Figure_6.4_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.315.1">Figure 6.4 – Coupling on the four layers diagram</span></p>
<p><span class="koboSpan" id="kobo.316.1">Let’s</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.317.1"> move on </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.318.1">to the next section where we’ll</span><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.319.1"> analyze the </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">SOLID principle.</span></span></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.321.1">Critical analysis of SOLID</span></h1>
<p><span class="koboSpan" id="kobo.322.1">Though</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.323.1"> I have realized in time (certainly like many others) that the SOLID principles apply almost as well to information systems as to object-oriented classes and interfaces, some parts deserve discussion. </span><span class="koboSpan" id="kobo.323.2">Indeed, like for any other</span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.324.1"> principle, a strict, not thoughtful, application may lead to problems. </span><span class="koboSpan" id="kobo.324.2">And even when the principles apply well to a given context, they may have strong side effects that make them ultimately more harmful than helpful. </span><span class="koboSpan" id="kobo.324.3">The necessary measured approach has led to lots of polemics and you must be carefu</span><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.325.1">l in handling </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">these principles.</span></span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.327.1">Limits of the separation of responsibilities</span></h2>
<p><span class="koboSpan" id="kobo.328.1">The </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.329.1">first (and maybe most important) principle, namely the one about separation of responsibilities, is sometimes hard – perhaps impossible in some cases – to apply to services or high-level modules of an application. </span><span class="koboSpan" id="kobo.329.2">With classes, there is always the possibility to decompose a class without much impact on the whole application, once compiled. </span><span class="koboSpan" id="kobo.329.3">Services and modules do not present this ease of composition because they come with additional constraints such as exposition, endpoints, coding interfaces, documentation, integration subsystems, and so on. </span><span class="koboSpan" id="kobo.329.4">All this takes a toll on the decomposition, and</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.330.1"> this is the reason why people who are not careful with microservices and decompose them too much in their systems end up spending more time evolving them than if they had stayed on a monolith architecture. </span><span class="koboSpan" id="kobo.330.2">I am not going to talk again about granularity because the subject was already developed in the previous chapters, but this is clearly something that must be pondered and can limit the reach of the principle of separation of responsibilities, or at least </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">its depth.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">Another difficulty is not linked to how deeply you can separate the responsibilities, but how intricate some of them are sometimes, even at a relatively high level. </span><span class="koboSpan" id="kobo.332.2">This is, for example, a huge difficulty in “micro-frontend” architectures, and I am not talking about the problem associated with how “micro” the frontend component is. </span><span class="koboSpan" id="kobo.332.3">The simple fact that visual components present functions, but also have a visual impact, is a huge difficulty in making them independent. </span><span class="koboSpan" id="kobo.332.4">This is what is exposed, for example, in </span><a href="https://jonhilton.net/good-blazor-components/"><span class="koboSpan" id="kobo.333.1">https://jonhilton.net/good-blazor-components/</span></a><span class="koboSpan" id="kobo.334.1">: by delegating the content of a Blazor component to another sub-component (in the example of the article, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">ChildContext</span></strong><span class="koboSpan" id="kobo.336.1"> property to include a </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">Card</span></strong><span class="koboSpan" id="kobo.338.1"> instance), you indeed externalize the responsibility of displaying the inner part of a visual component. </span><span class="koboSpan" id="kobo.338.2">But that does not mean it will not have an impact, as the rendering of the subcomponent will necessarily have an impact on the one above it. </span><span class="koboSpan" id="kobo.338.3">Indeed, either the container fixes a size for the child and then takes responsibility for its display, or the container – in a purely responsive design manner – lets the child component adapt its display. </span><span class="koboSpan" id="kobo.338.4">In this case, its own size will be impacted by its child, which also ruins the independence that was supposed to be achieved by the principle of separation </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">of responsibilities.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">The intellectual solution for this is to consider that each component has the responsibility for its content, but not for its display and that this is the responsibility of the display engine in the browser. </span><span class="koboSpan" id="kobo.340.2">It may not be very satisfying because it comes back to a single point of execution for the whole frontend, which we were trying to make modular and easy to evolve, but at least the low coupling between the components has been achieved, though on a limited perimeter. </span><span class="koboSpan" id="kobo.340.3">This is one of the many compromises one will have to make when designing information </span><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.341.1">systems and </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">modular applications.</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.343.1">About the polemics on monoliths</span></h2>
<p><span class="koboSpan" id="kobo.344.1">This chapter </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.345.1">may be a good place to talk about the long-held discussion about “going back to monoliths,” a reaction to the drawbacks of microservices that have been very much observed in the discussions of the communities of software architects. </span><span class="koboSpan" id="kobo.345.2">In summary, the microservice approach is considered harmful and some people recommend going back to monolith applications. </span><span class="koboSpan" id="kobo.345.3">This is sadly another example of how polarized debates are nowadays, because both approaches (and the huge spectrum between them) have value, depending on </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">your needs.</span></span></p>
<p><span class="koboSpan" id="kobo.347.1">No one serious has ever pretended microservices were the best solution for every architecture. </span><span class="koboSpan" id="kobo.347.2">In fact, right from the beginning, most articles explaining the approach insisted that they were only adapted to some specific circumstances (high volumes, frequent modification of the application, clear cut between teams in charge of different modules, and so on). </span><span class="koboSpan" id="kobo.347.3">However, some people did not take this into account and now complain that microservices were not the right fit for their case. </span><span class="koboSpan" id="kobo.347.4">Even worse, in a binary and not very thought-out reaction, they discard the whole principle of microservices and advertise a so-called “return to the monolith.” </span><span class="koboSpan" id="kobo.347.5">Any sensible engineer in this case would simply spot the well-known pendulum movement where one extreme chases another one. </span><span class="koboSpan" id="kobo.347.6">And the solution in this case is not in either of them or continuously balancing between one and the other, but simply reaching the nice equilibrium </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">between them.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">In the case of software applications, what do we call a monolith? </span><span class="koboSpan" id="kobo.349.2">An application made of a single process? </span><span class="koboSpan" id="kobo.349.3">No, otherwise that would mean that even the smallest application such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">cd</span></strong><span class="koboSpan" id="kobo.351.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">exit</span></strong><span class="koboSpan" id="kobo.353.1"> should be considered as such. </span><span class="koboSpan" id="kobo.353.2">The term has been coined precisely to describe single applications that were in charge of too many business features, which made them too heavy to have a nice evolution or fit the use they were </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">designed for.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">The situation talked about in the articles on the so-called death of microservice architecture and going back to monolith simply do not talk about the right subject, which is the granularity of services. </span><span class="koboSpan" id="kobo.355.2">Sure, the very small grain of microservices did not satisfy their information system needs. </span><span class="koboSpan" id="kobo.355.3">But that simply means the grain was too fine. </span><span class="koboSpan" id="kobo.355.4">Going back to the coarsest grain one can have (the monolith) simply displays a lack of depth in the comprehension of the problem. </span><span class="koboSpan" id="kobo.355.5">An engineer approach to this would be to search for the right granularity of the services. </span><span class="koboSpan" id="kobo.355.6">As said in </span><a href="https://codeopinion.com/biggest-scam-in-software-dev-best-practices/"><span class="koboSpan" id="kobo.356.1">https://codeopinion.com/biggest-scam-in-software-dev-best-practices/</span></a><span class="koboSpan" id="kobo.357.1">, the choice is not only between “Amazon is doing it, so let’s do it” and “we are not Amazon so we should not do it” – knowledge of the business and analysis of the context only will tell you where you should place yourself between </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">the two.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">It just happens</span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.360.1"> that there is an existing design method called domain-driven design that is the perfect method to find out the right granularity of services for an information system. </span><span class="koboSpan" id="kobo.360.2">It also relates strongly to the principles of business/IT alignment, as it states how business domains can be cut into internally cohesive, externally low-coupled modules. </span><span class="koboSpan" id="kobo.360.3">Everything we will be doing in the design of our demo application will be an illustration of this research of the right granularity, base</span><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.361.1">d on the business </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">functional needs.</span></span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.363.1">Beware of unintended coupling</span></h2>
<p><span class="koboSpan" id="kobo.364.1">One last piece </span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.365.1">of advice on the separation of responsibilities (this first principle is definitely causing lots of discussions!): once you have established a clear cut of responsibilities based on the </span><strong class="bold"><span class="koboSpan" id="kobo.366.1">business capability map</span></strong><span class="koboSpan" id="kobo.367.1">, you</span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.368.1"> are not done with the separation of responsibilities, as it is very easy to recreate coupling afterward in the technological transformation of </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">the functions.</span></span></p>
<p><span class="koboSpan" id="kobo.370.1">I will give one simple example of such a problem because it is very representative of the trap I described. </span><span class="koboSpan" id="kobo.370.2">Imagine we create our demo application with an API for the books, an API for the book sales (possibly exposed under the same URL, but still independent in terms of contract), and an API for the authors. </span><span class="koboSpan" id="kobo.370.3">The director of the company may want, at some point, a report on how the geographical origin of the authors impacts the localization of their sales (maybe an author from Brittany will sell more in their region because their network of contacts is denser around them? </span><span class="koboSpan" id="kobo.370.4">Or perhaps it has no impact? </span><span class="koboSpan" id="kobo.370.5">Anyway, this might be interesting to analyze). </span><span class="koboSpan" id="kobo.370.6">This is a common issue with microservices, which are supposed to have their own persistence. </span><span class="koboSpan" id="kobo.370.7">In this case, how can we make links between data, just like we were creating </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">join</span></strong><span class="koboSpan" id="kobo.372.1"> operations when we added a single database? </span><span class="koboSpan" id="kobo.372.2">One of the standard approaches is to add a collecting data structure that gathers, indexes, and aggregates data from all the microservices and proposes a dedicated </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">/api/reporting</span></strong><span class="koboSpan" id="kobo.374.1"> service with its own </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">API contract.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">This service of course presents a level of coupling toward its source, but this can be made a lower level of coupling, for example, by keeping a local cache or mixing a subscribe approach to the data changes with a direct collection under a lower frequency to ensure that no signal has been lost and the data is reset at a controlled frequency. </span><span class="koboSpan" id="kobo.376.2">Also, it presents interesting functions that none of the atomic data services provide, such as indexing, the capacity of dynamic aggregation, and </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.377.1">so on. </span><strong class="bold"><span class="koboSpan" id="kobo.378.1">GraphQL</span></strong><span class="koboSpan" id="kobo.379.1"> is a nice protocol to expose such services, and </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.380.1">they integrate very well in a </span><strong class="bold"><span class="koboSpan" id="kobo.381.1">Command Query Responsibility </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.382.1">Segregation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.383.1"> architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.384.1">However, there</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.385.1"> might be an unintended coupling if the atomic service not only provides data for this reporting service but also starts consuming atomic data from it. </span><span class="koboSpan" id="kobo.385.2">And this can happen very quickly because the performance boost of an indexing engine is very appealing to developers. </span><span class="koboSpan" id="kobo.385.3">The problem is that this causes a circular functional dependency, which is already quite a problem, but also a higher level of coupling since, once this dependency is created, the atomic data service becomes suddenly coupled to each of the other ones. </span><span class="koboSpan" id="kobo.385.4">Of course, the coupling may remain low, but nonetheless, a link has been created and this is – in most cases I have seen – a real pain to come into </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">If you really need fast aggregated reads in an atomic service, you have to deal with this internally, by adding indexes on the dedicated persistency, for example. </span><span class="koboSpan" id="kobo.387.2">This may sound complicated if you see this nice indexing engine right on the other side of the service wall, but this is the price to pay to keep your system free from coupling and easy to evolve in time. </span><span class="koboSpan" id="kobo.387.3">Again, this is a compromise and if the architect decides the functional coupling is not a problem, you may save time by doing so. </span><span class="koboSpan" id="kobo.387.4">But this has to be a conscious (and </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">documented) compromise.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.389.1"><img alt="﻿Figure 6.5 – Reducing coupling strength" src="image/Figure_6.5_B21293.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.390.1">Figure 6.5 – Reducing coupling strength</span></p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.391.1">Wrapping up before going back to the demo</span></h1>
<p><span class="koboSpan" id="kobo.392.1">In this chapter, we have learned about the SOLID principles that can be applied to information systems (and not only object-oriented programming, as they were initially aimed at); the single responsibility principle and the interface segregation principle have been used to start a definition of the different API contracts we will need for our demo application. </span><span class="koboSpan" id="kobo.392.2">The open/closed principle will help to keep this API grammar free to evolve, and its evolution will have to follow the Liskov substitution principle for the system to evolve satisfyingly. </span><span class="koboSpan" id="kobo.392.3">Finally, dependency inversion has been demonstrated as the core principle behind contract-first API and the capacity to align the software implementations on the business-oriented functions, which is the main goal we seek in </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">In the next chapter, we will go one step further in the design of our demo application by defining its different components. </span><span class="koboSpan" id="kobo.394.2">This will help us to draw a perimeter of the first version we want to create in this book, but also to define more clearly the different parts of the application using a method that adapts to the depth </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">of decomposition.</span></span></p>
</div>
</body></html>