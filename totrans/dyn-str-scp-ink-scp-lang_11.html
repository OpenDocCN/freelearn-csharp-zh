<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer123">
			<h1 id="_idParaDest-138"><em class="italic"><a id="_idTextAnchor137"/>Chapter 9</em>: Story API – Observing and Reacting to Story Events</h1>
			<p>In this chapter, we will explore how changes in a running ink story can trigger events in Unity. We will learn how the <strong class="source-inline">ObserveVariable()</strong> and <strong class="source-inline">ObserveVariables()</strong> methods of the Story API, as provided by the ink-Unity Integration plugin, allow you to prepare functions to react to future events in Unity. We will begin by observing a single variable and then move on to learn how to watch multiple values. </p>
			<p>In <a href="B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123"><em class="italic">Chapter 8</em></a>, <em class="italic">Story API – Accessing ink Variables and Functions</em>, the focus was on controlling an ink story by calling its functions and changing its values from Unity. This chapter reverses the emphasis between the two systems. In this chapter, we will explore how narrative events, such as variables changing because of a player's choices, can be used to control what information is presented in Unity.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Listening for variable changes</li>
				<li>Dynamically responding to ink stories</li>
				<li>Observing multiple ink values</li>
			</ul>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor138"/>Technical requirements</h1>
			<p>The examples used in this chapter, in the <strong class="source-inline">*.ink</strong> files, can be found on GitHub at <a href="https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter9">https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter9</a>.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/>Listening for variable changes</h1>
			<p>Variables in ink are <a id="_idIndexMarker355"/>global. Once they are created, they can be accessed at any point in the story. In <a href="B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123"><em class="italic">Chapter 8</em></a>, <em class="italic">Story API – Accessing ink Variables and Functions</em>, we learned how this functionality can be used with the <strong class="source-inline">variablesState</strong> property to access or change their values. However, instead of directly interfering in a running ink from Unity, we can also wait for something to happen in ink and then react in Unity. The verb used for this type of approach, as part of the Story API, is called <em class="italic">observing</em>.</p>
			<p>When we observe an ink variable, we can write our own rules regarding what should happen when its value changes or meets a certain threshold. We are merely <em class="italic">observing</em> its value. What we do because of this observance is up to the developer.</p>
			<p>In this topic, we will explore the <strong class="source-inline">ObserveVariable()</strong> method.</p>
			<p class="callout-heading">Recommendation</p>
			<p class="callout">It is recommended that you create a new Unity 2D project for this topic. Instructions regarding how to create a new Unity project and import the ink-Unity Integration plugin can be found in <a href="B17597_06_Final_PG_ePub.xhtml#_idTextAnchor092"><em class="italic">Chapter 6</em></a>, <em class="italic">Adding and Working with the ink Unity Plugin.</em></p>
			<p>We will perform the following steps:</p>
			<ol>
				<li>In a new Unity project, using the 2D template with the ink-Unity Integration plugin imported, create a new, empty game object and name it <strong class="source-inline">InkStory</strong>. This game object will hold the <strong class="source-inline">script</strong> component and react to changes in the Ink code.</li>
				<li>Create a new Ink file and name it <strong class="source-inline">InkStoryStepCounter.ink</strong>.</li>
				<li>Open <strong class="source-inline">InkStoryStepCounter.ink</strong> for editing in Inky and update its contents to <strong class="source-inline">Example 1 (InkStoryStepCounter.ink).</strong></li>
				<li>Create a new <strong class="source-inline">script</strong> component inside the <strong class="source-inline">InkStory</strong> game object. Name the created file <strong class="source-inline">InkStoryScript.cs</strong>.</li>
				<li>Open <strong class="source-inline">InkStoryScript.cs</strong> for editing in Visual Studio.<p>Update <strong class="source-inline">InkStoryScript.cs</strong> to <strong class="source-inline">Example 1 (InkStoryScript.cs)</strong>.</p><p>The <strong class="source-inline">ObserveVariable()</strong> method<a id="_idIndexMarker356"/> is a new method introduced in this chapter and accepts two parameters. The first parameter is the name of a variable to observe and the second is a function or a method to call.</p><p>The code used in this example also incorporates a C# concept known as a <strong class="bold">lambda expression</strong>. Any <a id="_idIndexMarker357"/>function without a name in C# is a lambda expression. This allows you to write a function with its parameters and body, but without a name.</p><p>Putting the concepts together, the <strong class="source-inline">ObserveVariable()</strong> method watches a variable in ink. If its value changes at any point, the lambda expression will run. This operates outside the normal flow.</p></li>
				<li>Associate the compiled Ink JSON file.</li>
				<li>Run the project.</li>
			</ol>
			<p>When the project is run, the <strong class="bold">Console</strong> window will show a series of messages. The first message will show the text of the story, the second will show the value produced by the <strong class="source-inline">ObserveVariable()</strong> method, and the third will be the text produced as the first option chosen:</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="Images/Figure_9.1_B17597.jpg" alt="Figure 9.1 – The Text output is shown in order of execution in Unity" width="608" height="251"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – The Text output is shown in order of execution in Unity</p>
			<p>The reason why the second message shows the value before the third text of the option is because of the execution order. Within the running ink story, the <strong class="source-inline">ObserveVariable()</strong> method occurs <em class="italic">before</em> the text output is produced for the option and returned to Unity. The use of the delegated lambda expression occurs outside the normal flow of execution in this way. Whenever the value of the observed variable changes, the function is immediately called, regardless of any other code happening<a id="_idIndexMarker358"/> around it at the same time.</p>
			<p>In the next section, we will build on this pattern. Often, there are contexts in which Unity should only be told a variable has been changed when it happens. This frees up the execution time for other tasks in Unity and allows a developer to write more reactive code that only runs when needed.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor140"/>Dynamically responding to ink stories</h1>
			<p>In Unity, multiple <a id="_idIndexMarker359"/>methods are called as part of the normal execution cycle when a project runs. Often, methods such as <strong class="source-inline">Update()</strong>, a common part of behavior scripts in Unity, include many lines of code. Even a method such as <strong class="source-inline">FixedUpdate()</strong>, called at the end of the physics calculations for each cycle in a running project, might include multiple parts. Any code that depends on other systems, such as those communicating with ink, can also add extra time per cycle.</p>
			<p>The use of the <strong class="source-inline">ObserveVariable()</strong> method allows data from ink to only update Unity when needed. Because the Story API will only call the delegated function when necessary, Unity will also only get the data when there is a change it needs to know about when it needs to know about it. This will also happen outside the use of an <strong class="source-inline">Update()</strong> method or even a <strong class="source-inline">FixedUpdate()</strong> method in Unity.</p>
			<p>In this section, we will examine how the <strong class="source-inline">ObserveVariable()</strong> method operates outside of other methods as part of Unity. It will only call the delegated function when a value changes allowing a dynamic response in Unity.</p>
			<p>Return to the project created in the previous section, and perform the following steps:</p>
			<ol>
				<li value="1">Update the <strong class="source-inline">InkStoryScript.cs</strong> file to <strong class="source-inline">Example 2 (InkStoryScript.cs)</strong>.</li>
				<li>Within the <strong class="source-inline">Update()</strong> method, four different actions are taking place. <p>The <em class="italic">first</em> is the increase in the variable time with the most recent <strong class="source-inline">Time.deltaTime</strong>, which is the number of milliseconds between cycles as measured in a decimal (float) number. The <em class="italic">second</em> is a conversion between its float value into an integer. This operation removes the decimal part of the number. The <em class="italic">third</em> action is a<a id="_idIndexMarker360"/> mathematical operation called <strong class="bold">modulo</strong>. </p><p>In many<a id="_idIndexMarker361"/> programming languages, C# among them, the percentage symbol, <strong class="source-inline">%</strong>, can be used to find the remainder from division. This operation is called <em class="italic">modulo</em>. However, many programming languages also use the term <em class="italic">remainder operator</em>. When this operation is performed, it will determine how many times one number can be divided into another. In this case, using the remainder of <strong class="source-inline">60</strong>, the <strong class="source-inline">seconds</strong> variable will always be equal to the number of seconds that have passed since the project began, as divided by the <strong class="source-inline">time</strong> variable.</p><p>The <em class="italic">fourth</em> action within the <strong class="source-inline">Update()</strong> method is the assignment of the <strong class="source-inline">seconds</strong> variable to the number of seconds, as defined by the previously explained actions. In every cycle in Unity, this number will be updated, and the <strong class="source-inline">seconds</strong> variable will always be up to date.</p><p>One final action takes place in the delegated function, that is, the use of the <strong class="source-inline">Destroy()</strong> method. Within the code, once the value of the <strong class="source-inline">steps</strong> ink variable is equal to <strong class="source-inline">3</strong>, as determined by Unity, it will remove a button from the scene. This helps to keep the control of the button connected to a value changed outside of Unity. Once the ink variable changes and is reported to Unity, the button is removed.</p><p>On the last line of the <strong class="source-inline">Start()</strong> method, a button is given a listener function for its <strong class="source-inline">onClick</strong> event. When the button is clicked on, any functions associated with the listeners will be called. In this example, clicking on the button will call the new <strong class="source-inline">TakeStep()</strong> method. This will load the next text content up to the next weave encountered in the ink code and then choose the first (<strong class="source-inline">0</strong>) option within the weave. This will cause the ink code to loop internally.</p><p>With the code created, two more steps are required before the project can be played. First, a new <strong class="source-inline">Button</strong> game object needs to be added to the project. Then, once the <strong class="source-inline">Button</strong> game object exists, it must be associated with the <strong class="source-inline">InkStory</strong> property <a id="_idIndexMarker362"/>as part of the new code.</p></li>
				<li>Create a new <strong class="source-inline">Button</strong> game object in Unity.</li>
				<li>Associate the <strong class="source-inline">Button</strong> game object with the <strong class="source-inline">Button Step</strong> property.</li>
				<li>Play the project.</li>
				<li>The created <strong class="source-inline">Button</strong> game object appears at the bottom of the scene. Clicking on the <strong class="source-inline">Button</strong> game object four times will cause it to disappear, and a message will appear in the <strong class="bold">Console</strong> window:<div id="_idContainer121" class="IMG---Figure"><img src="Images/Figure_9.2_B17597.jpg" alt="Figure 9.2 – A message in the Console window generated by a delegated function&#13;&#10;" width="457" height="137"/></div><p class="figure-caption">Figure 9.2 – A message in the Console window generated by a delegated function</p></li>
				<li>Stop the project.</li>
			</ol>
			<p>When the project first started, the <strong class="source-inline">Update()</strong> method of the code was called during each cycle. Internally, it updated the <strong class="source-inline">time</strong> and <strong class="source-inline">seconds</strong> variables in the Unity code. Whenever the <strong class="source-inline">Button</strong> game object was clicked on, it progressed the ink code, which looped itself internally. Because of the use of the <strong class="source-inline">ObserveVariable()</strong> method, any time the ink variable steps were updated, it called the delegated function and tested the new value passed to it. Once it reached <strong class="source-inline">3</strong> (based on a total of four clicks to move it from <strong class="source-inline">0</strong> to <strong class="source-inline">3</strong>), the delegated function created a message in the <strong class="bold">Console</strong> window and destroyed the <strong class="source-inline">Button</strong> game object.</p>
			<p>The example used in this section follows a common pattern where Unity performs its own calculations as part of a method, such as <strong class="source-inline">Update()</strong>, and dynamically responds to changes in an ink story as they happen. Instead of potentially checking the <strong class="source-inline">steps</strong> ink variable as part of the <strong class="source-inline">variablesState</strong> property every cycle, and wasting time if the value has not changed, the delegated function allows Unity to only act when needed. For more complicated projects, this is the preferred approach, and generally, it produces faster projects.</p>
			<p>More than a single variable can be observed in ink. Depending on the complexity of design, a Unity<a id="_idIndexMarker363"/> project might be interested in observing multiple ink values and updating onscreen areas with information on story progression or the current statistics of the player. For these contexts, a different method is needed: <strong class="source-inline">ObserveVariables()</strong>. In the next section, we will demonstrate how to work with this method.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor141"/>Observing multiple ink values</h1>
			<p>Along with<a id="_idIndexMarker364"/> the <strong class="source-inline">ObserveVariable()</strong> method is a sister method named <strong class="source-inline">ObserveVariables()</strong>. However, while the <strong class="source-inline">ObserveVariable()</strong> method accepts the name of a variable and a delegate function, the <strong class="source-inline">ObserveVariables()</strong> method accepts an <strong class="source-inline">IList&lt;string&gt;</strong> of variable names and a delegate function. Instead of responding when a single variable is changed, its delegate function is called when any of the variables passed as a list to the method are changed. While slightly more complicated to set up, the <strong class="source-inline">ObserveVariables()</strong> method provides the functionality to observe multiple ink variables.</p>
			<p class="callout-heading">Recommendation</p>
			<p class="callout">It is recommended that you create a new Unity 2D project for this section. Instructions regarding how to create a new Unity project and import the ink-Unity Integration plugin can be found in <a href="B17597_06_Final_PG_ePub.xhtml#_idTextAnchor092"><em class="italic">Chapter 6</em></a>, <em class="italic">Adding and Working with the ink-Unity Integration Plugin</em>.</p>
			<p>Perform the following steps:</p>
			<ol>
				<li value="1">In a new Unity 2D project with the ink-Unity Integration plugin imported, create a new, empty game object and name it <strong class="source-inline">InkStory</strong>. This game object will hold the <strong class="source-inline">Script</strong> component and react to any changes in the ink code.</li>
				<li>Create a new ink file and name it <strong class="source-inline">InkStoryPlayerStatistics.ink</strong>.</li>
				<li>Open the <strong class="source-inline">InkStoryPlayerStatistics.ink</strong> file for editing in Inky and update its content to <strong class="source-inline">Example</strong> <strong class="source-inline">3</strong> <strong class="source-inline">(InkStoryPlayerStatistics.ink)</strong>.</li>
				<li>Create a<a id="_idIndexMarker365"/> new <strong class="source-inline">script</strong> component inside the <strong class="source-inline">InkStory</strong> game object. Name the created file <strong class="source-inline">InkStoryPlayerStatisticsScript.cs</strong>.</li>
				<li>Open the created <strong class="source-inline">InkStoryPlayerStatisticsScript.cs</strong> file in Visual Studio. Update it to <strong class="source-inline">Example</strong> <strong class="source-inline">3</strong> <strong class="source-inline">(</strong> <strong class="source-inline">InkStoryPlayerStatisticsScript.cs)</strong>.<p>The updated code begins by setting up the Story API. It does this by creating a new object based on the <strong class="source-inline">Story</strong> class. Next, a <strong class="source-inline">List&lt;string&gt;</strong> is created. This is used as a <em class="italic">list</em> of the variable names based on their string values. After creating the list, two values are added to it in an order, based on the names of the <strong class="source-inline">mental_health</strong> and <strong class="source-inline">physcial_health</strong> ink variables. This created list is then passed to the <strong class="source-inline">ObserveVariables()</strong> method, and a second parameter, that is, a delegated function in the form of a lambda expression, is used.</p><p>The <strong class="source-inline">Start()</strong> method ends with a call to the created <strong class="source-inline">ProgressStory()</strong> method. Inside this created method, the story is progressed programmatically by using the <strong class="source-inline">ContinueMaximally()</strong> and <strong class="source-inline">ChooseChoiceIndex()</strong> methods. The first method loads all of the text content up to the first weave, while the second method selects the first (<strong class="source-inline">0</strong>) option in the weave. The final, second use of the <strong class="source-inline">ContinueMaximally()</strong> method loads the resulting text within the Ink code and is needed to cause the variable to change.</p></li>
				<li>Associate the compiled Ink JSON file with the <strong class="source-inline">InkStory</strong> game object.</li>
				<li>Run the project.<p>When the project starts, it will programmatically progress the ink story used within this section. As a result, it will produce a message in the <strong class="bold">Console</strong> window:</p><div id="_idContainer122" class="IMG---Figure"><img src="Images/Figure_9.3_B17597.jpg" alt="Figure 9.3 – The Console window showing changes to the mental_health ink variable&#13;&#10;" width="624" height="156"/></div><p class="figure-caption">Figure 9.3 – The Console window showing changes to the mental_health ink variable</p><p>Two different <a id="_idIndexMarker366"/>ink variables were added to the <strong class="source-inline">List&lt;string&gt;</strong> that was passed to the <strong class="source-inline">ObserveVariables()</strong> method. However, only one of them was changed because of the ink story progression. As a result, the variable changed, and its new value was passed back to Unity. When the change happened, the delegated function was called with the second parameter, the name of the variable (<strong class="source-inline">variableName</strong>), and its new value (<strong class="source-inline">newValue</strong>).</p><p>The <strong class="source-inline">ObserveVariables()</strong> method works similarly to its sister <strong class="source-inline">ObserveVariable()</strong> method. Both respond with the name of the variable and the changed value as soon as they happen in ink. The major difference between them is in their first parameter. The <strong class="source-inline">ObserveVariables()</strong> method accepts the name of a single variable name in ink, and the <strong class="source-inline">ObserveVariables()</strong> method is a list of which variables to observe and then respond to using the delegated function.</p></li>
				<li>Stop the project.</li>
			</ol>
			<p>This section focused on the use of the <strong class="source-inline">ObserveVariables()</strong> method, echoing the pattern in the previous section where we used the <strong class="source-inline">ObserveVariable()</strong> sister method. In general, either approach offers a way to control how Unity reacts to ink, shifting the control of information between the two systems. Along with the <strong class="source-inline">variablesState</strong> property, the different approaches in this chapter, as covered in <a href="B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123"><em class="italic">Chapter 8</em></a>, <em class="italic">Story API – Accessing ink Variables and Functions</em>, provide access to the variables in ink. They can be used in a project, depending on the needs of the developer, to either <a id="_idIndexMarker367"/>drive a Unity project more from the ink side or directly change values on the ink side from the Unity code as needed.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor142"/>Summary</h1>
			<p>In this chapter, we explored multiple examples. First, we started with the <strong class="source-inline">ObserveVariable()</strong> method and watched only one variable. In the second section, we dynamically responded to ink stories in Unity. Using delegated functions, we learned how parts of a piece of code will only be called when an ink variable changes. In the third section, we looked at the use of the <strong class="source-inline">ObserveVariables()</strong> method to watch multiple variables specified by name.</p>
			<p>In <a href="B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145"><em class="italic">Chapter 10</em></a>, <em class="italic">Dialogue Systems with ink</em>, we will move away from the individual properties and methods of the Story API and start to combine functionality into more complex use cases. Combining parts of the Unity API introduced in <a href="B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 7</em></a>, <em class="italic">Unity API – Making Choices and Story Progression</em>, along with the <strong class="source-inline">ObserveVariable()</strong> method covered in this chapter, we will examine how to create different dialogue systems.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor143"/>Questions</h1>
			<ol>
				<li value="1">What is the action of <em class="italic">observing</em>, and how does it apply to the methods provided by the <strong class="source-inline">Story</strong> class?</li>
				<li>What roles do delegated functions serve when working with the <strong class="source-inline">ObserveVariable()</strong> and <strong class="source-inline">ObserveVariables()</strong> methods?</li>
				<li>What is the difference between the <strong class="source-inline">ObserveVariable()</strong> method and the <strong class="source-inline">ObserveVariables()</strong> method?</li>
				<li>What is the difference between accessing ink variables using the <strong class="source-inline">variablesState</strong> property and using the <strong class="source-inline">ObserveVariable()</strong> method or the <strong class="source-inline">ObserveVariables()</strong> method?</li>
			</ol>
		</div>
	</div></body></html>