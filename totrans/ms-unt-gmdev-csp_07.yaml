- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Engaging Game Mechanics Using C# in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [*Chapter 4*](B22017_04.xhtml#_idTextAnchor058), where we invite
    you into the dynamic world of game development. As you delve into this chapter,
    your journey will begin by exploring the foundational principles that drive successful
    game mechanics. This initial step involves an introduction to game mechanics,
    allowing you to grasp the essential concepts that form the backbone of captivating
    gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, you’ll seamlessly transition into the realm of player behavior
    and AI before delving into the topics of challenge and reward systems. This journey
    unravels the art of crafting interactive and responsive gaming experiences.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be equipped with not only theoretical insights
    but also practical skills to shape immersive gaming adventures in Unity using
    the power of C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing game mechanics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing player behavior and AI logic using C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing challenge and reward systems using C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can access the code samples and project files on our dedicated GitHub repository:
    [https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2004](https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2004).'
  prefs: []
  type: TYPE_NORMAL
- en: Clone or download the repository so that you have easy access to the code demonstrated
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing game mechanics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Game mechanics** are the rules and systems that shape how a game is played.
    Think of them as the behind-the-scenes mechanisms that define the player’s experience.
    They are vital for crafting engaging gameplay, influencing everything from movement
    and combat to how a story unfolds. Successful games, such as *Mario* with its
    jumping mechanics, or *Tetris* with its block arrangement challenges, showcase
    how well-crafted mechanics can create memorable and enjoyable experiences for
    players.'
  prefs: []
  type: TYPE_NORMAL
- en: Game mechanics go beyond just making a game work; they subtly tell stories by
    how players interact. Whether it’s in fighting games with complex combat or in
    platformers with puzzle-solving, these mechanics add to the overall story. When
    players follow the game’s rules, they’re not just watching; they become part of
    the story.
  prefs: []
  type: TYPE_NORMAL
- en: So, understanding and creating game mechanics is like becoming skilled at interactive
    storytelling. Each button that’s pressed or moved in the game helps the story
    move along, making every playthrough a unique and personal journey.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will talk about the essential principles you need
    to know about game mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: Essential principles of game mechanics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s get into the important stuff that makes games enjoyable. We’re talking
    about the basic rules that shape how players have fun. It’s all about finding
    the right balance, giving feedback, and making sure players feel in control. These
    simple things turn games into exciting adventures where every move adds to the
    fun.
  prefs: []
  type: TYPE_NORMAL
- en: Balance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Balance** in games is like ensuring everyone gets a fair shot at having fun.
    Picture a game where one character is super strong, making it impossible for others
    to enjoy. That wouldn’t be fair, right? Game developers work hard to create a
    balanced experience where each player or character has a chance to shine. Take
    *Overwatch*, for example. In this game, each hero boasts unique abilities, and
    no one is overwhelmingly powerful or weak. It’s this careful balance that ensures
    a level playing field, allowing everyone to have a good time and contribute to
    the game’s excitement.'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, balance goes beyond characters; it extends to the overall gameplay.
    Imagine a game with levels that are either too easy or impossibly hard – players
    would quickly lose interest. Achieving balance in challenges, difficulty, and
    rewards keeps players engaged. Games that strike this delicate balance provide
    a satisfying and enjoyable experience for players of all skill levels, making
    them want to keep playing and exploring what the game has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Feedback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the world of gaming, **feedback** is the game’s way of talking to you, letting
    you know how you’re doing. It’s like a pat on the back when you do something right
    or a gentle nudge when you could improve. In *Minecraft*, for instance, when you
    successfully mine resources, a satisfying sound accompanies the action. That sound
    is feedback, a small celebration telling you that you’ve accomplished a task.
  prefs: []
  type: TYPE_NORMAL
- en: Think about playing a racing game without any feedback – no cheering crowd,
    no speedometer ticking up – it would be a bit strange, right? Good feedback, whether
    it’s visual, auditory, or haptic, is essential for making players feel accomplished
    and guiding them through the game’s challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, feedback extends to storytelling in games. Choices you make should
    have consequences, and the game should let you know how your decisions impact
    the story. Effective feedback creates a dynamic connection between the player
    and the game world, making every action feel meaningful. Whether it’s triumphant
    music after a successful quest or a subtle change in the environment based on
    your decisions, feedback adds depth to the gaming experience, ensuring players
    stay engaged and invested in the virtual world they’re exploring.
  prefs: []
  type: TYPE_NORMAL
- en: Player agency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Player agency** is like having a steering wheel in a game – you get to make
    choices and have control over your virtual adventure. In *The Elder Scrolls V:
    Skyrim*, this principal shines brightly. Right from the start, you decide who
    your character is going to be. Do you want to be a brave warrior, a sneaky thief,
    or a powerful wizard? The game doesn’t force you down a specific path; instead,
    it lets you carve out your own story.'
  prefs: []
  type: TYPE_NORMAL
- en: This freedom to make choices extends beyond character creation. As you progress
    through the game, you encounter various quests and challenges, and here, again,
    player agency takes center stage. You can decide how to approach a situation –
    do you want to negotiate, fight, or sneak past enemies? Your choices influence
    not just the immediate outcome but also the overall story. Your version of *Skyrim*
    might be entirely different from someone else’s because player agency allows for
    diverse experiences.
  prefs: []
  type: TYPE_NORMAL
- en: Having player agency transforms a game into more than just a set path with predetermined
    outcomes. It transforms it into your story, where your decisions matter, and the
    game adapts to your choices. This sense of control and the ability to shape your
    unique adventure is what makes player agency a key principle in creating immersive
    and personally meaningful gaming experiences.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we are going to understand the relationship between
    code and game mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: The connection between code and game mechanics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, here’s the cool part – the code is what turns ideas into action in the
    game. It’s like a rulebook that tells the game what to do. If you want to create
    a game where players can shoot lasers, you’d write code to make it happen. So,
    the relationship between code and game mechanics is like a chef’s recipe for a
    delicious meal – the code guides the game to do exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding these coding basics is like having the keys to the game-making
    kingdom. It allows you to bring your game ideas to life and create all sorts of
    cool stuff. Plus, the more you understand C#, the more you can make your games
    do awesome things. So, get ready to dive into the world of coding in this chapter
    – it’s not as tricky as it sounds, and it’s the secret sauce that makes games
    so much fun to play!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing player behavior and AI logic using C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll be getting into how games are made, looking at how players
    act and how computer-controlled characters (we call it AI) think in games. Figuring
    out how players act and how game characters react is a big deal in making games
    fun. It’s like giving players a script to follow, just like actors in a play.
    Players bring the game to life, a bit like how actors make a story interesting.
    We’ll look at different types of games, checking out how players act in all sorts
    of situations, from big adventures to tactical fights.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we’ll check out AI, the smart computer stuff that makes game enemies,
    friends, and other characters feel real. AI isn’t just code; it’s like magic that
    makes challenges exciting, enemies tricky, and friends helpful. We’ll explain
    the basic ideas behind this digital magic, kind of like understanding the cues
    a conductor gives to an orchestra, guiding all the actions and reactions in a
    game.
  prefs: []
  type: TYPE_NORMAL
- en: So, we’re on a journey to make player behavior and AI logic less mysterious
    using C# – a fancy way to talk to computers. You’ll be all set to make games that
    feel real, keeping players interested and making your game super exciting!
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding player behavior design**: In the realm of player behavior design,
    crafting a responsive game involves the fundamental aspect of **health management**.
    **Health**, being a universal concept for both players and enemies, is a core
    behavior that greatly influences the overall gaming experience. To achieve a modular
    and extensible system, we must introduce an **IHealth** interface that encapsulates
    essential functions, such as tracking maximum health, current health, taking damage,
    and healing. By adopting this interface, we can establish a unified approach to
    health management that applies to both players and enemies. This not only streamlines
    the code base but also allows for easy expansion and modification as the game
    evolves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shooting mechanics**: In addition to health, we’ll delve into shooting mechanics,
    a pivotal player behavior in a shooting game. Rather than a simplistic shooting
    script, we’ll opt for a modular approach, creating separate components for bullets,
    projectiles, and weapons. This modular design enables flexibility and scalability,
    making it easier to introduce new weapons, tweak projectile behaviors, and enhance
    overall gameplay dynamics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Introduction to AI logic**: Transitioning to AI logic, we’ll explore fundamental
    concepts that breathe life into in-game adversaries. Basic AI principles encompass
    understanding the role of AI in creating dynamic and challenging gameplay. The
    AI system becomes a crucial component in determining enemy behaviors, ranging
    from simple wandering to complex attack patterns. By delving into these concepts,
    we’ll gain insights into the decision-making processes that drive AI-controlled
    entities, contributing to the overall richness of the gaming experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coding player behavior and AI**: Moving from theory to practice, we’ll embark
    on the practical implementation of player behavior and AI logic using C# scripts.
    The **IHealth** and **IDamage** interfaces become the cornerstone for implementing
    health-related functionalities, ensuring a consistent and manageable approach
    across diverse game elements. The modular shooting system will take shape as we
    learn to handle bullets, projectiles, and weapons separately, promoting code reusability
    and maintainability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To reinforce learning, we’ll engage in hands-on demonstrations, showcasing the
    step-by-step creation of C# scripts for player behavior and AI logic in the subsequent
    sections. We’ll gain proficiency in designing and implementing responsive player
    behaviors, fostering an understanding of how to bring dynamic AI characters to
    life within the Unity game development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by writing the `IHealth` interface and establishing the fundamental
    logic for it.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the IHealth and IDamage interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following code block, we’ve introduced the `IHealth` interface, which
    incorporates properties for maximum and current health, along with essential functions
    for setting maximum health, inflicting damage, and facilitating healing. Here,
    we’ll create an interface to manage the health logic throughout the entire game.
    I’ve designed it so that it oversees the health of each entity once they implement
    this interface. This approach will simplify communication between entities and
    prove beneficial when we also create the `IDamage` interface. Implementing `IDamage`
    in components responsible for dealing damage will allow us to affect the health
    component seamlessly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create the `IDamage` interface, which will feature a central
    function for dealing damage. Subsequent classes will implement this interface,
    handling damage calculations internally and conveying the resulting damage value
    to other classes, as demonstrated in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must integrate the `IHealth` interface into the player. Therefore,
    we will generate the `PlayerHealth` component and affix it to the player’s `GameObject`.
    The `PlayerHealth` class will manage all functions related to the player’s health,
    including setting the maximum health and processing damage. When the player’s
    health falls to zero or below, the player dies. It’s designed as a separate class
    that you attach to the player’s GameObject, facilitating communication with enemies,
    as illustrated in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, I’ve included the required variables related to the
    player’s health and healing. Additionally, a coroutine will ensure the player
    heals gradually within the `PlayerHealth` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a look at the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OnDestroy**: This method ensures that the healing coroutine is stopped when
    the player object is destroyed to prevent memory leaks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start**: This method initializes the player’s health parameters, sets their
    maximum health, creates a **WaitForSeconds** instance for healing intervals, and
    starts the healing coroutine:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TakeDamage**: This method handles the logic for deducting health from the
    player when they take damage. It also checks if the player’s health has reached
    zero, triggering the **onPlayerDied** event if necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SetMaxHealth**: This method sets the maximum health of the player to the
    specified starting maximum health value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Heal**: This method restores the player’s health. It increments the current
    health by the specified healing amount and ensures that the player’s current health
    does not exceed the maximum health.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**StartHealingOverTime**: This method initiates the healing coroutine that’s
    responsible for gradually restoring the player’s health over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HealOverTime**: This coroutine runs indefinitely, waiting for the specified
    healing interval and then invoking the **Heal** method to restore the player’s
    health.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s examine the `PlayerCollision` component and understand how the player
    incurs damage. The following code block demonstrates the process of the player
    taking damage either directly from the enemy or from their projectiles. This class
    acts as a bridge between the player’s health component and the `IDamage` interface
    of the colliding object. We can utilize `PlayerHealth` and obtain damage through
    the `IDamage` interface by using the `OnCollisionEnter` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s look at the different variables we used here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**private PlayerHealth playerHealth;**: This is a reference to the **PlayerHealth**
    component that’s attached to the same GameObject. This component manages the health
    of the player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**private IDamage enemyDamage;**: This is an interface reference for handling
    damage inflicted by enemies or enemy projectiles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start**: This method retrieves the **PlayerHealth** component that’s attached
    to the same GameObject during initialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OnCollisionEnter**: This method is invoked automatically when a collision
    occurs that involves the GameObject. It checks if the collision involves an enemy
    or an enemy projectile by comparing tags. If the collision involves an enemy or
    an enemy projectile, it attempts to retrieve the **IDamage** component from the
    colliding object using **TryGetComponent**. If successful, it invokes the **TakeDamage**
    method of the **PlayerHealth** component to apply damage to the player’s health.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, this script handles collisions between the player character and enemy
    entities or enemy projectiles. Upon collision, it retrieves the damage value from
    the colliding object and applies it to the player’s health, ensuring proper damage
    management in the game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore how the player engages in shooting enemies.
    However, before delving into that, we’ll implement a shoot system to ensure both
    the player and the enemy can make use of it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a shoot system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll create classes for shooting. Here, we’ll incorporate
    the `IDamage` interface into the `BaseProjectile` class, which serves as the foundation
    for all ammunition types. This allows us to compute the damage that will be applied
    to the health component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we’re configuring the damage value, which will
    be calculated for the player or enemies. This is a general system that can be
    applied to all objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the variables that were used here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**private float damage;**: This variable stores the damage value associated
    with the projectile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public virtual void SetDamageValue(float value)**: This method allows subclasses
    to set the damage value for the projectile. It takes a float parameter value representing
    the damage to be set. When called, it assigns the provided value to the damage
    variable. The **virtual** keyword indicates that this method can be overridden
    by subclasses to provide specialized behavior if needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GetDamageValue Method**: This method retrieves the damage value of the projectile.
    It simply returns the value stored in the damage variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, this abstract class provides a blueprint for projectile objects in
    the game. Subclasses can inherit from this class and customize the behavior of
    projectiles by overriding the `SetDamageValue` method or adding additional functionality
    as needed. The `GetDamageValue` method allows other game components to access
    the damage value of projectiles when needed, enabling consistent damage handling
    throughout the game.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can create the `BaseWeapon` script, which is versatile enough to be
    utilized by both players and enemies, considering that enemies will also possess
    weapons. Each weapon will be associated with an attached projectile, allowing
    for the creation of various projectile types.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, there is the concept of `weaponPower`, a variable that varies
    from one weapon to another, influencing the applied damage. `muzzleTransform`
    serves as the point for shooting projectiles, and `projectileForce` dictates the
    movement of the projectile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we must define the `Shoot` function, as illustrated in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the serialized fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**protected BaseProjectile attachedProjectile**: This refers to the type of
    projectile attached to the weapon. It is serialized to allow assignment in Unity’s
    **Inspector** view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**protected float weaponPower**: This refers to the power of the weapon. It
    is serialized to allow for adjustments in the **Inspector** view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**protected Transform muzzleTransform**: This refers to the position where
    projectiles spawn, typically the muzzle of the weapon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**protected float projectileForce**: This refers to the force that’s applied
    to the projectile when it’s shot from the weapon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shoot**: This method is responsible for shooting the weapon. First, it attempts
    to get a pooled projectile object from Object Pool Manager. If a projectile object
    is retrieved, it sets its position to the muzzle of the weapon and adds force
    to propel it forward. This method also modifies the fire damage by adding the
    weapon’s power to it. Finally, it applies the modified damage and any other logic
    to the projectile, potentially by implementing an **IDamage** interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, this abstract class provides a foundation for implementing different
    types of weapons in the game. Subclasses can inherit from this class to create
    specific weapon types and customize their behavior as needed. The `Shoot` method
    handles the spawning and firing of projectiles, allowing for flexible and dynamic
    weapon functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block provides an example of utilizing `BaseWeapon` with
    the `SimpleGun` class. We’re going to use it with the player for shooting enemies,
    so it will be used as the player’s weapon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SimpleGun**: This class represents a specific type of gun in the game. It
    inherits from the **BaseWeapon** class, indicating that it shares characteristics
    and functionality with other weapons but may have specialized behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Override Shoot**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public override void Shoot(float fireDamage)**: This method overrides the
    **Shoot** method defined in the **BaseWeapon** class'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **base.Shoot(fireDamage)** statement calls the **Shoot** method from the
    base class (**BaseWeapon**), allowing the gun to perform the standard shooting
    behavior defined in the base class
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, the `SimpleGun` class extends the functionality of the `BaseWeapon`
    class by providing its own implementation of the `Shoot` method. This allows for
    specialized behavior while leveraging the common functionality provided by the
    base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s present the `PlayerShoot` component, which encompasses the shooting
    logic. In this context, the player awaits input actions and possesses the current
    weapon. In [*Chapter 6*](B22017_06.xhtml#_idTextAnchor098), which focuses on data
    handling, we’ll create scriptable objects for weapon statistics. This way, we
    can substitute the weapon’s power with the weapon’s stats, utilizing the power
    derived from it. We can also make different stats for the same weapon, as illustrated
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**onFire Event**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public static UnityAction onFire = delegate { };**: This static event is
    triggered whenever the player fires a shot. Other scripts can subscribe to this
    event to perform actions when the player shoots.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serialized fields**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**currentWeapon**: This field holds a reference to the current weapon the player
    is using'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fireDamage**: This field represents the damage value of the player’s shots'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**shootingInterval**: This field specifies the time interval between consecutive
    shots'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event subscriptions**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OnEnable()**: Subscribes the **OnShootFire** method to the **onShoot** event
    when the object is enabled'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OnDisable()**: Unsubscribes the **OnShootFire** method from the **onShoot**
    event when the object is disabled'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OnShootFire**: This method is invoked when the player performs a shoot action
    (**onShoot event**). It checks if enough time has passed since the last shot.
    If so, it triggers the **Shoot** method of the current weapon, resets the shot
    timer, and invokes the **onFire** event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, the `PlayerShoot` class facilitates player shooting mechanics by controlling
    the shooting interval, managing events for shooting actions, and delegating the
    shooting logic to the current weapon.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you assign distinct tags to projectiles associated with both
    the player and the enemies. This prevents conflicts when they collide with each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the player possesses the capability to both shoot and endure damage.
    In the following subsection, we will delve into the AI logic for our game.
  prefs: []
  type: TYPE_NORMAL
- en: Delving into the AI logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Welcome to the world of **AI logic**! In this section, we’ll explore the algorithms
    and decision-making processes that bring intelligence to our game characters.
    We’ll discover how AI logic enhances navigation, strategy, and dynamic interactions,
    elevating the overall gaming experience. Join us as we unravel the secrets behind
    crafting smart behaviors for a more immersive virtual world. Plus, we’ll delve
    into the implementation of a finite state machine to create distinct states for
    all enemies, allowing seamless transitions between behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the upcoming steps, we’ll integrate the `NavMesh` package into our project.
    However, before delving into AI logic, it’s essential to include the navigation
    package in the project. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Before Unity 2022, navigation was pre-implemented; however, starting from Unity
    2022, it must be added via Package Manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Access **Package Manager** to install the **AI Navigation** package, as shown
    in *Figure 4**.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Installing AI Navigation via Package Manager](img/B22017_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Installing AI Navigation via Package Manager
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the installation, you’ll notice a new menu that allows you to toggle
    the visibility of **NavMesh** surfaces and access other options concerning **AI
    Navigation**. This menu is integrated into the *scene toolbar*, as illustrated
    in *Figure 4**.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The AI Navigation menu in the Scene view](img/B22017_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The AI Navigation menu in the Scene view
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading
  prefs: []
  type: TYPE_NORMAL
- en: 'You can explore the **AI Navigation** settings or find more information in
    the official Unity documentation: [https://docs.unity3d.com/Packages/com.unity.ai.navigation@1.1/manual/index.html](https://docs.unity3d.com/Packages/com.unity.ai.navigation@1.1/manual/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin utilizing this feature, we’ll need to incorporate a **NavMesh Surface**
    property into the scene. You can choose this from the **Create** menu, as shown
    in *Figure 4**.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Choosing NavMesh Surface from the Create menu](img/B22017_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Choosing NavMesh Surface from the Create menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Subsequently, **NavMesh Surface** will be included, at which point you can
    proceed to **Bake** the surface. This refers to the process of precomputing and
    storing navigation data for AI pathfinding, as demonstrated in *Figure 4**.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The Bake action in the NavMeshSurface component](img/B22017_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – The Bake action in the NavMeshSurface component
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Before initiating the baking process, it’s crucial to remove the player and
    dynamic objects to prevent the creation of empty spaces in the resulting baking.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also include additional AI agents by navigating to the **Navigation**
    tab under **Window** in the top bar. Choose **AI** and then **Navigation**, avoiding
    the **Navigation (Obsolete)** option, as illustrated in *Figure 4**.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Selecting Navigation](img/B22017_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Selecting Navigation
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Navigation** tab, you have the option to include more **Agents** with
    various settings, allowing for increased diversity in enemy behavior, as depicted
    in *Figure 4**.6*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Adding more agents via the Navigation tab](img/B22017_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Adding more agents via the Navigation tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you have the flexibility to introduce more **Areas**, providing
    variations in your gameplay. As shown in the following screenshot, you can designate
    areas as **Walkable**, **Not Walkable**, or even as **Jump** areas, tailoring
    them to the specific requirements of your game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Areas in the Navigation tab](img/B22017_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Areas in the Navigation tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve familiarized ourselves with adding additional areas or agents,
    we won’t be making further modifications to them. I’ve mentioned them for informational
    purposes only. Now, let’s proceed with integrating AI into our game. To do so,
    we must attach the **Nav Mesh Agent** component to the enemies to enable navigation,
    as illustrated in *Figure 4**.8*. We have the flexibility to adjust values tailored
    to our game, such as changing the speed and when the AI will stop when the AI
    has reached its goal. For further details, please refer to the official *Unity
    documentation*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.8 – The Nav Mesh Agent component for one of the enemies](img/B22017_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – The Nav Mesh Agent component for one of the enemies
  prefs: []
  type: TYPE_NORMAL
- en: After installing the package, we’ll kick off the AI logic. We’ll begin by establishing
    the `BaseEnemy` class and laying down the foundation for the state system since
    we intend to construct a finite state machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the interface for states. The foundational structure is provided
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**void** **EnterState(BaseEnemy enemy)**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method is responsible for setting up the initial conditions and behaviors
    when the enemy enters this state. It takes a **BaseEnemy** object as a parameter,
    allowing us to access the enemy’s properties and methods.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**void** **UpdateState(BaseEnemy enemy)**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method is called repeatedly while the enemy is in this state. It defines
    the logic and actions that the enemy should perform during this state. Again,
    it takes a **BaseEnemy** object as a parameter to manipulate the enemy’s behavior.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**void** **ExitState(BaseEnemy enemy)**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method is called when the enemy exits this state. It is responsible for
    cleaning up any resources or resetting any variables associated with this state.
    As with the other methods, it also accepts a **BaseEnemy** object parameter.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: By implementing this interface, different classes representing specific enemy
    states can define their unique behavior for entering, updating, and exiting those
    states. This approach allows for modular and organized management of enemy behavior,
    making it easier to add, remove, or modify states as needed within the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move on to creating enemy components, starting with: `EnemyHealth`. This
    component will integrate the `IHealth` interface and handle all health-related
    logic for enemies. Check out the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s understand the `EnemyHealth` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '**startingMaxHealth**: Default starting maximum health for the enemy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**healAmount**: Amount of healing per interval'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**healInterval**: Time interval for healing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**healIntervalWait**: Reusable **WaitForSeconds** instance for healing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**healOverTimeCoroutine**: Coroutine for healing over time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**maxHealth**: Maximum health of the enemy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**currentHealth**: Current health of the enemy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TakeDamage(float damage)**: Handles damage taken by the enemy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SetMaxHealth()**: Sets the maximum health of the enemy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Heal()**: Heals the enemy over time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**StartHealingOverTime()**: Starts the coroutine for healing over time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HealOverTime()**: The coroutine method for healing over time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next up is the `EnemyAnimations` component, which is responsible for managing
    the animations of the enemy. Let’s delve into its code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, `StartAttackAnimations()` and `StopAttackAnimations()` manage attack animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll implement the collision logic for the enemy in the `EnemyCollision`
    class. This class will handle collisions with the player, allowing the enemy to
    take damage. Look at the following code block for details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at what the `EnemyCollision` class does:'
  prefs: []
  type: TYPE_NORMAL
- en: '**playerDamage**: Represents the damage that’s inflicted by the player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**damage**: Damage inflicted when the enemy collides with the player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OnCollisionEnter(Collision collision)**: Handles collisions with player projectiles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final component in the enemy’s logic is `EnemyShoot`. It’s responsible
    for firing projectiles using the attached weapon. Implement the `IDamage` interface
    here so that it will pass the damage value to the player. Refer to the following
    code block for details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at what `EnemyShoot` does:'
  prefs: []
  type: TYPE_NORMAL
- en: '**fireDamage**: Damage inflicted when the enemy shoots the player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**attachedWeapon**: Reference to the attached weapon of the enemy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FireProjectile()**: Initiates the firing of the attached weapon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GetDamageValue()**: Retrieves the damage value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s create the `BaseEnemy` class is an abstract class that defines the
    basic functionality and attributes of an enemy in a game. It will utilize state
    machine logic and contain references for the shooting and animation components
    of the enemies. This class facilitates communication between different states
    of the enemy, making it suitable for use with all enemies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at this code so that we understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**player**: Reference to the player’s **Transform** value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**navMeshAgent**: Reference to the **NavMeshAgent** component for navigation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**currentState**: Reference to the current state of the enemy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**wanderState**, **idleState**, **attackState**, **deathState**, **chaseState**:
    Different states of the enemy (wandering, idle, attacking, dead, and chasing,
    respectively)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**attackRange**: The range within which the enemy can attack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**chaseSpeed**: The speed at which the enemy chases the player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rotationSpeed**: The speed of rotation for the enemy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start()Method**: Initializes states, sets the initial state, and gets references'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update()Method**: Updates the current state of the enemy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s delve into the state machine logic that’s responsible for transitioning
    between states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand this code, let’s examine its functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PlayerInSight()** and **PlayerInRange()**: These functions check if the player
    is in sight or range, respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IsIdleConditionMet()**: Checks if the conditions for idling have been met'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TransitionToState()**: Transitions to a new state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OnDied()Method**: Transitions to the death state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s move on to the states. First, we’ll implement `IEnemyStates` so
    that we can include the base methods. Then, in the subsequent code block, we’ll
    develop the logic for `IdleState`, detailing the actions the enemy will take in
    this state. `IdleState` is the default state for all enemies. Here, we simply
    check for the conditions of other states so that we can transition to them when
    their respective logic is met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Variables**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**idleTime**: This variable determines the duration for which the enemy remains
    idle'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**timer**: This variable tracks the elapsed time while the enemy is in the
    idle state'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Methods**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EnterState(BaseEnemy enemy)**: This method is called when the enemy enters
    the idle state. Here, it initializes the timer.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ExitState(BaseEnemy enemy)**: This method is called when the enemy exits
    the idle state. Currently, it’s empty, but you can add logic here if needed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UpdateState(BaseEnemy enemy)**: This method is called every frame to update
    the state of the enemy. Here’s what happens:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The timer is incremented by the time elapsed since the last frame
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the idle time exceeds the specified duration (**idleTime**), the enemy transitions
    to the wander state, indicating it’s ready to move around
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the enemy detects the player within its line of sight (**PlayerInSight()**),
    it transitions to the chase state to pursue the player
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the player is within the attack range (**PlayerInRange()**), the enemy transitions
    to the attack state to engage the player
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This code ensures that the enemy behaves as expected while in the idle state,
    transitioning to other states based on specific conditions, such as time elapsed
    and player proximity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following class, `AttackState`, we also implement `IEnemyState` so that
    we can modify the base methods so that they fit the attack state. The attack state
    is the state that all enemies will enter when they are attacking the player. It
    includes logic for tracking the player’s position and firing projectiles toward
    the player, along with handling associated animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an explanation for this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Methods**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EnterState**: Initializes the attack state, starts attack animations, and
    resets the attack timer.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UpdateState**: Checks if it’s time to attack based on the time between attacks.
    It ensures that the enemy is facing the player and initiates the attack if conditions
    are met.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ExitState**: Stops attack animations when exiting the state.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LookAtPlayer**: Calculates the direction to look at the player and smoothly
    rotates the enemy toward the player.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AttackPlayer**: Causes the enemy to perform an attack action, such as firing
    a projectile.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With that, you’ve learned how to create states, enabling you to effortlessly
    add more states so that you can tailor your game.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve established the interaction loop between the enemy and the player,
    allowing them to shoot at each other, the next step involves creating a prefab
    for each enemy – for instance, implementing the `ShooterEnemy` base class and
    adding this component to the respective `GameObject`, turning it into a prefab.
    Similarly, for projectiles, remember that it’s essential to modify tags based
    on whether they’re for the player or the enemy.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing challenge and reward systems using C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Challenges breathe life into the gaming experience, pulsating with excitement
    and unpredictability, guiding players through pivotal moments that require skill,
    strategy, and determination. These obstacles ensure players stay fully immersed
    in the gaming world, crafting a dynamic landscape that turns each gaming session
    into an adventure, complete with unexpected twists and turns.
  prefs: []
  type: TYPE_NORMAL
- en: In games such as *Dark Souls*, challenges manifest in the form of formidable
    enemies and intricate level designs. Players are tested on their combat skills
    and adaptability, creating an intense and rewarding experience. *Super Mario Bros.*
    introduces challenges through precise platforming, timing, and defeating enemies.
    Each level presents a new set of challenges, gradually increasing in complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges versus missions/quests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While challenges, missions, and quests share common ground in engaging players,
    they differ in their nature. **Challenges** often refer to specific obstacles
    or tasks that test a player’s abilities, such as completing a level within a time
    limit or defeating a powerful adversary. **Missions and quests**, on the other
    hand, are broader objectives that contribute to the game’s narrative and involve
    a series of tasks that may include challenges. The distinction lies in the focused,
    skill-testing nature of challenges, making them pivotal components of dynamic
    gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *The Legend of Zelda: Breath of the Wild*, a challenge might involve solving
    a complex puzzle shrine and testing the player’s problem-solving skills. In contrast,
    a mission could be part of the game’s overarching narrative, such as rescuing
    a character or retrieving a special item. Challenges offer immediate, skill-based
    hurdles, while missions contribute to the overall progression and storytelling.'
  prefs: []
  type: TYPE_NORMAL
- en: Balancing difficulty levels for broad appeal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Achieving a harmonious difficulty curve is essential to cater to players of
    varying skill levels. Balancing challenges ensures that both novice and experienced
    players find engagement without encountering excessive frustration. Games such
    as *Celeste* masterfully balance difficulty, starting with simple challenges and
    gradually introducing more complex ones, allowing players to grow alongside the
    game’s intricacies.
  prefs: []
  type: TYPE_NORMAL
- en: Successful games often employ techniques such as **adaptive difficulty scaling**
    or optional challenges to accommodate diverse player skill levels. This careful
    balance prevents discouragement for newcomers while providing a satisfying experience
    for seasoned players seeking greater challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring reward systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Reward systems** in gaming are like treasured prizes waiting for triumphant
    players after they’ve overcome tough challenges. These systems are closely linked
    to the challenge dynamics, acting as the driving force that propels players forward.
    Rewards come in various forms – power-ups, upgrades, or in-game currency, along
    with narrative progress and cosmetic items, each with its unique appeal.'
  prefs: []
  type: TYPE_NORMAL
- en: In games such as *The Legend of Zelda*, conquering tricky dungeons or defeating
    tough bosses often rewards players with new tools or abilities to progress in
    the story. In RPGs such as *The Witcher 3*, completing side quests not only gives
    experience points and in-game money but also unlocks new storylines or equipment.
    The connection between challenges and rewards ensures that overcoming obstacles
    not only tests the player’s skills but also promises valuable incentives, boosting
    player engagement and satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: Successfully blending rewards into the gameplay loop ensures that challenges
    aren’t just hurdles but opportunities for growth. This fosters a sense of accomplishment
    and progression. Players are motivated to take on tougher challenges for the promise
    of more significant rewards, creating a satisfying gaming experience. The seamless
    integration of rewards makes the gaming journey fulfilling and enjoyable.
  prefs: []
  type: TYPE_NORMAL
- en: C# implementation of challenges and rewards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Moving from theory to practice, our C# implementation of challenges and rewards
    brings coding insights to life. With illustrative code snippets, you’ll gain hands-on
    experience, bringing challenges to life and rewarding players meaningfully. We’ll
    discuss the delicate balance that’s needed to keep players engaged and motivated,
    understanding how challenge difficulty correlates with the magnitude of rewards.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the challenge logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s begin by establishing the foundational data structure for challenges.
    This can be seen in the following class. Every challenge will share this common
    set of data, simplifying runtime tracking and allowing prizes to be assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s proceed to the `BaseChallenge` class, which features the logic for starting
    and completing challenges. Refer to the following code block for details. All
    challenges will derive from this script, customizing their logic within its methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: '**public CommonChallengeData commonData**: This is a public variable of the
    **CommonChallengeData** type. It holds data that might be common across various
    types of challenges. It allows derived classes to access and modify shared challenge
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public abstract void StartChallenge()**: This is an abstract method declaration
    without any implementation. It specifies that any class inheriting from **BaseChallenge**
    must provide its own implementation for the **StartChallenge** method. This method
    likely contains logic to initialize or begin the challenge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public abstract void CompleteChallenge()**: Similar to **StartChallenge()**,
    this is another abstract method that any derived class must implement. It is responsible
    for handling the completion of the challenge, which may involve updating the UI,
    awarding rewards, or triggering other game events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, `BaseChallenge` serves as a template for creating different types
    of challenges in a game. It defines common functionality that all challenges should
    have, such as starting and completing the challenge, while allowing specific implementations
    to vary based on the type of challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s transition to `ChallengeManager`, a central entity that houses all challenges
    and takes on the responsibility of initiating challenges. Currently, it includes
    a dictionary for storing all challenge components by their respective types, encompassing
    all challenge types. It also features a method to commence challenges, which will
    be invoked by `LevelManager`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, each level can have a designated challenge, and the manager maintains
    a reference to the current challenge. All of these functionalities are detailed
    in the following code script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an explanation of the `ChallengeManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**public enum ChallengeType**: This is an enumeration that defines different
    types of challenges available in the game. Each challenge type represents a specific
    kind of gameplay challenge, such as **EnemyWaves**, **TimeTrials**, **LimitedResources**,
    **NoDamageRun**, and **AccuracyChallenge**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public GenericDictionary<ChallengeType**, **BaseChallenge> challengeDictionary**:
    This is a generic dictionary that maps **ChallengeType** enum values to corresponding
    **BaseChallenge** objects. It stores instances of different challenge scripts
    associated with their respective challenge types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public void StartChallenge(ChallengeType challengeType)**: This method is
    responsible for starting a challenge of the specified type. It retrieves the corresponding
    challenge script from the dictionary based on the provided challenge type and
    then calls the **StartChallenge()** method of the retrieved script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**private BaseChallenge currentChallenge**: This private field holds a reference
    to the currently active challenge. It is used to track and manage the state of
    the current challenge being played.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**private void** **SetCurrentChallenge(BaseChallenge challenge** **Script)**:
    This method sets the current challenge to the one provided as an argument. Before
    setting the new challenge, it ensures that any existing challenge is completed
    by calling its **CompleteChallenge()** method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, the `ChallengeManager` class facilitates the management and execution
    of different types of challenges in the game. It provides methods to start challenges,
    handle the completion of challenges, and track the current active challenge. The
    use of a singleton pattern ensures centralized control over challenge management
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s shift our focus to the individual challenges. The following code
    block contains an example that implements the `BaseChallenge` class, integrating
    custom logic specific to the `Enemy Waves` challenge. When the challenge starts,
    enemies are spawned near the player. Additionally, it includes logic to reward
    the player upon completing the challenge. This is facilitated by the `RewardManager`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an explanation of the `EnemyWavesChallenge` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**public int totalWaves = 5**: This variable determines the total number of
    waves for the enemy challenge. Game designers can adjust this value to set the
    desired number of waves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**private int currentWave = 0**: This variable keeps track of the current wave
    during the challenge. It starts at **0** and increments as waves are spawned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public override void StartChallenge()**: This method overrides the **StartChallenge()**
    method that’s inherited from the **BaseChallenge** class. It initiates the enemy
    waves challenge if it’s not already completed. Inside this method, a coroutine
    named **StartEnemyWavesChallenge()** is started to handle the wave spawning process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IEnumerator StartEnemyWavesChallenge()**: This coroutine function manages
    the spawning of enemy waves. It runs until the current wave count reaches the
    total number of waves specified. Inside the loop, it waits for a wave to be spawned
    using the **SpawnEnemyWave()** coroutine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public override void CompleteChallenge()**: This method overrides the **CompleteChallenge()**
    method from the base class. It grants rewards for completing the challenge using
    **RewardManager** and marks the challenge as completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IEnumerator SpawnEnemyWave()**: This coroutine function represents the logic
    for spawning an enemy wave. Game designers can adjust spawn positions, enemy types,
    and other parameters to customize the wave spawning process. In this example,
    it logs a message indicating the wave being spawned and waits for a set duration
    before spawning the next wave.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, the `EnemyWavesChallenge` class defines a challenge where waves
    of enemies are spawned sequentially. It provides methods to start the challenge,
    spawn enemy waves, and handle the completion of the challenge by granting rewards.
    Game designers can customize the wave spawning process and adjust parameters according
    to the game’s requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example is just one of the challenges provided. You can find all
    the challenges in this book’s GitHub repository (see the *Technical requirements*
    section). Lastly, here’s `LevelManager`, which is tasked with assigning a suitable
    challenge for the current level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an explanation of the `LevelManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**public GenericDictionary<int**, **ChallengeType> levelChallengeMapping**:
    This dictionary stores mappings between levels and their corresponding challenge
    types. The key represents the level number, and the value represents the type
    of challenge associated with that level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public int currentLevel**: This variable stores the current level of the
    game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**private void Start()**: This method is called when the **LevelManager** object
    is initialized. It automatically starts the challenge associated with the current
    level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public void StartChallengeForCurrentLevel(int currentLevel)**: This method
    starts the challenge for the specified current level. It checks if a challenge
    has been mapped for the current level in the **levelChallengeMapping** dictionary.
    If a mapping is found, it retrieves the associated challenge type and starts the
    corresponding challenge using **ChallengeManager**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ChallengeManager.Instance.StartChallenge(challengeType)**: This line of code
    invokes the **StartChallenge** method of the **ChallengeManager** singleton instance,
    passing the challenge type associated with the current level as an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, the `LevelManager` class facilitates the initiation of challenges
    based on the current level of the game. It ensures that the correct challenge
    is started for each level by looking up the challenge type associated with the
    current level in the `levelChallengeMapping` dictionary and then invoking the
    `StartChallenge` method of the `ChallengeManager` singleton instance.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the reward system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let’s delve into the reward system, a crucial element in the gameplay flow
    that allows users to receive rewards. This feature is essential for user motivation
    and engagement
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s `RewardManager`, which is tasked with providing the user with rewards
    based on the challenge data. As we can see, it communicates with other managers
    to enable the user to receive specific rewards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an explanation of the `RewardManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**public enum RewardType**: This enumeration defines different types of rewards
    that can be granted to the player, such as power-ups, unlockable weapons, score
    multipliers, items found in secret areas, and coins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public void GrantReward(CommonChallengeData commonData)**: This method is
    responsible for granting rewards to the player. It takes a **CommonChallengeData**
    object as a parameter, which contains information about the type and amount of
    reward to be granted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**switch (commonData.rewardType)**: This switch statement checks the type of
    reward specified in the **CommonChallengeData** object and executes the corresponding
    reward logic based on **RewardType**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**case RewardType.PowerUp**: This case allows temporary power-ups to be granted
    to the player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**case RewardType.UnlockableWeapon**: This case allows new weapons to be unlocked
    for the player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**case RewardType.ScoreMultiplier**: This case applies a score multiplier to
    the player’s score by invoking the **ApplyScoreMultiplier** method with the specified
    multiplier value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**case RewardType.SecretArea**: This case allows items to be found in secret
    areas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**case RewardType.Coins**: This case grants coins to the player by invoking
    the **GrantCoins** method with the specified coin amount.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**private void ApplyScoreMultiplier(int multiplier)**: This method applies
    a score multiplier to the player’s score by invoking the **ApplyMultiplier** method
    of the **ScoreManager** singleton instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**private void GrantCoins(int coinAmount)**: This method adds coins to the
    player’s currency balance by invoking the **AddCoins** method of the **CurrencyManager**
    singleton instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, the `RewardManager` class provides a centralized mechanism for managing
    and granting various types of rewards to the player upon completing challenges.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block contains `CurrencyManager`, which is responsible for
    overseeing in-game currency. However, the focus here is on a segment dedicated
    to adding coins to the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an explanation of the `CurrencyManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**private int currentCoins**: This variable stores the current number of coins
    the player has.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public void AddCoins(int amount)**: This method allows you to add coins to
    the player’s currency balance. It takes an integer parameter amount, representing
    the number of coins to add to the current balance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**currentCoins += amount**: This line increments the **currentCoins** variable
    by the specified amount, effectively adding coins to the player’s balance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, the `CurrencyManager` class provides a simple yet essential functionality
    for managing the player’s currency balance, specifically adding coins to their
    total balance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block contains `ScoreManager`, which is tasked with managing
    the player’s score and implementing a scoring multiplier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an explanation of the `ScoreManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**private float currentScore**: This variable stores the current score of the
    player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**private int scoreMultiplier = 1**: This variable represents the score multiplier,
    which starts at **1** by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public void ApplyMultiplier(int multiplier)**: This method allows you to
    apply a score multiplier to the current score. It takes an integer parameter multiplier,
    which adjusts the score multiplier accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***scoreMultiplier = multiplier**: This line multiplies the existing score
    multiplier by the specified multiplier, effectively adjusting the score multiplier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**private void ResetMultiplier()**: This method resets the score multiplier
    to its default value of **1**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public void AddScore(int scoreValue)**: This method adds a specified score
    value to the player’s current score. It takes an integer parameter called **scoreValue**,
    representing the score to add to the current score.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**currentScore += scoreValue * scoreMultiplier**: This line adjusts the current
    score based on the score value and the current score multiplier. It multiplies
    the score value by the score multiplier and adds it to the current score.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, the `ScoreManager` class handles score calculations and updates, including
    applying multipliers and adding score values to the player’s total score.
  prefs: []
  type: TYPE_NORMAL
- en: This example highlights the vital relationship between challenges and the reward
    system in game development. Challenges provide engaging obstacles and objectives,
    fostering player interaction and progression. Integrated with the reward system,
    completing challenges becomes not just an accomplishment but a satisfying experience,
    offering incentives that motivate players. This dynamic interplay enhances the
    overall gaming experience, ensuring players remain engaged, motivated, and fulfilled
    throughout their journey in the game world.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B22017_06.xhtml#_idTextAnchor098), which focuses on data handling,
    I intend to introduce a save system that will store all pertinent data, encompassing
    the elements we’ve discussed so far. This chapter will delve into the specifics
    of implementing this system.
  prefs: []
  type: TYPE_NORMAL
- en: The provided scripts serve as demonstrations, and you can find the complete
    logic in this book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved into essential Unity game development principles,
    specifically addressing game mechanics with a focus on C#. We underscored their
    significance in shaping engaging gameplay, encompassing aspects such as balance,
    feedback, and player agency. This provided you with practical skills in C# coding
    for implementing effective game mechanics. Transitioning to the next section,
    *Implementing player behavior and AI logic using C#*, we explored player behavior
    design and foundational AI concepts. Additionally, we emphasized the crucial role
    of challenges and reward systems in elevating the player experience and fostering
    engagement.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B22017_05.xhtml#_idTextAnchor074)*,* *Designing Optimized User
    Interfaces with C# for Unity Games*, you will delve into the domain of UI design
    principles and responsive UI elements. By mastering UI design techniques using
    C#, you’ll be able to craft visually appealing and immersive interfaces. This
    chapter aims to augment your skills in designing effective visual hierarchies,
    layouts, and responsive UI elements, ultimately contributing to an enhanced user
    experience, including optimized UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: As you embark on this ongoing journey of skill-building, the upcoming chapter
    holds exciting challenges and discoveries. Happy coding!
  prefs: []
  type: TYPE_NORMAL
