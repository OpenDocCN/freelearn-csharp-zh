- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 2*, *Design and Prototype*, we discussed that this book will be
    utilizing a vertical slice method for our model. Being a vertical slice, the project
    is a simplification of the game. It is similar to a demo, but it has all of the
    main mechanics the game would contain, just in a simpler form. It is meant to
    give investors a strong example of what could be an entire game experience. We
    will be showing the character’s behavior to draw the player in and then lead into
    a small portion of the story with mechanics driven by environment puzzles while
    learning about the main character’s past.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with the concepts related to the main character; we will then
    model the character out and make changes as we see fit by working through their
    mechanics and movement. We will make a rig for them so they can be animated. After
    this, we will put them in Unity and test out how it feels moving them around in
    the engine. This chapter will be packed with a lot of information, and we will
    be going over many different production concepts to create our character and get
    them properly moving:'
  prefs: []
  type: TYPE_NORMAL
- en: Design and concept
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rigging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting your character’s movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with the conception phase for Myvari, the main character of our
    small story.
  prefs: []
  type: TYPE_NORMAL
- en: Design and concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make a character, there can be many dimensions. We want to make sure that
    the hero character of this vertical slice, Myvari, is as fleshed out as possible.
    One of the best tools for this is asking “why” for aspects of the character.
  prefs: []
  type: TYPE_NORMAL
- en: Asking why
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are building an adventure-based puzzle game. The first question that comes
    to mind is: why is the character on this adventure? In this case, we answered
    that question with: “She is seeking to find answers about her race’s past that
    aren’t in the stories being told or the books she’s read.” Now we’ve defined a
    few things, but there are still more questions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To give an idea of the questions that came up from this initial answer, look
    at this list:'
  prefs: []
  type: TYPE_NORMAL
- en: What race is she and why does this matter to the story?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why female?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is her history hidden?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is her clothing like?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does the race look like?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is she humanoid?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, this can go on for a while, and it should. All of these answers
    should bring more questions. Take them down to their lowest possible components.
    This may seem tedious, but when you are done, you will know how this character
    acts when they are confronted, their facial expressions, behaviors, inside jokes,
    family backstory, and everything in between.
  prefs: []
  type: TYPE_NORMAL
- en: Concept time!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a strong idea of Myvari and who she is, we can draw up concept
    art. We first start out with some proportion work and sketch work to find her
    basic appearance.
  prefs: []
  type: TYPE_NORMAL
- en: On the left in *Figure 4.1*, we also drew up a behavioral take. This gives us
    a visual idea of how she may act in an **idle break** animation. An idle break
    is an animation that occurs when your character remains still for some time. We
    felt that her character would be studious and inquisitive, so she would pull out
    a book and just start studying on the spot.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17304_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Initial Myvari sketches'
  prefs: []
  type: TYPE_NORMAL
- en: After we have drawn up the sketches of what she may look like, including giving
    a sense of her personality, we need to get a feel for the colors to finalize the
    design. The color scheme shown in *Figure 4.2* was chosen after answering all
    the previous questions.
  prefs: []
  type: TYPE_NORMAL
- en: Myvari’s overall color themes give the sense of royalty, curiosity, and safety.
    These are depicted through regal clothing with gold lines denoting royalty. Blue
    evokes a sense of safety—a psychological and physical effect, as seeing this color
    lowers our blood pressure. Using blue draws the player slightly more into her
    character, curious about this bright blue amongst the rest of her neutrally colored
    outfit.
  prefs: []
  type: TYPE_NORMAL
- en: Her most unique accessory is her necklace, which has a mechanical purpose. It
    will be the key for the puzzles that she will have to interact with. For this
    reason, the necklace has a color that stands out from the rest of Myvari. This
    color will also be unique in the environment utilizing a concept known as **user
    guidance**, which we will talk about in *Chapter 5*, *Environment*, *Chapter 6*,
    *Interactions and Mechanics*, *Chapter 7*, *Rigid Bodies and Physics Interaction*,
    and *Chapter 12*, *Final Touches*. We will need to use this color continuously
    in the environment, the mechanics, as well as the polishing of the entire vertical
    slice.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17304_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Myvari’s color scheme'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a strong idea about the character’s personality and colors, we
    need to move into the 3D versions of concepting. This is less creating and more
    defining a character. The following image depicts the character’s facial features
    using a **sculpting** tool. Our team has a strong background in the use of Pixologic’s
    ZBrush, which allowed us to create the sculpt you see in *Figure 4.3*. 3DCoat
    and Blender also offer sculpting tools.
  prefs: []
  type: TYPE_NORMAL
- en: After we’ve worked through enough iterations with the sculpts, we will use this
    as a beginning high-resolution model.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve defined our primary high-res sculpt, we can move on to getting
    a low-res model out of ZBrush.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17304_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Myvari’s high-resolution head sculpt'
  prefs: []
  type: TYPE_NORMAL
- en: The low-res model will be our scale bias for everything in the game, as seen
    below in *Figure 4.4*. When you are creating buildings, flora, fauna, or characters,
    this model will act as the universal **scale** for them. There are multiple ways
    to work through scale, however, I know that this character is the main creature
    in this game; all of the items will be environmental or props, which will all
    be scaled off her size as the base scale.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17304_04_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Myvari’s low-resolution head sculpt'
  prefs: []
  type: TYPE_NORMAL
- en: Some other ways scaling can be done is by building to scale. Unity’s units are
    centimeters. If you build to a meter and then export from your Digital Content
    Creation (**DCC**) as a centimeter, everything will follow a single unit scale.
    This is a great way to build if you are building a large game with many teams
    working around the world. You could also build the game around the environment
    itself. An example of this could be a top-down game using squares for environment
    creation, so it all clicks together. The squares may be a 10^(th) of the screen.
    From this information, you would take a screenshot at the resolution expected,
    then draw the character concepts on that picture to fit the scale. Look at your
    project and look through what the single point of scale that you can build off
    is. This will ultimately save you time down the road.
  prefs: []
  type: TYPE_NORMAL
- en: You could potentially just build whatever you can and scale the item in-game
    after it’s imported. However, what will happen with that is the mechanics may
    not work properly. Think about games like Tomb Raider or Assassin’s Creed, where
    the main character must climb onto walls. This requires the character to have
    a very specific height and a large amount of conditioning to ensure they are in
    the right spot at the right time for the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Rigging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After working through this whole concepting phase, we need to work on getting
    some bones into the character so we can animate her. We will be using Autodesk’s
    Maya 2022 to rig our character. The points we will go over will be principles,
    not technical details. Depending on your DCC tool, you may encounter slightly
    different terminology, however, the following terms will generally apply to any
    of the major DCCs in use for game development.
  prefs: []
  type: TYPE_NORMAL
- en: Animation-first thinking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When beginning the rigging task, the most efficient way to work is by having
    a detailed conversation about the animations themselves with the artists who will
    be responsible for them. Even if you’re doing the animations yourself, successful
    rigs are ones that ensure the animator doesn’t need an explanation of what each
    control does. There may be some technical attributes, but overall if a control
    doesn’t need something, it should be locked and hidden.
  prefs: []
  type: TYPE_NORMAL
- en: When the animator moves a control that oversees the hand, they may expect all
    the finger controls to be on that control. This is intuitive but it shouldn’t
    be assumed that the animator needs this. They may want all individual controls
    to be placed on their own control.
  prefs: []
  type: TYPE_NORMAL
- en: Deformation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the ability for a mesh to be able to bend in a predetermined way, such
    as the elbows or knees. Since you know how they will be bending, you can plan
    your mesh for that deformation to be possible with a proper **edge flow** in your
    model. Edge flow is an art form all on its own, ensuring that there is enough
    geometry to keep the shape when deforming. An example edge flow can be seen in
    *Figure 4.5*. Take your time working through other AAA model examples and learn
    how each body structure may bend.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17304_04_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Example of edge flow on a humanoid'
  prefs: []
  type: TYPE_NORMAL
- en: Facial deformation is by far the most specific deformation. If you are planning
    on having any facial deformation when you start rigging, look for some videos
    explaining how to set up the character for this. Facial expressions are intricate
    and hard to do correctly.
  prefs: []
  type: TYPE_NORMAL
- en: A small example of edge flow and separation can be seen in *Figure 4.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17304_04_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Example of facial edge flow'
  prefs: []
  type: TYPE_NORMAL
- en: Facial deformation done correctly will result in your character producing relatable
    expressions. This can accentuate the experience by bolstering the immersion through
    emotion. If you plan on having close-ups of your character, it’s a good idea to
    take the time to work through facial deformation.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hierarchy and parenting are an integral part of rigging knowledge. When Unity
    imports a skeletal mesh, there may be transforms that your DCC had in place. This
    can sometimes be a grouping or hierarchical change that has its own transform.
    Unity would see these items as GameObjects and place them in the same spot in
    the Hierarchy of the skeleton. Every application may be slightly different. An
    example of this is with Maya: if your hierarchy has a group node as a parent of
    your rig, Unity will think this is a transform of its own and import it as such.
    This may not cause an issue in the beginning with no logic on the GameObject,
    but it’s always best to be as clean as possible. If you are using Maya, we recommend
    that you don’t have any parent nodes on the skeleton you will be binding.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings up a topic that is interesting to work with: the **control rig**.
    The most customizable rig that we’ve worked with was a binding rig, which was
    bound to all the vertices on the character. This was then driven directly by a
    duplicate rig, which we called a control rig. This allowed for the bind rig to
    only worry about the inputs of a single entity. This is important as sometimes
    you may want to have multiple deforming tools moving around the rig. You might
    want a separate squash control and twist control. All this logic on the control
    rig will drive the bind rig without worrying about breaking the binding on the
    character.'
  prefs: []
  type: TYPE_NORMAL
- en: Bones or joints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bones and joints are terms used interchangeably in rigging. The bind skeleton
    consists only of bones or joints in its own Hierarchy from the root, through the
    spine, arms, legs, neck, and head. These bones can be seen in *Figure 4.7* below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17304_04_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Examples of joints of character inside DCC'
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve laid out your bones, you then need to plan out the next level by
    constraining systems that will drive the bones’ structure. If you are using a
    control rig on top, these constraints would instead drive the control rig bones.
  prefs: []
  type: TYPE_NORMAL
- en: Forward Kinematics/Inverse Kinematics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Forward Kinematics** (**FK**) and **Inverse Kinematics** (**IK**) are two
    major forms of animation for arms and legs. FK is a technique where the animator
    will manually rotate every joint individually. If you are animating an arm, you
    would start from the shoulder, then the elbow, then the wrist, etc. It’s called
    “forward” as you are going forward down the Hierarchy for animation. On the contrary,
    IK is where you would animate the hand, and the shoulder and elbow would follow
    from the guidance of a rotate plane. There is a debate on whether to use one or
    the other, however, they are tools. If you work with one and it makes your job
    easier, then use that style. It is very common to see FK/IK switches on character
    rigs as both have their places in certain animation workflows.'
  prefs: []
  type: TYPE_NORMAL
- en: Further, the primary concern about IK is that you can keep the hand in the same
    position or to the space where it was last placed. Imagine standing up and putting
    a hand in the air, then moving your hips up and down while keeping your hand in
    the air in the same place. This would be extremely tedious to animate with an
    FK-only setup as you would have to key the shoulder, elbow, and wrist separately
    to all the hip motions. With IK, you would be able to key the wrist in the spot
    where it would be and then just animate the hips. IK would handle the shoulder
    and elbow for you. However, a walk cycle where gravity is working on the hand
    and it’s mostly just making an arc with the momentum of the movement is better
    suited for FK.
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, these are tools that can potentially produce the same
    result. As you build experience with your tools, it will provide you with insight
    into your animation style.
  prefs: []
  type: TYPE_NORMAL
- en: Constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constraining is a simple action. Using visual objects, we want the animators
    to understand the control’s purpose straight away. A concise example would be
    a **NURBS** (**non-uniform rational basis spline**—a point in space that creates
    something visual) curve that will point to each finger in a rigged hand to help
    with making a fist. *Figure 4.8* below shows how we did this with Myvari’s rig.
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, indoor  Description automatically generated](img/B17304_04_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Myvari’s hand controls'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are called controls simply because they allow the animators to control
    certain aspects of the character. Reading this may sound similar to another term
    we introduced in *Chapter 1*, *A Primer to the Third Dimension*: **parenting**.
    It is true that there is a similarity between constraining and parenting, however,
    we are allowed to be specific in what we want to constrain with constraints. In
    Maya, this is separated into translation, rotation, and scale constraining. You
    can also constrain individual components of each of these, such as “rotate *x*”
    only. This allows the rigger to be able to restrict the animator a bit. The above
    example with the head control may only need a rotational constraint. This makes
    it so the translation of the box would not affect the bones. With parenting, you
    wouldn’t be able to separate these. Parents affect all transforms of the child
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: Deformers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The deforming tools will be unique to each DCC. The primary function of a deformer
    is to control the top-level hierarchy in certain ways. An example of this may
    be a twist deformer, which could allow a nice twist of the controls to make it
    easier for the animator to build a twist animation.
  prefs: []
  type: TYPE_NORMAL
- en: Some advanced animations use the deformers on another mesh that is controlling
    the bones, which is sometimes called a ribbon rig, which is seen below in *Figure
    4.9*. This image shows the ribbon on the left and the deformers that control the
    underlying joints of the necklace. The right side shows what the animator sees
    by hiding the underlying ribbon control.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17304_04_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Examples of a ribbon rig for Myvari’s necklace'
  prefs: []
  type: TYPE_NORMAL
- en: Controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Animators have the unique job in the 3D world of working with representations
    of the items they need to move in real time. Whether this is a box surrounding
    the hand or head, each shape gives the animator control. Each character will have
    controls unique to their needs. Myvari will have standard controls for a biped
    and extra controls for her clothing and trinkets.
  prefs: []
  type: TYPE_NORMAL
- en: Below in *Figure 4.10* is our character’s controls for her whole body.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17304_04_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Myvari’s whole-body controls'
  prefs: []
  type: TYPE_NORMAL
- en: Physics-based animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some animation can be done through a simulation. There should be a bone attached
    to the mesh, but the DCC will perform physics movements that would be slightly
    constrained. These are very good to work with for chains, necklaces, and basically
    anything springy or dangly. These things are notoriously difficult to animate
    by hand, so it’s best to let the application handle it for you. In some cases,
    the game engine can handle all the physics-based animation and doesn’t need to
    be keyed by the animators. This means that the physics animation would be independent
    of the animation file itself, which would allow for a much smoother blending of
    animations.
  prefs: []
  type: TYPE_NORMAL
- en: Human Inverse Kinematics (HIK) system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Autodesk has created a biped rigging system to integrate multiple software easily.
    This is needed primarily for motion capture work where the animations are created
    through separate technologies. Motion capture is done through suits, facial capture
    devices, as well as specialized gloves.
  prefs: []
  type: TYPE_NORMAL
- en: The primary purpose of a **Human Inverse Kinematics** (**HIK**) rig is to gather
    animation data for the biped’s head, spine, arms, and legs. There is an advanced
    version that allows for fingers as well as more features on the arms and legs,
    such as twists. To gather more information about HIK skeletons, Autodesk has published
    documentation about how best to use it. For our demonstrations, we will not be
    using the HIK system. With Myvari, we will be doing all hand-keyed animations
    and no mocap work. In knowing this, we decided to stick to just keeping a custom
    rig and control system.
  prefs: []
  type: TYPE_NORMAL
- en: Animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now designed, modeled, and rigged a character with controls. Now we
    can use our animation skills in our DCC to give some life to the character. When
    you are deciding what animations to make, be sure to give good thought to what
    personality the character has. Since we spent a good amount of time asking all
    the hard questions about our character’s motivations and desires, we should honor
    that with the correct movements expected of someone with that personality.
  prefs: []
  type: TYPE_NORMAL
- en: A strong way to work through animations is the same way that you would work
    through any art form. First, we will work with a blocking phase to get the timing
    right by working with just key poses. While you are doing this, get the key posing
    as strong as possible. Every keyframe should have a personality in it. If you
    look at the keyframe and cannot get a sense of the character, then it would not
    be considered “key” to the character. After you have blocked in some keyframes
    and moved them to get a sense of timing, this is when you would then add in-betweens.
  prefs: []
  type: TYPE_NORMAL
- en: These are keyframes in between the key poses in timing. These keys will help
    sell the movement within each key pose.
  prefs: []
  type: TYPE_NORMAL
- en: Once you get to this point, it can be a good idea to add it into the game engine
    to get a sense of actual movement with the character controller to see if what
    you see in the DCC translates into the game’s movement. Doing this at this stage
    is smart as you will have a good amount of time near the end of the project to
    polish all your animations after you learn how to move your character.
  prefs: []
  type: TYPE_NORMAL
- en: Character controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have put together a character design, model, and rig, we need to
    set up a **controller** to have them react to inputs. There are two general methods
    for character controllers. The built-in character controller that Unity provides
    will allow you to have a character walk around, up stairs, and easily build in
    further functions of interaction, but it has its limits. The largest limitation
    is that it is not used as a physics object. If you need your character to get
    pushed around by physics, there is a second option available. The second option
    is using a Rigidbody and collision capsule with a character script using these
    as restrictions to the physics engine. Just as you may have come to expect by
    now, to choose the correct option here we need to ask questions! The following
    are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the primary mechanics?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do I need physics for movements?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many other limitations will there be for my character?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After some time, you may learn to ask these questions very early when you start
    seeing what architecture may be needed to pull off the gameplay you want within
    Unity. This will only happen after leaving these questions unanswered and missing
    the mark slightly. Do not get discouraged by this. This is the best way of learning:
    failing fast and failing often. The options available to you are not always obvious.'
  prefs: []
  type: TYPE_NORMAL
- en: An example of this is asking yourself what the primary mechanics are. Looking
    at your game, you may try to push crafting weapons in the game, but the combat
    mechanics are more fun during production. After finding this out, you may cut
    most of the crafting and put more effort into polishing the combat mechanics.
    What this does is place more emphasis on the character controller over UI or interactive
    crafting work.
  prefs: []
  type: TYPE_NORMAL
- en: In our game, we decided to take a simple approach to the character movement.
    We only need movement, and all other interactions will mostly be through mouse
    position and camera work. With that in mind, we will investigate the character
    controller foundation to build upon.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in character controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unity has a built-in character controller component that can be added to your
    character. This will give you solid foundations to work with. It is simply a capsule
    collider that allows simple movement for a first-person or third-person game.
    The interesting portion of this is that it does not use physics or Rigidbodies
    for physics. Unity documentation explains this the best as a “Doom-style” controller:
    moving very fast and when you let go of the thumbstick, it stops immediately.
    This is sometimes desirable, but not often. An example of when this could be desirable
    is when you’re making a game where extremely tight controls are needed. Metroid
    uses this to flip the character left and right immediately. If you had to slow
    to a stop before turning, the game wouldn’t feel as good as it does.'
  prefs: []
  type: TYPE_NORMAL
- en: The best part of this is that it is fast and easy to throw it on your character
    to get moving if you want to just test something simple. If you want to add jumping,
    floating, swimming, flying, or anything dealing with physics, this application
    will not work without a good amount of work.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the built-in character controller for this tutorial, as Myvari
    only needs to explore on the ground without jumping or sliding and none of her
    interactions use any focused physics.
  prefs: []
  type: TYPE_NORMAL
- en: Rigidbody character controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This option for a component starts with coding in mind but offers a large amount
    of flexibility that the built-in character controller can’t provide for many purposes.
    The initial reasoning for using a Rigidbody is if you are looking to have different
    physics materials in your game. If your game is planning on utilizing physics
    in multiple ways, then it would be better to plan on working with the Rigidbody
    and collision components as your choice for physics on your character controller.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting your character’s movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you’re scripting your character, it’s a good idea to have as many movement-related
    design conversations as you can to know what to architect out. For Myvari, we
    wanted to have a few movement-related specifics in the environment because this
    game is an environmental puzzle game. We should have the environment interact
    with her as she traverses it. Here is a list of what we went over:'
  prefs: []
  type: TYPE_NORMAL
- en: Idling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Walking:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the ground
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In water
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On ledges
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two movement-related scripts that we, at this time, haven’t fully
    decided on implementing. These are running and jumping. The reason we aren’t going
    to implement these currently is that we do not know for certain that we need them.
    As we move through the level currently, it feels good walking through it, and
    we want the player to pay attention to the environment as well. We will set up
    the character controller to accept a running movement if we think it’s needed
    later. Jumping is similar, but we have no mechanics that require jumping up or
    over. You would only implement this to satisfy the need for jumping around in
    an environment. We may find that this is needed after some QA passes are done
    and player feedback states that they need to jump around. If this is a strong
    enough case, we can add it in.
  prefs: []
  type: TYPE_NORMAL
- en: Initial setup in Unity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To begin with, to get Myvari set up to even accept scripts for movement, we
    should set it up in Unity. We should already have Myvari imported into the Unity
    project. Just so you are aware, the way to go about this is just a simple drag
    and drop onto the project’s folder you want her to be in. If you select `SM_Myvari`
    in the `Character` folder, the Inspector will show the imported settings on the
    model, as shown in *Figure 4.11*. The default settings that are in use here are
    good for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17304_04_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Import settings Model tab'
  prefs: []
  type: TYPE_NORMAL
- en: We need to move over to the **Rig** tab and set up our rig. In *Figure 4.12*,
    we have a couple of options to go over. We want to make sure that **Animation
    Type** is set to **Humanoid**. We also want to create an avatar from this model
    and then configure it. This will open another window to set up the bones in the
    humanoid structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B17304_04_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: Import settings Rig tab'
  prefs: []
  type: TYPE_NORMAL
- en: This window will default to the body portion, though we’re showing the head
    section in *Figure 4.13*. It’s best to go through every portion of the body as
    the avatar system will do its best to align the joints to the right location,
    but sometimes it doesn’t work out. If it isn’t set up properly, just select the
    correct joint to fill the slot properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface  Description automatically generated with medium
    confidence](img/B17304_04_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: Import settings Rig, configure head portion'
  prefs: []
  type: TYPE_NORMAL
- en: Before we set up the controller, we should have a chat about our decisions on
    how the game will be played. We have a third-person, over-the-shoulder play style.
    This means we must add a camera to the character. As such, we should make a **Prefab**
    with our character and our camera. To set this up, we make a Hierarchy that will
    allow for independent camera movement but keep the camera and character together.
    In *Figure 4.14* you can see the way we set up the Prefab.
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B17304_04_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: Character prefab hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: The reason we set it up this way was that we wanted a container to hold both
    the camera and the character. The character GameObject holds all the scripts needed
    for the character. The mesh will hold the animator and avatar. The camera rig
    will house the camera as well as the scripts needed to maintain the camera in
    the position we want. Later in the book, when we get into the mechanics in *Chapter
    6*, *Interactions and Mechanics*, we will be going over **Cinemachine** quite
    heavily as there are parts of the game where we will need to put the camera in
    a location for a cinematic.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this chapter, we will go over just the basics of setting the
    character up for movement. On the character GameObject, let’s set up the components
    to get her moving around. As shown in *Figure 4.15*, we will add four more components.
    These are the character controller, our movement script, a Rigidbody component,
    and a player input system.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17304_04_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: Character GameObject components'
  prefs: []
  type: TYPE_NORMAL
- en: As stated previously, we will be using the base character controller. These
    settings are subjective, and we haven’t finalized them, but this is what we have
    so far. One note we should add here regards the **center attribute**. This is
    where the character controller thinks the center of the character is. It defaults
    to being on the ground, but you need to move it up so the capsule is closer to
    the center and slightly off the ground. We try to put it near the pelvis and then
    use the radius and height to encompass the general body of the character. We do
    this because the pelvis controls the overall height as the human structure has
    its center of mass in the belly button.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to skip over the movement script for now. The Rigidbody here is
    to help with future mechanics needs and physics-based work. We will cover this
    in *Chapter 5*, *Environment*, and *Chapter 6*, *Interactions and Mechanics*.
  prefs: []
  type: TYPE_NORMAL
- en: '**PlayerInput** is a Unity system that sets up modular inputs to easily add
    different input systems without needing to change the code. Firstly, open your
    **Package Manager** and see if the **Input System** is installed. It would be
    part of the **Unity Registry**. If it’s not installed, install it! If it is, then
    we need to make an input system for us to work with.'
  prefs: []
  type: TYPE_NORMAL
- en: This can be done by adding a new asset called **Input Actions**, as shown in
    *Figure 4.16*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_04_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: Adding an Input Actions asset'
  prefs: []
  type: TYPE_NORMAL
- en: After you create the input action, name it according to your needs. We are naming
    ours `Player Actions`. We are going to use this grouping of input actions specifically
    for any player actions needed. You may need other actions besides characters in
    your future projects. At this point, you will need to double-click the asset to
    open the **Input Actions** window. Here, we will design the input options for
    use as currently needed for Myvari.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4.17* shows a completed input system as we need it currently. We may
    add more inputs as the vertical slice continues to develop.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface  Description automatically generated](img/B17304_04_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: Input Actions'
  prefs: []
  type: TYPE_NORMAL
- en: '**Action Maps** are groupings that have their own set of actions that can be
    called upon. Properties are details and options for the selected action. For this
    case, we only need inputs for Myvari, so we created a Myvari Action Mapping. Notice
    the capitalization of the **Action Mapping** name, as it will be used in scripting
    once we get into the movement script.'
  prefs: []
  type: TYPE_NORMAL
- en: In **Actions**, the green sections are the actions themselves, the blue are
    the bindings, and the light red are the binding parts. For **Locomotion** we only
    need to worry about a composite of vectors. When adding a new binding, if you
    press the plus (**+**) symbol on the right of the action, you have two options.
    These are **Binding** or **2D Vector Composite**. When you click **2D Vector Composite**,
    it automatically adds the **Up**, **Down**, **Left**, and **Right** composite
    parts. We are defining them as keyboard inputs currently to stick with a certain
    input system. There is a very interesting and useful tool when setting an action,
    called the **Listen** button. Looking at *Figure 4.18*, you can see that it’s
    pressed and is listening for input. For us, being able to press the assumed button
    that may be pressed gives us a sense of immediate player feedback. If it feels
    odd at this point to assign a keystroke to an action, then it won’t feel much
    better during gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17304_04_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.18: Listening for input'
  prefs: []
  type: TYPE_NORMAL
- en: The **Look** input is for camera movement, and we are using **Delta** for mouse
    movement. Our **Aim** action is meant for when you’re holding down the right mouse
    button for precision. This is choosing the **Action Type** as a **button** and
    expecting a right mouse button input. Finally, we have an **Interact** button.
    This is the same as **Aim** but designed for the *E* key to be hit at certain
    times. Those times will be defined in*, Environment,* and *, Interactions and
    Mechanics*.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a setup for the inputs we as players put into the game. Even if
    we wrote scripts to work with this input system, it wouldn’t affect anything.
    So, before we start scripting, we need to put together the basics of the animation
    setup for Myvari. Let’s look at the animations we will need. For now, we only
    need **Idle** and **Walk** for animation transitioning. We do not need to set
    up **Interact** just yet here as we do not currently have a use for it. In *Chapter
    5*, *Environment*, we will be looking at the use of **Interact**.
  prefs: []
  type: TYPE_NORMAL
- en: Idling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Myvari may have to stand still for a time as the player looks around. Most of
    the time, there is no scripting involved when idling as this should be the standard
    state in your animation controller. When you bring the character into your Scene,
    you will need to add an **Animator** component. See *Figure 4.19* for a correct
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B17304_04_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.19: Animator component'
  prefs: []
  type: TYPE_NORMAL
- en: '**Controller** and **Avatar** will be empty. We need to create the controller
    by creating a new asset and going to **Create** > **Animator Controller**. The
    controller is an interface between the code and visuals to move the skeletal mesh
    we want to animate.'
  prefs: []
  type: TYPE_NORMAL
- en: With **Idle**, we will make a default state and name it `Idle`. You can see
    this in *Figure 4.20*. In the **Characters** > **Animations** folder within the
    project, there are animations we’ve set up with Myvari. Select the **Idle** state
    and drag the idle animation from that folder onto the **Motion** parameter in
    the inspector, as shown in *Figure 4.21* below.
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17304_04_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.20: Controller state machine'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B17304_04_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.21: Idle animation state inspector'
  prefs: []
  type: TYPE_NORMAL
- en: When you have the idle animation in place, when you press **Play**, the character
    will enter idle mode and loop that animation forever!
  prefs: []
  type: TYPE_NORMAL
- en: We also want to have a walk animation though. To add this, in an empty space,
    right-click and choose **Create State** and then choose **Empty**.
  prefs: []
  type: TYPE_NORMAL
- en: Name it `Walk`. Select it and add the walking animation. After that, right-click
    on **Idle** and choose **Make Transition**, then left-click on the **Walk** state.
  prefs: []
  type: TYPE_NORMAL
- en: This will make a transition from **Idle** to **Walk**. Do the same thing from
    the **Walk** state back to **Idle**. This allows us to set up parameters to transition
    to and from **Idle** and **Walk**. We will now add a parameter of `isWalking`
    to the controller, as seen in *Figure 4.22*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_04_22.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.22 Controller parameters
  prefs: []
  type: TYPE_NORMAL
- en: The **Parameters** section is found on the upper left of the controller. We
    want to make a bool and name it `isWalking`. We will be using this parameter in
    the transition points. If you select the transition from the **Idle** to **Walk**
    states, you will see the transition from one animation to the other in the inspector.
    At the bottom of the inspector are conditions. Let’s add a condition and set it
    to **isWalking is True**. The animation state of **Idle** will change to **Walk**
    when `isWalking` is `true`. You can then do the opposite to revert to **Idle**.
  prefs: []
  type: TYPE_NORMAL
- en: We now have inputs and animations in place with a transition ready to listen
    to the character logic. We now need to get in there and get the movement script
    working. Let’s dive into the code!
  prefs: []
  type: TYPE_NORMAL
- en: Code entry point
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We wanted to add a small section here explaining how we will go over the code.
    In *Chapter 3*, *Programming*, we went step by step through every line to go over
    the basics of code. What we plan on doing here is having the script in its entirety
    available to you, with full comments so you can read it if you’re more comfortable
    with code. In the rest of this chapter, we will be going over small parts we haven’t
    been over previously and explaining them as tools. We encourage you to build your
    own scripts and work with the tools we go over to build your own character movement
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to be working through the `MyvariThirdPersonMovement.cs` file.
    We have some simple work here as well as a complicated function. While we are
    going through this, know that it is OK not to fully grasp everything that is discussed.
    By noticing the hard parts and working through them, you are solidifying that
    knowledge and understanding how to work as a developer in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: RequireComponent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you see a `RequireComponent` above the class definition, this is saying
    that the GameObject that this script is attached to is required to have something.
    In our case, we want `MyvariThirdPersonMovement.cs` on the character, and we need
    to ensure it has a character controller. Something that is very helpful is that
    if Unity sees that the GameObject you attach this to doesn’t have the required
    component, it will just attach it to the GameObject for you! Isn’t that nice?
    We think so.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Update code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re going to go through this part in a bit of detail as each line goes in-depth
    about the previous information and it’s difficult to explain a single line at
    the end without showing the context. For the first part, we want to ensure that
    if the character is grounded and their velocity isn’t above *0*, it is set to
    *0*. Sometimes GameObjects will move in small increments in the *y* direction.
    This isn’t a common occurrence, however sometimes in 3D applications, rotations
    and movement causing rounding to happen for values and velocity can increment
    when it shouldn’t. This can be prevented by using these few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the next section we are breaking down the code we’ve written to ensure a
    thorough explanation leading up to the character movement script assignment in
    the Editor.
  prefs: []
  type: TYPE_NORMAL
- en: If you recall at the start of the *Scripting your character movement* section
    of this chapter, walking through water was one of the movements we wanted to have
    set up. We need to check if the character is in water to know how to set up that
    logic. We will be using a method from the **Physics** library called **Raycast**,
    which takes arguments, as seen in the helper tooltip in *Figure 4.23* below.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B17304_04_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.23: Physics.Raycast arguments'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a Raycast is used, its arguments are as follows: **origin**, **direction**,
    **hitInfo**, **maxDistance**, and **layerMask**:'
  prefs: []
  type: TYPE_NORMAL
- en: We define **origin** as this GameObject’s position plus one unit in the up direction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**direction** is the down direction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hitInfo** is being saved as a `RayCastHit` named `hit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**maxDistance** is set to 2 units'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**layerMask** is set to `waterLayer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To test this, make a cube and select **Water** for its layer value in the inspector.
    We will call for this `waterLayer` check during the `controller.Move` portion
    at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This next part is where the **Input System** is reading the value of the locomotion
    we put together. The **movement** variable is a `Vector2,` or *x* and *y* only.
    So, we will need to manipulate this to make sure it makes sense for a 3D movement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We make a `Vector3` and place the *x* and *y* from the read value while keeping
    the *y* of the `Vector3` as *0*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We now need to think about the character and camera coordination. We have a
    `move` variable that has the `movement` we need to move toward, but the camera
    may be looking in another direction other than straight forward relative to your
    character. So, let’s take that into account before moving.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Then we again just zero out that *y* value. If we were to implement jumping
    sometime later, we would need to change this from *0* to different values depending
    on the jump.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here we go. Now it’s time to move the character. We’ve thought about all the
    possible problems we could have with the camera, character, and type of terrain.
    The standard Unity character controller has a method named **Move**. This method
    takes a single argument, a `Vector3`. This tells the character which way to go.
    We need to take advantage of a few things. How fast are they moving? Are they
    in water? Something new we are using here is something called a **ternary**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give a slight explanation before we get into the next line of code. This
    is the ternary function. What is being said here is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is handy! We can slow the character down by a tunable value easily and
    if we aren’t in water, she moves at the regular rate we have already designed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have gravity defined at the top of this class, and we set the velocity to
    that gravity value multiplied by the change in time to account for framerate.
    This will not be accounted for unless Myvari is not grounded due to the `if` statement
    on top of the update function, which sets the `velocity.y` to *0* if it’s less
    than *0* and `isGrounded`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here we are calling two methods to handle rotation and animation states.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an effort to keep the update loop as clean as possible, we refactored out
    handling the rotation and animation from the `Update` function.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring is the process of restructuring existing code to make it more readable.
    It’s running in the update, but it’s only called one line per method. The initial
    method we’d like to go over is the `HandleAnimation` method. This takes a `Vector2`
    as an input, which is the direct input to the `Vector2` reading from the input
    system. We are only worried about the single animation parameter `isWalking`.
  prefs: []
  type: TYPE_NORMAL
- en: We first get the value of the bool at its current state and store it in a local
    variable. Then we check if either of the vectors in the input movement is nonzero
    as well as if `isWalking` is currently `false`. If so, we set the animator bool
    to `true`. Otherwise, we set it to `false`. When this bool changes, it will update
    in the controller and set the animations to the appropriate state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is the most advanced method we have going on here. We think it’s a smart
    idea to get out of our comfort zones as often as possible to continue growth.
    We will walk through this and if it’s not making sense right now, let it sink
    in and your brain will work through it. There are three actions taking place here.
    We need to find the angle we want to rotate to, get a rotation value, and then
    rotate!
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, `targetAngle` is doing a `Mathf` method called `Atan2`. `Atan2` is
    an arctangent method that allows you to find the angle given the target position
    of where you want to rotate to. It’s an interesting method that is very useful
    in games for character rotations in 3D applications. The problem is that we need
    to also account for the camera again. `Atan2` returns radians, so we need to multiply
    it by the radians-to-degrees constant and then add the camera’s *y* angle. This
    is the offset from the character’s angle.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we then take that target angle and create a quaternion from it in the
    current camera angle on the *y* axis. This will allow us to get an angle we will
    need to go to without worrying about **gimbal locking** occurring. Gimbal locking
    is when two axes get stuck in rotation due to one axis being 90 degrees off center.
    Quaternions are not susceptible to gimbal locking, which is why we transfer to
    quaternions in the end from the Euler angles.
  prefs: []
  type: TYPE_NORMAL
- en: By definition, Euler angles are oriented with respect to a fixed coordinate
    system. This is how we represent the angle we are at in the game where the reference
    is from *0*, *0*, *0* in rotation on import. If you rotate the character 90 degrees
    on the *y* axis, it is represented as *0*, *90*, *0* in the rotational fields
    of the transform of that GameObject. These values are Euler angles.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to transition to that rotation value. We do this through a
    **Slerp**. This stands for a **spherical lerp**. When working with rotations,
    it’s best to use the Slerp method. The arguments are our current rotation, the
    new rotation we just made, and then how long it should take to rotate to that
    new position. We made this rotation speed publicly available so we could change
    it on the fly to get the variable that feels best.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After this is done, your character now has movement and rotation. This is a
    great first step to building out an environmental, narrative-driven exploration
    game. Let’s finish up with a summary of what the whole chapter covered.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a large amount of character information. We went
    through design, modeling and rigging, character controllers, rigid bodies, working
    in Unity, and scripting a movement controller.
  prefs: []
  type: TYPE_NORMAL
- en: Design will always be boiled down to the question of “why?” You should’ve taken
    away from this chapter that the why of your character and their motivations will
    help secure a unique character that can be relatable. Modeling and rigging are
    heavily dependent on the type of modeling you will need to do. We went over some
    key methods to help guide your modeling to think of animation first. This also
    applies to rigging. Animation will be the final stage, and the easier it is to
    properly animate, the easier you and your players will find a better overall experience.
    Animations tend to be continually worked on until very close to release. Take
    the design of the rig seriously, as making changes after animations start could
    end up requiring a remake of animations.
  prefs: []
  type: TYPE_NORMAL
- en: We realized that Unity built-in character controller makes the most sense to
    us as we don’t need Myvari to be tossed around by physics, such as ragdolling.
    We then went into Unity and imported Myvari and went over the components needed
    to get input as well as animations for her. Finally, we finished going over a
    character script for movement and rotations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the environment, the terrain, and a tool
    called ProBuilder.
  prefs: []
  type: TYPE_NORMAL
- en: Join us on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing this book, we had over 200 Unity professionals on the
    Unity server and we are constantly adapting to add new channels to facilitate
    conversations on key topics such as C# programming, game mechanics, game UI, animations,
    3D games, sound and effects, and a dedicated channel for Packt authors to connect
    with the book’s readers.
  prefs: []
  type: TYPE_NORMAL
- en: Tell us about your progress made so far and the game idea you have in mind to
    build alongside this book. You never know—you might end up collaborating with
    someone on the server to build your mini-team today.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/unity3dgamedev](https://packt.link/unity3dgamedev)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code89002272-1876859406.png)'
  prefs: []
  type: TYPE_IMG
