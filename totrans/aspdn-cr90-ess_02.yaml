- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Dynamic UIs with Razor Pages, MVC, and Blazor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core 9 has a complete UI framework to suit different types of approaches
    and applications that allow the use of page rendering strategies on both the client
    side and server side. In this chapter, we will learn about the options available
    in the ASP.NET Core UI framework, in addition to understanding how to define the
    best option for each scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, we will understand some important concepts and then continue with
    a practical approach so that we are able to exercise the concepts learned.
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, we will initially understand what the ASP.NET Core UI framework
    is, learning about the different approaches to rendering applications both on
    the server, using Razor Pages and ASP.NET MVC, and rendering on the client, using
    JavaScript frameworks. Finally, we will understand the power of merging different
    technologies into a hybrid solution that uses the best of both the client and
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the ASP.NET Core UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a UI server render model with Razor Pages and ASP.NET MVC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring UI client rendering with Blazor and JavaScript frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with hybrid solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find all code examples and other materials used in this chapter in
    the following repository: [https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials)'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the ASP.NET Core UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic web-based applications have a flow that basically involves two distinct
    “worlds” the frontend and the backend. In general, the frontend deals with the
    mechanisms that are visualized and allow interaction between users and the various
    functionalities proposed by the solution. Therefore, a frontend is made up of
    buttons, texts, lists, menus, images, and other aspects that together form the
    UI. The backend is the representation of the mechanisms used to allow dynamism
    to the frontend, according to user interaction. We will discuss more about backend-related
    aspects in [*Chapter 3*](B21788_03.xhtml#_idTextAnchor044) .
  prefs: []
  type: TYPE_NORMAL
- en: Each of the terms expressed in the previous paragraph works in different contexts.
    The *frontend* usually runs on the client, which translates into the user’s browser.
    *Client* is a generic term that can express other types of user interaction. But
    in this case, we will talk about the client as the browser of your choice. The
    *backend* runs on the server, whether in a data center or even a cloud provider
    such as Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Through user interactions in the UI, the user must communicate with the backend
    and subsequently be able to adapt to the server’s responses to deliver some type
    of response and interaction, again , to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The browser basically uses three technologies: HTML, CSS, and JavaScript. HTML
    is static; that is, it is interpreted by the browser and then rendered in the
    form of a UI. CSS is responsible for making visual elements more attractive, defining
    colors, shadows, and formatting, among other design aspects. JavaScript is used
    to make static elements dynamic, and this includes, for example, making a call
    to a server, and depending on the result, modifying the user’s UI to adapt to
    the response of the processing carried out. JavaScript is responsible for increasing
    the ability of web-based applications to become dynamic and interactive. However,
    it can be complex to create and manipulate elements through JavaScript code and,
    in addition, to manage calls on the server. There are several excellent JavaScript
    frameworks available, such as Angular or React that allow you to develop richly
    dynamic UI solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: It is essential to have knowledge of UI technologies; however, in addition,
    we can benefit from an integrated development model that allows us to work on
    both the UI and the backend in a rich way.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 9 has a complete UI framework to meet any UI requirement for web
    applications and is fully integrated with the .NET platform, using best practices
    for separation of responsibilities, management, and maintenance, among other important
    aspects. Despite this, ASP.NET Core is not restricted to the use of the UI renderers
    proposed by the platform; it also integrates well with JavaScript frameworks and
    even allows you to use the best of the available options by adopting a hybrid
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we move on to a more specific understanding of the options available
    in ASP.NET Core 9, let’s learn about important aspects related to web systems
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are different approaches to developing web-based solutions when it comes
    to the UI layer, even before talking about technologies.
  prefs: []
  type: TYPE_NORMAL
- en: There are basically two models, client-side and server-side, with their respective
    pros and cons. There is also a third possibility, which would be to use a hybrid
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: In the client-side model, processing is done locally in the browser. In this
    way, all the HTML, CSS, JavaScript, and other assets are processed by the browser,
    responding to user stimuli. Interactions with users are handled locally through
    scripts containing UI-related logic without the need to request the server.
  prefs: []
  type: TYPE_NORMAL
- en: However, this approach depends on server resources, such as access to data,
    among other things, and so it is necessary to make frequent calls to the server
    in order to obtain information based on the user’s needs, which is then processed
    and presented in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: In the server-side approach, all the processing is delegated to the server,
    which returns a customized HTML page ready to be rendered in the browser. The
    server processes all the necessary information, allows access to data, manages
    business logic, has the ability to abstract sensitive information using secrets,
    and delegates minimal processing to the client. However, if the server is not
    available, it will not be possible to use the system.
  prefs: []
  type: TYPE_NORMAL
- en: In the hybrid approach, there is a combination of the best of “ both worlds.”
  prefs: []
  type: TYPE_NORMAL
- en: There are many JavaScript frameworks prepared to make web-based systems dynamic,
    providing a great user experience by processing resources on the client and, likewise,
    having the ability to interact with the server, delegating the processing of only
    relevant information to the UI rather than the entire processing of a page.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, ASP.NET Core 9 is prepared for the development of web-based solutions
    in the different approaches mentioned. We’ll start to understand the first UI
    development model, using Razor Pages, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a UI server render model with Razor Pages and ASP.NET MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ASP.NET Core 9 offers two powerful server-render models: Razor Pages and MVC.
    They are similar models, but MVC is more elaborate and implements the Model-View-Controller
    architectural design pattern—we’ll talk more about this in the *ASP.NET Core MVC*
    section. For now, let’s start learning about Razor Pages.'
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core Razor Pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Razor Pages is a server-rendered framework that implements a page-based model.
    The page-based model basically contextualizes the implementation of a specific
    page, taking into account the UI and business logic, but correctly segregating
    responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Razor is a markup language that acts similarly to a template engine and combines
    its use with HTML and C# code.
  prefs: []
  type: TYPE_NORMAL
- en: Razor’s origins
  prefs: []
  type: TYPE_NORMAL
- en: Razor’s development began in June 2010, but it was only released in January
    2011 with MVC 3, as part of Microsoft Visual Studio 2010. Razor is a simple-syntax
    visualization engine.
  prefs: []
  type: TYPE_NORMAL
- en: This page-based development model brings great advantages, such as ease of creating
    and updating the UI; it’s testable, keeps UI and business logic separate, and
    although it has similarities to ASP.NET Core MVC, it’s simpler. Taking all these
    advantages into consideration, let’s create our first project using Razor Pages.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first project with Razor Pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create a Razor Pages project, you can use Visual Studio or the **dotnet**
    CLI tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creation using Visual Studio is very simple; just open the IDE, select **Create
    a new project** , and then select the **ASP.NET Core Web App** template, as shown
    in *Figure 2* *.1* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Selecting a project template](img/B21788_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Selecting a project template
  prefs: []
  type: TYPE_NORMAL
- en: Both Visual Studio and the CLI tool work with the concept of templates. With
    the .NET platform, it is possible to develop different types of projects, whether
    for web, Windows, or mobile. Each template creates a basic project structure.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the rest of the book, we will use the CLI tool to create projects,
    as well as other needs that we will discuss later. From now on, we will use the
    .NET CLI tool to create a Razor Pages project, as this tool offers us several
    benefits that we will discuss in the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: When you install the .NET 9 SDK, a number of tools are available. The main tool
    we will use in this book is **dotnet** .
  prefs: []
  type: TYPE_NORMAL
- en: 'The **dotnet** CLI tool also has a concept of templates. To test this functionality,
    open your operating system’s Command Prompt and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the preceding command, the current version of the tool will be
    displayed. This time, still at the prompt, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the preceding command, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – dotnet CLI tool templates](img/B21788_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – dotnet CLI tool templates
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen in *Figure 2* *.2* , some templates and examples of use were
    listed. Each model has a set of parameters that are used to customize project
    creation. If you want to know more about the parameters of each template, just
    type the following command; for example, for the **webapp** template, you’d type
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The **-h** (help) parameter will provide a list of parameters and documentation
    for the desired template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the installation on your machine, there may be other templates.
    Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a list containing many types of project templates; we will focus
    on the projects highlighted in *Figure 2* *.3* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – All available project templates](img/B21788_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – All available project templates
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve understood templates, let’s finally create a new Razor Pages
    project via the command line. To do this, open Command Prompt, create a new folder
    called **NewRazorPages** , and run the following command on this folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The previous command is composed of the **new** command, to create a new project,
    then **razor** , representing the short name of the desired template, and finally
    the **-n** parameter, which defines the name of the project.
  prefs: []
  type: TYPE_NORMAL
- en: After executing the command, a new folder containing the project will be created.
  prefs: []
  type: TYPE_NORMAL
- en: Command details
  prefs: []
  type: TYPE_NORMAL
- en: Each of the commands available in the CLI tool can have a set of parameters.
    To find out more about these parameters, simply add the **-h** option after a
    command; for example, **dotnet** **new -h** .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also consult the tool’s documentation at the following link: [https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet](https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet)'
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of the book, we will consider creating projects via the command
    line. Now, let’s go into more detail about the Razor Pages project we’ve created.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Razor Pages project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Razor Pages project has a very simple directory structure and configurations
    compared to ASP.NET Core MVC. However, many of the concepts used in this project
    serve as a basis for the MVC project, so we’ll take advantage of all the content.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2* *.4* shows the structure of the project created in the previous
    section and has been expanded to express each important item that we will discuss
    in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Razor Pages project structure](img/B21788_02_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Razor Pages project structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Razor Pages has a simple structure that can basically be divided into four
    important items:'
  prefs: []
  type: TYPE_NORMAL
- en: '**wwwroot folder** : This folder contains the application’s static files, such
    as JavaScript, CSS, libraries, and images. By default, three subdirectories are
    configured, such as **css** , **js** , and **lib** , used to contain JavaScript
    files from external libraries, such as jQuery, among others. You can also create
    other directories to contain files such as images, fonts, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pages folder** : This folder contains the application’s pages, subdivided
    into a pair of files with the **cshtml** extension that contain the HTML code
    and C# code using Razor syntax, and **cshtml.cs** , which contains the C# code
    responsible for handling page events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**appsettings.json** : This is a file in **JSON** format that is used to maintain
    application settings centrally, as well as database connection strings, API keys,
    and other parameters. We’ll talk more about settings in [*Chapter 9*](B21788_09.xhtml#_idTextAnchor146)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Program.cs** : This is the most important file in the Razor Pages project,
    written in C# and containing all the execution settings for the entire application
    flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some other details and configurations related to the project will be seen in
    the other chapters of the book as we add more features and concepts to the learning
    process. For now, it’s very important to understand some of the project’s premises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the **Program.cs** file to understand some details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following points explain the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the file creates an instance of an ASP.NET Core web application,
    using some standard configurations, such as adding middleware, between *lines
    9* and *13* , that acts on the application flow and convention configurations
    for generating routes, among other aspects provided by the framework itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have the execution of the **builder.services.AddRazorPages** line,
    which is responsible for configuring the web application with the characteristics
    of the Razor Pages project. This project has dependencies on certain classes that
    are used by the platform when running the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Between *lines 4* and *8* , there is a check related to the environment in which
    the application is running. This block ensures that if there are any errors not
    dealt with by the application, the user will be redirected to a generic error
    page, preventing details of the application from being exposed. The **app.UseHsts()**
    code aims to force communication via the **HTTP Strict Transport Security** (
    **HSTS** ) protocol to add security and the use of HTTPS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On *line 9* , we guarantee the use of the HTTPS protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 10* is necessary for the Razor Pages application to take into account
    static files, localization, and the use of HTTPS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to consider, at this point, that the code described in the **Program.cs**
    file will affect how the application will behave at runtime. We must also consider
    the order of each of the methods located in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Further details and configuration variations will be discussed later in the
    book. We are already familiar with the Razor Pages project structure, so let’s
    learn more about the syntax used in HTML pages and how to interact with C# code.
  prefs: []
  type: TYPE_NORMAL
- en: Working with pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Razor acts as a powerful templating engine, allowing you to create pages using
    HTML, CSS, JavaScript, and C# code in the same file. This approach brings great
    flexibility in generating dynamic pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of the **Index.html** page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first lines of code refer to page-related settings, and then we have the
    pure HTML code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand the main components described in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: The **@page** directive must be the first directive in a Razor page view. It
    indicates that the page will function as an action handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **@model** directive indicates which type of model will be passed to the
    page. Razor Pages has a set of two files that make up a page, **.cshtml** and
    **.cshtml.cs** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **ViewData["Title"]** code is a dictionary, which represents another way
    of passing data to pages. In general, **ViewData** is used to pass small amounts
    of data. In the case of the preceding code, **ViewData** is being used to pass
    information from the page title to the HTML template.
  prefs: []
  type: TYPE_NORMAL
- en: The first concerns HTML; as with the previous example, **.cshtml.cs** refers
    to the C# code of the page handler, which contains the model or information that
    will be used on the page. Thus, the **Index.cshtml** file has an association with
    the **index.cshtml.cs** file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we have the **IndexModel** class that represents the
    model that will be used on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we noted in the example, the **Index.cshtml** page does not have the entire
    structure of an HTML page. This is because Razor Pages allows the concept of Layout.
    That is, pages can often share a similar structure. This way, we can reuse the
    code to both generate common Layouts and create shared View blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the project structure, Layouts are kept within the **Pages/Shared** folder.
    By convention, shared views start with an underscore. The **_Layout.cshtml** file
    has a common HTML structure and, in addition, a special directive, **@RenderBody()**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The **RenderBody()** method specifies the location where views will be rendered
    after server processing. In the case of the **index.cshtml** page, all HTML will
    be rendered between the main tags, in the **_Layout.cshtml** file. Also, note
    the use of **ViewData["Title"]** , which will display the value set on a page,
    as done in the **index.cshtml** file.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two other special files that, by convention, should be located in
    the **Pages** folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '**_ViewStart.cshtml** : This is a file that allows us to define code that must
    be executed before displaying each Views. In this case, this file has a code where
    it defines which Layout file will be used for Views.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**_ViewImports.cshtml** : This file is used to define the namespace and import
    features into the page, in a common way. This way, there is no need to declare
    namespaces and other features on each page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand the entire project structure and how Razor pages are
    managed in the project, let’s add some customizations to the **Index** page and
    the **IndexModel** model and learn how to use Razor syntax and interact with C#
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the Razor syntax and C# model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As explained previously, Razor pages have two files, one responsible for rendering
    the UI and the other responsible for containing the page’s business logic. Furthermore,
    there is the possibility of using C# code together with HTML, meaning that the
    page can be generated during processing time on the server, according to user
    interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make some changes to the **index.cshtml** file, adding some controls
    as shown in *Figure 2* *.5* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Customizing the index.cshtml file using Razor syntax](img/B21788_02_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Customizing the index.cshtml file using Razor syntax
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **index.cshtml** file in Visual Studio or Visual Studio Code to make
    the changes and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Between the **@{}** instance, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, change all the content between the **div** tags, which contain the page
    content, to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code creates formatting for the **Price** property so that it
    is displayed in currency format. This formatting will take into account your browser’s
    regional settings. In the case of the example run in this book, the formatting
    will display the price in **en-US** culture format.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To ensure that the property is displayed in a specific format, a new property
    can be created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This way, we can update the existing code for price display to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, we can define the application culture globally, avoiding the need
    to create a new property. To make this change, add the following code to the **Program.cs**
    file below the **var app =** **builder.Build()** line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about managing cultures in ASP.NET Core 9, see the following
    link: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/localization?view=aspnetcore-9-0](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/localization?view=aspnetcore-9-0)'
  prefs: []
  type: TYPE_NORMAL
- en: Some elements that use inline C# code have been added, in addition to some calls
    to the server code. At the moment, it is important to understand how Razor syntax
    can be used together with HTML. Let’s understand all the elements added to the
    UI and how they interact with C#.
  prefs: []
  type: TYPE_NORMAL
- en: The first snippet added on *line 5* , **string subtitle = "It's funny"** , is
    C# code, declaring a variable of type **string** .
  prefs: []
  type: TYPE_NORMAL
- en: Note that all the code is enclosed between **@{ and }** symbols, as per the
    example between *lines 3* and *6* of the **index.cshtml** file. This syntax allows
    the addition of a block of code capable of containing C# and HTML instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Combining C# and HTML code and a block
  prefs: []
  type: TYPE_NORMAL
- en: 'Within a C# code block, it is also possible to add HTML tags. Using this strategy
    brings great advantages, such as determining what type of HTML tag will be rendered,
    according to an **if** statement, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**@{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**if (total >** **0)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**<h1>The available amount** **is: @total</h1>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**else**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**<h2>There is no** **amount available</h2>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the code block, the use of the **@** symbol allows the addition
    of C# code in one line, as in the example of the preceding code, which will display
    the value of the **Message** property of the **Model** object and display the
    value of the **subtitle** variable, previously defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Razor Pages provides directives, which are features added to HTML tags. The
    following code adds two anchors to the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that there are two attributes, **asp-page-handler** and **asp-route-id**
    . These are directive Razor pages, which determine, respectively, the name of
    the event handler when the link is clicked and the value that will be sent as
    a parameter to the handler.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the **div** style has the **@Model.Color** code, inserted as
    the value of the **background-color** property. The color of the **div** tag will
    be set dynamically, according to the link.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of the controls created on the page, we have a purely HTML form
    and a table that lists randomly generated products. The form does not have the
    **action** attribute, used to determine the page or script that will process the
    posting of data. This attribute was omitted because Razor Pages follows a convention,
    which in this case is to infer the action to the form page itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code generates the rows and columns of the product table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a mix of HTML and C# code. After executing the **foreach**
    statement, the columns and rows of the product table are defined. Products are
    generated in the **Products** property of the **Model** object.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to separate responsibilities
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, it is possible to add any C# code to an HTML page using Razor
    Pages. However, use this approach to manipulate UI elements, but it is important
    to separate responsibilities correctly, avoiding multiple implementations of business
    rules together with UI manipulation rules.
  prefs: []
  type: TYPE_NORMAL
- en: All the elements we need at this point have been added, and we now know how
    to add C# code to manipulate our UI. Let’s finalize the **Index** page, adding
    the necessary code for its operation in the **index.cshtml.cs** file.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the page model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the previously created UI to work correctly, we must add some properties
    and methods to the page model. Open the **index.cshtml.cs** file so that we can
    add the necessary functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The **Index** page model is, in fact, a C# class that has an inheritance from
    the **PageModel** class, which is an abstraction of several properties and methods
    used by models in Razor Pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make changes to the **IndexModel** class and understand each piece of
    code added:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a **Message** property to the **Index.cshtml.cs** file. It will be used
    to define a message that will be displayed in the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the project root, create a folder named **Models** and then add a class
    called **Product.cs** . This class must have the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go back to the **Index.cshtml.cs** file and add a **Products** property that
    will contain a list of objects that will be listed in the table created in the
    UI previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, add a **Color** property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The basic properties have been created. Now, let’s create a method that randomly
    generates a list of products. Add the **GenerateProduct** method as per the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will change the class constructor and add default values for the **Products**
    and **Message** properties. This way, as soon as the page is displayed, we will
    have a randomly generated list of products and an **I’m using the Razor** **Syntax**
    message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The method that generates the products is being used in the constructor to
    generate an initial listing. However, we want to interact through the UI and generate
    a list based on a value that will be entered in the form. To do this, we will
    create an **OnPost** method. This method generates a new list, based on the quantity
    entered in the UI form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s define a last method that will be responsible for setting the
    value of the **Color** property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our model is ready to interact with the UI. But before running the application,
    let’s understand a simple concept of Razor Pages convention.
  prefs: []
  type: TYPE_NORMAL
- en: The **OnPost** method has this name, following a convention, and is related
    to the **GET** , **POST** , **DELETE** , and **PUT** HTTP verbs. This way, by
    defining methods such as **OnGet** , **OnPost** , **OnDelete** , and **OnPut**
    , they will be able to handle page events, according to the HTTP verb. The **Index**
    page UI has a form with the **POST** method. Therefore, when clicking on the **Load
    Products** button, Razor Pages will automatically call the **OnPost** method on
    the **IndexModel** model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **OnGetDefineColor** method has this name to follow the convention, but
    there is no obligation to use the **OnGet** prefix in the method name. In HTML,
    we do not define the link handler as **OnGetDefineColor** ; this is because, by
    convention, Razor Pages will infer the prefix from the method name, and also because
    a **GET** request is performed. But if you wish to provide your full name, there
    will be no problem. The **OnGetDefineColor** method has another important characteristic:
    its **id** parameter. The **id** parameter receives the value defined in the directive
    added in the HTML link, as shown in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This action is called binding, which means that when passing the **id** parameter,
    Razor Pages sets the values of the method arguments according to the name of each
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Directive tip
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters in the previously defined HTML link is done using the **asp-route**
    directive together with the name of the parameter expected in the method—in this
    case, **id** . This way, the complete directive is defined by **asp-route-id**
    . If there were another argument called **name** , for example, the directive
    would be **asp-route-name** .
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the entire implementation of the **Index** page, run the application
    and interact with the controls created previously.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned how to use Razor Pages to create dynamic pages using
    the server-side approach. With each interaction with the controls created on the
    **Index** page, a call will be made to the server, which will manipulate the information,
    interpret the Razor page code implemented in the UI, and later return an HTML
    output with the result.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is quite similar to ASP.NET Core MVC, which we will learn about
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core MVC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET Core MVC is also a very powerful server-side framework that implements
    the MVC design pattern. Let’s understand how the MVC design pattern works and
    then learn how to benefit from this approach by creating a new project.
  prefs: []
  type: TYPE_NORMAL
- en: MVC pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MVC is an architectural design pattern that works on the separation of responsibilities
    or context:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – MVC pattern](img/B21788_02_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – MVC pattern
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 2* *.6* , the **Controller** acts as an orchestrator,
    responding to user interactions through the **View** , and delegating actions
    to the **Model** , which represents the application state and business rules.
    Subsequently, the Controller returns the result, defining which View will be responsible
    for displaying the UI to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: The View and the Controller have a dependency on the Model, but the Model is
    agnostic, allowing the separation of responsibilities and the use of good code
    practices, such as the use of unit tests, as there is independence from the visual
    presentation.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core MVC is based on the MVC pattern, adapting the project model and
    conventions. Let’s understand how this pattern is implemented in this type of
    project.
  prefs: []
  type: TYPE_NORMAL
- en: The ASP.NET Core MVC project structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating the ASP.NET Core MVC project is very simple, and we use the CLI tool,
    in addition to Visual Studio Code as an editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the next instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your operating system’s Command Prompt and access a directory of your choice
    where the project will be created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following command to create the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command uses the **dotnet** CLI tool, where we specify the action
    of creating a new project through the **new** command. Then, we define which type
    of project will be created. In this case, we inform that the template will be
    **mvc** , and a **--name** parameter has been added, whereby we inform the name
    of the project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A folder will be created with the name of the application. Access this folder
    and then open Visual Studio Code by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding command will open up the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.7 – ASP.NET MVC project structure](img/B21788_02_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – ASP.NET MVC project structure
  prefs: []
  type: TYPE_NORMAL
- en: When looking at the structure of the MVC project created, we will notice a similarity
    with Razor Pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main project folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Views** : It has the same characteristics as the **Pages** folder in Razor
    Pages; that is, it is the application’s UI. It has **.cshtml** files, and these
    are organized into subfolders that represent a page and contain all the UIs that
    can be used as responses to actions. However, there are no **.** **cshtml.cs**
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller** : The controller has a similar role to the class defined in
    the Razor Pages **.cshtml.cs** file. As mentioned, it is an orchestrator that
    has methods to manipulate events executed in Views. In MVC, each controller method
    is called **actions** and can return Views, redirections, or even data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Models** : This folder is used to manage the business classes and models
    that will be used to exchange information between Views and HTML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This structure follows a convention, which, in a way, facilitates development
    in this approach. However, the platform allows us to make customizations if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The MVC project also presents a small difference in the settings defined in
    the **program.cs** file in relation to Razor Pages. Before executing the **app.Run()**
    line, there is a call to the **app.MapControllerRoute** method. This method is
    responsible for configuring all of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Routes define what will be accessed and how it should be accessed through application
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following code, a default route is configured, called **default**
    , which has the **controller** / **action** / **parameter** pattern. Furthermore,
    the controller and action have a default value, **Home** and **Index** , respectively,
    while the parameter is optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is a standard MVC convention and can be easily changed. In this model,
    if access to the application does not have a definition of the controller and
    which action should be executed, then the default controller, **Home** , and the
    **Index** action will be defined as the response to the request.
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to note that we are referring to Controllers and not pages.
    This is because the MVC pattern allows the Controller to orchestrate the request,
    according to the desired action, and then return a result or a View.
  prefs: []
  type: TYPE_NORMAL
- en: As we progress through the chapters of the book, we will have other examples
    of using routes.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding patterns and conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MVC project follows a convention that benefits the file structure presented
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned, the Controller acts as an orchestrator between the Model and
    the View. This way, instead of using a concept of pages, there is the idea of
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the user’s intention or interaction, it triggers an action. This action
    is captured by a Controller, which then performs the processing and returns either
    a value or a View, as shown in *Figure 2* *.8* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – MVC request flow](img/B21788_02_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – MVC request flow
  prefs: []
  type: TYPE_NORMAL
- en: The **Controller** class is a C# class, which has attributes and methods. The
    **Controller** class’s public methods are called actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a registry of people. We would then have the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The **PersonController** class follows the name convention, adopting the **Controller**
    suffix at the end of the class name. Furthermore, this class has an inheritance
    from the **Controller** class, which is a base class that already has some utility
    methods responsible for processing and returning data and information through
    the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have a method called **Index** , which just returns a View, executing
    the **return** **View()** command.
  prefs: []
  type: TYPE_NORMAL
- en: Which View is returned?
  prefs: []
  type: TYPE_NORMAL
- en: 'The **View()** method takes into account the Asp.NET Core MVC convention. So,
    when executed, the view that is instantiated considers the following path: **/Views/<ControllerName>/Action.cshtml**
    . This means that in the case of the **PersonController** class, calling the **Index**
    method will return a View: **Views/Person/Index.cshtml** .'
  prefs: []
  type: TYPE_NORMAL
- en: The **View()** method has other overloads, making it possible to pass an object
    that will be used as a Model into the View or even define a Controller View that
    should be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **GetPeople()** method just returns a list of people in JSON format, as
    shown in *Figure 2* *.9* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – JSON with a list of people](img/B21788_02_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – JSON with a list of people
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Register()** method processes the form request and returns an object
    to the **Result** View. However, in this case, it is making the call to an action
    from the **PersonController** controller, executing the **RedirectToAction** method,
    called **Result** , which expects a string as a parameter. *Figure 2* *.10* demonstrates
    the display of the action result after registering a person:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Register Person view](img/B21788_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Register Person view
  prefs: []
  type: TYPE_NORMAL
- en: Base Controller class
  prefs: []
  type: TYPE_NORMAL
- en: The abstract **Controller** class has some utility methods that allow you to
    work on the communication flow between the Controller and the View.
  prefs: []
  type: TYPE_NORMAL
- en: The **Json()** , **View()** , and **RedirectToAction()** methods are some of
    the resources that are commonly used in a controller class.
  prefs: []
  type: TYPE_NORMAL
- en: The MVC model and Razor Pages have similarities, but a big difference is the
    use of actions instead of pages. In this way, the controller has the ability to
    decide what type of View or information should be returned, in relation to some
    user interaction, orchestrating the processing flow.
  prefs: []
  type: TYPE_NORMAL
- en: The Controller responds to user events, and the View is an important aspect
    of this type of project. Based on the **PersonController** example, we will understand
    how the View was created and learn how the interaction with the Controller’s actions
    works in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Views on ASP.NET MVC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The concept of Views in ASP.NET MVC is the same as that used in Razor Pages,
    using the Razor syntax. As we can see in the following code, there is a form tag,
    using Razor directives, defining which Controller and action will process the
    registration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding file was created in the **Views/Person/Index.cshtml** directory
    structure. Following the convention, for the **PersonController** controller,
    there must be a **Person** folder, a subfolder of Views, which will contain all
    the Views that will be displayed through the **PersonController** controller.
  prefs: []
  type: TYPE_NORMAL
- en: The view index is a good practice
  prefs: []
  type: TYPE_NORMAL
- en: It is good practice to have an **Index.cshtml** file and an **Index()** action
    in each controller. Following the route pattern, defined in the **Program.cs**
    file, by default, when an action is not specified, an **Index()** action will
    be executed. In this case, having a View and Action Index will avoid usability
    problems in your application.
  prefs: []
  type: TYPE_NORMAL
- en: To create the labels and inputs used in the form, **tag helpers** were used.
    Tag helpers are Razor Pages methods that basically render HTML. The difference,
    in the preceding code presented, is that there is a connection with the Model.
  prefs: []
  type: TYPE_NORMAL
- en: In the first line of the **Index.csthml** page, a Model was defined, using the
    **@model MyFirstMVCApp.Models.PersonModel** code. This makes the Model strongly
    typed. By using a tag helper, together with a Lambda expression, we are implementing
    good practice in relation to the MVC binding model.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, the HTML generated by tag helpers for the form will have the correct
    names in relation to the model properties, following the flow outlined next:'
  prefs: []
  type: TYPE_NORMAL
- en: The data is the name and date of birth informed in the inputs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user clicks the **Register** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ASP.NET framework makes a request to the **Result** action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ASP.NET framework identifies that the **Result** action has a **PersonModel**
    object as a parameter and then creates an instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ASP.NET framework binds the data posted by the form and sets the values
    in the corresponding properties of the instantiated object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ASP.NET framework executes the **Result** action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the bind is done through property names, if any name is typed incorrectly,
    some properties will not have a value.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the tag helpers approach also helps in other aspects such as attributes
    added to the **Model** class that allow validations, among other aspects. We will
    discuss more about attributes and bind during *Chapters 3* and *5* .
  prefs: []
  type: TYPE_NORMAL
- en: The MVC pattern provides us with several benefits, especially in more complex
    projects where there is a need to control different business flows and return
    dynamic Views according to the need.
  prefs: []
  type: TYPE_NORMAL
- en: There are other approaches to working with UIs in ASP.NET Core 9. Let’s learn
    a little more about other options, such as using Blazor and integrations with
    JavaScript frameworks, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring UI client rendering with Blazor and JavaScript frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core 9 has several frameworks that provide the creation of UIs with
    high quality and good user experience, using client-side and server-side approaches.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about the newest technology that uses the **WebAssembly** standard,
    called Blazor, which is a powerful and flexible UI framework. However, if you
    are used to JavaScript frameworks, you can also benefit from the . NET platform.
  prefs: []
  type: TYPE_NORMAL
- en: Rich UIs with Blazor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as with Razor Pages and MVC, Blazor offers a **single-page application**
    ( **SPA** ) framework on the .NET platform, running both client-side and server-side,
    using all the power of C#.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor WebAssembly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The client-server version of Blazor runs on the WebAssembly platform, which
    is a compact bytecode with an optimized format, fast to download, and provides
    great performance when running on the client side, creating rich UI experiences.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 2* *.11* , Blazor is an abstraction of ASP.NET Core
    for WebAssembly. This way, the Blazor code will generate application assemblies,
    which require the .NET runtime for execution, also allowing interaction between
    WebAssembly and the HTML document.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly
  prefs: []
  type: TYPE_NORMAL
- en: 'WebAssembly is a web standard, and you can learn more about it at the official
    website: [https://webassembly.org/](https://webassembly.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – WebAssembly and Blazor](img/B21788_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – WebAssembly and Blazor
  prefs: []
  type: TYPE_NORMAL
- en: The WebAssembly platform uses an interoperability model, which allows it to
    interact with all browser APIs, running in a sandbox, providing security against
    malicious actions, and also allowing the execution of . NET code.
  prefs: []
  type: TYPE_NORMAL
- en: All page code developed is compiled into .NET assemblies. Thus, when accessing
    the page through the browser, both the assemblies and the .NET runtime are downloaded.
    Then, with the support of WebAssembly, the application runs and uses JavaScript
    interop to handle **DOM** ( **Document Object Model** ) manipulation and browser
    API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor is a flexible framework that also allows you to create projects with
    the benefits of server-side processing, offering an excellent client-side experience.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Blazor also allows for a server-side UI rendering approach. However, unlike
    what happens with Razor Pages and MVC, instead of rendering the entire HTML for
    each client request and returning a complete document as a response, Blazor creates
    a graph, which represents the page components, considering properties and state.
  prefs: []
  type: TYPE_NORMAL
- en: Then, with each interaction, Blazor performs an evaluation of the graph and
    produces a binary representation, which is sent back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor’s server-side approach uses **SignalR** technology, which allows you
    to update the UI through a direct connection to the server, bringing better usability
    and a rich user experience. We will cover SignalR in [*Chapter 4*](B21788_04.xhtml#_idTextAnchor061)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Blazor Server brings great benefits in the development of web-based solutions,
    with C# as a common language, bringing security, reliability, and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s understand the development approach using Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor components and structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as with some JavaScript frameworks, such as Angular, Blazor works with
    a component structure.
  prefs: []
  type: TYPE_NORMAL
- en: A component is one or more UI elements developed with a specific objective,
    according to the needs of the application. This component can be reused throughout
    the application, enabling separation of responsibilities, reusability, and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: All Blazor components have the **.razor** extension and use both the Razor syntax
    and all the benefits of C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a Blazor project, simply use the **dotnet** CLI, with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Interactivity Render Mode
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 9 introduces the render interactive mode on Blazor Apps. The interactive
    render mode feature enhances the way Blazor apps handle rendering, introducing
    a mode where the server-rendered static HTML is progressively enhanced into a
    fully interactive client-side application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goals of this feature are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Progressive Enhancement: When a Blazor app is initially loaded, the server
    pre-renders the HTML, providing a fully functional page for users to interact
    with immediately. This allows the app to seamlessly transition from this static
    HTML to a fully interactive Blazor app once the Blazor framework is loaded on
    the client side.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Seamless Transition: ensures the app appears interactive even while the client-side
    Blazor runtime is being initialized and users can start interacting with the app
    before the complete Blazor runtime is ready, making the user experience smoother.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Improved Performance: optimizes the time-to-interactivity by reducing the noticeable
    delay that users might experience in traditional Blazor Server or Blazor WebAssembly
    apps.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enhanced User Experience: minimizes interruptions or loading indicators during
    transitions, giving users a better perception of speed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you create a Blazor app using the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dotnet new blazor --** **name MyFirstBlazorApp**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default interactive mode is Server. In case you want to leverage the new
    feature, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dotnet new blazor --name MyFirstBlazorApp --** **interactivity Auto**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about this new feature, access the following URL: [https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-9.0)'
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the project, just open the **Pages** folder, and you will then
    find some components as shown in *Figure 2* *.12* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – The Blazor project structure](img/B21788_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – The Blazor project structure
  prefs: []
  type: TYPE_NORMAL
- en: There are components that are defined as pages and therefore have the **@pages**
    directive, where a route to access the page is defined. There are also components
    that are added to pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Counter.razor** file is a page component and has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is use of Razor and HTML syntax, as we learned in the Razor
    Pages and MVC approaches. There is also C# code between the **@code {}** tags.
  prefs: []
  type: TYPE_NORMAL
- en: The C# code defined in the preceding file has the functionality to increment
    a counter when the user clicks on the **Click** **me** button.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML button tag has the **@onclick** attribute, which is defined with the
    name defined in the C# code block.
  prefs: []
  type: TYPE_NORMAL
- en: For simple components, the approach of using HTML and C# code in the same file
    may be valid. However, it is good practice to separate business rules from the
    UI. Therefore, Blazor allows a file to be created containing the component’s C#
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code example, there would be two files: **Counter.razor**
    and **Counter.razor.cs** . All C# code could be moved to the new file generating
    the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Blazor is very flexible and offers a huge range of possibilities for developing
    rich web-based applications, integrated with HTML, CSS, and JavaScript and using
    the most modern technologies. It would take an exclusive book to talk about Blazor,
    however; this book will focus on approaches based on Razor Pages and MVC.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 9 is very flexible when it comes to developing UIs, featuring different
    frameworks. But if you are familiar with Angular, React, or Vue.js, you can benefit
    from the power of the . NET platform.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 9 and JavaScript frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learned during the other topics in this chapter, ASP.NET Core 9 offers
    several approaches to building a UI, interacting with C# code. There are several
    related benefits, including the use of a common development model, using the Razor
    syntax, and all the benefits of the . NET platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you are used to using a framework for building SPAs, such as Angular,
    Vue.js, and React, the .NET platform has some templates available for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – ASP.NET Core 9 JavaScript frameworks template](img/B21788_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – ASP.NET Core 9 JavaScript frameworks template
  prefs: []
  type: TYPE_NORMAL
- en: The **React and ASP.NET Core** template creates two projects, one for the frontend
    and the other for the application’s backend.
  prefs: []
  type: TYPE_NORMAL
- en: SPAs use the approach where the UI is developed independently of the backend,
    which is generally an external service or application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the model offered by ASP.NET Core, there is also a clear separation
    between the UI and the backend. The project is already configured for integration
    with the web API developed in .NET. One of the great benefits of this is the convenience
    of publishing the UI and backend project in a single simple unit, facilitating
    publication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – ASP.NET Core React standalone project structure](img/B21788_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – ASP.NET Core React standalone project structure
  prefs: []
  type: TYPE_NORMAL
- en: Using project templates for frameworks such as Angular, Vue.js, or React is
    completely optional. Even if the UI project is created independently, we can benefit
    from ASP.NET Core by developing web APIs to serve the UI. We’ll talk about creating
    web APIs in [*Chapter 3*](B21788_03.xhtml#_idTextAnchor044) .
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the platform offers several approaches for developing high-quality
    web-based systems. Each ASP.NET Core UI framework has several benefits that can
    be combined to generate even more powerful solutions, and we will look at these
    solutions in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with hybrid solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the great benefits of working on a powerful platform such as ASP.NET
    Core is having the ability to integrate between technologies. Therefore, we can
    combine all the power of Razor Pages, MVC, and Blazor in the same project.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of integration with Blazor, there is the benefit of using **.razor**
    components, providing reusability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blazor integration into Razor Pages or MVC projects must be configured according
    to the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the project root, add a file named **_Imports.razor** . This file will be
    responsible for importing the namespaces necessary for the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that at the end of the file, there is a **{CHANGE_FOR_THE_NAMESPACE_OF_YOUR_PROJECT}**
    tag. Change this value to your project namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, it will be necessary to change the **_Layout.cshtml** file, located in
    **Pages/Shared** directory in the case of the Razor Pages project or in the **Views/Shared**
    directory for MVC projects. Add the following code in the head element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The purpose of defining **<base href="~/"/>** is to define the base path of
    the application, while the **component** tag is used to render the contents of
    the Razor components in the HTML head element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following script before the **@await RenderSection(...)** render section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Don’t worry about the script path, much less creating it. This will be done
    automatically by the framework.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, open the **Program.cs** file to make some modifications. First, we must
    register the Blazor services so that they are available while the application
    is running. Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You also need to add the Blazor route mapping control. Add the following line
    below the **MapRazorPages** call (in the case of a Razor Pages project) or the
    **MapControllerRoute** call (in the case of an MVC project):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the project is integrated with Blazor, let’s create a component with
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called **technology.razor** in the **Pages/Shared** (Razor Pages)
    or **Views/Shared** (MVC) folder and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code creates a **Load** button with a click event that will load
    a list of technologies. This list of technologies was created in the **@code{}**
    session, using an array of strings. When running the application, the screen will
    be similar to *Figure 2* *.15* :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Page/View using the Blazor component](img/B21788_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – Page/View using the Blazor component
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this component, add the following code to any MVC Razor page or View:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When running the application, simply use the component to obtain the expected
    result, as shown in *Figure 2* *.16* . This component is reusable and can be added
    to any page or view, bringing greater flexibility and power to UI development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Using a Blazor component with Razor Pages and MVC](img/B21788_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – Using a Blazor component with Razor Pages and MVC
  prefs: []
  type: TYPE_NORMAL
- en: Combining ASP.NET Core UI frameworks can bring benefits during the web-based
    application development process, using the best of each approach.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ve delved into the rich world of the ASP.NET Core UI, gaining
    valuable insights into the available tools for crafting dynamic and engaging UIs.
    You’ve not only understood the key concepts and tools required for implementing
    a server-side UI, but you’ve also discovered the remarkable benefits of WebAssembly
    through Blazor, enabling you to create powerful SPAs in conjunction with ASP.NET
    Core. As you wrap up this chapter, you’ve learned how to seamlessly combine ASP.NET
    Core UI solutions. Now, with a solid foundation in place, I invite you to embark
    on the next exciting journey in [*Chapter 3*](B21788_03.xhtml#_idTextAnchor044)
    , where we’ll explore the world of web APIs and their pivotal role in delivering
    outstanding services. Get ready to take your skills to the next level!
  prefs: []
  type: TYPE_NORMAL
