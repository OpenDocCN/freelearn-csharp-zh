- en: Gameplay and Screen Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to creating believable and immersive games, the material design
    is not the only aspect that we need to take into account. The overall feeling
    can be altered using screen effects. This is very common in movies, for instance,
    when colors are corrected in the post-production phase. You can implement these
    techniques in your games too, using the knowledge from [Chapter 9](part0227.html#6OFFM0-e8c76c858d514bc3b1668fda96f8fa08),
    *Screen Effects with Unity Render Texture*. Two interesting effects are presented
    in this chapter; you can, however, adapt them to fit your needs and create your
    very own screen effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an old movie screen effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a night vision screen effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are reading this book, you are most likely a person who has played a
    game or two in your time. One of the aspects of real-time games is the effect
    of immersing a player into a world to make it feel as if they were actually playing
    in the real world. More modern games make heavy use of screen effects to achieve
    this immersion.
  prefs: []
  type: TYPE_NORMAL
- en: With screen effects, we can turn the mood of a certain environment from calm
    to scary, just by changing the look of the screen. Imagine walking into a room
    that is contained within a level, then the game takes over and goes into a cinematic
    moment. Many modern games will turn on different screen effects to change the
    mood of the current moment. Understanding how to create effects triggered by gameplay
    is next in our journey about shader writing.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to take a look at some of the more common gameplay
    screen effects. You are going to learn how to change the look of the game from
    normal to an old movie effect, and we are going to take a look at how many first-person
    shooter games apply their night vision effects to the screen. With each of these
    recipes, we are going to look at how to hook these up to game events so that they
    are turned on and off as the game's current presentation require.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an old movie screen effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many games are set in different times. Some take place in fantasy worlds or
    future sci-fi worlds, and some even take place in the Old West, where film cameras
    were just being developed and the movies that people watched were black and white
    or sometimes tinted with what is called a **sepia effect**. The look is very distinct,
    and we are going to replicate this look using a screen effect in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few steps to achieving this look; just to make the whole screen
    black and white or grayscale, we need to break down this effect into its component
    parts. If we analyze some reference footage of an old movie, we can begin to do
    this. Let''s take a look at the following image and break down the elements that
    make up the old movie look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00202.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We constructed this image using a few reference images found online. It is always
    a good idea to try and utilize Photoshop to construct images like this to aid
    you in creating a plan for your new screen effect. Performing this process not
    only tells us the elements we will have to code in, but it also gives us a quick
    way to see which blending modes work and how we will construct the layers of our
    screen effect.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know what we have to make, let''s take a look at how each of the
    layers is combined to create the final effect and gather some resources for our
    shader and screen effect script:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sepia tone**: This is a relatively simple effect to achieve, as we just need
    to bring all the pixel colors of the original render texture to a single color
    range. This is easily achieved using the luminance of the original image and adding
    a constant color. Our first layer will look like the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00203.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Vignette effect**: We can always see some sort of soft border around old
    films when they are being projected using an old movie projector. This is caused
    because the bulb that is used for the movie projector has more brightness in the
    middle than it does at the edges of the film. This effect is generally called
    the vignette effect and is the second layer in our screen effect. We can achieve
    this with an overlaid texture over the whole screen. The following screenshot
    demonstrates what this layer looks like, isolated as a texture:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00204.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Dust and scratches**: The third and final layer in our old movie screen effect
    is dust and scratches. This layer will utilize two different tiled textures, one
    for scratches and one for dust. The reason is that we will want to animate these
    two textures over time at different tiling rates. This will give the effect that
    the film is moving along and there are small scratches and dust on each frame
    of the old film. The following screenshot demonstrates this effect isolated to
    its own texture:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00205.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s get our screen effect system ready with the preceding textures. Perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Gather up a vignette texture and a dust and scratches texture, like the ones
    we just saw.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will also need a scene for which we want to emulate the effect we''re trying
    to build. I have created a sample scene that you can use in the `Chapter 10` folder
    of the example code, called `10.1 Starter Scene`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00206.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Create a new shader by duplicating the `ScreenGrayscale` code; select it from
    the Project tab under the `Chapter 9 `| `Shaders` folder and press *Ctrl* + *D*.
    Once duplicated, rename the script to `ScreenOldFilm`. Then, drag and drop the
    script into the `Chapter 10 `| `Shaders` folder, creating it if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go to the `Chapter 9 `| `Scripts` folder and duplicate the `TestRenderImage`
    script. Rename the new file to `RenderOldFilm` and then drag and drop it into
    the `Chapter 10 `| `Scripts` folder, creating it if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, with our screen effect system up and running and our textures gathered,
    we can begin the process of recreating this old film effect.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our individual layers for our old film screen effect are quite simple, but when
    combined, we get some very visually stunning effects. Let's run through how to
    construct the code for our script and shader, then we can step through each line
    of code and learn why things are working the way they are. At this point, you
    should have the screen effects system up and running, as we will not be covering
    how to set this up in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by entering the code in our script. Our first step in modifying
    our script is to rename the class to match our filename, `RenderOldFilm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first block of code that we will enter will define the variable that we
    want to expose to Inspector, in order to let the user of this effect adjust it
    as they see fit. We can also use our mocked-up Photoshop file as a reference when
    deciding what we will need to expose to the Inspector of this effect. Enter the
    following code in your effect script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to fill in the contents of our `OnRenderImage()` function. Here,
    we will be passing the data from our variables to our shader so that the shader
    can then use this data in the processing of the render texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete the script portion of this effect, we simply need to make sure
    that we clamp the values of the variables that need to have a clamped range instead
    of being any value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With our script complete, let''s turn our attention to our shader file. We
    need to create the corresponding variables, which we created in our script in
    our shader. This will allow the script and shader to communicate with one another.
    Enter the following code in the `Properties` block of the shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, as usual, we need to add these same variable names to our `CGPROGRAM`
    block so that the `Properties` block can communicate with the `CGPROGRAM` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we simply fill in the guts of our `frag()` function so that we can process
    the pixels for our screen effect. To start with, let''s get the render texture
    and vignette texture passed to us by the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to add the process for the dust and scratches by entering the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The sepia tone process is next on our list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we combine all of our layers and colors and return the final screen
    effect texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With all of our code entered and no errors, return to the Unity editor and
    add the `RenderOldFilm` component to the `MainCamera` in our example scene. From
    there, drag and drop our shader into the Cur Shader property. Afterward, under
    Sepia Color,  assign a brown color like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00207.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Afterward, assign each of the textures given to the appropriate property. You
    should then notice something similar to the following on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00208.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Also, make sure to hit Play in the Unity Editor to see the full extent of the
    effects of the dust and scratches and the slight image shift that we gave the
    screen effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's walk through each of the layers in this screen effect, break down
    why each of the lines of code is working the way it is, and get more insight about
    how we can add more to this screen effect.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our old film screen effect is working, let's step through the lines
    of code in our `frag()` function, as all the other code should be pretty self-explanatory
    at this point in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Just like our Photoshop layers, our shader is processing each layer and then
    compositing them together, so while we go through each layer, try to imagine how
    the layers in Photoshop work. Keeping this concept in mind always helps when developing
    new screen effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have the first set of lines of code in our `frag()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first line of code, just after the `frag()` function declaration, is the
    definition of how the UVs should work for our main render texture or the actual
    rendered frame of our game. As we are looking to fake the effect of an old film
    style, we want to adjust the UVs of our render texture in every frame, such that
    they flicker. This flickering simulates how the winding of the film's projector
    is just a bit off. This tells us that we need to animate the UVs and this is what
    this first line of code is doing.
  prefs: []
  type: TYPE_NORMAL
- en: We used the built-in `_SinTime` variable, which Unity provides, to get a value
    between `-1` and `1`. We then multiply this by a very small number, in this case,
    `0.005`, to reduce the intensity of the effect. The final value is then multiplied
    again by the `_RandomValue` variable, which we generated in the effect script.
    This value bounces back and forth between `-1` and `1` to basically flip the direction
    of the motion back and forth.
  prefs: []
  type: TYPE_NORMAL
- en: Once our UVs are built and stored in the `renderTexUV` variable, we can sample
    the render texture using a `tex2D()` function. This operation then gives us our
    final render texture, which we can use to process further in the rest of the shader.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on to the last line in the previous image, we simply do a straight sample
    of the vignette texture using the `tex2D()` function. We don't need to use the
    animated UVs we already created, as the vignette texture will be tied to the motion
    of the camera itself and not to the flickering of the camera film.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These lines of code are almost exactly like the previous lines of code, in which
    we need to generate unique animated UV values to modify the position of our screen
    effect layers. We simply use the built-in `_SinTime` value to get a value between
    `-1` and `1`, multiply it by our random value, and then by another multiplier
    to adjust the overall speed of the animation. Once these UV values are generated,
    we can then sample our dust and scratches texture using these new animated values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next set of code handles the creation of the colorizing effect for our
    old film screen effect. The following code snippet demonstrates these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With this set of code, we are creating the actual color tinting of the entire
    render texture. To accomplish this, we first need to turn the render texture into
    the grayscale version of itself. To do this, we can use the luminosity values
    given to us by the `YIQ` values. `YIQ` values are the color space used by the
    NTSC color TV system. Each letter in `YIQ` actually stores color constants that
    are used by TVs to adjust the color for readability.
  prefs: []
  type: TYPE_NORMAL
- en: While it is not necessary to actually know the reasons for this color scale,
    it should be known that the `Y` value in `YIQ` is the constant luminance value
    for any image. So, we can generate a grayscale image of our render texture by
    taking each pixel of the render texture and dotting it with our luminance values.
    This is what the first line in this set is doing.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the luminance values, we can simply add the color we want to tint
    the image with. This color is passed from our script to our shader, then to our
    `CGPROGRAM` block, where we can add it to our grayscale render to texture. Once
    completed, we will have a perfectly tinted image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we create the blending between each of our layers in our screen effect.
    The following code snippet shows the set of code we are looking at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Our last set of code is relatively simple and doesn't really need a ton of explanation.
    In short, it is simply multiplying all the layers together to reach our final
    result. Just like we multiplied our layers together in Photoshop, we multiply
    them together in our shader. Each layer is processed through a `lerp()` function
    so that we can adjust the opacity of each layer, which gives more artistic control
    over the final effect. The more tweaks one can offer, the better when it comes
    to screen effects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information on the `YIQ` values, refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/YIQ](http://en.wikipedia.org/wiki/YIQ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.blackice.com/colorspaceYIQ.htm](http://www.blackice.com/colorspaceYIQ.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a night vision screen effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our next screen effect is definitely a more popular one. The night vision screen
    effect is seen in *Call of Duty: Modern Warfare*, *Halo*, and just about any first-person
    shooter out in the market today. It is the effect of brightening the whole image
    using that very distinct lime-green color.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to achieve our night vision effect, we need to break down our effect
    using Photoshop. It is a simple process of finding some reference images online
    and composing a layered image to see what kind of blending modes you will need
    or in which order we will need to combine our layers. The following screenshot
    shows the result of performing just this process in Photoshop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00209.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's begin to break down our rough Photoshop composite image into its component
    parts so that we can better understand the assets we will have to gather. In the
    next recipe, we will cover the process of doing this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin this screen effect by again breaking down our effect into its
    component layers. Using Photoshop, we can construct a layered image to better
    illustrate how we can go about capturing the effect of night vision:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tinted green**: Our first layer in our screen effect is the iconic green
    color, found in just about every night vision image. This will give our effect
    that signature night vision look, as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00210.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Scan lines**: To increase the effect of this being a new type of display
    for the player, we include scan lines over the top of our tinted layer. For this,
    we will use a texture created in Photoshop and let the user tile it so that the
    scan lines can be bigger or smaller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Noise**: Our next layer is a simple noise texture that we tile over the tinted
    image and scan lines to break up the image and add even more detail to our effect.
    This layer simply emphasizes that digital read-out look:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00211.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Vignette**: The last layer in our night vision effect is the vignette. If
    you look at the night vision effect in *Call of Duty: Modern Warfare*, you will
    notice that it uses a vignette that fakes the effect of looking down a scope.
    We will do that for this screen effect:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00212.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create a screen effect system by gathering our textures. Perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Gather up a vignette texture, noise texture, and scan line texture, like the
    ones we just saw. Like before, I have these textures available in the book's example
    code under the `Chapter 10` | `Textures` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find a sample scene to make it easy to see the effect of the shader. I will
    be using the same scene as in the previous recipe, so feel free to use the `10.1
    Sample Scene` again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new shader by duplicating the `ScreenGrayscale` code; select it from
    the Project tab under the `Chapter 9` | `Shaders` folder and press *Ctrl *+ *D*.
    Once duplicated, rename the script to  `ScreenNightVision`. Then drag and drop
    the script into the `Chapter 10 `| `Shaders` folder, creating it if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go the `Chapter 9 `| `Scripts` folder and duplicate the `TestRenderImage` script.
    Rename the new file to `RenderNightVision` and then drag and drop it into the `Chapter
    10 `| `Scripts` folder, creating it if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, with our screen effect system up and running and our textures gathered,
    we can begin the process of recreating this night vision effect.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all of our assets gathered and the screen effect system running smoothly,
    let''s begin to add the code necessary to both the script and shader. We will
    begin our coding with the `RenderNightVision.cs` script, so double-click on this
    file now to open it in your code editor of choice:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by entering the code in our script. Our first step in modifying
    our script is to rename the class to match our filename, `RenderNightVision`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to create a few variables that will allow the user of this effect to
    adjust it in the script''s Inspector. Enter the following code in the `NightVisionEffect.cs`
    script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to complete our `OnRenderImage()` function so that we are passing
    the right data to the shader in order for the shader to process the screen effect
    properly. Complete the `OnRenderImage()` function with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete the `NightVisionEffect.cs` script, we simply need to make sure
    that we clamp certain variables so that they stay within a range. These ranges
    are arbitrary and can be changed at a later time. These are just values that worked
    well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now turn our attention over to the shader portion of this screen effect.
    Open the shader, if you haven''t already, and begin by entering the following
    properties in the `Properties` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure that we are passing the data from our `Properties` block to our
    `CGPROGRAM` block, we need to make sure to declare them with the same name in
    the `CGPROGRAM` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Our effect is also going to include a lens distortion to further convey the
    effect that we are looking through a lens and the edges of the image are being
    distorted by the angle of the lens. Enter the following function just after the
    variable declarations in the `CGPROGRAM` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now concentrate on the meat of our `NightVisionEffect` shader. Let''s
    start this by entering the code that is necessary to get the render texture and
    vignette texture. Enter the following code in the `frag()` function of our shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step in our `frag()` function is to process the scan lines and `Noise`
    textures and apply the proper animated UVs to them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete all of our layers in the screen effect, we simply need to process
    the luminance value of our render texture, and then apply the night vision color
    to it to achieve that iconic night vision look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we will combine all the layers together and return the final color
    of our night vision effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have finished entering the code, return to the Unity editor to let
    the script and shader compile. If there are no errors, select the `MainCamera`
    in your scene. Remove the Render Old Film component, if it is there already, and
    add the `RenderNightVision` component. Once there, drag and drop the `ScreenNightVision`
    shader into the Cur Shader property of the component and then assign the Night
    Vision Color property to a green color like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00213.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Afterward, assign the textures to their proper spot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00214.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Afterward, make sure to play in the editor to see the full, final version of
    the effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00215.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The final result of our night-vision screen effect
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The night vision effect is actually very similar to the old film screen effect,
    which shows us just how modular we can make these components. Just by simply swapping
    the textures that we are using for overlays and changing the speed at which our
    tiling rates are being calculated, we can achieve very different results using
    the same code.
  prefs: []
  type: TYPE_NORMAL
- en: The only difference with this effect is the fact that we are including a lens
    distortion to our screen effect. So let's break this down so that we can get a
    better understanding of how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not uncommon in video games to have the need to highlight certain objects.
    For instance, a thermal visor should only apply a post-processing effect to people
    and other sources of heat. Doing this is already possible with the knowledge gathered
    so far in this book; you can, in fact, change the shader or material of an object
    by code. However, this is often laborious and has to be replicated on every the
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more effective way to use replaced shaders. Each shader has a tag called
    `RenderType` that has never been used so far. This property can be used to force
    a camera to apply a shader only to certain objects. You can do this by attaching
    the following script to the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After entering the play mode, the camera will query all the objects that it
    has to render. If they don't have a shader decorated with `RenderType = "Heat"`,
    they will not be rendered. Objects with such a tag will be rendered with the shader
    attached to the script.
  prefs: []
  type: TYPE_NORMAL
