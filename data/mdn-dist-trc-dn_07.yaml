- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Adding Custom Metrics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自定义度量值
- en: In the previous chapter, we looked into manual distributed tracing instrumentation,
    which should help us debug individual operations or analyze service usage with
    ad hoc queries. Here, we’ll talk about metrics. First, we’ll learn when to use
    them, understand cardinality requirements, and then see how traces and metrics
    complement each other. We’ll explore the metrics API’s evolution in .NET and then
    spend most of this chapter talking about OpenTelemetry metrics. We’ll cover **instruments**
    such as counters, gauges, and histograms, and learn about each of them in depth.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了手动分布式跟踪仪表化，这应该有助于我们通过临时查询调试单个操作或分析服务使用情况。在这里，我们将讨论度量值。首先，我们将学习何时使用它们，了解基数要求，然后了解跟踪和度量值如何相互补充。我们将探讨.NET中度量值API的演变，然后在本章的大部分内容中讨论OpenTelemetry度量值。我们将涵盖**仪表**，如计数器、仪表和直方图，并深入了解每个仪表。
- en: 'We will cover the following topics in the chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The benefits, limitations, and evolution of metrics in .NET
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET中度量值的优点、局限性和演变
- en: How and when to use different counters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何以及何时使用不同的计数器
- en: How to record and use gauges
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何记录和使用仪表
- en: How to record value distribution with histograms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用直方图记录值分布
- en: By the end of this chapter, you should be able to pick the right instrument
    for each scenario and implement and use it in your applications to analyze performance,
    health, and usage.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够为每个场景选择合适的仪表，并在你的应用程序中实现和使用它来分析性能、健康和用法。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter is available in this book’s repository on GitHub at
    [https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter7](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter7).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在GitHub上本书的存储库中找到：[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter7](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter7)。
- en: 'To run the samples and perform analysis, we’ll need the following tools:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例和执行分析，我们需要以下工具：
- en: .NET SDK 7.0 or later
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET SDK 7.0或更高版本
- en: Docker and `docker-compose`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker和`docker-compose`
- en: Metrics in .NET – past and present
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET中的度量值——过去和现在
- en: Even though we are focusing on distributed tracing in this book, learning about
    metrics is important to understand when and how to use them to improve observability.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这本书中专注于分布式跟踪，但了解度量值对于理解何时以及如何使用它们来提高可观察性非常重要。
- en: Metrics allow us to report data that’s been aggregated over a certain period
    and set of attributes (that is, dimensions or tags). A metric can be represented
    as a set of time series where each series measures the change of one indicator
    with a unique combination of attribute values over time. Examples include CPU
    utilization for a given service instance or HTTP request latency for a given route,
    HTTP method, response code, and instance.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 度量值使我们能够报告在一定时间段和一组属性（即维度或标签）上聚合的数据。度量值可以表示为一系列时间序列，其中每个序列测量一个指标随时间变化的唯一属性值组合。例如，包括特定服务实例的CPU利用率或特定路由、HTTP方法、响应代码和实例的HTTP请求延迟。
- en: The key difference between traces and metrics is aggregation – traces capture
    individual operations with detailed attributes. Traces answer questions such as
    “*What happened with this specific request?*” and “*Why did it happen?*” Metrics,
    on the other hand, tell us what happens in the system or specific parts of it,
    how common a failure is, how widespread the performance issue is, and so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪和度量值之间的主要区别在于聚合——跟踪捕获具有详细属性的单独操作。跟踪回答诸如“*这个特定请求发生了什么？*”和“*为什么会发生？*”等问题。另一方面，度量值告诉我们系统或其特定部分发生了什么，失败的常见程度如何，性能问题有多普遍，等等。
- en: Before diving into the use cases, benefits, and APIs of metrics, we first need
    to learn about the main limitation of metrics – low **cardinality**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究度量值的使用案例、优点和API之前，我们首先需要了解度量值的主要限制——低**基数**。
- en: Cardinality
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基数
- en: Cardinality represents number of combinations of unique attributes or number
    of time series. Adding a new attribute causes a combinatorial explosion of a time-series
    number, which leads to the combinatorial growth of a metric’s volume.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 基数表示唯一属性组合的数量或时间序列的数量。添加一个新属性会导致时间序列数量的组合爆炸，这会导致度量值体积的组合增长。
- en: Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Metrics should have low cardinality, but “low” and “high” are relative – their
    definition depends on the budget, backend limits, and local memory consumption.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 指标应该具有低基数，但“低”和“高”是相对的——它们的定义取决于预算、后端限制和本地内存消耗。
- en: For example, a relatively big Prometheus instance can support millions of active
    time series. If we have 1,000 instances of a service running, and the service
    exposes four HTTP routes with three methods each and returns five different status
    codes, we’re going to report 1,000 (instances) * 4 (routes) * 3 (methods) * 5
    (status codes) = 60K time series of an HTTP server’s request duration metric (at
    worst). If we try to include something such as the `customer_id` attribute and
    have 1,000 active customers, we’ll start reporting 60M time series for the HTTP
    server request duration metric only.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个相对较大的 Prometheus 实例可以支持数百万个活跃的时间序列。如果我们有 1,000 个服务实例正在运行，并且该服务公开了四个 HTTP
    路由，每个路由有三个方法，并返回五个不同的状态码，我们将报告 1,000（实例）* 4（路由）* 3（方法）* 5（状态码）= 60K 个 HTTP 服务器请求持续时间指标的时序（在最坏的情况下）。如果我们尝试包含诸如
    `customer_id` 属性之类的信息，并且有 1,000 个活跃客户，我们仅对 HTTP 服务器请求持续时间指标就开始报告 60M 个时序。
- en: We can still do this by scaling Prometheus horizontally, so reporting a few
    high-cardinality attributes is still feasible when justified.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以通过水平扩展 Prometheus 来做到这一点，因此当有正当理由时，报告一些高基数属性仍然是可行的。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Metrics are aggregated in memory before they are exported, so metrics with high
    cardinality may affect application performance.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 指标在导出之前在内存中聚合，因此具有高基数的指标可能会影响应用程序性能。
- en: There are no limits in terms of attribute cardinality in .NET, but the OpenTelemetry
    SDK has configurable limits on the maximum number of metrics and the number of
    attribute combinations per metric.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，属性基数没有限制，但 OpenTelemetry SDK 对每个指标的最大指标数和每个指标的属性组合数有可配置的限制。
- en: When to use metrics
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用指标
- en: Resource consumption, low-level communication details, or the number of open
    connections are best represented by metrics. In other cases, we have a choice
    and can report telemetry as metrics, spans, or events. For example, if we want
    to measure number of incoming HTTP requests by route, we can query spans that
    are filtered by service, route, and timestamp. Should we also report metrics for
    it? Let’s see.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 资源消耗、低级通信细节或打开连接的数量最好用指标表示。在其他情况下，我们有选择，可以将遥测报告为指标、跨度或事件。例如，如果我们想按路由测量传入 HTTP
    请求的数量，我们可以查询按服务、路由和时间戳过滤的跨度。我们也应该报告关于它的指标吗？让我们看看。
- en: 'Metrics are implemented and optimized under the assumption of low cardinality,
    which enables several important benefits:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 指标是在假设低基数的情况下实现和优化的，这带来了几个重要的好处：
- en: '**Predictable costs and limited resource consumption**: The metrics’ volume
    does not grow much as load increases – we only get a new set of time series when
    the service scales up adding new instances.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可预测的成本和有限的资源消耗**：随着负载的增加，指标的量增长不多——只有当服务扩展并添加新实例时，我们才会得到一组新的时序。'
- en: '**Low performance impact**: Reporting a single measurement can be done without
    allocating memory.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低性能影响**：报告单个测量值无需分配内存。'
- en: '**Unbiased usage and performance data**: Metrics are recorded regardless of
    sampling decisions. Metrics don’t always report exact data, but we can control
    their precision by configuring collection intervals and histogram boundaries.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无偏的使用和性能数据**：指标不受采样决策的影响而记录。指标并不总是报告精确数据，但我们可以通过配置收集间隔和直方图边界来控制它们的精度。'
- en: '**Fast and cheap(er) queries**: While observability backends store metrics
    in different ways and their pricing options vary, metrics are much more compact,
    which usually leads to faster ingestion and cheaper queries.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速且便宜（更便宜）的查询**：虽然可观察性后端以不同的方式存储指标，并且它们的定价选项各不相同，但指标通常更紧凑，这通常会导致更快的摄取和更便宜的查询。'
- en: Metrics work best when we use them to monitor service health and usage regularly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定期使用指标来监控服务健康和利用率时，指标效果最佳。
- en: 'When you want to instrument some operation and are in doubt about which signal
    to use, the following strategy can help: if you need unbiased data or want to
    create an alert or a chart on a dashboard, use metrics. Otherwise, start with
    tracing and ad hoc queries. If you find yourself running a lot of similar queries
    over traces, then add a metric to optimize such queries.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想对某些操作进行仪表化并且对使用哪个信号有疑问时，以下策略可以有所帮助：如果你需要无偏数据或想在仪表板上创建警报或图表，请使用指标。否则，从跟踪和临时查询开始。如果你发现自己正在大量运行类似的跟踪查询，那么添加一个指标以优化此类查询。
- en: Assuming your tracing backend does not support rich queries, you probably want
    to be more proactive in adding metrics. And if your backend is optimized for high-cardinality
    data and ad hoc analysis, you might not need metrics much.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的跟踪后端不支持丰富的查询，你可能希望更加主动地添加指标。如果你的后端针对高基数数据和即兴分析进行了优化，你可能不需要很多指标。
- en: Now that we have a rough idea of when we need metrics, let’s dive into instrumentation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对何时需要指标有了大致的了解，让我们深入了解仪表化。
- en: Reporting metrics
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 报告指标
- en: There are a few different metrics (and counters) APIs in .NET – let’s take a
    look at them and learn when to use them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中有几个不同的指标（和计数器）API - 让我们来看看它们，并了解何时使用它们。
- en: Performance counters
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能计数器
- en: The `System.Diagnostics.PerformanceCounter` class and its friends implement
    Windows performance counters. They don’t support dimensions. These limitations
    make performance counters an unlikely choice for a modern distributed system monitoring
    story.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Diagnostics.PerformanceCounter`类及其相关类实现了Windows性能计数器。它们不支持维度。这些限制使得性能计数器不太可能成为现代分布式系统监控故事的理想选择。'
- en: Event counters
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件计数器
- en: '`System.Diagnostics.Tracing.EventCounter` is a cross-platform implementation
    of a counter, which represents a single time series – we saw it in action in [*Chapter
    2*](B19423_02.xhtml#_idTextAnchor038), *Native Monitoring in .NET*, and [*Chapter
    4*](B19423_04.xhtml#_idTextAnchor068), *Low-Level Performance Analysis with Diagnostic
    Tools*, where we collected counters coming from .NET with `dotnet-counters` and
    `dotnet-monitor`. OpenTelemetry can listen to them too, converting them into OpenTelemetry
    metrics and enriching them with resource attributes.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Diagnostics.Tracing.EventCounter`是一个跨平台的计数器实现，它代表一个单一的时间序列 - 我们在[*第2章*](B19423_02.xhtml#_idTextAnchor038)，*Native
    Monitoring in .NET*，和[*第4章*](B19423_04.xhtml#_idTextAnchor068)，*Low-Level Performance
    Analysis with Diagnostic Tools*中看到了它的实际应用，在那里我们使用`dotnet-counters`和`dotnet-monitor`收集了来自.NET的计数器。OpenTelemetry也可以监听它们，将它们转换为OpenTelemetry指标，并用资源属性丰富它们。'
- en: If you want to report a metric that does not need any dimensions except static
    context and want to be able to dynamically turn this metric on and off using diagnostics
    tools, event counters would be a good choice.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要报告一个不需要任何维度（除了静态上下文）的指标，并且希望能够使用诊断工具动态地打开和关闭此指标，事件计数器将是一个不错的选择。
- en: We’re not going to dive into the `EventCounter` API, so please refer to the
    .NET documentation ([https://learn.microsoft.com/dotnet/core/diagnostics/event-counters](https://learn.microsoft.com/dotnet/core/diagnostics/event-counters))
    to find out more.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨`EventCounter` API，所以请参考.NET文档([https://learn.microsoft.com/dotnet/core/diagnostics/event-counters](https://learn.microsoft.com/dotnet/core/diagnostics/event-counters))以获取更多信息。
- en: OpenTelemetry metrics
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenTelemetry指标
- en: The APIs we’re going to focus on are available in the `System.Diagnostics.Metrics`
    namespace in the `System.Diagnostics.DiagnosticSource` NuGet package. These APIs
    follow OpenTelemetry’s metrics specification and terminology, except the term
    “tags” is used instead of “attributes.” There is no shim for metrics.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要关注的API在`System.Diagnostics.Metrics`命名空间中，位于`System.Diagnostics.DiagnosticSource`
    NuGet包中。这些API遵循OpenTelemetry的指标规范和术语，除了使用“tags”代替“attributes”这个术语。没有为指标提供适配器。
- en: 'The metrics API supports recording multi-dimensional data using the following
    instruments:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 指标API支持使用以下仪表记录多维数据：
- en: '**Counter**: Represents a value that increments over time – for example, the
    number of open connections'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Counter**: 表示随时间增加的值 - 例如，打开的连接数'
- en: '**UpDownCounter**: Represents an additive value that increments or decrements
    over time – for example, the number of active connections'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UpDownCounter**: 表示随时间增加或减少的加法值 - 例如，活动连接数'
- en: '**Gauge**: Represents a current value – for example, the sequence number of
    the last message received from the messaging queue'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gauge**: 表示当前值 - 例如，从消息队列接收到的最后一条消息的序列号'
- en: '**Histogram**: Represents a distribution of value – for example, HTTP request
    latency'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Histogram**: 表示值的分布 - 例如，HTTP请求延迟'
- en: 'Instruments can be created with the `Meter` class. So, first, we need an instance
    of `Meter`, which we can create using a name and optional instrumentation version:
    `Meter meter =` `new ("sample")`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`Meter`类创建仪表。因此，首先我们需要一个`Meter`实例，我们可以使用一个名称和可选的仪表版本来创建它：`Meter meter =
    new("sample")`。
- en: 'The name of `Meter` can match the application name, namespace, class, or anything
    else that makes sense in your case. It’s used to enable metrics, as shown in the
    following example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meter` 的名称可以与应用程序名称、命名空间、类或其他在您的情况下有意义的任何内容匹配。它用于启用指标，如下面的示例所示：'
- en: Program.cs
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Program.cs
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Program.cs)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Program.cs)'
- en: Here, we enabled all metrics coming from any `Meter` whose name starts with
    `queue.` (we can use an exact match or wildcards).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们启用了所有来自以 `queue.` 开头的 `Meter` 的指标（我们可以使用精确匹配或通配符）。
- en: '`Meter` is disposable. In some cases, when you use the same `Meter` instance
    for the application’s lifetime, you can make `Meter` instances static; otherwise,
    make sure to dispose of them to disable all nested instruments.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meter` 是可丢弃的。在某些情况下，当您在整个应用程序的生命周期中使用相同的 `Meter` 实例时，可以将 `Meter` 实例设置为静态；否则，请确保将其丢弃以禁用所有嵌套仪器。'
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We can listen to metrics directly, without OpenTelemetry, using the `System.Diagnostics.Metrics.MeterListener`
    class. It can subscribe to specific instruments and record their measurements.
    `MeterListener` is used by OpenTelemetry, so you might find it useful to debug
    instrumentation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接监听指标，无需 OpenTelemetry，使用 `System.Diagnostics.Metrics.MeterListener` 类。它可以订阅特定的仪器并记录它们的测量值。`MeterListener`
    被OpenTelemetry使用，因此您可能会发现它在调试仪器时很有用。
- en: Now that we have a `Meter` instance and configured OpenTelemetry to export metrics,
    we can create instruments using factory methods on the `Meter` class; for example,
    `meter.CreateCounter<long>("connections.open")`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `Meter` 实例并配置了 OpenTelemetry 以导出指标，我们可以使用 `Meter` 类的工厂方法创建仪器；例如，`meter.CreateCounter<long>("connections.open")`。
- en: 'We’ll see how to create instruments later in this chapter, but for now, here’s
    a list of common instrument properties:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面看到如何创建仪器，但到目前为止，这里有一个常见仪器属性的列表：
- en: '`byte`, `short`, `int`, `long`, `float`, `double`, or `decimal`).'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (`byte`, `short`, `int`, `long`, `float`, `double`, 或 `decimal`)。
- en: '**The instrument name** represents a unique exported metric name; it’s a required
    property. OpenTelemetry limits the instrument name to 63 characters and has other
    limitations. We’ll talk about it more in [*Chapter 9*](B19423_09.xhtml#_idTextAnchor148),
    *Best Practices*.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪器名称**代表一个唯一的导出指标名称；这是一个必需的属性。OpenTelemetry将仪器名称限制为63个字符，并具有其他限制。我们将在[*第9章*](B19423_09.xhtml#_idTextAnchor148)的*最佳实践*中进一步讨论。'
- en: '**A unit** represents an optional value unit following Unified Code for Units
    and Measure ([https://unitsofmeasure.org/](https://unitsofmeasure.org/)).'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单位**代表统一单位与度量代码（[https://unitsofmeasure.org/](https://unitsofmeasure.org/)）之后的可选值单位。'
- en: '**The description** is an optional free-form piece of text that briefly describes
    the instrument.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**是一个可选的自由格式文本，简要描述仪器。'
- en: We can create multiple instances of instruments with the same name in the process
    – the OpenTelemetry SDK aggregates data coming from them into one value. Instruments
    are de facto identified by their name, unit, and combination of resource attributes.
    So, measurements from multiple instrument instances that share the same identity
    are aggregated together. Let’s explore instruments one by one and learn how to
    use them, starting with counters.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在进程中创建具有相同名称的多个仪器实例 – OpenTelemetry SDK 将来自它们的聚合数据合并为一个值。仪器实际上是通过其名称、单位和资源属性组合来识别的。因此，来自具有相同身份的多个仪器实例的测量值将一起聚合。让我们逐一探索仪器，并学习如何使用它们，从计数器开始。
- en: Using counters
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计数器
- en: '**Counter** and **UpDownCounter** represent additive values – values that it
    makes sense to sum up. For example, the sum of incoming request counts with different
    HTTP methods makes sense, but the sum of CPU utilization across different cores
    does not.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**Counter** 和 **UpDownCounter** 代表可加值 – 有意义求和的值。例如，具有不同HTTP方法的传入请求数的求和是有意义的，但不同核心的CPU利用率求和则没有意义。'
- en: On the instrumentation side, the only difference between **Counter** and **UpDownCounter**
    is that the former increases monotonically (or stays the same), while the latter
    can decrease. For example, the number of open and closed connections should be
    represented by **Counter**, while the number of active connections should be represented
    by **UpDownCounter**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在仪器方面，**Counter** 和 **UpDownCounter** 之间的唯一区别是前者单调增加（或保持不变），而后者可以减少。例如，打开和关闭的连接数量应该用
    **Counter** 表示，而活动连接的数量应该用 **UpDownCounter** 表示。
- en: 'Both kinds of counters can be synchronous and asynchronous:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种计数器都可以是同步的或异步的：
- en: '**Synchronous** counters report a delta of value when change happens. For example,
    once we successfully initiate a new connection, we can increment counters for
    both open and active connections. Once we’ve finished terminating a connection,
    we decrement the number of active connections only.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步**计数器在值发生变化时报告值的变化量。例如，一旦我们成功启动了一个新的连接，我们可以增加打开和活动连接的计数器。一旦我们完成了连接的终止，我们只减少活动连接的数量。'
- en: '`UpDownCounter` instrument and increment it when the item is enqueued and decrement
    when dequeued or create `ObservableUpDownCounter` and return the queue’s length
    in a callback.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpDownCounter` 仪器在项目入队时增加，在出队或创建 `ObservableUpDownCounter` 并在回调中返回队列长度时减少。'
- en: Let’s instrument in-memory queue processing and learn about each instrument
    as we go.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在内存队列处理中进行仪器化，并在过程中了解每个仪器。
- en: The Counter class
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Counter 类
- en: 'A synchronous counter is implemented in the `System.Diagnostics.Metrics.Counter`
    class. We’ll use it to keep track of the number of enqueued items:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 同步计数器在 `System.Diagnostics.Metrics.Counter` 类中实现。我们将使用它来跟踪入队项的数量：
- en: Producer.cs
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Producer.cs
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Producer.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Producer.cs)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Producer.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Producer.cs)'
- en: Here, we created an instance of the `Meter` class called `queue.producer`. It’s
    static here because we never need to disable corresponding instruments. Then,
    we created a static counter called `queue.enqueue.count` with a `long` type parameter,
    with the unit set to `{count}`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `queue.producer` 的 `Meter` 类实例。在这里它是静态的，因为我们永远不会需要禁用相应的仪器。然后，我们创建了一个名为
    `queue.enqueue.count` 的静态计数器，其参数类型为 `long`，单位设置为 `{count}`。
- en: 'We also need to increment it every time an item is enqueued. `Counter` exposes
    the `Add` method to record a positive delta; it has several overloads to pass
    zero or more attributes. In our sample, we have multiple queues and pass queue
    names:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在每次入队时增加它。`Counter` 提供了 `Add` 方法来记录正的变化量；它有几个重载可以传递零个或多个属性。在我们的示例中，我们有多个队列，并传递队列名称：
- en: Producer.cs
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Producer.cs
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Producer.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Producer.cs)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Producer.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Producer.cs)'
- en: 'Let’s run the sample application with `metrics$ docker-compose up --build`
    and open the metrics endpoint on OpenTelemetry Collector at `http://localhost:8889/metrics`.
    We should see `queue_enqueued_count_total` among other metrics in the Prometheus
    exposition format:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `metrics$ docker-compose up --build` 运行示例应用程序，并在 OpenTelemetry Collector
    的 `http://localhost:8889/metrics` 上打开指标端点。我们应该在 Prometheus 展示格式中看到 `queue_enqueued_count_total`
    等其他指标：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we can see the description, along with the instrument’s type, followed
    by a list of all attribute combinations and the latest reported counter values.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到描述，以及仪器的类型，随后是所有属性组合的列表和最新的计数器值。
- en: We can also visualize this counter in Prometheus (at `http://localhost:9090`).
    Usually, we are interested in rates or trends, and not the absolute value of a
    counter. For example, the rate at which items are enqueued would be a good indication
    of producer load and performance.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在 Prometheus（在 `http://localhost:9090`）中可视化这个计数器。通常，我们对速率或趋势感兴趣，而不是计数器的绝对值。例如，项目入队的速率可以很好地表明生产者的负载和性能。
- en: 'We can get this by using the `sum by (queue) (rate(queue_enqueued_count_total[1m]))`
    query – Prometheus calculates the rate per second (and averages it over 1 minute),
    then sums up values by grouping them by queue name across application instances.
    The corresponding chart is shown in *Figure 7**.1*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `sum by (queue) (rate(queue_enqueued_count_total[1m]))` 查询来获取这个值 –
    Prometheus 计算每秒的速率（并在1分钟内平均），然后通过按队列名称对应用程序实例进行分组来汇总值。相应的图表显示在 *图 7**.1* 中：
- en: '![Figure 7.1 – Enqueue rate per second grouped by queue name](img/Figure_7.01_B19423.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 按队列名称分组的每秒入队速率](img/Figure_7.01_B19423.jpg)'
- en: Figure 7.1 – Enqueue rate per second grouped by queue name
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 按队列名称分组的每秒入队速率
- en: Here, we can see that we enqueue items at around 16 items per second to each
    queue. Instead of `sum`, we could use the `min` or `max` operators to see whether
    there are application instances that stand out.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们以大约每秒16个项目的速度向每个队列中入队。除了 `sum`，我们还可以使用 `min` 或 `max` 运算符来查看是否有突出显示的应用程序实例。
- en: Counters, along with other instruments, expose an `Enabled` flag, which indicates
    whether there are any listeners for this instrument. Meters are not enabled by
    default and the specific instrument could be disabled, so the `Enabled` flag should
    be used to guard any additional work necessary for metric reporting. It’s really
    important for native instrumentations, where end users of such libraries may or
    may not have metrics enabled and the goal is to have zero performance impact when
    metrics are disabled.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器以及其他仪器公开了一个 `Enabled` 标志，该标志指示是否有任何监听器为此仪器。仪表默认情况下是禁用的，并且特定的仪器可以被禁用，因此应该使用
    `Enabled` 标志来保护任何必要的指标报告的额外工作。这对于本地仪器非常重要，因为此类库的最终用户可能已启用或未启用指标，目标是当指标被禁用时没有性能影响。
- en: Other properties that are exposed on the instruments include `Name`, `Unit`,
    `Description`, and `Meter`, which we used to create this instrument.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在仪器上公开的其他属性包括 `Name`、`Unit`、`Description` 和 `Meter`，我们使用这些属性来创建此仪器。
- en: The UpDownCounter class
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UpDownCounter 类
- en: The `System.Diagnostics.Metrics.UpDownCounter` class is very similar to `Counter`
    in terms of the API. You can create one with the `CreateUpDownCounter` method
    on the `Meter` instance by providing an instrument name, along with an optional
    unit and description. The `UpDownCounter` class exposes an `Add` method, which
    takes a delta of the measured value and zero or more tags. It also exposes the
    `Enabled` flag and the properties the instrument was created with, such as its
    name, unit, and description.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Diagnostics.Metrics.UpDownCounter` 类在 API 方面与 `Counter` 类非常相似。您可以通过在
    `Meter` 实例上使用 `CreateUpDownCounter` 方法来创建一个，提供仪器名称，以及可选的单位描述。`UpDownCounter` 类公开了一个
    `Add` 方法，该方法接受测量值的增量以及零个或多个标签。它还公开了 `Enabled` 标志以及仪器创建时使用的属性，例如其名称、单位和描述。'
- en: On the consumption side, however, `UpDownCounter` is different. It’s not monotonic
    and maps to the `gauge` type in Prometheus. We’ll learn more about it in *The
    ObservableUpDownCounter* *class* section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在消费端，`UpDownCounter` 是不同的。它不是单调的，映射到 Prometheus 中的 `gauge` 类型。我们将在 *The ObservableUpDownCounter*
    *类* 部分了解更多关于它的信息。
- en: The ObservableCounter class
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ObservableCounter 类
- en: '`System.Diagnostics.Metrics.ObservableCounter` implements an asynchronous version
    of `Counter`. There is no difference between synchronous and asynchronous counters
    on the consumption side. `ObservableCounter` just provides a more convenient way
    to record counters in a callback executed periodically.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Diagnostics.Metrics.ObservableCounter` 实现了 `Counter` 的异步版本。在消费端，同步和异步计数器之间没有区别。`ObservableCounter`
    只提供了在定期执行的回调中记录计数器的更方便的方式。'
- en: For example, the number of completed (by the thread pool) tasks (`process.runtime.dotnet.thread_pool.completed_items.count`)
    available in the `OpenTelemetryInstrumentation.Runtime` NuGet package is implemented
    as `ObservableCounter`. On every call, it returns the `ThreadPool.CompletedWorkItems`
    property.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 `OpenTelemetryInstrumentation.Runtime` NuGet 包中，可用的完成（由线程池完成）任务的数量（`process.runtime.dotnet.thread_pool.completed_items.count`）被实现为
    `ObservableCounter`。在每次调用时，它返回 `ThreadPool.CompletedWorkItems` 属性。
- en: 'We can create an observable counter with the `CreateObservableCounter` method:
    `Meter.CreateObservableCounter<long>("my.counter", GetValue)`. Here, in addition
    to the name, we pass a lambda function – `GetValue` – which returns the current
    value of the counter.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `CreateObservableCounter` 方法创建一个可观察的计数器：`Meter.CreateObservableCounter<long>("my.counter",
    GetValue)`。在这里，除了名称之外，我们还传递了一个 lambda 函数 – `GetValue` – 该函数返回计数器的当前值。
- en: 'It’s executed when metrics are about to be exported. In our application, this
    happens every 5 seconds, while the default period for the OTLP exporter is 60
    seconds. We configured it with the `OTEL_METRIC_EXPORT_INTERVAL` environment variable,
    but it’s also possible to set it explicitly with the `PeriodicExportingMetricReaderOptions.ExportIntervalMilliseconds`
    property:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 它在指标即将导出时执行。在我们的应用程序中，这每5秒发生一次，而OTLP导出器的默认周期是60秒。我们使用`OTEL_METRIC_EXPORT_INTERVAL`环境变量进行了配置，但也可以通过`PeriodicExportingMetricReaderOptions.ExportIntervalMilliseconds`属性显式设置：
- en: ExplicitConfiguration.cs
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ExplicitConfiguration.cs
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/ExplicitConfiguration.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/ExplicitConfiguration.cs)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/ExplicitConfiguration.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/ExplicitConfiguration.cs)'
- en: The `ExportIntervalMilliseconds` property controls how frequently counter values
    are collected, so it controls the precision and volume of individual time series.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExportIntervalMilliseconds`属性控制计数器值收集的频率，因此它控制了单个时间序列的精度和体积。'
- en: This configuration does not affect pull-based exporters such as Prometheus,
    where it’s controlled externally (for example, with the `scrape_interval` parameter
    on the Prometheus instance). In our sample application, we have the OTLP exporter,
    which is push-based and sends metrics to OpenTelemetry Collector. Collector then
    exposes metrics on the `http://localhost:8889/metrics` endpoint, where Prometheus
    scrapes them from.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置不会影响基于拉取的导出器，如Prometheus，其中它由外部控制（例如，通过Prometheus实例上的`scrape_interval`参数）。在我们的示例应用程序中，我们有OTLP导出器，它是基于推送的，并将指标发送到OpenTelemetry
    Collector。然后收集器在`http://localhost:8889/metrics`端点公开指标，Prometheus从那里抓取它们。
- en: With `ObservableCounter`, we can only record data using the callback provided
    at start time, and there are several overloads of the `CreateObservableCounter`
    method that allow us to report the metric’s value, along with its attributes (via
    the `Measurement` struct) or as a list of `Measurement` instances.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ObservableCounter`，我们只能使用启动时提供的回调记录数据，并且`CreateObservableCounter`方法有几个重载，允许我们报告指标值，以及其属性（通过`Measurement`结构体）或作为`Measurement`实例的列表。
- en: 'There are several important things to know about the callback:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有几件重要的事情需要了解回调：
- en: Unlike the `Counter.Add` method, it reports an absolute value of the counter.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`Counter.Add`方法不同，它报告计数器的绝对值。
- en: It should finish in a reasonable amount of time. We can configure the timeout
    similarly to the export interval with the `OTEL_METRIC_EXPORT_TIMEOUT` environment
    variable or the `PeriodicExportingMetricReaderOptions.ExportTimeoutMilliseconds`
    property.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该在合理的时间内完成。我们可以使用`OTEL_METRIC_EXPORT_TIMEOUT`环境变量或`PeriodicExportingMetricReaderOptions.ExportTimeoutMilliseconds`属性以类似的方式配置超时。
- en: The callback should not return multiple measurements for the same set of attributes.
    The OpenTelemetry SDK’s behavior is not defined for this case.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调不应为同一组属性返回多个测量值。OpenTelemetry SDK对此情况的行为未定义。
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: These requirements are from the OpenTelemetry specification. `MeterListener`
    does not enforce any of them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求来自OpenTelemetry规范。`MeterListener`不会强制执行任何这些要求。
- en: To unsubscribe from observable counters, we must dispose of the corresponding
    `Meter` instance. So, if the counter relies on any instance data and belongs to
    an object with a limited lifetime, we must create `Meter` as an instance variable
    and dispose of it, along with the object it belongs to. Let’s see an example of
    this with `ObservableUpDownCounter`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消订阅可观察计数器，我们必须销毁相应的`Meter`实例。因此，如果计数器依赖于任何实例数据，并且属于具有有限生命周期的对象，我们必须将`Meter`作为实例变量创建，并与其所属的对象一起销毁。让我们通过`ObservableUpDownCounter`的例子来看一下这一点。
- en: The ObservableUpDownCounter class
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ObservableUpDownCounter类
- en: '`System.Diagnostics.Metrics.ObservableUpDownCounter` represents an asynchronous
    version of `UpDownCounter`. Its creation is similar to `ObservableCounter`, but
    its consumption side matches `UpDownCounter`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Diagnostics.Metrics.ObservableUpDownCounter`表示`UpDownCounter`的异步版本。它的创建方式类似于`ObservableCounter`，但其消费端与`UpDownCounter`相匹配。'
- en: We’ll use it to report queue length – it should give us a good indication of
    processor throughput and whether it processes items fast enough.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用它来报告队列长度——它应该能给我们一个很好的指示，关于处理器的吞吐量和它是否足够快地处理项目。
- en: 'The queue length is not monotonic – it can go up and down, so a regular counter
    would not work. We could track it as `UpDownCounter`: we could increment it when
    enqueueing an item and decrement when dequeuing. But if we use `ObservableUpDownCounter`,
    we’ll achieve the same more frugally by only returning the queue length every
    few seconds.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 队列长度不是单调的——它可以上升和下降，因此常规计数器将不起作用。我们可以将其跟踪为 `UpDownCounter`：在入队时增加它，在出队时减少它。但如果我们使用
    `ObservableUpDownCounter`，我们只需每几秒返回一次队列长度，就能更节省地达到相同的效果。
- en: In a more complicated case of a distributed queue, we might not be able to instrument
    both the producer and consumer and would need to periodically get the current
    distributed queue length with a network call to the broker (be careful if you
    decide to do this in the counter callback).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的分布式队列案例中，我们可能无法对生产者和消费者都进行仪表化，并需要定期通过向代理的网络调用获取当前分布式队列长度（如果你决定在计数器回调中这样做，请小心）。
- en: 'Let’s implement the queue length counter. First, the `Processor` class is disposable,
    so we should assume it can die before the application ends. It’s important to
    disable all the instruments when this happens – we need to create a `Meter` as
    an instance variable and create the counter:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现队列长度计数器。首先，`Processor` 类是可丢弃的，因此我们应该假设它在应用程序结束之前可能会死亡。在这种情况下，禁用所有仪器很重要——我们需要创建一个
    `Meter` 作为实例变量并创建计数器：
- en: Processor.cs
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Processor.cs
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs)'
- en: Here, we created an `ObservableUpDownCounter` instance with a `queue.length`
    name and configured it to report the length in a callback, along with the queue
    name attribute. The last thing we need to do is to dispose of the `Meter` instance,
    along with the processor, using the `_meter.Dispose()` method. That’s it!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `queue.length` 的 `ObservableUpDownCounter` 实例，并将其配置为在回调中报告长度，同时包含队列名称属性。我们最后需要做的是使用
    `_meter.Dispose()` 方法来销毁 `Meter` 实例以及处理器。就这样了！
- en: 'Start the sample application (unless it’s still running) with `metrics$ docker-compose
    up --build` and check out the `queue_length` metric (at `http://localhost:8889/metrics`).
    You should see it, among other metrics:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `metrics$ docker-compose up --build` 启动示例应用程序（除非它仍在运行），并检查 `queue_length`
    度量（在 `http://localhost:8889/metrics`）。你应该会看到它，以及其他度量：
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, `UpDownCounter` and `ObservableUpDownCounter` are both mapped
    to gauge Prometheus – we’ll learn more about gauges in the next section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`UpDownCounter` 和 `ObservableUpDownCounter` 都映射到仪表 Prometheus - 我们将在下一节中了解更多关于仪表的信息。
- en: 'We can visualize this metric in the Prometheus UI (at `http://localhost:9090`)
    with the `avg by (queue) (queue_length)` query, as shown in *Figure 7**.2*:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Prometheus UI（在 `http://localhost:9090`）中的 `avg by (queue) (queue_length)`
    查询来可视化此度量，如图 *图 7.2* 所示：
- en: '![Figure 7.2 – Average queue length per queue](img/Figure_7.02_B19423.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 每个队列的平均队列长度](img/Figure_7.02_B19423.jpg)'
- en: Figure 7.2 – Average queue length per queue
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 每个队列的平均队列长度
- en: By looking at this chart, we can say that the **update** queue grows linearly
    while the other queues remain almost empty. We don’t need any complicated queries
    here because we’re interested in absolute values as we expect the queue length
    to always be small.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看此图表，我们可以得出结论，**更新**队列线性增长，而其他队列几乎为空。我们在这里不需要复杂的查询，因为我们对绝对值感兴趣，因为我们预计队列长度始终很小。
- en: Let’s learn about other instruments – gauges and histograms – and investigate
    what happens with the **update** queue.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解其他仪器——仪表和直方图——并调查更新队列中会发生什么。
- en: Using an asynchronous gauge
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步仪表
- en: '`System.Diagnostics.Metrics.ObservableGauge` represents the current value of
    a non-additive metric. There is only an asynchronous version of it.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Diagnostics.Metrics.ObservableGauge` 表示非累加度量的当前值。它只有异步版本。'
- en: The key difference with `ObservableUpdownCounter` is that the counter is additive.
    For example, with counters, if we have multiple metric points for the same counter
    name, at the same timestamp, and with the same attributes, we can just add them
    up. For gauge, aggregation makes no sense and OpenTelemetry uses the last reported
    value.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `ObservableUpdownCounter` 的关键区别在于计数器是可累加的。例如，对于计数器，如果我们有多个具有相同计数器名称、相同时间戳和相同属性的度量点，我们只需将它们相加即可。对于仪表，聚合没有意义，OpenTelemetry
    使用最后报告的值。
- en: When exported to Prometheus, `ObservableGauge` and `ObservableUpdownCounter`
    are the same, but their OTLP definitions (over-the-wire formats) are different.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当导出到Prometheus时，`ObservableGauge`和`ObservableUpdownCounter`是相同的，但它们的OTLP定义（网络格式）是不同的。
- en: Tip
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can get an idea of the internal representation of metric points on the OpenTelemetry
    side by enabling the `ConsoleExporter` output or looking into the OpenTelemetry
    documentation at [https://opentelemetry.io/docs/reference/specification/overview/#metrics-data-model-and-sdk](https://opentelemetry.io/docs/reference/specification/overview/#metrics-data-model-and-sdk).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过启用`ConsoleExporter`输出或查看OpenTelemetry文档在[https://opentelemetry.io/docs/reference/specification/overview/#metrics-data-model-and-sdk](https://opentelemetry.io/docs/reference/specification/overview/#metrics-data-model-and-sdk)来了解OpenTelemetry侧指标点的内部表示。
- en: We use `ObservableGauge` to report a sequence number for the last processed
    item. It’s useful with distributed queues, where the sequence number (or offset)
    represents the unique and ordered position of the item in the queue.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ObservableGauge`来报告最后处理项的序列号。这对于分布式队列很有用，其中序列号（或偏移量）表示项在队列中的唯一和有序位置。
- en: By looking at sequence number trends, we can estimate how many items are processed
    and how fast they are processed. For example, if the processor is stuck trying
    to process an invalid work item, we’d see that the sequence number is not increasing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看序列号趋势，我们可以估计处理了多少项以及它们的处理速度有多快。例如，如果处理器卡在尝试处理无效的工作项，我们会看到序列号没有增加。
- en: 'Adding up sequence numbers from different queues make no sense, so it should
    be an `ObservableGauge`, which we can create using a familiar API:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将来自不同队列的序列号相加没有意义，因此它应该是一个`ObservableGauge`，我们可以使用熟悉的API来创建它：
- en: Processor.cs
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Processor.cs
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs)'
- en: In the callback, we return the `_seqNo` instance variable, which we update after
    dequeuing the work item. The only thing we need here is thread safety; we don’t
    need precision since data is collected periodically.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调中，我们返回`_seqNo`实例变量，我们在出队工作项后更新它。我们在这里唯一需要的是线程安全；我们不需要精度，因为数据是定期收集的。
- en: We can report values with zero or more attributes or multiple measurements at
    once, so long as they have different attributes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 只要它们具有不同的属性，我们可以报告带有零个或多个属性或一次多个测量的值。
- en: 'If we run the sample application with `metrics$ docker-compose up --build`,
    we can check the sequence number in Prometheus with a query such as `delta(processor_last_sequence_number[1m])`.
    It returns the delta per minute and is shown in *Figure 7**.3*:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`metrics$ docker-compose up --build`运行示例应用程序，我们可以使用如`delta(processor_last_sequence_number[1m])`之类的查询在Prometheus中检查序列号。它返回每分钟的增量，并在*图7**.3中显示：
- en: '![Figure 7.3 – Sequence number delta per minute](img/Figure_7.03_B19423.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 每分钟的序列号增量](img/Figure_7.03_B19423.jpg)'
- en: Figure 7.3 – Sequence number delta per minute
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 每分钟的序列号增量
- en: As we can see, after the application starts, the delta stabilizes around 3,000
    items per minute in the `queue_length` counter – the **update** queue is not processed
    fast enough. By looking at metrics, we can’t say why, but there is one that can
    cast some light on it – the processing duration. Let’s take a look at it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在应用程序启动后，`queue_length`计数器的增量稳定在每分钟约3,000项——**更新**队列处理不够快。通过查看指标，我们无法说为什么，但有一个可以提供一些线索——处理持续时间。让我们看看它。
- en: Using histograms
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用直方图
- en: '`System.Diagnostics.Metrics.Histogram` represents a distribution of values
    – for example, the operation duration or payload size. Histograms can only be
    reported synchronously as each measurement is important. As we saw in [*Chapter
    2*](B19423_02.xhtml#_idTextAnchor038), *Native Monitoring in .NET*, they allow
    us to calculate percentiles at query time.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Diagnostics.Metrics.Histogram` 表示值的分布——例如，操作持续时间或有效载荷大小。直方图只能同步报告，因为每个测量都很重要。正如我们在[*第2章*](B19423_02.xhtml#_idTextAnchor038)中看到的，*在.NET中的原生监控*，它们允许我们在查询时计算百分位数。'
- en: 'We’ll use a histogram to record the processing duration in our example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用直方图来记录处理持续时间：
- en: Processor.cs
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Processor.cs
- en: '[PRE8]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs)'
- en: 'Every time we process an item from the queue, we should measure and record
    the time it took:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们从队列中处理一个项目时，我们都应该测量并记录它所花费的时间：
- en: Processor.cs
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Processor.cs
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter7/metrics/Processor.cs)'
- en: Here, we are using the `Enabled` flag – when metrics are not enabled, it prevents
    us from allocating a `Stopwatch` object on the heap.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`Enabled`标志 – 当指标未启用时，它阻止我们在堆上分配`Stopwatch`对象。
- en: The recording method has multiple overloads to report zero or more attributes
    associated with this value. Here, we report the queue name and the processing
    status. The status has low cardinality – it’s an `enum` with a few values.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 记录方法有多个重载，可以报告与该值关联的零个或多个属性。在这里，我们报告队列名称和处理状态。状态具有低基数 – 它是一个只有几个值的`enum`。
- en: We also want to stay as efficient as possible, so we implemented the optimal
    and non-allocating `StatusToString` method.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望尽可能高效，因此我们实现了最优且非分配的`StatusToString`方法。
- en: Let’s run the application with `metrics$ docker-compose up --build` and check
    out how the histogram looks in Prometheus exposition format (at `http://localhost:8889/metrics`).
    You should see a set of `processor_processing_duration_milliseconds_bucket` points
    for each queue, status, and bucket.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`metrics$ docker-compose up --build`运行应用程序，并检查Prometheus展示格式（在`http://localhost:8889/metrics`）中的直方图看起来如何。你应该会看到每个队列、状态和桶的`processor_processing_duration_milliseconds_bucket`点集。
- en: 'For example, this is what I see for the `Ok` (attributes and some buckets have
    been omitted for brevity):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是我看到的`Ok`（为了简洁起见，省略了一些属性和桶）：
- en: '[PRE10]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Each bucket is identified by a `le` attribute – the inclusive upper boundary.
    There were 27 measurements smaller than or equal to 50 milliseconds, 52 measurements
    that were smaller than 75 milliseconds, and so on. Overall, there were 72 measurements,
    and the sum of all durations was around 4,146 milliseconds.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每个桶由一个`le`属性标识 – 包含的上限边界。有27个测量值小于或等于50毫秒，52个测量值小于75毫秒，等等。总的来说，有72个测量值，所有持续时间的总和约为4,146毫秒。
- en: 'OTLP format defines a few more interesting properties that we can’t see here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: OTLP格式定义了一些我们在这里看不到的更多有趣属性：
- en: The `min` and `max` values for each bucket – they are not supported by Prometheus
    but show up in OTLP data.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个桶的`min`和`max`值 – Prometheus不支持它们，但在OTLP数据中显示出来。
- en: '**Exemplars**, which represent examples of traces in a bucket. We could use
    them to easily navigate from metrics to traces and investigate long processing
    operations in higher histogram buckets. They are not implemented in OpenTelemetry
    for .NET yet.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例**，代表桶中跟踪的示例。我们可以使用它们轻松地从指标导航到跟踪，并调查高直方图桶中的长时间处理操作。它们在.NET的OpenTelemetry中尚未实现。'
- en: The bucket boundaries we can see here are the default ones. They are static
    and work best if the measured value is well within the [0, 10000] range. If we
    start to measure values in the [10,000, 20,000] range, every measurement would
    be in the last two buckets, making the percentile calculation invalid. In this
    case, we should set explicit boundaries for corresponding histograms with the
    `MeterProviderBuilder.AddView` method.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里可以看到的桶边界是默认的。它们是静态的，如果测量的值在[0, 10000]范围内，则效果最佳。如果我们开始测量[10,000, 20,000]范围内的值，每个测量值都会在最后两个桶中，这将使百分位计算无效。在这种情况下，我们应该使用`MeterProviderBuilder.AddView`方法为相应的直方图设置显式边界。
- en: In the future, OpenTelemetry will allow us to use exponential histograms with
    dynamic boundaries adjusted to data.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 未来，OpenTelemetry将允许我们使用具有动态边界调整的数据的指数直方图。
- en: Note that we also have the `processor_processing_duration_milliseconds_sum`
    and `processor_processing_duration_milliseconds_count` metrics, so by reporting
    only the histogram, we get percentiles, averages, and measurement counters.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还有`processor_processing_duration_milliseconds_sum`和`processor_processing_duration_milliseconds_count`指标，因此通过仅报告直方图，我们就可以得到百分位数、平均值和测量计数器。
- en: 'We can get the median processing time with the following query:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下查询获取中值处理时间：
- en: '[PRE11]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This should produce the chart shown in *Figure 7**.4*:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该生成*图7.4*中所示的图表：
- en: '![Figure 7.4 – Median processing time per queue](img/Figure_7.04_B19423.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 每个队列的中值处理时间](img/Figure_7.04_B19423.jpg)'
- en: Figure 7.4 – Median processing time per queue
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 每个队列的中值处理时间
- en: Here, we can see that the median processing time for the **add** queue is around
    61 milliseconds, 48 milliseconds for the **remove** queue, and 75 milliseconds
    for the **update** queue.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到**添加**队列的中值处理时间约为61毫秒，**移除**队列约为48毫秒，**更新**队列约为75毫秒。
- en: 'Let’s also check the processing rate using the `sum by (queue) (rate(processor_processing_duration_milliseconds_count[1m]))`
    query, as shown in *Figure 7**.5*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也检查处理速率，使用`sum by (queue) (rate(processor_processing_duration_milliseconds_count[1m]))`查询，如*图7.5*所示：
- en: '![Figure 7.5 – Processing rate per queue](img/Figure_7.05_B19423.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 每个队列的处理速率](img/Figure_7.05_B19423.jpg)'
- en: Figure 7.5 – Processing rate per queue
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 每个队列的处理速率
- en: 'Items from the **update** queue are processed at a rate of about 14 items per
    second; the enqueue rate is ~16 items per second, as we saw in *Figure 7**.1*.
    This should explain why the **update** queue is growing:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**更新**队列中的项目以每秒约14个项目的速率进行处理；入队速率约为每秒16个项目，正如我们在*图7.1*中看到的。这应该解释了为什么**更新**队列在增长：'
- en: Processing takes too much time – we should try to optimize it so that it targets
    at least 60 milliseconds to be able to process 16 items per second.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理时间过长 – 我们应该尝试优化它，使其目标至少为60毫秒，以便能够以每秒16个项目的速率进行处理。
- en: If optimization is not possible (or is not enough), we know that we need to
    process an extra 2-3 items per second, so we need ~20% more processor instances.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果优化不可行（或不足），我们知道我们需要每秒处理额外的2-3个项目，因此我们需要大约20%更多的处理器实例。
- en: We could also implement backpressure on the producer side and throttle **update**
    requests to decrease the enqueue rate on the processor.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以在生产者端实现背压，并限制**更新**请求，以减少处理器的入队速率。
- en: With just a small set of metrics, we were able to narrow down the problem to
    a specific area. If it was a production incident, we’d be able to quickly mitigate
    it by scaling the number of processors up and then investigating other options.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用一小套指标，我们就能够将问题缩小到特定区域。如果这是一个生产事故，我们能够通过增加处理器数量来快速缓解，然后调查其他选项。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored metrics in .NET and OpenTelemetry.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了.NET和OpenTelemetry中的指标。
- en: Metrics allow us to collect aggregated multi-dimensional data. They produce
    unbiased telemetry with a predictable volume at any scale and allow us to monitor
    system health, performance, and usage.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 指标使我们能够收集聚合的多维数据。它们在任何规模下都能产生无偏见的遥测数据，并具有可预测的量级，使我们能够监控系统健康、性能和利用率。
- en: 'Metrics can’t have high-cardinality attributes, so we can’t use them to detect
    problems that happen in specific and narrow cases – for this, we need distributed
    tracing or events. .NET provides an OpenTelemetry metrics implementation that
    consists of the `Meter` class, which can create specific instruments: counters,
    gauges, and histograms.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 指标不能有高基数属性，因此我们无法使用它们来检测在特定和狭窄情况下发生的问题 – 对于此，我们需要分布式跟踪或事件。.NET提供了一个OpenTelemetry指标实现，它由`Meter`类组成，可以创建特定的工具：计数器、仪表和直方图。
- en: Counters are used to report additive values and can be synchronous or asynchronous.
    Gauges report current, non-additive values asynchronously, while histograms report
    value distribution.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器用于报告累加值，可以是同步的或异步的。仪表报告当前的、非累加值，而直方图报告值分布。
- en: With this, you should be able to identify scenarios where metrics are beneficial,
    choose appropriate instruments, and efficiently report metrics in your application.
    You should also be able to configure OpenTelemetry, and, most importantly, start
    detecting and monitoring performance issues.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，你应该能够识别出指标有益的场景，选择合适的工具，并高效地在你的应用程序中报告指标。你还应该能够配置OpenTelemetry，最重要的是，开始检测和监控性能问题。
- en: In the next chapter, we’re going to look at structured logs and events and learn
    how to write and consume them efficiently using .NET and OpenTelemetry.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨结构化日志和事件，并学习如何使用.NET和OpenTelemetry高效地编写和消费它们。
- en: Questions
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Let’s say you want to track the number of meme downloads (from our meme sample
    applications). Which telemetry signals would you choose? Why?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你想跟踪meme下载的数量（从我们的meme示例应用程序中）。你会选择哪些遥测信号？为什么？
- en: When reporting HTTP request duration, would you report it as a span, metric,
    or both?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 报告 HTTP 请求持续时间时，您会将其报告为时间段、指标，还是两者都要？
- en: How would you monitor the number of active application instances and the uptime?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会如何监控活跃的应用实例数量和正常运行时间？
