- en: '*Chapter 7*: Unity API – Making Choices and Story Progression'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：Unity API – 做出选择和故事推进'
- en: This chapter begins with reviewing how to add a `script` component to a game
    object in Unity. By creating a `script` component associated with a C# file, code
    can be written to load the compiled JSON files created by the ink-Unity Integration
    plugin from ink source files as part of the Unity scene. Next, we will examine
    how to load an ink story and start to progress through it. We will see how to
    programmatically make selections of options presented by ink and then how to continue
    story progression as a result. We will end with an example of a common approach
    of presenting multiple user interface elements to a player in Unity. A user will
    be able to click buttons in Unity and guide story progression in a running ink
    story.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先回顾了如何在Unity中将`script`组件添加到游戏对象中。通过创建与C#文件关联的`script`组件，可以编写代码从ink源文件加载ink-Unity集成插件创建的编译后的JSON文件，作为Unity场景的一部分。接下来，我们将探讨如何加载ink故事并开始推进它。我们将看到如何通过编程选择ink提供的选项，然后如何作为结果继续故事推进。我们将以在Unity中向玩家展示多个用户界面元素的常见方法为例。用户将能够在Unity中点击按钮并引导ink故事的推进。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Loading a compiled ink story
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载编译后的ink故事
- en: Selecting options programmatically
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序化选择选项
- en: Creating a dynamic user interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动态用户界面
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The examples used in this chapter, in `*.ink` files, can be found online on
    GitHub: [https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter7](https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter7).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的示例，在`*.ink`文件中，可以在GitHub上找到：[https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter7](https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter7)。
- en: Loading a compiled ink story
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载编译后的ink故事
- en: In [*Chapter 6*](B17597_06_Final_PG_ePub.xhtml#_idTextAnchor092), *Adding and
    Working with the ink-Unity Integration Plugin*, we saw how to add new ink files
    to a Unity project. After importing the plugin, new files can be created using
    the **Create** menu from the **Project** window. When an ink source was added,
    the plugin automatically created a compiled JSON file. As we now move into working
    with the ink API provided by the plugin, we will use the created JSON files for
    working with a story.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B17597_06_Final_PG_ePub.xhtml#_idTextAnchor092)中，*添加和使用ink-Unity集成插件*，我们学习了如何将新的ink文件添加到Unity项目中。在导入插件后，可以使用**项目**窗口中的**创建**菜单创建新文件。当添加ink源时，插件会自动创建一个编译后的JSON文件。随着我们现在开始使用插件提供的ink
    API进行工作，我们将使用创建的JSON文件来处理故事。
- en: The first step for working with code in Unity is to create a `GameObject`. This
    is a basic container in Unity. Each `GameObject` holds at least one component.
    The different systems in Unity, such as the rendering system (for drawing things
    on a screen), physics (for detecting whether two things overlap on a screen),
    and input (for detecting whether a user presses a button) all communicate with
    these components. When Unity runs a project, it sends data to components matching
    the system associated with it. For example, to work with data from the input system,
    an input component is needed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中使用代码的第一步是创建一个`GameObject`。这是Unity中的一个基本容器。每个`GameObject`至少包含一个组件。Unity中的不同系统，如渲染系统（用于在屏幕上绘制事物）、物理系统（用于检测屏幕上两个事物是否重叠）和输入系统（用于检测用户是否按下了按钮）都与这些组件进行通信。当Unity运行项目时，它会将数据发送到与它关联的系统所匹配的组件。例如，要处理来自输入系统的数据，需要一个输入组件。
- en: To work with code in Unity, a `script` component is needed. All code added to
    a Unity project works through being a part of different systems. A `script` component
    allows a developer to write code for working with a game object and the different
    components it contains. Unlike most other components that primarily receive data
    from different systems, a `script` component can *script* other objects and values.
    Through code, it can instruct other components to change their values when different
    events, such as a user clicking on a button, happen.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Unity中使用代码，需要一个`script`组件。添加到Unity项目中的所有代码都是通过成为不同系统的一部分来工作的。`script`组件允许开发者编写用于处理游戏对象及其包含的不同组件的代码。与其他主要从不同系统接收数据的组件不同，`script`组件可以*脚本化*其他对象和值。通过代码，它可以指示其他组件在发生不同事件（如用户点击按钮）时更改其值。
- en: Creating a script component
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建脚本组件
- en: 'Any game object can have a `script` component. However, for better organization,
    it is often useful to create a new `GameObject` for each type of data, behavior,
    or task related to a project. This separates each new action or possible event
    with a `GameObject` and makes working on the different parts of a larger project
    much easier:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 任何游戏对象都可以有一个 `script` 组件。然而，为了更好的组织，通常为每个类型的数据、行为或与项目相关的任务创建一个新的 `GameObject`
    是很有用的。这通过 `GameObject` 将每个新的动作或可能的事件分开，使得在大项目中的不同部分工作变得更加容易：
- en: Open a new or existing Unity project.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的或现有的 Unity 项目。
- en: If not already added, be sure to install the ink-Unity Integration plugin.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未添加，请确保安装 ink-Unity Integration 插件。
- en: There are always multiple ways to do things in Unity, and this is also true
    of creating a new game object. One of the easiest ways to create a new game object
    is by using the **GameObject** menu.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Unity 中做事情总是有多种方式，创建新的游戏对象也是如此。创建新游戏对象最简单的方法之一是使用 **GameObject** 菜单。
- en: Click on **GameObject** and then click on **Create Empty**.![Figure 7.1 – GameObject
    menu
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **GameObject**，然后点击 **Create Empty**。![图 7.1 – GameObject 菜单
- en: '](img/Figure_7.1_B17597.jpg)'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.1 – B17597.jpg](img/Figure_7.1_B17597.jpg)'
- en: Figure 7.1 – GameObject menu
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.1 – GameObject 菜单
- en: A new `GameObject` will be created and added to the `GameObject` will show its
    current components in the `GameObject` is merely a container. Its components do
    all the work involved with running the project. Even the name of the `GameObject`
    is a value contained as part of its components.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建一个新的 `GameObject` 并添加到 `GameObject` 中，将显示其当前组件。`GameObject` 仅仅是一个容器。其组件执行与运行项目相关的所有工作。甚至
    `GameObject` 的名称也是其组件包含的一个值。
- en: To change the name of the created `GameObject`, click on it in the `GameObject`
    (the default value) to `Ink` `Story`.![Figure 7.3 – Ink Story name change in Unity
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更改创建的 `GameObject` 的名称，请点击它，在 `GameObject`（默认值）更改为 `Ink` `Story`。![图 7.3 –
    在 Unity 中更改 Ink Story 名称
- en: '](img/Figure_7.3_B17597.jpg)'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.3 – B17597.jpg](img/Figure_7.3_B17597.jpg)'
- en: Figure 7.3 – Ink Story name change in Unity
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.3 – 在 Unity 中更改 Ink Story 名称
- en: The newly named `Ink` `Story` will be a container for other components related
    to running an ink story. Changing the name of the game object to `Ink` `Story`
    makes it easier to find it among potentially many other objects in the project
    and explains its role in the project as well.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新命名的 `Ink` `Story` 将成为运行墨迹故事相关组件的容器。将游戏对象名称更改为 `Ink` `Story` 使得在项目中众多其他对象中更容易找到它，同时也解释了它在项目中的作用。
- en: With the components of `Ink` `Story` shown in the **Inspector** view, click
    on **Add Component**.![Figure 7.4 – Component listing in the Add Component menu
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Inspector** 视图中显示 `Ink` `Story` 的组件，点击 **Add Component**。![图 7.4 – 添加组件菜单中的组件列表
- en: '](img/Figure_7.4_B17597.jpg)'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.4 – B17597.jpg](img/Figure_7.4_B17597.jpg)'
- en: Figure 7.4 – Component listing in the Add Component menu
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.4 – 添加组件菜单中的组件列表
- en: In the listing, click on **New script**.![Figure 7.5 – New script component
    creation](img/Figure_7.5_B17597.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表中点击 **New script**。![图 7.5 – 新脚本组件创建](img/Figure_7.5_B17597.jpg)
- en: Figure 7.5 – New script component creation
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.5 – 新脚本组件创建
- en: Name this new script file `inkLoader.cs`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此新的脚本文件命名为 `inkLoader.cs`。
- en: Note
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Clicking on the `script` component name does not always allow access to rename
    the file in Unity. Pressing the down arrow twice on the keyboard will move the
    selection from the search to the title of the file.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击 `script` 组件名称并不总是允许在 Unity 中重命名文件。按键盘上的向下箭头两次将选择从搜索移动到文件标题。
- en: '![Figure 7.6 – Script renamed InkLoader](img/Figure_7.6_B17597.jpg)'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 7.6 – 脚本重命名为 InkLoader](img/Figure_7.6_B17597.jpg)'
- en: Figure 7.6 – Script renamed InkLoader
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.6 – 脚本重命名为 InkLoader
- en: After renaming the file, click the **Create and Add** button. A new C# file
    will be added to the **Project** window.![Figure 7.7 – Assets in Unity with the
    new InkLoader.cs file
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名文件后，点击 **Create and Add** 按钮。一个新的 C# 文件将被添加到 **Project** 窗口中。![图 7.7 – Unity
    中的新 InkLoader.cs 文件
- en: '](img/Figure_7.7_B17597.jpg)'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.7 – B17597.jpg](img/Figure_7.7_B17597.jpg)'
- en: Figure 7.7 – Assets in Unity with the new InkLoader.cs file
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.7 – Unity 中的新 InkLoader.cs 文件
- en: Double-click on this file to open it in Visual Studio for editing.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击此文件以在 Visual Studio 中打开它进行编辑。
- en: This first section has included a step-by-step process of preparing a Unity
    project for working with the ink Story API. We have seen how to create a `GameObject`
    and add a `script` component. In the next section, we will build on this project
    to begin to work with the Story API added to Unity as part of the ink-Unity Integration
    plugin.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本节已包含了一个逐步过程，用于准备Unity项目以使用ink Story API。我们看到了如何创建`GameObject`并添加`script`组件。在下一节中，我们将在此基础上构建项目，开始使用作为ink-Unity
    Integration插件部分添加到Unity中的Story API。
- en: Adding the ink Story API
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加ink Story API
- en: 'Installing the ink-Unity Integration plugin adds an additional `Ink`. It contains,
    in turn, three other namespaces named `Parsed`, `Runtime`, and `UnityIntegration`,
    each of which contains classes related to their names. To work with compiled ink
    JSON files, the `Ink``.Runtime` namespace is needed. This tells Unity that it
    should start with the `ink` namespace and then find the namespace within it named
    `Runtime`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 安装ink-Unity Integration插件会添加一个额外的`Ink`。它包含三个其他命名空间，分别命名为`Parsed`、`Runtime`和`UnityIntegration`，每个命名空间都包含与其名称相关的类。要处理编译后的ink
    JSON文件，需要`Ink`.`Runtime`命名空间。这告诉Unity应该从`ink`命名空间开始，然后找到其中名为`Runtime`的命名空间：
- en: 'In the file opened in the *Creating a script component* section, add a new
    `using` line after those already there in the created file:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*创建脚本组件*部分打开的文件中，在已创建文件中已有的那些之后添加一个新的`using`行：
- en: '[PRE0]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, create a public field called `inkJSONAsset` and change the `Start()`
    method to the following:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`inkJSONAsset`的公共字段，并将`Start()`方法更改为以下内容：
- en: '[PRE1]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save the `InkLoader.cs` file in Visual Studio and return to Unity.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中保存`InkLoader.cs`文件，并返回Unity。
- en: After a moment, Unity will refresh and reload the changed C# file.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一段时间后，Unity将刷新并重新加载更改后的C#文件。
- en: The final step is to associate an ink JSON file with the created C# file. In
    the `InkStory` game object. In the `script` component, as shown in the following
    screenshot:![Figure 7.8 – New Ink JSON Asset property in the Inspector view
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将一个ink JSON文件与创建的C#文件关联。在`InkStory`游戏对象中，在`script`组件中，如下截图所示：![Figure 7.8
    – 新的Ink JSON资产属性在检查器视图中
- en: '](img/Figure_7.8_B17597.jpg)'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.8_B17597.jpg)'
- en: Figure 7.8 – New Ink JSON Asset property in the Inspector view
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figure 7.8 – 新的Ink JSON Asset属性在检查器视图中
- en: The property shows the value `None (Text Asset)`. This means no files are associated
    with this property. To change this, a compiled JSON file needs to be added.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 属性显示值为`None (Text Asset)`。这意味着没有文件与此属性关联。要更改此，需要添加一个编译后的JSON文件。
- en: Note
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: An ink JSON file will be needed for the next steps. If one is not created, add
    a new one by creating an ink file and letting the **Automatic compile** option
    create one, or click on an existing ink source file and then click on **Compile**
    in the **Inspector** view to create a new JSON file.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一步需要ink JSON文件。如果没有创建，可以通过创建ink文件并让**自动编译**选项创建一个，或者点击现有的ink源文件，然后在**检查器**视图中点击**编译**来创建一个新的JSON文件。
- en: Click on the **TextAsset** selection circle next to the value to open a **Select
    TextAsset** window.![Figure 7.9 – Select TextAsset window
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击值旁边的**TextAsset**选择圆圈以打开**选择TextAsset**窗口。![Figure 7.9 – 选择TextAsset窗口
- en: '](img/Figure_7.9_B17597.jpg)'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.9_B17597.jpg)'
- en: Figure 7.9 – Select TextAsset window
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figure 7.9 – 选择TextAsset窗口
- en: Select an ink-compiled JSON file.![Figure 7.10 – Updated Ink JSON Asset property
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个ink编译的JSON文件。![Figure 7.10 – 更新的Ink JSON Asset属性
- en: '](img/Figure_7.10_B17597.jpg)'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.10_B17597.jpg)'
- en: Figure 7.10 – Updated Ink JSON Asset property
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figure 7.10 – 更新的Ink JSON Asset属性
- en: After the value of the **Ink JSON Asset** property updates, close the **Select
    TextAsset** window.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在**Ink JSON Asset**属性值更新后，关闭**选择TextAsset**窗口。
- en: Click on the **Play** button in the middle of the Unity editor.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器的中间点击**Play**按钮。
- en: '![Figure 7.11 – Play button in Unity'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.11 – Unity中的播放按钮'
- en: '](img/Figure_7.11_B17597.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.11_B17597.jpg)'
- en: Figure 7.11 – Play button in Unity
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.11 – Unity中的播放按钮
- en: Unity will run the current scene, and nothing will appear to happen. If no errors
    appear in the **Console** window, everything has run correctly. Internally, Unity
    has loaded the compiled ink JSON file and is ready to run the ink story.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Unity将运行当前场景，看起来似乎没有发生任何事情。如果没有错误出现在**控制台**窗口中，则一切运行正确。内部，Unity已加载编译后的ink JSON文件，并准备好运行ink故事。
- en: Stop the running scene by clicking on the **Play** button a second time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过第二次点击**Play**按钮停止运行场景。
- en: Running an ink JSON file
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行ink JSON文件
- en: ink stories are run using the `Story` class and methods. Loading an ink JSON
    file is only the first step. The `Story` class must be told to load one or more
    *lines* of the story at a time.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ink 故事使用 `Story` 类和方法运行。加载 ink JSON 文件只是第一步。必须告诉 `Story` 类一次加载故事的一个或多个 *行*。
- en: 'When Inky was used to run the ink source file previously, it displayed one
    line at a time with an empty line between them:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当之前使用 Inky 运行 ink 源文件时，它一次显示一行，并在它们之间有一个空行：
- en: 'Example 1:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When run in Inky, *Example 1* creates the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Inky 中运行时，*示例 1* 生成以下输出：
- en: '![Figure 7.12 – Example 1 output'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.12 – 示例 1 输出'
- en: '](img/Figure_7.12_B17597.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.12_B17597.jpg)'
- en: Figure 7.12 – Example 1 output
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 示例 1 输出
- en: 'In Inky, the extra lines it created are a result of its own use of the Story
    API. To replicate this output, we will need to add a new method: `Continue()`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Inky 中，它创建的额外行是其自身使用 Story API 的结果。为了复制此输出，我们需要添加一个新方法：`Continue()`：
- en: In the same file used as part of the *Adding the ink Story API* section, open
    the file in Inky for editing.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在作为 *添加 ink Story API* 部分的一部分使用的相同文件中，在 Inky 中打开文件进行编辑。
- en: Change the content of the new ink source file to *Example 1* and then save the
    file in Inky. Do not close Inky after saving the file. Now return to Unity.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新 ink 源文件的内容更改为 *示例 1* 并然后在 Inky 中保存该文件。保存文件后不要关闭 Inky。现在返回 Unity。
- en: Upon detecting the change in the ink source file, the ink-Unity Integration
    plugin will automatically re-compile the ink JSON file. Because it was associated
    with the Ink JSON Asset property as part of the *Adding the ink Story API* section,
    the ink JSON file will also always be loaded correctly.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检测到 ink 源文件的更改后，ink-Unity Integration 插件将自动重新编译 ink JSON 文件。因为它作为 *添加 ink Story
    API* 部分的一部分与 Ink JSON Asset 属性相关联，ink JSON 文件也将始终正确加载。
- en: If the `InkLoader.cs` file is not already open in Visual Studio, double-click
    on it in the **Project** window.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `InkLoader.cs` 文件尚未在 Visual Studio 中打开，请双击 **项目** 窗口中的它。
- en: 'Add the following line to the `Start()` method:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到 `Start()` 方法中：
- en: '[PRE3]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Save the changed `inkLoader.cs` file and return to Unity.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改后的 `inkLoader.cs` 文件并返回 Unity。
- en: Click on the **Play** button to run the current scene.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **播放** 按钮来运行当前场景。
- en: This time, the **Console** window will show a message.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，**控制台** 窗口将显示一条消息。
- en: '![Figure 7.13 – Console window in Unity'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.13 – Unity 中的控制台窗口'
- en: '](img/Figure_7.13_B17597.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.13_B17597.jpg)'
- en: Figure 7.13 – Console window in Unity
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – Unity 中的控制台窗口
- en: The `Debug.Log()` method used what was returned by the `Continue()` method as
    part of the `Story` class to display a message in the **Console** window.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Debug.Log()` 方法使用 `Continue()` 方法返回的内容作为 `Story` 类的一部分，在 **控制台** 窗口中显示一条消息。'
- en: 'Each time the `Continue()` method is called, it loads the next line in an ink
    story and returns a string representing it. However, the method has an issue:
    it cannot detect the end of a story. For that, a different property is required.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `Continue()` 方法时，它都会加载 ink 故事的下一行，并返回一个表示它的字符串。然而，该方法有一个问题：它无法检测故事的结尾。为此，需要一个不同的属性。
- en: Stop the running scene by clicking on the **Play** button again.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 再次点击 **播放** 按钮来停止正在运行的场景。
- en: Checking whether a story can continue
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查故事是否可以继续
- en: The `Continue()` method loads the next line of a story if it is available. In
    the code from *Example 1*, there are two lines.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Continue()` 方法会在有可用的情况下加载故事的下一行。在 *示例 1* 的代码中，有两行。'
- en: 'Return to Visual Studio and edit the `Ink``Loader.cs` file. Change the `Story()`
    method to the following:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Visual Studio 并编辑 `Ink` `Loader.cs` 文件。将 `Story()` 方法更改为以下内容：
- en: '[PRE4]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Save the `InkLoader.cs` file after adding the new line of code. Return to Unity
    and click on the **Play** button to play the current scene and updated file.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加新行代码后保存 `InkLoader.cs` 文件。返回 Unity 并点击 **播放** 按钮来播放当前场景和更新后的文件。
- en: The `Continue()` method and then passed to the `Debug.Log()` method.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Continue()` 方法传递给 `Debug.Log()` 方法。
- en: Click on the **Play** button again in Unity to stop the current scene.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在 Unity 中点击 **播放** 按钮来停止当前场景。
- en: 'Return to Visual Studio and edit the `InkLoader.cs` file. Add the following
    code to the `Start()` method:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Visual Studio 并编辑 `InkLoader.cs` 文件。将以下代码添加到 `Start()` 方法中：
- en: '[PRE5]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save the updated `InkLoader.cs` file.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更新的 `InkLoader.cs` 文件。
- en: Return to Unity and play the scene.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Unity 并播放场景。
- en: With the third use of the `Continue()` method, an error will happen and be displayed
    in the **Console** window.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `Continue()` 方法的第三次调用时，将发生错误并在 **控制台** 窗口中显示。
- en: '![Figure 7.15 – Continue() error in the Unity console'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.15 – Unity 控制台中 Continue() 错误'
- en: '](img/Figure_7.15_B17597.jpg)'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.15_B17597.jpg)'
- en: Figure 7.15 – Continue() error in the Unity console
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.15 – Unity 控制台中的 Continue() 错误
- en: Click on the `Continue()` method does not check whether there is another line
    to load. When there is no more content, it throws an error.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `Continue()` 方法不会检查是否有其他行要加载。当没有更多内容时，它会抛出一个错误。
- en: To fix this issue, a property mentioned in the error is needed. The `Story`
    class provides the `canContinue` property for checking whether there is more story
    content to load. It contains a Boolean value. If there is more content, `canContinue`
    will be `true`. Otherwise, it will be `false`.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了解决这个问题，需要一个在错误中提到的属性。`Story` 类提供了 `canContinue` 属性来检查是否有更多故事内容要加载。它包含一个布尔值。如果有更多内容，`canContinue`
    将为 `true`。否则，它将为 `false`。
- en: 'Return to Visual Studio and edit the `InkLoader.cs` file. Update the `Start()`
    method in the `InkLoader.cs` file to the following:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Visual Studio 并编辑 `InkLoader.cs` 文件。将 `InkLoader.cs` 文件中的 `Start()` 方法更新如下：
- en: '[PRE6]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Save the edited `InkLoader.cs` file in Visual Studio.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中保存编辑后的 `InkLoader.cs` 文件。
- en: Return to Unity and play the scene again.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Unity 并再次播放场景。
- en: With the use of a `while` loop, the story will be loaded line by line until
    there is no content left. Once this happens, the `canContinue` property is changed
    to `false` and the loop ends.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `while` 循环，故事将逐行加载，直到没有内容为止。一旦发生这种情况，`canContinue` 属性将更改为 `false`，循环结束。
- en: '![Figure 7.16 – Console window using an updated while loop'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.16 – 使用更新后的 while 循环的 Console 窗口'
- en: '](img/Figure_7.16_B17597.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.16_B17597.jpg)'
- en: Figure 7.16 – Console window using an updated while loop
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 – 使用更新后的 while 循环的 Console 窗口
- en: The combination of the `canContinue` property with the `Continue()` method is
    a common pattern when using the Story API. More advanced usage patterns may not
    use a `while` loop, but the property and method will often appear together.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `canContinue` 属性与 `Continue()` 方法结合使用是使用 Story API 时的常见模式。更高级的使用模式可能不会使用 `while`
    循环，但属性和方法通常会一起出现。
- en: Selecting options programmatically
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以编程方式选择选项
- en: Displaying only the text of an ink story has limited usefulness. Most advanced
    ink stories use weaves to present different options. Along with the `Continue()`
    method and the `canContinue` property, the Story API also has another property
    called `currentChoices` that contains a list of the options generated by the most
    recent weave.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 仅显示 ink 故事的文本具有有限的有用性。大多数高级 ink 故事使用 weave 来展示不同的选项。除了 `Continue()` 方法和 `canContinue`
    属性外，Story API 还有一个名为 `currentChoices` 的属性，它包含由最近的 weave 生成的选项列表。
- en: As was demonstrated in the *Checking whether a story can continue* section,
    the `canContinue` property is affected by the `Continue()` method. After each
    line is loaded and returned as a string, the `Story` class will update the `canContinue`
    property if there is more story to load. This is also true of the `currentChoice`
    property. When the `Continue()` method is used, it will load the next line *and*
    any weaves.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 *检查故事是否可以继续* 部分所示，`canContinue` 属性受 `Continue()` 方法的影响。在每行加载并返回为字符串后，如果还有更多故事要加载，`Story`
    类将更新 `canContinue` 属性。这也适用于 `currentChoice` 属性。当使用 `Continue()` 方法时，它将加载下一行 *以及*
    任何 weave。
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Any previously used game objects or C# files created as part of this chapter
    can safely be deleted. This section will create a new game object and script component,
    and use different code for working with weaves and options.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 任何之前在本章中使用的游戏对象或 C# 文件都可以安全删除。本节将创建一个新的游戏对象和脚本组件，并使用不同的代码来处理 weave 和选项。
- en: Detecting ink choices
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测 ink 选项
- en: 'The first step to act on a weave is to detect that its choices have been loaded
    by the `currentChoices` property. This means both the `canContinue` property and
    `Continue()` method are also needed. The first prevents any issues of trying to
    load content that may not exist and the second loads the current line and any
    weaves along the way:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对 weave 进行操作的第一步是检测其选项是否已通过 `currentChoices` 属性加载。这意味着需要 `canContinue` 属性和 `Continue()`
    方法。第一个属性防止尝试加载可能不存在的内容，第二个属性则加载当前行和任何沿途的 weave：
- en: In a new or existing Unity project with no other game objects using the Story
    API, create a new, empty `GameObject`. Name it `Ink` `Choices`.![Figure 7.17 –
    ink Choices GameObject
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个没有使用 Story API 的新或现有 Unity 项目中，创建一个新的空 `GameObject`。将其命名为 `Ink` `Choices`。![图
    7.17 – ink Choices GameObject
- en: '](img/Figure_7.17_B17597.jpg)'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.17_B17597.jpg)'
- en: Figure 7.17 – ink Choices GameObject
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.17 – ink Choices GameObject
- en: As was shown in the *Creating a script component* section, create a new `script`
    component on the `Ink` `Choices` game object. Name this new file `LoadingChoices.cs`.![Figure
    7.18 – LoadingChoices.cs file in the Assets window](img/Figure_7.18_B17597.jpg)
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如在 *创建脚本组件* 部分所示，在 `Ink` `Choices` 游戏对象上创建一个新的 `script` 组件。将此新文件命名为 `LoadingChoices.cs`。![图
    7.18 – Assets 窗口中的 LoadingChoices.cs 文件](img/Figure_7.18_B17597.jpg)
- en: Figure 7.18 – LoadingChoices.cs file in the Assets window
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.18 – Assets 窗口中的 LoadingChoices.cs 文件
- en: 'Double-click on the `LoadingChoices.cs` file in the **Assets** window to open
    it for editing in Visual Studio:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Assets** 窗口中双击 `LoadingChoices.cs` 文件，以在 Visual Studio 中打开它进行编辑：
- en: '[PRE7]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Save the file in Visual Studio and return to Unity.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中保存文件并返回 Unity。
- en: Create a new ink file and name (or rename) the file to `Example3.ink`.![Figure
    7.19 – Example3.ink file in the Assets window
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 ink 文件，并将其命名为（或重命名为）`Example3.ink`![图 7.19 – Assets 窗口中的 Example3.ink
    文件
- en: '](img/Figure_7.19_B17597.jpg)'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.19_B17597.jpg)'
- en: Figure 7.19 – Example3.ink file in the Assets window
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.19 – Assets 窗口中的 Example3.ink 文件
- en: Following the instructions in the *Running an ink JSON file* section, associate
    the automatically generated ink JSON file with the `Ink` `Choices` game object
    property.![Figure 7.20 – Example3.json file associated with the ink JSON Asset
    property](img/Figure_7.20_B17597.jpg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照在 *运行 ink JSON 文件* 部分中的说明，将自动生成的 ink JSON 文件与 `Ink` `Choices` 游戏对象属性关联。![图
    7.20 – 与 ink JSON 资产属性关联的 Example3.json 文件](img/Figure_7.20_B17597.jpg)
- en: Figure 7.20 – Example3.json file associated with the ink JSON Asset property
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.20 – 与 ink JSON 资产属性关联的 Example3.json 文件
- en: 'Open the `Example3.ink` file for editing in Inky. Change it to the following:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Inky 中打开 `Example3.ink` 文件进行编辑。将其更改为以下内容：
- en: '[PRE8]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Save the changed `Example3.ink` file. Return to Unity and run the scene. The
    **Console** window in Unity will now show the text content of each option.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改后的 `Example3.ink` 文件。返回 Unity 并运行场景。现在 Unity 的 **控制台** 窗口将显示每个选项的文本内容。
- en: '![Figure 7.21 – Example 3 options in the Console window'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.21 – 控制窗口中的 Example 3 选项'
- en: '](img/Figure_7.21_B17597.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.21_B17597.jpg)'
- en: Figure 7.21 – Example 3 options in the Console window
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.21 – 控制窗口中的 Example 3 选项
- en: 'The use of the `Continue()` method loaded not only the first line of *Example
    3* but also the first weave appearing within the code. The `currentChoices` property
    contains a `List<Choice>` of objects per choice that exists within the weave.
    Each element of `List<Choice>` is a `Choice` object, a special class containing
    two important properties: `index` and `text`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Continue()` 方法不仅加载了 *Example 3* 的第一行，还加载了代码中出现的第一个编织。`currentChoices` 属性包含每个编织中存在的选项的对象的
    `List<Choice>`。`List<Choice>` 的每个元素都是一个 `Choice` 对象，这是一个包含两个重要属性的特定期类：`index`
    和 `text`。
- en: Within the `foreach` loop, the `text` property of each `Choice` object is retrieved.
    This is then passed to the `Debug.Log()` method. When run, the ink story is loaded.
    Next, the first line and weave are loaded. Inside the loop, the `currentChoices`
    property is used to retrieve the value of each `text` property. Each is then shown
    in the `Debug.Log()` method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `foreach` 循环中，检索每个 `Choice` 对象的 `text` 属性。然后将其传递给 `Debug.Log()` 方法。当运行时，ink
    故事被加载。接下来，加载第一行和编织。在循环内部，使用 `currentChoices` 属性检索每个 `text` 属性的值。每个值随后在 `Debug.Log()`
    方法中显示。
- en: Making choices using the Unity API
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Unity API 进行选择
- en: Options are selected by players to continue a story. Within the ink source code,
    a choice is created using either the asterisk (`*`) or the plus symbol (`+`).
    When run, the ink runtime code as part of the `Story` class creates *options*
    from these source code choices. However, to progress in an ink story, a choice
    must be *made*. It must exist in the code and then be presented as an option.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家通过选择选项来继续故事。在 ink 源代码中，使用星号（`*`）或加号符号（`+`）创建一个选择。当运行时，ink 运行时代码作为 `Story`
    类的一部分从这些源代码选择中创建 *选项*。然而，要在一个 ink 故事中前进，必须 *做出* 选择。它必须存在于代码中，然后作为选项呈现。
- en: 'The `Story` class provides a method named `ChooseChoiceIndex()`. This accepts
    an *index* (`int`) within the range of the current total number of elements in
    the `currentChoices` property. Each `Choice` object within the list of `currentChoices`
    has `index` and `text` properties. In the *Detecting ink choices* section, the
    `text` property was used to display the generated option from the ink source file.
    To *make* a choice, its `index` property is used:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Story`类提供了一个名为`ChooseChoiceIndex()`的方法。该方法接受`currentChoices`属性中当前元素总数范围内的一个*索引*（`int`）。`currentChoices`列表中的每个`Choice`对象都有`index`和`text`属性。在*检测墨水选择*部分，使用了`text`属性来显示从墨水源文件生成的选项。要*做出*选择，则使用其`index`属性：'
- en: Double-click on the `LoadingChoices.cs` file from the *Detecting ink choices*
    section to open it for editing if it is not already open in Visual Studio.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击*检测墨水选择*部分中的`LoadingChoices.cs`文件，如果它尚未在Visual Studio中打开，则打开它进行编辑。
- en: 'Update the file to the following:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件更新如下：
- en: '[PRE9]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Save the file in Visual Studio, return to Unity, and run the scene.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中保存文件，返回Unity，并运行场景。
- en: The `0`) position element within the `currentChoices` property.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentChoices`属性中的`0`)位置元素。'
- en: '![Figure 7.22 – Option chosen from Example 3 in the Console window'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.22 – 控制窗口中从Example 3选择的选项'
- en: '](img/Figure_7.22_B17597.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.22_B17597.jpg)'
- en: Figure 7.22 – Option chosen from Example 3 in the Console window
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22 – 控制窗口中从Example 3选择的选项
- en: The `ChooseChoiceIndex()` method selects the first choice within the weave based
    on the `index` property of `exampleChoice`. This is then displayed in the Unity
    `Continue()` method.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChooseChoiceIndex()`方法根据`exampleChoice`的`index`属性在编织中选择第一个选项。然后，在Unity的`Continue()`方法中显示出来。'
- en: To *make* choices when using ink and Unity, a combination of things needs to
    happen in sequence. First, a story must be loaded. Second, at least one line needs
    to be loaded that also contains a weave. Next, the `currentChoices` property of
    the `Story` class must be used to retrieve the created options for the player.
    The `ChooseChoiceIndex()` method then needs to be used with the `index` property
    of one of the `Choice` objects retrieved from the `currentChoices` property. Finally,
    the next part of the story needs to be loaded. This additional loading will include
    the text of the option (if selective output is not used) chosen using the `ChooseChoiceIndex()`
    method. The rest of the story can then proceed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用ink和Unity进行选择时，需要按顺序发生一系列事情。首先，必须加载一个故事。其次，至少需要加载一行，该行还包含一个编织点。接下来，必须使用`Story`类的`currentChoices`属性来检索为玩家创建的选项。然后，需要使用从`currentChoices`属性检索到的`Choice`对象的`index`属性来使用`ChooseChoiceIndex()`方法。最后，需要加载故事的下一部分。这次额外的加载将包括使用`ChooseChoiceIndex()`方法选择的选项的文本（如果未使用选择性输出）。然后，故事的其余部分可以继续。
- en: Loading all text until the next weave
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载所有文本直到下一个编织点
- en: While useful for loading story content, the `Continue()` method must be used
    multiple times to load each line at a time. As with the code in the *Making choices
    using the Unity API* section, this means it would need to appear across multiple
    lines of code. Anticipating this problem, the Story API also includes a method
    named `ContinueMaximally()`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于加载故事内容很有用，但必须多次使用`Continue()`方法逐行加载。与*使用Unity API进行选择*部分中的代码一样，这意味着它需要出现在多行代码中。为了预见这个问题，Story
    API还包括一个名为`ContinueMaximally()`的方法。
- en: 'Instead of loading a line at a time, the `ContinueMaximally()` method loads
    all content until it encounters a weave. For many projects, this is a preferred
    method to use when there might be multiple lines of text between weaves or generated
    by ink internally as a part of the weave itself:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与逐行加载不同，`ContinueMaximally()`方法会加载所有内容，直到遇到一个编织点。对于许多项目来说，当编织点之间或由墨水内部作为编织本身的一部分生成多行文本时，这是一种首选的方法：
- en: Create a new ink source file in Unity. Name (or rename) the file to `Example4.ink`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中创建一个新的墨水源文件。命名（或重命名）文件为`Example4.ink`。
- en: 'Open `Example4.ink` for editing in Inky and update it to the following:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Inky中打开`Example4.ink`进行编辑，并将其更新如下：
- en: '[PRE10]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Update the `Example4.ink` file with the content from *Example 4*.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`Example4.ink`文件，将其内容从*Example 4*中提取。
- en: Click on the `Example3.json` to `Example4.json`.![Figure 7.23 – Updated Example4.json
    value in the Inspector view
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Example3.json`到`Example4.json`。![图7.23 – 在检查器视图中更新的Example4.json值
- en: '](img/Figure_7.23_B17597.jpg)'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.23_B17597.jpg)'
- en: Figure 7.23 – Updated Example4.json value in the Inspector view
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.23 – 在检查器视图中更新的Example4.json值
- en: Double-click on `LoadingChoices.cs` to open it for editing in Visual Studio.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `LoadingChoices.cs` 以在 Visual Studio 中打开它进行编辑。
- en: 'Update the file to the following:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件更新如下：
- en: '[PRE11]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Save the changes in Visual Studio, return to Unity, and run the scene.![Figure
    7.24 – Loaded lines and choice text from Example 4
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中保存更改，返回 Unity，并运行场景。![Figure 7.24 – Loaded lines and choice
    text from Example 4](img/Figure_7.24_B17597.jpg)
- en: '](img/Figure_7.24_B17597.jpg)'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 7.24 – Loaded lines and choice text from Example 4](img/Figure_7.24_B17597.jpg)'
- en: Figure 7.24 – Loaded lines and choice text from Example 4
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.24 – 从示例 4 加载的行和选择文本
- en: Stop the running scene.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止正在运行的场景。
- en: The first usage of the `ContinueMaximally()` method loaded the first two lines
    and the weave. Next, the `ChooseChoiceIndex()` method chose the first option.
    The second `ContinueMaximally()` method usage, when paired with the internal divert,
    then loaded the next line and the weave again.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContinueMaximally()` 方法的第一次使用加载了前两行和编织点。接下来，`ChooseChoiceIndex()` 方法选择了第一个选项。第二次
    `ContinueMaximally()` 方法的使用，与内部转向相结合，再次加载了下一行和编织点。'
- en: When working with looping structures, the `ContinueMaximally()` method is often
    better than using the `Continue()` method. Use of the `ContinueMaximally()` method
    will always load all the new text until it encounters the next weave. For loops
    where text might appear between weaves, a single use of the `ContinueMaximally()`
    method would achieve the same effect as multiple calls to the `Continue()` method
    to load the same content.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当与循环结构一起工作时，`ContinueMaximally()` 方法通常比使用 `Continue()` 方法更好。使用 `ContinueMaximally()`
    方法将始终加载所有新的文本，直到遇到下一个编织点。对于文本可能在编织点之间出现的情况，单次使用 `ContinueMaximally()` 方法可以达到与多次调用
    `Continue()` 方法加载相同内容相同的效果。
- en: This topic started with detecting choices in a running ink story with the `currentChoices`
    property. We then moved into making choices, both creating them in the ink code
    and then using the `ChooseChoiceIndex()` method to pick them. Finally, we saw
    how the `ContinueMaximally()` method can be combined with both the `currentChoices`
    property and the `ChooseChoiceIndex()` method. In the next topic, we will expand
    on these concepts. To create a dynamic interface, we can use our knowledge of
    the Story API to associate the `GameObjects` user interface and create a connection
    between clicking a button on the screen and progressing an ink story.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本主题从使用 `currentChoices` 属性检测运行中的墨迹故事中的选择开始。然后，我们转向制作选择，包括在墨迹代码中创建它们，然后使用 `ChooseChoiceIndex()`
    方法来选择它们。最后，我们看到了如何将 `ContinueMaximally()` 方法与 `currentChoices` 属性和 `ChooseChoiceIndex()`
    方法结合使用。在下一个主题中，我们将扩展这些概念。为了创建一个动态界面，我们可以使用我们对 Story API 的知识来关联 `GameObjects` 用户界面，并在屏幕上点击按钮与推进墨迹故事之间建立连接。
- en: Creating a dynamic user interface
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动态用户界面
- en: The `Story` class provides multiple methods for loading and progressing a story.
    However, without a user interface, a player is not able to select between options
    and see the result. To fix this problem, additional game objects are needed to
    show text and provide an interface for a user to click on different things.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Story` 类提供了多种加载和推进故事的方法。然而，如果没有用户界面，玩家将无法在选项之间进行选择并看到结果。为了解决这个问题，需要额外的游戏对象来显示文本并为用户提供一个点击不同内容的界面。'
- en: To start, a new project is needed. Instead of example code, this will use different
    user interface objects for working with a user. The project will also need to
    create a `GameObject` can become *prefabricated* by moving it from the `GameObject`
    during runtime.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要一个新项目。而不是示例代码，这将使用不同的用户界面对象来与用户一起工作。项目还需要创建一个 `GameObject`，在运行时可以从 `GameObject`
    中移动以成为 *预制件*。
- en: The current lines as returned by the `ContinueMaximally()` method and choices
    in the `currentChoices` property can potentially be dynamic while an ink story
    runs. Combined with a Prefab, C# code can recreate an interface dynamically because
    of a player clicking on buttons to make choices in a story.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `ContinueMaximally()` 方法返回的当前行和在 `currentChoices` 属性中的选择在墨迹故事运行时可能具有动态性。结合预制件，C#
    代码可以通过玩家点击按钮在故事中进行选择来动态地重新创建界面。
- en: In this topic, we will move through the steps of creating a dynamic interface
    by starting with a new Unity project and creating the necessary game objects.
    Next, we will associate a Prefab with our code. Finally, we will end with a section
    on putting everything together and running the combined project.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将通过从创建一个新的Unity项目开始，并创建必要的游戏对象，来逐步学习如何创建一个动态界面。接下来，我们将把预制件与我们的代码关联起来。最后，我们将结束于一个关于将所有内容组合在一起并运行组合项目的部分。
- en: Creating a new project and game objects
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新项目和游戏对象
- en: 'Let us now start with creating a new project and game objects:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个新的项目和游戏对象：
- en: Create a new project in Unity. Name this project `The Body` and use a 2D template.![Figure
    7.25 – Unity Hub project creation with the name of The Body](img/Figure_7.25_B17597.jpg)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 中创建一个新的项目。将此项目命名为 `The Body` 并使用 2D 模板。![图 7.25 – 以 The Body 命名的 Unity
    Hub 项目创建](img/Figure_7.25_B17597.jpg)
- en: Figure 7.25 – Unity Hub project creation with the name of The Body
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.25 – 以 The Body 命名的 Unity Hub 项目创建
- en: Important Note
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: Before doing anything else, install the ink-Unity Integration plugin in the
    new project using the instructions as part of [*Chapter 6*](B17597_06_Final_PG_ePub.xhtml#_idTextAnchor092),
    *Adding and Working with the ink-Unity Integration Plugin*.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在进行任何其他操作之前，请按照 [*第 6 章*](B17597_06_Final_PG_ePub.xhtml#_idTextAnchor092) 中
    *添加和操作 ink-Unity 集成插件* 的说明，在新项目中安装 ink-Unity Integration 插件。
- en: Once the project has been created by Unity, add a `Canvas` game object to the
    `Canvas` game object can be accessed by selecting `Canvas` game object, Unity
    will automatically add an `EventSystem` game object.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 Unity 创建了项目，请向 `Canvas` 游戏对象添加一个 `Canvas` 游戏对象可以通过选择 `Canvas` 游戏对象访问，Unity
    将自动添加一个 `EventSystem` 游戏对象。
- en: Click on the `Canvas` game object. In the **Inspector** view, click on the **Add
    Component** button. Select **Layout** and then **Vertical Layout Group**.![Figure
    7.27 – Vertical Layout Group component selection
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `Canvas` 游戏对象。在 **检查器** 视图中，点击 **添加组件** 按钮。选择 **布局** 然后选择 **垂直布局组**。![图 7.27
    – 选择垂直布局组组件
- en: '](img/Figure_7.27_B17597.jpg)'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.27_B17597.jpg)'
- en: Figure 7.27 – Vertical Layout Group component selection
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.27 – 选择垂直布局组组件
- en: A vertical layout group will automatically align all other UI game objects within
    itself in a *vertical* pattern.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 垂直布局组将自动以垂直模式在其内部对齐所有其他 UI 游戏对象。
- en: In the vertical layout group, click on the **Child Alignment** dropdown and
    select **Middle Center**.![Figure 7.28 – Vertical Layout Group with Middle Center
    selected
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在垂直布局组中，点击 **子对齐** 下拉菜单并选择 **中间居中**。![图 7.28 – 已选择中间居中的垂直布局组
- en: '](img/Figure_7.28_B17597.jpg)'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.28_B17597.jpg)'
- en: Figure 7.28 – Vertical Layout Group with Middle Center selected
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.28 – 已选择中间居中的垂直布局组
- en: With the `Canvas` game object selected in the `Text` game object. `Text` game
    objects can be found under `Text` will be added as a child of the `Canvas` game
    object.![Figure 7.29 – Added Text game object in the Hierarchy view
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Text` 游戏对象中选择 `Canvas` 游戏对象。`Text` 游戏对象可以在 `Text` 下找到，并将作为 `Canvas` 游戏对象的子对象添加。![图
    7.29 – 在层次结构视图中添加的 Text 游戏对象
- en: '](img/Figure_7.29_B17597.jpg)'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.29_B17597.jpg)'
- en: Figure 7.29 – Added Text game object in the Hierarchy view
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.29 – 在层次结构视图中添加的 Text 游戏对象
- en: With the `Canvas` game object selected in the `Button` game object. `Button`
    can be found under `Button` game object will be added as a child of the `Canvas`
    game object.![Figure 7.30 – Added Button game object in the Hierarchy view
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Button` 游戏对象中选择 `Canvas` 游戏对象。`Button` 可以在 `Button` 游戏对象下找到，并将作为 `Canvas`
    游戏对象的子对象添加。![图 7.30 – 在层次结构视图中添加的 Button 游戏对象
- en: '](img/Figure_7.30_B17597.jpg)'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.30_B17597.jpg)'
- en: Figure 7.30 – Added Button game object in the Hierarchy view
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.30 – 在层次结构视图中添加的 Button 游戏对象
- en: Select the newly added `Button` game object, and then click and drag it from
    the `Button` in the **Project** window.![Figure 7.31 – Prefab created in the Project
    window
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新添加的 `Button` 游戏对象，然后从 **项目** 窗口中的 `Button` 拖动并点击。![图 7.31 – 在项目窗口中创建的预制件
- en: '](img/Figure_7.31_B17597.jpg)'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.31_B17597.jpg)'
- en: Figure 7.31 – Prefab created in the Project window
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.31 – 在项目窗口中创建的预制件
- en: After the `Button` game object icon changes in the `Button` game object in the
    `Button` game object is now a Prefab, it exists as an asset and does not need
    to exist in the current **Hierarchy** view. (It will later be instantiated by
    code.)
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Button` 游戏对象图标在 `Button` 游戏对象中的 `Button` 游戏对象更改后，现在它是一个预制件，它作为一个资产存在，不需要在当前的
    **层次结构** 视图中存在。（它稍后将通过代码实例化。）
- en: With the project and game objects created, the next item is a `script` component.
    This will create the necessary properties for other files to be associated with
    running the story.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建项目和游戏对象后，下一项是一个 `script` 组件。这将创建运行故事所需的必要属性。
- en: Associating Prefab and ink JSON files
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联预制件和 ink JSON 文件
- en: 'After creating the game objects in the last section, we will now create a `script`
    component, create the necessary properties, and then associate assets with the
    properties:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节创建游戏对象后，我们现在将创建一个 `script` 组件，创建必要的属性，然后将资产与属性关联：
- en: Select the `Canvas` game object in the **Hierarchy** view.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**视图中选择`Canvas`游戏对象。
- en: In the `script` component using the instructions in the *Creating a script component*
    section.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用*创建脚本组件*部分中的说明的`script`组件中。
- en: Name (or rename following creation) this new file `InkStory.cs`.![Figure 7.32
    – Created InkStory.cs file
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （或创建后重命名）此新文件为`InkStory.cs`。![图7.32 – 创建的InkStory.cs文件
- en: '](img/Figure_7.32_B17597.jpg)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.32_B17597.jpg)'
- en: Figure 7.32 – Created InkStory.cs file
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.32 – 创建的InkStory.cs文件
- en: Double-click on the `InkStory.cs` file for editing in Visual Studio.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`InkStory.cs`文件以在Visual Studio中进行编辑。
- en: 'Update the code to the following:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码更新为以下内容：
- en: '[PRE12]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are three new additions to the default code provided by Unity. The first
    is the inclusion of the `Ink.Runtime` namespace. This will allow us to work with
    ink while a story runs. The second two additions are the properties we will be
    using in the `public` keyword in C# to create a property we can adjust in the
    editor:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供的默认代码中新增了三项内容。第一项是包含`Ink.Runtime`命名空间，这将允许我们在故事运行时使用ink。后两项新增内容是我们将在C#中的`public`关键字中使用的属性，以创建可以在编辑器中调整的属性：
- en: Save the file and return to Unity.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并返回Unity。
- en: Create a new ink file named (or renamed following creation) `TheBody.ink`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为（或创建后重命名）`TheBody.ink`的新ink文件。
- en: Open the `TheBody.ink` file in Inky for editing and copy the contents from the
    file from GitHub.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Inky中打开`TheBody.ink`文件进行编辑，并从GitHub的文件中复制内容。
- en: Note
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The code for this example, `TheBody.ink`, can be found on GitHub.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此示例的代码`TheBody.ink`可以在GitHub上找到。
- en: Save the ink source file and return to Unity.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存ink源文件并返回Unity。
- en: The use of the `public` keyword in `InkStory.cs` added two new properties to
    the `Canvas` game object.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`InkStory.cs`中使用的`public`关键字为`Canvas`游戏对象添加了两个新属性。
- en: '![Figure 7.33 – Properties added in the Inspector view'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.33 – 在检查器视图中添加的属性'
- en: '](img/Figure_7.33_B17597.jpg)'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.33_B17597.jpg)'
- en: Figure 7.33 – Properties added in the Inspector view
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.33 – 在检查器视图中添加的属性
- en: Click on the file selection next to the `Ink` `JSON Asset` property to open
    the **Select TextAsset** window.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Ink` `JSON Asset`属性旁边的文件选择，打开**选择文本资产**窗口。
- en: Associate the ink JSON file created by the ink-Unity Integration plugin with
    the **Ink JSON Asset** property and then close the **Select TextAsset** window.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ink-Unity Integration插件创建的ink JSON文件与**Ink JSON Asset**属性关联，然后关闭**选择文本资产**窗口。
- en: Click on the file selection next to the `Button` Prefab to open the **Select
    GameObject** window.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Button`预制件旁边的文件选择，打开**选择游戏对象**窗口。
- en: Select the **Assets** tab in the **Select GameObject** window if it is not open.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果未打开，在**选择游戏对象**窗口中选择**资产**选项卡。
- en: Select the **Button** Prefab and then close the **Select GameObject** window.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**按钮**预制件，然后关闭**选择游戏对象**窗口。
- en: The result of associating the ink JSON file with the `Button` Prefab will be
    that the code has access to those assets during runtime.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将ink JSON文件与`Button`预制件关联的结果是，代码在运行时可以访问这些资源。
- en: '![Figure 7.34 – Updated Ink Story component with the ink JSON file and button
    Prefab values'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.34 – 更新了Ink Story组件，包含ink JSON文件和按钮预制件值'
- en: '](img/Figure_7.34_B17597.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.34_B17597.jpg)'
- en: Figure 7.34 – Updated Ink Story component with the ink JSON file and button
    Prefab values
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.34 – 更新了Ink Story组件，包含ink JSON文件和按钮预制件值
- en: With the file associated with properties of the `script` component, additional
    code can now be written. Changing the ink source file, `TheBody.ink`, and saving
    the change will automatically update the `TheBody.json` file. The same is also
    true of the `Button` Prefab. It can also be adjusted, and its settings changed.
    As long as neither asset is renamed, Unity will maintain the association and allow
    developers to customize their settings independent of the code using them when
    the scene runs.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 与`script`组件的属性关联的文件，现在可以编写额外的代码。更改ink源文件`TheBody.ink`并保存更改将自动更新`TheBody.json`文件。同样，对于`Button`预制件也是如此。它也可以进行调整，并更改其设置。只要这两个资源没有重命名，Unity将保持关联，并允许开发者在场景运行时独立于使用它们的代码自定义其设置。
- en: By the end of this section, we will have created a Unity project, its game objects,
    and associated assets with properties. Before we can run the project, we will
    need to write more code to dynamically create a user interface based on the content
    of a running ink story. In the next section, we will write the code to use the
    Prefab and create a dynamic interface based on the text output of the `ContinueMaximally()`
    method and the `currentChoices` property.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，我们将创建一个Unity项目、其游戏对象以及相关的具有属性的资源。在我们能够运行项目之前，我们需要编写更多代码来根据正在运行的墨迹故事的内容动态创建用户界面。在下一节中，我们将编写代码来使用预制件并根据`ContinueMaximally()`方法和`currentChoices`属性的文字输出创建动态界面。
- en: Making a dynamic user interface
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作动态用户界面
- en: The final series of steps needed before the Unity project can be run is to add
    more code. We need to incorporate the concepts explained in this chapter covering
    the use of the `ContinueMaximally()` method and the `currentChoices` property.
    We also need to add an overall loop within the code using the `canContinue` property
    to check whether there is more content before progressing the story.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity项目可以运行之前，需要添加更多的代码。我们需要结合本章中解释的概念，包括使用`ContinueMaximally()`方法和`currentChoices`属性。我们还需要在代码中添加一个整体循环，使用`canContinue`属性检查在推进故事之前是否有更多内容。
- en: We begin by adding the properties we will need within the class that will not
    be used by the Unity editor. We mark these using the `private` keyword.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在不会由Unity编辑器使用的类中添加我们将需要的属性。我们使用`private`关键字标记这些属性。
- en: 'Open `InkStory.cs` for editing in Visual Studio:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开`InkStory.cs`进行编辑：
- en: '[PRE13]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To work with user interface game objects, another instance of the `using` keyword
    is needed. This adds access to classes such as `Text` and `Button` used in this
    file.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要与用户界面游戏对象一起工作，需要另一个`using`关键字的实例。这将为`Text`和`Button`等在此文件中使用的类添加访问权限。
- en: The `Story` class and the `Text` game object `currentLinesText` will be used
    across methods in this code. To make sure they can be used in this way, they must
    be properties of the `InkStory` class and not variables within any method.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`Story`类和`Text`游戏对象`currentLinesText`将在本代码的多个方法中使用。为了确保它们可以以这种方式使用，它们必须是`InkStory`类的属性，而不是任何方法中的变量。'
- en: 'The first thing that must happen is the loading of the ink JSON file. Next,
    a reference to the `Text` component is needed. The text will be shown to the user
    each time they make a choice. This means the `text` property of the `Text` game
    object will need to be updated. However, as it is a child of `Canvas`, the `GetComponentInChildren()`
    method is needed:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 必须首先发生的是加载ink JSON文件。接下来，需要一个对`Text`组件的引用。每次用户做出选择时，都会显示文本。这意味着需要更新`Text`游戏对象的`text`属性。然而，由于它是`Canvas`的子项，需要使用`GetComponentInChildren()`方法：
- en: '[PRE14]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The process of loading the text content and current choices will be used multiple
    times. This means all the code used as part of the process should be its own method:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 加载文本内容和当前选项的过程将被多次使用。这意味着作为该过程一部分使用的所有代码都应该是一个独立的方法：
- en: '[PRE15]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the new `LoadTextAndWeave()` method, new text content will be loaded if the
    `canContinue` property is true. Using the `foreach` keyword, new buttons will
    be added by using the `Instantiate()` method in Unity. This *instantiates* a Prefab
    as a GameObject during runtime, creating it through code and adding it to the
    running scene.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的`LoadTextAndWeave()`方法中，如果`canContinue`属性为真，将加载新的文本内容。使用`foreach`关键字，通过Unity中的`Instantiate()`方法添加新的按钮。这将在运行时将预制件作为GameObject实例化，通过代码创建它并将其添加到正在运行的场景中。
- en: Finally, the `AddListener()` method is used with the `OnClick` property of a
    button in Unity. This adds to a collection of which functions should be notified
    that a click has happened. The `delegate` keyword allows a developer to pass a
    method as an argument to another method. In this case, a short method is created
    within the same scope as the `foreach` loop. The `index` property can thus be
    used inside this created method.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用Unity中按钮的`OnClick`属性和`AddListener()`方法。这会将一个集合添加到其中，指定哪些函数应该在点击发生时被通知。`delegate`关键字允许开发人员将方法作为参数传递给另一个方法。在这种情况下，在`foreach`循环的同一作用域内创建了一个简短的方法。因此，可以在创建的方法中使用`index`属性。
- en: 'Every time the button is clicked, the `Story` class method `ChooseChoiceIndex()`
    will be called with the correct index, and the `LoadTextAndWeave()` method will
    be called again, refreshing the value of the `currentLinesText` method and updating
    the current buttons shown on the screen:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 每次按钮被点击时，`Story`类方法`ChooseChoiceIndex()`将使用正确的索引被调用，并且`LoadTextAndWeave()`方法将再次被调用，刷新`currentLinesText`方法的值并更新屏幕上显示的当前按钮：
- en: 'To run the current code, one more change is needed. The `LoadTextAndWeave()`
    method needs to be called inside the `Start()` method:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行当前代码，还需要进行一项更改。需要在`Start()`方法中调用`LoadTextAndWeave()`方法：
- en: '[PRE16]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Save the current code in Visual Studio. Return to Unity and run the scene.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中保存当前代码。返回Unity并运行场景。
- en: Immediately, two problems will become evident. First, the default black text
    on a dark background makes the text impossible to read. Second, only the first
    few words will be shown.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 立即，两个问题将变得明显。首先，默认的黑色文本在深色背景上使得文本难以阅读。其次，只显示前几个单词。
- en: '![Figure 7.35 – The Body project running in Unity](img/Figure_7.35_B17597.jpg)'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.35 – 在Unity中运行的Body项目](img/Figure_7.35_B17597.jpg)'
- en: Figure 7.35 – The Body project running in Unity
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.35 – 在Unity中运行的Body项目
- en: Click on the **(Continue.)** button to see two more problems.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**（继续。）**按钮以查看更多两个问题。
- en: '![Figure 7.36 – Dynamically created buttons in The Body](img/Figure_7.36_B17597.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图7.36 – 在The Body中动态创建的按钮](img/Figure_7.36_B17597.jpg)'
- en: Figure 7.36 – Dynamically created buttons in The Body
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.36 – 在The Body中动态创建的按钮
- en: The first problem is that instead of replacing the first button, Unity added
    two more. This is caused by the second call to the `LoadTextAndWeave()`method
    internally. First, the text content and button were loaded. Next, when the **(Continue.)**
    button was clicked, it was called again, adding more buttons.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是在替换第一个按钮而不是添加两个按钮。这是由于对`LoadTextAndWeave()`方法的第二次内部调用引起的。首先，加载了文本内容和按钮。然后，当**（继续。）**按钮被点击时，它再次被调用，添加了更多按钮。
- en: 'We can also observe that the buttons are small and hard to read. By default,
    Unity will assume some values for a `Button` game object. While adjusting our
    code, we will also need to change the properties:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以观察到按钮很小，难以阅读。默认情况下，Unity将为`Button`游戏对象假设一些值。在调整我们的代码时，我们还需要更改属性：
- en: Stop the running scene.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止运行场景。
- en: To start to fix the issue with the text, first, select the `Text` game object
    in the `160` and `30`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始修复文本问题，首先，在`160`和`30`中选择`Text`游戏对象。
- en: Through either clicking and dragging using the `800` and height of `300`.![Figure
    7.37 – The Inspector view in Unity with updated width and height values
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击和拖动使用`800`宽度和`300`高度。![图7.37 – Unity中带有更新后的宽度和高度值的检查器视图
- en: '](img/Figure_7.37_B17597.jpg)'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.37 – Unity中带有更新后的宽度和高度值的检查器视图](img/Figure_7.37_B17597.jpg)'
- en: Figure 7.37 – The Inspector view in Unity with updated width and height values
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.37 – Unity中带有更新后的宽度和高度值的检查器视图
- en: Click on the `14` to `24`. This will make the starting size larger.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`14`到`24`。这将使起始大小更大。
- en: Click on the `default` to `white` and then close the **Color** window.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`default`将其更改为`white`，然后关闭**颜色**窗口。
- en: The updated values will now display more text and, with the white on a darker
    background, increase its readability.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更新后的值现在将显示更多文本，并且由于白色背景较暗，其可读性有所提高。
- en: '![Figure 7.38 – Updated Text GameObject component values'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.38 – 更新后的Text GameObject组件值'
- en: '](img/Figure_7.38_B17597.jpg)'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.38 – 更新后的button Prefab值](img/Figure_7.38_B17597.jpg)'
- en: Figure 7.38 – Updated Text GameObject component values
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.38 – 更新后的Text GameObject组件值
- en: Click on the `Button` Prefab in the **Project** window.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中单击`Button`Prefab。
- en: Like the `Text` game object, its default width is `160` and its height is `30`.
    Change the width to `250` and the height to `100`.![Figure 7.39 – Updated button
    Prefab values
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`Text`游戏对象一样，其默认宽度为`160`，高度为`30`。将宽度更改为`250`，高度更改为`100`。![图7.39 – 更新后的button
    Prefab值
- en: '](img/Figure_7.39_B17597.jpg)'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.39 – 更新后的button Prefab值](img/Figure_7.39_B17597.jpg)'
- en: Figure 7.39 – Updated button Prefab values
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.39 – 更新后的button Prefab值
- en: Return to editing `InkStory.cs` in Visual Studio.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到Visual Studio中的`InkStory.cs`进行编辑。
- en: 'The fix to the code is a small but important one. Each time the button is clicked,
    the code will need to destroy the current buttons and then create new ones:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的修复是一个小但重要的更改。每次按钮被点击时，代码将需要销毁当前按钮并创建新的按钮：
- en: 'A new method is needed for the specific task of destroying `Button` children:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要一种新方法来执行特定任务，即销毁`Button`子对象：
- en: '[PRE17]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: cloneButtonButton.onClick.AddListener(delegate
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cloneButtonButton.onClick.AddListener(delegate
- en: '{'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: inkStory.ChooseChoiceIndex(c.index);
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: inkStory.ChooseChoiceIndex(c.index);
- en: DestoryButtonChildren();
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: DestoryButtonChildren();
- en: LoadTextAndWeave();
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: LoadTextAndWeave();
- en: '});'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE18]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Save the updated file in Visual Studio and return to Unity.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中保存更新后的文件并返回 Unity。
- en: The `DestroyButtonChildren()` method looks for a specific `tag` value. This
    needs to be added to the `Button` Prefab.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DestroyButtonChildren()`方法查找特定的`标签`值。这需要添加到`按钮`预制件中。'
- en: Select the `Button` Prefab in the **Project** window.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中选择`按钮`预制件。
- en: In the **Inspector** view, click on the **Tag** drop-down menu and then the
    **Add Tag…** option.![Figure 7.40 – Tag drop-down menu in the Unity Inspector
    view](img/Figure_7.40_B17597.jpg)
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**视图中，点击**标签**下拉菜单，然后选择**添加标签…**选项。![图 7.40 – Unity 检查器视图中的标签下拉菜单](img/Figure_7.40_B17597.jpg)
- en: Figure 7.40 – Tag drop-down menu in the Unity Inspector view
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.40 – Unity 检查器视图中的标签下拉菜单
- en: Click on the **+** icon to add a new tag to the list. In the prompt, use the
    name *ButtonChoice*.![Figure 7.41 – New tag name
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**+**图标向列表中添加一个新的标签。在提示中，使用名称*ButtonChoice*。![图 7.41 – 新标签名称
- en: '](img/Figure_7.41_B17597.jpg)'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.41_B17597.jpg)'
- en: Figure 7.41 – New tag name
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.41 – 新标签名称
- en: Click on **Save** to create a new tag.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**以创建一个新的标签。
- en: Click on the `Button` Prefab in the `ButtonChoice` tag has been added, it must
    be selected.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击已添加到`ButtonChoice`标签中的`按钮`预制件，必须选择它。
- en: In the **Tag** dropdown, select **ButtonChoice**.![Figure 7.42 – Added ButtonChoice
    option to the Tag drop-down menu
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**标签**下拉菜单中，选择**ButtonChoice**。![图 7.42 – 将 ButtonChoice 选项添加到标签下拉菜单
- en: '](img/Figure_7.42_B17597.jpg)'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.42_B17597.jpg)'
- en: Figure 7.42 – Added ButtonChoice option to the Tag drop-down menu
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.42 – 将 ButtonChoice 选项添加到标签下拉菜单
- en: Run the scene. Play through the story by clicking on buttons to make choices
    and see the result.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景。通过点击按钮进行选择并查看结果来玩故事。
- en: Stop the running scene when done playing the story.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩完故事后，停止运行场景。
- en: The changes to the `Text` game object and code will load the new text and correctly
    update the choices as the player clicks on the buttons. While consisting of multiple
    steps, this same approach can be used with most ink JSON files to present text
    and dynamic buttons for a player to make different choices and then see the result
    on the screen.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 对`文本`游戏对象和代码的更改将加载新的文本，并在玩家点击按钮时正确更新选择。虽然步骤较多，但这种方法可以用于大多数 ink JSON 文件，以向玩家展示文本和动态按钮，让他们做出不同的选择，并在屏幕上看到结果。
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we worked through the process of adding a `script` component,
    associating an ink JSON file with a property, and using methods and properties
    as part of the `Story` class to progress a running ink story. We saw how the `Continue()`
    method loads one line at a time and the `ContinueMaximally()` method loads all
    text until it encounters a weave. When combined with the `canContinue` property,
    these methods allow for text content to be loaded from an ink JSON file and prevent
    any errors when the content runs out. With the `currentChoices` property, we examined
    how to use loops, such as those using the `foreach` keyword. When we used the
    `ChooseChoiceIndex()` method, we picked which option among the weave we wanted
    and progressed through a story using the `Continue()` or `ContinueMaximally()`
    methods again.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了添加`脚本`组件、将 ink JSON 文件与属性关联以及使用`Story`类中的方法和属性来推进运行中的 ink 故事的过程。我们看到了`Continue()`方法一次加载一行，而`ContinueMaximally()`方法则加载所有文本直到遇到编织点。当与`canContinue`属性结合使用时，这些方法允许从
    ink JSON 文件中加载文本内容，并在内容耗尽时防止出现任何错误。通过`currentChoices`属性，我们探讨了如何使用循环，例如使用`foreach`关键字。当我们使用`ChooseChoiceIndex()`方法时，我们选择了想要从编织点中选择的选项，并再次使用`Continue()`或`ContinueMaximally()`方法推进故事。
- en: By setting up user interface game objects in Unity, we built a dynamic process
    to load ink story content, destroy buttons, and then create new ones. Needing
    to create a `Button` Prefab, we saw how these could be instantiated by the code
    while it was running. Adjusting the values of `Text` and `Button` game objects,
    we completed an interface for running an ink JSON file and built a system usable
    by many other projects working with the same game objects and organization.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 Unity 中设置用户界面游戏对象，我们构建了一个动态过程来加载墨水故事内容，销毁按钮，然后创建新的按钮。需要创建一个`按钮`预制件时，我们看到了代码在运行时如何实例化这些预制件。调整`文本`和`按钮`游戏对象的值，我们完成了一个运行
    ink JSON 文件的界面，并构建了一个许多其他项目都可以使用的系统，这些项目使用相同的游戏对象和组织。
- en: In the next chapter, we continue to use the `Story` class and its methods. We
    will examine how to retrieve and update the values of variables in an ink story
    using C# code. We will also see ways of accessing functions in ink and how to
    pass data in and out of them. Combined with user interface game objects, we will
    build an example of how to communicate between the ink runtime and Unity code
    by using content from ink to create multiple dynamic interfaces in Unity.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们继续使用`Story`类及其方法。我们将探讨如何使用C#代码检索和更新墨迹故事中的变量值。我们还将了解如何访问ink中的函数以及如何向它们传递和接收数据。结合用户界面游戏对象，我们将构建一个示例，展示如何通过使用ink中的内容在Unity中创建多个动态界面，从而实现ink运行时与Unity代码之间的通信。
- en: Questions
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between the `Continue()` and `ContinueMaximally()` methods
    in the `Story` class?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Story`类中的`Continue()`和`ContinueMaximally()`方法之间的区别是什么？'
- en: What type of data does the `ChooseChoiceIndex()` method in the `Story` class
    expect?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Story`类中的`ChooseChoiceIndex()`方法期望哪种类型的数据？'
- en: How is the `canContinue` property used with the `Continue()` and `ContinueMaximally()`
    methods in the `Story` class?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Story`类中，如何使用`canContinue`属性与`Continue()`和`ContinueMaximally()`方法一起使用？
- en: What is a Prefab in Unity?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unity中的Prefab是什么？
- en: What type of object is found in the `currentChoices` list property of the `Story`
    class?
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Story`类的`currentChoices`列表属性中可以找到哪种类型的对象？
