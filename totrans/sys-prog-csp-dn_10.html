<html><head></head><body>
		<div id="_idContainer042">
			<h1 class="chapter-number" id="_idParaDest-221"><a id="_idTextAnchor222"/>10</h1>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor223"/>The One with the Systems Check-Ups</h1>
			<p><em class="italic">Logging, Monitoring, </em><span class="No-Break"><em class="italic">and Metrics</em></span></p>
			<p>Now and then, software fails. Whether we like it or not, that is simply a fact of life. We make mistakes during development. Other people make mistakes. The environment changes. A network becomes unstable. These are all reasons the system might not behave as <span class="No-Break">we intended.</span></p>
			<p>Testing can help. A good and solid set of tests can show you the errors in your work and help make your system more robust. However, sometimes things still go wrong. Let’s face it: building software is a creative art form and thus subject to influences beyond our control. So, when things go wrong and our systems do not do what we thought they would be doing, we need a way to look into their workings. That can help us figure out what happened and what we can do to <span class="No-Break">fix things.</span></p>
			<p>This is where logging and monitoring comes into play. Logging helps us write important information and store it in a well-known place. Logging is part of our code base. Monitoring is watching the system from the outside to track what is happening. In this chapter, I will show you exactly how to do everything from a systems <span class="No-Break">developer’s perspective.</span></p>
			<p>In this chapter, we will learn about the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>What logging frameworks <span class="No-Break">are there?</span></li>
				<li>How do I set up the correct levels <span class="No-Break">of logging?</span></li>
				<li>What is <span class="No-Break">structured logging?</span></li>
				<li>How can I monitor my logs outside <span class="No-Break">my system?</span></li>
				<li>What <span class="No-Break">is monitoring?</span></li>
				<li>How do I set <span class="No-Break">up monitoring?</span></li>
				<li>What should I monitor <span class="No-Break">or log?</span></li>
			</ul>
			<p>I hope you are as excited about this as <span class="No-Break">I am!</span></p>
			<h1 id="_idParaDest-223"><a id="_idTextAnchor224"/>Technical requirements</h1>
			<p>In this chapter, we look into monitoring and logging tools. One of the tools I often use is <strong class="bold">Seq</strong>. I am not affiliated with them; it is just a tool I like to use. You can download a free-to-use personal version at <a href="https://datalust.co/download">https://datalust.co/download</a>. You can download the installer or run the tool as a Docker image. To use this, you have to install Docker on your environment. I suggest you go to <a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a> to learn more about Docker.  If you want to play around, I suggest you choose the Docker version. You can run the image locally by invoking the following command from <span class="No-Break">a terminal:</span></p>
			<pre class="console">
docker run -d
    --restart unless-stopped
    --name seq
    -e ACCEPT_EULA=Y
    -v c:\data:/data
    -p 80:80
    -p 5341:5341
    datalust/seq:latest</pre>			<p>This Docker command downloads the image from <strong class="source-inline">datalust/seq</strong>. It listens to ports <strong class="source-inline">80</strong> for the <strong class="bold">User Interface</strong> (<strong class="bold">UI</strong>) and <strong class="source-inline">5341</strong> to intercept logs. All settings are stored in the <strong class="source-inline">C:\data</strong> folder, so you must create that folder beforehand (or change the <strong class="source-inline">-v</strong> property in the <span class="No-Break">Docker command).</span></p>
			<p>I will also show you how to use Prometheus in this chapter. To get that up and running, you could do the same thing. Either download the software from their website at <a href="https://prometheus.io/">https://prometheus.io/</a> or run it in a <span class="No-Break">Docker container:</span></p>
			<pre class="console">
docker run -d
    --name prom
    -p 9090:9090
    -v c:\data\prometheus.yml:/etc/prometheus/prometheus.yml
    prom/prometheus</pre>			<p>You need to have a <strong class="source-inline">prometheus.yml</strong> file that contains information about what you want to monitor. I will show you what that file looks like later in this chapter, where I will also explain what each <span class="No-Break">part does.</span></p>
			<p>We will be using a lot of NuGet packages as well; they are all mentioned in the paragraphs where I discuss each of them and how to <span class="No-Break">use them.</span></p>
			<p>You can download all code samples mentioned in this chapter from our GitHub repo <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter10"><span class="No-Break">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter10</span></a></p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor225"/>Available logging frameworks</h1>
			<p>Logging has been <a id="_idIndexMarker736"/>around forever. In the early days of computing, operators would walk around the machines and note whatever they saw happening to them. If a light blinked when it should not have blinked or vice versa, they wrote it down a journal somewhere. Later, systems would log everything they could onto paper and punch cards. If systems did something unexpected, the operators could go to the paper trail and figure out what had caused the event. After that, people used serial monitors that logged everything onto a <span class="No-Break">separate device.</span></p>
			<p>These days, we hardly use punch cards anymore. However, we still log. There are many frameworks out there that help you get the job done. In this chapter, I will explain three of those frameworks. They all have pros and cons. I will highlight these as much as possible. That way, you can make your own decisions about what to use and when to <span class="No-Break">use it.</span></p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor226"/>Default logger in .NET</h2>
			<p>Microsoft <a id="_idIndexMarker737"/>offers a <strong class="bold">default logger</strong>. We have<a id="_idIndexMarker738"/> seen it before: if you create an ASP.Net application or, as we have done, a worker process, you will get a logger framework for free. This framework is surprisingly full-featured. This framework offers enough features to satisfy the needs of most developers. So, let’s have a look <span class="No-Break">at it!</span></p>
			<p>As I said, many <a id="_idIndexMarker739"/>of the templates in Visual Studio already include the standard <strong class="source-inline">Logger</strong> class. Some templates, however, do not have this. So, let’s <a id="_idIndexMarker740"/>have a look at how to add it. We’ll begin with a clean, empty <span class="No-Break">Console application.</span></p>
			<p>The first thing we need to do is add the correct NuGet package. In this case, you need to install <strong class="source-inline">Microsoft.Extensions.Logging</strong> in your project. Once you have done that, you will have access to the <span class="No-Break">logging framework.</span></p>
			<p>In your main project, you can set up the logging <span class="No-Break">like this:</span></p>
			<pre class="source-code">
using Microsoft.Extensions.Logging;
ILoggerFactory loggerFactory = LoggerFactory.Create(builder =&gt;
{
    builder.SetMinimumLevel(LogLevel.Information);
});
var logger = loggerFactory.CreateLogger&lt;Program&gt;();
logger.LogInformation("This is some information");</pre>			<p>This code works. If you run it, you will not get any errors. However, you will also not get any output, so that is pretty useless, to <span class="No-Break">be honest.</span></p>
			<p>This is because the framework is quite flexible. It can handle all sorts of outputs to various destinations. However, you have to specify what <span class="No-Break">you want.</span></p>
			<p>Let’s fix this. Install another NuGet package; this time, we need the <strong class="source-inline">Microsoft.Extensions.Logging.Console</strong> package. Once you have installed that, we need to change the code in the <strong class="source-inline">LoggerFactory.Create()</strong> method to look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
var loggerFactory = LoggerFactory.Create(builder =&gt;
{
    builder.AddConsole();
    builder.SetMinimumLevel(LogLevel.Information);
});</pre>			<p>In the<a id="_idIndexMarker741"/> second line, we added the Console as a way <span class="No-Break">to output.</span></p>
			<p>If you run the program this time, you will get the <span class="No-Break">desired information:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer036">
					<img alt="Figure 10.1: Output from the log" src="image/B20924_11_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1: Output from the log</p>
			<p>OK. We <a id="_idIndexMarker742"/>got something on our screen. Let’s see what we have done so far since I deliberately skipped over <span class="No-Break">some steps.</span></p>
			<p><strong class="source-inline">LoggerFactory</strong> is a factory class that can create instances of a class that implements <strong class="source-inline">Ilogger&lt;T&gt;</strong>. We set up <strong class="source-inline">LoggerFactory</strong> by hooking up the desired outputs (in our case, Console; we’ll add others later). We also gave it the minimum log level <span class="No-Break">we wanted.</span></p>
			<p>Let’s dive into this. I want to discuss log levels and configuration, as well as the different tools <span class="No-Break">we have.</span></p>
			<h3>Log levels</h3>
			<p>Not all<a id="_idIndexMarker743"/> messages are equally important. If you are starting out on your project, you will probably want to log a lot. You can output anything you want and you will probably do so. You can write the contents of variables, loop controls, where you are in the flow, and so on. Anything that can help you understand the flow of your program as you run it is a candidate <span class="No-Break">for logging.</span></p>
			<p>However, once you have written and tested your software, you will probably not want all of that information anymore. You might want to log exceptional cases and errors, but that is <span class="No-Break">about it.</span></p>
			<p>To achieve that, you must remove all the logging code that you do not need anymore. Alternatively, you could wrap up the code in <strong class="source-inline">#IF / #ENDIF</strong> statements and thus effectively remove the calls when you recompile using a different <strong class="source-inline">#DEFINE</strong>. However, that means changing your code. That could lead to side effects. If you later find a bug and decide that you need that code in again, you will need to rewrite or recompile <span class="No-Break">the system.</span></p>
			<p><strong class="source-inline">Loglevels</strong> eliminates <span class="No-Break">that problem.</span></p>
			<p>Each log message we write has a level. In the preceding example, we used <strong class="source-inline">Log.LogInformation()</strong>. That means that we want to write something informational. There <a id="_idIndexMarker744"/>are other levels we can use as well. What you use them for is entirely up to you. However, in general, there is meaning to each level. These are the levels we can use <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">ILogger</strong></span><span class="No-Break">:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-9">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold"> </strong><span class="No-Break"><strong class="bold">Log level</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold"> </strong><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> <span class="No-Break">Trace</span></p>
						</td>
						<td class="No-Table-Style">
							<p> This refers to the most detailed messages. These messages may contain sensitive application data and are therefore not recommended to be enabled in a production environment unless they are necessary for troubleshooting and only for <span class="No-Break">short periods.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> <span class="No-Break">Debug</span></p>
						</td>
						<td class="No-Table-Style">
							<p>This displays messages that are useful for debugging. It is less verbose than Trace, but more <span class="No-Break">than Information.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> <span class="No-Break">Information</span></p>
						</td>
						<td class="No-Table-Style">
							<p>This allows the system to show informational messages that highlight the general flow of the application. It is useful for general <span class="No-Break">application insights.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> <span class="No-Break">Warning</span></p>
						</td>
						<td class="No-Table-Style">
							<p>This is all about messages that highlight an abnormal or unexpected event in the application flow, but which do not otherwise cause the application execution <span class="No-Break">to stop.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> <span class="No-Break">Error</span></p>
						</td>
						<td class="No-Table-Style">
							<p>These are messages that highlight when the current flow of execution is stopped due to a failure. These should indicate a failure in the current activity, not an <span class="No-Break">application-wide failure.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> <span class="No-Break">Critical</span></p>
						</td>
						<td class="No-Table-Style">
							<p>This is about messages describing an unrecoverable application, system crash, or catastrophic failure requiring <span class="No-Break">immediate attention.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> <span class="No-Break">None</span></p>
						</td>
						<td class="No-Table-Style">
							<p>This results in no messages being logged. This level is used to turn <span class="No-Break">off logging.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.1 Log levels in Microsoft Logger</p>
			<p>There are two ways in which you can specify what level your message has to be. You can use one of the dedicated log methods (such as <strong class="source-inline">LogInformation</strong>, <strong class="source-inline">LogTrace</strong>, <strong class="source-inline">LogDebug</strong>, and so on) or the generic <strong class="source-inline">Log()</strong> method. That looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
logger.Log(LogLevel.Critical, "This is a critical message");</pre>			<p>You just <a id="_idIndexMarker745"/>call <strong class="source-inline">Log()</strong> and then give it the <strong class="source-inline">LogLevel</strong>. Whatever method you choose, you can decide what level the log is supposed to <span class="No-Break">be on.</span></p>
			<p>However, that only solves a part of the issue. We want to be flexible in what we output to the screen. That’s where the <strong class="source-inline">SetMinimumLevel()</strong> method on the <strong class="source-inline">ILoggingBuilder</strong> comes <span class="No-Break">into play.</span></p>
			<p>The method determines what the log is writing to the chosen output channels. If you set it to <strong class="source-inline">Information</strong>, all calls to the log are processed if they are of the Information level or higher. In other words, all calls to <strong class="source-inline">Log.LogTrace()</strong>, <strong class="source-inline">Log.Debug()</strong>, <strong class="source-inline">Log.Log(LogLevel.Trace)</strong>, and <strong class="source-inline">Log.Log(LogLevel.Debug)</strong> are ignored. So you can, in one line, determine what you do and do not want to appear on the logs. You specify the level and all information on that level or above is outputted. The rest <span class="No-Break">is ignored.</span></p>
			<p>During development, you might want to set the level to Trace. After extensive testing, you might want to set it to <strong class="source-inline">Critical</strong> or maybe <strong class="source-inline">Error</strong> <span class="No-Break">during production.</span></p>
			<h3>Using a Settings file</h3>
			<p>Of course, we<a id="_idIndexMarker746"/> are not there yet. If you want to change the log level, you still need to change the code and recompile the system. Let’s change that so we can use <span class="No-Break">something else.</span></p>
			<p>Add a new file to your program called <strong class="source-inline">appsettings.json</strong>. Make sure you change the <strong class="source-inline">Copy to output directory</strong> property to <strong class="source-inline">Copy if newer</strong>; you need this file next to <span class="No-Break">the binaries.</span></p>
			<p>The file should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information"
    }
  }
}</pre>			<p>Now, we need to add a couple of NuGet packages. Install <strong class="source-inline">Microsoft.Extensions.Configuration.JSon</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Microsoft.Extensions.Logging.Configuration</strong></span><span class="No-Break">.</span></p>
			<p>When we have<a id="_idIndexMarker747"/> done that, we will add the following code that actually reads <span class="No-Break">the configuration:</span></p>
			<pre class="source-code">
var configurationBuilder = new ConfigurationBuilder()
    .AddJsonFile(
        path: "appsettings.json",
        optional:true,
        reloadOnChange:true);
var configuration = configurationBuilder.Build();
var configurationSection=
    configuration.GetSection("Logging");</pre>			<p>This code creates a <strong class="source-inline">ConfigurationBuilder</strong> and then adds the JSON file we just added. We set the <strong class="source-inline">optional</strong> parameter to <strong class="source-inline">true</strong>; if people decide to remove the file, our app will still work. We also specify that the <strong class="source-inline">reloadOnChange</strong> parameter is <strong class="source-inline">true</strong>. As you have probably guessed, the configuration is reloaded when the <span class="No-Break">file changes.</span></p>
			<p>The following is relatively straightforward: we call <strong class="source-inline">Build()</strong> to get the <strong class="source-inline">IConfiguration</strong>, then call <strong class="source-inline">GetSection</strong> (Logging) to load that specific part of our <span class="No-Break">JSON file.</span></p>
			<p>We need to do some work on our <strong class="source-inline">LoggerFactory</strong> as well. Change it to look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
var loggerFactory = LoggerFactory.Create(builder =&gt;
{
    builder.AddConsole();
    builder.AddConfiguration(configurationSection);
});</pre>			<p>Instead of <a id="_idIndexMarker748"/>hardcoding the log level, we will now give it the configuration section from the <span class="No-Break">JSON file.</span></p>
			<p>Lastly, let’s change the code that does the actual logging a bit. I will wrap it in a <span class="No-Break">continuous loop:</span></p>
			<pre class="source-code">
while (true)
{
    logger.LogTrace("This is a trace");
    logger.LogDebug("This is debug");
    logger.LogInformation("This is information");
    logger.LogWarning("This is warning");
    logger.LogError("This is an error");
    logger.LogCritical("This is a critical message");
    await Task.Delay(1000);
}</pre>			<p>Run your program and see all the different ways of displaying your message. Open another terminal window, navigate to the compiled application folder, and change the log setting in the <strong class="source-inline">appsettings.json</strong> file. As soon as you save the file, you will see a different behavior in the application. Depending on your desire, it will display more or fewer lines <span class="No-Break">of logging.</span></p>
			<p>Now, you can add all the logging you want to your application, use <strong class="source-inline">Trace</strong> during debugging and development, and then move to <strong class="source-inline">Critical</strong> or <strong class="source-inline">Error</strong> if your system is ready for production. You can quickly return to a more detailed debugging level as soon as something happens. All of that is done <span class="No-Break">without recompiling!</span></p>
			<h3>Using EventId</h3>
			<p>Having different debugging levels is nice, but that is not enough to structure the information if you<a id="_idIndexMarker749"/> have a lot of messages. To help you create a bit of order in the logging chaos, you can use <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">EventId</strong></span><span class="No-Break">.</span></p>
			<p>All log methods have an overload that allows you to add an <strong class="source-inline">EventId</strong>. An <strong class="source-inline">EventId</strong> is a class that contains an ID in the <strong class="source-inline">integer</strong> form and a name in the <strong class="source-inline">string</strong> form. What those are is entirely left up to you. The name is not even used in the logs, but it is there for your convenience during development. We can create an <strong class="source-inline">EventId</strong>, or multiple, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
var initEventId = new EventId(1, "Initialization");
var shutdownEventId = new EventId(2, "Shutdown");
var fileReadingEventId = new EventId(3, "File Reading");</pre>			<p>I just made up a bunch of categories: <strong class="source-inline">Initialization</strong>, <strong class="source-inline">Shutdown</strong>, and <strong class="source-inline">File Reading</strong>. This is just an example; I am sure that you can come up with much <span class="No-Break">better names.</span></p>
			<p>When you log something, you can use an <strong class="source-inline">EventId</strong> to indicate that the message you log has to do with a certain part of the system. That looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
logger.LogInformation(initializationEventId, "Application started");
logger.LogInformation(shutdownEventId, "Application shutting down");
logger.LogError(fileReadingEventId, "File not found");</pre>			<p>The output now looks a <span class="No-Break">bit different:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer037">
					<img alt="FIgure 10.2: Output of logging with an EventId (or multiple)" src="image/B20924_11_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">FIgure 10.2: Output of logging with an EventId (or multiple)</p>
			<p>Next to the <strong class="source-inline">Log</strong> type and the <strong class="source-inline">Program</strong>, you can see the number between brackets. That is the number of the <strong class="source-inline">EventId</strong> type. In our case, <strong class="source-inline">1</strong> was initialization, <strong class="source-inline">2</strong> was shut down, and <strong class="source-inline">3</strong> was<a id="_idIndexMarker750"/> file reading. Again, these strings are never used and, unfortunately, are not shown on the screen. However, having these numbers in there can help you find the areas that you are <span class="No-Break">interested in.</span></p>
			<h3>Using Type information</h3>
			<p>There is one last <a id="_idIndexMarker751"/>thing you can use to organize your logs. I didn’t explain it earlier, but you must have noticed that when we created the instance of our <strong class="source-inline">logger</strong>, we gave it a <strong class="source-inline">Program</strong> <span class="No-Break">type parameter:</span></p>
			<pre class="source-code">
var logger = loggerFactory.CreateLogger&lt;Program&gt;();</pre>			<p>Since we called <strong class="source-inline">CreateLogger</strong> with the <strong class="source-inline">Program</strong> type, we see the <strong class="source-inline">Program</strong> string on the screen in <span class="No-Break">the logs.</span></p>
			<p>You can create several instances of the <strong class="source-inline">ILogger</strong> interface, each with its own type attached to it. That way, you can create different loggers for each application part. If you have a part of your system that handles printing and the main class is called <strong class="source-inline">Printer</strong>, you can create a logger of the <strong class="source-inline">Printer</strong> type <span class="No-Break">like this:</span></p>
			<pre class="source-code">
var printLogger = loggerFactory.CreateLogger&lt;Printer&gt;();</pre>			<p>All logs written to the <strong class="source-inline">printLogger</strong> instance will now show <strong class="source-inline">Printer</strong> in their log lines instead of <strong class="source-inline">Program</strong>. Of course, it doesn’t really matter what you pass in that parameter. You can use the <strong class="source-inline">Printer</strong> logger in your main program if you want to. It is just decoration that helps you organize the output of the logs. That’s it. There is no logic <span class="No-Break">behind it.</span></p>
			<p class="callout-heading">Using categories wisely</p>
			<p class="callout">I suggest you use these categories, but use them sparingly; too many will only clutter your logs. I usually create empty classes just for use in the logger creation. That way, I can get a nice set of logger instances without relying on internal code that nobody outside should see. However, I will leave that entirely up <span class="No-Break">to you.</span></p>
			<p>Now that we have basic logging out of the way, it is time to look at some popular alternatives that offer some other nifty tricks we can use. Let us begin <span class="No-Break">with NLog!</span></p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor227"/>NLog</h2>
			<p>Microsoft is <a id="_idIndexMarker752"/>not the only company that offers a logging framework. There <a id="_idIndexMarker753"/>are others out there, each with their own strengths and weaknesses. One of the more popular ones out there <span class="No-Break">is </span><span class="No-Break"><strong class="bold">NLog</strong></span><span class="No-Break">.</span></p>
			<p>NLog was created by Jared Kowalski in 2006 as an alternative to the popular log4net solution, which is a port of the immensely popular log4j Java logging solution. Kowalski aimed to build a logging solution that was high in performance but also flexible in the configuration of <span class="No-Break">the settings.</span></p>
			<h3>Setting up NLog</h3>
			<p>To use <a id="_idIndexMarker754"/>NLog, you need to install the corresponding NuGet package. The name of the package is <span class="No-Break">simply </span><span class="No-Break"><strong class="source-inline">NLog</strong></span><span class="No-Break">.</span></p>
			<p>Once you have installed that package, we must create a configuration file. To do that, add a new XML file to your project (do not forget to set the properties to <strong class="source-inline">Copy if newer</strong> so that the project can find the file when it runs). By convention, this file is called <strong class="source-inline">NLog.config</strong>, but you can choose any name. The file should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;nlog xmlns=http://www.nlog-project.org/schemas/NLog.xsd
      xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance
      &gt;
  &lt;targets&gt;
    &lt;target
      name="logfile"
      xsi:type="File"
      fileName="${basedir}/logs/logfile.txt"
      layout="${date:format=HH\:mm\:ss} ${logger} ${uppercase:${level}} ${message}" /&gt;
    &lt;target
      name="logconsole"
      xsi:type="Console" /&gt;
  &lt;/targets&gt;
  &lt;rules&gt;
    &lt;logger name="*"
            minlevel="Info"
            writeTo="logfile,logconsole" /&gt;
  &lt;/rules&gt;
&lt;/nlog&gt;</pre>			<p>You can control <a id="_idIndexMarker755"/>almost all of NLog through this configuration file. You can set up all parameters in code, but that kind of defeats the purpose of NLog. I suggest that you use the <strong class="source-inline">configuration</strong> file and avoid setting things in the code. That is unless you have a really good reason to do otherwise, of course. After all, it is still your code, <span class="No-Break">not mine.</span></p>
			<p>Now, it is time to start logging. In your program, add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
using NLog;
LogManager.Configuration =
    new XmlLoggingConfiguration(
        "NLog.config"
    );
try
{
    Logger logger = LogManager.GetCurrentClassLogger();
    logger.Trace("This is a trace message");
    logger.Debug("This is a debug message");
    logger.Info("Application started");
    logger.Warn("This is a warning message");
    logger.Error("This is an error message");
    logger.Fatal("This is a fatal error message");
}finally{
    LogManager.Shutdown();
}</pre>			<p>First, we<a id="_idIndexMarker756"/> will load the configuration in the <strong class="source-inline">LogManager</strong>. You usually have one setup for all your logging needs in your entire application, so you might as well do <span class="No-Break">this first.</span></p>
			<p>Then, we will call <strong class="source-inline">GetCurrentClassLogger()</strong>. This call is the equivalent of the call to <strong class="source-inline">CreateLogger&lt;T&gt;</strong> in the Microsoft framework. It ties the current class name to the logger so you can categorize <span class="No-Break">your logs.</span></p>
			<p>If you want other loggers to be associated with different classes, you can do so by calling something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
var otherLogger  = LogManager.GetLogger("OtherLogger");</pre>			<p>This call creates another logger with the same configuration but will show <strong class="source-inline">"OtherLogger"</strong> in the output <span class="No-Break">this time.</span></p>
			<p>The rest of the code is self-explanatory, except for the line that says <strong class="source-inline">LogManager.Shutdown()</strong>. This line is needed to flush out all logs in the code and ensure that no message is <span class="No-Break">left behind.</span></p>
			<h3>Log levels in NLog logging</h3>
			<p>As with the<a id="_idIndexMarker757"/> Microsoft framework, you can specify which level you want to see in the log files. The levels for NLog are comparable, but there are minor differences. The following table shows the <span class="No-Break">available options:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-7">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">NLog level</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> <span class="No-Break">Trace</span></p>
						</td>
						<td class="No-Table-Style">
							<p>This provides the most detailed information. Use this for the most low-level <span class="No-Break">debug information.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> <span class="No-Break">Debug</span></p>
						</td>
						<td class="No-Table-Style">
							<p>This provides coarse-grained debugging information. It is less detailed <span class="No-Break">than Trace.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> <span class="No-Break">Info</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Informational messages that highlight the general flow of the application come with <span class="No-Break">this level.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> <span class="No-Break">Warn</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Potentially harmful situations of interest to end users or system managers that indicate potential problems are flagged at <span class="No-Break">this level.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> <span class="No-Break">Error</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Error events of considerable importance that will prevent normal program execution but might still allow the application to continue running are <span class="No-Break">flagged here.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> <span class="No-Break">Fatal</span></p>
						</td>
						<td class="No-Table-Style">
							<p>This level focuses on very severe error events that will presumably lead the application <span class="No-Break">to abort.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p> <span class="No-Break">Off</span></p>
						</td>
						<td class="No-Table-Style">
							<p>This involves no logging <span class="No-Break">at all.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.2: Log levels in NLog</p>
			<p>As you can see, the<a id="_idIndexMarker758"/> levels are almost the same; they are just named differently. That makes it harder to remember when you switch from one framework to another, but we can do nothing about that. We have to memorize the terms, <span class="No-Break">I guess.</span></p>
			<h3>NLog targets</h3>
			<p>You <a id="_idIndexMarker759"/>control NLog through the configuration file. That is one of the two main principles that drove the development of NLog (the other being that NLog should be <span class="No-Break">highly performant).</span></p>
			<p>In the sample we have worked on, we wrote the logs in both the Console and a file. In the <strong class="source-inline">settings</strong> file, we have defined different targets where NLog writes the logs. Currently, more than 100 different targets are available, some of which are part of the core package and some of which require a <span class="No-Break">NuGet package.</span></p>
			<p>Let’s have a look at another target. We currently use <strong class="source-inline">Console</strong>, but we can replace that with <strong class="source-inline">ColoredConsole</strong>. That is part of the default package, so we do not have to add a <span class="No-Break">NuGet package.</span></p>
			<p>In the <a id="_idIndexMarker760"/>configuration, add a new target to the <strong class="source-inline">targets</strong> section. It looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
&lt;target
  name="logcolorconsole"
  xsi:type="ColoredConsole"
  header="Logfile for run ${longdate)"
  footer="-----------"
  layout="${date:format=HH\:mm\:ss} ${logger}
${uppercase:${level}} ${message}" /&gt;</pre>			<p>This segment tells NLog that we want to use a new target of the <strong class="source-inline">ColoredConsole</strong> type. We can call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">logcolorconsole</strong></span><span class="No-Break">.</span></p>
			<p>We also specified a header that should display the <strong class="source-inline">Logfile for run</strong> text and then the current data. I also added a footer that consists of a simple line. The layout section is the same as the one we used with the file: we display the time (in the <strong class="source-inline">HH:mm:ss</strong> format), the name of the logger (which is <strong class="source-inline">Program</strong> or <strong class="source-inline">OtherLogger</strong>, depending on the line we are on), the level of the log in uppercase, and finally the <span class="No-Break">message itself.</span></p>
			<p>You can vary this as much as you want and add or remove elements at will. You can also set up rules on what to display depending on various factors, such as <span class="No-Break">the level.</span></p>
			<p>We must also add it to the rules. Just for simplicity, I removed the file and console as a target and used the new <span class="No-Break"><strong class="source-inline">logcolorconsole</strong></span><span class="No-Break"> one:</span></p>
			<pre class="source-code">
&lt;rules&gt;
  &lt;logger name="*"
          minlevel="Info"
          writeTo="logcolorconsole" /&gt;
&lt;/rules&gt;</pre>			<p>If you run the sample after making these changes, you will see a set of colorful lines. Yes, you can change or alter the colors based on the level. The options are <span class="No-Break">almost endless.</span></p>
			<p>As I said, there<a id="_idIndexMarker761"/> are over 100 targets available. Let me give you a shortened list of some of the more commonly <span class="No-Break">used targets:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table003-5">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Target name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">NuGet package</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">File Target</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Logs data to files on a disk with options for filenames, directories, rotations, <span class="No-Break">and archiving</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">NLog</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Console Target</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Sends log messages to the standard output or error streams; useful <span class="No-Break">during development</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">NLog</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>ColoredConsole <span class="No-Break">Target</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Sends log messages to the Console with color coding based on <span class="No-Break">log level</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">NLog</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Database Target</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Logs messages to a database using parameterized <span class="No-Break">SQL commands</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">NLog</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">EventLog Target</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Writes log entries to the Windows Event Log; ideal for <span class="No-Break">Windows apps</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">NLog.WindowsEventLog</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Mail Target</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Sends log entries as email messages; suitable for alerts <span class="No-Break">and monitoring</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">NLog.MailKit</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Network Targets</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Includes WebService, TCP, and UDP targets for logging <span class="No-Break">over networks</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">NLog</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Trace Target</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Sends log messages to .NET trace listeners, integrating with other <span class="No-Break">diagnostics tools</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">NLog</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Memory Target</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Logs messages to an in-memory list of strings, mainly for <span class="No-Break">debugging purposes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">NLog</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Null Target</span></p>
						</td>
						<td class="No-Table-Style">
							<p>A target that does nothing; useful for disabling logging in <span class="No-Break">certain scenarios</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">NLog</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.3: Targets in NLog</p>
			<p>I recommend you <a id="_idIndexMarker762"/>look at the documentation at <a href="https://nlog-project.org/config/">https://nlog-project.org/config/</a> to see the different options and the settings per option. It is <span class="No-Break">pretty extensive!</span></p>
			<h3>Rules in NLog</h3>
			<p>In addition to the <a id="_idIndexMarker763"/>targets, you can set rules in NLog. The rules define which target is used under <span class="No-Break">which circumstances.</span></p>
			<p>In our example, we used one rule: all logs should go to the Console and <strong class="source-inline">file</strong> targets or the <strong class="source-inline">ColoredConsole</strong> target, which we <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">logcolorconsole</strong></span><span class="No-Break">.</span></p>
			<p>Let’s change that a bit; I want to make it more intelligent. Change the rules section so that it looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
&lt;rules&gt;
  &lt;logger name="*"
          minlevel="Trace"
          writeTo="logfile" /&gt;
  &lt;logger name="Program"
          minLevel="Warn"
          writeTo="logcolorconsole" /&gt;
  &lt;logger name="OtherLogger"
          minLevel="Info"
          writeTo="logconsole" /&gt;
&lt;/rules&gt;</pre>			<p>We now have<a id="_idIndexMarker764"/> <span class="No-Break">three rules:</span></p>
			<ul>
				<li>The first is the catch-all. By writing <strong class="source-inline">name="*"</strong>, we tell the system to take all loggers. The minimum level we want is Trace, the lowest level, so we want all messages (yes, you can also define a maximum level). We define the target as a <strong class="bold">logfile</strong>. This target is the one that writes to <span class="No-Break">a file.</span></li>
				<li>The second rule only applies to the logger that has the name <strong class="source-inline">Program</strong>. Thus, all loggers are created by calling <strong class="source-inline">GetCurrentClassLogger()</strong> using our <strong class="source-inline">Main</strong> method. We raise the minimum level to Warn; we are not interested in anything below that. The file catches this. We want to see them in nice colors, so we specify the <strong class="source-inline">writeTo</strong> parameter <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">logcolorconsole</strong></span><span class="No-Break">.</span></li>
				<li>All messages sent to the logger named <strong class="source-inline">OtherLogger</strong> are the subject of the third rule. We want all messages of the Info level or above, and we want to see them processed by our colorless, default <span class="No-Break">Console logger.</span></li>
			</ul>
			<p>Run the sample. See how messages on different loggers get sent to the <span class="No-Break">right place.</span></p>
			<h3>Asynchronous logging</h3>
			<p>Remember <a id="_idIndexMarker765"/>when I said that anything that takes longer than a few clock cycles should be done asynchronously? Well, NLog allows you to log to databases or network connections. They definitely have long-running operations. Unfortunately, there is no such method as <strong class="source-inline">LogAsync()</strong> in NLog. However, there is another solution <span class="No-Break">to this.</span></p>
			<p>There is a target called <strong class="source-inline">AsyncWrapper</strong>. As the name suggests, this is a wrapper around other targets that make them work asynchronously. All you have to do is add that to the configuration <span class="No-Break">like this:</span></p>
			<pre class="source-code">
&lt;target
  name="asyncWrapper"
  xsi:type="AsyncWrapper"&gt;
  &lt;target
    name="logfile"
    xsi:type="File"
    fileName="${basedir}/logs/logfile.txt"
    layout="${date:format=HH\:mm\:ss} ${logger} ${uppercase:${level}} ${message}" /&gt;
  &lt;/target&gt;</pre>			<p>Although the <a id="_idIndexMarker766"/>methods are still synchronous, NLog places all the log messages in a queue on a separate thread and writes them to the target on that thread instead of on the calling thread. You can set several variables to determine how long the delay must be, how long the queue can become, and so on. However, we have eliminated our delay when writing to a file, a database, or a network connection. I strongly suggest that you use that wrapper for anything <span class="No-Break">besides Console!</span></p>
			<h3>Two useful but often neglected additional settings</h3>
			<p>There <a id="_idIndexMarker767"/>are two more things I want to show you in the <span class="No-Break">configuration file.</span></p>
			<p>The root element, NLog, can have a property named <strong class="source-inline">autoReload=true</strong>. If you set that, you can have NLog pick up changes in the log file while the application runs. We saw a similar option with the Microsoft logger; it is good to know that NLog also <span class="No-Break">supports this.</span></p>
			<p>With all the available rules, targets, variables, and other things you can set in the configuration file, you might wonder what to do if things <span class="No-Break">go wrong.</span></p>
			<p>The people behind NLog thought of that as well. You can turn on logging for NLog itself. All you have to do is change the root entry to look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
&lt;nlog xmlns=http://www.nlog-project.org/schemas/NLog.xsd
      xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance
      autoReload="true"
      internalLogFile="${basedir}/logs/internallog.txt"
      internalLogLevel="Trace"
      &gt;</pre>			<p>I have added the <strong class="source-inline">internalLogFile</strong> and <strong class="source-inline">internalLogLevel</strong> properties. Adding these properties results in NLog logging its internal logs to the given file. Doing this might help<a id="_idIndexMarker768"/> you find issues in your logging. It is all becoming a bit metaphysical, but you can log better by logging the workings of the log. Give it <span class="No-Break">a try!</span></p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor228"/>Serilog</h2>
			<p>There is one<a id="_idIndexMarker769"/> more framework I want to share with you. Serilog is a<a id="_idIndexMarker770"/> popular logging framework that first saw the light of day <span class="No-Break">in 2013.</span></p>
			<p>The idea behind Serilog is that it allows for structured logging. So far, all the logs we have seen have all just been one-liners with some text. Serilog is built around the idea that structure can <span class="No-Break">bring clarity.</span></p>
			<p>Let me show you what I mean by that. Let’s build <span class="No-Break">a sample.</span></p>
			<p>Although Serilog can (and should) be controlled by the settings in a configuration file, I will control this final example exclusively through code. I want to show you how to do that so you have at least seen <span class="No-Break">it once.</span></p>
			<p>However, again, since you want to change logging depending on the state of the system, you are better off having a configuration file that you can change <span class="No-Break">without recompiling.</span></p>
			<p>Of course, we will begin by creating a new Console application and adding some <span class="No-Break">NuGet packages.</span></p>
			<h3>Standard logging with Serilog</h3>
			<p>NLog has<a id="_idIndexMarker771"/> targets, and Serilog <a id="_idIndexMarker772"/>has <strong class="bold">sinks</strong>. You have to install all the sinks you need from different packages. I will only use Console and File in my sample, but there are others: SQL Server, HTTP, AWS, and <span class="No-Break">so on.</span></p>
			<p>You need to install the <strong class="source-inline">Serilog</strong>, <strong class="source-inline">Serilog.Sinks.Console</strong> and <strong class="source-inline">Serilog.Sinks.File</strong> <span class="No-Break">NuGet packages.</span></p>
			<p>Let’s write <span class="No-Break">the code:</span></p>
			<pre class="source-code">
using Serilog;
var logger = new LoggerConfiguration()
    .MinimumLevel.Debug()
    .WriteTo.Console()
    .WriteTo.File(path:
        "logs\\log.txt",
        rollingInterval: RollingInterval.Day)
    .CreateLogger();
try
{
    logger.Verbose("This is verbose");
    logger.Debug("This is debug");
    logger.Information("This is information");
    logger.Warning("This is warning");
    logger.Error("This is error");
    logger.Fatal("This is fatal");
}
finally
{
    await Log.CloseAndFlushAsync();
}</pre>			<p>This code should <a id="_idIndexMarker773"/>look familiar. We create a configuration, this time all in code; we create a logger and log our messages. We end with a <strong class="source-inline">CloseAndFlushAsync()</strong> to ensure nothing is left in <span class="No-Break">some buffer.</span></p>
			<p>There is nothing special about this code. OK, the new thing here is the <strong class="source-inline">RollingInterval</strong>. This property determines when the system should create a new file. You can set that to anything from a minute to a year. If you do not want to create a new file at any point, you can also set it to <strong class="source-inline">Infinite</strong>. That way, the system creates the file once and never again (unless you delete it, <span class="No-Break">of course).</span></p>
			<p>Apart from<a id="_idIndexMarker774"/> that, there is nothing remarkable about Serilog. However, let’s change that. Change the parameters in the call to <strong class="source-inline">WriteTo.File()</strong> so that it looks like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
var logger = new LoggerConfiguration()
    .MinimumLevel.Debug()
    .WriteTo.Console(new JsonFormatter())
    .WriteTo.File(
        new JsonFormatter(),
        "logs\\log.txt",
        rollingInterval: RollingInterval.Day)
    .CreateLogger();</pre>			<p>In this code sample, I added a <strong class="source-inline">JsonFormatter</strong> to the output of both the console and the file. When you add a formatter, you tell Serilog to output the logs a certain way. The <strong class="source-inline">JsonFormatter</strong> formatter forces the output to be in (well, you guessed it) the <span class="No-Break">JSON format.</span></p>
			<p>To truly use the structure log, we must change how we log the messages. Let’s add one line to the part where we write <span class="No-Break">the logs:</span></p>
			<pre class="source-code">
logger.Information(
    "The user with userId {userId} logged in at {loggedInTime}",
    42,
    DateTime.UtcNow.TimeOfDay);</pre>			<p>As you can see, we log a line of text, but instead of building that string beforehand, we do it in the message. In this case, we give it named parameters, <strong class="source-inline">userId,</strong> and <strong class="source-inline">loggedInTime</strong>, and<a id="_idIndexMarker775"/> then pass in the values that we want <span class="No-Break">to display.</span></p>
			<p>If you run it now, that last line, after formatting, results <span class="No-Break">in this:</span></p>
			<pre class="source-code">
{
    "Timestamp": "2024-04-20T11:47:31.5139218+02:00",
    "Level": "Information",
    "MessageTemplate": "The user with userId {userId} logged in at {loggedInTime}",
    "Properties": {
        "userId": 42,
        "loggedInTime": "09:47:31.5125828"
    }
}</pre>			<p>As you can see, a lot more information is suddenly available. The structure of the logline is such that if we store it in a system somewhere, we can easily query the lines. Later in this chapter, I will show you how this <span class="No-Break">is done.</span></p>
			<p>So, Serilog is comparable to the other two frameworks until you use one of the many formatters. The ability to store the log information to easily query it makes it a very powerful tool to have in <span class="No-Break">your toolbelt!</span></p>
			<h3>Log levels in Serilog logging</h3>
			<p>As you will <a id="_idIndexMarker776"/>probably expect by now, Serilog also has levels. Those levels should look very familiar to you. This table shows the levels that Serilog offers and what they are meant <span class="No-Break">to do.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table004-3">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Serilog level</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Verbose</span></p>
						</td>
						<td class="No-Table-Style">
							<p>This contains the most detailed information. These messages may contain sensitive application data and are therefore not recommended for production <span class="No-Break">unless hidden.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Debug</span></p>
						</td>
						<td class="No-Table-Style">
							<p>This level contains information that is useful in development <span class="No-Break">and debugging.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Information</span></p>
						</td>
						<td class="No-Table-Style">
							<p>This level contains informational messages that highlight the general flow of the application. It is useful for general <span class="No-Break">application insights.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Warning</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Indications of possible issues or service and functionality degradation are included at <span class="No-Break">this level.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Error</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Errors and exceptions that cannot be handled or are unexpected are <span class="No-Break">included here.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Fatal</span></p>
						</td>
						<td class="No-Table-Style">
							<p>This level focuses on critical errors causing complete failure of the application and requiring <span class="No-Break">immediate attention.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Silent</span></p>
						</td>
						<td class="No-Table-Style">
							<p>This is the level for no logging at all (Serilog does not explicitly define a Silent level, but logging can effectively be <span class="No-Break">turned off).</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.4: Serilog log levels</p>
			<p>Again, there are <a id="_idIndexMarker777"/>no surprises here. As with the other frameworks, you can use this however you want: no one can stop you from adding lots of debug information to the Error level. It is just not a very <span class="No-Break">good idea.</span></p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor229"/>Comparing the logging frameworks</h2>
			<p>After <a id="_idIndexMarker778"/>having seen all of these frameworks, you might wonder: which one should I pick? The answer is simple: choose whichever one you feel most <span class="No-Break">comfortable with.</span></p>
			<p>All frameworks have pros and cons; none are bad or extremely good. They do have different use cases and areas of attention. The following table highlights some <span class="No-Break">of those:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table005-2">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Feature</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">.</strong><span class="No-Break"><strong class="bold">NET Logger</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">NLog</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Serilog</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Overview</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Reliable and integrates seamlessly <span class="No-Break">with .NET</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Rich in features, great for a wide range <span class="No-Break">of applications</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Excels in structured logging, making data meaningful <span class="No-Break">and searchable</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Integration</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Deeply integrated with .NET Core, supports dependency injection and <span class="No-Break">configuration settings</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Flexible, can be used in various .NET applications, supports <span class="No-Break">multiple targets</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Great with .NET applications, especially for structured data stores such as Seq <span class="No-Break">or Elasticsearch</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Pros</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Minimal setup</span></p>
							<p>Supports <span class="No-Break">structured logging</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Advanced log routing and filtering; logs to multiple <span class="No-Break">targets simultaneously</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Exceptional at structured logging; supports enrichers for <span class="No-Break">additional context</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Cons</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Less feature-rich without <span class="No-Break">third-party providers</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Configuration can <span class="No-Break">get complex</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Might be overkill for simple needs; best features require compatible <span class="No-Break">logging targets</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Best for</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Projects that need straightforward logging with <span class="No-Break">minimal setup</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Applications requiring detailed control over logging, or when logging into <span class="No-Break">multiple places</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Projects where structured logging and data querying <span class="No-Break">are priorities</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.5: Comparison between the logging frameworks</p>
			<p>You just have to<a id="_idIndexMarker779"/> look at your own needs and determine your scenario and way of working best. Pick that tool. My advice is to give the others a go. You might find a new favorite <span class="No-Break">logging framework!</span></p>
			<p>So, we have now looked at logging. We have seen the most commonly used frameworks and how to use them. We have looked at default Microsoft logging; we have had an in-depth look at NLog and its robust collection of targets and rules. Finally, we have looked at Serilog’s structured <span class="No-Break">logging approach.</span></p>
			<p>You should be<a id="_idIndexMarker780"/> able to use logging from now on. However, logging is part of your application. What if you do not get all the information you need from logging? That is where monitoring comes into play. Let’s have a look at <span class="No-Break">that next!</span></p>
			<p class="callout-heading">A word of caution</p>
			<p class="callout">Logging is very useful. In fact, I would suggest that you cannot do serious development on systems without a UI if you do not have extensive logging. However, you must be careful: it is too easy to leak sensitive information about your system. Consider things such as connection strings, credentials, and other sensitive information. Also, you might sometimes accidentally disclose information about the inner workings of your system or even about the organization that this system runs. Be careful. Do not assume that people will not try to move the log level to Trace to see what is happening. Log as much as possible, but be mindful of <span class="No-Break">the dangers!</span></p>
			<p>Logging is one of the best things you can do to solve development and production issues. However, there is more that we can do. We need insights into these logs, but we must also monitor things such as memory usage, CPU usage, and much more. Let’s talk about <span class="No-Break">monitoring next!</span></p>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor230"/>Monitoring your applications</h1>
			<p>We need to keep<a id="_idIndexMarker781"/> an eye on things as our software runs. During development, we can turn on extensive logging to the console or to a file, which helps us track errors and issues. However, once our code runs on the final machine, it needs to run, and it might be a bit harder to look at all those <span class="No-Break">log files.</span></p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor231"/>Monitoring with Seq</h1>
			<p>Monitoring<a id="_idIndexMarker782"/> the system’s state is essential to keep things healthy. One of the great tools we have available to do this is Seq. Seq and Serilog are a match made <span class="No-Break">in heaven!</span></p>
			<p>One of the reasons why Serilog is getting so much attention these days is because of its ability to write<a id="_idIndexMarker783"/> logs in a structured manner. We looked at this in the previous section but did not dive into what we could do. It is time to <span class="No-Break">change that.</span></p>
			<p>Since the logs coming <a id="_idIndexMarker784"/>from Serilog are formatted in a particular way, we can also store them in a specific way. One of the tools that allow us to do so is Seq. Seq is a tool by the company Datalust. You can get a free personal license from them to play around with your logs. You can choose to install Seq on your machine, or you can choose to download a Docker image that contains everything you need. I prefer the latter, but it doesn’t matter which option you choose. The Datalust website clearly explains how to get the bits. You can find the documentation at <a href="https://docs.datalust.co/docs/an-overview-of-seq">https://docs.datalust.co/docs/an-overview-of-seq</a>. In the <em class="italic">Technical requirements</em> section of this chapter, I have shown you the Docker command that you will need to execute to get a local version of <span class="No-Break">Seq running.</span></p>
			<p>Once you <a id="_idIndexMarker785"/>have done that, you can actually start to use Seq. We need to change our code a little bit. In addition to the packages that we installed earlier to enable logging to <strong class="source-inline">Console</strong> and <strong class="source-inline">File</strong>, we will also need a new <span class="No-Break">package: </span><span class="No-Break"><strong class="source-inline">Serilog.Sinks.Seq</strong></span><span class="No-Break">.</span></p>
			<p>Once you have installed that, we must change the setup of the log a bit. That looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
var logger = new LoggerConfiguration()
    .MinimumLevel.Verbose()
    .WriteTo.Console(new JsonFormatter())
    .WriteTo.File(
        new JsonFormatter(),
        "logs\\log.json",
        rollingInterval: RollingInterval.Day)
    .WriteTo.Seq("http://localhost:5341")
    .CreateLogger();</pre>			<p>As you can see, we added a new <strong class="source-inline">Sink</strong> to our configuration, and this time, we are writing to Seq. I use the default port <strong class="source-inline">5341</strong>, since this is the port that Seq <span class="No-Break">listens to.</span></p>
			<p>If I run the application and go to the Seq dashboard on my machine, I will also get to see the logs there. That looks <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer038">
					<img alt="Figure 10.3: Serilog captured by Seq" src="image/B20924_11_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3: Serilog captured by Seq</p>
			<p>You can<a id="_idIndexMarker786"/> clearly see all log messages. They are nicely colored. I<a id="_idIndexMarker787"/> have also opened the last message, in which we added some structural information. Seq captures this information and shows you exactly what is <span class="No-Break">going on.</span></p>
			<p>You can also query over the logs by entering a SQL-like statement in the top edit box. That looks <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer039">
					<img alt="Figure 10.﻿4: Seq dashboard with a filter for user Id." src="image/B20924_11_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4: Seq dashboard with a filter for user Id.</p>
			<p>I added the <strong class="source-inline">userId = 42</strong> query in the edit box. This results in Seq only showing all messages about the user whose <strong class="source-inline">userId</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">42</strong></span><span class="No-Break">.</span></p>
			<p>The<a id="_idIndexMarker788"/> query language is extensive and you can write complex queries. This<a id="_idIndexMarker789"/> means that you can always find what you need even if you log <span class="No-Break">many messages.</span></p>
			<p>Seq is extremely powerful and yet easy to set up. I highly recommend checking <span class="No-Break">it out!</span></p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor232"/>Performance counters</h1>
			<p>Windows gives <a id="_idIndexMarker790"/>us lots of tools to monitor our systems, such as <strong class="source-inline">EventViewer</strong>. We can use those tools in our own systems as well. For instance, there are a lot of performance counters available that you can access both inside and outside of <span class="No-Break">your code.</span></p>
			<p>Let’s look at how to get that in our <span class="No-Break">code first.</span></p>
			<p>I started a new Console application, added the <strong class="source-inline">System.Diagnostic</strong> NuGet package, and then wrote the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
using System.Diagnostics;
using ExtensionLibrary;
#pragma warning disable CA1416
var counter = 0;
var cpuCounter = new PerformanceCounter("Processor", "% Processor Time", "_Total");
while (true)
{
    if (counter++ == 10)
        // Start a method on a background thread
        Task.Run(() =&gt;
        {
            Parallel.For(0, Environment.ProcessorCount, j =&gt;
            {
                for (var i = 0; i &lt; 100000000; i++)
                {
                    var result = Math.Exp(Math.Sqrt(Math.PI));
                }
            });
            counter = 0;
        });
    var cpuUsage = cpuCounter.NextValue();
    var message = $"CPU Usage: {cpuUsage}%";
    var color = cpuUsage &gt; 10 ? ConsoleColor.Red : ConsoleColor.Green;
    message.Dump(color);
    await Task.Delay(200);
}</pre>			<p>Near <a id="_idIndexMarker791"/>the top of the file, I have created an instance of the <strong class="source-inline">PerformanceCounter </strong>class. This class gives us access to all the performance counters that we have mentioned, so we can also use them in our code. We need to specify the category and the item in that category we want to monitor. In my case, I went for <strong class="source-inline">Processor</strong> and <strong class="source-inline">% Processor Time</strong>, which are indicators of the load on <span class="No-Break">the CPUs</span></p>
			<p>Then, I start a never-ending loop in which I increase a counter. As soon as that counter reaches <strong class="source-inline">10</strong>, I do some silly calculations on all the CPUs available on my machine. These calculations do not do anything useful besides keeping the CPUs busy. All this happens on a background thread, so the main loop keeps displaying how busy the <span class="No-Break">system is.</span></p>
			<p>For readability, I will also change the color of the output if the CPU percentage is over 10%. You might have to change this threshold if you have a slower or faster machine than <span class="No-Break">I do.</span></p>
			<p>If you<a id="_idIndexMarker792"/> run this, you will be able to see how busy the system is. You should see a nice green output, but the system will get busier every few seconds, as shown by the <span class="No-Break">red output.</span></p>
			<p>You can measure many items, tracking what the computer is doing. Suppose that you want to find out what you can monitor. In that case, you only need to open the Performance Monitor application on your Windows machine (search for <strong class="source-inline">perfmon.exe</strong>). You can add counters to the main screen; the dialog that shows them is a good source of information. Make sure that you check the <strong class="bold">Show description</strong> box at the bottom of the screen to see what all the counters do. To give you an idea, this is what that screen looks like when you search for the counter that we <span class="No-Break">just used:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer040">
					<img alt="Figure 10.5: Perfmon.exe example with % Processor Time" src="image/B20924_11_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5: Perfmon.exe example with % Processor Time</p>
			<p>I suggest <a id="_idIndexMarker793"/>that you browse through that list and see what you can find that might be useful. There are even categories specifically for the .NET CLR, so you can see how often the garbage collector runs or how frequently an exception has been raised <span class="No-Break">per second!</span></p>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor233"/>Prometheus</h1>
			<p>Keeping an<a id="_idIndexMarker794"/> eye on your system’s vital metrics can help you pinpoint issues. If your system suddenly starts using a lot more memory, or if at certain times the CPU usage spikes, you might have a problem that needs fixing. Thus, it is important to track those metrics. As we just learned, we can use the <strong class="source-inline">PerformanceCounter</strong> class to get the necessary information and do something with it, such as writing it to Seq <span class="No-Break">with Serilog.</span></p>
			<p>However, that is <a id="_idIndexMarker795"/>not the only way. There is nothing wrong with the combination of Serilog and Seq. However, their primary goal is to log events. You can use a tool such as Prometheus to track trends, such as CPU usage or <span class="No-Break">memory pressure.</span></p>
			<p>Prometheus <a id="_idIndexMarker796"/>is similar to Serilog and Seq: they allow you to write something in your code to an external system that you can look at in your web browser. However, Prometheus is primarily used for ad monitoring and time series databases. It is designed to record real-time metrics in a scalable fashion. It excels at monitoring the state of your applications <span class="No-Break">and infrastructure.</span></p>
			<p>Let’s have a look at how all of <span class="No-Break">that works.</span></p>
			<p>The application that you want to monitor needs a NuGet package. So, let’s install that. It is called <strong class="source-inline">prometheus-net</strong>. However, that is only part of the equation. As I said, you can use your browser to see the events that you are interested in, so we will also need to install <span class="No-Break">the server.</span></p>
			<p>You can download Prometheus<a id="_idIndexMarker797"/> from <a href="https://prometheus.io">https://prometheus.io</a> and run it on your machine. However, if you are just trying to figure out how it works and see whether this is the tool for you, I recommend downloading the Docker image and <span class="No-Break">running it.</span></p>
			<p>Prometheus needs a configuration file. This is a simple YAML file telling it how to behave. We need to link to that configuration file when we start the Docker image, so let’s write that <span class="No-Break">file first.</span></p>
			<p>Open your favorite code editor and create a file called <strong class="source-inline">prometheus.yml</strong> somewhere. I have placed mine in a folder called <strong class="source-inline">c:\data</strong>. The preceding Docker command will ensure that it gets read and used inside the running container. This is what the file <span class="No-Break">looks like:</span></p>
			<pre class="source-code">
global:
  scrape_interval: 5s
  evaluation_interval: 5s
scrape_configs:
  - job_name: 'c# worker'
    static_configs:
      - targets: ['host.docker.internal:1234']</pre>			<p>Let’s see what is going <span class="No-Break">on here.</span></p>
			<p>The first line defines the <strong class="source-inline">scrape_interval</strong>. This is the interval that determines how often Prometheus looks at the metrics. Since metrics are usually interesting over a longer time, you do not need the system to measure them continuously. In our example, I have set it to do a scrape every <span class="No-Break">five seconds.</span></p>
			<p>The following line <a id="_idIndexMarker798"/>defines the <strong class="source-inline">evaluation_interval</strong>. Prometheus can have rules and alerts that fire when a particular metric goes over or under a specific metric. This interval determines how often it checks to see whether the alert needs to be fired. Again, I have set it to <span class="No-Break">five seconds.</span></p>
			<p>These <a id="_idIndexMarker799"/>two settings are global; they apply to all the metrics for all the applications that we monitor. We can later change these for each specific metric or application if we <span class="No-Break">want to.</span></p>
			<p>The following section, called <strong class="source-inline">scrape_configs</strong>, defines the specific metrics that we want to collect. In my case, I have given it a name: <strong class="source-inline">C# worker</strong>. Then, we will tell it which server supplies the metrics. Again, in my case, it is <strong class="source-inline">host.docker.internal:1234</strong>. This means that the server runs on that URL with that <span class="No-Break">specific port.</span></p>
			<p>“Wait a minute,” you might say, “I am not running a server; I am running a Console application!” Do not worry; Prometheus takes care <span class="No-Break">of this.</span></p>
			<p>The server application of Prometheus calls into the systems it needs to monitor over an HTTP connection. Thus, the clients it monitors need a web server that supplies that information. We do not have to take care of that; Prometheus does that <span class="No-Break">for us.</span></p>
			<p class="callout-heading">IP addresses in Docker</p>
			<p class="callout">You might wonder why I use the <strong class="source-inline">host.docker.internal</strong> hostname as the server address. After all, both Docker and our Console application run on the same system. They both are available on <strong class="source-inline">localhost</strong>, right? That is incorrect; Docker containers all run in their own network (I am simplifying things here, but the idea still works). That means that if the Prometheus server would listen to anything on <strong class="source-inline">localhost:1234</strong>, it would only listen to the virtual network in the image. We need to supply the actual IP address of the machine that runs our application. However, if you do not want to hardcode that, use the <strong class="source-inline">host.docker.internal</strong> DNS name. The DNS system in Docker knows this name. It resolves the actual IP address of the host machine so that the containers in Docker can find the <span class="No-Break">correct machine.</span></p>
			<p>Let’s have a<a id="_idIndexMarker800"/> look at our code. I have started a new<a id="_idIndexMarker801"/> Console application and added the NuGet package. The code itself looks like this. I start by setting up <span class="No-Break">our metrics:</span></p>
			<pre class="source-code">
Gauge memoryGauge =
    Metrics.CreateGauge(
        "app_memory_usage_bytes",
        "Memory Usage of the application in bytes.");
var server =
    new MetricServer(
        hostname:"127.0.0.1",
        port: 1234);
server.Start();</pre>			<p>First, I create a <strong class="source-inline">Gauge</strong>. This is like a thermometer that you use to measure metrics. In this case, I will make one that measures <strong class="source-inline">app_memory_usage_bytes</strong>, one of the many metrics that we <span class="No-Break">can use.</span></p>
			<p>Then, we will create an instance of a <strong class="source-inline">MetricServer</strong>. You must specify the host from which the app runs and the port from which it broadcasts the metrics. Remember when I said that Prometheus listens to servers to collect its metrics? Well, this is where we set up <span class="No-Break">that server.</span></p>
			<p class="callout-heading">IP addresses and Docker, again</p>
			<p class="callout">I have used the <strong class="source-inline">127.0.0.1</strong> hostname here. If I used <strong class="source-inline">localhost</strong>, I would get errors for some reason. If I used the machine’s actual hostname, I would get errors. Either the app does not start up, or the Prometheus server can’t find my app. However, if I specify the IP address here (my actual IP address also works), the system works just fine. So, if you have issues with getting things to work, just try to use <span class="No-Break"><strong class="source-inline">127.0.0.1</strong></span><span class="No-Break"> here.</span></p>
			<p>Then, I will start <span class="No-Break">the server.</span></p>
			<p>Now, you are <a id="_idIndexMarker802"/>ready to send the metrics to the server. I have created a simple method that <span class="No-Break">does this:</span></p>
			<pre class="source-code">
static void UpdateMemoryGauge(Gauge memoryGauge)
{
    var memoryUsage = GC.GetTotalMemory(forceFullCollection: false);
    memoryGauge.Set(memoryUsage);
}</pre>			<p>That is <a id="_idIndexMarker803"/>basically all that you have <span class="No-Break">to do.</span></p>
			<p>However, let’s see what happens when we actually do something. In the main body of my code, I have a simple loop that adds a block of memory every five seconds and then clears them all after 20 seconds, after which the whole thing starts all <span class="No-Break">over again.</span></p>
			<p>The code looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
var counter = 0;
List&lt;byte[]&gt; buffer = [];
Random rnd = new Random();
while (true)
{
    if (counter++ % 5 == 0)
        AllocateMemoryBlock(rnd, buffer);
    if (counter == 20)
    {
        ClearMemory(buffer);
        counter = 0;
    }
    UpdateMemoryGauge(memoryGauge);
    await Task.Delay(1000);
}</pre>			<p>I have defined<a id="_idIndexMarker804"/> some variables, such as <strong class="source-inline">counter</strong>, <strong class="source-inline">buffer,</strong> and <strong class="source-inline">rnd</strong>. In the loop, I will either add memory to the system, clear the memory, or do nothing. At the end, I will make sure to call the <strong class="source-inline">UpdateMemoryGauge()</strong> method. Then, the app sleeps for <span class="No-Break">one second.</span></p>
			<p>The <strong class="source-inline">AllocateMemoryBlock()</strong> looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
static void AllocateMemoryBlock(Random random, List&lt;byte[]&gt; bytesList)
{
    var memoryToAllocate =
        random.Next(50000000, 200000000);
    var dummyBlock =
        new byte[memoryToAllocate];
    bytesList.Add(dummyBlock);
    "Memory block added".Dump(ConsoleColor.Blue);
}</pre>			<p>Again, this is <a id="_idIndexMarker805"/>silly code; I hope you never write this in actual production code. However, it works here; we want to measure the memory usage of our app, so we might as well allocate lots of it. I have used a randomizer to make the system a bit less predictable because I like the look of the charts a bit better <span class="No-Break">that way.</span></p>
			<p>The <strong class="source-inline">ClearMemory()</strong> is <span class="No-Break">even simpler:</span></p>
			<pre class="source-code">
static void ClearMemory(List&lt;byte[]&gt; list)
{
    list.Clear();
    GC.Collect();
    "Memory block cleared".Dump(ConsoleColor.Green);
}</pre>			<p>We then <a id="_idIndexMarker806"/>clear the list and clean up the memory by calling <strong class="source-inline">GC.Collect()</strong>, and we will log that to <span class="No-Break">the screen.</span></p>
			<p>That is it! If you run this for a while and open your browser to the default Prometheus URL of <a href="http://localhost:9090">http://localhost:9090</a>, you can search for the <strong class="source-inline">app_memory_usage_bytes</strong> metric. If you<a id="_idIndexMarker807"/> run the app for a while, you will get a nice chart <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer041">
					<img alt="Figure 10.6: Prometheus sampling our memory usage" src="image/B20924_11_6.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6: Prometheus sampling our memory usage</p>
			<p>The chart shows <a id="_idIndexMarker808"/>our app in action, depicting how much memory it uses. You can probably also see why I used a randomizer; the chart looks slightly more interesting. However, that is just my <span class="No-Break">personal preference.</span></p>
			<p>You can<a id="_idIndexMarker809"/> search for metrics in the top part of the screen, or you can search for jobs. If you specify the <strong class="source-inline">{job = "c# worker"}</strong> search string, you will get over 30 metrics for your app. You can click on each of them to add them to the chart. There is a ton of <span class="No-Break">information there!</span></p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor234"/>Other platforms for monitoring</h2>
			<p>We have looked at <a id="_idIndexMarker810"/>Seq to collect our logs. We looked at performance counters and we looked at Prometheus. These are all great tools and I believe they are the ones that fit us as system programmers the best. However, there are many more systems out there that might work better for you and your specific use case. I will not describe them all in detail; that would justify a book in itself. However, here is an overview of some of the most used ones. If you are interested in them, I suggest that you do research and find out how they can <span class="No-Break">help you!</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table006-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Tool</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Use case</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Application <span class="No-Break">Insights</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Part of Azure Monitor, it provides APM features and <span class="No-Break">telemetry data</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Cloud-based <span class="No-Break">monitoring</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">New Relic</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Offers full-stack observability, including <span class="No-Break">application monitoring</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Performance <span class="No-Break">insights</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Dynatrace</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Utilizes AI for automatic monitoring and <span class="No-Break">problem resolution</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Full-stack <span class="No-Break">monitoring</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Datadog</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Provides monitoring, troubleshooting, and security for <span class="No-Break">cloud applications</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Cloud-native <span class="No-Break">environments</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">ELK Stack</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Elasticsearch, Logstash for data processing, Kibana <span class="No-Break">for visualization</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Log Management</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Nagios</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Offers monitoring and alerting services for servers, switches, applications, <span class="No-Break">and services</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Infrastructure <span class="No-Break">monitoring</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">AppDynamics</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Application performance management and IT <span class="No-Break">operations analytics</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Business performance <span class="No-Break">monitoring</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.6: Monitoring tools</p>
			<p>As you can see, there are<a id="_idIndexMarker811"/> many options available, so there is definitely something that you can use that fits your <span class="No-Break">specific needs!</span></p>
			<p>Now that you know how to monitor using Seq, performance counters, and Prometheus, we should look at what we are logging <span class="No-Break">and monitoring.</span></p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor235"/>What you should be monitoring or logging</h1>
			<p>We have seen a lot of ways in which we can log and monitor our systems. However, the question remains: what should you be logging and monitoring? The answer is simple: whatever you need to keep your <span class="No-Break">systems healthy.</span></p>
			<p>OK, that answer is probably the easy way out. Let’s be a bit <span class="No-Break">more specific.</span></p>
			<h3>Basic health monitoring</h3>
			<p>You should <a id="_idIndexMarker812"/>monitor the overall health of your system. Your application does not live in a vacuum, so you should be mindful of the state of the complete system and how you interact with it. These are some of the items you might want to keep an <span class="No-Break">eye on:</span></p>
			<ul>
				<li><strong class="bold">CPU usage</strong>: Track CPU usage to determine whether your application is causing a high <span class="No-Break">CPU load</span></li>
				<li><strong class="bold">Memory usage</strong>: Monitor memory consumption to detect memory leaks or excessive memory usage, which is critical in a managed environment such as .NET, where garbage <span class="No-Break">collection occurs</span></li>
				<li><strong class="bold">Disk I/O</strong>: Monitor read/write operations and disk usage to ensure that disk I/O is not <span class="No-Break">a bottleneck</span></li>
				<li><strong class="bold">Network I/O</strong>: Keep an eye on inbound and outbound network traffic, especially if your system communicates with <span class="No-Break">other services</span></li>
			</ul>
			<p>Of course, there are many other metrics you might be interested in, but these are usually the ones that people care about <span class="No-Break">the most.</span></p>
			<h3>Application-specific metrics</h3>
			<p>Of course, your<a id="_idIndexMarker813"/> system itself is also something that you should look into. These are the metrics I would suggest you add to your <span class="No-Break">monitoring tool:</span></p>
			<ul>
				<li><strong class="bold">Thread counts and thread pool health</strong>: It is helpful to know whether your threads are getting starved or whether the pool <span class="No-Break">is overworked</span></li>
				<li><strong class="bold">Garbage collection metrics</strong>: Track the frequency and duration of garbage collection events to manage memory more effectively and optimize <span class="No-Break">application performance</span></li>
				<li><strong class="bold">Queue lengths</strong>: If your application uses message queues or similar structures, monitoring their lengths can help you understand throughput <span class="No-Break">and backlogs</span></li>
			</ul>
			<p>These metrics are more geared toward your application than the whole system, so I really recommend that you <span class="No-Break">use these.</span></p>
			<h3>Errors and exceptions</h3>
			<p>Exceptions happen. That<a id="_idIndexMarker814"/> is just a fact of life. So, you might want to track those as well. Monitoring tools can capture these exceptions, but I <a id="_idIndexMarker815"/>would not solely rely on them. Always log what is happening in your exception-handling code blocks. You should be thinking about <span class="No-Break">these items:</span></p>
			<ul>
				<li><strong class="bold">Unhandled exceptions</strong>: Log all unhandled exceptions with complete stack traces <span class="No-Break">for debugging</span></li>
				<li><strong class="bold">Handled exceptions</strong>: Sometimes, knowing about handled exceptions can provide insights into potential issues that are not critical yet but may <span class="No-Break">become problematic</span></li>
			</ul>
			<p>Monitoring errors and exceptions is, in my opinion, a given. You really want to know about <span class="No-Break">these events!</span></p>
			<h4>Application logs</h4>
			<p>Several things are <a id="_idIndexMarker816"/>happening around your application that might be worthwhile to keep track of. These are some <span class="No-Break">of them:</span></p>
			<ul>
				<li><strong class="bold">Start/stop events</strong>: Log when services or components start and stop to understand application life <span class="No-Break">cycle events</span></li>
				<li><strong class="bold">Significant state changes</strong>: Any change in the state that might affect the application’s behavior should <span class="No-Break">be logged</span></li>
				<li><strong class="bold">Security-related events</strong>: These events include authentication attempts, access violations, and other <span class="No-Break">security checks</span></li>
			</ul>
			<h3>Dependency health</h3>
			<p>Applications rarely<a id="_idIndexMarker817"/> work in isolation. There are usually other systems that they depend on. You should track those dependencies <span class="No-Break">as well:</span></p>
			<ul>
				<li><strong class="bold">Database connectivity</strong>: Regular checks to ensure that your application can connect to databases or other <span class="No-Break">storage systems</span></li>
				<li><strong class="bold">External services</strong>: Monitor the availability and response times of any APIs or external services that your application <span class="No-Break">relies on</span></li>
			</ul>
			<h3>Custom business logic monitoring</h3>
			<p>Of course, the application does some specific things that only apply to your environment. These might also be targets to monitor. Think about things such <span class="No-Break">as these:</span></p>
			<ul>
				<li><strong class="bold">Performance of critical operations</strong> such as algorithms or processes central to your <span class="No-Break">application’s functionality</span></li>
				<li><strong class="bold">Data processing rates</strong>, especially in systems that handle large volumes of data or <span class="No-Break">streaming data</span></li>
			</ul>
			<p>These are just some of the things you might add to <span class="No-Break">your toolbelt.</span></p>
			<p class="callout-heading">Use the right level!</p>
			<p class="callout">Remember: assigning the right level to each event is essential when logging. Not everything should be Information; you must distinguish between an error and debug information. Again, please make sure that you are not leaking sensitive information through <span class="No-Break">your logs.</span></p>
			<h1 id="_idParaDest-235"><a id="_idTextAnchor236"/>Next steps</h1>
			<p>I hope that you took note of all of these items and kept a log of what we have been talking about! Logging and monitoring are extremely important, especially when you do not have a UI. We covered the logging frameworks available to you as a systems programmer in this chapter: the good and default Microsoft log, as well as NLog and structured logging <span class="No-Break">in Serilog.</span></p>
			<p>We also looked at monitoring the health of your system and your application. We looked at Seq to collect our logs, discussed how to use performance counters, and dove into monitoring <span class="No-Break">with Prometheus.</span></p>
			<p>We also talked about what you should be logging and monitoring and why you should <span class="No-Break">do that.</span></p>
			<p>All in all, from now on, you will no longer be in the dark when unexpected things happen. Since they <em class="italic">will</em> happen, you’d better make sure that you are prepared. A good logging and monitoring strategy can save your life. Well, maybe not your life, but it can help your system. That is what makes it all worth it. After all, a good log can set you on the right track when you want to start debugging your system. Incidentally, that is the topic of the <span class="No-Break">next chapter!</span></p>
		</div>
	</body></html>