<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-229"><a id="_idTextAnchor438"/>11</h1>
<h1 id="_idParaDest-230"><a id="_idTextAnchor439"/>Getting Started with gRPC</h1>
<p>Besides RESTful APIs, there are other types of APIs. One of them is the <strong class="bold">remote procedure call</strong> (<strong class="bold">RPC</strong>)-based API, which we introduced in <a href="B18971_01.xhtml#_idTextAnchor012"><em class="italic">Chapter 1</em></a>. gRPC is a high-performance RPC framework developed by Google. Now, it is an open-source project under the <strong class="bold">Cloud Native Computing Foundation</strong> (<strong class="bold">CNCF</strong>), and it is becoming more and more popular.</p>
<p>ASP.NET Core provides a set of gRPC tools to help us build gRPC services. In this chapter, we will introduce the fundamentals of gRPC and <strong class="bold">Protocol Buffers</strong> (<strong class="bold">Protobuf</strong>) messages. First, we will learn how to define protobuf messages and gRPC services. Then, we will learn how to implement gRPC services in ASP.NET Core, empowering us to communicate seamlessly between different applications. We will be covering the following topics in this chapter:</p>
<ul>
<li>Recap of gRPC</li>
<li>Setting up a gRPC project</li>
<li>Defining gRPC services and messages</li>
<li>Implementing gRPC services and clients</li>
<li>Consuming gRPC services in ASP.NET Core applications</li>
</ul>
<p>By the end of this chapter, you should be able to understand the fundamentals of protobuf and gRPC and know how to build gRPC services in ASP.NET Core.</p>
<h1 id="_idParaDest-231"><a id="_idTextAnchor440"/>Technical requirements</h1>
<p>The code examples in this chapter can be found at <a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter11">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter11</a>. You can use VS 2022 or VS Code to open the solutions.</p>
<h1 id="_idParaDest-232"><a id="_idTextAnchor441"/>Recap of gRPC</h1>
<p>If you have read <a href="B18971_01.xhtml#_idTextAnchor012"><em class="italic">Chapter 1</em></a>, you should be familiar with the concept of RPC – it is a protocol that allows a program to call a procedure on a remote machine. Unlike RESTful APIs, which center around resources, RPC-based APIs focus on actions. So, RPC methods support various types of actions besides CRUD operations.</p>
<p>gRPC is <a id="_idIndexMarker1086"/>one of the most popular RPC frameworks. It provides many benefits over traditional RPC frameworks. As we mentioned in <a href="B18971_01.xhtml#_idTextAnchor012"><em class="italic">Chapter 1</em></a>, gRPC is based on HTTP/2, which is more efficient than HTTP/1.1. gRPC uses protobuf as the default data serialization format, which is a binary format that is more compact and efficient than JSON. The tooling support for gRPC is also very good. It follows the contract-first approach, which means we can create language-neutral service definitions and generate code for different languages. It also supports streaming, which is a very useful feature for real-time communication.</p>
<p>With the increasing popularity of microservices, gRPC is becoming more and more popular. While gRPC offers some advantages over RESTful APIs, it is not considered a complete replacement. gRPC is an excellent choice for high-performance, low-latency communication between microservices, but RESTful APIs are more suitable for web-based applications and scenarios where simplicity, flexibility, and wide adoption are more critical. It’s important to choose the right protocol based on the requirements of your specific use case. In the next section, we will learn how to set up a gRPC project in ASP.NET Core.<a id="_idTextAnchor442"/></p>
<h1 id="_idParaDest-233"><a id="_idTextAnchor443"/>Setting up a gRPC project</h1>
<p>In this section, we<a id="_idIndexMarker1087"/> will build a gRPC project using the dotnet CLI. We will also create a client project to consume the gRPC service. We will be using the same project throughout this chapter<a id="_idTextAnchor444"/>.</p>
<h2 id="_idParaDest-234"><a id="_idTextAnchor445"/>Creating a new gRPC project</h2>
<p>To create a <a id="_idIndexMarker1088"/>new gRPC project, we can use the <code>dotnet new</code> command. The dotnet CLI provides a template for gRPC projects, which includes a basic gRPC service. We can use the following command to create a new gRPC project:</p>
<pre class="console">
dotnet new grpc -o GrpcDemo</pre> <p>The <code>-o</code> option specifies the output directory. After running the command, we will see that a project named <code>GrpcDemo</code> is created.</p>
<p>If you<a id="_idIndexMarker1089"/> prefer to use VS 2022, you can also create a new gRPC project in VS 2022 using the built-in gRPC template. You can select the <strong class="bold">ASP.NET Core gRPC Service</strong> template when creating a new project, as shown in <em class="italic">Figure 11</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 11.1 – Creating a new gRPC project in VS 2022" src="img/B18971_11_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Creating a new gRPC project in VS 2022</p>
<p>After creating the project, you can use VS Code or VS 2022 to open the project. Next, we’ll explore the project structur<a id="_idTextAnchor446"/>e.</p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor447"/>Understanding the gRPC project structure</h2>
<p>The <a id="_idIndexMarker1090"/>project structure of a gRPC project has some differences from a RESTful API project. There is no <code>Controllers</code> folder in the gRPC project. Instead, there is a <code>Protos</code> folder, which contains the proto files. You can find a <code>greet.proto</code> file in the <code>Protos</code> folder, as follows:</p>
<pre class="source-code">
syntax = "proto3";option csharp_namespace = "GrpcDemo";
package greet;
// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply);
}
// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}
// The response message containing the greetings.
message HelloReply {
  string message = 1;
}</pre>
<p>gRPC <a id="_idIndexMarker1091"/>uses protobuf as the <a id="_idIndexMarker1092"/>default data serialization format. The <code>greet.proto</code> file is the proto file that defines the gRPC service and messages. If you are familiar with RESTful APIs, you can think of this file as the Swagger file (OpenAPI specification). It is the contract of the gRPC service. In the preceding proto file, we define a service named <code>Greeter</code> with a method named <code>SayHello()</code>. The <code>SayHello()</code> method takes a <code>HelloRequest</code> message as input and returns a <code>HelloReply</code> message as output. Both <code>HelloRequest</code> and <code>HelloReply</code> messages have string properties named <code>name</code> and <code>message</code>, respectively.</p>
<p>In a proto file, you can use <code>//</code> to add comments. To add multi-line comments, you can use <code>/* ... */</code>.</p>
<p class="callout-heading">Important note</p>
<p class="callout">VS Code does not provide syntax highlighting for proto files by default. You can install some extensions, such as <code>vscode-proto3</code>, to enable syntax highlighting.</p>
<p>Let’s check<a id="_idIndexMarker1093"/> the project file. Open the <code>GrpcDemo.csproj</code> file; we will see the following content:</p>
<pre class="source-code">
&lt;ItemGroup&gt;  &lt;Protobuf Include="Protos\greet.proto" GrpcServices="Server" /&gt;
&lt;/ItemGroup&gt;
&lt;ItemGroup&gt;
  &lt;PackageReference Include="Grpc.AspNetCore" Version="2.51.0" /&gt;
  &lt;PackageReference Include="Google.Protobuf" Version="3.22.0-rc2" /&gt;
&lt;/ItemGroup&gt;</pre>
<p>You will see that it includes two package references:</p>
<ul>
<li><code>Grpc.AspNetCore</code>: This package provides the gRPC server library for ASP.NET Core. It also references the <code>Grpc.Tools</code> package, which provides the code-generation tooling.</li>
<li><code>Google.Protobuf</code>: This package provides the <code>Protobuf</code> runtime library.</li>
</ul>
<p>There is a <code>Protobuf</code> item group that includes the proto file. The <code>GrpcServices</code> attribute specifies the type of code generated by the proto file. It can be set to the following values:</p>
<ul>
<li><code>None</code>: No code is generated</li>
<li><code>Client</code>: This option only generates client-side code</li>
<li><code>Server</code>: This option only generates server-side code</li>
<li><code>Both</code>: This option generates both client-side code and server-side code. It is the default value</li>
</ul>
<p>In the <a id="_idIndexMarker1094"/>template project, the <code>GrpcServices</code> attribute is set to <code>Server</code>, which means only server-side code is generated.</p>
<p>If you have multiple proto files, you can add multiple <code>Protobuf</code> items to the <code>ItemGroup</code> element.</p>
<p>Next, let’s check the <code>Services</code> folder. You can find the <code>GreeterService.cs</code> file in the <code>Services</code> folder, which contains the implementation of the <code>Greeter</code> service:</p>
<pre class="source-code">
public class GreeterService(ILogger&lt;GreeterService&gt; logger) : Greeter.GreeterBase{
    public override Task&lt;HelloReply&gt; SayHello(HelloRequest request, ServerCallContext context)
    {
        return Task.FromResult(new HelloReply
        {
            Message = "Hello " + request.Name
        });
    }
}</pre>
<p>The <code>GreeterService</code> class inherits from the <code>GreeterBase</code> class, which is generated by the proto file. It has a <code>SayHello()</code> method, which takes a <code>HelloRequest</code> object as input and returns a <code>HelloReply</code> object as output. The implementation of the <code>SayHello()</code> method is very simple – it matches the definition of the <code>SayHello()</code> method in the proto file.</p>
<p>If you move your mouse over the <code>HelloRequest</code> class in VS Code, you will see a pop-up message, which shows that the namespace of the <code>HelloRequest</code> class is <code>GrpcDemo.HelloRequest</code>, as shown in <em class="italic">Figure 11</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 11.2 – The namespace of the HelloRequest class" src="img/B18971_11_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – The namespace of the HelloRequest class</p>
<p>The <code>HelloReply</code> class is <a id="_idIndexMarker1095"/>also similar. However, you won’t be able to find the <code>HelloRequest</code> class and the <code>HelloReply</code> class in the project. Where are these classes defined?</p>
<p>You can press <em class="italic">F12</em> to go to the definition of the <code>HelloRequest</code> class in VS Code. You will be navigated to a <code>Greet.cs</code> file, which is located in the <code>obj\Debug\net8.0\Protos</code> folder. This file is generated by the proto file and contains the definition of the <code>HelloRequest</code> class:</p>
<pre class="source-code">
  #region Messages  /// &lt;summary&gt;
  /// The request message containing the user's name.
  /// &lt;/summary&gt;
  public sealed partial class HelloRequest : pb::IMessage&lt;HelloRequest&gt;
  {
    private static readonly pb::MessageParser&lt;HelloRequest&gt; _parser = new pb::MessageParser&lt;HelloRequest&gt;(() =&gt; new HelloRequest());
    // Omitted for brevity
    public HelloRequest() {
      OnConstruction();
    }
    // Omitted for brevity
    /// &lt;summary&gt;Field number for the "name" field.&lt;/summary&gt;
    public const int NameFieldNumber = 1;
    private string name_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    // Omitted for brevity
  }</pre>
<p>In the definition <a id="_idIndexMarker1096"/>of the <code>HelloRequest</code> class, you can see that it implements the <code>IMessage&lt;HelloRequest&gt;</code> interface, which is defined in the <code>Google.Protobuf</code> package. All protobuf messages must implement this base interface. The <code>HelloRequest</code> class also has a <code>Name</code> property, which is defined in the proto file. You can find a <code>DebuggerNonUserCodeAttribute</code> attribute on the <code>Name</code> property. This attribute means that the <code>Name</code> member is not part of the user code for an application. The <code>Name</code> property also has a <code>GeneratedCode</code> attribute, which means this member is generated by the tooling. Specifically, the <code>Name</code> property is generated by the <code>protoc</code> tool, which is the protobuf compiler. Users should not modify this member.</p>
<p>You can also <a id="_idIndexMarker1097"/>find the definition of the <code>HelloReply</code> class in the <code>Greet.cs</code> file. Next to the <code>Greet.cs</code> file, in the <code>Protos</code> folder, you can find a <code>GreetGrpc.cs</code> file, which defines the <code>GreeterBase</code> abstract class as the base class of the <code>GreeterService</code> class. Similarly, the <code>GreeterBase</code> class is also generated by the gRPC tooling. It contains the definition of the <code>SayHello()</code> method, as follows:</p>
<pre class="source-code">
/// &lt;summary&gt;Base class for server-side implementations of Greeter&lt;/summary&gt;[grpc::BindServiceMethod(typeof(Greeter), "BindService")]
public abstract partial class GreeterBase
{
  /// &lt;summary&gt;
  /// Sends a greeting
  /// &lt;/summary&gt;
  /// &lt;param name="request"&gt;The request received from the client.&lt;/param&gt;
  /// &lt;param name="context"&gt;The context of the server-side call handler being invoked.&lt;/param&gt;
  /// &lt;returns&gt;The response to send back to the client (wrapped by a task).&lt;/returns&gt;
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  public virtual global::System.Threading.Tasks.Task&lt;global::GrpcDemo.HelloReply&gt; SayHello(global::GrpcDemo.HelloRequest request, grpc::ServerCallContext context)
  {
    throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
  }
}</pre>
<p>The <code>GreeterBase</code> class <a id="_idIndexMarker1098"/>is marked with the <code>BindServiceMethod</code> attribute, which means this method is the implementation of the <code>SayHello()</code> method defined in the proto file. The <code>SayHello()</code> method has an attribute called <code>GeneratedCode</code> that indicates that this class is generated by the gRPC C# plugin. Inside the <code>SayHello()</code> method, you can see that it throws an exception by default. Because this method is <code>virtual</code>, we need to override this method in the <code>GreeterService</code> class to provide the actual implementation.</p>
<p>Next, let’s check the <code>Program.cs</code> file. You will find the following code in the <code>Program.cs</code> file:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);// Add services to the container.
builder.Services.AddGrpc();
var app = builder.Build();
// Configure the HTTP request pipeline.
app.MapGrpcService&lt;GreeterService&gt;();</pre>
<p>In the preceding code block, we can see that the <code>AddGrpc()</code> method is called to add gRPC services to the service container. Then, we use the <code>MapGrpcService&lt;GreeterService&gt;()</code> method to map the <code>GreeterService</code> class to the gRPC service, which is similar to the <code>MapControllers</code> method in the RESTful API project.</p>
<p>There is another line of code in the <code>Program.cs</code> file that uses the <code>MapGet()</code> method to show a message if users access the root path of the application from a web browser:</p>
<pre class="source-code">
app.MapGet("/", () =&gt; "Communication with gRPC endpoints must be made through a gRPC client. To learn how to create a client, visit: https://go.microsoft.com/fwlink/?linkid=2086909");</pre> <p>This is because gRPC services cannot be accessed by a web browser. So, we need to show a message to notify users that they need to use a gRPC client to access the gRPC service.</p>
<p>Let’s update <a id="_idIndexMarker1099"/>the proto file and see what happens. Open the <code>greet.proto</code> file and update the <code>HelloRequest</code>, as follows:</p>
<pre class="source-code">
message HelloRequest {  string name = 1;
  string address = 2;
}</pre>
<p>Save the file and go back to the <code>GreeterService</code> class. In the <code>SayHello()</code> method, you can try to access the <code>Address</code> property of the <code>HelloRequest</code> object. You will find that the <code>Address</code> property is not available. This is because the generated code is not updated. We need to regenerate the code by using the <code>dotnet build</code> command. Alternatively, you can delete the <code>obj</code> folder and the code will be regenerated automatically.</p>
<p>You may find that it is not convenient to store the generated code in the <code>obj</code> folder. We can change the output directory of the generated code by using the <code>OutputDir</code> attribute in the <code>Protobuf</code> item in the <code>.csproj</code> file. For example, you can change the <code>Protobuf</code> item as follows:</p>
<pre class="source-code">
&lt;ItemGroup&gt;  &lt;Protobuf Include="Protos\greet.proto" GrpcServices="Server" OutputDir="Generated" /&gt;
&lt;/ItemGroup&gt;</pre>
<p>Now, the generated code will be stored in the <code>Generated\Protos</code> folder. A proto file can generate multiple files for server-side code. For example, the <code>greet.proto</code> file will generate the following files:</p>
<ul>
<li><code>greet.cs</code>: This file contains the definition of the messages and the methods to serialize and deserialize the messages</li>
<li><code>greetGrpc.cs</code>: This file contains the definition of the base class of the service and the methods to bind the service to the server</li>
</ul>
<p>Now that we<a id="_idIndexMarker1100"/> understand the structure of the gRPC project, let’s learn the concepts behind protobuf  messages.</p>
<h1 id="_idParaDest-236"><a id="_idTextAnchor448"/>Creating protobuf messages</h1>
<p>In this <a id="_idIndexMarker1101"/>section, we will learn how to create protobuf messages. We will introduce the concepts of protobuf messages and how to define them in a proto file.</p>
<p>gRPC is a contract-first framework, meaning that the gRPC service and messages must be defined in a proto file. When we talk about messages, we are talking about the data that is sent between the client and the server. While gRPC messages may be similar to the data model in RESTful APIs, they are not the same. RESTful APIs are centered around resources, and the data model is usually a resource model that can be mapped to one or multiple database tables. In contrast, gRPC is action-based, and the message can be any other type of data model or other message sent between the client and the server. Therefore, gRPC messages may not be exactly mapped to a resource model in RESTful APIs.</p>
<p>For example, when creating an invoice through a RESTful API using JSON as the data format, we need to send an HTTP POST request with a JSON body to the server. The JSON body will be deserialized into a .NET object, which serves as the data model for the invoice. To retrieve an invoice, we need to send an HTTP GET request to the server and the server. The server will serialize the data model into a JSON string and send it back to the client. We may also have other actions, such as updating an invoice, deleting an invoice, and so on. All these actions are mapped to HTTP methods.</p>
<p>To implement the same functionality using gRPC, we need to define a gRPC service with several methods: <code>CreateInvoice()</code>, <code>GetInvoice()</code>, <code>UpdateInvoice()</code>, <code>DeleteInvoice()</code>, and others. For each of these methods, we must also define the corresponding request and response messages. For example, the <code>CreateInvoice()</code> method requires a <code>CreateInvoiceRequest</code> message containing the properties of the invoice, as well as a <code>CreateInvoiceResponse</code> message containing the ID of the created invoice. It is important to note that the request and response messages are distinct from the data model of the invoice, which is used to represent the invoice entity in the system. The request and response messages are used to send data between the client and the server.</p>
<p>Note that <a id="_idIndexMarker1102"/>gRPC and protobuf are not the same thing. protobuf is a language-neutral, platform-neutral data serialization format. gRPC is a framework that uses protobuf as the default data serialization format. Sometimes, these two terms are used interchangeably, but we should know the difference between them.</p>
<p>Think about the invoice example we mentioned previously. An invoice has several properties, such as the invoice number, the invoice date, the customer’s name, the total amount, and so on. A customer has a name and an address. An address has some properties, such as street, city, state, and so on.</p>
<p>Next, we’ll define the first message that is used to create an address for the invoice service. The source code for this section can be found in the <code>chapter11/GrpcDemo-v2</code> folder. We will start with a simple message and then introduce more concepts regarding protobuf messages, including field numbers, field types, and how to use other .NET types in protobuf messages. We will also learn how to implement list and dictionary types using the <code>repeated</code> an<a id="_idTextAnchor449"/>d <code>map</code> keywords.</p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor450"/>Defining a protobuf message</h2>
<p>Create a <a id="_idIndexMarker1103"/>new <code>invoice.proto</code> file in the <code>Protos</code> folder. VS Code provides a proto file template when you create a new file, as shown in <em class="italic">Figure 11</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 11.3 – The proto file template in VS Code" src="img/B18971_11_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – The proto file template in VS Code</p>
<p>The proto file<a id="_idIndexMarker1104"/> template creates a proto file named <code>Protos.proto</code>. Rename it <code>invoice.proto</code>. The content of the proto file is as follows:</p>
<pre class="source-code">
syntax = "proto3";option csharp_namespace = "MyApp.Namespace";</pre>
<p>A proto file is a text file with the <code>.proto</code> extension. The first line of the proto file specifies the syntax version of the proto file. At the time of writing, the latest version of the proto file is version 3, which was released in 2016. You can find more information about the proto file syntax at <a href="https://protobuf.dev/programming-guides/proto3/">https://protobuf.dev/programming-guides/proto3/</a>.</p>
<p>The <code>option csharp_namespace</code> line specifies the namespace of the generated code in C#. You can change the namespace according to your needs. This option is used to avoid naming conflicts between different proto files. Note that even though a proto file is language-neutral, the <code>option csharp_namespace</code> attribute is only used by the C# code generator. In this sample project, we can change the namespace to <code>GrpcDemo</code> to match the namespace of the existing code.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Protobuf supports a <code>package</code> keyword to avoid naming conflicts, depending on the language. For example, <code>package com.company</code> is equivalent to <code>option csharp_namespace = "Com.Company"</code> in C# (the name will be converted into PascalCase), and <code>package com.company</code> is equivalent to <code>option java_package = "com.company"</code> in Java. However, <code>package com.company</code> will be ignored in Python since Python modules are organized by filesystem directories.</p>
<p class="callout">Since we are using C#, we use the <code>option csharp_namespace</code> attribute, which can override the <code>package</code> keyword for C# applications. If you share the proto file with other applications that use other languages, you can use the <code>package</code> keyword or the language-specific option to avoid naming conflicts.</p>
<p>Once the proto file has<a id="_idIndexMarker1105"/> been created, we need to add it to the project file. Open the <code>GrpcDemo.csproj</code> file and add the following code to an <code>&lt;</code><code>ItemGroup&gt;</code> element:</p>
<pre class="source-code">
&lt;Protobuf Include="Protos\invoice.proto" GrpcServices="Server"  OutputDir="Generated"/&gt;</pre> <p>Now, the gRPC tooling will generate the code for the <code>invoice.proto</code> file when we build the project.</p>
<p>gRPC proto3 uses similar concepts as .NET classes to define messages. However, there are some differences. For example, proto3 does not support <code>GUID</code> and <code>decimal</code> types. Let’s start with a simple message. We can define an <code>Address</code> message as follows:</p>
<pre class="source-code">
message CreateAddressRequest {  string street = 1;
  string city = 2;
  string state = 3;
  string zip_code = 4;
  string country = 5;
}</pre>
<p>As we can see, it is similar to a .NET class. We use a <code>message</code> keyword to define a gRPC message. In the message body, we can use <code>string</code> to declare a string field. However, there are some<a id="_idIndexMarker1106"/> questions to answer here:</p>
<ul>
<li>Why do we assign a number to each property? Is it the default value?</li>
<li>Why does the number start with 1? Can we use 0?</li>
<li>Should we use these numbers in a specific order?</li>
</ul>
<p>Let’s answer these questions b<a id="_idTextAnchor451"/>efore we move on.</p>
<h2 id="_idParaDest-238"><a id="_idTextAnchor452"/>Understanding field numbers</h2>
<p>The<a id="_idIndexMarker1107"/> numbers following the field names are called <em class="italic">field numbers</em>. Field numbers play an important role in the proto file. These field numbers are used to identify the fields in the message. What is the benefit of using field numbers instead of field names? Let’s look at an example of an XML document:</p>
<pre class="source-code">
&lt;address&gt;  &lt;street&gt;1 Fake Street&lt;/street&gt;
  &lt;city&gt;Wellington&lt;/city&gt;
  &lt;state&gt;Wellington&lt;/state&gt;
  &lt;zip_code&gt;6011&lt;/zip_code&gt;
  &lt;country&gt;New Zealand&lt;/country&gt;
&lt;/address&gt;</pre>
<p>In the preceding XML document, each field is wrapped in a tag. We have to open and close the tags to wrap the values of the fields. The XML syntax wastes a lot of space when transferring data. Consider the following example of a JSON document:</p>
<pre class="source-code">
{  "street": "1 Fake Street",
  "city": "Wellington",
  "state": "Wellington",
  "zip_code": "6011",
  "country": "New Zealand"
}</pre>
<p>In the<a id="_idIndexMarker1108"/> preceding JSON document, we just use each field name once. Normally, JSON format is more compact than XML format. What if we get rid of the field names? That is why we use field numbers in the proto file. By using field numbers instead of field names when encoding the message, we can make the gRPC message more compact. This is because numbers are shorter than field names. Additionally, protobuf uses a binary format, which is more compact than plain text formats such as JSON and XML. This further helps reduce the size of the message.</p>
<p>There are a few things to note about field numbers according to the protobuf documentation:</p>
<ul>
<li>The range of field numbers is from <code>1</code> to <code>536,870,911</code>. So we cannot use <code>0</code> as a field number.</li>
<li>The field numbers must be unique within a message.</li>
<li>Field numbers <code>19000</code> to <code>19999</code> are reserved for protobuf, so you cannot use them.</li>
<li>Technically, the order of the field numbers does not matter. It is recommended to use the ascending order of the field numbers. Smaller field numbers use fewer bytes to encode. For example, a field number between <code>1</code> and <code>15</code> uses only one byte to encode, but numbers from <code>16</code> to <code>2047</code> use two bytes.</li>
<li>Once a field number is assigned to a field, it cannot be changed if the proto file is used in production. Changing a field number will break the backward compatibility of the proto file.</li>
</ul>
<p>With that, we have learned what field numbers are and why we use them. Next, let’s unde<a id="_idTextAnchor453"/>rstand field types.</p>
<h2 id="_idParaDest-239"><a id="_idTextAnchor454"/>Understanding the field types</h2>
<p>Similar to .NET classes, a gRPC <a id="_idIndexMarker1109"/>message can have different types of fields. protobuf provides a set of native types, which are called <strong class="bold">scalar value types</strong>. These <a id="_idIndexMarker1110"/>scalar value types have representations in most programming<a id="_idIndexMarker1111"/> languages. The following table lists the mapping between protobuf scalar value types and .NET types:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-8">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Protobuf Type</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">.</strong><strong class="bold">NET Type</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Notes</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>double</code></p>
</td>
<td class="No-Table-Style">
<p><code>double</code></p>
</td>
<td class="No-Table-Style">
<p>±5.0 × 10−324 to ±1.7 × 10308.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>float</code></p>
</td>
<td class="No-Table-Style">
<p><code>float</code></p>
</td>
<td class="No-Table-Style">
<p>±1.5 x 10−45 to ±3.4 x 1038.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>int32</code></p>
</td>
<td class="No-Table-Style">
<p><code>int</code></p>
</td>
<td class="No-Table-Style">
<p>The length is variable. Use <code>sint32</code> if the field has negative numbers.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>int64</code></p>
</td>
<td class="No-Table-Style">
<p><code>long</code></p>
</td>
<td class="No-Table-Style">
<p>The length is variable. Use <code>sint64</code> if the field has negative numbers.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>uint32</code></p>
</td>
<td class="No-Table-Style">
<p><code>uint</code></p>
</td>
<td class="No-Table-Style">
<p>The length is variable. Unsigned integer. 0 to (232-1).</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>uint64</code></p>
</td>
<td class="No-Table-Style">
<p><code>ulong</code></p>
</td>
<td class="No-Table-Style">
<p>The length is variable. Unsigned integer. 0 to (264-1).</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>sint32</code></p>
</td>
<td class="No-Table-Style">
<p><code>int</code></p>
</td>
<td class="No-Table-Style">
<p>The length is variable. Signed integer. -231 to (231-1).</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>sint64</code></p>
</td>
<td class="No-Table-Style">
<p><code>long</code></p>
</td>
<td class="No-Table-Style">
<p>The length is variable. Signed integer. -263 to (263-1).</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>fixed32</code></p>
</td>
<td class="No-Table-Style">
<p><code>uint</code></p>
</td>
<td class="No-Table-Style">
<p>The length is always 4 bytes. This type is more efficient than <code>uint32</code> for serializing or deserializing values that are greater than 228.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>fixed64</code></p>
</td>
<td class="No-Table-Style">
<p><code>ulong</code></p>
</td>
<td class="No-Table-Style">
<p>The length is always 8 bytes. This type is more efficient than <code>uint64</code> for serializing or deserializing values that are greater than 256.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>sfixed32</code></p>
</td>
<td class="No-Table-Style">
<p><code>int</code></p>
</td>
<td class="No-Table-Style">
<p>The length is always 4 bytes.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>sfixed64</code></p>
</td>
<td class="No-Table-Style">
<p><code>long</code></p>
</td>
<td class="No-Table-Style">
<p>The length is always 8 bytes.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>bool</code></p>
</td>
<td class="No-Table-Style">
<p><code>bool</code></p>
</td>
<td class="No-Table-Style"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>string</code></p>
</td>
<td class="No-Table-Style">
<p><code>string</code></p>
</td>
<td class="No-Table-Style">
<p>A <code>string</code> field must be encoded in UTF-8 or 7-bit ASCII. The maximum length of a <code>string</code> field is 232.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>bytes</code></p>
</td>
<td class="No-Table-Style">
<p><code>ByteString</code></p>
</td>
<td class="No-Table-Style">
<p>This type is defined in protobuf runtime. It can be mapped to and from C#’s <code>byte[]</code> type.</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.1 – Protobuf scalar value types and .NET types</p>
<p>Let’s create a new <a id="_idIndexMarker1112"/>message <a id="_idIndexMarker1113"/>named <code>CreateContactRequest</code> and add some fields to it:</p>
<pre class="source-code">
message CreateContactRequest {  string first_name = 1;
  string last_name = 2;
  string email = 3;
  string phone = 4;
  int32 year_of_birth = 5;
  bool is_active = 6;
}</pre>
<p>The <code>CreateContactRequest</code> message requires the <code>first_name</code>, <code>last_name</code>, <code>email</code>, <code>phone</code>, <code>year_of_birth</code>, and <code>is_active</code> fields. The types for these fields are <code>string</code>, <code>int32</code>, and <code>bool</code>, respectively.</p>
<p>Next, we<a id="_idIndexMarker1114"/> can run <code>dotnet build</code> to generate the code. Alternatively, you can delete the existing files in the <code>Generated</code> folder and gRPC tooling will regenerate the code automatically based on the proto files.</p>
<p>The generated code files contain some complicated code. However, we can find the definition of the <code>CreateContactRequest</code> class, which is as follows:</p>
<pre class="source-code">
public sealed partial class CreateContactRequest : pb::IMessage&lt;CreateContactRequest&gt;{
    private string firstName_ = "";
    public string FirstName {
      get { return firstName_; }
      set {
        firstName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    private string lastName_ = "";
    public string LastName {
      get { return lastName_; }
      set {
        lastName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    private string email_ = "";
    public string Email {
      get { return email_; }
      set {
        email_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    private string phone_ = "";
    public string Phone {
      get { return phone_; }
      set {
        phone_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    private int yearOfBirth_;
    public int YearOfBirth {
      get { return yearOfBirth_; }
      set {
        yearOfBirth_ = value;
      }
    }
    private bool isActive_;
    public bool IsActive {
      get { return isActive_; }
      set {
        isActive_ = value;
      }
    }
}</pre>
<p>In the preceding <a id="_idIndexMarker1115"/>code block, some code has been omitted for brevity. You can see that the <code>CreateContactRequest</code> message has been converted into a .NET class, which includes the properties for each field.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Protobuf has a style guide for naming fields and methods. The general rules are as follows:</p>
<ul>
<li class="callout">Use <code>lower_snake_case</code> for field names</li>
<li class="callout">Use <code>PascalCase</code> for method names</li>
<li class="callout">File names should be in <code>lower_snake_case</code></li>
<li class="callout">Using double quotes for string literals is preferred over single quotes</li>
<li class="callout">The indentation should be two spaces in length</li>
</ul>
<p class="callout">You can find more information at <a href="https://protobuf.dev/programming-guides/style/">https://protobuf.dev/programming-guides/style/</a>.</p>
<p>With that, we’ve <a id="_idIndexMarker1116"/>learned how to use protobuf scalar value types. Now, let’s consider other types<a id="_idTextAnchor455"/>.</p>
<h2 id="_idParaDest-240"><a id="_idTextAnchor456"/>Other .NET types</h2>
<p>The protobuf <a id="_idIndexMarker1117"/>scalar data types do not support all the .NET types, such as <code>Guid</code>, <code>DateTime</code>, <code>decimal</code>, and others. There are some workarounds for<a id="_idIndexMarker1118"/> these types. In this section, we will learn how to use these types in protobuf. We will also explore some other types, such as <code>enum</code> and <code>repeat<a id="_idTextAnchor457"/>ed</code>.</p>
<h3>GUID values</h3>
<p>The <code>GUID</code> type (on other platforms, it may have another name, <code>UUID</code>) is a 128-bit structure<a id="_idIndexMarker1119"/> that is used to identify objects. It is a very common type in .NET applications. Normally, a <code>GUID</code> value can be represented as a string that contains 32 hexadecimal digits. For example, <code>31F6E4E7-7C48-4F91-8D33-7A74F6729C8B</code> is a <code>GUID</code> value.</p>
<p>However, protobuf does not support the <code>GUID</code> type. The best way to represent a <code>GUID</code> value in protobuf is to use a <code>string</code> field. In the .NET code, we can use <code>Guid.Parse()</code> to convert a string into a <code>GUID</code> value and use <code>Guid.ToString()</code> to convert a <code>GUID</code> value into a str<a id="_idTextAnchor458"/>ing.</p>
<h3>DateTime values</h3>
<p>.NET has<a id="_idIndexMarker1120"/> several types to represent a date and time value, such as <code>DateTime</code>, <code>DateTimeOffset</code>, and <code>TimeSpan</code>. Although protobuf does not support these types directly, it provides several extensions to support them.</p>
<p>To use these extension types, we need to import the <code>google/protobuf/xxx.proto</code> file into the proto file. For example, here is a message that contains a timestamp and a duration:</p>
<pre class="source-code">
syntax = "proto3";import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
message UpdateInvoiceDueDateRequest {
  string invoice_id = 1;
  google.protobuf.Timestamp due_date = 2;
  google.protobuf.Duration grace_period = 3;
}</pre>
<p>Check the generated code for the <code>UpdateInvoiceDueDateRequest</code> message in the <code>Generated</code> folder. You will find that the <code>due_date</code> field is converted into a <code>Timestamp</code> type, and the <code>grace_period</code> field is converted into a <code>Duration</code> type, as follows:</p>
<pre class="source-code">
public const int DueDateFieldNumber = 2;private global::Google.Protobuf.WellKnownTypes.Timestamp dueDate_;
public global::Google.Protobuf.WellKnownTypes.Timestamp DueDate {
  get { return dueDate_; }
  set {
    dueDate_ = value;
  }
}
public const int GracePeriodFieldNumber = 3;
private global::Google.Protobuf.WellKnownTypes.Duration gracePeriod_;
public global::Google.Protobuf.WellKnownTypes.Duration GracePeriod {
  get { return gracePeriod_; }
  set {
    gracePeriod_ = value;
  }
}</pre>
<p>The <code>Timestamp</code> type and the <code>Duration</code> type are not native .NET types. They are defined in the <code>Google.Protobuf.WellKnownTypes</code> namespace, which includes some <a id="_idIndexMarker1121"/>well-known types that are not supported by protobuf. The source code for these types can be found at <a href="https://github.com/protocolbuffers/protobuf/tree/main/csharp/src/Google.Protobuf/WellKnownTypes">https://github.com/protocolbuffers/protobuf/tree/main/csharp/src/Google.Protobuf/WellKnownTypes</a>.</p>
<p>Because these types are not native .NET types, we need to convert them into native .NET types when using them. The <code>Google.Protobuf.WellKnownTypes</code> namespace provides some methods to do the conversion. Here is an example of converting .NET types into protobuf types:</p>
<pre class="source-code">
var updateInvoiceDueDateRequest = new UpdateInvoiceDueDateRequest{
    InvoiceId = Guid.Parse("3193C36C-2AAB-49A7-A0B1-6BDB3B69DEA1"),
    DueDate = Timestamp.FromDateTime(DateTime.UtcNow.AddDays(30)),
    GracePeriod = Duration.FromTimeSpan(TimeSpan.FromDays(10))
};</pre>
<p>We<a id="_idIndexMarker1122"/> can use the <code>Timestamp</code> class to convert <code>DateTime</code> and <code>DateTimeOffset</code> values into <code>Timestamp</code> values. The <code>Timestamp.FromDateTime()</code> method is used to convert a <code>DateTime</code> value, while the <code>Timestamp.FromDateTimeOffset()</code> method is used to convert a <code>DateTimeOffset</code> value. We can also use the <code>Duration.FromTimeSpan()</code> method to convert a <code>TimeSpan</code> value into a <code>Duration</code> value. Note that if you use the <code>DateTimeOffset</code> type in your application, the offset of <code>DateTimeOffset</code> values is always 0, and the <code>DateTime.Kind</code> property is always set to <code>DateTimeKind.Utc</code>.</p>
<p>Similarly, we can convert protobuf types into .NET types:</p>
<pre class="source-code">
var dueDate = updateInvoiceDueDateRequest.DueDate.ToDateTime();var gracePeriod = updateInvoiceDueDateRequest.GracePeriod.ToTimeSpan();</pre>
<p>The <code>Timestamp</code> class provides several methods for converting its values into other types. The <code>ToDateTime()</code> method can be used to convert a <code>Timestamp</code> value into a <code>DateTime</code> value, while the <code>ToTimeSpan()</code> method can be used to convert a <code>Duration</code> value into a <code>TimeSpan</code> value. Additionally, the <code>ToDateTimeOffset()</code> method can be used to convert a <code>Timestamp</code> value into a <code>DateTimeOffset</code> value. Depending on your requirements, you can select the appropriate method for your<a id="_idTextAnchor459"/> needs.</p>
<h3>Decimal values</h3>
<p>At the time <a id="_idIndexMarker1123"/>of writing, protobuf does not support the <code>decimal</code> type directly. There are some discussions about adding the <code>decimal</code> type to protobuf, but it hasn’t been implemented yet. As a workaround, Microsoft Docs provides a <code>DecimalValue</code> type, which can be used to represent a <code>decimal</code> value in protobuf. The following code, which has been copied from Microsoft Docs, shows how <a id="_idIndexMarker1124"/>to define a <code>decimal</code> value in protobuf:</p>
<pre class="source-code">
// Example: 12345.6789 -&gt; { units = 12345, nanos = 678900000 }message DecimalValue {
    // Whole units part of the amount
    int64 units = 1;
    // Nano units of the amount (10^-9)
    // Must be same sign as units
    sfixed32 nanos = 2;
}</pre>
<p>We will not delve into the details of the <code>DecimalValue</code> type in this book. You can find more information at <a href="https://learn.microsoft.com/en-us/dotnet/architecture/grpc-for-wcf-developers/protobuf-data-types#decimals">https://learn.microsoft.com/en-us/dotnet/architecture/grpc-for-wcf-developers/protobuf-data-types#decimals</a>.</p>
<h3>Enum values</h3>
<p>The <code>enum</code> type is<a id="_idIndexMarker1125"/> very common in .NET applications. protobuf supports the <code>enum</code> type. Here’s an example of its usage:</p>
<pre class="source-code">
enum InvoiceStatus {  INVOICE_STATUS_UNKNOWN = 0;
  INVOICE_STATUS_DRAFT = 1;
  INVOICE_STATUS_AWAIT_PAYMENT = 2;
  INVOICE_STATUS_PAID = 3;
  INVOICE_STATUS_OVERDUE = 4;
  INVOICE_STATUS_CANCELLED = 5;
}</pre>
<p>The preceding enum definition is similar to the enum definition in C#, but we need to define <a id="_idIndexMarker1126"/>it in the proto file. In the preceding code, we define an <code>InvoiceStatus</code> enum type with six values. Note that every enum type must contain a <code>0</code> value, which is the default value and must be placed at the first position. The <code>InvoiceStatus</code> enum type is converted into a .NET enum type, as follows:</p>
<pre class="source-code">
public enum InvoiceStatus {  [pbr::OriginalName("INVOICE_STATUS_UNKNOWN")] Unknown = 0,
  [pbr::OriginalName("INVOICE_STATUS_DRAFT")] Draft = 1,
  [pbr::OriginalName("INVOICESTATUS_AWAIT_PAYMENT")] AwaitPayment = 2,
  [pbr::OriginalName("INVOICE_STATUS_PAID")] Paid = 3,
  [pbr::OriginalName("INVOICE_STATUS_OVERDUE")] Overdue = 4,
}</pre>
<p>As you can see, the <code>INVOICE_STATUS</code> prefix in the original names is removed because the prefix is the same as the enum name. In the .NET code, the enum names are converted into PascalCase.</p>
<p>Besides the <code>enum</code> type, .NET also has a common type named <code>nullable</code>. We’ll check out nullable types in the ne<a id="_idTextAnchor461"/>xt section.</p>
<h3>Nullable values</h3>
<p>Protobuf scalar <a id="_idIndexMarker1127"/>value types, such as <code>int32</code>, <code>sint32</code>, <code>fixed32</code>, and <code>bool</code>, cannot be <code>null</code>. But in .NET, nullable value types are very common. For example, we can use <code>int?</code> to declare an integer value that can be <code>null</code>. To support nullable value types, protobuf provides some wrapper types, which are defined in the <code>google/protobuf/wrappers.proto</code> file, to support nullable types. We can import this file into the proto file and use the wrapper types. For example, we can define a message as follows:</p>
<pre class="source-code">
syntax = "proto3";import "google/protobuf/wrappers.proto";
message AddInvoiceItemRequest {
  string name = 1;
  string description = 2;
  google.protobuf.DoubleValue unit_price = 3;
  google.protobuf.Int32Value quantity = 4;
  google.protobuf.BoolValue is_taxable = 5;
}</pre>
<p>In the <a id="_idIndexMarker1128"/>preceding code, the <code>google.protobuf.DoubleValue</code> type is used to represent a nullable <code>double</code> value, the <code>google.protobuf.Int32Value</code> type is used to represent a nullable <code>int32</code> value, and the <code>google.protobuf.BoolValue</code> type is used to define a nullable <code>bool</code> value. The generated code for the <code>AddInvoiceItemRequest</code> message is shown here:</p>
<pre class="source-code">
private double? unitPrice_;public double? UnitPrice {
  get { return unitPrice_; }
  set {
    unitPrice_ = value;
  }
}
private int? quantity_;
public int? Quantity {
  get { return quantity_; }
  set {
    quantity_ = value;
  }
}
private bool? isTaxable_;
public bool? IsTaxable {
  get { return isTaxable_; }
  set {
    isTaxable_ = value;
  }
}</pre>
<p>As you <a id="_idIndexMarker1129"/>can see, the <code>unitPrice</code>, <code>quantity</code>, and <code>IsTaxable</code> fields are converted into nullable types in .NET.</p>
<p>Most of .NET nullable types are supported by protobuf. Besides the <code>google.protobuf.DoubleValue</code>, <code>google.protobuf.Int32Value</code>, and <code>google.protobuf.BoolValue</code> types, protobuf also provides the following wrapper types:</p>
<ul>
<li><code>google.protobuf.FloatValue</code>: This type is used to represent a <code>float</code>? value.</li>
<li><code>google.protobuf.Int64Value</code>: This type is used to represent a <code>long</code>? value.</li>
<li><code>google.protobuf.UInt32Value</code>: This type is used to represent a <code>uint</code>? value.</li>
<li><code>google.protobuf.UInt64Value</code>: This type is used to represent a <code>ulong</code>? value.</li>
<li><code>google.protobuf.StringValue</code>: This type is used to represent a <code>string</code> value.</li>
<li><code>google.protobuf.BytesValue</code>: This type is used to represent a <code>ByteString</code> value.</li>
</ul>
<p>There are<a id="_idIndexMarker1130"/> two special types in the preceding list: <code>google.protobuf.StringValue</code> and <code>google.protobuf.BytesValue</code>. The corresponding .NET types are <code>string</code> and <code>ByteString</code>. The <code>ByteString</code> type is a class that represents an immutable array of bytes, which is defined in the protobuf runtime. The default value of these two types is <code>null</code>.</p>
<p>So, if <code>google.protobuf.StringValue</code> is mapped to <code>string</code> in .NET, what is the difference between <code>google.protobuf.StringValue</code> and <code>string</code> in protobuf? The difference is the default value. We’ll look at the default values of these types in th<a id="_idTextAnchor462"/>e next section.</p>
<h3>Default values</h3>
<p>The following table lists <a id="_idIndexMarker1131"/>the default values of the scalar value types:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-7">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Protobuf Type</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Default Value</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>string</code></p>
</td>
<td class="No-Table-Style">
<p>An empty string</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>bytes</code></p>
</td>
<td class="No-Table-Style">
<p>An empty byte array</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>bool</code></p>
</td>
<td class="No-Table-Style">
<p><code>false</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Numeric types</p>
</td>
<td class="No-Table-Style">
<p><code>0</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>enums</code> </p>
</td>
<td class="No-Table-Style">
<p>The first enum value</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.2 – Default values of protobuf scalar value types</p>
<p>If you use <code>string</code> as the type of a field, the default value will be an empty string. However, the default value of a <code>google.protobuf.StringValue</code> field is <code>null</code>. Similarly, the default value of a <code>bytes</code> field is an empty byte array, while the default value of a <code>google.protobuf.BytesValue</code> field is <code>null</code>. All other wrapper types also have a default value of <code>null</code>.</p>
<p>All <a id="_idIndexMarker1132"/>numeric types, including <code>int32</code>, <code>double</code>, and <code>float</code>, have a default value of <code>0</code>. This applies to all numerical data types. <code>Enum</code> types in protobuf have a default value of the first value in the enum type, which must be 0. For instance, the <code>InvoiceStatus</code> enum type has a default value of <code>INVOICE_STATUS_UNKNOWN</code>, which is <code>0</code>.<a id="_idTextAnchor463"/></p>
<h3>Repeated fields</h3>
<p>Similar <a id="_idIndexMarker1133"/>to .NET collections, protobuf supports repeated fields. A repeated field can contain zero or more items. The following code shows how to define a repeated field:</p>
<pre class="source-code">
message UpdateBatchInvoicesStatusRequest {  repeated string invoice_ids = 1;
  InvoiceStatus status = 2;
}</pre>
<p>In the preceding code, we use the <code>repeated</code> keyword to define a repeated field. The generated code for the repeated <code>invoice_ids</code> field in the <code>UpdateInvoicesStatusRequest</code> message is as follows:</p>
<pre class="source-code">
private readonly pbc::RepeatedField&lt;string&gt; invoiceIds_ = new pbc::RepeatedField&lt;string&gt;();public pbc::RepeatedField&lt;string&gt; InvoiceIds {
  get { return invoiceIds_; }
}</pre>
<p>From the generated code, we can see that the repeated <code>string</code> field is converted into a <code>RepeatedField&lt;string&gt;</code> type. The <code>RepeatedField&lt;T&gt;</code> type is defined in the <code>Google.Protobuf.Collections</code> namespace, and it implements the .NET collection interfaces, as follows:</p>
<pre class="source-code">
public sealed class RepeatedField&lt;T&gt; : IList&lt;T&gt;, ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IEnumerable, IList, ICollection, IDeepCloneable&lt;RepeatedField&lt;T&gt;&gt;, IEquatable&lt;RepeatedField&lt;T&gt;&gt;, IReadOnlyList&lt;T&gt;, IReadOnlyCollection&lt;T&gt;{
  // Omitted for brevity
}</pre>
<p>The <code>RepeatedField&lt;T&gt;</code> type can be used as a normal .NET collection type, and any LINQ methods can be applied to it. This makes it a powerful and versatile tool for data manipulation.</p>
<p>You will <a id="_idIndexMarker1134"/>also find that the <code>InvoiceIds</code> field is a read-only property. To add one or multiple items to the collection, the <code>Add()</code> method can be used. Here’s an example:</p>
<pre class="source-code">
var updateInvoicesStatusRequest = new UpdateBatchInvoicesStatusRequest();// Add one item
updateInvoicesStatusRequest.InvoiceIds.Add("3193C36C-2AAB-49A7-A0B1-6BDB3B69DEA1");
// Add multiple items
updateInvoicesStatusRequest.InvoiceIds.Add(new[]
            { "99143291-2523-4EE8-8A4D-27B09334C980", "BB4E6CFE-6AAE-4948-941A-26D1FBF59E8A" });</pre>
<p>The default value of a repeated field is an empty collectio<a id="_idTextAnchor464"/>n.</p>
<h3>Map fields</h3>
<p>Protobuf<a id="_idIndexMarker1135"/> supports map fields, which are collections of key-value pairs similar to a .NET dictionary. The following code provides an example of how to define a map field:</p>
<pre class="source-code">
message UpdateInvoicesStatusRequest {  map&lt;string, InvoiceStatus&gt; invoice_status_map = 1;
}</pre>
<p>The<a id="_idIndexMarker1136"/> generated code for the <code>invoice_status_map</code> field is as follows:</p>
<pre class="source-code">
private readonly pbc::MapField&lt;string, global::GrpcDemo.InvoiceStatus&gt; invoiceStatusMap_ = newpbc::MapField&lt;string, global::GrpcDemo.InvoiceStatus&gt;();public pbc::MapField&lt;string, global::GrpcDemo.InvoiceStatus&gt; InvoiceStatusMap {
  get { return invoiceStatusMap_; }
}</pre>
<p>The <code>MapField&lt;Tkey, TValue&gt;</code> type is defined in the <code>Google.Protobuf.Collections</code> namespace and it implements the <code>IDictionary&lt;TKey, TValue&gt;</code> interface, as follows:</p>
<pre class="source-code">
public sealed class MapField&lt;TKey, TValue&gt; : IDeepCloneable&lt;MapField&lt;TKey, TValue&gt;&gt;, IDictionary&lt;TKey, TValue&gt;, ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;, IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;, IEnumerable, IEquatable&lt;MapField&lt;TKey, TValue&gt;&gt;, IDictionary, ICollection, IReadOnlyDictionary&lt;TKey, TValue&gt;, IReadOnlyCollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;{
  // Omitted for brevity
}</pre>
<p>The <code>MapField&lt;TKey, TValue&gt;</code> type can be used as a normal .NET dictionary type. This type provides the same functionality as a standard dictionary, allowing for the storage and retrieval of key-value pairs.</p>
<p>Similar to the repeated field, the <code>InvoiceStatusMap</code> field is also a read-only property. We can use the <code>Add()</code> method to add one key-value pair or multiple key-value pairs to the collection, as follows:</p>
<pre class="source-code">
var updateInvoicesStatusRequest = new UpdateInvoicesStatusRequest();// Add one key-value pair
updateInvoicesStatusRequest.InvoiceStatusMap.Add("3193C36C-2AAB-49A7-A0B1-6BDB3B69DEA1", InvoiceStatus.AwaitPayment);
// Add multiple key-value pairs
updateInvoicesStatusRequest.InvoiceStatusMap.Add(new Dictionary&lt;string, InvoiceStatus&gt;
{
    { "99143291-2523-4EE8-8A4D-27B09334C980", InvoiceStatus.Paid },
    { "BB4E6CFE-6AAE-4948-941A-26D1FBF59E8A", InvoiceStatus.Overdue }
});</pre>
<p>Note that map<a id="_idIndexMarker1137"/> fields cannot be repeated. Also, the key of a map field must be a <code>string</code> or integer type. You cannot use an <code>enum</code> type as the key of a map field. The value of a map field can be any type, including a message type. But the value type cannot be another map field.</p>
<p>We have now acquired a comprehensive understanding of protobuf messages, including field numbers, field types, default values, repeated fields, and map fields. For further information on protobuf messages, please refer to <a href="https://protobuf.dev/programming-guides/proto3/">https://protobuf.dev/programming-guides/proto3/</a>.</p>
<p>Next, we’ll examine the various protobuf services. We will explore the various types of RPC methods and how to create a gRPC client for the service. By doing so, we will gain a better understanding of how these services function and how to use them effecti<a id="_idTextAnchor465"/>vely.</p>
<h1 id="_idParaDest-241"><a id="_idTextAnchor466"/>Creating a protobuf service</h1>
<p>Now that we have<a id="_idIndexMarker1138"/> understood the definition of a protobuf message, we can move on to defining protobuf services. These services are comprised of RPC methods, each of which has a request and response message. To facilitate the implementation of these services, gRPC tooling will generate the necessary C# code, which can then be used as the base class for the service.</p>
<p>gRPC supports four types of RPC methods:</p>
<ul>
<li><strong class="bold">Unary RPC</strong>: The client sends a <a id="_idIndexMarker1139"/>single request message to the server and receives a single response message in return. This type of method is suitable for applications that need single request-response exchanges.</li>
<li><strong class="bold">Server streaming RPC</strong>: The <a id="_idIndexMarker1140"/>client sends a single request message to the server and the server then responds with a stream of response messages. This type of method allows for continuous data exchange between the client and server.</li>
<li><strong class="bold">Client streaming RPC</strong>: The<a id="_idIndexMarker1141"/> client sends a stream request message to the server and the server then responds with a response message. Similar to server streaming RPC, this type of method also allows for a continuous data exchange but the data change is initiated by the client.</li>
<li><strong class="bold">Bidirectional streaming RPC</strong>: The <a id="_idIndexMarker1142"/>client initiates the process by sending a stream request message, to which the server responds with a stream response message. This type of method enables communication between the client and the server to be conducted in both directions.</li>
</ul>
<p>Let’s check out these RPC methods one by one. The source code for this section can be found in the <code>chapter11/GrpcDemo-<a id="_idTextAnchor467"/>v3</code> folder.</p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor468"/>Defining a unary service</h2>
<p>A <a id="_idIndexMarker1143"/>unary service is <a id="_idIndexMarker1144"/>the simplest type of RPC method. The following code shows a unary service:</p>
<pre class="source-code">
message CreateContactRequest {  string first_name = 1;
  string last_name = 2;
  string email = 3;
  string phone = 4;
  int32 year_of_birth = 5;
  bool is_active = 6;
}
message CreateContactResponse {
  string contact_id = 1;
}
service ContactService {
  rpc CreateContact(CreateContactRequest) returns (CreateContactResponse);
}</pre>
<p>In the <a id="_idIndexMarker1145"/>preceding code, we define a <code>CreateContactRequest</code> message and a <code>CreateContactResponse</code> message, and then we define a <code>ContactService</code> service, which contains a <code>CreateContact()</code> RPC method. The <code>CreateContact</code> RPC method requires a <code>CreateContactRequest</code> request message and a <code>CreateContactResponse</code> response message.</p>
<p>The generated <a id="_idIndexMarker1146"/>code for the <code>CreateContact()</code> RPC method is as follows:</p>
<pre class="source-code">
public abstract partial class ContactServiceBase{
  public virtual global::System.Threading.Tasks.Task&lt;global::GrpcDemo.CreateContactResponse&gt; CreateContact(global::GrpcDemo.CreateContactRequest request, grpc::ServerCallContext context)
  {
    throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
  }
}</pre>
<p>The <code>ContactServiceBase</code> class is a base class for the service implementation. It contains the <code>CreateContact()</code> method, which is a <code>virtual</code> method. By default, the <code>CreateContact()</code> method throws an exception because the method is not implemented. We need to override this method in the service implementation.</p>
<p>Next, create<a id="_idIndexMarker1147"/> a <code>ContactService.cs</code> file in the <code>Service</code> folder. In the <code>ContactService.cs</code> file, we need to implement the <code>ContactService</code> class, which is <a id="_idIndexMarker1148"/>derived from the <code>ContactServiceBase</code> class. The <code>ContactService</code> class is as follows:</p>
<pre class="source-code">
public class ContactService(ILogger&lt;ContactService&gt; logger) : Contact.ContactBase{
    public override Task&lt;CreateContactResponse&gt; CreateContact(CreateContactRequest request, ServerCallContext context)
    {
        // TODO: Save contact to database
        return Task.FromResult(new CreateContactResponse
        {
            ContactId = Guid.NewGuid().ToString()
        });
    }
}</pre>
<p>In the <a id="_idIndexMarker1149"/>preceding code, we override the <code>CreateContact()</code> method and implement the method. This <code>CreateContact()</code> method allows us to execute some logic we need, such as saving the contact to the database. For simplicity, we just return a new <code>CreateContactResponse</code> object with a new <code>ContactId</code> value. In reality, we may have additional logic.</p>
<p>Next, we need to register the <code>ContactService</code> class in the DI container. Open the <code>Program.cs</code> file and add the following code to the <code>ConfigureServices()</code> method:</p>
<pre class="source-code">
app.MapGrpcService&lt;ContactService&gt;();</pre> <p>Our new <a id="_idIndexMarker1150"/>unary service simplifies the process of handling HTTP requests, eliminating the need to write any code or manage different HTTP methods. All RPC calls are handled by the gRPC framework, allowing for a streamlined process.</p>
<p>To call a gRPC service, a gRPC client must be created as current browsers do not support this protocol. Alternatively, tools such as Postman can be used to access the service. In the following section, we will demonstrate how to create a console application to<a id="_idTextAnchor469"/> call the service.</p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor470"/>Creating a gRPC client</h2>
<p>A gRPC can <a id="_idIndexMarker1151"/>be a console application, a web application, or any other type of application, such as a WPF application. In this section, we will create a console application as the gRPC client for the unary service we created in the previous section. You can use similar code in other types of applications. Follow these steps:</p>
<ol>
<li>Use the <code>dotnet new</code> command to create a new console project:<pre class="source-code">
<strong class="bold">dotnet new console -o GrpcDemo.Client</strong></pre></li> <li>Now, we have two projects. If you have not created a solution file, you can create it by running the following command:<pre class="source-code">
<strong class="bold">dotnet new sln -n GrpcDemo</strong></pre></li> <li>Then, add the two projects to the solution:<pre class="source-code">
<code>GrpcDemo.Client</code> folder and add the <code>Grpc.Net.Client</code> package to the project:<pre class="source-code">
<strong class="bold">cd GrpcDemo.Client</strong><strong class="bold">dotnet add GrpcDemo.Client.csproj package Grpc.Net.Client</strong></pre></li> <li>To use the gRPC tooling to generate the client code, we also need to add the following packages:<pre class="source-code">
<code>Grpc.Tools</code> package contains code-generation tooling for gRPC. It is a development-time dependency, which means that it is not required at runtime. So, we need to add the <code>&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;</code> element to the <code>Grpc.Tools</code> package to ensure that the package is not included in the published application.</pre></li> <li>Next, copy <a id="_idIndexMarker1153"/>the <code>Protos</code> folder from the <code>GrpcDemo</code> project to the <code>GrpcDemo.Client</code> project. Then, add the following code to the <code>GrpcDemo.Client.csproj</code> file:<pre class="source-code">
&lt;ItemGroup&gt;  &lt;Protobuf Include="Protos\greet.proto" GrpcServices="Client" OutputDir="Generated"/&gt;  &lt;Protobuf Include="Protos\invoice.proto" GrpcServices="Client"  OutputDir="Generated"/&gt;  &lt;Protobuf Include="Protos\demo.proto" GrpcServices="Client"  OutputDir="Generated"/&gt;&lt;/ItemGroup&gt;</pre><p class="list-inset">Similar to the <code>GrpcDemo</code> project, we use the <code>Protobuf</code> element to specify the proto files and the output directory. The <code>GrpcServices</code> attribute is used to specify the type of the generated code. In this case, we use <code>Client</code> because we are creating a gRPC client.</p><p class="list-inset">When you make changes to the proto files in the <code>GrpcDemo</code> project, do not forget to copy the changes to the <code>GrpcDemo.Client</code> project to ensure that the client code is up to date.</p><p class="list-inset">In the <code>Generated/Protos</code> folder, you will find the generated code for each proto file. For<a id="_idIndexMarker1154"/> example, the <code>invoice.proto</code> file will generate the following files:</p><ul><li><code>Invoice.cs</code>: This file contains the definition of the messages in the <code>invoice.proto</code> file</li><li><code>InvoiceGrpc.cs</code>: This file contains the gRPC client code for the services in the <code>invoice.proto</code> file</li></ul></li> <li>Next, let’s create an <code>InvoiceClient.cs</code> file in the project root folder and add the following code:<pre class="source-code">
using Grpc.Net.Client;namespace GrpcDemo.Client;internal class InvoiceClient{    public async Task CreateContactAsync()    {        using var channel = GrpcChannel.ForAddress("http://localhost:5269");        var client = new Contact.ContactClient(channel);        var reply = await client.CreateContactAsync(new CreateContactRequest()        {            Email = "john.doe@abc.com",            FirstName = "John",            LastName = "Doe",            IsActive = true,            Phone = "1234567890",            YearOfBirth = 1980        });        Console.WriteLine("Created Contact: " + reply.ContactId);        Console.ReadKey();    }}</pre><p class="list-inset">In the preceding code, we use the <code>GrpcChannel.ForAddress()</code> method to create a gRPC channel, which accepts the address of the gRPC server.</p></li> <li>To get the<a id="_idIndexMarker1155"/> address of the gRPC server, you can use the <code>dotnet run</code> command in the <code>GrpcDemo</code> project to start the gRPC server. The following output shows the address of the gRPC server:<pre class="source-code">
info: Microsoft.Hosting.Lifetime[14]      Now listening on: http://localhost:5269info: Microsoft.Hosting.Lifetime[0]      Application started. Press Ctrl+C to shut down.info: Microsoft.Hosting.Lifetime[0]      Hosting environment: Development</pre></li> <li>Alternatively, you can check the <code>applicationUrl</code> property in the <code>Properties/launchSettings.json</code> file. The following code shows the <code>applicationUrl</code> property:<pre class="source-code">
{  "$schema": "http://json.schemastore.org/launchsettings.json",  "profiles": {    "http": {      ...      "applicationUrl": "http://localhost:5269",      ...    },    "https": {      ...      "applicationUrl": "https://localhost:7179;http://localhost:5269",      ...    }  }}</pre><p class="list-inset">A gRPC <a id="_idIndexMarker1156"/>channel is used to establish a connection to the gRPC server on the specified address and port. Once we have the gRPC channel, we can create an instance of the <code>ContactClient</code> class, which is generated from the proto file. Then, we call the <code>CreateContactAsync()</code> method to create a contact. The <code>CreateContactAsync()</code> method accepts a <code>CreateContactRequest</code> object as the parameter. The <code>CreateContactAsync()</code> method returns a <code>CreateContactResponse</code> object, which contains the <code>ContactId</code> value. At the end of the method, we print the <code>ContactId</code> value to the console.</p><p class="list-inset">This method is straightforward. There are a few things to note:</p><ul><li>Creating a gRPC channel is an expensive operation. So, it is recommended to reuse the gRPC channel. However, a gRPC client is a lightweight object, so there is no need to reuse it.</li><li>You can create multiple gRPC clients from one gRPC channel, and you can safely use multiple gRPC clients concurrently.</li></ul></li> <li>To secure the<a id="_idIndexMarker1157"/> gRPC channel using TLS, you need to run the gRPC service with HTTPS. For example, you can use the following command to run the gRPC service:<pre class="source-code">
<strong class="bold">dotnet run --urls=https://localhost:7179</strong></pre></li> <li>Then, you can use the HTTPS address to create the gRPC channel:<pre class="source-code">
<code>Program.cs</code> file, call the <code>CreateContactAsync()</code> method, as follows:<pre class="source-code">
var contactClient = new InvoiceClient();await contactClient.CreateContactAsync();</pre></li> <li>Run the gRPC server and the gRPC client in different terminals. By doing this, you will be able to see the following output in the gRPC client terminal:<pre class="source-code">
<strong class="bold">Created Contact: 3193c36c-2aab-49a7-a0b1-6bdb3b69dea1</strong></pre></li> </ol>
<p>This is a simple example of a gRPC client in a console application. In the next section, we will create a server streaming service and the c<a id="_idTextAnchor471"/>orresponding gRPC client.</p>
<h2 id="_idParaDest-244"><a id="_idTextAnchor472"/>Defining a server streaming service</h2>
<p>Similar to a <a id="_idIndexMarker1158"/>unary service, a server<a id="_idIndexMarker1159"/> streaming service has a request message and a response message. The difference is that the response message is a stream message. Once the server starts to send the stream response message, the client cannot send any more messages to the server, unless the server finishes sending the stream response message or the client cancels the RPC call by raising <code>ServerCallContext.CancellationToken</code>.</p>
<p>The server streaming service is useful when we need to send a stream of data to the client. In this case, the server can send multiple messages to the client over a single RPC call. Here are some <a id="_idIndexMarker1160"/>scenarios where a server streaming service is useful:</p>
<ul>
<li><strong class="bold">Events streaming</strong>: When the server needs to send a stream of event messages to the client so that the client can process the event messages.</li>
<li><strong class="bold">Real-time data feeds</strong>: When the server has a continuous stream of data to send to the client, such as stock prices, weather data, and so on.</li>
<li><strong class="bold">File streaming</strong>: When the server needs to send a large file to the client, the server can split the file into small chunks and send them one by one as a stream response message. This can reduce the memory usage on the server and the client because the server and the client do not need to load the entire file into memory.</li>
</ul>
<p>The following code shows a server streaming service with the required message types:</p>
<pre class="source-code">
message GetRandomNumbersRequest {  int32 min = 1;
  int32 max = 2;
  int32 count = 3;
}
message GetRandomNumbersResponse {
  int32 number = 1;
}
service RandomNumbers {
  rpc GetRandomNumbers(GetRandomNumbersRequest) returns (stream GetRandomNumbersResponse);
}</pre>
<p>In the preceding proto file, we define two messages named <code>GetRandomNumbersRequest</code> and <code>GetRandomNumbersResponse</code>. Then, we define a <code>RandomNumbers</code> service, which contains a <code>GetRandomNumbers()</code> RPC method. Note that the response message of the <code>GetRandomNumbers</code> RPC method is annotated with the <code>stream</code> keyword. This means that the response message is a stream message.</p>
<p>The generated <a id="_idIndexMarker1161"/>code for the <code>GetRandomNumbers()</code> RPC method is as follows:</p>
<pre class="source-code">
[grpc::BindServiceMethod(typeof(RandomNumbers), "BindService")]public abstract partial class RandomNumbersBase
{
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  public virtual global::System.Threading.Tasks.Task GetRandomNumbers(global::GrpcDemo.GetRandomNumbersRequest request, grpc::IServerStreamWriter&lt;global::GrpcDemo.GetRandomNumbersResponse&gt; responseStream, grpc::ServerCallContext context)
  {
    throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
  }
}</pre>
<p>In the generated code, we can see that the type of the response message is <code>IServerStreamWriter&lt;GetRandomNumbersResponse&gt;</code>. Let’s add a simple implementation for the <code>RandomNumbers</code> service. Follow these steps:</p>
<ol>
<li>Create a <code>RandomNumbersService.cs</code> file in the <code>Service</code> folder and add the <a id="_idIndexMarker1162"/>following code:<pre class="source-code">
public class RandomNumbersService(ILogger&lt;RandomNumbersService&gt; logger) : RandomNumbers.RandomNumbersBase{    public override async Task GetRandomNumbers(GetRandomNumbersRequest request,        IServerStreamWriter&lt;GetRandomNumbersResponse&gt; responseStream, ServerCallContext context)    {        var random = new Random();        for (var i = 0; i &lt; request.Count; i++)        {            await responseStream.WriteAsync(new GetRandomNumbersResponse            {                Number = random.Next(request.Min, request.Max)            });            await Task.Delay(1000);        }    }}</pre><p class="list-inset">In the implementation of the <code>GetRandomNumbers()</code> method, we use a <code>for</code> loop to generate random numbers and send them to the client every second. Note that we use the <code>responseStream.WriteAsync()</code> method to send the stream response message to the client. The message finishes sending when the loop ends.</p></li> <li>If we need a <a id="_idIndexMarker1163"/>continuous stream response message, we can check the <code>ServerCallContext.CancellationToken</code> property of the <code>context</code> parameter. If the client cancels the RPC call, the <code>ServerCallContext.CancellationToken</code> property will be raised. The following code shows how to check the <code>ServerCallContext.CancellationToken</code> property:<pre class="source-code">
public override async Task GetRandomNumbers(GetRandomNumbersRequest request,    IServerStreamWriter&lt;GetRandomNumbersResponse&gt; responseStream, ServerCallContext context){    var random = new Random();    while (!context.CancellationToken.IsCancellationRequested)    {        await responseStream.WriteAsync(new GetRandomNumbersResponse        {            Number = random.Next(request.Min, request.Max)        });        await Task.Delay(1000, context.CancellationToken);    }}</pre><p class="list-inset">In the preceding code, we use a <code>while</code> loop to check the <code>ServerCallContext.CancellationToken</code> property. If the client cancels the RPC call, the <code>ServerCallContext.CancellationToken</code> property will be raised, and the <code>while</code> loop will end. If there are any other asynchronous operations in the method, we can pass the <code>ServerCallContext.CancellationToken</code> property to the asynchronous operations. This can ensure that the asynchronous operations will be canceled when the client cancels the RPC call.</p></li> <li>Next, we<a id="_idIndexMarker1164"/> will register the <code>RandomNumbersService</code> class in the DI  container. Open the <code>Program.cs</code> file and add the following code:<pre class="source-code">
app.MapGrpcService&lt;RandomNumbersService&gt;();</pre></li> <li>Next, we will create a gRPC client to call the <code>GetRandomNumbers()</code> RPC method. Create a <code>RandomNumbersClient.cs</code> file in the project root folder and add the following code:<pre class="source-code">
internal class ServerStreamingClient{    public async Task GetRandomNumbers()    {        using var channel = GrpcChannel.ForAddress("https://localhost:7179");        var client = new RandomNumbers.RandomNumbersClient(channel);        var reply = client.GetRandomNumbers(new GetRandomNumbersRequest()        {            Count = 100,            Max = 100,            Min = 1        });        await foreach (var number in reply.ResponseStream.ReadAllAsync())        {            Console.WriteLine(number.Number);        }        Console.ReadKey();    }}</pre><p class="list-inset">The code<a id="_idIndexMarker1165"/> to create the client is similar to that of <code>InvoiceClient</code>, which we introduced in the <em class="italic">Creating a gRPC client</em> section. The only difference is in the response message, which is handled using the <code>await foreach</code> statement. The <code>ReadAllAsync()</code> method returns an <code>IAsyncEnumerable&lt;T&gt;</code> object, which can be iterated over using the <code>await </code><code>foreach</code> statement.</p></li> <li>In the <code>Program.cs</code> file of the <code>GrpcDemo.Client</code> project, call the <code>GetRandomNumbers()</code> method, as follows:<pre class="source-code">
var serverStreamingClient = new ServerStreamingClient();await serverStreamingClient.GetRandomNumbers();</pre></li> <li>Run the gRPC server and the gRPC client in different terminals. You will see that the output contains a series of random numbers.</li>
</ol>
<p>This is an example of a server streaming service and the corresponding gRPC client. In the next section, we will create a client streaming service a<a id="_idTextAnchor473"/>nd the corresponding gRPC client.</p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor474"/>Defining a client streaming service</h2>
<p>A<a id="_idIndexMarker1166"/> client streaming service allows the<a id="_idIndexMarker1167"/> client to send a stream of messages to the server over a single request. The server then sends a single response message to the client when it finishes processing the stream request messages. Once the server sends the response message, the client streaming call is complete.</p>
<p>Here are some scenarios where a<a id="_idIndexMarker1168"/> client streaming service is useful:</p>
<ul>
<li><strong class="bold">File uploading</strong>: When the client uploads a large file to the server, the client can split the file into small chunks and send them one by one as a stream request message, which can be more efficient than sending the entire file in a single request.</li>
<li><strong class="bold">Real-time data capture</strong>: When the client needs to send a stream of data to the server, such as sensor data, user interactions, or any continuous stream of data, the server can process the data and respond to the batch of data.</li>
<li><strong class="bold">Data aggregation</strong>: When the client needs to send a batch of data to the server for aggregation or analysis.</li>
</ul>
<p>To define a client streaming service, we need to use the <code>stream</code> keyword to annotate the request message. The following code shows a client streaming service with the required message types:</p>
<pre class="source-code">
message SendRandomNumbersRequest {  int32 number = 1;
}
message SendRandomNumbersResponse {
  int32 count = 1;
  int32 sum = 2;
}
service RandomNumbers {
  rpc SendRandomNumbers(stream SendRandomNumbersRequest) returns (SendRandomNumbersResponse);
}</pre>
<p>The<a id="_idIndexMarker1169"/> preceding <code>.proto</code> file defines two messages: <code>SendRandomNumbersRequest</code> and <code>SendRandomNumbersResponse</code>. The client sends a stream message containing a series of numbers to the server. The server then processes the stream message and calculates the sum of the numbers. Finally, the server sends a response message to the client, which contains the count of the numbers and the sum of the numbers. It is important to note that the <code>SendRandomNumbers()</code> RPC method is annotated with the <code>stream</code> keyword, indicating that the request message is a stream message.</p>
<p>Similar to the server streaming service, we can implement the <code>SendRandomNumbers()</code> method, as follows:</p>
<pre class="source-code">
public override async Task&lt;SendRandomNumbersResponse&gt; SendRandomNumbers(IAsyncStreamReader&lt;SendRandomNumbersRequest&gt; requestStream, ServerCallContext context){
    var count = 0;
    var sum = 0;
    await foreach (var request in requestStream.ReadAllAsync())
    {
        _logger.LogInformation($"Received: {request.Number}");
        count++;
        sum += request.Number;
    }
    return new SendRandomNumbersResponse
    {
        Count = count,
        Sum = sum
    };
}</pre>
<p>We utilize the <code>IAsyncStreamReader&lt;T&gt;.ReadAllAsync()</code> method in the preceding code to read all the stream request messages from the client. Subsequently, we use <code>await foreach</code> to iterate over the stream request messages. Lastly, we compute the count and sum of the numbers and return a <code>SendRandomNumbersResponse</code> object.</p>
<p>To <a id="_idIndexMarker1170"/>consume the client streaming service, we will copy the proto files from the <code>GrpcDemo</code> project to the <code>GrpcDemo.Client</code> project. Then, we will create a <code>ClientStreamingClient</code> class in the <code>GrpcDemo.Client</code> project and add the following code:</p>
<pre class="source-code">
internal class ClientStreamingClient{
    public async Task SendRandomNumbers()
    {
        using var channel = GrpcChannel.ForAddress("https://localhost:7179");
        var client = new RandomNumbers.RandomNumbersClient(channel);
        // Create a streaming request
        using var clientStreamingCall = client.SendRandomNumbers();
        var random = new Random();
        for (var i = 0; i &lt; 20; i++)
        {
            await clientStreamingCall.RequestStream.WriteAsync(new SendRandomNumbersRequest
            {
                Number = random.Next(1, 100)
            });
            await Task.Delay(1000);
        }
        await clientStreamingCall.RequestStream.CompleteAsync();
        // Get the response
        var response = await clientStreamingCall;
        Console.WriteLine($"Count: {response.Count}, Sum: {response.Sum}");
        Console.ReadKey();
    }
}</pre>
<p>In <a id="_idIndexMarker1171"/>the <code>SendRandomNumbers()</code> method, we create an <code>AsyncClientStreamingCall</code> object by calling the <code>SendRandomNumbers()</code> method of the <code>RandomNumbersClient</code> class. Note that the client streaming call starts when the <code>SendRandomNumbers()</code> method is called, but the client does not send any messages until the <code>RequestStream.CompleteAsync()</code> method is called. In a <code>for</code> loop, we use the <code>RequestStream.WriteAsync()</code> method to send the stream request message to the server. At the end of the method, we call the <code>RequestStream.CompleteAsync()</code> method to indicate that the stream request message is complete. The stream request message contains 20 numbers, which are generated randomly.</p>
<p>In the <code>Program.cs</code> file of the <code>GrpcDemo.Client</code> project, we then call the <code>SendRandomNumbers()</code> method, as follows:</p>
<pre class="source-code">
var clientStreamingClient = new ClientStreamingClient();await clientStreamingClient.SendRandomNumbers();</pre>
<p>Run the <a id="_idIndexMarker1172"/>gRPC server and the gRPC client in different terminals. After around 20 seconds, you will see the following output in the gRPC client terminal (the sum may be different):</p>
<pre class="source-code">
Count: 20, Sum: 1000</pre> <p>With that, we’ve learned how to create a client streaming service and the corresponding gRPC client. In the next section, we will create a bidirectional streaming se<a id="_idTextAnchor475"/>rvice and the corresponding gRPC client.</p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor476"/>Defining a bidirectional streaming service</h2>
<p>A<a id="_idIndexMarker1173"/> bidirectional streaming <a id="_idIndexMarker1174"/>service allows the client and the server to send a stream of messages to each other over a single request concurrently. Once the connection has been established, the client and the server can send messages to each other at any time in any order because the two streams are independent. For example, the server can respond to each message from the client, or the server can send a response message after receiving a series of messages from the client.</p>
<p>Here are some scenarios <a id="_idIndexMarker1175"/>where a bidirectional streaming service is useful:</p>
<ul>
<li><strong class="bold">Chat applications</strong>: When the client and the server need to send instant messages to each other</li>
<li><strong class="bold">Real-time data dashboard</strong>: When the client continuously sends data to the server and the server builds a real-time dashboard to display the data</li>
<li><strong class="bold">Multiplayer games</strong>: When the players need to interact with each other in real-time and the server needs to synchronize the game state between the players</li>
</ul>
<p>Let’s define <a id="_idIndexMarker1176"/>a bidirectional streaming service. In this example, the client sends some sentences to the server and the server responds to each sentence with the uppercase version <a id="_idIndexMarker1177"/>of the sentence. The following code shows the required message types:</p>
<pre class="source-code">
message ChatMessage {  string sender = 1;
  string message = 1;
}
service Chat {
  rpc SendMessage(stream ChatMessage) returns (stream ChatMessage);
}</pre>
<p>In the preceding proto file, we have defined a <code>ChatMessage</code> message containing two fields: <code>sender</code> and <code>message</code>. Additionally, we have defined a <code>Chat</code> service with a <code>SendMessage</code> RPC method. It is important to note that both the request and response of this method are annotated with the <code>stream</code> keyword, indicating that they are both stream messages.</p>
<p>Now, we can implement the <code>SendMessage()</code> method. Follow these steps:</p>
<ol>
<li>Create a <code>ChatService.cs</code> file in the <code>Service</code> folder and add the following code:<pre class="source-code">
public class ChatService(ILogger&lt;ChatService&gt; logger) : Chat.ChatBase{    public override async Task SendMessage(IAsyncStreamReader&lt;ChatMessage&gt; requestStream, IServerStreamWriter&lt;ChatMessage&gt; responseStream, ServerCallContext context)    {        await foreach (var request in requestStream.ReadAllAsync())        {            logger.LogInformation($"Received: {request.Message}");            await responseStream.WriteAsync(new ChatMessage            {                Message = $"You said: {request.Message.ToUpper()}"            });        }    }}</pre><p class="list-inset">Here, we<a id="_idIndexMarker1178"/> utilize the <code>await foreach</code> method to iterate over the stream request messages. For each request message, we use the <code>WriteAsync()</code> method to send a response message back to the client. This response message contains the uppercase version of the request message.</p></li> <li>Next, register the <code>ChatService</code> class in the dependency injection container. Open the <code>Program.cs</code> file and add the following code:<pre class="source-code">
<code>GrpcDemo</code> project to the <code>GrpcDemo.Client</code> project. Then, create a <code>BidirectionalStreamingClient</code> class in the <code>GrpcDemo.Client</code> project and add the following code:<pre class="source-code">
internal class BidirectionalStreamingClient{    public async Task SendMessage()    {        using var channel = GrpcChannel.ForAddress("https://localhost:7179");        var client = new Chat.ChatClient(channel);        // Create a streaming request        using var streamingCall = client.SendMessage();        Console.WriteLine("Starting a background task to receive messages...");        var responseReaderTask = Task.Run(async () =&gt;        {            await foreach (var response in streamingCall.ResponseStream.ReadAllAsync())            {                Console.WriteLine(response.Message);            }        });        Console.WriteLine("Starting to send messages...");        Console.WriteLine("Input your message then press enter to send it.");        while (true)        {            var message = Console.ReadLine();            if (string.IsNullOrWhiteSpace(message))            {                break;            }            await streamingCall.RequestStream.WriteAsync(new ChatMessage            {                Message = message            });        }        Console.WriteLine("Disconnecting...");        await streamingCall.RequestStream.CompleteAsync();        await responseReaderTask;    }}</pre><p class="list-inset">Because we<a id="_idIndexMarker1179"/> use a console application to call the bidirectional streaming service, we need to use a background task to read the stream response messages. The <code>ReadAllAsync()</code> method returns an <code>IAsyncEnumerable&lt;T&gt;</code> object, which can be iterated over using the <code>await foreach</code> statement. In the background task, we use the <code>await foreach</code> statement to iterate over the stream response messages and print them to the console.</p><p class="list-inset">Additionally, we use a <code>while</code> loop to read the input from the console and send the stream request messages to the server in the main thread. The <code>while</code> loop ends when the user enters an empty string. At the end of the method, we call the <code>RequestStream.CompleteAsync()</code> method to indicate that the stream request message is complete so that the server can finish processing the stream request messages gracefully.</p></li> <li>In the <code>Program.cs</code> file of the <code>GrpcDemo.Client</code> project, call the <code>SendMessage()</code> method, as follows:<pre class="source-code">
var bidirectionalStreamingClient = new BidirectionalStreamingClient();await bidirectionalStreamingClient.SendMessage();</pre></li> <li>Run the <a id="_idIndexMarker1180"/>gRPC server and the gRPC client in different terminals. You will see the following output in the gRPC client terminal:<pre class="source-code">
Hello, World!Starting background task to receive messages...Starting to send messages...Input your message then press enter to send it.How are you?You said: HOW ARE YOU?What is ASP.NET Core?You said: WHAT IS ASP.NET CORE?Disconnecting...</pre></li> </ol>
<p>This example is a simple demonstration of a bidirectional streaming service and the corresponding gRPC client. The bidirectional streaming service allows the client and the server to send a stream of messages to each other at any time in any order. In the preceding example, the service responds to each message from the client. However, using similar code, we can implement more complex logic per the requirements.</p>
<p>We have now explored four types of gRPC services: unary, server streaming, client streaming, and bidirectional streaming. We have also learned how to create a gRPC client to call each of these gRPC services. In the next section, we will learn how to<a id="_idTextAnchor477"/> use gRPC services in ASP.NET Core applications.</p>
<h1 id="_idParaDest-247"><a id="_idTextAnchor478"/>Consuming gRPC services in ASP.NET Core applications</h1>
<p>In the <a id="_idIndexMarker1181"/>previous section, we learned how to create console applications to consume gRPC services. In this section, we<a id="_idIndexMarker1182"/> will integrate gRPC services into ASP.NET Core applications. We will reuse the gRPC services we created in the previous section, and we will create a new ASP.NET Core application to consume the gRPC services.</p>
<p>To get started with the steps outlined in this section, begin with the <code>GrpcDemo-v3</code> folder of the source code. The complete code for this section can be found in the <code>GrpcDemo-v4</code> folder.</p>
<p>In the console applications, we used the <code>GrpcChannel</code> class to create a gRPC channel, after which we used the gRPC channel to create a gRPC client, as shown in the following code:</p>
<pre class="source-code">
using var channel = GrpcChannel.ForAddress("https://localhost:7179");var client = new Contact.ContactClient(channel);</pre>
<p>In ASP.NET Core applications, a better way to create a gRPC client is to use the <code>IHttpClientFactory</code> interface with dependency injection. Let’s see how to use the DI container to create a gRPC client:</p>
<ol>
<li>First, we must create a new ASP.NET Core application. In this ASP.NET Core application, we will create a REST API to consume the gRPC services we created in the previous section. Use the <code>dotnet new</code> command to create a new ASP.NET Core application:<pre class="source-code">
<strong class="bold">dotnet new webapi -o GrpcDemo.Api -controllers</strong></pre></li> <li>Then, add this project to the solution:<pre class="source-code">
<code>Grpc.Net.ClientFactory</code> and <code>Grpc.Tools</code> packages to the <a id="_idIndexMarker1183"/>project:<pre class="source-code">
<code>Grpc.Net.ClientFactory</code> package allows developers to create a gRPC client using a dependency injection container, eliminating the need for the <code>new</code> keyword. Additionally, the <code>Grpc.Tools</code> package can be used to generate gRPC client code from proto files.</p></li> <li>Then, copy <a id="_idIndexMarker1184"/>the <code>Protos</code> folder from the <code>GrpcDemo</code> project to the <code>GrpcDemo.Api</code> project. Next, add the following code to the <code>GrpcDemo.Api.csproj</code> file:<pre class="source-code">
&lt;ItemGroup&gt;  &lt;Protobuf Include="Protos\greet.proto" GrpcServices="Client" OutputDir="Generated"/&gt;  &lt;Protobuf Include="Protos\invoice.proto" GrpcServices="Client"  OutputDir="Generated"/&gt;  &lt;Protobuf Include="Protos\demo.proto" GrpcServices="Client"  OutputDir="Generated"/&gt;&lt;/ItemGroup&gt;</pre><p class="list-inset">Similar to the <code>GrpcDemo.Client</code> project, we use the <code>GrpcServices="Client"</code> attribute to specify the type of the generated code. In this case, we use <code>Client</code> because we will create a gRPC client to consume the gRPC services in the ASP.NET Core application.</p></li> <li>Next, we<a id="_idIndexMarker1185"/> can register the gRPC client in the DI container. Open the <code>Program.cs</code> file and add the following code:<pre class="source-code">
<code>ContactController.cs</code> file in the <code>Controllers</code> folder and add the following code:<pre class="source-code">
[ApiController][Route("[controller]")]public class ContactController(Contact.ContactClient client, ILogger&lt;ContactController&gt; logger) : ControllerBase{    [HttpPost]    public async Task&lt;IActionResult&gt; CreateContact(CreateContactRequest request)    {        var reply = await _client.CreateContactAsync(request);        return Ok(reply);    }}</pre><p class="list-inset">In the <code>ContactController</code> class, we use dependency injection to inject the gRPC client, <code>ContactClient</code>, which is generated from the <code>demo.proto</code> file. Then, we create a <code>CreateContact</code> action method to call the <code>CreateContactAsync()</code> method of the <code>ContactClient</code> class. The <code>CreateContactAsync()</code> method accepts a <code>CreateContactRequest</code> object as the parameter, which is also generated from the proto file. The <code>CreateContactAsync()</code> method returns a <code>CreateContactResponse</code> object, which contains the <code>ContactId</code> value. At the end of the method, we return the <code>ContactId</code> value to the client.</p></li> <li>Run the<a id="_idIndexMarker1187"/> gRPC <a id="_idIndexMarker1188"/>server and the ASP.NET Core application in different terminals. Note that the gRPC server address must match the address specified in the <code>AddGrpcClient()</code> method. Then, you can navigate to the Swagger UI page, such as <code>http://localhost:5284/swagger/index.html</code>, to test the <code>CreateContact()</code> action method. For example, you can use the following JSON object as the request body:<pre class="source-code">
{  "firstName": "John",  "lastName": "Doe",  "email": "john.doe@example.com",  "phone": "1234567890",  "yearOfBirth": 1980,  "isActive": true}</pre><p class="list-inset">You will see the following response (the <code>contactId</code> value may be different):</p><pre class="source-code"><strong class="bold">{</strong><strong class="bold">  "contactId": "8fb43c22-143f-4131-a5f5-c3700b4f3a08"</strong><strong class="bold">}</strong></pre></li> </ol>
<p>This simple <a id="_idIndexMarker1189"/>example shows how to use the <code>AddGrpcClient()</code> method to register a gRPC client in the DI  container in ASP.NET Core applications, and how to use the gRPC client to consume<a id="_idIndexMarker1190"/> a unary gRPC service. For other types <a id="_idTextAnchor479"/>of gRPC services, you need to update the code accordingly.</p>
<h1 id="_idParaDest-248"><a id="_idTextAnchor480"/>Updating proto files</h1>
<p>gRPC is a <a id="_idIndexMarker1191"/>contract-first RPC framework. This means that the server and the client communicate with each other using a contract, which is defined in a proto file. Inevitably, the contract will change over time. In this section, we will learn how to update the contract and how to handle the changes in the server and the client.</p>
<p>Once a proto file is used in production, we need to consider backward compatibility when we update the proto file. This is because the existing clients may use the old version of the proto file, which may not be compatible with the new version of the proto file. If the new version of the contract is not backward compatible, the existing clients will break.</p>
<p>The following changes are backward compatible:</p>
<ul>
<li><strong class="bold">Adding new fields to a request message</strong>: If the client does not send the new fields, the server can use the default values of the new fields.</li>
<li><strong class="bold">Adding new fields to a response message</strong>: If the response message contains the new fields but the client does not recognize the new fields, the client will discard the new fields in proto 3. In the future version of proto, known as 3.5, this behavior will be changed to preserve the new fields as unknown fields.</li>
<li><strong class="bold">Adding a new RPC method to a service</strong>: The client that uses old versions of the proto file will not be able to call the new RPC method. However, the old RPC methods will still work.</li>
<li><strong class="bold">Adding a new service to a proto file</strong>: Similar to adding a new RPC method, the new service will not be available to the old clients, but the old services will still work.</li>
</ul>
<p>The following<a id="_idIndexMarker1192"/> changes may cause breaking changes, which require the clients to be updated accordingly:</p>
<ul>
<li>Removing a field from a message</li>
<li>Renaming a field in a message</li>
<li>Removing or renaming a message</li>
<li>Changing a data type of a field</li>
<li>Changing a field number</li>
<li>Removing or renaming a service</li>
<li>Removing or renaming an RPC method from a service</li>
<li>Renaming a package</li>
<li>Changing the <code>csharp_namespace</code> option</li>
</ul>
<p>Protobuf uses field numbers to serialize and deserialize messages. If we rename a field in a message without changing the field number and the data type, the message can still be serialized and deserialized correctly, but the field name in the .NET code will be different from the field name in the proto file. This can be confusing for developers. So, the client code needs to be updated to use the new field name.</p>
<p>Removing a field from a message is a breaking change as the field number cannot be reused. For example, if we remove the <code>year_of_birth</code> field from the <code>CreateContactRequest</code> message defined in the <em class="italic">Understanding the field types</em> section for the gRPC server, the server will deserialize field number 5 as an unknown field. This could lead to errors in serialization/de-serialization if a developer later decides to add a new field with field number 5 as a different data type while existing clients still send field number 5 as an integer value.</p>
<p>To safely remove a field, we must ensure that the removed field number is not being used in the future. To avoid any potential conflicts, we can reserve the removed field number by using the <code>reserved</code> keyword. For example, if we delete the <code>year_of_birth</code> and <code>is_active</code> fields from the <code>CreateContactRequest</code> message, we can reserve the field numbers, as follows:</p>
<pre class="source-code">
message CreateContactRequest {  reserved 5, 6;
  reserved "year_of_birth", "is_active";
  string first_name = 1;
  string last_name = 2;
  string email = 3;
  string phone = 4;
}</pre>
<p>In the preceding code, we use the <code>reserved</code> keyword to reserve field numbers 5 and 6, and the <code>year_of_birth</code> and <code>is_active</code> field names. The reserved field numbers and field names cannot be reused in the proto file. If we try to use a reserved field number or field name, the gRPC tooling will report an error.</p>
<p>Note that the<a id="_idIndexMarker1193"/> reserved field names should be listed, as well as the reserved field numbers. This ensures that the JSON and text formats are backward compatible. When the field names are reserved, they cannot be <a id="_idTextAnchor481"/>placed in the same <code>reserved</code> statement with the field numbers.</p>
<h1 id="_idParaDest-249"><a id="_idTextAnchor482"/>Summary</h1>
<p>In this chapter, we explored the fundamentals of gRPC services and clients. We discussed the field types that are used in protobuf, including the scalar types and some other types such as <code>DateTime</code>, <code>enum</code>, repeated fields, and map fields. Then, we learned about four types of gRPC services: unary, server streaming, client streaming, and bidirectional streaming. We explored how to implement each type of gRPC service and how to create a gRPC client to consume the gRPC service. Additionally, we demonstrated how to use the <code>AddGrpcClient()</code> method to register a gRPC client in the DI  container of an ASP.NET Core application and how to use the gRPC client to consume a unary gRPC service. Finally, we discussed how to update the proto files and how to handle the changes in the server and the client.</p>
<p>To simplify the code samples, we did not use any database access code in the gRPC services. In a real-world application, we may need to interact with a database or other external services in the gRPC services. You can follow the same approach as you do in REST API services.</p>
<p>gRPC is suitable for building high-performance service-to-service communication. Due to this book’s content limitations, we only covered the basics of gRPC. We did not cover advanced topics such as authentication, error handling, performance tuning, and others. However, this chapter should be enough to get you started with gRPC.</p>
<p>In the next chapter, we will explore GraphQL, an alternative approach to web APIs. GraphQL provides clients with the ability to request only the data they need, making it easier to modify APIs over time and enabling the use of powerful developer tools.</p>
<h2 id="_idParaDest-250"><a id="_idTextAnchor483"/>Further reading</h2>
<p>To learn more about gRPC on .NET Core, please refer to the following resources:</p>
<ul>
<li><a href="https://protobuf.dev/">https://protobuf.dev/</a></li>
<li><a href="https://grpc.io/docs/languages/csharp/">https://grpc.io/docs/languages/csharp/</a></li>
<li><a href="https://learn.microsoft.com/en-us/aspnet/core/grpc/">https://learn.microsoft.com/en-us/aspnet/core/grpc/</a></li>
</ul>
</div>
</body></html>