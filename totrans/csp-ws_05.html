<html><head></head><body>
<div id="sbo-rt-content"><div>
<div class="Content" id="_idContainer123">
</div>
</div>
<div class="Content" id="_idContainer124">
<h1 id="_idParaDest-184"><a id="_idTextAnchor205"/>5. Concurrency: Multithreading Parallel and Async Code</h1>
</div>
<div class="Content" id="_idContainer129">
<p class="callout-heading">Overview</p>
<p class="callout">C# and .NET provide a highly effective way to run concurrent code, making it easy to perform complex and often time-consuming actions. In this chapter, you will explore the various patterns that are available, from creating tasks using the <strong class="source-inline">Task</strong> factory methods to continuations to link tasks together, before moving on to the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> keywords, which vastly simplify such code. By the end of this chapter, you will see how C# can be used to execute code that runs concurrently and often produces results far quicker than a single-threaded application.</p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor206"/>Introduction</h1>
<p>Concurrency is a generalized term that describes the ability of software to do more than one thing at the same time. By harnessing the power of concurrency, you can provide a more responsive user interface by offloading CPU-intensive activities from the main UI thread. On the server side, taking advantage of modern processing power through multi-processor and multi-core architectures, scalability can be achieved by processing operations in parallel.</p>
<p>Multithreading is a form of concurrency whereby multiple threads are used to perform operations. This is typically achieved by creating many <strong class="source-inline">Thread</strong> instances and coordinating operations between them. It is regarded as a legacy implementation, having largely been replaced by parallel and async programming; you may well find it used in older projects.</p>
<p>Parallel programming is a class of multithreading where similar operations are run independently of each other. Typically, the same operation is repeated using multiple loops, where the parameters or target of the operation themselves vary by iteration. .NET provides libraries that shield developers from the low-level complexities of thread creation. The phrase <strong class="bold">embarrassingly parallel</strong> is often used to describe an activity that requires little extra effort to be broken down into a set of tasks that can be run in parallel, often where there are few interactions between sub-tasks. One such example of parallel programming could be counting the number of words found in each text file within a folder. The job of opening a file and scanning through the words can be split into parallel tasks. Each task executes the same lines of code but is given a different text file to process.</p>
<p>Asynchronous programming is a more recent form of concurrency where an operation, once started, will complete at some point in the future, and the calling code is able to continue with other operations. This completion is often known as a <strong class="bold">promise</strong> (or a future in other languages) and is implemented through the task and its generic <strong class="source-inline">Task&lt;&gt;</strong> equivalent. In C# and .NET, async programming has become the preferred means to achieve concurrent operations.</p>
<p>A common application of asynchronous programming is where multiple slow-running or expensive dependencies need to be initialized and marshaled prior to calling a final step that should be called only when all or some of the dependencies are ready to be used. For example, a mobile hiking application may need to wait for a reliable GPS satellite signal, a planned navigation route, and a heart-rate monitoring service to be ready before the user can start hiking safely. Each of these distinct steps would be initialized using a dedicated task.</p>
<p>Another very common use case for asynchronous programming occurs in UI applications where, for example, saving a customer's order to a database could take 5-10 seconds to complete. This may involve validating the order, opening a connection to a remote server or database, packaging and sending the order in a format that can be transmitted over the wire, and then finally waiting for confirmation that the customer's order has been successfully stored in a database. In a single-threaded application, this would take much longer, and this delay would soon be noticed by the user. The application would become unresponsive until the operation was completed. In this scenario, the user may rightly think the application has crashed and may try to close it. That is not an ideal user experience.</p>
<p>Such issues can be mitigated by using async code that performs any of the slow operations using a dedicated task for each. These tasks may choose to provide feedback as they progress, which the UI's main thread can use to notify the user. Overall, the operation should complete sooner, thus freeing the user to continue interacting with the app. In modern applications, users have come to expect this method of operation. In fact, many UI guidelines suggest that if an operation may take more than a few seconds to complete, then it should be performed using async code.</p>
<p>Note that when code is executing, whether it's synchronous or asynchronous code, it is run within the context of a <strong class="source-inline">Thread</strong> instance. In the case of asynchronous code, this <strong class="source-inline">Thread</strong> instance is chosen by the .NET scheduler from a pool of available threads.</p>
<p>The <strong class="source-inline">Thread</strong> class has various properties but one of the most useful is <strong class="source-inline">ManagedThreadId</strong>, which will be used extensively throughout this chapter. This integer value serves to uniquely identify a thread within your process. By examining <strong class="source-inline">Thread.ManagedThreadId</strong>, you can determine that multiple thread instances are being used. This can be done by accessing the <strong class="source-inline">Thread</strong> instance from within your code using the static <strong class="source-inline">Thread.CurrentThread</strong> method.</p>
<p>For example, if you started five long-running tasks and examined the <strong class="source-inline">Thread.ManagedThreadId</strong> for each, you would observe five unique IDs, possibly numbered as two, three, four, five, and six. In most cases, the thread with ID number one is the process's main thread, created when the process first starts.</p>
<p>Keeping track of thread IDs can be quite useful, especially when you have time-consuming operations to perform. As you have seen, using concurrent programming, multiple operations can be executed at the same time, rather than using a traditional single-threaded approach, where one operation must complete before a subsequent operation can start.</p>
<p>In the physical world, consider the case of building a train tunnel through a mountain. Starting at one side of a mountain and tunneling through to the other side could be made considerably faster if two teams started on opposite sides of the mountain, both tunneling toward each other. The two teams could be left to work independently; any issues experienced by a team on one side should not have an adverse effect on the other side's team. Once both sides have completed their tunneling, there should be one single tunnel, and the construction could then continue with the next task, such as laying the train line.</p>
<p>The next section will look at using the C# <strong class="source-inline">Task</strong> class, which allows you to execute blocks of code at the same time and independently of each other. Consider again the example of the UI app, where the customer's order needs to be saved to a database. For this, you would have two options:</p>
<p>Option 1 is to create a C# <strong class="source-inline">Task</strong> that performs each step one after another:</p>
<ul>
<li>Validate the order.</li>
<li>Connect to the server.</li>
<li>Send the request.</li>
<li>Wait for a response.</li>
</ul>
<p>Option 2 is to create a C# <strong class="source-inline">Task</strong> for each of the steps, executing each in parallel where possible.</p>
<p>Both options achieve the same end result, freeing the UI's main thread to respond to user interactions. Option one may well be slower to finish, but the upside is that this would require simpler code. However, Option two would be the preferred choice as you are offloading multiple steps, so it should complete sooner. Although, this could involve additional complexity as you may need to coordinate each of the individual tasks as they are complete.</p>
<p>In the upcoming sections, you will first get a look at how Option one could be approached, that is, using a single <strong class="source-inline">Task</strong> to run blocks of code, before moving on to the complexity of Option two where multiple tasks are used and coordinated.</p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor207"/>Running Asynchronous Code Using Tasks</h1>
<p>The <strong class="source-inline">Task</strong> class is used to execute blocks of code asynchronously. Its usage has been somewhat superseded by the newer <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> keywords, but this section will cover the basics of creating tasks as they tend to be pervasive in larger or mature C# applications and form the backbone of the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> keywords.</p>
<p>In C#, there are three ways to schedule asynchronous code to run using the <strong class="source-inline">Task</strong> class and its generic equivalent <strong class="source-inline">Task&lt;T&gt;</strong>.</p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor208"/>Creating a New Task</h2>
<p>You'll start off with the simplest form, one that performs an operation but does not return a result back to the caller. You can declare a <strong class="source-inline">Task</strong> instance by calling any of the <strong class="source-inline">Task</strong> constructors and passing in an <strong class="source-inline">Action</strong> based delegate. This delegate contains the actual code to be executed at some point in the future. Many of the constructor overloads allow cancellation tokens and <strong class="bold">creation options</strong> to further control how the <strong class="source-inline">Task</strong> runs.</p>
<p>Some of the commonly used constructors are as follows:</p>
<ul>
<li><strong class="source-inline">public Task(Action action)</strong>: The <strong class="source-inline">Action</strong> delegate represents the body of code to be run.</li>
<li><strong class="source-inline">public Task(Action action, CancellationToken cancellationToken)</strong>: The <strong class="source-inline">CancellationToken</strong> parameter can be used as a way to interrupt the code that is running. Typically, this is used where the caller has been provided with a means to request that an operation be stopped, such as adding a <strong class="source-inline">Cancel</strong> button that a user can press.</li>
<li><strong class="source-inline">public Task(Action action, TaskCreationOptions creationOptions)</strong>: <strong class="source-inline">TaskCreationOptions</strong> offers a way to control how the <strong class="source-inline">Task</strong> is run, allowing you to provide hints to the scheduler that a certain <strong class="source-inline">Task</strong> might take extra time to complete. This can help when running related tasks together.</li>
</ul>
<p>The following are the most often used <strong class="source-inline">Task</strong> properties:</p>
<ul>
<li><strong class="source-inline">public bool IsCompleted { get; }</strong>: Returns <strong class="source-inline">true</strong> if the <strong class="source-inline">Task</strong> completed (completion does not indicate success).</li>
<li><strong class="source-inline">public bool IsCompletedSuccessfully { get; }</strong>: Returns <strong class="source-inline">true</strong> if the <strong class="source-inline">Task</strong> completed successfully.</li>
<li><strong class="source-inline">public bool IsCanceled { get; }</strong>: Returns <strong class="source-inline">true</strong> if the <strong class="source-inline">Task</strong> was canceled prior to completion.</li>
<li><strong class="source-inline">public bool IsFaulted { get; }</strong>: Returns <strong class="source-inline">true</strong> if the <strong class="source-inline">Task</strong> has thrown an unhandled exception prior to completion.</li>
<li><strong class="source-inline">public TaskStatus Status { get; }</strong>: Returns an indicator of the task's current status, such as <strong class="source-inline">Canceled</strong>, <strong class="source-inline">Running</strong>, or <strong class="source-inline">WaitingToRun</strong>.</li>
<li><strong class="source-inline">public AggregateException Exception { get; }</strong>: Returns the exception, if any, that caused the <strong class="source-inline">Task</strong> to end prematurely.</li>
</ul>
<p>Note that the code within the <strong class="source-inline">Action</strong> delegate is not executed until sometime after the <strong class="source-inline">Start()</strong> method is called. This may well be some milliseconds after and is determined by the .NET scheduler.</p>
<p>Start here by creating a new VS Code console app, adding a utility class named <strong class="source-inline">Logger</strong>, which you will use in the exercises and examples going forward. It will be used to log a message to the console along with the current time and current thread's <strong class="source-inline">ManagedThreadId</strong>.</p>
<p>The steps for this are as follows:</p>
<ol>
<li>Change to your source folder.</li>
<li>Create a new console app project called <strong class="source-inline">Chapter05</strong> by running the following command:<p class="source-code">source&gt;dotnet new console -o Chapter05</p></li>
<li>Rename the <strong class="source-inline">Class1.cs</strong> file to <strong class="source-inline">Logger.cs</strong> and remove all the template code.</li>
<li>Be sure to include the <strong class="source-inline">System</strong> and <strong class="source-inline">System.Threading</strong> namespaces. <strong class="source-inline">System.Threading</strong> contains the <strong class="source-inline">Threading</strong> based classes:<p class="source-code">using System;</p><p class="source-code">using System.Threading;</p><p class="source-code">namespace Chapter05</p><p class="source-code">{</p></li>
<li>Mark the <strong class="source-inline">Logger</strong> class as static so that it can be used without having to create an instance to use:<p class="source-code">    public static class Logger</p><p class="source-code">    {</p><p class="callout-heading">Note</p><p class="callout">If you use the <strong class="source-inline">Chapter05</strong> namespace, then the <strong class="source-inline">Logger</strong> class will be accessible to code in examples and activities, provided they also use the <strong class="source-inline">Chapter05</strong> namespace. If you prefer to create a folder for each example and exercise, then you should copy the file <strong class="source-inline">Logger.cs</strong> into each folder that you create.</p></li>
<li>Now declare a <strong class="source-inline">static</strong> method called <strong class="source-inline">Log</strong> that is passed a <strong class="source-inline">string message</strong> parameter:<p class="source-code">        public static void Log(string message)</p><p class="source-code">        {</p><p class="source-code">            Console.WriteLine($"{DateTime.Now:T} [{Thread.CurrentThread.ManagedThreadId:00}] {message}");</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>When invoked, this will log a message to the console window using the <strong class="source-inline">WriteLine</strong> method. In the preceding snippet, the string interpolation feature in C# is used to define a string using the <strong class="source-inline">$</strong> symbol; here, <strong class="source-inline">:T</strong> will format the current time (<strong class="source-inline">DateTime.Now</strong>) into a time-formatted string and <strong class="source-inline">:00</strong> is used to include <strong class="source-inline">Thread.ManagedThreadId</strong> with a leading 0.</p>
<p>Thus, you have created the static Logger class that will be used throughout the rest of this chapter.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/cg6c5">https://packt.link/cg6c5</a>.</p>
<p>In the next example, you will use the <strong class="source-inline">Logger</strong> class to log details when a thread is about to start and finish.</p>
<ol>
<li value="7">Start by adding a new class file called <strong class="source-inline">TaskExamples.cs</strong>:<p class="source-code">using System;</p><p class="source-code">using System.Threading;</p><p class="source-code">using System.Threading.Tasks;</p><p class="source-code">namespace Chapter05.Examples</p><p class="source-code">{</p><p class="source-code">    class TaskExamples</p><p class="source-code">    {</p></li>
<li>The <strong class="source-inline">Main</strong> entry point will log that <strong class="source-inline">taskA</strong> is being created:<p class="source-code">        public static void Main()</p><p class="source-code">        {</p><p class="source-code">            Logger.Log("Creating taskA");</p></li>
<li>Next, add the following code:<p class="source-code">            var taskA = new Task(() =&gt;</p><p class="source-code">            {</p><p class="source-code">                Logger.Log("Inside taskA");</p><p class="source-code">                Thread.Sleep(TimeSpan.FromSeconds(5D));</p><p class="source-code">                Logger.Log("Leaving taskA");</p><p class="source-code">            });</p></li>
</ol>
<p>Here, the simplest <strong class="source-inline">Task</strong> constructor is passed an <strong class="source-inline">Action</strong> lambda statement, which is the actual target code that you want to execute. The target code writes the message <strong class="source-inline">Inside taskA</strong> to the console. It pauses for five seconds using <strong class="source-inline">Thread.Sleep</strong> to block the current thread, thus simulating a long-running activity, before finally writing <strong class="source-inline">Leaving taskA</strong> to the console.</p>
<ol>
<li value="10">Now that you have created <strong class="source-inline">taskA</strong>, confirm that it will only invoke its target code when the <strong class="source-inline">Start()</strong> method is called. You will do this by logging a message immediately before and after the method is called:<p class="source-code">            Logger.Log($"Starting taskA. Status={taskA.Status}");</p><p class="source-code">            taskA.Start();</p><p class="source-code">            Logger.Log($"Started taskA. Status={taskA.Status}");</p><p class="source-code">            Console.ReadLine();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">} </p></li>
<li>Copy the contents of <strong class="source-inline">Logger.cs</strong> file to same folder as the <strong class="source-inline">TaskExamples.cs</strong> example.</li>
<li>Next run the console app to produce the following output:<p class="source-code"><a id="_idTextAnchor209"/>10:47:34 [01] Creating taskA</p><p class="source-code">10:47:34 [01] Starting taskA. Status=Created</p><p class="source-code">10:47:34 [01] Started taskA. Status=WaitingToRun</p><p class="source-code">10:47:34 [03] Inside taskA</p><p class="source-code">10:47:39 [03] Leaving taskA</p></li>
</ol>
<p>Note that the task's status is <strong class="source-inline">WaitingToRun</strong> even after you've called <strong class="source-inline">Start</strong>. This is because you are asking the .NET scheduler to schedule the code to run—that is, to add it to its queue of pending actions. Depending on how busy your application is with other tasks, it may not run immediately after you've called <strong class="source-inline">Start</strong>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/DHxt3">https://packt.link/DHxt3</a>.</p>
<p>In earlier versions of C#, this was the main way to create and start <strong class="source-inline">Task</strong> objects directly. It is no longer recommended and is only included here as you may find it used in older code. Its usage has been replaced by the <strong class="source-inline">Task.Run</strong> or <strong class="source-inline">Task.Factory.StartNew</strong> static factory methods, which offer a simpler interface for the most common usage scenarios.</p>
<h3 id="_idParaDest-188"><a id="_idTextAnchor210"/>Using Task.Factory.StartNew</h3>
<p>The static method <strong class="source-inline">Task.Factory.StartNew</strong> contains various overloads that make it easier to create and configure a <strong class="source-inline">Task</strong>. Notice how the method is named <strong class="source-inline">StartNew</strong>. It creates a <strong class="source-inline">Task</strong> and automatically starts the method for you. The .NET team recognized that there is little value in creating a <strong class="source-inline">Task</strong> that is not immediately started after it is first created. Typically, you would want the <strong class="source-inline">Task</strong> to start performing its operation right away.</p>
<p>The first parameter is the familiar <strong class="source-inline">Action</strong> delegate to be executed, followed by optional cancelation tokens, creation options, and a <strong class="source-inline">TaskScheduler</strong> instance.</p>
<p>The following are some of the common overloads:</p>
<ul>
<li><strong class="source-inline">Task.Factory.StartNew(Action action)</strong>: The <strong class="source-inline">Action</strong> delegate contains the code to execute, as you have seen previously.</li>
<li><strong class="source-inline">Task.Factory.StartNew(Action action, CancellationToken cancellationToken)</strong>: Here, <strong class="source-inline">CancellationToken</strong> coordinates the cancellation of the task.</li>
<li><strong class="source-inline">Task.Factory.StartNew(Action&lt;object&gt; action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler)</strong>: The <strong class="source-inline">TaskScheduler</strong> parameter allows you to specify a type of low-level scheduler responsible for queuing tasks. This option is rarely used.</li>
</ul>
<p>Consider the following code, which uses the first and simplest overload:</p>
<p class="source-code">var taskB = Task.Factory.StartNew((() =&gt;</p>
<p class="source-code">{</p>
<p class="source-code">  Logger.Log("Inside taskB");</p>
<p class="source-code">  Thread.Sleep(TimeSpan.FromSeconds(3D));</p>
<p class="source-code">  Logger.Log("Leaving taskB");</p>
<p class="source-code">}));</p>
<p class="source-code">Logger.Log($"Started taskB. Status={taskB.Status}");</p>
<p class="source-code">Console.ReadLine();</p>
<p>Running this code produces the following output:</p>
<p class="source-code">21:37:42 [01] Started taskB. Status=WaitingToRun</p>
<p class="source-code">21:37:42 [03] Inside taskB</p>
<p class="source-code">21:37:45 [03] Leaving taskB</p>
<p>From the output, you can see that this code achieves the same result as creating a <strong class="source-inline">Task</strong> but is more concise. The main point to consider is that <strong class="source-inline">Task.Factory.StartNew</strong> was added to C# to make it easier to create tasks that are started for you. It was preferable to use <strong class="source-inline">StartNew</strong> rather than creating tasks directly.</p>
<p class="callout-heading">Note</p>
<p class="callout">The term <strong class="bold">Factory</strong> is often used in software development to represent methods that help create objects.</p>
<p><strong class="source-inline">Task.Factory.StartNew</strong> provides a highly configurable way to start tasks, but in reality, many of the overloads are rarely used and need a lot of extra parameters to be passed to them. As such, <strong class="source-inline">Task.Factory.StartNew</strong> itself has also become somewhat obsolete in favor of the newer <strong class="source-inline">Task.Run</strong> static method. Still, the <strong class="source-inline">Task.Factory.StartNew</strong> is briefly covered as you may see it used in legacy C# applications.</p>
<h3 id="_idParaDest-189"><a id="_idTextAnchor211"/>Using Task.Run</h3>
<p>The alternative and preferred <strong class="source-inline">static</strong> factory method, <strong class="source-inline">Task.Run</strong>, has various overloads and was added later to .NET to simplify and shortcut the most common task scenarios. It is preferable for newer code to use <strong class="source-inline">Task.Run</strong> to create started tasks, as far fewer parameters are needed to achieve common threading operations.</p>
<p>Some of the common overloads are as follows:</p>
<ul>
<li><strong class="source-inline">public static Task Run(Action action)</strong>: Contains the <strong class="source-inline">Action</strong> delegate code to execute.</li>
<li><strong class="source-inline">public static Task Run(Action action, CancellationToken cancellationToken)</strong>: Additionally contains a cancelation token used to coordinate the cancellation of a task.</li>
</ul>
<p>For example, consider the following code:</p>
<p class="source-code">var taskC = Task.Run(() =&gt;</p>
<p class="source-code">{</p>
<p class="source-code">  Logger.Log("Inside taskC");</p>
<p class="source-code">  Thread.Sleep(TimeSpan.FromSeconds(1D));</p>
<p class="source-code">  Logger.Log("Leaving taskC");</p>
<p class="source-code">  });</p>
<p class="source-code">Logger.Log($"Started taskC. Status={taskC.Status}");</p>
<p class="source-code">Console.ReadLine();</p>
<p>Running this code will produce the following output:</p>
<p class="source-code">21:40:27 [03] Inside taskC</p>
<p class="source-code">21:40:27 [01] Started taskC. Status=WaitingToRun</p>
<p class="source-code">21:40:28 [03] Leaving taskC</p>
<p>As you can see, the output is pretty similar to the outputs of the previous two code snippets. Each wait for a shorter time than its predecessor before the associated <strong class="source-inline">Action</strong> delegate completes.</p>
<p>The main difference is that creating a <strong class="source-inline">Task</strong> instance directly is an obsolete practice but will allow you to add an extra logging call before you explicitly call the <strong class="source-inline">Start</strong> method. That is the only benefit in creating a <strong class="source-inline">Task</strong> directly, which is not a particularly compelling reason to do so.</p>
<p>Running all three examples together produces this:</p>
<p class="source-code">21:45:52 [01] Creating taskA</p>
<p class="source-code">21:45:52 [01] Starting taskA. Status=Created</p>
<p class="source-code">21:45:52 [01] Started taskA. Status=WaitingToRun</p>
<p class="source-code">21:45:52 [01] Started taskB. Status=WaitingToRun</p>
<p class="source-code">21:45:52 [01] Started taskC. Status=WaitingToRun</p>
<p class="source-code">21:45:52 [04] Inside taskB</p>
<p class="source-code">21:45:52 [03] Inside taskA</p>
<p class="source-code">21:45:52 [05] Inside taskC</p>
<p class="source-code">21:45:53 [05] Leaving taskC</p>
<p class="source-code">21:45:55 [04] Leaving taskB</p>
<p class="source-code">21:45:57 [03] Leaving taskA</p>
<p>You can see various <strong class="source-inline">ManagedThreadIds</strong> being logged and that <strong class="source-inline">taskC</strong> completes before <strong class="source-inline">taskB</strong>, which completes before <strong class="source-inline">taskA</strong>, due to the decreasing number of seconds specified in the <strong class="source-inline">Thread.Sleep</strong> calls in each case.</p>
<p>It is preferable to favor either of the two static methods, but which should you use when scheduling a new task? <strong class="source-inline">Task.Run</strong> should be used for the <strong class="bold">majority</strong> of cases where you need to simply offload some work onto the thread pool. Internally, <strong class="source-inline">Task.Run</strong> defers down to <strong class="source-inline">Task.Factory.StartNew</strong>.</p>
<p><strong class="source-inline">Task.Factory.StartNew</strong> should be used where you have more advanced requirements, such as defining where tasks are queued, by using any of the overloads that accept a <strong class="source-inline">TaskScheduler</strong> instance, but in practice, this is seldom the requirement.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find more information on <strong class="source-inline">Task.Run</strong> and <strong class="source-inline">Task.Factory.StartNew</strong> at <a href="https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/">https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/</a> and <a href="https://blog.stephencleary.com/2013/08/startnew-is-dangerous.xhtml">https://blog.stephencleary.com/2013/08/startnew-is-dangerous.xhtml</a>.</p>
<p>So far, you have seen how small tasks can be started, each with a small delay before completion. Such delays can simulate the effect caused by code accessing slow network connections or running complex calculations. In the following exercise, you'll extend your <strong class="source-inline">Task.Run</strong> knowledge by starting multiple tasks that run increasingly longer numeric calculations.</p>
<p>This serves as an example to show how potentially complex tasks can be started and allowed to run to completion in isolation from one another. Note that in a traditional synchronous implementation, the throughput of such calculations would be severely restricted, owing to the need to wait for one operation to complete before the next one can commence. It is now time to practice what you have learned through an exercise.</p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor212"/>Exercise 5.01: Using Tasks to Perform Multiple Slow-Running Calculations</h2>
<p>In this exercise, you will create a recursive function, Fibonacci, which calls itself twice to calculate a cumulative value. This is an example of potentially slow-running code rather than using <strong class="source-inline">Thread.Sleep</strong> to simulate a slow call. You will create a console app that repeatedly prompts for a number to be entered. The larger this number, the longer each task will take to calculate and output its result. The following steps will help you complete this exercise:</p>
<ol>
<li value="1">In the <strong class="source-inline">Chapter05</strong> folder, add a new folder called <strong class="source-inline">Exercises</strong>. Inside that folder, add a new folder called <strong class="source-inline">Exercise01</strong>. You should have the folder structure as <strong class="source-inline">Chapter05\Exercises\Exercise01</strong>.</li>
<li>Create a new file called <strong class="source-inline">Program.cs</strong>.</li>
<li>Add the recursive <strong class="source-inline">Fibonacci</strong> function as follows. You can save a little processing time by returning <strong class="source-inline">1</strong> if the requested iteration is less than or equal to <strong class="source-inline">2</strong>:<p class="source-code">using System;</p><p class="source-code">using System.Globalization;</p><p class="source-code">using System.Threading;</p><p class="source-code">using System.Threading.Tasks;</p><p class="source-code">namespace Chapter05.Exercises.Exercise01</p><p class="source-code">{</p><p class="source-code">  class Program</p><p class="source-code">  {</p><p class="source-code">        private static long Fibonacci(int n)</p><p class="source-code">        {</p><p class="source-code">            if (n &lt;= 2L)</p><p class="source-code">                return 1L;</p><p class="source-code">            return Fibonacci(n - 1) + Fibonacci(n - 2);</p><p class="source-code">        }</p></li>
<li>Add the <strong class="source-inline">static Main</strong> entry point to the console app and use a <strong class="source-inline">do</strong>-loop to prompt for a number to be entered.</li>
<li>Use <strong class="source-inline">int.TryParse</strong> to convert the string into an integer if the user enters a string:<p class="source-code">        public static void Main()</p><p class="source-code">        {</p><p class="source-code">            string input;</p><p class="source-code">            do</p><p class="source-code">            {</p><p class="source-code">                Console.WriteLine("Enter number:");</p><p class="source-code">                input = Console.ReadLine();</p><p class="source-code">                if (!string.IsNullOrEmpty(input) &amp;&amp;                     int.TryParse(input, NumberStyles.Any, CultureInfo.CurrentCulture, out var number))</p></li>
<li>Define a lambda statement that captures the current time using <strong class="source-inline">DateTime.Now</strong>, calls the slow-running <strong class="source-inline">Fibonacci</strong> function, and logs the time taken to run:<p class="source-code">                 {</p><p class="source-code">                    Task.Run(() =&gt;</p><p class="source-code">                    {</p><p class="source-code">                        var now = DateTime.Now;</p><p class="source-code">                        var fib = Fibonacci(number);</p><p class="source-code">                        var duration = DateTime.Now.Subtract(now);</p><p class="source-code">                        Logger.Log($"Fibonacci {number:N0} = {fib:N0} (elapsed time: {duration.TotalSeconds:N0} secs)");</p><p class="source-code">                    });</p><p class="source-code">                } </p></li>
</ol>
<p>The lambda is passed to <strong class="source-inline">Task.Run</strong> and will be started by <strong class="source-inline">Task.Run</strong> shortly, freeing the <strong class="source-inline">do-while</strong> loop to prompt for another number.</p>
<ol>
<li value="7">The program shall exit the loop when an empty value is entered:<p class="source-code">             } while (input != string.Empty);</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>For running the console app, start by entering the numbers <strong class="source-inline">1</strong> and then <strong class="source-inline">2</strong>. As these are very quick calculations, they both return in under one second.<p class="callout-heading">Note</p><p class="callout">The first time you run this program, Visual Studio will show a warning similar to <strong class="source-inline">"Converting null literal or possible null value to non-nullable type"</strong>. This is a reminder that you are using a variable that could be a null value.</p><p class="source-code">Enter number:1</p><p class="source-code">Enter number:2</p><p class="source-code">11:25:11 [04] Fibonacci 1 = 1 (elapsed time: 0 secs)</p><p class="source-code">Enter number:45</p><p class="source-code">11:25:12 [04] Fibonacci 2 = 1 (elapsed time: 0 secs)</p><p class="source-code">Enter number:44</p><p class="source-code">Enter number:43</p><p class="source-code">Enter number:42</p><p class="source-code">Enter number:41</p><p class="source-code">Enter number:40</p><p class="source-code">Enter number:10</p><p class="source-code">11:25:35 [08] Fibonacci 41 = 165,580,141 (elapsed time: 4 secs)</p><p class="source-code">11:25:35 [09] Fibonacci 40 = 102,334,155 (elapsed time: 2 secs)</p><p class="source-code">11:25:36 [07] Fibonacci 42 = 267,914,296 (elapsed time: 6 secs)</p><p class="source-code">Enter number: 39</p><p class="source-code">11:25:36 [09] Fibonacci 10 = 55 (elapsed time: 0 secs)</p><p class="source-code">11:25:37 [05] Fibonacci 43 = 433,494,437 (elapsed time: 9 secs)</p><p class="source-code">11:25:38 [06] Fibonacci 44 = 701,408,733 (elapsed time: 16 secs)</p><p class="source-code">Enter number:38</p><p class="source-code">11:25:44 [06] Fibonacci 38 = 39,088,169 (elapsed time: 1 secs)</p><p class="source-code">11:25:44 [05] Fibonacci 39 = 63,245,986 (elapsed time: 2 secs)</p><p class="source-code">11:25:48 [04] Fibonacci 45 = 1,134,903,170 (elapsed time: 27 secs)</p></li>
</ol>
<p>Notice how the <strong class="source-inline">ThreadId</strong> is <strong class="source-inline">[04]</strong> for both <strong class="source-inline">1</strong> and <strong class="source-inline">2</strong>. This shows that the same thread was used by <strong class="source-inline">Task.Run</strong> for both iterations. By the time <strong class="source-inline">2</strong> was entered, the previous calculation had already been completed. So .NET decided to reuse thread <strong class="source-inline">04</strong> again. The same occurs for the value <strong class="source-inline">45</strong>, which took <strong class="source-inline">27</strong> seconds to complete even though it was the third requested.</p>
<p>You can see that entering values above <strong class="source-inline">40</strong> causes the elapsed time to increase quite dramatically (for each increase by one, the time taken almost doubles). Starting with higher numbers and descending downward, you can see that the calculations for <strong class="source-inline">41</strong>, <strong class="source-inline">40</strong>, and <strong class="source-inline">42</strong> were all completed before <strong class="source-inline">44</strong> and <strong class="source-inline">43</strong>, even though they were started at similar times. In a few instances, the same thread appears twice. Again, this is .NET re-using idle threads to run the task's action.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/YLYd4">https://packt.link/YLYd4</a>.</p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor213"/>Coordinating Tasks</h2>
<p>In the previous <em class="italic">Exercise 5.01</em>, you saw how multiple tasks can be started and left to run to completion without any interaction between the individual tasks. One such scenario is a process that needs to search a folder looking for image files, adding a copyright watermark to each image file found. The process can use multiple tasks, each working on a distinct file. There would be no need to coordinate each task and its resulting image.</p>
<p>Conversely, it is quite common to start various long-running tasks and only continue when some or all of the tasks have completed; maybe you have a collection of complex calculations that need to be started and can only perform a final calculation once the others have completed.</p>
<p>In the <em class="italic">Introduction</em> section, it was mentioned that a hiking application needed a GPS satellite signal, navigation route, and a heart rate monitor before it could be used safely. Each of these dependencies can be created using a <strong class="source-inline">Task</strong> and only when all of them have signaled that they are ready to be used should the application then allow the user to start with their route.</p>
<p>Over the next sections, you will cover various ways offered by C# to coordinate tasks. For example, you may have a requirement to start many independent tasks running, each running a complex calculation, and need to calculate a final value once all the previous tasks have completed. You may either like to start downloading data from multiple websites but want to cancel the downloads that are taking too long to complete. The next section will cover this scenario.</p>
<h3 id="_idParaDest-192"><a id="_idTextAnchor214"/>Waiting for Tasks to Complete</h3>
<p><strong class="source-inline">Task.Wait</strong> can be used to wait for an individual task to complete. If you are working with multiple tasks, then the static <strong class="source-inline">Task.WaitAll</strong> method will wait for all tasks to complete. The <strong class="source-inline">WaitAll</strong> overloads allow cancellation and timeout options to be passed in, with most returning a Boolean value to indicate success or failure, as you can see in the following list:</p>
<ul>
<li><strong class="source-inline">public static bool WaitAll(Task[] tasks, TimeSpan timeout)</strong>: This is passed an array of <strong class="source-inline">Task</strong> items to wait for. It returns <strong class="source-inline">true</strong> if <strong class="bold">all</strong> of the tasks complete within the maximum time period specified (<strong class="source-inline">TimeSpan</strong> allows specific units such as hours, minutes, and seconds to be expressed).</li>
<li><strong class="source-inline">public static void WaitAll(Task[] tasks, CancellationToken cancellationToken)</strong>: This is passed an array of <strong class="source-inline">Task</strong> items to wait for, and a cancellation token that can be used to coordinate the cancellation of the tasks.</li>
<li><strong class="source-inline">public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken)</strong>: This is passed an array of <strong class="source-inline">Task</strong> items to wait for and a cancellation token that can be used to coordinate the cancellation of the tasks. <strong class="source-inline">millisecondsTimeout</strong> specifies the number of milliseconds to wait for all tasks to complete by.</li>
<li><strong class="source-inline">public static void WaitAll(params Task[] tasks)</strong>: This allows an array of <strong class="source-inline">Task</strong> items to wait for.</li>
</ul>
<p>If you need to wait for any task to complete from a list of tasks, then you can use <strong class="source-inline">Task.WaitAny</strong>. All of the <strong class="source-inline">WaitAny</strong> overloads return either the index number of the first completed task or <strong class="source-inline">-1</strong> if a timeout occurred (the maximum amount of time to wait for).</p>
<p>For example, if you pass an array of five Task items and the last Task in that array completes, then you will be returned the value four (array indexes always start counting at zero).</p>
<ul>
<li><strong class="source-inline">public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken)</strong>: This is passed an array of <strong class="source-inline">Task</strong> items to wait for, the number of milliseconds to wait for any <strong class="source-inline">Task</strong> to complete by, and a cancellation token that can be used to coordinate the cancellation of the tasks.</li>
<li><strong class="source-inline">public static int WaitAny(params Task[] tasks)</strong>: This is passed an array of <strong class="source-inline">Task</strong> items to wait for any <strong class="source-inline">Task</strong> to be completed.</li>
<li><strong class="source-inline">public static int WaitAny(Task[] tasks, int millisecondsTimeout)</strong>: Here, you pass the number of milliseconds to wait for any tasks to complete.</li>
<li><strong class="source-inline">public static int WaitAny(Task[] tasks, CancellationToken cancellationToken) CancellationToken</strong>: This is passed a cancellation token that can be used to coordinate the cancellation of the tasks.</li>
<li><strong class="source-inline">public static int WaitAny(Task[] tasks, TimeSpan timeout)</strong>: This is passed the maximum time period to wait for.</li>
</ul>
<p>Calling <strong class="source-inline">Wait</strong>, <strong class="source-inline">WaitAll</strong>, or <strong class="source-inline">WaitAny</strong> will block the current thread, which can negate the benefits of using a task in the first place. For this reason, it is preferable to call these from within an awaitable task, such as via <strong class="source-inline">Task.Run</strong> as the following example shows.</p>
<p>The code creates <strong class="source-inline">outerTask</strong> with a lambda statement, which itself then creates two inner tasks, <strong class="source-inline">inner1</strong>, and <strong class="source-inline">inner2</strong>. <strong class="source-inline">WaitAny</strong> is used to get the index of the <strong class="bold">first</strong> inner task to complete. In this example, <strong class="source-inline">inner2</strong> will complete first as it pauses for a shorter time, so the resulting index value will be <strong class="source-inline">1</strong>:</p>
<p class="source-code-heading">TaskWaitAnyExample.cs</p>
<p class="source-code">1    var outerTask = Task.Run( () =&gt;</p>
<p class="source-code">2    {</p>
<p class="source-code">3        Logger.Log("Inside outerTask");</p>
<p class="source-code">4        var inner1 = Task.Run(() =&gt;</p>
<p class="source-code">5        {</p>
<p class="source-code">6            Logger.Log("Inside inner1");</p>
<p class="source-code">7            Thread.Sleep(TimeSpan.FromSeconds(3D));</p>
<p class="source-code">8        });</p>
<p class="source-code">9        var inner2 = Task.Run(() =&gt;</p>
<p class="source-code">10        {</p>
<p class="source-code">11            Logger.Log("Inside inner2");</p>
<p class="source-code">12            Thread.Sleep(TimeSpan.FromSeconds(2D));</p>
<p class="source-code">13        });</p>
<p class="source-code">14</p>
<p class="source-code">15        Logger.Log("Calling WaitAny on outerTask");</p>
<p class="source-code-link">You can find the complete code here: <a href="http://packt.link/CicWk">http://packt.link/CicWk</a>.</p>
<p>When the code runs, it produces the following output:</p>
<p class="source-code">15:47:43 [04] Inside outerTask</p>
<p class="source-code">15:47:43 [01] Press ENTER</p>
<p class="source-code">15:47:44 [04] Calling WaitAny on outerTask</p>
<p class="source-code">15:47:44 [05] Inside inner1</p>
<p class="source-code">15:47:44 [06] Inside inner2</p>
<p class="source-code">15:47:46 [04] Waitany index=1</p>
<p>The application remains responsive because you called <strong class="source-inline">WaitAny</strong> from inside a <strong class="source-inline">Task</strong>. You have not blocked the application's main thread. As you can see, thread ID <strong class="source-inline">01</strong> has logged this message: <strong class="source-inline">15:47:43 [01] Press ENTER</strong>.</p>
<p>This type of pattern can be used in cases where you need to fire and forget a task. For example, you may want to log an informational message to a database or a log file, but it is not essential that the flow of the program is altered if either task fails to complete.</p>
<p>A common progression from fire-and-forget tasks is those cases where you need to wait for several tasks to complete within a certain time limit. The next exercise will cover this scenario.</p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor215"/>Exercise 5.02: Waiting for Multiple Tasks to Complete Within a Time Period</h2>
<p>In this exercise, you will start three long-running tasks and decide your next course of action if they all completed within a certain randomly selected time span.</p>
<p>Here, you will see the generic <strong class="source-inline">Task&lt;T&gt;</strong> class being used. The <strong class="source-inline">Task&lt;T&gt;</strong> class includes a <strong class="source-inline">Value</strong> property that can be used to access the result of <strong class="source-inline">Task</strong> (in this exercise, it is a string-based generic, so <strong class="source-inline">Value</strong> will be a string type). You won't use the <strong class="source-inline">Value</strong> property here as the purpose of this exercise is to show that void and generic tasks can be waited for together. Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">Add the main entry point to the console app:<p class="source-code">using System;</p><p class="source-code">using System.Threading;</p><p class="source-code">using System.Threading.Tasks;</p><p class="source-code">namespace Chapter05.Exercises.Exercise02</p><p class="source-code">{</p><p class="source-code">    class Program</p><p class="source-code">    {</p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p><p class="source-code">            Logger.Log("Starting");</p></li>
<li>Declare a variable named <strong class="source-inline">taskA</strong>, passing <strong class="source-inline">Task.Run</strong> a lambda that pauses the current thread for <strong class="source-inline">5</strong> seconds:<p class="source-code">            var taskA = Task.Run( () =&gt;</p><p class="source-code">            {</p><p class="source-code">                Logger.Log("Inside TaskA");</p><p class="source-code">                Thread.Sleep(TimeSpan.FromSeconds(5));</p><p class="source-code">                Logger.Log("Leaving TaskA");</p><p class="source-code">                return "All done A";</p><p class="source-code">            });</p></li>
<li>Create two more tasks using the method group syntax:<p class="source-code">            var taskB = Task.Run(TaskBActivity);</p><p class="source-code">            var taskC = Task.Run(TaskCActivity);</p></li>
</ol>
<p>As you may recall, this shorter syntax can be used if the compiler can determine the type of argument required for a zero- or single-parameter method.</p>
<ol>
<li value="4">Now pick a random maximum timeout in seconds. This means that either of the two tasks may <strong class="bold">not</strong> complete before the timeout period has elapsed:<p class="source-code">            var timeout = TimeSpan.FromSeconds(new Random().Next(1, 10));</p><p class="source-code">            Logger.Log($"Waiting max {timeout.TotalSeconds} seconds...");</p></li>
</ol>
<p>Note that each of the tasks will still run to completion as you have not added a mechanism to stop executing the code inside the body of the <strong class="source-inline">Task.Run</strong> <strong class="source-inline">Action</strong> lambda.</p>
<ol>
<li value="5">Call <strong class="source-inline">WaitAll</strong>, passing in the three tasks and the <strong class="source-inline">timeout</strong> period:<p class="source-code">            var allDone = Task.WaitAll(new[] {taskA, taskB, taskC}, timeout);</p><p class="source-code">            Logger.Log($"AllDone={allDone}: TaskA={taskA.Status}, TaskB={taskB.Status}, TaskC={taskC.Status}");</p><p class="source-code">            Console.WriteLine("Press ENTER to quit");</p><p class="source-code">            Console.ReadLine();</p><p class="source-code">        }</p></li>
</ol>
<p>This will return <strong class="source-inline">true</strong> if all tasks complete in time. You will then log the status of all tasks and wait for <strong class="source-inline">Enter</strong> to be pressed to exit the application.</p>
<ol>
<li value="6">Finish off by adding two slow-running <strong class="source-inline">Action</strong> methods:<p class="source-code">        private static string TaskBActivity()</p><p class="source-code">        {</p><p class="source-code">            Logger.Log($"Inside {nameof(TaskBActivity)}");</p><p class="source-code">            Thread.Sleep(TimeSpan.FromSeconds(2));</p><p class="source-code">            Logger.Log($"Leaving {nameof(TaskBActivity)}");</p><p class="source-code">            return "";</p><p class="source-code">        }</p><p class="source-code">        private static void TaskCActivity()</p><p class="source-code">        {</p><p class="source-code">            Logger.Log($"Inside {nameof(TaskCActivity)}");</p><p class="source-code">            Thread.Sleep(TimeSpan.FromSeconds(1));</p><p class="source-code">            Logger.Log($"Leaving {nameof(TaskCActivity)}");</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>Each will log a message when starting and leaving a task, after a few seconds. The useful <strong class="source-inline">nameof</strong> statement is used to include the name of the method for extra logging information. Often, it is useful to examine log files to see the name of a method that has been accessed rather than hardcoding its name as a literal string.</p>
<ol>
<li value="7">Upon running the code, you will see the following output:<p class="source-code">14:46:28 [01] Starting</p><p class="source-code">14:46:28 [04] Inside TaskBActivity</p><p class="source-code">14:46:28 [05] Inside TaskCActivity</p><p class="source-code">14:46:28 [06] Inside TaskA</p><p class="source-code">14:46:28 [01] Waiting max 7 seconds...</p><p class="source-code">14:46:29 [05] Leaving TaskCActivity</p><p class="source-code">14:46:30 [04] Leaving TaskBActivity</p><p class="source-code">14:46:33 [06] Leaving TaskA</p><p class="source-code">14:46:33 [01] AllDone=True: TaskA=RanToCompletion, TaskB=RanToCompletion, TaskC=RanToCompletion</p><p class="source-code">Press ENTER to quit</p></li>
</ol>
<p>While running the code, a seven-second timeout was randomly picked by the runtime. This allowed all tasks to complete in time, so <strong class="source-inline">true</strong> was returned by <strong class="source-inline">WaitAll</strong> and all tasks had a <strong class="source-inline">RanToCompletion</strong> status at that point. Notice that the thread ID, in square brackets, is different for all three tasks.</p>
<ol>
<li value="8">Run the code again:<p class="source-code">14:48:20 [01] Starting</p><p class="source-code">14:48:20 [01] Waiting max 2 seconds...</p><p class="source-code">14:48:20 [05] Inside TaskCActivity</p><p class="source-code">14:48:20 [06] Inside TaskA</p><p class="source-code">14:48:20 [04] Inside TaskBActivity</p><p class="source-code">14:48:21 [05] Leaving TaskCActivity</p><p class="source-code">14:48:22 [04] Leaving TaskBActivity</p><p class="source-code">14:48:22 [01] AllDone=False: TaskA=Running, TaskB=Running, TaskC=RanToCompletion</p><p class="source-code">Press ENTER to quit</p><p class="source-code">14:48:25 [06] Leaving TaskA</p></li>
</ol>
<p>This time the runtime picked a two-second maximum wait time, so the <strong class="source-inline">WaitAll</strong> call times out with <strong class="source-inline">false</strong> being returned.</p>
<p>You may have noticed from the output that <strong class="source-inline">Inside TaskBActivity</strong> can sometimes appear before <strong class="source-inline">Inside TaskCActivity</strong>. This demonstrates the .NET scheduler's queuing mechanism. When you call <strong class="source-inline">Task.Run</strong>, you are asking the scheduler to add this to its queue. There may only be a matter of milliseconds between the time that you call <strong class="source-inline">Task.Run</strong> and when it invokes your lambda, but this can depend on how many other tasks you have recently added to the queue; a greater number of pending tasks could increase that time period.</p>
<p>Interestingly, the output shows <strong class="source-inline">Leaving TaskBActivity</strong>, but the <strong class="source-inline">taskB</strong> status was still <strong class="source-inline">Running</strong> just after <strong class="source-inline">WaitAll</strong> finished waiting. This indicates that there can sometimes be a very slight delay when a timed-out task's status is changed.</p>
<p>Some three seconds after the <strong class="source-inline">Enter</strong> key is pressed, <strong class="source-inline">Leaving TaskA</strong> is logged. This shows that the <strong class="source-inline">Action</strong> within any timed-out tasks will continue to run, and .NET will not stop it for you.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/5lH0o">https://packt.link/5lH0o</a>.</p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor216"/>Continuation Tasks</h2>
<p>So far, you have created tasks that are independent of one another, but what if you need to continue a task with the results of the previous task? Rather than blocking the current thread, by calling <strong class="source-inline">Wait</strong> or accessing the <strong class="source-inline">Result</strong> property, this can be achieved using the <strong class="source-inline">Task</strong> <strong class="source-inline">ContinueWith</strong> methods.</p>
<p>These methods return a new task, referred to as a <strong class="bold">continuation</strong> task, or more simply, a continuation, which can consume the previous task's or the antecedent's results.</p>
<p>As with standard tasks, they do not block the caller thread. There are several <strong class="source-inline">ContinueWith</strong> overloads available, many allowing extensive customization. A few of the more commonly used overloads are as follows:</p>
<ul>
<li><strong class="source-inline">public Task ContinueWith(Action&lt;Task&lt;TResult&gt;&gt; continuationAction)</strong>: This defines a generic <strong class="source-inline">Action&lt;T&gt;</strong> based <strong class="source-inline">Task</strong> to run when the previous task completes.</li>
<li><strong class="source-inline">public Task ContinueWith(Action&lt;Task&lt;TResult&gt;&gt; continuationAction, CancellationToken cancellationToken)</strong>: This has a task to run and a cancellation token that can be used to coordinate the cancellation of the task.</li>
<li><strong class="source-inline">public Task ContinueWith(Action&lt;Task&lt;TResult&gt;&gt; continuationAction, TaskScheduler scheduler)</strong>: This also has a task to run and a low-level <strong class="source-inline">TaskScheduler</strong> that be used to queue the task.</li>
<li><strong class="source-inline">public Task ContinueWith(Action&lt;Task&lt;TResult&gt;&gt; continuationAction, TaskContinuationOptions continuationOptions)</strong>: A task to run, with the behavior for the task specified with <strong class="source-inline">TaskContinuationOptions</strong>. For example, specifying <strong class="source-inline">NotOnCanceled</strong> indicates that you do <strong class="bold">not</strong> want the continuation to be called if the previous task is canceled.</li>
</ul>
<p>Continuations have an initial <strong class="source-inline">WaitingForActivation</strong> status. The .NET Framework will execute this task once the antecedent task or tasks have completed. It is important to note that you do not need to start a continuation and attempting to do so will result in an exception.</p>
<p>The following example simulates calling a long-running function, <strong class="source-inline">GetStockPrice</strong> (this may be some sort of web service or database call that takes a few seconds to return):</p>
<p class="source-code-heading">ContinuationExamples.cs</p>
<p class="source-code">1    class ContinuationExamples</p>
<p class="source-code">2    {</p>
<p class="source-code">3        public static void Main()</p>
<p class="source-code">4        {</p>
<p class="source-code">5            Logger.Log("Start...");</p>
<p class="source-code"><strong class="bold">6</strong>            <strong class="bold">Task.Run(<a id="_idTextAnchor217"/>GetStockPrice)</strong></p>
<p class="source-code"><strong class="bold">7</strong>                <strong class="bold">.ContinueWith(prev =&gt;</strong></p>
<p class="source-code"><strong class="bold">8</strong>                <strong class="bold">{</strong></p>
<p class="source-code"><strong class="bold">9</strong>                    <strong class="bold">Logger.Log($"GetPrice returned {prev.Result:N2}, status={prev.Status}");</strong></p>
<p class="source-code"><strong class="bold">10</strong>                <strong class="bold">});</strong></p>
<p class="source-code">11</p>
<p class="source-code">12           Console.ReadLine();</p>
<p class="source-code">13        }</p>
<p class="source-code">14</p>
<p class="source-code-link">You can find the complete code here: <a href="http://packt.link/rpNcx">http://packt.link/rpNcx</a>.</p>
<p>The call to <strong class="source-inline">GetStockPrice</strong> returns a <strong class="source-inline">double</strong>, which results in the generic <strong class="source-inline">Task&lt;double&gt;</strong> being passed to as a continuation (see the highlighted part). The <strong class="source-inline">prev</strong> parameter is a generic <strong class="source-inline">Action</strong> of type <strong class="source-inline">Task&lt;double&gt;</strong>, allowing you to access the antecedent task and its <strong class="source-inline">Result</strong> to retrieve the value returned from <strong class="source-inline">GetStockPrice</strong>.</p>
<p>If you hover your mouse over the <strong class="source-inline">ContinueWith</strong> method, you will see the IntelliSense description for it as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer125">
<img alt="Figure 5.1: ContinueWith method signature " height="521" src="image/B16835_05_01.jpg" width="1235"/>
</div>
</div>
<p class="figure-caption">Figure 5.1: ContinueWith method signature</p>
<p class="callout-heading">Note</p>
<p class="callout">The <strong class="source-inline">ContinueWith</strong> method has various options that can be used to fine-tune behavior, and you can get more details about them from <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions">https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions</a>.</p>
<p>Running the example produces an output similar to the following:</p>
<p class="source-code">09:30:45 [01] Start...</p>
<p class="source-code">09:30:45 [03] Inside GetStockPrice</p>
<p class="source-code">09:30:50 [04] GetPrice returned 76.44, status=RanToCompletion</p>
<p>In the output, thread <strong class="source-inline">[01]</strong> represents the console's main thread. The task that called <strong class="source-inline">GetStockPrice</strong> was executed by thread ID <strong class="source-inline">[03]</strong>, yet the continuation was executed using a different thread, thread (<strong class="source-inline">[04]</strong>).</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/rpNcx">https://packt.link/rpNcx</a>.</p>
<p>The continuation running on a different thread may not be a problem, but it certainly will be an issue if you are working on UWP, WPF, or WinForms UI apps where it's essential that UI elements are updated using the main UI thread (unless you are using binding semantics).</p>
<p>It is worth noting that the <strong class="source-inline">TaskContinuationOptions.OnlyOnRanToCompletion</strong> option can be used to ensure the continuation only runs if the antecedent task has run to completion first. For example, you may create a <strong class="source-inline">Task</strong> that fetches customers' orders from a database and then use a continuation task to calculate the average order value. If the previous task fails or is canceled by the user, then there is no point in wasting processing power to calculate the average if the user no longer cares about the result.</p>
<p class="callout-heading">Note</p>
<p class="callout">The <strong class="source-inline">ContinueWith</strong> method has various options that can be used to fine-tune behavior, and you can see <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions">https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions</a> for more details.</p>
<p>If you access the <strong class="source-inline">Task&lt;T&gt; Result</strong> property on a <strong class="bold">failed</strong> or <strong class="bold">canceled</strong> antecedent task, this will result in an <strong class="source-inline">AggregateException</strong> being thrown. This will be covered in more detail later.</p>
<h3 id="_idParaDest-195"><a id="_idTextAnchor218"/>Using Task.WhenAll and Task.WhenAny with Multiple Tasks</h3>
<p>You have seen how a single task can be used to create a continuation task, but what if you have multiple tasks and need to continue with a final operation when any or all of the previous tasks have completed?</p>
<p>Earlier, the <strong class="source-inline">Task.WaitAny</strong> and <strong class="source-inline">Task.WaitAll</strong> methods were used to wait for tasks to complete, but these block the current thread. This is where <strong class="source-inline">Task.WhenAny</strong> and <strong class="source-inline">Task.WhenAll</strong> can be used. They return a new <strong class="source-inline">Task</strong> whose <strong class="source-inline">Action</strong> delegate is called <strong class="bold">when</strong> any, or all, of the preceding tasks have completed.</p>
<p>There are four <strong class="source-inline">WhenAll</strong> overloads, two that return a <strong class="source-inline">Task</strong> and two that return a generic <strong class="source-inline">Task&lt;T&gt;</strong> allowing the task's result to be accessed:</p>
<ol>
<li value="1"><strong class="source-inline">public static Task WhenAll(IEnumerable&lt;Task&gt; tasks)</strong>: This continues when the collection of tasks completes.</li>
<li><strong class="source-inline">public static Task WhenAll(params Task[] tasks)</strong>: This continues when the array of tasks completes.</li>
<li><strong class="source-inline">public static Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt;(params Task&lt;TResult&gt;[] tasks)</strong>: This continues when the array of generic <strong class="source-inline">Task&lt;T&gt;</strong> items complete.</li>
<li><strong class="source-inline">public static Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt;(IEnumerable&lt;Task&lt;TResult&gt;&gt; tasks)</strong>: This continues when the collection of generic <strong class="source-inline">Task&lt;T&gt;</strong> items complete.</li>
</ol>
<p><strong class="source-inline">WhenAny</strong> has a similar set of overloads but returns the <strong class="source-inline">Task</strong> or <strong class="source-inline">Task&lt;T&gt;</strong> that is the <strong class="bold">first</strong> task to complete. You'll next perform a few exercises showing <strong class="source-inline">WhenAll</strong> and <strong class="source-inline">WhenAny</strong> in practice.</p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor219"/>Exercise 5.03: Waiting for All Tasks to Complete</h2>
<p>Say you have been asked by a car dealer to create a console application that calculates the average sales value for cars sold across different regions. A dealership is a busy place, but they know it may take a while to fetch and calculate the average. For this reason, they want to enter a maximum number of seconds that they are prepared to wait for the average calculation. Any longer and they will leave the app and ignore the result.</p>
<p>The dealership has 10 regional sales hubs. To calculate the average, you need to first invoke a method called <strong class="source-inline">FetchSales</strong>, which returns a list of <strong class="source-inline">CarSale</strong> items for each of these regions.</p>
<p>Each call to <strong class="source-inline">FetchSales</strong> could be to a potentially slow-running service (you will implement random pauses to simulate such a delay) so you need to use a <strong class="source-inline">Task</strong> for each as you can't know for sure how long each call will take to complete. You also do not want slow-running tasks to affect other tasks, but to calculate a valid average, it's important to have <strong class="bold">all</strong> results returned before continuing.</p>
<p>Create a <strong class="source-inline">SalesLoader</strong> class that implements <strong class="source-inline">IEnumerable&lt;CarSale&gt; FetchSales()</strong> to return the car sales details. Then, a <strong class="source-inline">SalesAggregator</strong> class should be passed a list of <strong class="source-inline">SalesLoader</strong> (in this exercise, there will be 10 loader instances, one for each region). The aggregator will wait for all loaders to finish using <strong class="source-inline">Task.WhenAll</strong> before continuing with a task that calculates the average across all regions.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">First, create a <strong class="source-inline">CarSale</strong> record. The constructor accepts two values, the name of the car and its sale price (<strong class="source-inline">name</strong> and <strong class="source-inline">salePrice</strong>):<p class="source-code">using System;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.Globalization;</p><p class="source-code">using System.Linq;</p><p class="source-code">using System.Threading;</p><p class="source-code">using System.Threading.Tasks;</p><p class="source-code">namespace Chapter05.Exercises.Exercise03</p><p class="source-code">{</p><p class="source-code">    public record CarSale</p><p class="source-code">    {</p><p class="source-code">        public CarSale(string name, double salePrice)</p><p class="source-code">            =&gt; (Name, SalePrice) = (name, salePrice);</p><p class="source-code">        public string Name { get; }</p><p class="source-code">        public double SalePrice { get; }</p><p class="source-code">    }</p></li>
<li>Now create an interface, <strong class="source-inline">ISalesLoader</strong>, that represents the sales data loading service:<p class="source-code">    public interface ISalesLoader</p><p class="source-code">    {</p><p class="source-code">        public IEnumerable&lt;CarSale&gt; FetchSales();</p><p class="source-code">    }</p></li>
</ol>
<p>It has just one call, <strong class="source-inline">FetchSales</strong>, returning an enumerable of type <strong class="source-inline">CarSale</strong>. For now, it's not important to know how the loader works; just that it returns a list of car sales when called. Using an interface here allows using various types of loader as needed.</p>
<ol>
<li value="3">User the aggregator class to call an <strong class="source-inline">ISalesLoader</strong> implementation:<p class="source-code">    public static class SalesAggregator</p><p class="source-code">    {</p><p class="source-code">       public static Task&lt;double&gt; Average(IEnumerable&lt;ISalesLoader&gt; loaders)</p><p class="source-code">       {</p></li>
</ol>
<p>It is declared as <strong class="source-inline">static</strong> as there is no state between calls. Define an <strong class="source-inline">Average</strong> function that is passed an enumerable of <strong class="source-inline">ISalesLoader</strong> items and returns a generic <strong class="source-inline">Task&lt;Double&gt;</strong> for the final average calculation.</p>
<ol>
<li value="4">For each of the loader parameters, use a LINQ projection to pass a <strong class="source-inline">loader.FetchSales</strong> method to <strong class="source-inline">Task.Run</strong>:<p class="source-code">         var loaderTasks = loaders.Select(ldr =&gt; Task.Run(ldr.FetchSales));</p><p class="source-code">         return Task</p><p class="source-code">                .WhenAll(loaderTasks)</p><p class="source-code">                .ContinueWith(tasks =&gt;</p></li>
</ol>
<p>Each of these will return a <strong class="source-inline">Task&lt;IEnumerable&lt;CarSale&gt;&gt;</strong> instance. <strong class="source-inline">WhenAll</strong> is used to create a single task that continues when <strong class="bold">all</strong> of the loader tasks have completed via a <strong class="source-inline">ContinueWith</strong> call.</p>
<ol>
<li value="5">Use the LINQ <strong class="source-inline">SelectMany</strong> to grab all of the <strong class="source-inline">CarSale</strong> items from every loader call result, before calling the Linq <strong class="source-inline">Average</strong> on the <strong class="source-inline">SalePrice</strong> field of each <strong class="source-inline">CarSale</strong> item:<p class="source-code">                {</p><p class="source-code">                    var average = tasks.Result</p><p class="source-code">                        .SelectMany(t =&gt; t)</p><p class="source-code">                        .Average(car =&gt; car.SalePrice);</p><p class="source-code">                    return average;</p><p class="source-code">                });</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Implement the <strong class="source-inline">ISalesLoader</strong> interface from a class called <strong class="source-inline">SalesLoader</strong>:<p class="source-code">    public class SalesLoader : ISalesLoader</p><p class="source-code">    {</p><p class="source-code">        private readonly Random _random;</p><p class="source-code">        private readonly string _name;</p><p class="source-code">        public SalesLoader(int id, Random rand)</p><p class="source-code">        {</p><p class="source-code">            _name = $"Loader#{id}";</p><p class="source-code">            _random = rand;</p><p class="source-code">        }</p></li>
</ol>
<p>The constructor will be passed an <strong class="source-inline">int</strong> variable used for logging and a <strong class="source-inline">Random</strong> instance to help create a random number of <strong class="source-inline">CarSale</strong> items.</p>
<ol>
<li value="7">Your <strong class="source-inline">ISalesLoader</strong> implementation requires a <strong class="source-inline">FetchSales</strong> function. Include a random delay of between <strong class="source-inline">1</strong> and <strong class="source-inline">3</strong> seconds to simulate a less reliable service:<p class="source-code">        public IEnumerable&lt;CarSale&gt; FetchSales()</p><p class="source-code">        {</p><p class="source-code">            var delay = _random.Next(1, 3);</p><p class="source-code">            Logger.Log($"FetchSales {_name} sleeping for {delay} seconds ...");</p><p class="source-code">            Thread.Sleep(TimeSpan.FromSeconds(delay));</p></li>
</ol>
<p>You are trying to test that your application behaves with various time delays. Hence, the random class use.</p>
<ol>
<li value="8">Use <strong class="source-inline">Enumerable.Range</strong> and <strong class="source-inline">random.Next</strong> to pick a random number from one to five:<p class="source-code">            var sales = Enumerable</p><p class="source-code">                .Range(1, _random.Next(1, 5))</p><p class="source-code">                .Select(n =&gt; GetRandomCar())</p><p class="source-code">                .ToList();</p><p class="source-code">            foreach (var car in sales)</p><p class="source-code">                Logger.Log($"FetchSales {_name} found: {car.Name} @ {car.SalePrice:N0}");</p><p class="source-code">            return sales;</p><p class="source-code">        }</p></li>
</ol>
<p>This is the total number of <strong class="source-inline">CarSale</strong> items to return using your <strong class="source-inline">GetRandomCar</strong> function.</p>
<ol>
<li value="9">Use the <strong class="source-inline">GetRandomCar</strong> to generate a <strong class="source-inline">CarSale</strong> item with a random manufacturer's name from a hardcoded list.</li>
<li>Use the <strong class="source-inline">carNames.length</strong> property to pick a random index number between zero and four for the car's name:<p class="source-code">        private readonly string[] _carNames = { "Ford", "BMW", "Fiat", "Mercedes", "Porsche" };</p><p class="source-code">        private CarSale GetRandomCar()</p><p class="source-code">        {</p><p class="source-code">            var nameIndex = _random.Next(_carNames.Length);</p><p class="source-code">            return new CarSale(</p><p class="source-code">                _carNames[nameIndex], _random.NextDouble() * 1000);</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
<li>Now, create your console app to test this out:<p class="source-code">    public class Program</p><p class="source-code">    {</p><p class="source-code">        public static void Main()</p><p class="source-code">        {</p><p class="source-code">            var random = new Random();</p><p class="source-code">            const int MaxSalesHubs = 10;</p><p class="source-code">            string input;</p><p class="source-code">            do</p><p class="source-code">            {</p><p class="source-code">                Console.WriteLine("Max wait time (in seconds):");</p><p class="source-code">                input = Console.ReadLine();</p><p class="source-code">                if (string.IsNullOrEmpty(input))</p><p class="source-code">                    continue;</p></li>
</ol>
<p>Your app will repeatedly ask for a maximum time that the user is prepared to wait while data is downloaded. Once all the data has been downloaded, the app will use this to calculate an average price. Pressing <strong class="source-inline">Enter</strong> alone will result in the program loop ending. <strong class="source-inline">MaxSalesHubs</strong> is the maximum number of sales hubs to request data for.</p>
<ol>
<li value="12">Convert the entered value into an <strong class="source-inline">int</strong> type, then use <strong class="source-inline">Enumerable.Range</strong> again to create a random number of new <strong class="source-inline">SalesLoader</strong> instances (you have up to 10 different sales hubs):<p class="source-code">                if (int.TryParse(input, NumberStyles.Any, CultureInfo.CurrentCulture, out var maxDelay))</p><p class="source-code">                {</p><p class="source-code">                       var loaders = Enumerable.Range(1,                                           random.Next(1, MaxSalesHubs))</p><p class="source-code">                        .Select(n =&gt; new SalesLoader(n, random))</p><p class="source-code">                        .ToList();</p></li>
<li>Pass loaders to the static <strong class="source-inline">SalesAggregator.Average</strong> method to receive a <strong class="source-inline">Task&lt;Double&gt;</strong>.</li>
<li>Call <strong class="source-inline">Wait</strong>, passing in the maximum wait time:<p class="source-code">                    var averageTask = SalesAggregator.Average(loaders);</p><p class="source-code">                    var hasCompleted = averageTask.Wait(                              TimeSpan.FromSeconds(maxDelay));</p><p class="source-code">                    var average = averageTask.Result;</p></li>
</ol>
<p>If the <strong class="source-inline">Wait</strong> call does return in time, then you will see a <strong class="source-inline">true</strong> value for has completed.</p>
<ol>
<li value="15">Finish off by checking <strong class="source-inline">hasCompleted</strong> and log a message accordingly:<p class="source-code">                    if (hasCompleted)</p><p class="source-code">                    {</p><p class="source-code">                        Logger.Log($"Average={average:N0}");</p><p class="source-code">                    }</p><p class="source-code">                    else</p><p class="source-code">                    {</p><p class="source-code">                        Logger.Log("Timeout!");</p><p class="source-code">                    }</p><p class="source-code">                }</p><p class="source-code">            } while (input != string.Empty);</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>When running the console app and entering a short maximum wait of <strong class="source-inline">1</strong> second, you see three loader instances randomly created:<p class="source-code">Max wait time (in seconds):1</p><p class="source-code">10:52:49 [04] FetchSales Loader#1 sleeping for 1 seconds ...</p><p class="source-code">10:52:49 [06] FetchSales Loader#3 sleeping for 1 seconds ...</p><p class="source-code">10:52:49 [05] FetchSales Loader#2 sleeping for 1 seconds ...</p><p class="source-code">10:52:50 [04] FetchSales Loader#1 found: Mercedes @ 362</p><p class="source-code">10:52:50 [04] FetchSales Loader#1 found: Ford @ 993</p><p class="source-code">10:52:50 [06] FetchSales Loader#3 found: Fiat @ 645</p><p class="source-code">10:52:50 [05] FetchSales Loader#2 found: Mercedes @ 922</p><p class="source-code">10:52:50 [06] FetchSales Loader#3 found: Ford @ 9</p><p class="source-code">10:52:50 [05] FetchSales Loader#2 found: Porsche @ 859</p><p class="source-code">10:52:50 [05] FetchSales Loader#2 found: Mercedes @ 612</p><p class="source-code">10:52:50 [01] Timeout!</p></li>
</ol>
<p>Each loader sleeps for <strong class="source-inline">1</strong> second (you can see various thread IDs are logged) before returning a random list of <strong class="source-inline">CarSale</strong> records. You soon reach the maximum timeout value, hence the message <strong class="source-inline">Timeout!</strong> with no average value displayed.</p>
<ol>
<li value="17">Enter a larger timeout period of <strong class="source-inline">10</strong> seconds:<p class="source-code">Max wait time (in seconds):10</p><p class="source-code">20:08:41 [05] FetchSales Loader#1 sleeping for 2 seconds ...</p><p class="source-code">20:08:41 [12] FetchSales Loader#4 sleeping for 1 seconds ...</p><p class="source-code">20:08:41 [08] FetchSales Loader#2 sleeping for 1 seconds ...</p><p class="source-code">20:08:41 [11] FetchSales Loader#3 sleeping for 1 seconds ...</p><p class="source-code">20:08:41 [15] FetchSales Loader#5 sleeping for 2 seconds ...</p><p class="source-code">20:08:41 [13] FetchSales Loader#6 sleeping for 2 seconds ...</p><p class="source-code">20:08:41 [14] FetchSales Loader#7 sleeping for 1 seconds ...</p><p class="source-code">20:08:42 [08] FetchSales Loader#2 found: Porsche @ 735</p><p class="source-code">20:08:42 [08] FetchSales Loader#2 found: Fiat @ 930</p><p class="source-code">20:08:42 [11] FetchSales Loader#3 found: Porsche @ 735</p><p class="source-code">20:08:42 [12] FetchSales Loader#4 found: Porsche @ 735</p><p class="source-code">20:08:42 [08] FetchSales Loader#2 found: Porsche @ 777</p><p class="source-code">20:08:42 [11] FetchSales Loader#3 found: Ford @ 500</p><p class="source-code">20:08:42 [12] FetchSales Loader#4 found: Ford @ 500</p><p class="source-code">20:08:42 [12] FetchSales Loader#4 found: Porsche @ 710</p><p class="source-code">20:08:42 [14] FetchSales Loader#7 found: Ford @ 144</p><p class="source-code">20:08:43 [05] FetchSales Loader#1 found: Fiat @ 649</p><p class="source-code">20:08:43 [15] FetchSales Loader#5 found: Ford @ 779</p><p class="source-code">20:08:43 [13] FetchSales Loader#6 found: Porsche @ 763</p><p class="source-code">20:08:43 [15] FetchSales Loader#5 found: Fiat @ 137</p><p class="source-code">20:08:43 [13] FetchSales Loader#6 found: BMW @ 415</p><p class="source-code">20:08:43 [15] FetchSales Loader#5 found: Fiat @ 853</p><p class="source-code">20:08:43 [15] FetchSales Loader#5 found: Porsche @ 857</p><p class="source-code">20:08:43 [01] Average=639</p></li>
</ol>
<p>Entering a value of <strong class="source-inline">10</strong> seconds allow <strong class="source-inline">7</strong> random loaders to complete in time and to finally create the average value of <strong class="source-inline">639</strong>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/kbToQ">https://packt.link/kbToQ</a>.</p>
<p>So far, this chapter has considered the various ways that individual tasks can be created and how static <strong class="source-inline">Task</strong> methods are used to create tasks that are started for us. You saw how <strong class="source-inline">Task.Factory.StartNew</strong> is used to create configured tasks, albeit with a longer set of configuration parameters. The <strong class="source-inline">Task.Run</strong> methods, which were more recently added to C#, are preferable by using their more concise signatures for most regular scenarios.</p>
<p>Using continuations, single and multiple tasks can be left to run in isolation, only continuing with a final task when all or any of the preceding tasks have run to completion.</p>
<p>Now it is time to look at the <strong class="source-inline">async</strong> and <strong class="source-inline">wait</strong> keywords to run asynchronous code. These keywords are a relatively new addition to the C# language. The <strong class="source-inline">Task.Factory.StartNew</strong> and <strong class="source-inline">Task.Run</strong> methods can be found in older C# applications, but hopefully, you will see that <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> provides a much clearer syntax.</p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor220"/>Asynchronous Programming</h1>
<p>So far, you have created tasks and used the static <strong class="source-inline">Task</strong> factory methods to run and coordinate such tasks. In earlier versions of C#, these were the only ways to create tasks.</p>
<p>The C# language now provides the <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> keywords to <strong class="bold">mark</strong> a method as asynchronous. This is the preferred way to run asynchronous code. Using the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> style results in less code and the code that is created is generally easier to grasp and therefore easier to maintain.</p>
<p class="callout-heading">Note</p>
<p class="callout">You may often find that legacy concurrent-enabled applications were originally created using <strong class="source-inline">Task.Factory.StartNew</strong> methods are subsequently updated to use the equivalent <strong class="source-inline">Task.Run</strong> methods or are updated directly to the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> style.</p>
<p>The <strong class="source-inline">async</strong> keyword indicates that the method will return to the caller before it has had a chance to complete its operations, therefore the caller should wait for it to complete at some point in time.</p>
<p>Adding the <strong class="source-inline">async</strong> keyword to a method instructs the compiler that it may need to generate additional code to create a state machine. In essence, a state machine extracts the logic from your original method into a series of delegates and local variables that allows code to continue onto the next statement following an <strong class="source-inline">await</strong> expression. The compiler generates delegates that can jump back to the same location in the method once they have completed. </p>
<p class="callout-heading">Note</p>
<p class="callout">You don't normally see this extra complied code, but if you are interested in learning more about state machines in C#, visit <a href="https://devblogs.microsoft.com/premier-developer/dissecting-the-async-methods-in-c">https://devblogs.microsoft.com/premier-developer/dissecting-the-async-methods-in-c</a>.</p>
<p>Adding the <strong class="source-inline">async</strong> keyword does not mean that <strong class="bold">all</strong> or <strong class="bold">any</strong> part of the method will actually run in an asynchronous manner. When an <strong class="source-inline">async</strong> method is executed, it starts off running synchronously until it comes to a section of code with the <strong class="source-inline">await</strong> keyword. At this point, the awaitable block of code (in the following example, the <strong class="source-inline">BuildGreetings</strong> call is awaitable due to the preceding <strong class="source-inline">async</strong> keyword) is checked to see if it has already been completed. If so, it continues executing synchronously. If not, the asynchronous method is paused and returns an incomplete <strong class="source-inline">Task</strong> to the caller. This will be complete once the <strong class="source-inline">async</strong> code has been completed.</p>
<p>In the following console app, the entry point, <strong class="source-inline">static Main</strong>, has been marked as <strong class="source-inline">async</strong> and the <strong class="source-inline">Task</strong> return type added. You cannot mark a <strong class="source-inline">Main</strong> entry point, which returns either <strong class="source-inline">int</strong> or <strong class="source-inline">void</strong>, as <strong class="source-inline">async</strong> because the runtime must be able to return a <strong class="source-inline">Task</strong> result to the calling environment when the console app closes:</p>
<p class="source-code-heading">AsyncExamples.cs</p>
<p class="source-code">1    using System;</p>
<p class="source-code">2    using System.Threading;</p>
<p class="source-code">3    using System.Threading.Tasks;</p>
<p class="source-code">4    </p>
<p class="source-code">5    namespace Chapter05.Examples</p>
<p class="source-code">6    {</p>
<p class="source-code">7        public class AsyncExamples</p>
<p class="source-code">8        {</p>
<p class="source-code">9            public static async Task Main()</p>
<p class="source-code">10            {</p>
<p class="source-code">11                Logger.Log("Starting");</p>
<p class="source-code">12                await BuildGreetings();</p>
<p class="source-code">13</p>
<p class="source-code">14                Logger.Log("Press Enter");</p>
<p class="source-code">15                Console.ReadLine();</p>
<p class="source-code-link">You can find the complete code here: <a href="http://packt.link/CsCek">http://packt.link/CsCek</a>.</p>
<p>Running the example produces an output like this:</p>
<p class="source-code">18:20:31 [01] Starting</p>
<p class="source-code">18:20:31 [01] Morning</p>
<p class="source-code">18:20:41 [04] Morning...Afternoon</p>
<p class="source-code">18:20:42 [04] Morning...Afternoon...Evening</p>
<p class="source-code">18:20:42 [04] Press Enter</p>
<p>As soon as <strong class="source-inline">Main</strong> runs, it logs <strong class="source-inline">Starting</strong>. Notice how the <strong class="source-inline">ThreadId</strong> is <strong class="source-inline">[01]</strong>. As you saw earlier, the console app's main thread is numbered as <strong class="source-inline">1</strong> (because the <strong class="source-inline">Logger.Log</strong> method uses the <strong class="source-inline">00</strong> format string, which adds a leading <strong class="source-inline">0</strong> to numbers in the range zero to nine).</p>
<p>Then the asynchronous method <strong class="source-inline">BuildGreetings</strong> is called. It sets the string <strong class="source-inline">message</strong> variable to <strong class="source-inline">"Morning"</strong> and logs the message. The <strong class="source-inline">ThreadId</strong> is still <strong class="source-inline">[01]</strong>; this is currently running synchronously.</p>
<p>So far, you have been using <strong class="source-inline">Thread.Sleep</strong> to block the calling thread in order or simulate long-running operations, but <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> makes it easier to simulate slow actions using the static <strong class="source-inline">Task.Delay</strong> method and awaiting that call. <strong class="source-inline">Task.Delay</strong> returns a task so it can also be used in continuation tasks.</p>
<p>Using <strong class="source-inline">Task.Delay</strong>, you will make two distinct awaitable calls (one that waits for 10 seconds and the second for two seconds), before continuing and appending to your local <strong class="source-inline">message</strong> string. The two <strong class="source-inline">Task.Delay</strong> calls could have been any method in your code that returns a <strong class="source-inline">Task</strong>.</p>
<p>The great thing here is that each awaited section gets its correct state in the order that it was declared in the code, irrespective of waiting 10 (or two) seconds prior. The thread IDs have all changed from <strong class="source-inline">[01]</strong> to <strong class="source-inline">[04]</strong>. This tells you that a different thread is running these statements. Even the very last <strong class="source-inline">Press Enter</strong> message has a different thread to the original thread.</p>
<p><strong class="source-inline">Async/await</strong> makes it easier to run a series of task-based codes using the familiar <strong class="source-inline">WhenAll</strong>, <strong class="source-inline">WhenAny</strong>, and <strong class="source-inline">ContinueWith</strong> methods interchangeably.</p>
<p>The following example shows how multiple <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> calls can be applied at various stages in a program using a mixture of various awaitable calls. This simulates an application that makes a call to a database (<strong class="source-inline">FetchPendingAccounts</strong>) to fetch a list of user accounts. Each user in the pending accounts list is given a unique ID (using a task for each user).</p>
<p>Based on the user's region, an account is then created in the <strong class="bold">northern</strong> region or the other region, again, using a task for each. Finally, an awaitable <strong class="source-inline">Task.WhenAll</strong> call signals that everything has been completed.</p>
<p class="source-code">using System;</p>
<p class="source-code">using System.Collections.Generic;</p>
<p class="source-code">using System.Linq;</p>
<p class="source-code">using System.Threading.Tasks;</p>
<p class="source-code">namespace Chapter05.Examples</p>
<p class="source-code">{</p>
<p>Use an <strong class="source-inline">enum</strong> to define a <strong class="source-inline">RegionName</strong>:</p>
<p class="source-code">    public enum RegionName { North, East, South, West };</p>
<p>A <strong class="source-inline">User</strong> record constructor is passed a <strong class="source-inline">userName</strong> and the user's <strong class="source-inline">region</strong>:</p>
<p class="source-code">    public record User</p>
<p class="source-code">    {</p>
<p class="source-code">        public User(string userName, RegionName region)</p>
<p class="source-code">            =&gt; (UserName, Region) = (userName, region);</p>
<p class="source-code">        public string UserName { get; }</p>
<p class="source-code">        public RegionName Region { get; }</p>
<p class="source-code">        public string ID { get; set; }</p>
<p class="source-code">    }</p>
<p><strong class="source-inline">AccountGenerator</strong> is the main controlling class. It contains an <strong class="source-inline">async</strong> <strong class="source-inline">CreateAccounts</strong> method that can be awaited by a console app (this is implemented at the end of the example):</p>
<p class="source-code">    public class AccountGenerator</p>
<p class="source-code">    {</p>
<p class="source-code">        public async Task CreateAccounts()</p>
<p class="source-code">        {</p>
<p>Using the <strong class="source-inline">await</strong> keyword, you define an awaitable call to <strong class="source-inline">FetchPendingAccounts</strong>:</p>
<p class="source-code">            var users = await FetchPendingAccounts();</p>
<p>For each one of the users returned by <strong class="source-inline">FetchPendingAccounts</strong>, you make an awaitable call to <strong class="source-inline">GenerateId</strong>. This shows that a loop can contain multiple awaitable calls. The runtime will set the user ID for the correct user instance:</p>
<p class="source-code">            foreach (var user in users)</p>
<p class="source-code">            {</p>
<p class="source-code">                var id = await GenerateId();</p>
<p class="source-code">                user.ID = id;</p>
<p class="source-code">            }</p>
<p>Using a Linq <strong class="source-inline">Select</strong> function, you create a list of tasks. For each user, a Northern or Other account is created based on the user's region (each one of the calls is a <strong class="source-inline">Task</strong> per user):</p>
<p class="source-code">            var accountCreationTasks = users.Select(</p>
<p class="source-code">                user =&gt; user.Region == RegionName.North</p>
<p class="source-code">                    ? Task.Run(() =&gt; CreateNorthernAccount(user))</p>
<p class="source-code">                    : Task.Run(() =&gt; CreateOtherAccount(user)))</p>
<p class="source-code">                .ToList();</p>
<p>The list of account creation tasks is awaited using the <strong class="source-inline">static</strong> <strong class="source-inline">WhenAll</strong> call. Once this completes, <strong class="source-inline">UpdatePendindAccounts</strong> will be called passing in the updated user list. This shows that you can pass lists of tasks between <strong class="source-inline">async</strong> statements:</p>
<p class="source-code">            Logger.Log($"Creating {accountCreationTasks.Count} accounts");</p>
<p class="source-code">            await Task.WhenAll(accountCreationTasks);</p>
<p class="source-code">            var updatedAccountTask = UpdatePendingAccounts(users);</p>
<p class="source-code">            await updatedAccountTask;</p>
<p class="source-code">            Logger.Log($"Updated {updatedAccountTask.Result} pending accounts");</p>
<p class="source-code">        }</p>
<p>The <strong class="source-inline">FetchPendingAccounts</strong> method returns a <strong class="source-inline">Task</strong> containing a list of users (here you simulate a delay of <strong class="source-inline">3</strong> seconds using <strong class="source-inline">Task.Delay</strong>):</p>
<p class="source-code">        private async Task&lt;List&lt;User&gt;&gt; FetchPendingAccounts()</p>
<p class="source-code">        {</p>
<p class="source-code">            Logger.Log("Fetching pending accounts...");</p>
<p class="source-code">            await Task.Delay(TimeSpan.FromSeconds(3D));</p>
<p class="source-code">            var users = new List&lt;User&gt;</p>
<p class="source-code">            {</p>
<p class="source-code">                new User("AnnH", RegionName.North),</p>
<p class="source-code">                new User("EmmaJ", RegionName.North),</p>
<p class="source-code">                new User("SophieA", RegionName.South),</p>
<p class="source-code">                new User("LucyG", RegionName.West),</p>
<p class="source-code">            };</p>
<p class="source-code">            Logger.Log($"Found {users.Count} pending accounts");</p>
<p class="source-code">            return users;</p>
<p class="source-code">        }</p>
<p><strong class="source-inline">GenerateId</strong> uses <strong class="source-inline">Task.FromResult</strong> to generate a globally unique ID using the <strong class="source-inline">Guid</strong> class. <strong class="source-inline">Task.FromResult</strong> is used when you want to return a result but do not need to create a running task as you would with <strong class="source-inline">Task.Run</strong>:</p>
<p class="source-code">        private static Task&lt;string&gt; GenerateId()</p>
<p class="source-code">        {</p>
<p class="source-code">            return Task.FromResult(Guid.NewGuid().ToString());</p>
<p class="source-code">        }</p>
<p>The two <strong class="source-inline">bool</strong> task methods create either a northern account or other account. Here, you return <strong class="source-inline">true</strong> to indicate that each account creation call was successful, regardless:</p>
<p class="source-code">        private static async Task&lt;bool&gt; CreateNorthernAccount(User user)</p>
<p class="source-code">        {</p>
<p class="source-code">            await Task.Delay(TimeSpan.FromSeconds(2D));</p>
<p class="source-code">            Logger.Log($"Created northern account for {user.UserName}");</p>
<p class="source-code">            return true;</p>
<p class="source-code">        }</p>
<p class="source-code">        private static async Task&lt;bool&gt; CreateOtherAccount(User user)</p>
<p class="source-code">        {</p>
<p class="source-code">            await Task.Delay(TimeSpan.FromSeconds(1D));</p>
<p class="source-code">            Logger.Log($"Created other account for {user.UserName}");</p>
<p class="source-code">            return true;</p>
<p class="source-code">        }</p>
<p>Next, <strong class="source-inline">UpdatePendingAccounts</strong> is passed a list of users. For each user, you create a task that simulates a slow-running call to update each user and returning a count of the number of users subsequently updated:</p>
<p class="source-code">        private static async Task&lt;int&gt; UpdatePendingAccounts(IEnumerable&lt;User&gt; users)</p>
<p class="source-code">        {</p>
<p class="source-code">            var updateAccountTasks = users.Select(usr =&gt; Task.Run(</p>
<p class="source-code">                async () =&gt;</p>
<p class="source-code">                {</p>
<p class="source-code">                    await Task.Delay(TimeSpan.FromSeconds(2D));</p>
<p class="source-code">                    return true;</p>
<p class="source-code">                }))</p>
<p class="source-code">                .ToList();</p>
<p class="source-code">            await Task.WhenAll(updateAccountTasks);</p>
<p class="source-code">            return updateAccountTasks.Count(t =&gt; t.Result);</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p>Finally, the console app creates an <strong class="source-inline">AccountGenerator</strong> instance and waits for <strong class="source-inline">CreateAccounts</strong> to finish before writing an <strong class="source-inline">All done</strong> message:</p>
<p class="source-code">    public static class AsyncUsersExampleProgram</p>
<p class="source-code">    {</p>
<p class="source-code">        public static async Task Main()</p>
<p class="source-code">        {</p>
<p class="source-code">            Logger.Log("Starting");</p>
<p class="source-code">            await new AccountGenerator().CreateAccounts();</p>
<p class="source-code">            Logger.Log("All done");</p>
<p class="source-code">            Console.ReadLine();</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p class="source-code">   </p>
<p class="source-code">}</p>
<p>Running the console app produces this output:</p>
<p class="source-code">20:12:38 [01] Starting</p>
<p class="source-code">20:12:38 [01] Fetching pending accounts...</p>
<p class="source-code">20:12:41 [04] Found 4 pending accounts</p>
<p class="source-code">20:12:41 [04] Creating 4 accounts</p>
<p class="source-code">20:12:42 [04] Created other account for SophieA</p>
<p class="source-code">20:12:42 [07] Created other account for LucyG</p>
<p class="source-code">20:12:43 [04] Created northern account for EmmaJ</p>
<p class="source-code">20:12:43 [05] Created northern account for AnnH</p>
<p class="source-code">20:12:45 [05] Updated 4 pending accounts</p>
<p class="source-code">20:12:45 [05] All done</p>
<p>Here, you can see that thread <strong class="source-inline">[01]</strong> writes the <strong class="source-inline">Starting</strong> message. This is the application's main thread. Note, too, that the main thread also writes <strong class="source-inline">Fetching pending accounts...</strong> from the <strong class="source-inline">FetchPendingAccounts</strong> method. This is still running synchronously as the awaitable block (<strong class="source-inline">Task.Delay</strong>) has not yet been reached.</p>
<p>Threads <strong class="source-inline">[4]</strong>, <strong class="source-inline">[5]</strong>, and <strong class="source-inline">[7]</strong> create each of the four user accounts. You used <strong class="source-inline">Task.Run</strong> to call the <strong class="source-inline">CreateNorthernAccount</strong> or <strong class="source-inline">CreateOtherAccount</strong> methods. Thread <strong class="source-inline">[5]</strong> runs the last statement in <strong class="source-inline">CreateAccounts: Updated 4 pending accounts</strong>. The thread numbers might differ in your system because .NET uses an internal pool of threads which vary based on how busy each thread is.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/ZIK8k">https://packt.link/ZIK8k</a>.</p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor221"/>Async Lambda Expressions</h2>
<p><em class="italic">Chapter 3</em>, <em class="italic">Delegates, Events, and Lambdas</em>, looked at lambda expressions and how they can be used to create succinct code. You can also use the <strong class="source-inline">async</strong> keyword with lambda expressions to create code for an event handler that contains various <strong class="source-inline">async</strong> code.</p>
<p>The following example uses the <strong class="source-inline">WebClient</strong> class to show two different ways to download data from a website (this will be covered in great detail in <em class="italic">Chapter 8</em>, <em class="italic">Creating and Using Web API Clients</em> and <em class="italic">Chapter 9</em>, <em class="italic">Creating API Services</em>).</p>
<p class="source-code">using System;</p>
<p class="source-code">using System.Net;</p>
<p class="source-code">using System.Net.Http</p>
<p class="source-code">using System.Threading.Tasks;</p>
<p class="source-code">namespace Chapter05.Examples</p>
<p class="source-code">{</p>
<p class="source-code">    public class AsyncLambdaExamples</p>
<p class="source-code">    {</p>
<p class="source-code">        public static async Task Main()</p>
<p class="source-code">        {</p>
<p class="source-code">            const string Url = "https://www.packtpub.com/";</p>
<p class="source-code">            using var client = new WebClient();</p>
<p>Here, you add your own event handler to the <strong class="source-inline">WebClient</strong> class <strong class="source-inline">DownloadDataCompleted</strong> event using a lambda statement that is prefixed with the <strong class="source-inline">async</strong> keyword. The compiler will allow you to add awaitable calls inside the body of the lambda.</p>
<p>This event will be fired after <strong class="source-inline">DownloadData</strong> is called and the data requested has been downloaded for us. The code uses an awaitable block <strong class="source-inline">Task.Delay</strong> to simulate some extra processing on a different thread:</p>
<p class="source-code">            client.DownloadDataCompleted += async (sender, args) =&gt;</p>
<p class="source-code">            {</p>
<p class="source-code">                Logger.Log("Inside DownloadDataCompleted...looking busy");</p>
<p class="source-code">                await Task.Delay(500);</p>
<p class="source-code">                Logger.Log("Inside DownloadDataCompleted..all done now");</p>
<p class="source-code">            };</p>
<p>You invoke the <strong class="source-inline">DownloadData</strong> method, passing in your URL and then logging the length of the web data received. This particular call itself will block the main thread until data is downloaded. <strong class="source-inline">WebClient</strong> offers a task-based asynchronous version of the <strong class="source-inline">DownloadData</strong> method called <strong class="source-inline">DownloadDataTaskAsync</strong>. So it's recommended to use the more modern <strong class="source-inline">DownloadDataTaskAsync</strong> method as follows:</p>
<p class="source-code">            Logger.Log($"DownloadData: {Url}");</p>
<p class="source-code">            var data = client.DownloadData(Url);</p>
<p class="source-code">            Logger.Log($"DownloadData: Length={data.Length:N0}");</p>
<p>Once again, you request the same URL but can simply use an <strong class="source-inline">await</strong> statement, which will be run once the data download has been completed. As you can see, this requires less code and has a cleaner syntax:</p>
<p class="source-code">            Logger.Log($"DownloadDataTaskAsync: {Url}");</p>
<p class="source-code">            var downloadTask = client.DownloadDataTaskAsync(Url);</p>
<p class="source-code">            var downloadBytes =  await downloadTask;</p>
<p class="source-code">            Logger.Log($"DownloadDataTaskAsync: Length={downloadBytes.Length:N0}");</p>
<p class="source-code">            Console.ReadLine();</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p>Running the code produces this output:</p>
<p class="source-code">19:22:44 [01] DownloadData: https://www.packtpub.com/</p>
<p class="source-code">19:22:45 [01] DownloadData: Length=278,047</p>
<p class="source-code">19:22:45 [01] DownloadDataTaskAsync: https://www.packtpub.com/</p>
<p class="source-code">19:22:45 [06] Inside DownloadDataCompleted...looking busy</p>
<p class="source-code">19:22:45 [06] DownloadDataTaskAsync: Length=278,046</p>
<p class="source-code">19:22:46 [04] Inside DownloadDataCompleted..all done now</p>
<p class="callout-heading">Note</p>
<p class="callout">When running the program, you may see the following warning: <strong class="source-inline">"Warning SYSLIB0014: 'WebClient.WebClient()' is obsolete: 'WebRequest, HttpWebRequest, ServicePoint, and WebClient are obsolete. Use HttpClient instead.'"</strong>. Here, Visual Studio has suggested that the <strong class="source-inline">HttpClient</strong> class be used, as <strong class="source-inline">WebClient</strong> has been marked as obsolete.</p>
<p><strong class="source-inline">DownloadData</strong> is logged by thread <strong class="source-inline">[01]</strong>, the main thread, which is blocked for around one second until the download completes. The size of the downloaded file is then logged using the <strong class="source-inline">downloadBytes.Length</strong> property.</p>
<p>The <strong class="source-inline">DownloadDataTaskAsync</strong> request is handled by thread <strong class="source-inline">06</strong>. Finally, the delayed code inside the <strong class="source-inline">DownloadDataCompleted</strong> event handler completes via thread <strong class="source-inline">04</strong>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/IJEaU">https://packt.link/IJEaU</a>.</p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor222"/>Canceling Tasks</h2>
<p>Task cancelation is a two-step approach:</p>
<ul>
<li>You need to add a way to request a cancelation.</li>
<li>Any cancelable code needs to support this.</li>
</ul>
<p>You cannot provide cancelation without both mechanisms in place.</p>
<p>Typically, you will start a long-running task that supports cancelation and provide the user with the ability to cancel the operation by pressing a button on a UI. There are many real-world examples where such cancellation is needed, such as image processing where multiple images need to be altered allowing a user to cancel the remainder of the task if they run out of time. Another common scenario is sending multiple data requests to different web servers and allowing slow-running or pending requests to be canceled as soon as the first response is received.</p>
<p>In C#, <strong class="source-inline">CancellationTokenSource</strong> acts as a top-level object to initiate a cancelation request with its <strong class="source-inline">Token</strong> property, <strong class="source-inline">CancellationToken</strong>, being passed to concurrent/slow running code that can periodically check and act upon this cancellation status. Ideally, you would not want low-level methods to arbitrarily cancel high-level operations, hence the separation between the source and the token.</p>
<p>There are various <strong class="source-inline">C<a id="_idTextAnchor223"/><a id="_idTextAnchor224"/>ancellationTokenSource</strong> constructors, including one that will initiate a cancel request after a specified time has elapsed. Here are a few of the <strong class="source-inline">CancellationTokenSource</strong> methods, offering various ways to initiate a cancellation request:</p>
<ul>
<li><strong class="source-inline">public bool IsCancellationRequested { get; }</strong>: This returns <strong class="source-inline">true</strong> if a cancellation has been requested for this token source (a caller has called the <strong class="source-inline">Cancel</strong> method). This can be inspected at intervals in the target code.</li>
<li><strong class="source-inline">public CancellationToken Token { get; }</strong>: The <strong class="source-inline">CancellationToken</strong> that is linked to this source object is often passed to <strong class="source-inline">Task.Run</strong> overloads, allowing .NET to check the status of pending tasks or for your own code to check while running.</li>
<li><strong class="source-inline">public void Cancel()</strong>: Initiates a request for cancellation.</li>
<li><strong class="source-inline">public void Cancel(bool throwOnFirstException)</strong>: Initiates a request for cancellation and determines whether further operations are to be processed should an exception occur.</li>
<li><strong class="source-inline">public void CancelAfter(int millisecondsDelay)</strong>: Schedules a cancel request after a specified number of milliseconds.</li>
</ul>
<p><strong class="source-inline">CancellationTokenSource</strong> has a <strong class="source-inline">Token</strong> property. <strong class="source-inline">CancellationToken</strong> contains various methods and properties that can be used for code to detect a cancellation request:</p>
<ul>
<li><strong class="source-inline">public bool IsCancellationRequested { get; }</strong>: This returns <strong class="source-inline">true</strong> if a cancellation has been requested for this token.</li>
<li><strong class="source-inline">public CancellationTokenRegistration Register(Action callback)</strong>: Allows code to register a delegate that will be executed by the system if this token is canceled.</li>
<li><strong class="source-inline">public void ThrowIfCancellationRequested()</strong>: Calling this method will result in <strong class="source-inline">OperationCanceledException</strong> being thrown if a cancellation has been requested. This is typically used to break out of loops.</li>
</ul>
<p>Throughout the previous examples, you may have spotted that <strong class="source-inline">CancellationToken</strong> can be passed to many of the static <strong class="source-inline">Task</strong> methods. For example, <strong class="source-inline">Task.Run</strong>, <strong class="source-inline">Task.Factory.StartNew</strong>, and <strong class="source-inline">Task.ContinueWith</strong> all contain overrides that accept <strong class="source-inline">CancellationToken</strong>.</p>
<p>.NET will not try to interrupt or stop any of your code once it is running, no matter how many times you call <strong class="source-inline">Cancel</strong> on a <strong class="source-inline">CancellationToken</strong>. Essentially, you pass these tokens into target code, but it is up to that code to periodically check the cancellation status whenever it can, such as within a loop, and then decide how it should act upon it. This makes logical sense; how would .NET know at what point it was safe to interrupt a method, maybe one that has hundreds of lines of code?</p>
<p>Passing <strong class="source-inline">CancellationToken</strong> to <strong class="source-inline">Task.Run</strong> only provides a hint to the queue scheduler that it may not need to start a task's action, but once started, .NET will not stop that running code for you. The running code itself must subsequently observe the cancelation status.</p>
<p>This is analogous to a pedestrian waiting to cross a road at a set of traffic lights. Motor vehicles can be thought of as tasks that have been started elsewhere. When the pedestrian arrives at the crossing and they press a button (calling <strong class="source-inline">Cancel</strong> on <strong class="source-inline">CancellationTokenSource</strong>), the traffic lights should eventually change to red so that the moving vehicles are requested to stop. It is up to each individual driver to observe that the red light has changed (<strong class="source-inline">IsCancellationRequested</strong>) and then decide to stop their vehicle. The traffic light does not forcibly stop each vehicle (.NET runtime). If a driver notices that the vehicle behind is too close and stopping soon may result in a collision, they may decide to not stop immediately. A driver that is not observing the traffic light status at all may fail to stop.</p>
<p>The next sections will continue with exercises that show <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> in action, some of the commonly used options for canceling tasks, in which you will need to control whether pending tasks should be allowed to run to completion or interrupted, and when you should aim to catch exceptions.</p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor225"/>Exercise 5.04: Canceling Long-Running Tasks</h2>
<p>You will create this exercise in two parts:</p>
<ul>
<li>One that uses a <strong class="source-inline">Task</strong> that returns a double-based result.</li>
<li>Second that provides a fine-grained level of control by inspecting the <strong class="source-inline">Token.IsCancellationRequested</strong> property.</li>
</ul>
<p>Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">Create a class called <strong class="source-inline">SlowRunningService</strong>. As the name suggests, the methods inside the service have been designed to be slow to complete:<p class="source-code">using System;</p><p class="source-code">using System.Globalization;</p><p class="source-code">using System.Threading;</p><p class="source-code">using System.Threading.Tasks;</p><p class="source-code">namespace Chapter05.Exercises.Exercise04</p><p class="source-code">{</p><p class="source-code">    public class SlowRunningService</p><p class="source-code">    {</p></li>
<li>Add the first slow-running operation, <strong class="source-inline">Fetch</strong>, which is passed a delay time (implemented with a simple <strong class="source-inline">Thread.Sleep</strong> call), and the cancellation token, which you pass to <strong class="source-inline">Task.Run</strong>:<p class="source-code">        public Task&lt;double&gt; Fetch(TimeSpan delay, CancellationToken token)</p><p class="source-code">        {</p><p class="source-code">            return Task.Run(() =&gt;</p><p class="source-code">                {</p><p class="source-code">                    var now = DateTime.Now;</p><p class="source-code">                    Logger.Log("Fetch: Sleeping");</p><p class="source-code">                    Thread.Sleep(delay);</p><p class="source-code">                    Logger.Log("Fetch: Awake");</p><p class="source-code">                    return DateTime.Now.Subtract(now).TotalSeconds;</p><p class="source-code">                },</p><p class="source-code">                token);</p><p class="source-code">        }</p></li>
</ol>
<p>When <strong class="source-inline">Fetch</strong> is called, the token may get canceled before the sleeping thread awakes.</p>
<ol>
<li value="3">To test whether <strong class="source-inline">Fetch</strong> will just stop running or return a number, add a console app to test this. Here, use a default delay (<strong class="source-inline">DelayTime</strong>) of <strong class="source-inline">3</strong> seconds:<p class="source-code">    public class Program</p><p class="source-code">    {</p><p class="source-code">        private static readonly TimeSpan DelayTime=TimeSpan.FromSeconds(3);</p></li>
<li>Add a helper function to prompt for a maximum number of seconds that you are prepared to wait. If a valid number is entered, convert the value entered into a <strong class="source-inline">TimeSpan</strong>:<p class="source-code">        private static TimeSpan? ReadConsoleMaxTime(string message)</p><p class="source-code">        {</p><p class="source-code">            Console.Write($"{message} Max Waiting Time (seconds):");</p><p class="source-code">            var input = Console.ReadLine();</p><p class="source-code">            if (int.TryParse(input, NumberStyles.Any, CultureInfo.CurrentCulture, out var intResult))</p><p class="source-code">            {</p><p class="source-code">                return TimeSpan.FromSeconds(intResult);</p><p class="source-code">            }</p><p class="source-code">            return null;</p><p class="source-code">        }</p></li>
<li>Add a standard <strong class="source-inline">Main</strong> entry point for the console app. This is marked async and returns a <strong class="source-inline">Task</strong>:<p class="source-code">public static async Task Main()</p><p class="source-code">        {</p></li>
<li>Create an instance of the service. You will use the same instance in a loop, shortly:<p class="source-code">            var service = new SlowRunningService();</p></li>
<li>Now add a <strong class="source-inline">do</strong>-loop that repeatedly asks for a maximum delay time:<p class="source-code">          Console.WriteLine($"ETA: {DelayTime.TotalSeconds:N} seconds");  </p><p class="source-code">          </p><p class="source-code">          TimeSpan? maxWaitingTime;</p><p class="source-code">            while (true)</p><p class="source-code">            {</p><p class="source-code">                maxWaitingTime = ReadConsoleMaxTime("Fetch");</p><p class="source-code">                if (maxWaitingTime == null)</p><p class="source-code">                    break;</p></li>
</ol>
<p>This allows you to try various values to see how that affects the cancel token and the results you receive back. In the case of a <strong class="source-inline">null</strong> value, you will <strong class="source-inline">break</strong> out of the <strong class="source-inline">do</strong>-loop.</p>
<ol>
<li value="8">Create <strong class="source-inline">CancellationTokenSource</strong>, passing in the maximum waiting time:<p class="source-code">                using var tokenSource = new CancellationTokenSource( maxWaitingTime.Value);</p><p class="source-code">                var token = tokenSource.Token;</p></li>
</ol>
<p>This will trigger a cancellation without having to call the <strong class="source-inline">Cancel</strong> method yourself.</p>
<ol>
<li value="9">Using the <strong class="source-inline">CancellationToken.Register</strong> method, pass an <strong class="source-inline">Action</strong> delegate to be invoked when the token gets signaled for cancellation. Here, simply log a message when that occurs:<p class="source-code">                token.Register(() =&gt; Logger.Log($"Fetch: Cancelled token={token.GetHashCode()}"));</p></li>
<li>Now for the main activity, call the service's <strong class="source-inline">Fetch</strong> method, passing in the default <strong class="source-inline">DelayTime</strong> and the token:<p class="source-code">                var resultTask = service.Fetch(DelayTime, token);</p></li>
<li>Before you await <strong class="source-inline">resultTask</strong>, add a <strong class="source-inline">try-catch</strong> block to catch any <strong class="source-inline">TaskCanceledException</strong>:<p class="source-code">                try</p><p class="source-code">                {</p><p class="source-code">                    await resultTask;</p><p class="source-code">                    if (resultTask.IsCompletedSuccessfully)</p><p class="source-code">                        Logger.Log($"Fetch: Result={resultTask.Result:N0}");</p><p class="source-code">                    else</p><p class="source-code">                        Logger.Log($"Fetch: Status={resultTask.Status}");</p><p class="source-code">                }</p><p class="source-code">                catch (TaskCanceledException ex)</p><p class="source-code">                {</p><p class="source-code">                    Logger.Log($"Fetch: TaskCanceledException {ex.Message}");</p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>W<a id="_idTextAnchor226"/>hen using cancelable tasks, there is a possibility that they will throw <strong class="source-inline">TaskCanceledException</strong>. In this case, that is okay as you do expect that to happen. Notice that you only access the <strong class="source-inline">resultTask.Result</strong> if the task is marked as <strong class="source-inline">IsCompletedSuccessfully</strong>. If you attempt to access the <strong class="source-inline">Result</strong> property of a faulted task, then <strong class="source-inline">AggregateException</strong> instance is thrown. In some older projects, you may see non-async/await code that catches <strong class="source-inline">AggregateException</strong>.</p>
<ol>
<li value="12">Run the app and enter a waiting time greater than the ETA of three seconds, <strong class="source-inline">5</strong> in this case:<p class="source-code">ETA: 3.00 seconds</p><p class="source-code">Fetch Max Waiting Time (seconds):5</p><p class="source-code">16:48:11 [04] Fetch: Sleeping</p><p class="source-code">16:48:14 [04] Fetch: Awake</p><p class="source-code">16:48:14 [04] Fetch: Result=3</p></li>
</ol>
<p>As expected, the token was not canceled prior to completion, so you see <strong class="source-inline">Result=3</strong> (the elapsed time in seconds).</p>
<ol>
<li value="13">Try this again. For the cancellation to be triggered and detected, enter <strong class="source-inline">2</strong> for the number of seconds:<p class="source-code">Fetch Max Waiting Time (seconds):2</p><p class="source-code">16:49:51 [04] Fetch: Sleeping</p><p class="source-code">16:49:53 [08] Fetch: Cancelled token=28589617</p><p class="source-code">16:49:54 [04] Fetch: Awake</p><p class="source-code">16:49:54 [04] Fetch: Result=3 </p></li>
</ol>
<p>Notice that the <strong class="source-inline">Cancelled token</strong> message is logged <strong class="bold">before</strong> the <strong class="source-inline">Fetch</strong> awakes, but you still end up receiving a result of <strong class="source-inline">3</strong> seconds with no <strong class="source-inline">TaskCanceledException</strong> message. This emphasizes the point that passing a cancellation token to <strong class="source-inline">Start.Run</strong> does not stop the task's action from starting, and more importantly, it did not interrupt it either.</p>
<ol>
<li value="14">Finally, use <strong class="source-inline">0</strong> as the maximum waiting time, which will effectively trigger the cancellation immediately:<p class="source-code">Fetch Max Waiting Time (seconds):</p><p class="source-code">0</p><p class="source-code">16:53:32 [04] Fetch: Cancelled token=48717705</p><p class="source-code">16:53:32 [04] Fetch: TaskCanceledException A task was canceled. </p></li>
</ol>
<p>You will see the canceled token message and <strong class="source-inline">TaskCanceledException</strong> being caught, but there are no <strong class="source-inline">Sleeping</strong> or <strong class="source-inline">Awake</strong> messages logged at all. This shows that the <strong class="source-inline">Action</strong> passed to <strong class="source-inline">Task.Run</strong> was not actually started by the runtime. When you pass a <strong class="source-inline">CancelationToken</strong> to <strong class="source-inline">Start.Run</strong>, the task's <strong class="source-inline">Action</strong> gets queued but <strong class="source-inline">TaskScheduler</strong> will not run the action if it notices that the token has been canceled prior to starting; it just throws <strong class="source-inline">TaskCanceledException</strong>.</p>
<p>Now for an alternative slow-running method, one that allows you to support cancellable actions via a loop that polls for a change in the cancellation status.</p>
<ol>
<li value="15">In the <strong class="source-inline">SlowRunningService</strong> class, add a <strong class="source-inline">FetchLoop</strong> function:<p class="source-code">        public Task&lt;double?&gt; FetchLoop(TimeSpan delay, CancellationToken token)</p><p class="source-code">        {</p><p class="source-code">            return Task.Run(() =&gt;</p><p class="source-code">            {</p><p class="source-code">                const int TimeSlice = 500;</p><p class="source-code">                var iterations = (int)(delay.TotalMilliseconds / TimeSlice);</p><p class="source-code">                Logger.Log($"FetchLoop: Iterations={iterations} token={token.GetHashCode()}");</p><p class="source-code">                var now = DateTime.Now;</p></li>
</ol>
<p>This produces a result similar to the earlier <strong class="source-inline">Fetch</strong> function but its purpose is to show how a function can be broken into a repeating loop that offers the ability to examine <strong class="source-inline">CancellationToken</strong> as each loop iteration runs.</p>
<ol>
<li value="16">Define the body of a <strong class="source-inline">for...next</strong> loop, which checks, for each iteration, if the <strong class="source-inline">IsCancellationRequested</strong> property is <strong class="source-inline">true</strong> and simply returns a nullable double if it detects that a cancellation has been requested:<p class="source-code">                for (var i = 0; i &lt; iterations; i++)</p><p class="source-code">                {</p><p class="source-code">                    if (token.IsCancellationRequested)</p><p class="source-code">                    {</p><p class="source-code">                        Logger.Log($"FetchLoop: Iteration {i + 1} detected cancellation token={token.GetHashCode()}");</p><p class="source-code">                        return (double?)null;</p><p class="source-code">                    }</p><p class="source-code">                    Logger.Log($"FetchLoop: Iteration {i + 1} Sleeping");</p><p class="source-code">                    Thread.Sleep(TimeSlice);</p><p class="source-code">                    Logger.Log($"FetchLoop: Iteration {i + 1} Awake");</p><p class="source-code">                }</p><p class="source-code">                Logger.Log("FetchLoop: done");</p><p class="source-code">                return DateTime.Now.Subtract(now).TotalSeconds;</p><p class="source-code">            }, token);</p><p class="source-code">        }</p></li>
</ol>
<p>This is a rather firm way to exit a loop, but as far as this code is concerned, nothing else needs to be done.</p>
<p class="callout-heading">Note</p>
<p class="callout">You could have also used a <strong class="source-inline">continue</strong> statement and cleaned up before returning. Another option is to call <strong class="source-inline">token.ThrowIfCancellationRequested()</strong> rather than checking <strong class="source-inline">token.IsCancellationRequested</strong>, which will force you to exit the <strong class="source-inline">for</strong> loop.</p>
<ol>
<li value="17">In the <strong class="source-inline">Main</strong> console app, add a similar <strong class="source-inline">while</strong> loop that calls the <strong class="source-inline">FetchLoop</strong> method this time. The code is similar to the previous looping code:<p class="source-code">        while (true)</p><p class="source-code">            {</p><p class="source-code">                maxWaitingTime = ReadConsoleMaxTime("FetchLoop");</p><p class="source-code">                if (maxWaitingTime == null)</p><p class="source-code">                    break;</p><p class="source-code">                using var tokenSource = new CancellationTokenSource(maxWaitingTime.Value);</p><p class="source-code">                var token = tokenSource.Token;</p><p class="source-code">                token.Register(() =&gt; Logger.Log($"FetchLoop: Cancelled token={token.GetHashCode()}"));</p></li>
<li>Now call the <strong class="source-inline">FetchLoop</strong> and await the result:<p class="source-code">                var resultTask = service.FetchLoop(DelayTime, token);</p><p class="source-code">                try</p><p class="source-code">                {</p><p class="source-code">                    await resultTask;</p><p class="source-code">                    if (resultTask.IsCompletedSuccessfully)</p><p class="source-code">                        Logger.Log($"FetchLoop: Result={resultTask.Result:N0}");</p><p class="source-code">                    else</p><p class="source-code">                        Logger.Log($"FetchLoop: Status={resultTask.Status}");</p><p class="source-code">                }</p><p class="source-code">                catch (TaskCanceledException ex)</p><p class="source-code">                {</p><p class="source-code">                    Logger.Log($"FetchLoop: TaskCanceledException {ex.Message}");</p><p class="source-code">                }</p><p class="source-code">            } </p></li>
<li>Running the console app and using a <strong class="source-inline">5</strong>-second maximum allows all the iterations to run through with none detecting a cancellation request. The result is <strong class="source-inline">3</strong> as expected:<p class="source-code">FetchLoop Max Waiting Time (seconds):5</p><p class="source-code">17:33:38 [04] FetchLoop: Iterations=6 token=6044116</p><p class="source-code">17:33:38 [04] FetchLoop: Iteration 1 Sleeping</p><p class="source-code">17:33:38 [04] FetchLoop: Iteration 1 Awake</p><p class="source-code">17:33:38 [04] FetchLoop: Iteration 2 Sleeping</p><p class="source-code">17:33:39 [04] FetchLoop: Iteration 2 Awake</p><p class="source-code">17:33:39 [04] FetchLoop: Iteration 3 Sleeping</p><p class="source-code">17:33:39 [04] FetchLoop: Iteration 3 Awake</p><p class="source-code">17:33:39 [04] FetchLoop: Iteration 4 Sleeping</p><p class="source-code">17:33:40 [04] FetchLoop: Iteration 4 Awake</p><p class="source-code">17:33:40 [04] FetchLoop: Iteration 5 Sleeping</p><p class="source-code">17:33:40 [04] FetchLoop: Iteration 5 Awake</p><p class="source-code">17:33:40 [04] FetchLoop: Iteration 6 Sleeping</p><p class="source-code">17:33:41 [04] FetchLoop: Iteration 6 Awake</p><p class="source-code">17:33:41 [04] FetchLoop: done</p><p class="source-code">17:33:41 [04] FetchLoop: Result=3</p></li>
<li>Use <strong class="source-inline">2</strong> as the maximum. This time the token is auto-triggered during iteration <strong class="source-inline">4</strong> and spotted by iteration <strong class="source-inline">5</strong>, so you are returned a null result:<p class="source-code">FetchLoop Max Waiting Time (seconds):</p><p class="source-code">2</p><p class="source-code">17:48:47 [04] FetchLoop: Iterations=6 token=59817589</p><p class="source-code">17:48:47 [04] FetchLoop: Iteration 1 Sleeping</p><p class="source-code">17:48:48 [04] FetchLoop: Iteration 1 Awake</p><p class="source-code">17:48:48 [04] FetchLoop: Iteration 2 Sleeping</p><p class="source-code">17:48:48 [04] FetchLoop: Iteration 2 Awake</p><p class="source-code">17:48:48 [04] FetchLoop: Iteration 3 Sleeping</p><p class="source-code">17:48:49 [04] FetchLoop: Iteration 3 Awake</p><p class="source-code">17:48:49 [04] FetchLoop: Iteration 4 Sleeping</p><p class="source-code">17:48:49 [06] FetchLoop: Cancelled token=59817589</p><p class="source-code">17:48:49 [04] FetchLoop: Iteration 4 Awake</p><p class="source-code">17:48:49 [04] FetchLoop: Iteration 5 detected cancellation token=59817589</p><p class="source-code">17:48:49 [04] FetchLoop: Result=</p></li>
<li>By using <strong class="source-inline">0</strong>, you see the same output as the earlier <strong class="source-inline">Fetch</strong> example:<p class="source-code">FetchLoop Max Waiting Time (seconds):</p><p class="source-code">0</p><p class="source-code">17:53:29 [04] FetchLoop: Cancelled token=48209832</p><p class="source-code">17:53:29 [08] FetchLoop: TaskCanceledException A task was canceled.</p></li>
</ol>
<p>The action doesn't get a chance to run. You can see a <strong class="source-inline">Cancelled token</strong> message and <strong class="source-inline">TaskCanceledException</strong> being logged.</p>
<p>By running this exercise, you have seen how long-running tasks can be automatically marked for cancellation by the .NET runtime if they do not complete within a specified time. By using a <strong class="source-inline">for</strong> loop, a task was broken down into small iterative steps, which provided a frequent opportunity to detect if a cancellation was requested.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/xa1Yf">https://packt.link/xa1Yf</a>.</p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor227"/>Exception Handling in Async/Await Code</h2>
<p>You have seen that canceling a task can result in <strong class="source-inline">TaskCanceledException</strong> being thrown. Exception handling for asynchronous code can be implemented in the same way you would for standard synchronous code, but there are a few things you need to be aware of.</p>
<p>When code in an <strong class="source-inline">async</strong> method causes an exception to be thrown, the task's status is set to <strong class="bold">Faulted</strong>. However, an exception will not be rethrown until the awaited expression gets rescheduled. What this mean is that if you do not await a call, then it's possible for exceptions to be thrown and to go completely unobserved in code.</p>
<p>Unless you absolutely cannot help it, you should not create <strong class="source-inline">async void</strong> methods. Doing so makes it difficult for the caller to await your code. This means they cannot catch any exceptions raised, which by default, will terminate a program. If the caller is not given a <strong class="source-inline">Task</strong> reference to await, then there is no way for them to tell if the called method ran to completion or not.</p>
<p>The general exception to this guideline is in the case of fire-and-forget methods as mentioned at the start of the chapter. A method that asynchronously logs the usage of the application may not be of such critical importance, so you may not care if such calls are successful or not.</p>
<p>It is possible to detect and handle unobserved task exceptions. If you attach an event delegate to the static <strong class="source-inline">TaskScheduler.UnobservedTaskException</strong> event, you can receive a notification that a task exception has gone unobserved. You can attach a delegate to this event as follows:</p>
<p class="source-code">TaskScheduler.UnobservedTaskException += (sender, args) =&gt;</p>
<p class="source-code">{</p>
<p class="source-code">  Logger.Log($"Caught UnobservedTaskException\n{args.Exception}");</p>
<p class="source-code">};</p>
<p>The runtime considers a task exception to be <strong class="bold">unobserved</strong> once the task object is finalized.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/OkH7r">https://packt.link/OkH7r</a>.</p>
<p>Continuing with some more exception handling examples, see how you can catch a specific type of exception as you would with synchronous code.</p>
<p>In the following example, the <strong class="source-inline">CustomerOperations</strong> class provides the <strong class="source-inline">AverageDiscount</strong> function, which returns <strong class="source-inline">Task&lt;int&gt;</strong>. However, there is a chance that it may throw <strong class="source-inline">DivideByZeroException</strong>, so you will need to catch that; otherwise, the program will crash.</p>
<p class="source-code">using System;</p>
<p class="source-code">using System.Threading.Tasks;</p>
<p class="source-code">namespace Chapter05.Examples</p>
<p class="source-code">{</p>
<p class="source-code">    class ErrorExamplesProgram</p>
<p class="source-code">    {</p>
<p class="source-code">        public static async Task Main()</p>
<p class="source-code">        {</p>
<p class="source-code">            try</p>
<p class="source-code">            {</p>
<p>Create a <strong class="source-inline">CustomerOperations</strong> instance and wait for the <strong class="source-inline">AverageDiscount</strong> method to return a value:</p>
<p class="source-code">                var operations = new CustomerOperations();</p>
<p class="source-code">                var discount = await operations.AverageDiscount();</p>
<p class="source-code">                Logger.Log($"Discount: {discount}");</p>
<p class="source-code">            }</p>
<p class="source-code">            catch (DivideByZeroException)</p>
<p class="source-code">            {</p>
<p class="source-code">                Console.WriteLine("Caught a divide by zero");</p>
<p class="source-code">            }</p>
<p class="source-code">            Console.ReadLine();</p>
<p class="source-code">        }</p>
<p class="source-code">        class CustomerOperations</p>
<p class="source-code">        {</p>
<p class="source-code">            public async Task&lt;int&gt; AverageDiscount()</p>
<p class="source-code">            {</p>
<p class="source-code">                Logger.Log("Loading orders...");</p>
<p class="source-code">                await Task.Delay(TimeSpan.FromSeconds(1));</p>
<p>Choose a random value for <strong class="source-inline">ordercount</strong> between <strong class="source-inline">0</strong> and <strong class="source-inline">2</strong>. An attempt to divide by zero will result in an exception being thrown by the .NET runtime:</p>
<p class="source-code">                var orderCount = new Random().Next(0, 2);</p>
<p class="source-code">                var orderValue = 1200;</p>
<p class="source-code">                return orderValue / orderCount;</p>
<p class="source-code">            }</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p>The results show that when <strong class="source-inline">orderCount</strong> was zero, you did catch <strong class="source-inline">DivideByZeroException</strong> as expected:</p>
<p class="source-code">15:47:21 [01] Loading orders...</p>
<p class="source-code">Caught a divide by zero</p>
<p>Running a second time, there was no error caught:</p>
<p class="source-code">17:55:54 [01] Loading orders...</p>
<p class="source-code">17:55:55 [04] Discount: 1200</p>
<p>On your system you may find that the program needs to be run multiple times before the <strong class="source-inline">DivideByZeroException</strong> is raised. This is due to the use of a random instance to assign a value to <strong class="source-inline">orderCount</strong>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/18kOK">https://packt.link/18kOK</a>.</p>
<p>So far, you have created single tasks that may throw exceptions. The following exercise will look at a more complex variant.</p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor228"/>Exercise 5.05: Handling Async Exceptions</h2>
<p>Imagine you have a <strong class="source-inline">CustomerOperations</strong> class that can be used to fetch a list of customers via a <strong class="source-inline">Task</strong>. For each customer, you need to run an extra <strong class="source-inline">async</strong> task, which goes off to a service to calculate the total value of that customer's orders.</p>
<p>Once you have your customer list, the customers need to be sorted in descending order of sales, but due to some security restrictions, you are not allowed to read a customer's <strong class="source-inline">TotalOrders</strong> property if their region name is <strong class="source-inline">West</strong>. In this exercise you will create a copy of the <strong class="source-inline">RegionName</strong> enum that was used in the earlier example.</p>
<p>Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">Start by adding the <strong class="source-inline">Customer</strong> class:<p class="source-code">1    using System;</p><p class="source-code">2    using System.Collections.Generic;</p><p class="source-code">3    using System.Linq;</p><p class="source-code">4    using System.Threading.Tasks;</p><p class="source-code">5</p><p class="source-code">6    namespace Chapter05.Exercises.Exercise05</p><p class="source-code">7    {</p><p class="source-code">8        public enum RegionName { North, East, South, West };</p><p class="source-code">9</p><p class="source-code">10        public class Customer</p><p class="source-code">11        {</p><p class="source-code">12            private readonly RegionName _protectedRegion;</p><p class="source-code">13</p><p class="source-code">14            public Customer(string name, RegionName region, RegionName protectedRegion)</p><p class="source-code">15            {</p></li>
</ol>
<p>The constructor is passed the customer <strong class="source-inline">name</strong> and their <strong class="source-inline">region</strong>, along with a second region that identifies the <strong class="source-inline">protectedRegion</strong> name. If the customer's <strong class="source-inline">region</strong> is the same as this <strong class="source-inline">protectedRegion</strong>, then throw an access violation exception on any attempt to read the <strong class="source-inline">TotalOrders</strong> property.</p>
<ol>
<li value="2">Then add a <strong class="source-inline">CustomerOperations</strong> class:<p class="source-code">public class CustomerOperations</p><p class="source-code">{</p><p class="source-code">   public const RegionName ProtectedRegion = RegionName.West;</p></li>
</ol>
<p>This knows how to load a customer's name and populate their total order value. The requirement here is that customers from the <strong class="source-inline">West</strong> region need to have a restriction hardcoded, so add a constant called <strong class="source-inline">ProtectedRegion</strong> that has <strong class="source-inline">RegionName.West</strong> as a value.</p>
<ol>
<li value="3">Add a <strong class="source-inline">FetchTopCustomers</strong> function:<p class="source-code">        public async Task&lt;IEnumerable&lt;Customer&gt;&gt; FetchTopCustomers()</p><p class="source-code">        {</p><p class="source-code">            await Task.Delay(TimeSpan.FromSeconds(2));</p><p class="source-code">            Logger.Log("Loading customers...");</p><p class="source-code">            var customers = new List&lt;Customer&gt;</p><p class="source-code">            {</p><p class="source-code">            new Customer("Rick Deckard", RegionName.North, ProtectedRegion),</p><p class="source-code">            new Customer("Taffey Lewis", RegionName.North, ProtectedRegion),</p><p class="source-code">            new Customer("Rachael", RegionName.North, ProtectedRegion),</p><p class="source-code">            new Customer("Roy Batty", RegionName.West, ProtectedRegion),</p><p class="source-code">            new Customer("Eldon Tyrell", RegionName.East, ProtectedRegion)</p><p class="source-code">            };</p></li>
</ol>
<p>This returns a <strong class="source-inline">Task</strong> enumeration of <strong class="source-inline">Customer</strong> and is marked as <strong class="source-inline">async</strong> as you will make further <strong class="source-inline">async</strong> calls to populate each customer's order details inside the function. Await using <strong class="source-inline">Task.Delay</strong> to simulate a slow-running operation. Here, a sample list of customers is hardcoded. Create each <strong class="source-inline">Customer</strong> instance, passing their name, actual region, and the protected region constant, <strong class="source-inline">ProtectedRegion</strong>.</p>
<ol>
<li value="4">Add an <strong class="source-inline">await</strong> call to <strong class="source-inline">FetchOrders</strong> (which will be declared shortly):<p class="source-code">            await FetchOrders(customers);</p></li>
<li>Now, iterate through the list of customers, but be sure to wrap each call to <strong class="source-inline">TotalOrders</strong> with a <strong class="source-inline">try-catch</strong> block that explicitly checks for the access violation exception that will be thrown if you attempt to view a protected customer:<p class="source-code">            var filteredCustomers = new List&lt;Customer&gt;();</p><p class="source-code">            foreach (var customer in customers)</p><p class="source-code">            {</p><p class="source-code">                try</p><p class="source-code">                {</p><p class="source-code">                    if (customer.TotalOrders &gt; 0)</p><p class="source-code">                        filteredCustomers.Add(customer);</p><p class="source-code">                }</p><p class="source-code">                catch (AccessViolationException e)</p><p class="source-code">                {</p><p class="source-code">                    Logger.Log($"Error {e.Message}");</p><p class="source-code">                }</p><p class="source-code">            }</p></li>
<li>Now that the <strong class="source-inline">filteredCustomers</strong> list has been populated with a filtered list of customers, use the Linq <strong class="source-inline">OrderByDescending</strong> extension method to return the items sorted by each customer's <strong class="source-inline">TotalOrders</strong> value:<p class="source-code">            return filteredCustomers.OrderByDescending(c =&gt; c.TotalOrders);</p><p class="source-code">        } </p></li>
<li>Finish off <strong class="source-inline">CustomerOperations</strong> with the <strong class="source-inline">FetchOrders</strong> implementation.</li>
<li>For each customer in the list, use an <strong class="source-inline">async</strong> lambda that pauses for <strong class="source-inline">500</strong> milliseconds before assigning a random value to <strong class="source-inline">TotalOrders</strong>:<p class="source-code">        private async Task FetchOrders(IEnumerable&lt;Customer&gt; customers)</p><p class="source-code">        {</p><p class="source-code">            var rand = new Random();</p><p class="source-code">            Logger.Log("Loading orders...");</p><p class="source-code">            var orderUpdateTasks = customers.Select(</p><p class="source-code">              cust =&gt; Task.Run(async () =&gt;</p><p class="source-code">              {</p><p class="source-code">                    await Task.Delay(500);</p><p class="source-code">                    cust.TotalOrders = rand.Next(1, 100);</p><p class="source-code">               }))</p><p class="source-code">              .ToList();</p></li>
</ol>
<p>The delay could represent another slow-running service.</p>
<ol>
<li value="9">Wait for <strong class="source-inline">orderUpdateTasks</strong> to complete using <strong class="source-inline">Task.WhenAll</strong>:<p class="source-code">            await Task.WhenAll(orderUpdateTasks);</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
<li>Now create a console app to run the operation:<p class="source-code">    public class Program</p><p class="source-code">    {</p><p class="source-code">        public static async Task Main()</p><p class="source-code">        {</p><p class="source-code">            var ops = new CustomerOperations();</p><p class="source-code">            var resultTask = ops.FetchTopCustomers();</p><p class="source-code">            var customers = await resultTask;</p><p class="source-code">            foreach (var customer in customers)</p><p class="source-code">            {</p><p class="source-code">                Logger.Log($"{customer.Name} ({customer.Region}): {customer.TotalOrders:N0}");</p><p class="source-code">            }</p><p class="source-code">            Console.ReadLine();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>On running the console, there are no errors as <strong class="source-inline">Roy Batty</strong> from the <strong class="source-inline">West</strong> region was skipped safely:<p class="source-code">20:00:15 [05] Loading customers...</p><p class="source-code">20:00:16 [05] Loading orders...</p><p class="source-code">20:00:16 [04] Error Cannot access orders for Roy Batty</p><p class="source-code">20:00:16 [04] Rachael (North): 56</p><p class="source-code">20:00:16 [04] Taffey Lewis (North): 19</p><p class="source-code">20:00:16 [04] Rick Deckard (North): 10</p><p class="source-code">20:00:16 [04] Eldon Tyrell (East): 6</p></li>
</ol>
<p>In this exercise, you saw how exceptions can be handled gracefully with asynchronous code. You placed a <strong class="source-inline">try-catch</strong> block at the required location, rather than over-complicating and adding too many unnecessary levels of nested <strong class="source-inline">try-catch</strong> blocks. When the code was run, an exception was caught that did not crash the application.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/4ozac">https://packt.link/4ozac</a>.</p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor229"/>The AggregateException Class</h2>
<p>At the beginning of the chapter, you saw that the <strong class="source-inline">Task</strong> class has an <strong class="source-inline">Exception</strong> property of type <strong class="source-inline">AggregateException</strong>. This class contains details about one or more errors that occur during an asynchronous call.</p>
<p><strong class="source-inline">AggregateException</strong> has various properties, but the main ones are as follows:</p>
<ul>
<li><strong class="source-inline">public ReadOnlyCollection&lt;Exception&gt; InnerExceptions { get; }</strong>: A collection of exceptions that caused the current exception. A single asynchronous call can result in multiple exceptions being raised and collected here.</li>
<li><strong class="source-inline">public AggregateException Flatten()</strong>: Flattens all of the <strong class="source-inline">AggregateException</strong> instances in the <strong class="source-inline">InnerExeceptions</strong> property into a single new instance. This saves you from having to iterate over <strong class="source-inline">AggregateException</strong> nested with the exceptions list.</li>
<li><strong class="source-inline">public void Handle(Func&lt;Exception, bool&gt; predicate)</strong>: Invokes the specified Func handler on every exception in this aggregate exception. This allows the handler to return <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> to indicate whether each exception was handled. Any remaining unhandled exceptions will be thrown for the caller to catch as required.</li>
</ul>
<p>When something goes wrong and this exception is caught by a caller, <strong class="source-inline">InnerExceptions</strong> contains a list of the exceptions that caused the current exception. These can be from multiple tasks, so each individual exception is added to the resulting task's <strong class="source-inline">InnerExceptions</strong> collection.</p>
<p>You may often find <strong class="source-inline">async</strong> code with a <strong class="source-inline">try-catch</strong> block that catches <strong class="source-inline">AggregateException</strong> and logs each of <strong class="source-inline">InnerExceptions</strong> details. In this example, <strong class="source-inline">BadTask</strong> returns an <strong class="source-inline">int</strong> based task, but it can be the cause of an exception when run. Perform the following steps to complete this example:</p>
<p class="source-code">using System;</p>
<p class="source-code">using System.Collections.Generic;</p>
<p class="source-code">using System.Linq;</p>
<p class="source-code">using System.Threading.Tasks;</p>
<p class="source-code">namespace Chapter05.Examples</p>
<p class="source-code">{</p>
<p class="source-code">    class WhenAllErrorExamples</p>
<p class="source-code">    {+</p>
<p>It sleeps for <strong class="source-inline">1,000</strong> milliseconds before throwing the <strong class="source-inline">InvalidOperationException</strong> in case the number passed in is an even number (using the % operator to see if the number can be divided by <strong class="source-inline">2</strong> with no remainder):</p>
<p class="source-code">        private static async Task&lt;int&gt; BadTask(string info, int n)</p>
<p class="source-code">        {</p>
<p class="source-code">            await Task.Delay(1000);</p>
<p class="source-code">            Logger.Log($"{info} number {n} awake");</p>
<p class="source-code">            if (n % 2 == 0)</p>
<p class="source-code">            {</p>
<p class="source-code">                Logger.Log($"About to throw one {info} number {n}"…");</p>
<p class="source-code">                throw new InvalidOperationException"($"Oh dear from {info} number "n}");</p>
<p class="source-code">            }</p>
<p class="source-code">            return n;</p>
<p class="source-code">        }</p>
<p>Add a helper function, <strong class="source-inline">CreateBadTasks</strong>, that creates a collection of five bad tasks. When started, each of the tasks will eventually throw an exception of type <strong class="source-inline">InvalidOperationException</strong>:</p>
<p class="source-code">        private static IEnumerable&lt;Task&lt;int&gt;&gt; CreateBadTasks(string info)</p>
<p class="source-code">        {</p>
<p class="source-code">            return Enumerable.Range(0, 5)</p>
<p class="source-code">                .Select(i =&gt; BadTask(info, i))</p>
<p class="source-code">                .ToList();</p>
<p class="source-code">        }</p>
<p>Now, create the console app's <strong class="source-inline">Main</strong> entry point. You pass the results of <strong class="source-inline">CreateBadTasks</strong> to <strong class="source-inline">WhenAll</strong>, passing in the string <strong class="source-inline">[WhenAll]</strong> to make it easier to see what is happening in the output:</p>
<p class="source-code">        public static async Task Main()</p>
<p class="source-code">        {</p>
<p class="source-code">            var whenAllCompletedTask = Task.WhenAll(CreateBadTasks("[WhenAll]"));</p>
<p>Before you attempt to await the <strong class="source-inline">whenAllCompletedTask</strong> task, you need to wrap it in <strong class="source-inline">try-catch</strong>, which catches the base <strong class="source-inline">Exception</strong> type (or a more specific one if you are expecting that).</p>
<p>You cannot catch <strong class="source-inline">AggregateException</strong> here as it's the first exception inside the <strong class="source-inline">Task</strong> that you receive, but you can still use the <strong class="source-inline">Exception</strong> property of <strong class="source-inline">whenAllCompletedTask</strong> to get at the <strong class="source-inline">AggregateException</strong> itself:</p>
<p class="source-code">            try</p>
<p class="source-code">            {</p>
<p class="source-code">                await whenAllCompletedTask;</p>
<p class="source-code">            }</p>
<p class="source-code">            catch (Exception ex)</p>
<p class="source-code">            {</p>
<p>You've caught an exception, so log its type (this will be <strong class="source-inline">InvalidOperationException</strong> instance that you threw) and the message:</p>
<p class="source-code">                Console.WriteLine($"WhenAll Caught {ex.GetType().Name}, Message={ex.Message}");</p>
<p>Now you can examine <strong class="source-inline">whenAllCompletedTask</strong>, iterating though this task's <strong class="source-inline">AggregateException</strong> to see its <strong class="source-inline">InnerExceptions</strong> list:</p>
<p class="source-code">                Console.WriteLine($"WhenAll Task.Status={whenAllCompletedTask.Status}");</p>
<p class="source-code">               foreach (var ie in whenAllCompletedTask.Exception.InnerExceptions)</p>
<p class="source-code">               {</p>
<p class="source-code">                   Console.WriteLine($"WhenAll Caught Inner Exception: {ie.Message}");</p>
<p class="source-code">               }</p>
<p class="source-code">            }</p>
<p class="source-code">            Console.ReadLine();</p>
<p class="source-code">        }      </p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p>Running the code, you'll see five tasks that sleep, and eventually, numbers <strong class="source-inline">0</strong>, <strong class="source-inline">2</strong>, and <strong class="source-inline">4</strong> each throw <strong class="source-inline">InvalidOperationException</strong>, which you will catch:</p>
<p class="source-code">17:30:36 [05] [WhenAll] number 3 awake</p>
<p class="source-code">17:30:36 [09] [WhenAll] number 1 awake</p>
<p class="source-code">17:30:36 [07] [WhenAll] number 0 awake</p>
<p class="source-code">17:30:36 [06] [WhenAll] number 2 awake</p>
<p class="source-code">17:30:36 [04] [WhenAll] number 4 awake</p>
<p class="source-code">17:30:36 [06] About to throw one [WhenAll] number 2...</p>
<p class="source-code">17:30:36 [04] About to throw one [WhenAll] number 4...</p>
<p class="source-code">17:30:36 [07] About to throw one [WhenAll] number 0...</p>
<p class="source-code">WhenAll Caught InvalidOperationException, Message=Oh dear from [WhenAll] number 0</p>
<p class="source-code">WhenAll Task.Status=Faulted</p>
<p class="source-code">WhenAll Caught Inner Exception: Oh dear from [WhenAll] number 0</p>
<p class="source-code">WhenAll Caught Inner Exception: Oh dear from [WhenAll] number 2</p>
<p class="source-code">WhenAll Caught Inner Exception: Oh dear from [WhenAll] number 4</p>
<p>Notice how <strong class="source-inline">number 0</strong> appears to be the only error that was caught (<strong class="source-inline">(Message=Oh</strong> dear from <strong class="source-inline">[WhenAll] number 0</strong>). However, by logging each entry in the <strong class="source-inline">InnerExceptions</strong> list, you see all <strong class="bold">three</strong> erroneous tasks with <strong class="source-inline">number 0</strong> appearing once again.</p>
<p>You can try the same code, but this time use <strong class="source-inline">WhenAny</strong>. Remember that <strong class="source-inline">WhenAny</strong> will complete when the first task in the list completes, so notice the complete lack of <strong class="bold">error handling</strong> in this case:</p>
<p class="source-code">            var whenAnyCompletedTask = Task.WhenAny(CreateBadTasks("[WhenAny]"));</p>
<p class="source-code">            var result = await whenAnyCompletedTask;</p>
<p class="source-code">            Logger.Log($"WhenAny result: {result.Result}");</p>
<p>Unless you wait for all tasks to complete, you may miss an exception raised by a task when using <strong class="source-inline">WhenAny</strong>. Running this code results in not a single error being caught and the app does <strong class="bold">not</strong> break. The result is <strong class="source-inline">3</strong> as that completed first:</p>
<p class="source-code">18:08:46 [08] [WhenAny] number 2 awake</p>
<p class="source-code">18:08:46 [10] [WhenAny] number 0 awake</p>
<p class="source-code">18:08:46 [10] About to throw one [WhenAny] number 0...</p>
<p class="source-code">18:08:46 [07] [WhenAny] number 3 awake</p>
<p class="source-code">18:08:46 [09] [WhenAny] number 1 awake</p>
<p class="source-code">18:08:46 [07] WhenAny result: 3</p>
<p class="source-code">18:08:46 [08] About to throw one [WhenAny] number 2...</p>
<p class="source-code">18:08:46 [06] [WhenAny] number 4 awake</p>
<p class="source-code">18:08:46 [06] About to throw one [WhenAny] number 4...</p>
<p>You will finish this look at <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> code by looking at some of the newer options in C# around handling streams of <strong class="source-inline">async</strong> results. This provides a way to efficiently iterate through the items of a collection without the calling code having to wait for the entire collection to be populated and returned before it can start processing the items in the list.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/SuCXK">https://packt.link/SuCXK</a>.</p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor230"/>IAsyncEnumerable Streams</h2>
<p>If your application targets .NET 5, .NET6, .NET Core 3.0, .NET Standard 2.1, or any of the later versions, then you can use <strong class="source-inline">IAsyncEnumerable</strong> streams to create awaitable code that combines the <strong class="source-inline">yield</strong> keyword into an enumerator to iterate asynchronously through a collection of objects.</p>
<p class="callout-heading">Note</p>
<p class="callout">Microsoft's documentation provides this definition of the <strong class="source-inline">yield</strong> keyword: When a <strong class="source-inline">yield</strong> return statement is reached in the iterator method, expression is returned, and the current location in code is retained. Execution is restarted from that location the next time that the iterator function is called.</p>
<p>Using the <strong class="source-inline">yield</strong> statement, you can create methods that return an enumeration of items to the caller. Additionally, the caller does not need to wait for the <strong class="bold">entire list</strong> of items to be returned before they can start traversing each item in the list. Instead, the caller can access each item as soon as it becomes available.</p>
<p>In this example, you will create a console app that replicates an insurance quoting system. You will make five requests for an insurance quote, once again using <strong class="source-inline">Task.Delay</strong> to simulate a 1-second delay in receiving each delay.</p>
<p>For the list-based approach, you can only log each quote once all five results have been received back to the <strong class="source-inline">Main</strong> method. Using <strong class="source-inline">IAsyncEnumerable</strong> and the <strong class="source-inline">yield</strong> keyword, the same one second exists between quotes being received, but as soon as each quote is received, the <strong class="source-inline">yield</strong> statement allows the calling <strong class="source-inline">Main</strong> method to receive and process the value quoted. This is ideal if you want to start processing items right away or potentially do not want the overhead of having thousands of items in a list for longer than is needed to process them individually:</p>
<p class="source-code">using System;</p>
<p class="source-code">using System.Collections.Generic;</p>
<p class="source-code">using System.Threading.Tasks;</p>
<p class="source-code">namespace Chapter05.Examples</p>
<p class="source-code">{</p>
<p class="source-code">    class AsyncEnumerableExamplesProgram</p>
<p class="source-code">    {</p>
<p class="source-code">        public static async Task Main()</p>
<p class="source-code">        {</p>
<p>Start by <strong class="bold">awaiting</strong> for <strong class="source-inline">GetInsuranceQuotesAsTask</strong> to return a list of strings and iterate through each, logging the details of each quote. This code will wait for all quotes to be received before logging each item:</p>
<p class="source-code">            Logger.Log("Fetching Task quotes...");</p>
<p class="source-code">            var taskQuotes = await GetInsuranceQuotesAsTask();</p>
<p class="source-code">            foreach(var quote in taskQuotes)</p>
<p class="source-code">            {</p>
<p class="source-code">                Logger.Log($"Received Task: {quote}");</p>
<p class="source-code">            }</p>
<p>Now for the <strong class="source-inline">async</strong> stream version. If you compare the following code to the preceeding code block, you'll see that there are fewer lines of code needed to iterate through the items returned. This code does not wait for all quote items to be received but instead writes out each quote as soon as it is received from <strong class="source-inline">GetInsuranceQuotesAsync</strong>:</p>
<p class="source-code">            Logger.Log("Fetching Stream quotes...");</p>
<p class="source-code">            await foreach (var quote in GetInsuranceQuotesAsync())</p>
<p class="source-code">            {</p>
<p class="source-code">                Logger.Log($"Received Stream: {quote}");</p>
<p class="source-code">            }</p>
<p class="source-code">            Logger.Log("All done...");</p>
<p class="source-code">            Console.ReadLine();</p>
<p class="source-code">        }</p>
<p>The <strong class="source-inline">GetInsuranceQuotesAsTask</strong> method returns a <strong class="source-inline">Task</strong> of strings. Between each of the five quotes, you wait for one second to simulate a delay, before adding the result to the list and finally returning the entire list back to the caller:</p>
<p class="source-code">        private static async Task&lt;IEnumerable&lt;string&gt;&gt; GetInsuranceQuotesAsTask()</p>
<p class="source-code">        {</p>
<p class="source-code">            var rand = new Random();</p>
<p class="source-code">            var quotes = new List&lt;string&gt;();</p>
<p class="source-code">            for (var i = 0; i &lt; 5; i++)</p>
<p class="source-code">            {</p>
<p class="source-code">                await Task.Delay(1000);</p>
<p class="source-code">                quotes.Add($"Provider{i}'s quote is {rand.Next(5, 10)}");</p>
<p class="source-code">            }</p>
<p class="source-code">            return quotes;</p>
<p class="source-code">        } </p>
<p>The <strong class="source-inline">GetInsuranceQuotesAsync</strong> method contains the same delay between each quote, but rather than populating a list to return back to the caller, the <strong class="source-inline">yield</strong> statement is used to allow the <strong class="source-inline">Main</strong> method to process each quote item immediately:</p>
<p class="source-code">        private static async IAsyncEnumerable&lt;string&gt; GetInsuranceQuotesAsync()</p>
<p class="source-code">        {</p>
<p class="source-code">            var rand = new Random();</p>
<p class="source-code">            for (var i = 0; i &lt; 5; i++)</p>
<p class="source-code">            {</p>
<p class="source-code">                await Task.Delay(1000);</p>
<p class="source-code">                yield return $"Provider{i}'s quote is {rand.Next(5, 10)}";</p>
<p class="source-code">            }</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p>Running the console app produces the following output:</p>
<p class="source-code">09:17:57 [01] Fetching Task quotes...</p>
<p class="source-code">09:18:02 [04] Received Task: Provider0's quote is 7</p>
<p class="source-code">09:18:02 [04] Received Task: Provider1's quote is 9</p>
<p class="source-code">09:18:02 [04] Received Task: Provider2's quote is 9</p>
<p class="source-code">09:18:02 [04] Received Task: Provider3's quote is 8</p>
<p class="source-code">09:18:02 [04] Received Task: Provider4's quote is 8</p>
<p class="source-code">09:18:02 [04] Fetching Stream quotes...</p>
<p class="source-code">09:18:03 [04] Received Stream: Provider0's quote is 7</p>
<p class="source-code">09:18:04 [04] Received Stream: Provider1's quote is 8</p>
<p class="source-code">09:18:05 [05] Received Stream: Provider2's quote is 9</p>
<p class="source-code">09:18:06 [05] Received Stream: Provider3's quote is 8</p>
<p class="source-code">09:18:07 [04] Received Stream: Provider4's quote is 7</p>
<p class="source-code">09:18:07 [04] All done...</p>
<p>Thread <strong class="source-inline">[04]</strong> logged all five task-based quote details five seconds after the app started. Here, it waited for all quotes to be returned before logging each quote. However, notice that each of the stream-based quotes was logged as soon as it was yielded by threads <strong class="source-inline">4</strong> and <strong class="source-inline">5</strong> with 1 second between them.</p>
<p>The overall time taken for both calls is the same (5 seconds in total), but <strong class="source-inline">yield</strong> is preferrable when you want to start processing each result as soon as it is ready. This is often useful in UI apps where you can provide early results to the user.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/KarKW">https://packt.link/KarKW</a>.</p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor231"/>Parallel Programming</h2>
<p>So far, this chapter has covered async programming using the <strong class="source-inline">Task</strong> class and <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> keywords. You have seen how tasks and <strong class="source-inline">async</strong> blocks of code can be defined and the flow of a program can be finely controlled as these structures complete.</p>
<p>The Parallel Framework (PFX) offers further ways to utilize multicore processors to efficiently run concurrent operations. The phrase TPL (Task Parallel Library) is generally used to refer to the <strong class="source-inline">Parallel</strong> class in C#.</p>
<p>Using the Parallel Framework, you do not need to worry about the complexity of creating and reusing threads or coordinating multiple tasks. The framework manages this for you, even adjusting the number of threads that are used, in order to maximize throughput.</p>
<p>For parallel programming to be effective, the order in which each task executes must be irrelevant and all tasks should be independent of each other, as you cannot be certain when one task completes and the next one begins. Coordinating negates any benefits. Parallel programming can be broken down into two distinct concepts:</p>
<ul>
<li>Data parallelism</li>
<li>Task parallelism</li>
</ul>
<h3 id="_idParaDest-206"><a id="_idTextAnchor232"/>Data Parallelism</h3>
<p>Data parallelism is used when you have multiple data values, and the same operation is to be applied concurrently to each of those values. In this scenario, processing each of the values is partitioned across different threads.</p>
<p>A typical example might be calculating the prime numbers from one to 1,000,000. For each number in the range, the same function needs to be applied to determine whether the value is a prime. Rather than iterating through each number one at a time, an asynchronous approach would be to split numbers across multiple threads.</p>
<h3 id="_idParaDest-207"><a id="_idTextAnchor233"/>Task Parallelism</h3>
<p>Conversely, task parallelism is used where a collection of threads all performs a different action, such as calling different functions or sections of code, concurrently. One such example is a program that analyzes the words found in a book, by downloading the book's text and defining separate tasks to do the following:</p>
<ul>
<li>Count the number of words.</li>
<li>Find the longest word.</li>
<li>Calculate the average word length.</li>
<li>Count the number of noise words (the, and, of, for example).</li>
</ul>
<p>Each of these tasks can be run concurrently and they do not depend on each other.</p>
<p>For the <strong class="source-inline">Parallel</strong> class, the Parallel Framework provides various layers that offer parallelism, including Parallel Language Integrated Query (PLINQ). PLINQ is a collection of extension methods that add the power of parallel programming to the LINQ syntax. The PLINQ won't be covered here in detail, but the <strong class="source-inline">Parallel</strong> class will be covered in more detail.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you're interested in learning more about PLINQ, you can refer to the online documentation at <a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq">https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq</a>.</p>
<h3 id="_idParaDest-208"><a id="_idTextAnchor234"/>The Parallel Class</h3>
<p>The <strong class="source-inline">Parallel</strong> class contains just three <strong class="source-inline">static</strong> methods but there are numerous overloads providing options to control and influence how actions are performed. Each of the methods <strong class="bold">block</strong> the current thread, and if an exception occurs, whilst an iterator is working, the trailing iterators are stopped and an exception is thrown to the caller. Due to this blocking behavior, the <strong class="source-inline">Parallel</strong> class is often called from within an awaitable block such as <strong class="source-inline">Task.Run</strong>.</p>
<p>It is worth remembering that the runtime may run the required operations in parallel only if it thinks that is warranted. In the case of individual steps completing sooner than others, the runtime may decide that the overhead of running the remaining operations in parallel is not justified.</p>
<p>Some of the commonly used <strong class="source-inline">Parallel</strong> method overloads are as follows:</p>
<ul>
<li><strong class="source-inline">public static ParallelLoopResult For(int from, int to, Action&lt;int&gt; body)</strong>: This data parallelism call executes a loop by invoking the body <strong class="source-inline">Action</strong> delegate, passing in an <strong class="source-inline">int</strong> value across the from and to numeric range. It returns <strong class="source-inline">ParallelLoopResult</strong>, which contains details of the loop once completed.</li>
<li><strong class="source-inline">public static ParallelLoopResult For(int from, int to, ParallelOptions options, Action&lt;int, ParallelLoopState&gt; body)</strong>: A data parallelism call that executes a loop across the numeric range. <strong class="source-inline">ParallelOptions</strong> allows loop options to be configured and <strong class="source-inline">ParallelLoopState</strong> is used to monitor or manipulate the state of the loop as it runs. It returns <strong class="source-inline">ParallelLoopResult</strong>.</li>
<li><strong class="source-inline">public static ParallelLoopResult ForEach&lt;TSource&gt;(IEnumerable&lt;TSource&gt; source, Action&lt;TSource, ParallelLoopState&gt; body)</strong>: A data parallelism call that invokes the <strong class="source-inline">Action</strong> body on each item in the <strong class="source-inline">IEnumerable</strong> source. It returns <strong class="source-inline">ParallelLoopResult</strong>.</li>
<li><strong class="source-inline">public static ParallelLoopResult ForEach&lt;TSource&gt;(Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body)</strong>: An advanced data parallelism call that invokes the <strong class="source-inline">Action</strong> body and allows you to specify <strong class="source-inline">Partitioner</strong> to provide partitioning strategies optimized for specific data structures to improve performance. It returns <strong class="source-inline">ParallelLoopResult</strong>.</li>
<li><strong class="source-inline">public static void Invoke(params Action[] actions)</strong>: A task parallelism call that executes each of the actions passed.</li>
<li><strong class="source-inline">public static void Invoke(ParallelOptions parallelOptions, params Action[] actions)</strong>: A task parallelism call that executes each of the actions and allows <strong class="source-inline">ParallelOptions</strong> to be specified to configure method calls.</li>
</ul>
<p>The <strong class="source-inline">ParallelOptions</strong> class can be used to configure how the <strong class="source-inline">Parallel</strong> methods operate:</p>
<ul>
<li><strong class="source-inline">public CancellationToken CancellationToken { get; set; }</strong>: The familiar cancelation token that can be used to detect within loops if cancellation has been requested by a caller.</li>
<li><strong class="source-inline">public int MaxDegreeOfParallelism { get; set; }</strong>: An advanced setting that determines the maximum number of concurrent tasks that can be enabled at a time.</li>
<li><strong class="source-inline">public TaskScheduler? TaskScheduler { get; set; }</strong>: An advanced setting that allows a certain type of task queue scheduler to be set.</li>
</ul>
<p><strong class="source-inline">ParallelLoopState</strong> can be passed into the body of an <strong class="source-inline">Action</strong> for that action to then determine or monitor flow through the loop. The most commonly used properties are as follows:</p>
<ul>
<li><strong class="source-inline">public bool IsExceptional { get; }</strong>: Returns <strong class="source-inline">true</strong> if an iteration has thrown an unhandled exception.</li>
<li><strong class="source-inline">public bool IsStopped { get; }</strong>: Returns <strong class="source-inline">true</strong> if an iteration has stopped the loop by calling the <strong class="source-inline">Stop</strong> method.</li>
<li><strong class="source-inline">public void Break()</strong>: The <strong class="source-inline">Action</strong> loop can call this to indicate execution should cease beyond the current iteration.</li>
<li><strong class="source-inline">public void Stop()</strong>: Requests that the loop should cease execution at the current iteration.</li>
<li><strong class="source-inline">ParallelLoopResult</strong>, as returned by the <strong class="source-inline">For</strong> and <strong class="source-inline">ForEach</strong> methods, contains a completion status for the <strong class="source-inline">Parallel</strong> loop.</li>
<li><strong class="source-inline">public bool IsCompleted { get; }</strong>: Indicates that the loop ran to completion and did not receive a request to end before completion.</li>
<li><strong class="source-inline">public long? LowestBreakIteration { get; }</strong>: If <strong class="source-inline">Break</strong> is called <strong class="source-inline">while</strong> the loop runs. This returns the index of the lowest iteration the loop arrived at.</li>
</ul>
<p>Using the <strong class="source-inline">Parallel</strong> class does not automatically mean that a particular bulk operation will complete any faster. There is an overhead in scheduling tasks, so care should be taken when running tasks that are too short or too long. Sadly, there is no simple metric that determines an optimal figure here. It is often a case of profiling to see if operations do indeed complete faster using the <strong class="source-inline">Parallel</strong> class.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find more information on data and task parallelism at <a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism">https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism</a>.</p>
<h3 id="_idParaDest-209"><a id="_idTextAnchor235"/>Parallel.For and Parallel.ForEach</h3>
<p>These two methods offer data parallelism. The same operation is applied to a collection of data objects or numbers. To benefit from these, each operation should be CPU-bound, that is it should require CPU cycles to execute rather than being IO-bound (accessing a file, for example).</p>
<p>With these two methods, you define an <strong class="source-inline">Action</strong> to be applied, which is passed an object instance or number to work with. In the case of <strong class="source-inline">Parallel.ForEach</strong>, the <strong class="source-inline">Action</strong> is passed an object reference parameter. A numeric parameter is passed to <strong class="source-inline">Parallel.For</strong>.</p>
<p>As you saw in <em class="italic">Chapter 3</em>, <em class="italic">Delegates, Events, and Lambdas</em>, the <strong class="source-inline">Action</strong> delegate code can be as simple or complex as you need:</p>
<p class="source-code">using System;</p>
<p class="source-code">using System.Threading.Tasks;</p>
<p class="source-code">using System.Globalization;</p>
<p class="source-code">using System.Threading;</p>
<p class="source-code">namespace Chapter05.Examples</p>
<p class="source-code">{</p>
<p class="source-code">    class ParallelForExamples</p>
<p class="source-code">    {</p>
<p class="source-code">        public static async Task Main()</p>
<p class="source-code">        {</p>
<p>In this example, calling <strong class="source-inline">Parallel.For</strong>, you pass an inclusive <strong class="source-inline">int</strong> value to start from (<strong class="source-inline">99</strong>) and an exclusive end value (<strong class="source-inline">105</strong>). The third argument is a lambda statement, <strong class="source-inline">Action</strong>, that you want invoked over each iteration. This overload uses <strong class="source-inline">Action&lt;int&gt;</strong>, passing an integer via the <strong class="source-inline">i</strong> argument:</p>
<p class="source-code">            var loopResult = Parallel.For(99, 105, i =&gt;</p>
<p class="source-code">            {</p>
<p class="source-code">                Logger.Log($"Sleep iteration {i}");</p>
<p class="source-code">                Thread.Sleep(i * 10);</p>
<p class="source-code">                Logger.Log($"Awake iteration {i}");</p>
<p class="source-code">            });</p>
<p>Examine the <strong class="source-inline">ParallelLoopResult</strong> <strong class="source-inline">IsCompleted</strong> property:</p>
<p class="source-code">            Console.WriteLine($"Completed: {loopResult.IsCompleted}");</p>
<p class="source-code">            Console.ReadLine();</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p>Running the code, you'll see that it stops at <strong class="source-inline">104</strong>. Each iteration is executed by a set of different threads and the order appears somewhat random with certain iterations awaking before others. You have used a relatively short delay (using <strong class="source-inline">Thread.Sleep</strong>) so the parallel task scheduler may take a few additional milliseconds to activate each iteration. This is the reason why the orders in which iterations are executed should be independent of each other:</p>
<p class="source-code">18:39:37 [10] Sleep iteration 104</p>
<p class="source-code">18:39:37 [03] Sleep iteration 100</p>
<p class="source-code">18:39:37 [06] Sleep iteration 102</p>
<p class="source-code">18:39:37 [04] Sleep iteration 101</p>
<p class="source-code">18:39:37 [01] Sleep iteration 99</p>
<p class="source-code">18:39:37 [07] Sleep iteration 103</p>
<p class="source-code">18:39:38 [03] Awake iteration 100</p>
<p class="source-code">18:39:38 [01] Awake iteration 99</p>
<p class="source-code">18:39:38 [06] Awake iteration 102</p>
<p class="source-code">18:39:38 [04] Awake iteration 101</p>
<p class="source-code">18:39:38 [07] Awake iteration 103</p>
<p class="source-code">18:39:38 [10] Awake iteration 104</p>
<p class="source-code">Completed: True</p>
<p>Using the <strong class="source-inline">ParallelLoopState</strong> override, you can control the iterations from with the <strong class="source-inline">Action</strong> code. In the following example, the code checks to see if it is at iteration number <strong class="source-inline">15</strong>:</p>
<p class="source-code">            var loopResult1 = Parallel.For(10, 20,               (i, loopState) =&gt;</p>
<p class="source-code">              {</p>
<p class="source-code">                Logger.Log($"Inside iteration {i}");</p>
<p class="source-code">                if (i == 15)</p>
<p class="source-code">                {</p>
<p class="source-code">                    Logger.Log($"At {i}…break when you're ready");</p>
<p>Calling <strong class="source-inline">Break</strong> on <strong class="source-inline">loopState</strong> communicates that the <strong class="source-inline">Parallel</strong> loop should cease further iterations as soon as it can:</p>
<p class="source-code">                    loopState.Break();</p>
<p class="source-code">                }</p>
<p class="source-code">              });</p>
<p class="source-code">            Console.WriteLine($"Completed: {loopResult1.IsCompleted}, LowestBreakIteration={loopResult1.L<a id="_idTextAnchor236"/>owestBreakIteration}");</p>
<p class="source-code">            Console.ReadLine();</p>
<p>From the results, you can see you got to item <strong class="source-inline">17</strong> before things actually stopped, despite asking to break at iteration <strong class="source-inline">15</strong>, as can be seen from the following snippet:</p>
<p class="source-code">19:04:48 [03] Inside iteration 11</p>
<p class="source-code">19:04:48 [03] Inside iteration 13</p>
<p class="source-code">19:04:48 [03] Inside iteration 15</p>
<p class="source-code">19:04:48 [03] At 15...break when you're ready</p>
<p class="source-code">19:04:48 [01] Inside iteration 10</p>
<p class="source-code">19:04:48 [05] Inside iteration 14</p>
<p class="source-code">19:04:48 [07] Inside iteration 17</p>
<p class="source-code">19:04:48 [06] Inside iteration 16</p>
<p class="source-code">19:04:48 [04] Inside iteration 12</p>
<p class="source-code">Completed: False, LowestBreakIteration=15</p>
<p>The code used <strong class="source-inline">ParallelLoopState.Break</strong>; this indicates the loop <strong class="bold">should</strong> cease at the next iteration if possible. In this case, you actually arrived at iteration <strong class="source-inline">17</strong> despite requesting a stop at iteration <strong class="source-inline">15</strong>. This generally occurs when the runtime has already started a subsequent iteration and then detects a <strong class="source-inline">Break</strong> request just after. These are requests to stop; the runtime may run extra iterations before it can stop.</p>
<p>Alternatively, the <strong class="source-inline">ParallelLoopState.Stop</strong> method can be used for a more abrupt stop. An alternative <strong class="source-inline">Parallel.For</strong> overload allows state to be passed into each loop and return a single aggregate value.</p>
<p>To better learn about these overloads, you will calculate the value of <strong class="source-inline">pi</strong> in the next example. This is an ideal task for <strong class="source-inline">Parallel.For</strong> as it means repeatedly calculating a value, which is aggregated before being passed to the next iteration. The higher the number of iterations, the more accurate the final number.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find more information on the formula at <a href="https://www.mathscareers.org.uk/article/calculating-pi/">https://www.mathscareers.org.uk/article/calculating-pi/</a>.</p>
<p>You use a loop to prompt the user to enter the number of series (the number of decimal places to be shown) as a multiple of a million (to save typing many zeroes):</p>
<p class="source-code">            double series;</p>
<p class="source-code">            do</p>
<p class="source-code">            {</p>
<p class="source-code">                Console.Write("Pi Series (in millions):");</p>
<p class="source-code">                var input = Console.ReadLine();</p>
<p>Try to parse the input:</p>
<p class="source-code">                if (!double.TryParse(input, NumberStyles.Any, CultureInfo.CurrentCulture, out series))</p>
<p class="source-code">                {</p>
<p class="source-code">                    break;</p>
<p class="source-code">                }</p>
<p>Multiply the entered value by one million and pass it to the awaitable <strong class="source-inline">CalcPi</strong> function (which will be defined shortly):</p>
<p class="source-code">                var actualSeries = series * 1000000;</p>
<p class="source-code">                Console.WriteLine($"Calculating PI {actualSeries:N0}");</p>
<p class="source-code">                var pi = await CalcPi((int)(actualSeries));</p>
<p>You eventually receive the value of <strong class="source-inline">pi</strong>, so use the string interpolation feature to write <strong class="source-inline">pi</strong> to <strong class="source-inline">18</strong> decimal places using the <strong class="source-inline">:N18</strong> numeric format style:</p>
<p class="source-code">                Console.WriteLine($"PI={pi:N18}");</p>
<p class="source-code">            }</p>
<p>Repeat the loop until <strong class="source-inline">0</strong> is entered:</p>
<p class="source-code">            while (series != 0D);</p>
<p class="source-code">            Console.ReadLine();</p>
<p>Now for the <strong class="source-inline">CalcPi</strong> function. You know that the <strong class="source-inline">Parallel</strong> methods all block the calling thread, so you need to use <strong class="source-inline">Task.Run</strong> which will eventually return the final calculated value.</p>
<p>The concept of thread synchronization will be covered briefly. There is a danger when using multiple threads and shared variables that one thread may read a value from memory and attempt to write a new value at the same time a different thread is trying to do the same operation, with its own value and what it thinks is the correct current value, when it may have read an already out-of-date shared value.</p>
<p>To prevent such issues, a mutual-exclusion lock can be used so that a given thread can execute its statements while it holds a lock and then releases that lock when finished. All other threads are blocked from acquiring the lock and are forced to wait until the lock is released.</p>
<p>This can be achieved using the <strong class="source-inline">lock</strong> statement. All of the complexities are handled by the runtime when the <strong class="source-inline">lock</strong> statement is used to achieve thread synchronization. The <strong class="source-inline">lock</strong> statement has the following form:</p>
<p class="source-code">lock (obj){ //your thread safe code here }.</p>
<p>Conceptually, you can think of the <strong class="source-inline">lock</strong> statement as a narrow gate that has enough room to allow just one person to pass through at a time. No matter how long a person takes to pass through the gate and what they do while they are there, everyone else must wait to get through the gate until the person with the key has left (releasing the lock).</p>
<p>Returning to the <strong class="source-inline">CalcPi</strong> function:</p>
<p class="source-code">        private static Task&lt;double&gt; CalcPi(int steps)</p>
<p class="source-code">        {</p>
<p class="source-code">            return Task.Run(() =&gt;</p>
<p class="source-code">            {</p>
<p class="source-code">                const int StartIndex = 0;</p>
<p class="source-code">                var sum = 0.0D;</p>
<p class="source-code">                var step = 1.0D / (double)steps;</p>
<p>The <strong class="source-inline">gate</strong> variable is of type <strong class="source-inline">object</strong> and used with the <strong class="source-inline">lock</strong> statement inside the lambda to protect the <strong class="source-inline">sum</strong> variable from unsafe access:</p>
<p class="source-code">                var gate = new object();</p>
<p>This is where things get a little more complex, as you use the <strong class="source-inline">Parallel.For</strong> overload, which additionally allows you to pass in extra parameters and delegates:</p>
<ul>
<li><strong class="source-inline">fromInclusive</strong>: The start index (<strong class="source-inline">0</strong> in this case).</li>
<li><strong class="source-inline">toExclusive</strong>: The end index (steps).</li>
<li><strong class="source-inline">localInit</strong>: A <strong class="source-inline">Func</strong> delegate that returns the <strong class="bold">initial state</strong> of data local to each iteration.</li>
<li><strong class="source-inline">body</strong>: The actual <strong class="source-inline">Func</strong> delegate that calculates a value of Pi.</li>
<li><strong class="source-inline">localFinal</strong>: A <strong class="source-inline">Func</strong> delegate that performs the final action on the local state of each iteration.</li>
</ul>
<p class="source-code">                Parallel.For(</p>
<p class="source-code">                    StartIndex, </p>
<p class="source-code">                    steps,</p>
<p class="source-code">                    () =&gt; 0.0D,                 // localInit </p>
<p class="source-code">                    (i, state, localFinal) =&gt;   // body</p>
<p class="source-code">                    {</p>
<p class="source-code">                        var x = (i + 0.5D) * step;</p>
<p class="source-code">                        return localFinal + 4.0D / (1.0D + x * x);</p>
<p class="source-code">                    },</p>
<p class="source-code">                    localFinal =&gt;               //localFinally</p>
<p class="source-code">                    { </p>
<p>Here, you now use the <strong class="source-inline">lock</strong> statement to ensure that only one thread at a time can increment the value of <strong class="source-inline">sum</strong> with its own correct value:</p>
<p class="source-code">                        lock (gate)</p>
<p class="source-code">                            sum += localFinal; </p>
<p class="source-code">                    });</p>
<p class="source-code">                return step * sum;</p>
<p class="source-code">            });</p>
<p class="source-code">        }</p>
<p>By using the <strong class="source-inline">lock(obj)</strong> statement, you have provided a minimum level of thread safety, and running the program produces the following output:</p>
<p class="source-code">Pi Series (in millions):1</p>
<p class="source-code">Calculating PI 1,000,000</p>
<p class="source-code">PI=3.141592653589890000</p>
<p class="source-code">Pi Series (in millions):20</p>
<p class="source-code">Calculating PI 20,000,000</p>
<p class="source-code">PI=3.141592653589810000</p>
<p class="source-code">Pi Series (in millions):30</p>
<p class="source-code">Calculating PI 30,000,000</p>
<p class="source-code">PI=3.141592653589750000</p>
<p><strong class="source-inline">Parallel.ForEach</strong> follows similar semantics; rather than a range of numbers being passed to the <strong class="source-inline">Action</strong> delegate, you pass a collection of objects to work with.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/1yZu2">https://packt.link/1yZu2</a>.</p>
<p>The following example shows <strong class="source-inline">Parallel.ForEach</strong> using <strong class="source-inline">ParallelOptions</strong> along with a cancelation token. In this example, you have a console app that creates 10 customers. Each customer has a list containing the value of all orders placed. You want to simulate a slow-running service that fetches a customer's order on demand. Whenever any code accesses the <strong class="source-inline">Customer.Orders</strong> property, the list is populated only once though. Here, you will use another <strong class="source-inline">lock</strong> statement per customer instance to ensure the list is safely populated.</p>
<p>An <strong class="source-inline">Aggregator</strong> class will iterate through the list of customers and calculate the total and average order costs using a <strong class="source-inline">Parallel.ForEach</strong> call. Allow the user to enter a maximum time period that they are prepared to wait for all of the aggregations to complete and then show the top five customers.</p>
<p>Start by creating a <strong class="source-inline">Customer</strong> class whose constructor is passed a <strong class="source-inline">name</strong> argument:</p>
<p class="source-code">using System;</p>
<p class="source-code">using System.Collections.Generic;</p>
<p class="source-code">using System.Globalization;</p>
<p class="source-code">using System.Linq;</p>
<p class="source-code">using System.Threading;</p>
<p class="source-code">using System.Threading.Tasks;</p>
<p class="source-code">namespace Chapter05.Examples</p>
<p class="source-code">{</p>
<p class="source-code">    public class Customer</p>
<p class="source-code">    {</p>
<p class="source-code">        public Customer(string name)</p>
<p class="source-code">        {</p>
<p class="source-code">            Name = name;</p>
<p class="source-code">            Logger.Log($"Created {Name}");</p>
<p class="source-code">        }</p>
<p class="source-code">        public string Name { get; }</p>
<p>You want to populate the <strong class="source-inline">Orders</strong> list on demand and once only per customer, so use another <strong class="source-inline">lock</strong> example that ensures the list of orders is safely populated once. You simply use the <strong class="source-inline">Orders</strong> <strong class="source-inline">get</strong> accessor to check for a null reference on the <strong class="source-inline">_orders</strong> variable, before creating a random number of order values using the <strong class="source-inline">Enumerable.Range</strong> LINQ method to generate a range of numbers.</p>
<p>Note, you also simulate a slow request by adding <strong class="source-inline">Thread.Sleep</strong> to block the thread that is accessing this customer's orders for the first time (as you're using the <strong class="source-inline">Parallel</strong> class, this will be a background thread rather than the main thread):</p>
<p class="source-code-heading">ParallelForEachExample.cs</p>
<p class="source-code">1            private readonly object _orderGate = new object();</p>
<p class="source-code">2            private IList&lt;double&gt; _orders;</p>
<p class="source-code">3            public IList&lt;double&gt; Orders</p>
<p class="source-code">4            {</p>
<p class="source-code">5                get</p>
<p class="source-code">6                {</p>
<p class="source-code">7                    lock (_orderGate)</p>
<p class="source-code">8                    {</p>
<p class="source-code">9                        if (_orders != null)</p>
<p class="source-code">10                            return _orders;</p>
<p class="source-code">11</p>
<p class="source-code">12                        var random = new Random();</p>
<p class="source-code">13                        var orderCount = random.Next(1000, 10000);</p>
<p class="source-code">14</p>
<p class="source-code-link">You can find the complete code here: <a href="https://packt.link/Nmx3X">https://packt.link/Nmx3X</a>.</p>
<p>The <strong class="source-inline">Total</strong> and <strong class="source-inline">Average</strong> properties that will be calculated by your <strong class="source-inline">Aggregator</strong> class are as follows:</p>
<p class="source-code">        public double? Total { get; set; }</p>
<p class="source-code">        public double? Average { get; set; }</p>
<p class="source-code">    }</p>
<p>Looking at the <strong class="source-inline">Aggregator</strong> class, note that its <strong class="source-inline">Aggregate</strong> method is passed a list of customers to work with and <strong class="source-inline">CancellationToken</strong>, which will automatically raise a cancellation request based on the console user's preferred timespan. The method returns a bool-based <strong class="source-inline">Task</strong>. The result will indicate whether the operation was canceled partway through processing the customers:</p>
<p class="source-code">    public static class Aggregator</p>
<p class="source-code">    {</p>
<p class="source-code">        public static Task&lt;bool&gt; Aggregate(IEnumerable&lt;Customer&gt; customers, CancellationToken token)</p>
<p class="source-code">        {</p>
<p class="source-code">            var wasCancelled = false;</p>
<p>The main <strong class="source-inline">Parallel.ForEach</strong> method is configured by creating a <strong class="source-inline">ParallelOptions</strong> class, passing in the cancellation token. When invoked by the <strong class="source-inline">Parallel</strong> class, the <strong class="source-inline">Action</strong> delegate is passed a <strong class="source-inline">Customer</strong> instance (<strong class="source-inline">customer =&gt;</strong>) that simply sums the order values and calculates the average which is assigned to the customer's properties.</p>
<p>Notice how the <strong class="source-inline">Parallel.ForEach</strong> call is wrapped in a <strong class="source-inline">try-catch</strong> block that catches any exceptions of type <strong class="source-inline">OperationCanceledException</strong>. If the maximum time period is exceeded, then the runtime will throw an exception to stop processing. You must catch this; otherwise, the application will crash with an unhandled exception error:</p>
<p class="source-code-heading">ParallelForEachExample.cs</p>
<p class="source-code">1                return Task.Run(() =&gt;</p>
<p class="source-code">2                {</p>
<p class="source-code">3                    var options = new ParallelOptions { CancellationToken = token };</p>
<p class="source-code">4    </p>
<p class="source-code">5                    try</p>
<p class="source-code">6                    {</p>
<p class="source-code">7                        Parallel.ForEach(customers, options,</p>
<p class="source-code">8                            customer =&gt;</p>
<p class="source-code">9                            {</p>
<p class="source-code">10                                customer.Total = customer.Orders.Sum();</p>
<p class="source-code">11                                customer.Average = customer.Total / 12                                                   customer.Orders.Count;</p>
<p class="source-code">13                                Logger.Log($"Processed {customer.Name}");</p>
<p class="source-code">14                            });</p>
<p class="source-code">15                    }</p>
<p class="source-code-link">You can find the complete code here: <a href="https://packt.link/FfVNA">https://packt.link/FfVNA</a>.</p>
<p>The main console app prompts for a maximum waiting time, <strong class="source-inline">maxWait</strong>:</p>
<p class="source-code">    class ParallelForEachExampleProgram</p>
<p class="source-code">    {</p>
<p class="source-code">        public static async Task Main()</p>
<p class="source-code">        {</p>
<p class="source-code">            Console.Write("Max waiting time (seconds):");</p>
<p class="source-code">            var input = Console.ReadLine();</p>
<p class="source-code">            var maxWait = TimeSpan.FromSeconds(int.TryParse(input, NumberStyles.Any, CultureInfo.CurrentCulture, out var inputSeconds)</p>
<p class="source-code">                ? inputSeconds</p>
<p class="source-code">                : 5);</p>
<p>Create <strong class="source-inline">100</strong> customers that can be passed to the aggregator:</p>
<p class="source-code">            var customers = Enumerable.Range(1, 10)</p>
<p class="source-code">                .Select(n =&gt; new Customer($"Customer#{n}"))</p>
<p class="source-code">                .ToList();</p>
<p>Create <strong class="source-inline">CancellationTokenSource</strong> instance, passing in the maximum wait time. As you saw earlier, any code that uses this token will be interrupted with a cancellation exception should the time limit be exceeded:</p>
<p class="source-code">            var tokenSource = new CancellationTokenSource(maxWait);</p>
<p class="source-code">            var aggregated = await Task.Run(() =&gt; Aggregator.Aggregate(customers,                                   tokenSource.Token));            </p>
<p>Once the task completes, you simply take the top five customers ordered by total. The <strong class="source-inline">PadRight</strong> method is used to align the customer's name in the output:</p>
<p class="source-code">            var topCustomers = customers</p>
<p class="source-code">                .OrderByDescending(c =&gt; c.Total)</p>
<p class="source-code">                .Take(5);</p>
<p class="source-code">            Console.WriteLine($"Cancelled: {aggregated }");</p>
<p class="source-code">            Console.WriteLine("Customer      \tTotal         \tAverage  \tOrders");</p>
<p class="source-code">           </p>
<p class="source-code">            foreach (var c in topCustomers)</p>
<p class="source-code">            {</p>
<p class="source-code">                Console.WriteLine($"{c.Name.PadRight(10)}\t{c.Total:N0}\t{c.Average:N0}\t\t{c.Orders.Count:N0}");</p>
<p class="source-code">            }</p>
<p class="source-code">            Console.ReadLine();</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p>Running the console app with a short time of <strong class="source-inline">1</strong> second produces this output:</p>
<p class="source-code">Max waiting time (seconds):1</p>
<p class="source-code">21:35:56 [01] Created Customer#1</p>
<p class="source-code">21:35:56 [01] Created Customer#2</p>
<p class="source-code">21:35:56 [01] Created Customer#3</p>
<p class="source-code">21:35:56 [01] Created Customer#4</p>
<p class="source-code">21:35:56 [01] Created Customer#5</p>
<p class="source-code">21:35:56 [01] Created Customer#6</p>
<p class="source-code">21:35:56 [01] Created Customer#7</p>
<p class="source-code">21:35:56 [01] Created Customer#8</p>
<p class="source-code">21:35:56 [01] Created Customer#9</p>
<p class="source-code">21:35:56 [01] Created Customer#10</p>
<p class="source-code">21:35:59 [07] Processed Customer#5</p>
<p class="source-code">21:35:59 [04] Processed Customer#3</p>
<p class="source-code">21:35:59 [10] Processed Customer#7</p>
<p class="source-code">21:35:59 [06] Processed Customer#2</p>
<p class="source-code">21:35:59 [05] Processed Customer#1</p>
<p class="source-code">21:35:59 [11] Processed Customer#8</p>
<p class="source-code">21:35:59 [08] Processed Customer#6</p>
<p class="source-code">21:35:59 [09] Processed Customer#4</p>
<p class="source-code">21:35:59 [05] Caught The operation was canceled.</p>
<p class="source-code">Cancelled: True</p>
<p class="source-code">Customer        Total           Average         Orders</p>
<p class="source-code">Customer#1      23,097,348      2,395           9,645</p>
<p class="source-code">Customer#4      19,029,182      2,179           8,733</p>
<p class="source-code">Customer#8      15,322,674      1,958           7,827</p>
<p class="source-code">Customer#6      9,763,247       1,568           6,226</p>
<p class="source-code">Customer#2      6,189,978       1,250           4,952</p>
<p>The operation of creating <strong class="source-inline">10</strong> customers ran using Thread <strong class="source-inline">01</strong> as this was intentionally synchronous.</p>
<p class="callout-heading">Note</p>
<p class="callout">Visual Studio may show the following warning the first time you run the program: <strong class="source-inline">Non-nullable field '_orders' must contain a non-null value when exiting constructor. Consider declaring the field as nullable.</strong> This is a suggestion to check the code for the possibility of a null reference.</p>
<p><strong class="source-inline">Aggregator</strong> then starts processing each of the customers. Notice how different threads are used and processing does not start with the first customer either. This is the task scheduler deciding which task is next in the queue. You only managed to process eight of the customers before the token raised the cancelation exception.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/1LDxI">https://packt.link/1LDxI</a>.</p>
<p>You have looked at some of the features available in the <strong class="source-inline">Parallel</strong> class. You can see that it provides a simple yet effective way to run code across multiple tasks or pieces of data.</p>
<p>The phrase <strong class="bold">embarrassingly parallel</strong> was covered under <em class="italic">Parallel Programming</em> section at the beginning of the chapter and refers to cases in which a series of tasks can be broken down into small independent chunks. Using the <strong class="source-inline">Parallel</strong> class is an example of this and can be a great utility.</p>
<p>The next section will bring these concurrency concepts into an activity that uses multiple tasks to generate a sequence of images. As each of the images can take a few seconds to create, you will need to offer the user a way to cancel any remaining tasks if the user so chooses.</p>
<h2 id="_idParaDest-210">A<a id="_idTextAnchor237"/>ctivity 5.01: Creating Images from a Fibonacci Sequence</h2>
<p>In <em class="italic">Exercise 5.01</em>, you looked at a recursive function to create a value called a Fibonacci number. These numbers can be joined into what is known as a Fibonacci sequence and used to create interesting spiral-shaped images.</p>
<p>For this activity, you need to create a console application that allows various inputs to be passed to a sequence calculator. Once the user has entered their parameters, the app will start the time-consuming task of creating 1,000 images.</p>
<p>Each image in the sequence may take a few seconds to compute and create so you will need to provide a way to cancel the operation midway using <strong class="source-inline">TaskCancellationSource</strong>. If the user cancels the task, they should still be able to access the images that were created prior to the cancellation request. Essentially, you are allowing the user to try different parameters to see how this affects output images.</p>
<div>
<div class="IMG---Figure" id="_idContainer126">
<img alt="Figure 5.2: Fibonacci sequence image files " height="651" src="image/B16835_05_02.jpg" width="1612"/>
</div>
</div>
<p class="figure-caption">Figure 5.2: Fibonacci sequence image files</p>
<p>This is an ideal example for the <strong class="source-inline">Parallel</strong> class or <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> tasks if you prefer. The following inputs will be needed from the user:</p>
<ul>
<li>Input the value for <strong class="source-inline">phi</strong> (values between <strong class="source-inline">1.0</strong> and <strong class="source-inline">6.0</strong> provide ideal images).</li>
<li>Input the number of images to create (the suggestion is <strong class="source-inline">1,000</strong> per cycle).</li>
<li>Input the optional number of points per image (a default of <strong class="source-inline">3,000</strong> is recommended).</li>
<li>Input the optional image size (defaults to <strong class="source-inline">800</strong> pixels).</li>
<li>Input the optional point size (defaults to <strong class="source-inline">5</strong>).</li>
<li>Next input the optional file format (defaults to <strong class="source-inline">.png</strong> format).</li>
<li>The console app should use a loop that prompts for the preceding parameters and allows the user to enter new criteria while images are created for previous criteria.</li>
<li>If the user presses <strong class="source-inline">Enter</strong> whilst a previous set of images is still being created, then that task should be canceled.</li>
<li>Pressing <strong class="source-inline">x</strong> should close the application.</li>
</ul>
<p>As this activity is aimed at testing your asynchronous skills, rather than math or image processing, you have the following classes to help with calculations and image creation:</p>
<ul>
<li>The <strong class="source-inline">Fibonacci</strong> class defined here calculates <strong class="source-inline">X</strong> and <strong class="source-inline">Y</strong> coordinates for successive sequence items. For each image loop, return a list of <strong class="source-inline">Fibonacci</strong> classes.</li>
<li>Create the first element by calling <strong class="source-inline">CreateSeed</strong>. The remainder of the list should use <strong class="source-inline">CreateNext</strong>, passing in the previous item:<p class="source-code-heading">FibonacciSequence.cs</p><p class="source-code">1    public class Fibonacci</p><p class="source-code">2    {</p><p class="source-code">3        public static Fibonacci CreateSeed()</p><p class="source-code">4        {</p><p class="source-code">5            return new Fibonacci(1, 0D, 1D);</p><p class="source-code">6        }</p><p class="source-code">7    </p><p class="source-code">8        public static Fibonacci CreateNext(Fibonacci previous, double angle)</p><p class="source-code">9        {</p><p class="source-code">10            return new Fibonacci(previous, angle);</p><p class="source-code">11        }</p><p class="source-code">12    </p><p class="source-code">13        private Fibonacci(int index, double theta, double x)</p><p class="source-code">14        {</p><p class="source-code">15            Index = index;</p></li>
</ul>
<p class="source-code-link">You can find the complete code here: <a href="http://packt.link/I7C6A">http://packt.link/I7C6A</a>.</p>
<ul>
<li>Create a list of Fibonacci items using the following <strong class="source-inline">FibonacciSequence</strong>.<strong class="source-inline">Calculate</strong> method. This will be passed the number of points to be drawn and the value of <strong class="source-inline">phi</strong> (both as specified by the user):<p class="source-code-heading">FibonacciSequence.cs</p><p class="source-code">1    public static class FibonacciSequence</p><p class="source-code">2    {</p><p class="source-code">3        public static IList&lt;Fibonacci&gt; Calculate(int indices, double phi)</p><p class="source-code">4        {</p><p class="source-code">5            var angle = phi.GoldenAngle();</p><p class="source-code">6    </p><p class="source-code">7            var items = new List&lt;Fibonacci&gt;(indices)</p><p class="source-code">8            {</p><p class="source-code">9                Fibonacci.CreateSeed()</p><p class="source-code">10            };</p><p class="source-code">11            </p><p class="source-code">12            for (var i = 1; i &lt; indices; i++)</p><p class="source-code">13            {</p><p class="source-code">14                var previous = items.ElementAt(i - 1);</p><p class="source-code">15                var next = Fibonacci.CreateNext(previous, angle);</p></li>
</ul>
<p class="source-code-link">You can find the complete code here: <a href="https://packt.link/gYK4N">https://packt.link/gYK4N</a>.</p>
<ul>
<li>Export the generated data to <strong class="source-inline">.png</strong> format image files using the <strong class="source-inline">dotnet add package</strong> command to add a reference to the <strong class="source-inline">System.Drawing.Common</strong> namespace. Within your project's source folder, run this command:<p class="source-code">source\Chapter05&gt;dotnet add package System.Drawing.Common</p></li>
<li>This image creation class <strong class="source-inline">ImageGenerator</strong> can be used to create each of the final image files:<p class="source-code-heading">ImageGenerator.cs</p><p class="source-code">1    using System.Collections.Generic;</p><p class="source-code">2    using System.Drawing;</p><p class="source-code">3    using System.Drawing.Drawing2D;</p><p class="source-code">4    using System.Drawing.Imaging;</p><p class="source-code">5    using System.IO;</p><p class="source-code">6    </p><p class="source-code">7    namespace Chapter05.Activities.Activity01</p><p class="source-code">8    {</p><p class="source-code">9        public static class ImageGenerator</p><p class="source-code">10        {</p><p class="source-code">11            public static void ExportSequence(IList&lt;Fibonacci&gt; sequence, </p><p class="source-code">12                string path, ImageFormat format, 13                int width, int height, double pointSize)</p><p class="source-code">14            {</p><p class="source-code">15                double minX = 0; </p></li>
</ul>
<p class="source-code-link">You can find the complete code here: <a href="http://packt.link/a8Bu7">http://packt.link/a8Bu7</a>.</p>
<p>To complete this activity, perform the following steps:</p>
<ol>
<li value="1">Create a new console app project.</li>
<li>The generated images should be saved in a folder within the system's <strong class="source-inline">Temp</strong> folder, so use <strong class="source-inline">Path.GetTempPath()</strong> to get the <strong class="source-inline">Temp</strong> path and create a subfolder called <strong class="source-inline">Fibonacci</strong> using <strong class="source-inline">Directory.CreateDirectory</strong>.</li>
<li>Declare a <strong class="source-inline">do</strong>-loop that repeats the following <em class="italic">Step 4</em> to <em class="italic">Step 7</em>.</li>
<li>Prompt the user to enter a value for <strong class="source-inline">phi</strong> (this typically ranges from <strong class="source-inline">1.0</strong> to <strong class="source-inline">6.00</strong>). You will need to read the user's input as a string and use <strong class="source-inline">double.TryParse</strong> to attempt to convert their input into a valid double variable.</li>
<li>Next, prompt the user to enter a value for the number of image files to create (<strong class="source-inline">1,000</strong> is an acceptable example value). Store the parsed input in an <strong class="source-inline">int</strong> variable called <strong class="source-inline">imageCount</strong>.</li>
<li>If either of the entered values is empty, this will indicate that the user pressed the <strong class="source-inline">Enter</strong> key alone, so break out of the <strong class="source-inline">do</strong>-loop. Ideally, <strong class="source-inline">CancellationTokenSource</strong> can also be defined and used to cancel any pending calculations.</li>
<li>The value of <strong class="source-inline">phi</strong> and <strong class="source-inline">imageCount</strong> should be passed to a new method called <strong class="source-inline">GenerateImageSequences</strong>, which returns a <strong class="source-inline">Task</strong>.</li>
<li>The <strong class="source-inline">GenerateImageSequences</strong> method needs to use a loop that iterates for each of the image counts requested. Each iteration should increment <strong class="source-inline">phi</strong>, and a constant value (a suggestion is <strong class="source-inline">0.015</strong>) before awaiting a <strong class="source-inline">Task.Run</strong> method that calls <strong class="source-inline">FibonacciSequence.Calculate</strong>, passing in <strong class="source-inline">phi</strong> and a constant for the number of points (<strong class="source-inline">3,000</strong> provides an acceptable example value). This will return a list of Fibonacci items.</li>
<li><strong class="source-inline">GenerateImageSequences</strong> should then pass the generated Fibonacci list to the image creator <strong class="source-inline">ImageGenerator.ExportSequence</strong>, awaiting using a <strong class="source-inline">Task.Run</strong> call. An image size of <strong class="source-inline">800</strong> and a point size of <strong class="source-inline">5</strong> are recommended constants for the call to <strong class="source-inline">ExportSequence</strong>.</li>
<li>Running the console app should produce the following console output:<p class="source-code">Using temp folder: C:Temp\Fibonacci\</p><p class="source-code">Phi (eg 1.0 to 6.0) (x=quit, enter=cancel):1</p><p class="source-code">Image Count (eg 1000):1000</p><p class="source-code">Creating 1000 images...</p><p class="source-code">20:36:19 [04] Saved Fibonacci_3000_1.015.png</p><p class="source-code">20:36:19 [06] Saved Fibonacci_3000_1.030.png</p><p class="source-code">20:36:20 [06] Saved Fibonacci_3000_1.090.png</p></li>
</ol>
<p>You will find that various image files have been generated in the Fibonacci folder in the system's <strong class="source-inline">Temp</strong> folder:</p>
<div>
<div class="IMG---Figure" id="_idContainer127">
</div>
</div>
<div>
<div class="IMG---Figure" id="_idContainer128">
<img alt="Figure 5.3: Windows 10 Explorer image folder contents (a subset of images produced) " height="758" src="image/B16835_05_03.jpg" width="1442"/>
</div>
</div>
<p class="figure-caption">Figure 5.3: Windows 10 Explorer image folder contents (a subset of images produced)</p>
<p>By completing this activity, you have seen how multiple long-running operations can be started and then coordinated to produce a single result, with each step running in isolation, allowing other operations to continue as necessary.</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found at <a href="https://packt.link/qclbF">https://packt.link/qclbF</a>.</p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor238"/>Summary</h1>
<p>In this chapter, you considered some of the power and flexibility that concurrency provides. You started by passing target actions to tasks that you created and then looked at the static <strong class="source-inline">Task</strong> factory helper methods. By using continuation tasks, you saw that single tasks and collections of tasks can be coordinated to perform aggregate actions.</p>
<p>Next, you studied the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> keywords that can help you write simpler and more concise code that is, hopefully, easier to maintain.</p>
<p>This chapter looked at how C# provides, with relative ease, concurrency patterns that make it possible to leverage the power of multicore processors. This is great for offloading time-consuming calculations, but it does come at a price. You saw how the <strong class="source-inline">lock</strong> statement can be used to safely prevent multiple threads from reading or writing to a value simultaneously.</p>
<p>In the next chapter, you will look at how Entity Framework and SQL Server can be used to interact with relational data in C# applications. This chapter is about working with databases. If you are unfamiliar with database structure or would like a refresher on the basics of PostgreSQL, please refer to the bonus chapter available in the GitHub repository for this book.</p>
</div>
<div>
<div class="Content" id="_idContainer130">
</div>
</div>
</div>
</body></html>