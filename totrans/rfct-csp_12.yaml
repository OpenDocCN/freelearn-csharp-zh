- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code Analysis in Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far, we’ve covered how to refactor our code in a safe, effective, reliable,
    and productive manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll determine areas of code that might need refactoring
    using code metrics and code analysis tools. Along the way, we’ll cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculating code metrics in Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing code analysis in Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring advanced code analysis tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The starting code for this chapter is available from GitHub at [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    in the `Chapter12/Ch12BeginningCode` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating code metrics in Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every codebase I’ve ever worked with has had a few maintainability hot spots.
    These are areas that are frequently changed, have a higher degree of complexity
    than other areas of code, and represent serious quality risks to the software
    project.
  prefs: []
  type: TYPE_NORMAL
- en: These areas are usually some of the most critical to refactor and they tend
    to be easily discoverable using **code metrics**.
  prefs: []
  type: TYPE_NORMAL
- en: Code metrics calculate a handful of useful statistics about every file, class,
    method, and property in your C# code. This lets you spot hot spots in your code
    that have significantly higher complexity or lower maintainability. Code metrics
    can even help you find classes that are too large and likely violate the Single
    Responsibility Principle (SRP) as we discussed in [*Chapter 8*](B21324_08.xhtml#_idTextAnchor173).
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate code metrics, open your solution in Visual Studio and then click
    the **Analyze** menu, followed by **Calculate Code Metrics**, and then **For Solution**,
    as shown in *Figure 12**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Calculating code metrics](img/B21324_12_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Calculating code metrics
  prefs: []
  type: TYPE_NORMAL
- en: 'This will open the **Code Metrics Results** pane, as shown in *Figure 12**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Code Metrics Results](img/B21324_12_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Code Metrics Results
  prefs: []
  type: TYPE_NORMAL
- en: 'This pane displays a hierarchical view of your solution, along with the following
    six metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines of Source Code**: The number of lines of code for the class or method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines of Executable Code**: The lines of source code that ignore blank lines
    and comments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if` statement, loop, switch case, and similar type of branching instruction
    increases this by 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability Index**: A calculated value based on cyclomatic complexity,
    lines of code, and the number of operations performed in a method. This value
    ranges from 0 to 100, indicating how maintainable your code is. Values from 0
    to 9 are bad, 10 to 20 are warning areas, and 21 and above are areas to watch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Object`, which all classes ultimately inherit from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class Coupling**: The number of other classes your code depends on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these metrics is useful individually, but together, they tell a broader
    picture.
  prefs: []
  type: TYPE_NORMAL
- en: The maintainability index gives you a quick metric for an area of code. Unlike
    other columns, which sum up values for all code in a class, namespace, or project,
    the maintainability index acts as an average, which can help you quickly drill
    into problem areas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cyclomatic complexity can identify areas that are hard to test or hard to understand
    since it identifies the number of distinct paths through a method. *Figure 12**.3*
    illustrates a cyclomatic complexity of the `CalculatePrice` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Calculating cyclomatic complexity](img/B21324_12_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Calculating cyclomatic complexity
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `CalculatePrice` method has a cyclomatic complexity of 4\. All methods
    start with a cyclomatic complexity of 1, representing a single path through the
    method. Each branching statement, such as the `if` statements here, increments
    the cyclomatic complexity by 1, resulting in a total of 4.
  prefs: []
  type: TYPE_NORMAL
- en: I find cyclomatic complexity to be generally useful and try to keep this as
    low as possible. Keep in mind that cyclomatic complexity is biased against methods
    that use `switch` statements since each `case` statement adds to the complexity.
    Simple `switch` statements with only a line or two of code are generally not hard
    to maintain, so treat cyclomatic complexity as only one indicator of code quality.
    Microsoft recommends a maximum cyclomatic complexity of 10 for each method, but
    in my experience, I tend to be happiest with a cyclomatic complexity of 7 or less.
  prefs: []
  type: TYPE_NORMAL
- en: Depth of inheritance and class coupling can help you identify places where you
    may be over-using inheritance or have too high of coupling to other classes, as
    we covered in [*Chapter 8*](B21324_08.xhtml#_idTextAnchor173). Microsoft encourages
    a maximum depth of inheritance of 6 and a maximum class coupling of 9.
  prefs: []
  type: TYPE_NORMAL
- en: The lines of code metrics are quite useful. I find that having many lines of
    code in a class is frequently one of the greatest signs that a class violates
    the SRP and needs to be refactored. Similarly, if a method is too large, it’s
    usually hard to understand, maintain, and test.
  prefs: []
  type: TYPE_NORMAL
- en: I try to keep classes under 200 lines of code and methods to 20 lines or less.
    In both cases, I look for things I can pull out of the method or class and am
    hesitant to expand an already large class or method with new logic unless I can
    pull logic out of the code first.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that these are general guidelines I’ve found generally effective.
    These are not concrete rules that you must always follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'I encourage you to spend some time looking over code metrics for the sample
    code for this chapter or some code you maintain. In the case of the code for this
    chapter, I’m most concerned about the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BaggageCalculator.CalculatePrice` in the `Flight.Baggage` namespace has a
    maintainability index of 58, cyclomatic complexity of 4, and 26 lines of source
    code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FlightScheduler.Search`, which takes in a `FlightSearch` object in the `Flight.Scheduling`
    namespace, has a maintainability index of 48, a cyclomatic complexity of 9, a
    class coupling of 11, and 37 lines of source code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both methods are flagged by the metrics because they have several `if` statements
    that they need to run. Neither method is very complex, but at the same time, if
    either needs to grow significantly more, I’d like to see refactorings like the
    ones we applied in [*Chapter 5*](B21324_05.xhtml#_idTextAnchor101) to move complexity
    out of these methods and into other objects.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered code metrics, let’s see how code analysis can give us
    another way of looking at our code.
  prefs: []
  type: TYPE_NORMAL
- en: Performing code analysis in Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft knows that as C# and .NET changes, it can be very difficult to keep
    up with evolving standards in a broad and changing language.
  prefs: []
  type: TYPE_NORMAL
- en: To address this, Microsoft gave us tools beyond code metrics in the form of
    analyzers that inspect our C# code for issues. These analyzers look at our code
    and flag potential issues and optimizations. This helps ensure our code complies
    with standards and is secure, reliable, and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing your solution using the default ruleset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see an analyzer in action, build this chapter’s solution in Visual Studio
    and notice the three warnings that appear in the **Output** pane, as shown in
    *Figure 12**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – An overview of the build results showing warnings](img/B21324_12_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – An overview of the build results showing warnings
  prefs: []
  type: TYPE_NORMAL
- en: These three lines represent separate compiler warnings for the CS8618 code analysis
    rule, which we’ll look at shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we do that, click on the **View** menu and then select **Error List**.
    You should see the same warnings formatted in an easier-to-read manner, as shown
    in *Figure 12**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – An overview of the compiler warnings in Error List](img/B21324_12_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – An overview of the compiler warnings in Error List
  prefs: []
  type: TYPE_NORMAL
- en: If these warnings don’t show up, make sure the **Errors**, **Warnings**, and
    **Messages** buttons are checked, as shown in *Figure 12**.5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since these warnings are all associated with `Airport.cs`, let’s review its
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When looking at this code in Visual Studio, you’ll see a “green squiggly” underneath
    each of these three properties. As shown in *Figure 12**.6*, hovering the mouse
    cursor over any of these “squigglies” shows details about the warning or suggestion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – The CS8618 compiler warning associated with the Name property](img/B21324_12_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – The CS8618 compiler warning associated with the Name property
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the warning tells us that these three properties are non-nullable,
    meaning that they are declared as `string` instead of `string?`, as we discussed
    in [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209) when discussing nullability
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Since the default value for any `string` property in .NET is null and the `Airport`
    class doesn’t have any logic to initialize these three properties, the compiler
    warning is telling us that when `Airport` instances are created, they’ll have
    null values in properties we told it couldn’t be null!
  prefs: []
  type: TYPE_NORMAL
- en: Nullability analysis in .NET
  prefs: []
  type: TYPE_NORMAL
- en: Remember that although strings are reference types and can be null, nullability
    analysis in C# indicates if a property is expected to have a null value at any
    point in time. Here, the `string` type indicator means that we never expect these
    properties to have a null value. On the other hand, a `string?` type indicator
    would indicate that we might expect null values. See [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209)
    for more information on nullability analysis in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few ways to address this compiler warning:'
  prefs: []
  type: TYPE_NORMAL
- en: Default these properties to an empty string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change these properties to `string?` instead of `string`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a constructor that sets these properties to non-null values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark these properties as `required` so that they must be set on creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As shown here, the simplest fix is to mark these properties as `required`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This resolves the three code analysis warnings, leaving two less severe suggestions
    for us to investigate, both dealing with the `Equals` method of `Airport`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The first warning is IDE0019, which suggests using pattern matching when declaring
    `otherAirport`. Thankfully, this analyzer provides a `Airport?` type reveals the
    **Use pattern matching** **Quick Action**, as shown in *Figure 12**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Applying the Use pattern matching refactoring](img/B21324_12_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – Applying the Use pattern matching refactoring
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying this refactoring resolves the suggestion and makes our code more concise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The last remaining warning is *IDE0059: Unnecessary assignment of a value to
    ‘otherName’*. This highlights that we’ve declared a variable and assigned a value
    to that variable but never used the variable after that point, as shown here with
    `otherName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Looking at this code, it’s a toss-up as to whether `otherName` should be included
    in the equality check or if the variable is simply not needed. In this case, you
    might ask a business stakeholder if an airport could ever have multiple names
    but be the same airport. If you get a “yes,” then the fix would be to remove the
    `otherName` variable, while a “no” would indicate that a `Name` check should be
    added to the `return` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The correct fix for code issues is not always obvious without gathering more
    information about the business domain you’re modeling.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring code analysis rulesets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a large and growing number of analyzers in .NET and not every analyzer
    shares the same levels of importance. Because of this, Microsoft provides different
    sets of analyzers so that you can start with a small subset of the most useful
    ones and gradually expand into additional sets of analyzers as your maturity grows.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at our code analysis settings for the `Chapter12` project by right-clicking
    on the `Chapter12` project in **Solution Explorer** and then selecting **Properties**.
  prefs: []
  type: TYPE_NORMAL
- en: This will open the properties view of the project. This view lists all configurable
    properties associated with the project and can be scrolled through from top to
    bottom or navigated using the navigation pane on the left-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Code Analysis** in the navigation pane; you should see the project’s
    code analysis settings, as shown in *Figure 12**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Code Analysis settings for the project](img/B21324_12_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – Code Analysis settings for the project
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the **Run on build** setting, the compiler will analyze
    code every time the project is built.
  prefs: []
  type: TYPE_NORMAL
- en: The exact set of analyzers used is controlled by the **Analysis level** setting,
    which defaults to **Latest** for new projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a wide variety of analysis rulesets supported by Visual Studio, but
    let’s focus on the four rulesets that start with “Latest” as these are the most
    recent rulesets available, and the patterns in these rules will help you understand
    the other rules options. These options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Latest**: The default set of rules. This is a set of rules that is intended
    to be broadly applicable to any type of project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Latest Minimum**: Everything in **Latest** plus additional rules. This represents
    the minimum set of rules that Microsoft recommends using in a project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Latest Recommended**: Everything in **Latest Minimum** plus some additional
    rules. This contains a robust set of rules designed to help you maintain a business
    application that can run in any locale securely and reliably.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Latest All**: All available rules are enabled. Not every rule may be relevant
    for the application you’re trying to build, but it maximizes your chances of building
    a robust and reliable application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see what happens when we change our project from **Latest** to **Latest
    Recommended** and then build.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to code analysis rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After changing the project to use the **Latest Recommended** ruleset, three
    new warnings will appear, as shown in *Figure 12**.9:*
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – New compiler warnings after moving to a stricter ruleset](img/B21324_12_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – New compiler warnings after moving to a stricter ruleset
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the first warning. This corresponds to the `Flight` class,
    which is currently defined in only a few lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The CA1822 warning tells us *Member ‘BuildMessage’ does not access instance
    data and can be marked* *as static*.
  prefs: []
  type: TYPE_NORMAL
- en: This analyzer is suggesting we make the `BuildMessage` method `static` because
    it doesn’t deal with any specific information from the overall `Flight` class.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, making the method `static` could make it easier to test and allow
    the compiler to make a few performance optimizations as well.
  prefs: []
  type: TYPE_NORMAL
- en: We could resolve this warning by performing the *Make method static* refactoring
    we covered in [*Chapter 4*](B21324_04.xhtml#_idTextAnchor072), but instead, let’s
    explore suppressing specific warnings.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, let’s say that we intend `BuildMessage` to deal with instance-specific
    properties at some point in the future, but haven’t gotten there yet. Because
    of this, we want the warning to go away without making the method static.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `BuildMessage` method and then select the **Suppress or configure issues**
    submenu. From there, choose **Suppress CA1822**. This will reveal three different
    options for suppressing the issue, as shown in *Figure 12**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10 – Options for suppressing the code analysis warnings](img/B21324_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – Options for suppressing the code analysis warnings
  prefs: []
  type: TYPE_NORMAL
- en: 'These options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#pragma` statements above and below your code to disable the code analysis
    warning temporarily'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**in Suppression File**: This creates a separate file with code telling code
    analysis not to care about this specific issue for this specific method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SuppressMessageAttribute` above the method, suppressing the code analysis
    issue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All three of these approaches will suppress the issue, but all do so in different
    styles. I generally prefer to avoid preprocessor directives such as `#pragma`
    to have cleaner and more maintainable code. This leaves the suppression file and
    attribute approaches.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of a suppression file is that code analysis suppressions do not
    clutter your source code and instead live in a separate file. However, that’s
    also their disadvantage. By hiding away suppressions in another file, you reduce
    the odds of resolving them in the future since they’re “out of sight, out of mind.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `using` statement for `System.Diagnostic.CodeAnalysis` results in
    the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `SuppressMessage` attribute above the method marks the category of the code
    analysis issue as “Performance.” Next, it names the individual analysis rule being
    suppressed before providing a justification.
  prefs: []
  type: TYPE_NORMAL
- en: This justification is a string explaining to your coworkers (and future you)
    why you believe the code analysis rule should not be addressed at this time and
    should be excluded from the list of code analysis results.
  prefs: []
  type: TYPE_NORMAL
- en: I will never suppress a code analysis warning without providing a valid justification
    for the suppression. If a rule was important enough for someone to provide an
    analyzer for, it should either be resolved or I should have a valid justification
    for why I am choosing to ignore it. In case you were wondering, “I don’t feel
    like addressing it” is not a valid justification.
  prefs: []
  type: TYPE_NORMAL
- en: With the first warning out of the way, let’s look at the other two warnings
    together as they’re related.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first warning is CA1305, which is associated with the `DateHelpers` class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This warning states that the `ToString` call might result in a different result,
    depending on the user’s locale and language settings. My settings, as someone
    speaking English in the United States, may be different than someone running the
    same code with French as their primary locale.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next warning is on `BuildFlightIdentifier` in `CharterFlightInfo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This warning is complaining about a similar localization issue stating that
    the behavior of `StringBuilder.Append` could differ based on the user’s locale.
  prefs: []
  type: TYPE_NORMAL
- en: Recommended rules versus minimum and default rules
  prefs: []
  type: TYPE_NORMAL
- en: 'These formatting rules are examples of rules that are not relevant to all projects.
    These rules are not enabled in the default or minimum rulesets for a reason: not
    all applications you create will need to behave consistently, regardless of where
    they’re running. If you’re building a hobby application or an application that
    runs only on a single server or in your office, this rule probably isn’t important
    for you. However, if you’re building something that is distributed throughout
    the globe to customers of all cultures, this is going to be a rule you care about.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fix for these two warnings is to provide an explicit culture that you want
    to be used when formatting strings. This changes our append code to the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Our date formatting code changes in a similar manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With these changes made, we are now free of code analysis warnings. Let’s finish
    this section by looking at a way of making sure we stay free of warnings.
  prefs: []
  type: TYPE_NORMAL
- en: Treating warnings as errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I’ve met many developers who treat warnings like they treat speed limits while
    driving: they ignore them and cruise by at unsafe speeds.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few ways of making sure developers ensure their code is free of
    warnings. Perhaps the easiest way of doing so is to tell the C# compiler to treat
    any warning as if it were a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have the C# compiler treat all warnings as errors by right-clicking
    on the project and then selecting **Properties**, as we did before. From there,
    expand **Build** in the navigation pane and then click **Errors and warnings**.
    Once you do so, you should see something like *Figure 12**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11 – Configuring errors and warnings for a project](img/B21324_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – Configuring errors and warnings for a project
  prefs: []
  type: TYPE_NORMAL
- en: You can check **Treat warnings as errors** to have all warnings result in errors.
  prefs: []
  type: TYPE_NORMAL
- en: Since developers pay attention to things that stop their code from running at
    all, causing any warning to stop them from building their code will certainly
    get their attention! Be careful when using this as they may not be very happy
    about the severity of the interruption.
  prefs: []
  type: TYPE_NORMAL
- en: A less extreme option is to configure the **Treat specific warnings as errors**
    setting and include the identifiers of specific warnings you believe should always
    be addressed.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we wanted to force developers to respond to suggestions of making
    methods `static` (CA1822), you could set the `$(WarningsAsErrors);NU1605;CA1822`;
    by doing so, any place where the warning occurred and was not suppressed would
    result in a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered the code analysis features of Visual Studio, let’s take
    a look at a pair of additional options in the form of third-party tools that work
    well with C# code.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring advanced code analysis tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The built-in code analysis and code metrics tools are very good for engineers
    wanting to pinpoint bad code and ensure code follows best practices for .NET projects,
    but they lack some enterprise-level features.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll look at two different commercial analysis tools that
    I’ve found to provide additional value for .NET projects: **SonarCloud** and **NDepend**.'
  prefs: []
  type: TYPE_NORMAL
- en: I won’t be covering how to set up these tools as both tools have comprehensive
    documentation that I’ve provided links to in the *Further reading* section at
    the end of this chapter. Instead, we’ll focus on the types of insights that dedicated
    code analysis tools can give you beyond what’s available in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking code metrics with SonarCloud and SonarQube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SonarCloud and SonarQube are a pair of commercial code analysis tools offered
    by SonarSource. Both products look at Git repositories containing code in a variety
    of popular programming languages and generate a series of recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: The primary difference between SonarCloud and SonarQube is that SonarCloud is
    hosted on and analyzed by servers maintained by SonarSource while SonarQube is
    software you can install on your servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both pieces of software can analyze code in Git repositories and provide heat
    maps of problem areas in your code in the areas of reliability, maintainability,
    security, and code duplication. These views give you a simple graphical representation
    of your code that helps easily flag problem areas, as shown in *Figure 12**.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – SonarCloud analysis highlighting technical debt areas](img/B21324_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – SonarCloud analysis highlighting technical debt areas
  prefs: []
  type: TYPE_NORMAL
- en: These tools have built-in analyzers that analyze your code and flag reliability,
    security, and performance issues for remediation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once an issue has been flagged, you can use the web user interface shown in
    *Figure 12**.13* to assign it to a team member, add comments to it, or mark it
    as resolved or ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Code analysis recommendations per line of code](img/B21324_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 – Code analysis recommendations per line of code
  prefs: []
  type: TYPE_NORMAL
- en: 'For me, SonarCloud and SonarQube have a few major selling points:'
  prefs: []
  type: TYPE_NORMAL
- en: They help expose technical debt to non-developers in a very user-friendly way.
    An engineering manager or chief technology officer can look at the project in
    their web browser and get an understanding of the weak areas without ever having
    to install Visual Studio. This helps make technical debt transparent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Items flagged by SonarCloud and SonarQube tend to be worth investigating, perhaps
    even more so than items flagged by Visual Studio code analyzers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You tend to get a good result with these tools out of the box without needing
    additional configuration, though the configuration is available for customization
    should you wish to do so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SonarCloud and SonarQube are commercial products that are priced based on the
    lines of code in your projects. SonarCloud is also freely available for any public
    GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Since the code in this book is public on GitHub, you can see its code analysis
    results at [https://sonarcloud.io/summary/overall?id=IntegerMan_Refactoring-with-CSharp](https://sonarcloud.io/summary/overall?id=IntegerMan_Refactoring-with-CSharp).
    I’d also strongly recommend that you create an account and have SonarCloud analyze
    some open-source code you’ve written or are familiar with, just to walk through
    the setup and analysis process and see the recommendations it gives you.
  prefs: []
  type: TYPE_NORMAL
- en: While SonarCloud and SonarQube are not .NET-specific tools, I do find they work
    well with .NET projects, which is why they’re highlighted in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at a tool explicitly built for .NET and C# projects in particular:
    NDepend.'
  prefs: []
  type: TYPE_NORMAL
- en: In-depth .NET analysis with NDepend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NDepend is a power tool designed to help architects and software engineers get
    the most out of their C# projects.
  prefs: []
  type: TYPE_NORMAL
- en: NDepend can operate as a Visual Studio extension such as GitHub Copilot Chat,
    as a standalone application, or as a build agent integrated into an Azure DevOps
    build pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'When NDepend runs its analysis, it produces an HTML report (pictured in *Figure
    12**.14*) and populates a dashboard view with the same information in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – NDepend report showing code analysis results](img/B21324_12_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.14 – NDepend report showing code analysis results
  prefs: []
  type: TYPE_NORMAL
- en: This report highlights the number of code analysis rules violated by the project,
    the current unit test code coverage percentages, and how metrics have changed
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: Try it out
  prefs: []
  type: TYPE_NORMAL
- en: You can view a sample NDepend report for this chapter in the [Chapter12/Ch12FinalCode/NDependOut/NDependReport.html](http://Chapter12/Ch12FinalCode/NDependOut/NDependReport.html)
    file in this book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: If you and your engineering team are trying to answer questions such as “Are
    we getting better or worse?”, “What are our major problems?”, or “What areas need
    to be fixed the most?”, NDepend will help you with that.
  prefs: []
  type: TYPE_NORMAL
- en: Like SonarCloud, NDepend operates on a series of analyzers called “rules.” These
    rules are written using LINQ against a model representing your source code. The
    default rules ship with their source code included and can be customized to your
    team’s needs. You can also write your own rules – much as we’ll write our own
    Roslyn Analyzers in the next two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: These rules also allow you to compare how your code has changed since it was
    last baselined and estimate the amount of time it will take to resolve the technical
    debt they represent.
  prefs: []
  type: TYPE_NORMAL
- en: NDepend’s strengths go past its primary report, rules list, and list of rules
    violations. The real strength of NDepend is in its data visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dependency matrix is what NDepend was originally known for and allows you
    to see a two-dimensional matrix of different namespaces and types, as shown in
    *Figure 12**.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15 – The NDepend dependency matrix](img/B21324_12_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.15 – The NDepend dependency matrix
  prefs: []
  type: TYPE_NORMAL
- en: This matrix helps you detect namespaces or types that are dependent on each
    other. When different types or namespaces are mutually dependent on each other,
    this typically represents incorrectly segmented software architecture, and NDepend
    makes this highly visible when violations are present.
  prefs: []
  type: TYPE_NORMAL
- en: NDepend’s visualizations don’t stop there, however. My favorite visualization
    built into NDepend is its heat view, which allows you to view types or methods
    inside your project in a hierarchical tree with different rectangles representing
    different types or methods.
  prefs: []
  type: TYPE_NORMAL
- en: This view is similar to a tree map in data visualization tools, but each rectangle
    is colorized and sized based on various metrics calculated by NDepend. These metrics
    go well beyond the metrics Visual Studio calculates on its own and include things
    such as the lines of code, cyclomatic complexity, percentage of unit test coverage,
    or even the amount of comments in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This heat map, pictured in *Figure 12**.16*, is the most intuitive way I’ve
    found of helping me zero in on potentially problematic code – and communicate
    problem areas visually to key stakeholders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.16 – An NDepend heat map showing lines of code and cyclomatic complexity](img/B21324_12_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.16 – An NDepend heat map showing lines of code and cyclomatic complexity
  prefs: []
  type: TYPE_NORMAL
- en: 'NDepend also offers a dependency graph view. This graph allows you to see how
    assemblies, namespaces, types, methods, properties, events, and even fields interact
    with each other richly and interactively, as shown in *Figure 12**.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.17 – Namespace and type interactions within the Chapter12 project](img/B21324_12_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.17 – Namespace and type interactions within the Chapter12 project
  prefs: []
  type: TYPE_NORMAL
- en: This allows you to visualize your software architecture and communicate that
    architecture to others on your team. This is particularly handy when onboarding
    new developers.
  prefs: []
  type: TYPE_NORMAL
- en: The graph view also allows you to spot problem areas such as types that depend
    on too many other types, different namespaces dependent on each other, and classes
    that likely violate the SRP.
  prefs: []
  type: TYPE_NORMAL
- en: In my experience, NDepend takes some additional time to configure and investigate,
    but it represents a very effective way of visualizing, communicating, and navigating
    problem areas in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s finish this chapter by exploring code analysis at our fictional organization.
  prefs: []
  type: TYPE_NORMAL
- en: Case study – Cloudy Skies Airline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloudy Skies Airlines knew they had a lot of technical debt and code issues,
    but they weren’t sure which areas they should prioritize. Each engineer had different
    opinions on what was most important. As you would expect, these opinions were
    usually influenced by what each engineer had worked on most recently.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this issue, engineering leadership turned to the data. They started
    analyzing the available code metrics in Visual Studio and cataloging where most
    code analysis warnings seemed to be located.
  prefs: []
  type: TYPE_NORMAL
- en: Engineering management then compared the problem areas with the areas that had
    changed within the past 3 months and the areas the organization expects will need
    to change to support the team’s upcoming initiatives. This approach helped engineering
    management prioritize technical debt resolution in strategic areas that supported
    business objectives.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help resolve the backlog of warnings, developers were given a new mandate:
    each commit you make should not increase the number of active code analysis warnings.
    Decreasing the warning count or having it stay the same is fine, but increasing
    it will not be acceptable in code review.'
  prefs: []
  type: TYPE_NORMAL
- en: This policy built additional awareness of code analysis warnings and the warnings
    were gradually reduced over time. Once the team got acclimated to paying attention
    to warnings, they moved to a larger code analysis ruleset. This caused a new series
    of warnings to come in, but those warnings helped identify potential or actual
    problems, as well as optimizations for the application.
  prefs: []
  type: TYPE_NORMAL
- en: To help provide insight into the health of its code, the organization is currently
    evaluating SonarCloud and NDepend to provide the team with a quality dashboard
    that will help them focus on key areas and ensure quality remains high going forward.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how code metrics and code analysis tools can help you
    spot problem areas in your code, follow best practices, and prioritize areas of
    technical debt. This will help you understand the issues you and your team struggle
    with. Once you know the areas you struggle with, you can focus on remediating
    them going forward. This also helps you prioritize areas of technical debt and
    communicate those areas to others.
  prefs: []
  type: TYPE_NORMAL
- en: These built-in analyzers are incredibly handy and it turns out you can build
    some on your own. Over the next two chapters, we’ll do just that as we build our
    own code analyzer that can detect and automatically fix issues.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the areas you consider to be most problematic about your code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do the code metrics say about these problem areas?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is cyclomatic complexity and how is it calculated?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the things you should consider when picking a code analysis ruleset?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find more information about code analysis at these URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Code Metrics* *Values*: [https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values](https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Overview of .NET source code* *analysis*: [https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*SonarCloud*: [https://www.sonarsource.com/products/sonarcloud/](https://www.sonarsource.com/products/sonarcloud/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NDepend*: [https://www.ndepend.com/](https://www.ndepend.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
