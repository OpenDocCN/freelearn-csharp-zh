- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error Handling and Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging and error handling are two important concepts to consider (and implement)
    when building any application, and CLI applications are no exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: While error handling ensures graceful behavior of the application in the face
    of unexpected events, logging provides crucial insights into the application’s
    runtime behavior and facilitates troubleshooting and debugging.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why, in this chapter, we will cover these two concepts, starting with
    error handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we’ll cover the following main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Error handling in CLI applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging in CLI applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter06](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors in CLI applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Error handling may take two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: An exception is raised, due to an unexpected event (such as an invalid input
    or an inaccessible dependency)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program is terminated, and we want to prevent it crashing by allowing it
    to gracefully shut down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will cover both topics. Let’s start with exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is nothing special about handling exceptions in a CLI application compared
    to other kinds of applications, as it follows the same guidelines and best practices.
    That’s why, in this section, you might find that you already know all the concepts
    that we are going to talk about, and that’s perfectly normal because you’d likely
    have implemented them in other applications, whether web, APIs, or desktop applications.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is important to note that a robust error-handling strategy will
    have a significant impact on the quality, reliability, and resilience of your
    application. This is why it is worth taking the time to design a good error-handling
    strategy.
  prefs: []
  type: TYPE_NORMAL
- en: As you certainly know, every error-handling strategy relies on a `try-catch-finally`
    block. But not always! Not every method needs to implement a `try-catch-finally`
    block. In fact, best practices of error handling state that only the *caller*
    method (usually the top-level method) should handle exceptions, while the *callee*
    method should let the exceptions bubble up to be caught, and handled, by the *caller*
    method. This results in leaner, cleaner, and more focused methods.
  prefs: []
  type: TYPE_NORMAL
- en: Another best practice is to never swallow exceptions unless it is absolutely
    necessary. Why? Because swallowing exceptions hides errors, making code appear
    functional while it fails. This obscures valuable error information, allowing
    unpredictable behavior and data corruption. It complicates debugging and violates
    the principle of failing fast. In other words, it leads to silent failures that
    are hard to detect and fix, making it a poor practice.
  prefs: []
  type: TYPE_NORMAL
- en: The `finally` block is important, although I see it often forgotten. It is important
    to remember that this block is used to ensure that resources are freed, even if
    an exception occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'When catching exceptions, use multiple `catch` blocks, catching exceptions
    from the most specific to the most generic. This will ensure far better error
    handling than catching all exceptions as a generic exception and applying the
    same error-handling processing to all of them. An example of that is when working
    with files: we don’t want to handle the situation where the file is not found
    the same way as handling the situation where the file cannot be written to, because
    of a lack of permissions. By distinguishing each of these situations, we can apply
    a specific error-handling process and, ultimately, provide the user with appropriate
    details of what happened rather than having generic processing and telling the
    user that we couldn’t write to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: We can also create our own exceptions. I do this often because it helps improve
    code readability. It is easy to understand what happens when the `CreateNewUser`
    method throws an instance of the `UserAlreadyExistsException` exception, isn’t
    it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how this custom exception would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To catch or not to catch exceptions?
  prefs: []
  type: TYPE_NORMAL
- en: There’s a movement nowadays that is going against throwing exceptions because
    of the performance cost this may have, and I totally understand this. One great
    video about this topic is the one by Nick Chapsas, titled *Don’t throw exceptions
    in C#. Do this instead*, which you can find on YouTube. I encourage you to go
    and watch it and make up your own mind.
  prefs: []
  type: TYPE_NORMAL
- en: However, whether you choose to throw the exception or handle it without throwing
    it, you will likely be dealing with exceptions. Also, keep in mind that both the
    .NET framework and some other libraries that you might be using are probably throwing
    exceptions, and you will need to catch these to handle them. Because of that,
    the principles described here are still valid and worth knowing.
  prefs: []
  type: TYPE_NORMAL
- en: When catching exceptions, you can also filter them. This is because some exceptions
    may require a different handling mechanism depending on the reason they were thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example of this is the `HttpResponseException` exception type, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see here, we are catching the same exception (`HttpResponseException`)
    twice, but in each `catch` block, we focus on a very specific situation: in the
    first one, we are handling the situation where the resource was not found, whereas,
    in the second one, we are handling the situation where the user accessing the
    resource was not authenticated.'
  prefs: []
  type: TYPE_NORMAL
- en: One final best practice when handling exceptions is to avoid losing the stack
    trace of the exception when throwing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this principle, let’s consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we throw the exception using the `throw ex;` statement, we lose the stack
    trace containing the details of what happened up to this point. The proper way
    to do this is to simply use `throw` to ensure the stack trace is preserved.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in some cases, we may need to catch the exception, handle it, and
    rethrow it by encapsulating it into another exception type, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the stack trace is preserved.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s apply these principles to *Bookmarkr*, and more specifically, to
    the ability to export bookmarks out of *Bookmarkr*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you recall from the previous chapter, the export handler method (`OnHandleExportCommand`)
    looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, note that the `WriteAllText` method may throw many exceptions, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UnauthorizedAccessException` will be thrown in the case of insufficient permissions
    to access the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DirectoryNotFoundException` will be thrown if the path is invalid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PathTooLongException` will be thrown if the path exceeds the system-defined
    maximum length'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let’s handle these exceptions. The code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are handling the most common exceptions, and we
    are also handling the general exception in case of an unexpected exception (yes,
    exceptions are exceptional situations but are nonetheless expected to happen,
    at least most of the time).
  prefs: []
  type: TYPE_NORMAL
- en: Note that we handled exceptions for both the serialization process and the file-writing
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about best practices for handling exceptions, I recommend
    that you visit this page: [https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions](https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions).'
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors doesn’t necessarily mean handling exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As surprising as it may seem, this is true, and exceptions might be avoided
    (at least most of the time) by applying defensive programming techniques.
  prefs: []
  type: TYPE_NORMAL
- en: By validating inputs, enforcing preconditions, and proactively identifying potential
    failure scenarios, we can significantly reduce error occurrences and enhance the
    overall resilience of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what we can do here in terms of defensive programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Validate inputs**: We could ensure that the input file exists, hence avoiding
    an exception being raised if the file doesn’t exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bookmarks` list is not null. Otherwise, `JsonSerializer` will throw a `NullReferenceException`.
    We can also ensure that the list is not empty because, if it is empty, although
    the serialization will return an empty JSON array, we may not want to write this
    to a file, especially if this means overwriting the existing file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identify potential failure scenarios**: We have already done this by catching
    the most common exceptions and handling them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Okay. So, at this point, we know how to handle exceptions in our CLI applications,
    and we implemented this in *Bookmarkr*.
  prefs: []
  type: TYPE_NORMAL
- en: However, there exists one other kind of unexpected event that represents, in
    fact, normal behavior. I’m talking about **program termination**.
  prefs: []
  type: TYPE_NORMAL
- en: Handling program termination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A program might be terminated at any moment by pressing a specific keyboard
    combination (usually *Ctrl* + *C* or *Ctrl* + *Break*). When this happens, the
    operating system sends a signal to the program, instructing it to immediately
    stop its execution. This signal, often referred to as an interrupt or a termination
    signal, allows the program to perform any necessary cleanup operations, such as
    closing files, releasing resources, or saving state, before it exits. If the program
    has a signal handler for this specific signal, it can execute custom code to handle
    the termination gracefully. Otherwise, the program will terminate abruptly, and
    any unsaved data or incomplete operations may be lost.
  prefs: []
  type: TYPE_NORMAL
- en: Program termination allows one to gracefully stop a program that is taking too
    long to execute or that has become unresponsive.
  prefs: []
  type: TYPE_NORMAL
- en: '`System.CommandLine` provides a mechanism to handle program termination and
    execute custom code, allowing our CLI application to gracefully terminate.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement it to handle the situation where the user terminates the program
    while the export operation is ongoing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to handle program termination, we will need to modify the delegate
    of the `SetHandler` method to retrieve the cancellation token and pass it to the
    handler method itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can modify the handler method so it handles the program termination
    (i.e., catching the `OperationCanceledException` exception):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the program now and then terminate it by pressing the *Ctrl* + *C*
    keyboard combination, we get the following console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Handling program termination](img/B22400_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Handling program termination
  prefs: []
  type: TYPE_NORMAL
- en: One thing worth mentioning here is that we need to use the asynchronous version
    of the `WriteAllText` method (aka `WriteAllTextAsync`) in order to be able to
    pass the cancellation token we received as a parameter, and for that reason, we
    needed to declare the `OnExportCommand` method as `async`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that by handling program termination, we can gracefully handle the situation
    where the user abruptly stops the program. This results in a graceful shutdown
    of the program and release of the used resources, hence avoiding a crash and an
    error message.
  prefs: []
  type: TYPE_NORMAL
- en: Why are we passing the cancellation token as a parameter to the handler method
    and not using it?
  prefs: []
  type: TYPE_NORMAL
- en: This is an excellent question! As you have noticed, even though we receive the
    `CancellationToken` object as a parameter to the `OnExportCommand` method, we
    seem not to be using it. Then, why did we pass it in the first place?
  prefs: []
  type: TYPE_NORMAL
- en: This is related to how cancellation tokens work in .NET. Let me explain!
  prefs: []
  type: TYPE_NORMAL
- en: When `OperationCanceledException` is created in response to a cancellation request,
    it typically includes information about the `CancellationToken` object that triggered
    the cancellation.
  prefs: []
  type: TYPE_NORMAL
- en: For that matter, the `OperationCanceledException` exception class has a constructor
    that takes a `CancellationToken` object as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: When .NET framework asynchronous methods create this exception, they usually
    use this constructor and pass the cancellation token that triggered the cancellation
    request.
  prefs: []
  type: TYPE_NORMAL
- en: The `OperationCanceledException` class has a `CancellationToken` property that
    can be then accessed to get the token associated with the cancellation request.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we are accessing it to check whether the cancellation was requested
    by the user or not.
  prefs: []
  type: TYPE_NORMAL
- en: Having established a robust framework for error handling, it is equally important
    to ensure that these errors are recorded and monitored. That’s where logging comes
    into play!
  prefs: []
  type: TYPE_NORMAL
- en: Effective logging not only helps in diagnosing and resolving issues but also
    provides valuable insights into the application’s behavior, performance, and usage.
    In the upcoming section, we will dive into the best practices and strategies for
    implementing comprehensive logging mechanisms that complement our error-handling
    strategy.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have covered a lot of information on error handling. However,
    error handling works together with logging to improve application reliability
    and maintainability. So, let’s shift our focus to logging, and explore how to
    capture and preserve valuable information not only about errors but also about
    other significant events that will happen during program execution.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in CLI applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While error handling is more of a “just-in-time” compensation mechanism when
    an unexpected event or error occurs, we may want to keep track of what happened
    so we can reproduce the issue, analyze it, understand why it happened in the first
    place, and fix it.
  prefs: []
  type: TYPE_NORMAL
- en: By “keeping track of what happened,” we either mean the sequence of events that
    led to that unexpected behavior or error and/or the call stack of the exception
    raised when the error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a logging format is important. We want to find a balance between the
    amount of data we are logging (and storing) and the usage we intend to do with
    it. Logging unnecessary information will complexify log analysis, increase storage
    (and retention) costs, and may also slow down the logging process. We will also
    need to ensure that we are not logging sensitive information (such as credit card
    data), and if we do, that we are doing it in a safe manner. Some of the popular
    log formats include XML, JSON, CSV, and syslog.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the logging destination is equally important. We need to understand
    that there are no good or bad options, only appropriate and inappropriate options
    depending on our context and needs. If our intent is to analyze the logs, we may
    want to store these logs in a solution that provides log analysis mechanisms out
    of the box, so we don’t need to write code for that. Examples of such solutions
    are Azure Log Analytics, Splunk, Datadog, Dynatrace, Serilog, and Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: However, note that by relying on cloud solutions (such as Azure Log Analytics),
    our application needs either to be running in the cloud or to have a constant
    connection to the internet. Sure, we can also build our application to follow
    the **occasionally connected application** (**OCA**) pattern so it keeps logs
    locally when it is running offline and sends them to Azure Log Analytics when
    it goes back online, but the idea here is that we should select a logging solution
    that is coherent with the usage pattern of our application. So, for an application
    that is intended to run locally, we will favor a logging mechanism that runs locally
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it is also important to define the log retention period. This can
    either be enforced by the organization’s compliance rules or by the relevance
    of the logged data: do you still need to analyze data from a bug or customer behavior
    that occurred three years ago? If not, you don’t need to keep this data.'
  prefs: []
  type: TYPE_NORMAL
- en: Either way, it is important to separate the logging format from the solution
    you use to store and analyze these logs.
  prefs: []
  type: TYPE_NORMAL
- en: Since our application is intended to run locally, we will select JSON as a logging
    format and Serilog as a logging mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Why JSON?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSON-structured logs are easy to read and can easily be parsed by machines.
    Many modern log management solutions can ingest logs in JSON format, making it
    a good choice for structured logging.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, JSON is less verbose than XML, which results in files that are
    lightweight in size, which, in turn, reduces the amount of storage we need to
    store them.
  prefs: []
  type: TYPE_NORMAL
- en: Why Serilog?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serilog is a diagnostic logging library for .NET. It is built with powerful
    structured event data in mind and supports various “sinks,” which are the destinations
    where log events can be written to. Examples of such sinks include files, the
    console, databases or log management tools (such as Elasticsearch, Application
    Insights, Datadog, and Splunk). It’s easy to set up, has a clean API, and is portable.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key features of Serilog is its ability to log structured data, which
    allows for more meaningful and queryable logs. It uses message templates, a simple
    DSL extending .NET format strings, which can capture properties along with the
    log event.
  prefs: []
  type: TYPE_NORMAL
- en: I do like the way the NuGet packages for Serilog are structured. First, there
    is the base package, which provides Serilog’s functionalities in our code. Then,
    there are “sink” packages, one for each sink, and there are tons of them. We can
    even create our very own sink should we need it. I haven’t found a usage for that
    as there are already sinks for almost everything you can think of…
  prefs: []
  type: TYPE_NORMAL
- en: Oh! And, by the way, the Serilog NuGet package has been downloaded (to this
    day) more than 1.24 billion times! That should mean something, right? 😉
  prefs: []
  type: TYPE_NORMAL
- en: Before we add Serilog to our CLI application, we need to modify our code to
    expose the `IServiceCollection` property so we can configure our services.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing IServiceCollection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step we need to take is to add the `System.CommandLine.Hosting` NuGet
    package to our project. From the Visual Studio Code terminal, we can do so by
    typing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to update our instantiation of the `CommandLineBuilder` class
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We now have access to `IServiceCollection` and can thus add services to this
    collection and configure their behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Serilog to IServiceCollection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding Serilog to this collection will require the `Serilog.Extensions.Hosting`
    NuGet package. So, let’s add it!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to add Serilog to `IServiceCollection` by adding this line of
    code to the preceding code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Adding (and configuring) the required Serilog sinks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier, there are tons of sinks available with Serilog. However,
    since we are building a CLI application, we will only use two sinks: `Console`
    and `File`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also mentioned that Serilog is structured in such a way that each sink has
    its own NuGet package. We will then need to add the appropriate NuGet packages
    using these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can start using Serilog at this point by configuring the sinks in the code.
    The updated code for the instantiation of the `CommandLineBuilder` class would
    then be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at the part of the code where Serilog is configured
    (i.e., the delegate function within the `AddSerilog` method):'
  prefs: []
  type: TYPE_NORMAL
- en: This code acts on an instance of the `LoggerConfiguration` class that is used
    to configure the behavior of Serilog and its sinks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the minimum log level as `Information`. This means that every event
    that is informational or above (such as warnings and errors) will be logged unless
    overridden by a specific sink.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We notice that the `File` sink has overridden the log level in a way that only
    errors or higher severity events (such as `Fatal`) are logged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can also notice that the `File` sink has defined the location of the files
    (the `logs` folder) and the naming convention for the log files (`bookmark-.txt`).
    The dash symbol in the filename is not a misspelling but rather intentional! It
    is there because Serilog will append a unique identifier to that filename. Since
    we defined our rolling interval to be on a daily basis, Serilog will create a
    new log file every day. Hence, our log folder will contain files that will be
    named `bookmark-20240705.txt`, `bookmark-20240706.txt`, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We notice that we are also explicitly telling Serilog to log to the console.
    This is because even though we added a reference to the `Serilog.Sinks.Console`
    NuGet package, we still need to tell Serilog to actually use this sink.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we call the `CreateLogger` method so that all this configuration is
    taken into account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring sinks in appsettings.json
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although configuring the behavior of Serilog and its sinks directly in the code
    works perfectly fine, it is less flexible.
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to add a new sink or update the configuration of an existing
    one? Well, you guessed it, we need to update and redeploy the code.
  prefs: []
  type: TYPE_NORMAL
- en: Moving this configuration into a configuration file (such as `appsettings.json`)
    brings more flexibility to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how we can do this!
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to add the `Serilog.Settings.Configuration` NuGet package to
    our application by typing this command into the Visual Studio Code terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We then need to add an `appsettings.json` file to our application. This can
    easily be done by adding a new file to the project in Visual Studio Code or in
    your favorite code editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `appsettings.json` file to be deployed with our application, we need
    to ensure that its latest version is always copied to the output directory. This
    can be done in the `bookmarkr.csproj` file by adding this snippet just before
    the closing `</``Project>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s move the configuration of Serilog and its sinks from the code to
    the `appsettings.json` configuration file. The content of this file will then
    be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This file is easy to read and pretty self-explanatory. It describes the sinks
    to be used and their configuration and defines the minimum log level. There is
    one thing to pay attention to here, however! Notice that we have overridden the
    minimum log level for libraries of the `Microsoft` and `System` namespaces. This
    is because these libraries tend to be chatty, which may result in a large amount
    of log data that is not very useful. By setting their minimum log level to `Warning`,
    we can ensure to only capture relevant events such as warnings or errors.
  prefs: []
  type: TYPE_NORMAL
- en: The `Enrich` section is a new one, however. As the name suggests, it is there
    to enrich the log data with extra information such as the machine name and the
    thread ID. If your CLI application is intended to be executed on multiple computers
    within your organization, knowing on which machine you got the error helps you
    narrow the search area. If that application is intended to run in multiple instances
    on the same machine, the thread ID will let you know which instance logged that
    information. This can be helpful in a concurrent execution scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Are we done?
  prefs: []
  type: TYPE_NORMAL
- en: Not exactly… We still need to update the code inside the `ConfigureServices`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since all the configuration has been moved to the `appsettings.json` file,
    the code becomes simpler, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Configuration in code or in a file?
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering whether to configure your logger in the code or in a configuration
    file. That is a great question!
  prefs: []
  type: TYPE_NORMAL
- en: 'I personally rely on both: I configure my sinks in the code and the log level
    in the `appsettings.json` file. This way, I can ensure that my “base sinks” are
    always in use even though more may be added later.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a personal choice, however. You are, of course, welcome to use whatever
    works best for you.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that configuration in the code takes precedence over configuration
    in the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s log something!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally! Up to this point, all we did was configure our logger and its sinks.
    Let’s now see how this works!
  prefs: []
  type: TYPE_NORMAL
- en: Once everything is in place and well configured, logging information using Serilog
    is quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this, let’s take an example.
  prefs: []
  type: TYPE_NORMAL
- en: When we implemented the `import` command back in [*Chapter 5*](B22400_05.xhtml#_idTextAnchor068),
    if an existing bookmark was to be updated (because a bookmark with the same URL
    but a different name already existed in the list of bookmarks held by the application),
    we had no way to track the name of that conflicting bookmark before the update.
  prefs: []
  type: TYPE_NORMAL
- en: If this was a piece of critical information (for compliance reasons, for example),
    logging would come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: We will revisit this functionality and implement logging to keep track of the
    name before and after the update, along with its URL and the date and time of
    the update.
  prefs: []
  type: TYPE_NORMAL
- en: 'The log format would then be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we will do is to create a new version of the `import` method
    for the `BookmarkService` class. This new version will take a bookmark as a parameter
    and check whether a bookmark with the same URL but with a different name already
    exists in the list of bookmarks held by the application. If this is actually the
    case, it replaces the existing bookmark with the new name and then returns an
    instance of the `BookmarkConflictModel` type, which contains the original and
    updated name and the URL. If no conflict is detected, the method simply adds the
    bookmark and returns `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The code of the `BookmarkConflictModel` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the code of the handler method of the `Import` command is updated to
    process each bookmark read from the file such that if a conflict is detected,
    Serilog is used to keep track of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the updated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run this program, we can see that was logged in case of a conflict:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Logging in case of a conflict](img/B22400_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Logging in case of a conflict
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, this information was both logged to the console and to the file.
  prefs: []
  type: TYPE_NORMAL
- en: We are now able to use Serilog to log important information. But what happens
    if the application is closed or is terminated? In such a situation, we can rely
    on the `CloseAndFlush` method.
  prefs: []
  type: TYPE_NORMAL
- en: Closing and gracefully disposing of Serilog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using Serilog, the `Log.CloseAndFlush` method is called to ensure that
    all pending log event messages are flushed out to the sinks and that the logging
    system is properly shut down. This is particularly important in applications that
    have a definite end to their life cycle, such as console applications or batch
    jobs, to make sure that no log entries are missed due to the application closing
    before the logs are fully written out.
  prefs: []
  type: TYPE_NORMAL
- en: 'When calling this method, two things happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Close**: This sends a signal to the logging subsystem to stop accepting new
    log events. This is important to prevent any new logs from being generated after
    we have decided to shut down the logging system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flush**: This ensures that all log events that have been captured and are
    currently buffered are written out to their respective sinks. Serilog may buffer
    events in memory for efficiency, and flushing ensures that these buffered events
    are not lost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I recommend calling this method when exiting the application, either by shutting
    it down or by terminating it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that matter, I always create a method (which I call `FreeSerilogLoggerOnShutdown`)
    that will subscribe to two events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AppDomain.CurrentDomain.ProcessExit`: This event is raised when the process
    is about to exit, allowing us to perform cleanup tasks or save data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Console.CancelKeyPress`: This event is triggered when the user presses *Ctrl*
    + *C* or *Ctrl* + *Break*, terminating the currently running application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both cases, these subscription calls the same delegate method (which I call
    `ExecuteShutdownTasks`) that will call the `CloseAndFlush` method from Serilog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for these two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The call to the `FreeSerilogLoggerOnShutDown` method is the first instruction
    of the `Main` method of the `Program` class.
  prefs: []
  type: TYPE_NORMAL
- en: While this is not a book about Serilog (which, in my opinion, deserves a book
    on its own), in this section, we covered the basics, which is enough for the purpose
    of the book. If you want to find more information about Serilog, visit [https://serilog.net/](https://serilog.net/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we improved our CLI application, *Bookmarkr*, by adding error
    handling and logging into the application.
  prefs: []
  type: TYPE_NORMAL
- en: With error handling, we implemented graceful degradation into our CLI application.
    This means that our application is now more fault-tolerant and will not crash
    abruptly should an unexpected event occur.
  prefs: []
  type: TYPE_NORMAL
- en: With logging, we can record application activities, errors, and exceptions so
    that they can be analyzed at a later point in time in order to understand the
    sequence of events that led up to that error or unexpected behavior. But logging
    also enables the monitoring of application health and performance over time.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we will see how to make our CLI application more interactive
    and user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Your turn!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following along with the provided code is a great way to learn through practice.
  prefs: []
  type: TYPE_NORMAL
- en: A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to improve the *Bookmarkr* application by adding the following features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Task #1 – Handling errors for the Import command'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the input file cannot be accessed, or if its content cannot be deserialized,
    it is likely that the code will throw exceptions. Your mission is to identify
    what exceptions are likely to be thrown and handle them accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Task #2 – Logging errors to a file'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous task, the goal was to handle the exceptions. However, it might
    be useful to log the details of these exceptions to a file so we can review them
    later and use this information to improve the robustness of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Your mission here is to use Serilog to log exception data on a daily rolling
    interval and store these log files in the `logs/errors` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are also asked to customize the output template so that logs contain the
    following information:'
  prefs: []
  type: TYPE_NORMAL
- en: Date and time of the event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the machine on which the event happened
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of event (warning, error, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exception’s details, including its stack trace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: Advanced Topics in CLI Application Development'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will explore the world of interactive command-line applications,
    learning how to create engaging user experiences using libraries like `Spectre.Console`.
    You'll discover techniques for implementing rich prompts, colorful output, and
    interactive menus that enhance user interaction. Next, you'll delve into building
    modular and extensible CLI applications, focusing on architectural patterns that
    promote maintainability and scalability. This includes structuring your code and
    organizing your project into logical components. Finally, you'll learn about integrating
    external APIs and services into your CLI applications. By the end of this part,
    you'll have the skills to develop sophisticated CLI tools that can consume various
    external services and APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B22400_07.xhtml#_idTextAnchor105)*, Interactive CLI Applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B22400_08.xhtml#_idTextAnchor120)*, Building Modular and Extensible
    CLI Applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B22400_09.xhtml#_idTextAnchor136)*, Working with External APIs
    and Services*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
