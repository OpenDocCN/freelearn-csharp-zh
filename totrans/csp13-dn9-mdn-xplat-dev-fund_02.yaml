- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Speaking C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is all about the basics of the C# programming language. Over the
    course of this chapter, you’ll learn how to write statements using the grammar
    of C#, as well as be introduced to some of the common vocabulary words that you
    will use every day. In addition to this, by the end of the chapter, you’ll feel
    confident in knowing how to temporarily store and work with information in your
    computer’s memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the C# language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering your C# compiler version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding C# grammar and vocabulary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring more about console apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the C# language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part of the book is about the C# language—the grammar and vocabulary that
    you will use every day to write the source code for your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Programming languages have many similarities to human languages, except that
    in programming languages, you can make up your own words, just like Dr. Seuss!
  prefs: []
  type: TYPE_NORMAL
- en: 'In a book written by Dr. Seuss in 1950, *If I Ran the Zoo*, he states this:'
  prefs: []
  type: TYPE_NORMAL
- en: “And then, just to show them, I’ll sail to Ka-Troo And Bring Back an It-Kutch,
    a Preep, and a Proo, A Nerkle, a Nerd, and a Seersucker, too!”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: C# language versions and features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This part of the book covers the C# programming language and is written primarily
    for beginners, so it covers the fundamental topics that all developers need to
    know, including declaring variables, storing data, and how to define your own
    custom data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book covers features of the C# language from version 1 up to the latest
    version, C# 13\. You can read a summary of what’s new in C# 13 at the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-13](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-13)'
  prefs: []
  type: TYPE_NORMAL
- en: If you already have some familiarity with older versions of C# and are excited
    to find out about the new features in the most recent versions of C#, I have made
    it easier for you to jump around by listing language versions and their important
    new features below, along with the chapter number and topic title where you can
    learn about them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read this information in the GitHub repository at the following link:
    [https://github.com/markjprice/cs13net9/blob/main/docs/ch02-features.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch02-features.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding C# standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Over the years, Microsoft has submitted a few versions of C# to ECMA standards
    bodies. Microsoft made C# open source in 2014\. You can read the latest C# standard
    document at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/specification/](https://learn.microsoft.com/en-us/dotnet/csharp/specification/).
    More practically useful than the ECMA standards are the public GitHub repositories
    for making the work on C# and related technologies as open as possible, as shown
    in *Table 2.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Description** | **Link** |'
  prefs: []
  type: TYPE_TB
- en: '| C# language design | [https://github.com/dotnet/csharplang](https://github.com/dotnet/csharplang)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Compiler implementation | [https://github.com/dotnet/roslyn](https://github.com/dotnet/roslyn)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Standard to describe the language | [https://github.com/dotnet/csharpstandard](https://github.com/dotnet/csharpstandard)
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.1: Public GitHub repositories for C#'
  prefs: []
  type: TYPE_NORMAL
- en: Discovering your C# compiler version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The .NET language compiler for C# and Visual Basic, also known as **Roslyn**,
    along with a separate compiler for F#, is distributed as part of the .NET SDK.
    To use a specific version of C#, you must have at least that version of the .NET
    SDK installed, as shown in *Table 2.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **.NET SDK** | **Roslyn compiler** | **Default C# language** |'
  prefs: []
  type: TYPE_TB
- en: '| 1.0.4 | 2.0–2.2 | 7.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.1.4 | 2.3–2.4 | 7.1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2.1.2 | 2.6–2.7 | 7.2 |'
  prefs: []
  type: TYPE_TB
- en: '| 2.1.200 | 2.8–2.10 | 7.3 |'
  prefs: []
  type: TYPE_TB
- en: '| 3.0 | 3.0–3.4 | 8.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.0 | 3.8 | 9.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 6.0 | 4.0 | 10.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 7.0 | 4.4 | 11.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 8.0 | 4.8 | 12.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 9.0 | 4.12 | 13.0 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.2: .NET SDK versions and their C# compiler versions'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create class libraries, you can choose to target .NET Standard as
    well as versions of modern .NET. They have default C# language versions, as shown
    in *Table 2.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **.NET Standard** | **C#** |'
  prefs: []
  type: TYPE_TB
- en: '| 2.0 | 7.3 |'
  prefs: []
  type: TYPE_TB
- en: '| 2.1 | 8.0 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.3: .NET Standard versions and their default C# compiler versions'
  prefs: []
  type: TYPE_NORMAL
- en: Although you must have a minimum version of the .NET SDK installed to have access
    to a specific compiler version, the projects that you create can target older
    versions of .NET and still use a modern compiler version. For example, if you
    have the .NET 9 SDK or later installed, then you can use C# 13 language features
    in a console app that targets .NET 8.
  prefs: []
  type: TYPE_NORMAL
- en: How to output the SDK version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see what .NET SDK and C# language compiler versions you have available:'
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, start **Windows Terminal** or **Command Prompt**. On macOS, start
    **Terminal**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To determine which version of the .NET SDK you have available, enter the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that the version at the time of publishing is 9.0.100, indicating that
    it is the initial version of the SDK without any bug fixes or new features yet,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enabling a specific language version compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developer tools like Visual Studio and the `dotnet` command-line interface assume
    that you want to use the latest major version of a C# language compiler by default.
    Before C# 8 was released, C# 7 was the latest major version and was used by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the improvements in a C# point release like 7.1, 7.2, or 7.3, you had
    to add a `<LangVersion>` configuration element to the project file, as shown in
    the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After the release of C# 13 with .NET 9, if Microsoft releases a C# 13.1 compiler
    and you want to use its new language features, then you will have to add a configuration
    element to your project file, as shown in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Potential values for the `<LangVersion>` are shown in *Table 2.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **<LangVersion>** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `7`, `7.1`, `7.2`, `7.3`, `8`, `9`, `10`, `11`, `12`, `13` | Entering a specific
    version number will use that compiler if it has been installed. |'
  prefs: []
  type: TYPE_TB
- en: '| `latestmajor` | Uses the highest major number, for example, 7.0 in August
    2019, 8 in October 2019, 9 in November 2020, 10 in November 2021, 11 in November
    2022, 12 in November 2023, and 13 in November 2024. |'
  prefs: []
  type: TYPE_TB
- en: '| `latest` | Uses the highest major and highest minor number, for example,
    7.2 in 2017, 7.3 in 2018, 8 in 2019, and perhaps 13.1 in the first half of 2025.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `preview` | Uses the highest available preview version, for example, 14 in
    mid-July 2025 with .NET 10 Preview 6 installed. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.4: LangVersion settings for a project file'
  prefs: []
  type: TYPE_NORMAL
- en: Using preview C# compiler versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In February 2025, Microsoft is likely to release the first public preview of
    .NET 10 with the C# 14 compiler. You will be able to install its SDK from the
    following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://dotnet.microsoft.com/en-us/download/dotnet/10.0](https://dotnet.microsoft.com/en-us/download/dotnet/10.0)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** The link will give a `404 Missing resource` error until February
    2025, so do not bother using it until then!'
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve installed a .NET 10 SDK preview, you will be able to use it to
    create new projects and explore the new language features in C# 14.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating a new project, you must edit the `.csproj` file and add the
    `<LangVersion>` element set to `preview` to use the preview C# 14 compiler, as
    shown highlighted in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: You should only set `<LangVersion>` to `preview` for exploration,
    not production projects, because it is not supported by Microsoft and it is more
    likely to have bugs. Microsoft makes previews available because they want to hear
    feedback from developers like you. In this way, you can be a part of C#’s development
    and improvement.'
  prefs: []
  type: TYPE_NORMAL
- en: Switching the C# compiler for .NET 9 to a future version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET 9 comes with the C# 13 compiler but that does not mean that you are stuck
    with the C# 13 compiler. Once the .NET 10 SDK is made generally available in November
    2025, you will be able to get the best of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the .NET 10 SDK and its C# 14 compiler while your projects continue
    to target .NET 9\. To do so, set the target framework to `net9.0` and add a `<LangVersion>`
    element set to `14`, as shown highlighted in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding project targets `net9.0`, so it is supported until May 2026 when
    run on a monthly patched version of the .NET 9 runtime. If the preceding project
    is built using .NET 10 SDK, then it can have the `<LangVersion>` set to `14`,
    meaning C# 14.
  prefs: []
  type: TYPE_NORMAL
- en: If you target `net10.0`, which new projects will by default if you have installed
    the .NET 10 SDK, then the default language will be C# 14 so it would not need
    to be explicitly set.
  prefs: []
  type: TYPE_NORMAL
- en: 'In February 2026, Microsoft is likely to release the first preview of .NET
    11, and in November 2026, it will likely release .NET 11 for general availability
    in production. You will be able to install its SDK from the following link and
    explore C# 15 in the same way as described above for C# 14 with .NET 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://dotnet.microsoft.com/en-us/download/dotnet/11.0](https://dotnet.microsoft.com/en-us/download/dotnet/11.0)'
  prefs: []
  type: TYPE_NORMAL
- en: Again, the preceding link is for future use! It will give a `404 Missing resource`
    error until February 2026, so do not bother using the preceding link until then.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** Some C# language features depend on changes in the underlying
    .NET libraries. Even if you use the latest SDK with the latest compiler, you might
    not be able to use all the new language features while targeting an older version
    of .NET. For example, C# 11 introduced the `required` keyword, but it cannot be
    used in a project that targets .NET 6 because that language feature requires new
    attributes that are only available in .NET 7\. Luckily, the compiler will warn
    you if you try to use a C# feature that is not supported. Just be prepared for
    that eventuality.'
  prefs: []
  type: TYPE_NORMAL
- en: Showing the compiler version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by writing code that shows the compiler version:'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve completed *Chapter 1*, *Hello, C#! Welcome, .NET!*, then you will
    already have a `cs13net9` folder. If not, then you’ll need to create it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console App [C#]** / `console`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `Vocabulary`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter02`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not use top-level statements**: Cleared'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable native AOT publish**: Cleared'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice**: If you have forgotten how, or did not complete the previous
    chapter, then step-by-step instructions for creating a solution with multiple
    projects are given in *Chapter 1*, *Hello, C#! Welcome, .NET!*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Vocabulary` project, in `Program.cs`, after the comment, add a statement
    to show the C# version as an error, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using Visual Studio, then navigate to **Debug** | **Start Without
    Debugging**. When prompted to continue and run the last successful build, click
    **No**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using VS Code, then in a terminal for the `Vocabulary` folder, enter
    the `dotnet run` command. Note that we are expecting a compiler error, so do not
    panic when you see it!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that the compiler version and the language version appear as compiler
    error message number `CS8304`, as shown in *Figure 2.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: A compiler error that shows the C# language version'
  prefs: []
  type: TYPE_NORMAL
- en: 'The error message in the VS Code **PROBLEMS** window or Visual Studio **Error
    List** window says `Compiler version: ''4.12.0...''` with language version `default
    (13.0)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment out the statement that causes the error, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the compiler error messages disappear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding C# grammar and vocabulary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start by looking at the basics of the grammar and vocabulary of C#. Throughout
    this chapter, you will create multiple console apps, with each one showing related
    features of the C# language.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding C# grammar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The grammar of C# includes statements and blocks. To document your code, you
    can use comments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Comments should not be the only way that you document your
    code. Choosing sensible names for variables and functions, writing unit tests,
    and creating actual documents are other ways to document your code.'
  prefs: []
  type: TYPE_NORMAL
- en: Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In English, we indicate the end of a sentence with a period. A sentence can
    be composed of multiple words and phrases, with the order of words being part
    of the grammar. For example, in English, we say “the black cat.”
  prefs: []
  type: TYPE_NORMAL
- en: 'The adjective, *black*, comes before the noun, *cat*. However, French grammar
    has a different order; the adjective comes after the noun: “le chat noir.” What’s
    important to take away from this is that the order matters.'
  prefs: []
  type: TYPE_NORMAL
- en: C# indicates the end of a **statement** with a semicolon. A statement can be
    composed of multiple **types**, **variables**, and **expressions** made up of
    **tokens**. Each token is separated by white space or some other recognizably
    different token, like an operator, for example, `=` or `+`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following statement, `decimal` is a type, `totalPrice`
    is a variable, and `subtotal + salesTax` is an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The expression is made up of an operand named `subtotal`, an operator `+`, and
    another operand named `salesTax`. The order of operands and operators matters
    because the order affects the meaning and result.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Comments are the primary method of documenting your code to enhance the understanding
    of how it works, for other developers to read, or for you to read even when you
    come back to it months later.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 4,* *Writing, Debugging, and Testing Functions*, you will learn
    about XML comments that start with three slashes, `///`, and work with a tool
    to generate web pages to document your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add comments to explain your code using a double slash, `//`. The compiler
    will ignore everything after the `//` until the end of the line, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To write a multiline comment, use `/*` at the beginning and `*/` at the end
    of the comment, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Although `/* */` is mostly used for multiline comments, it is also useful for
    commenting in the middle of a statement, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: Well-designed code, including function signatures with well-named
    parameters and class encapsulation, can be somewhat self-documenting. When you
    find yourself putting too many comments and explanations in your code, ask yourself:
    can I rewrite, aka refactor, this code to make it more understandable without
    long comments?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code editor has commands to make it easier to add and remove comment characters,
    as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio: Navigate to **Edit** | **Advanced** | **Comment Selection**
    or **Uncomment Selection**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VS Code: Navigate to **Edit** | **Toggle Line Comment** or **Toggle Block Comment**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rider: Navigate to **Code** | **Comment with Line Comment** or **Comment with
    Block Comment**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice**: You **comment** code by adding descriptive text above or
    after code statements. You **comment out** code by adding comment characters before
    or around statements to make them inactive. **Uncommenting** means removing the
    comment characters.'
  prefs: []
  type: TYPE_NORMAL
- en: Blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In English, we indicate a new paragraph by starting a new line. C# indicates
    a **block** of code with the use of curly brackets, `{ }`.
  prefs: []
  type: TYPE_NORMAL
- en: Blocks start with a declaration to indicate what is being defined. For example,
    a block can define the start and end of many language constructs, including namespaces,
    classes, methods, or statements like `foreach`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn more about namespaces, classes, and methods later in this chapter
    and subsequent chapters, but to briefly introduce some of those concepts now:'
  prefs: []
  type: TYPE_NORMAL
- en: A **namespace** contains types like classes to group them together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **class** contains the members of an object, including methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **method** contains statements that implement an action that an object can
    take.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Code editors like Visual Studio, Rider, and VS Code provide a handy feature
    to collapse and expand blocks by toggling the arrow symbol pointing down or right
    when you move your mouse cursor over the left margin of the code, as shown in
    *Figure 2.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Code editors with expanded and collapsed blocks'
  prefs: []
  type: TYPE_NORMAL
- en: Regions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can define your own labeled regions around any statements you want and
    then most code editors will allow you to collapse and expand them in the same
    way as blocks, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this way, regions can be treated as commented blocks that can be collapsed
    to show a summary of what the block does.
  prefs: []
  type: TYPE_NORMAL
- en: I will use `#region` blocks throughout the solution code in the GitHub repository,
    especially for the early chapters before we start defining functions that act
    as natural collapsible regions, but I won’t show them in the print book to save
    space. Use your own judgment to decide if you want to use regions in your own
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of statements and blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a simple console app that does not use the top-level program feature, I’ve
    added some comments to the statements and blocks, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that C# uses a brace style where both the open and close braces are on
    their own line and are at the same indentation level, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Other languages like JavaScript use curly braces but format them differently.
    They put the open curly brace at the end of the declaration statement, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can use whatever style you prefer because the compiler does not care.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, to save vertical space in a print book, I use the JavaScript brace
    style, but mostly I stick with the C# brace style. I use two spaces instead of
    the more common four spaces for indenting because my code will be printed in a
    book and therefore has a narrow width available.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: The official coding style conventions can be found at
    the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions).'
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of any official guidelines, I recommend that you conform to whatever
    standards have been adopted by your development team, unless you are a solo developer,
    in which case as long as your code compiles, you can use any conventions you like.
    Be kind to your future self, though, by being consistent one way or the other!
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: The brace style used in the Microsoft official documentation
    is the most commonly used for C#. For example, see the `for` statement, as found
    at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements).'
  prefs: []
  type: TYPE_NORMAL
- en: Formatting code using white space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: White space includes the space, tab, and newline characters. You can use white
    space to format your code however you like because extra white space has no effect
    on the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** Unless a step-by-step instruction tells the reader to enter code,
    code examples are written to be read and understood, not typed into a code editor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following four statements are all equivalent. Since all four statements
    are equivalent, they all have the same variable name, and therefore cannot be
    all declared in the same code block, so please do not try to type this code unless
    you also change the three `sum` variable names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The only white space character required in the preceding statements is one between
    `int` and `sum` to tell the compiler they are separate tokens. Any single white
    space character (for example, a space, tab, or newline) would be acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: You can read the formal definition of C# white space
    at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#634-white-space](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#634-white-space).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding C# vocabulary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C# vocabulary is made up of **keywords**, **symbol characters**, and **types**.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the predefined, reserved keywords that you will see in this book and
    use frequently include `using`, `namespace`, `class`, `static`, `int`, `string`,
    `double`, `bool`, `if`, `switch`, `break`, `while`, `do`, `for`, `foreach`, `this`,
    and `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** The `this` keyword can be used in multiple ways, including to
    refer to the current instance of an object, to call a constructor on the current
    object instance, and to define an indexer. Examples of all three will be covered
    in *Chapter 5, Building Your Own Types with Object-Oriented Programming*.'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the symbol characters that you will see are `"`, `'`, `+`, `-`, `*`,
    `/`, `%`, `@`, and `$`.
  prefs: []
  type: TYPE_NORMAL
- en: '“Bracket” symbols include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`()` are called **parentheses**. They are used to call a function, define an
    expression or condition, and cast between types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{}` are called **braces** (aka curly brackets). They are used to define blocks
    and perform object and collection initialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[]` are called **brackets** (aka square brackets). They are used to access
    items in an array or collection, and around attributes decorating elements of
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<>` are called **angle brackets**. They are used for generic types, in XML
    and HTML files, and individually as *less than* or *greater than* tokens in an
    expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other contextual keywords that only have a special meaning in a specific
    context, like `and`, `or`, `not`, `record`, and `init`.
  prefs: []
  type: TYPE_NORMAL
- en: However, that still means that there are only about 100 actual C# keywords in
    the language.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: C# keywords use all lowercase. Although you can use all
    lowercase for your own type names, you should not. With C# 11 and later, the compiler
    will give a warning if you do, as shown in the following output: `Warning CS8981
    The type name ''person'' only contains lower-cased ascii characters. Such names
    may become reserved for the language.`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use a C# keyword to name a variable, then you can do so by prefixing
    it with the `@` symbol, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: Although you can use C# keywords for variable names, you
    should avoid doing this because it is poor practice. For multiple C# versions,
    Microsoft has wanted to add a new keyword, `field`, to the language, but they
    are reluctant to do so because some developers are likely to have variables named
    `field` and this would cause a breaking change to those projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing programming languages to human languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The English language has more than 250,000 distinct words, so how does C# get
    away with only having about 100 keywords? Moreover, why is C# so difficult to
    learn if it has only 0.0416% of the number of words in the English language?
  prefs: []
  type: TYPE_NORMAL
- en: One of the key differences between a human language and a programming language
    is that developers need to be able to define the new “words” with new meanings.
    Apart from the (approximately) 100 keywords in the C# language, this book will
    teach you about some of the hundreds of thousands of “words” that other developers
    have defined, but you will also learn how to define your own “words.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmers all over the world must learn English because most programming
    languages use English words such as “if” and “break.” There are programming languages
    that use other human languages, such as Arabic, but they are rare. If you are
    interested in learning more, this YouTube video shows a demonstration of an Arabic
    programming language: [https://www.youtube.com/watch?v=EwYIZBL4sAU](https://www.youtube.com/watch?v=EwYIZBL4sAU).'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the color scheme for C# syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, Visual Studio and VS Code show C# keywords in blue to make them
    easier to differentiate from other code, which defaults to black. Both tools allow
    you to customize the color scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **Tools** | **Options**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Options** dialog box, in the **Environment** section, select **Fonts
    and Colors**, and then select the display items that you would like to customize.
    You can also search for the section instead of browsing for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **File** | **Preferences** | **Theme** | **Color Theme**. It is
    in the **Code** menu on macOS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a color theme. For reference, I’ll use the **Light+ (default light)**
    color theme so that the screenshots look better in a printed book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Rider, navigate to **File** | **Settings** | **Editor** | **Color Scheme**.
  prefs: []
  type: TYPE_NORMAL
- en: Help for writing correct code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Plain text editors such as Notepad don’t help you write correct English. Likewise,
    Notepad won’t help you write the correct C# either.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Word can help you write English by highlighting spelling mistakes
    with red squiggles, with Word saying that “icecream” should be ice-cream or ice
    cream, and grammatical errors with blue squiggles, such as a sentence should have
    an uppercase first letter.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, Visual Studio and VS Code’s C# extension helps you write C# code
    by highlighting spelling mistakes, such as the method name needing to be `WriteLine`
    with an uppercase `L`, and grammatical errors, such as statements that must end
    with a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: The C# extension constantly watches what you type and gives you feedback by
    highlighting problems with colored squiggly lines, like that of Microsoft Word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: In `Program.cs`, change the `L` in the `WriteLine` method to lowercase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the semicolon at the end of the statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In VS Code, navigate to **View** | **Problems**; in Visual Studio, navigate
    to **View** | **Error List**; or in Rider, navigate to **View** | **Tool Windows**
    | **Problems**, and note that a red squiggle appears under the code mistakes and
    details are shown, as you can see in *Figure 2.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: The Error List window showing two compile errors'
  prefs: []
  type: TYPE_NORMAL
- en: Fix the two coding errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Importing namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`System` is a namespace, which is like an address for a type. To refer to someone’s
    location exactly, you might use `Oxford.HighStreet.BobSmith`, which tells us to
    look for a person named Bob Smith on the High Street in the city of Oxford.'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Console.WriteLine` tells the compiler to look for a method named `WriteLine`
    in a type named `Console` in a namespace named `System`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify our code, the **Console App** project template for every version
    of .NET before 6.0 added a statement at the top of the code file to tell the compiler
    to always look in the `System` namespace for types that haven’t been prefixed
    with their namespace, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We call this *importing the namespace*. The effect of importing a namespace
    is that all available types in that namespace will be available to your program
    without needing to enter the namespace prefix. All available types in that namespace
    will be seen in IntelliSense while you write code.
  prefs: []
  type: TYPE_NORMAL
- en: Implicitly and globally importing namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Traditionally, every `.cs` file that needs to import namespaces would have
    to start with `using` statements to import those namespaces. Namespaces like `System`
    and `System.Linq` are needed in almost all `.cs` files, so the first few lines
    of every `.cs` file often had at least a few `using` statements, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When creating websites and services using ASP.NET Core, there are often dozens
    of namespaces that each file would have to import.
  prefs: []
  type: TYPE_NORMAL
- en: C# 10 introduced a new keyword combination and .NET SDK 6 introduced a new project
    setting that work together to simplify importing common namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `global using` keyword combination means you only need to import a namespace
    in one `.cs` file and it will be available throughout all `.cs` files instead
    of having to import the namespace at the top of every file that needs it. You
    could put `global using` statements in the `Program.cs` file, but I recommend
    creating a separate file for those statements named something like `GlobalUsings.cs`
    with the contents being all your `global using` statements, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: As developers get used to this new C# feature, I expect
    one naming convention for this file to become the de facto standard. As you are
    about to see, the related .NET SDK feature uses a similar naming convention.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any projects that target .NET 6 or later, and therefore use the C# 10 or later
    compiler, generate a `<ProjectName>.GlobalUsings.g.cs` file in the `obj\Debug\net9.0`
    folder to implicitly globally import some common namespaces like `System`. The
    specific list of implicitly imported namespaces depends on which SDK you target,
    as shown in *Table 2.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SDK** | **Implicitly imported namespaces** |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.NET.Sdk` | `System``System.Collections.Generic``System.IO``System.Linq``System.Net.Http``System.Threading``System.Threading.Tasks`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.NET.Sdk.Web` | Same as `Microsoft.NET.Sdk`, plus:`System.Net.Http.Json``Microsoft.AspNetCore.Builder``Microsoft.AspNetCore.Hosting``Microsoft.AspNetCore.Http``Microsoft.AspNetCore.Routing``Microsoft.Extensions.Configuration``Microsoft.Extensions.DependencyInjection``Microsoft.Extensions.Hosting``Microsoft.Extensions.Logging`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.NET.Sdk.Worker` | Same as `Microsoft.NET.Sdk`, plus:`Microsoft.Extensions.Configuration``Microsoft.Extensions.DependencyInjection``Microsoft.Extensions.Hosting``Microsoft.Extensions.Logging`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.5: .NET SDKs and their implicitly imported namespaces'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see the current autogenerated implicit imports file:'
  prefs: []
  type: TYPE_NORMAL
- en: In **Solution Explorer**, toggle on the **Show All Files** button, and note
    the compiler-generated `bin` and `obj` folders are now visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Vocabulary` project, expand the `obj` folder, expand the `Debug` folder,
    expand the `net9.0` folder, and then open the file named `Vocabulary.GlobalUsings.g.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The naming convention for this file is `<ProjectName>.GlobalUsings.g.cs`. Note
    the **g** for **generated** to differentiate it from developer-written code files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that this file is automatically created by the compiler for projects
    that target .NET 6 and later and that it imports some commonly used namespaces,
    including `System.Threading`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Close the `Vocabulary.GlobalUsings.g.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In **Solution Explorer**, open the `Vocabulary.csproj` project file, and then
    add additional entries to the project file to control which namespaces are implicitly
    imported, as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `<ItemGroup>` is different from `<ImportGroup>`. Be sure to use the
    correct one! Also, note that the order of elements in a project group or item
    group does not matter. For example, `<Nullable>` can be before or after `<ImplicitUsings>`.
  prefs: []
  type: TYPE_NORMAL
- en: Save the changes to the project file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the `obj` folder, expand the `Debug` folder, expand the `net9.0` folder,
    and open the file named `Vocabulary.GlobalUsings.g.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that this file now imports `System.Numerics` instead of `System.Threading`,
    the `Environment` class has been imported and aliased to `Env`, and we have statically
    imported the `Console` class, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add a statement to output a message from the computer and
    note that because we statically imported the `Console` class, we can call its
    methods like `WriteLine` without prefixing them with `Console`, and we can reference
    the `Environment` class using its alias, `Env`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the project and note the message, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your computer name will be different unless you name your computers after characters
    from Doctor Who like I do.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can disable the implicitly imported namespaces feature for all SDKs by
    removing the `<ImplicitUsings>` element completely from the project file, or changing
    its value to `disable`, as shown in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: You might choose to do this if you want to manually create
    a single file with all the `global using` statements instead of potentially having
    one generated automatically and others created manually. But my recommendation
    is to leave the feature enabled and modify the project file to change what is
    included in the auto-generated class file in the `obj` folder hierarchy.'
  prefs: []
  type: TYPE_NORMAL
- en: Verbs are methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In English, verbs are doing or action words, like “run” and “jump.” In C#, doing
    or action words are called **methods**. There are hundreds of thousands of methods
    available to C#. In English, verbs change how they are written based on when in
    time the action happens. For example, Amir *was jumping* in the past, Beth *jumps*
    in the present, they *jumped* in the past, and Charlie *will jump* in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C#, methods such as `WriteLine` change how they are called or executed based
    on the specifics of the action. This is called overloading, which we’ll cover
    in more detail in *Chapter 5*, *Building Your Own Types with Object-Oriented Programming*.
    But for now, consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When I show code snippets without numbered step-by-step instructions, I do not
    expect you to enter them as code, so they won’t execute out of context.
  prefs: []
  type: TYPE_NORMAL
- en: A different and not quite exact analogy is that some verbs are spelled the same
    but have different meanings depending on the context, for example, you can lose
    a game, lose your place in a book, or lose your keys.
  prefs: []
  type: TYPE_NORMAL
- en: Nouns are types, variables, fields, and properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In English, nouns are names that refer to things. For example, Fido is the name
    of a dog. The word “dog” tells us the type of thing that Fido is, and so to order
    Fido to fetch a ball, we would use his name.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C#, their equivalents are **types**, **variables**, **fields**, and **properties**.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Animal` and `Car` are types; they are nouns for categorizing things.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Head` and `Engine` might be fields or properties; they are nouns that belong
    to `Animal` and `Car`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fido` and `Bob` are variables; they are nouns for referring to a specific
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are tens of thousands of types available to C#, though have you noticed
    how I didn’t say, “There are tens of thousands of types *in* C#”? The difference
    is subtle but important. The language of C# only has a few keywords for types,
    such as `string` and `int`, and strictly speaking, C# doesn’t define any types.
    Keywords such as `string` that look like types are **aliases**, which represent
    types provided by the platform on which C# runs.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to know that C# cannot exist alone; after all, it’s a language
    that runs on variants of .NET. In theory, someone could write a compiler for C#
    that uses a different platform, with different underlying types. In practice,
    the platform for C# is .NET, which provides tens of thousands of types to C#,
    including `System.Int32`, which is the C# keyword alias that `int` maps to, as
    well as many more complex types, such as `System.Xml.Linq.XDocument`.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth taking note that the term **type** is often confused with **class**.
    Have you ever played the parlor game *Twenty Questions*, also known as *Animal,
    Vegetable, or Mineral*? In the game, everything can be categorized as an animal,
    vegetable, or mineral. In C#, every **type** can be categorized as a `class`,
    `struct`, `enum`, `interface`, or `delegate`. You will learn what these mean in
    *Chapter 6*, *Implementing Interfaces and Inheriting Classes*. As an example,
    the C# keyword `string` is a `class`, but `int` is a `struct`. So, it is best
    to use the term **type** to refer to both.
  prefs: []
  type: TYPE_NORMAL
- en: Revealing the extent of the C# vocabulary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know that there are more than 100 keywords in C#, but how many types are
    there? Let’s write some code to find out how many types (and their methods) are
    available to C# in our simple console app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t worry about exactly how this code works for now, but know that it uses
    a technique called **reflection**:'
  prefs: []
  type: TYPE_NORMAL
- en: Comment out all the existing statements in `Program.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ll start by importing the `System.Reflection` namespace at the top of the
    `Program.cs` file so that we can use some of the types in that namespace like
    `Assembly` and `TypeName`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: We could use the implicit imports and `global using` features
    to import this namespace for all `.cs` files in this project, but since there
    is only one file, it is better to import the namespace in the one file in which
    it is needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write statements to get the compiled console app and loop through all the types
    that it has access to, outputting the names and number of methods each has, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`N0` is uppercase `N` followed by the digit zero. It is not uppercase `N` followed
    by uppercase `O`. It means “format a number (`N`) with zero (`0`) decimal places.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the project. You will see the actual number of types and methods that are
    available to you in the simplest application when running on your **operating
    system** (**OS**). The number of types and methods displayed will be different
    depending on the OS that you are using, as shown in the following output on Windows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Why does the `System.Runtime` assembly contain zero types? This assembly is
    special because it contains only **type-forwarders** rather than actual types.
    A type-forwarder represents a type that has been implemented outside of .NET or
    for some other advanced reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to the top of the file (after importing the `System.Reflection`
    namespace) to declare some variables, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app again and view the results, which should look like the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you have a better sense of why learning C# is a challenge – because there
    are so many types and methods to learn. Methods are only one category of a member
    that a type can have, and you and other programmers are constantly defining new
    types and members!
  prefs: []
  type: TYPE_NORMAL
- en: Example of asking ChatGPT to explain code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code we wrote in the `Vocabulary` project is a good example of when you
    might want to ask ChatGPT to explain something. If you enter a prompt of “Explain
    the following code:” followed by the code, here’s what it responded with:'
  prefs: []
  type: TYPE_NORMAL
- en: “This C# code performs an analysis of the assemblies (essentially libraries
    or modules) referenced by the current application. It tallies up the total number
    of types and methods in each referenced assembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down the code in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Reflection` namespace is used to work with assemblies, modules, types,
    methods, and so on, at runtime.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `System.Data.DataSet` and `HttpClient` instances are declared but not used.
    The comment implies that these are declared to ensure their respective assemblies
    are loaded for the subsequent analysis. Creating instances of classes from certain
    assemblies can cause those assemblies to be loaded into memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Assembly.GetEntryAssembly()` gets the assembly that is the entry point of
    the application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `myApp` is null (meaning there’s no entry assembly, which should be impossible
    in a normally running .NET app), the application exits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `foreach` loop iterates over each assembly name in the referenced assemblies
    of the entry point assembly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Assembly.Load(name)` loads an assembly given the assembly name. This allows
    you to interact with the assembly programmatically.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A counter variable, `methodCount`, is declared and initialized to `0`. This
    is used to count the total number of methods in the assembly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another nested `foreach` loop then iterates over each type in the assembly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each type, it gets the number of methods `(t.GetMethods().Length)` and adds
    it to the `methodCount`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the number of types and their methods in the assembly are output to
    the console using `WriteLine()`. The `{0:N0}` format specifier in the string is
    a placeholder for a number (`0` refers to the argument index, `N` is for number
    format, and 0 after N specifies the number of decimal places).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, in essence, this script counts how many types and methods exist in each
    assembly referenced by the application. This might be useful to understand the
    complexity or size of the dependencies the application has.”
  prefs: []
  type: TYPE_NORMAL
- en: And now back to the flesh and blood, Mark. That’s a pretty good explanation
    with no mistakes or hallucinations!
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Tools like GitHub Copilot and ChatGPT are especially useful
    for programmers when they are learning new things. And a good programmer is always
    learning new things! These tools are not just for writing code for you. They can
    explain existing code written by others and even suggest improvements.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All applications process data. Data comes in, data is processed, and then data
    goes out.
  prefs: []
  type: TYPE_NORMAL
- en: Data usually comes into our program from files, databases, or user input, and
    it can be put temporarily into variables, which will be stored in the memory of
    the running program. When the program ends, the data in memory is lost. Data is
    usually output to files and databases, or to the screen or a printer. When using
    variables, you should think about, firstly, how much space the variable takes
    up in the memory, and, secondly, how fast it can be processed.
  prefs: []
  type: TYPE_NORMAL
- en: We control this by picking an appropriate type. You can think of simple common
    types such as `int` and `double` as being different-sized storage boxes, where
    a smaller box would take less memory but may not be as fast at being processed;
    for example, adding 16-bit numbers might not be processed as quickly as adding
    64-bit numbers on a 64-bit operating system. Some of these boxes may be stacked
    close by, and some may be thrown into a big heap further away.
  prefs: []
  type: TYPE_NORMAL
- en: Naming things and assigning values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are naming conventions for things, and it is a good practice to follow
    them, as shown in *Table 2.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Naming convention** | **Examples** | **Used for** |'
  prefs: []
  type: TYPE_TB
- en: '| Camel case | `cost`, `orderDetail`, and `dateOfBirth` | Local variables and
    private fields |'
  prefs: []
  type: TYPE_TB
- en: '| Title case, aka Pascal case | `String`, `Int32`, `Cost`, `DateOfBirth`, and
    `Run` | Types, non-private fields, and other members like methods |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.6: Naming conventions and what they should be used for'
  prefs: []
  type: TYPE_NORMAL
- en: Some C# programmers like to prefix the names of private fields with an underscore,
    for example, `_dateOfBirth` instead of `dateOfBirth`. The naming of private members
    of all kinds is not formally defined because they will not be visible outside
    the class, so writing them either with or without an underscore prefix is valid.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Following a consistent set of naming conventions will enable
    your code to be easily understood by other developers (and yourself in the future!).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block shows an example of declaring a named local variable
    and assigning a value to it with the `=` symbol. You should note that you can
    output the name of a variable using a keyword introduced in C# 6, `nameof`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Warning!** The message in double quotes in the preceding code wraps onto
    a second line because the width of a printed page is too narrow. When entering
    a statement like this in your code editor, type it all in a single line.'
  prefs: []
  type: TYPE_NORMAL
- en: In C# 12 and later, `nameof` can now access instance data from a static context.
    You will learn the difference between instance and static data in *Chapter 5*,
    *Building Your Own Types with Object-Oriented Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Literal values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you assign to a variable, you often, but not always, assign a **literal**
    value. But what is a literal value? A literal is a notation that represents a
    fixed value. Data types have different notations for their literal values, and
    over the next few sections, you will see examples of using literal notation to
    assign values to variables.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: You can read the formal definition of literals in the
    C# language specification: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#645-literals](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#645-literals).'
  prefs: []
  type: TYPE_NORMAL
- en: Storing text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For text, a single letter, such as an `A`, is stored as a `char` type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Actually, it can be more complicated than that. Egyptian
    Hieroglyph A002 (U+13001) needs two `System.Char` values (known as surrogate pairs)
    to represent it: `\uD80C` and `\uDC01`. Do not always assume one `char` equals
    one letter or you could introduce hard-to-notice bugs into your code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `char` is assigned using single quotes around the literal value, or assigning
    the return value of a function call, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'For text, multiple letters, such as `Bob`, are stored as a `string` type and
    are assigned using double quotes around the literal value, or by assigning the
    return value of a function call or constructor, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Outputting emojis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To output emojis at a command prompt on Windows, you must use Windows Terminal
    because Command Prompt does not support emojis, and set the output encoding of
    the console to use UTF-8, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Verbatim strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An escape character is a special character in programming and text processing
    that is used to introduce an **escape sequence**. Escape sequences allow the representation
    of characters that are difficult or impossible to include directly in a string.
    These sequences often start with a backslash, `\`, followed by one or more characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'When storing text in a `string` variable, you can include escape sequences,
    which represent special characters like tabs and newlines using a backslash, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: But what if you are storing the path to a file on Windows, and one of the folder
    names starts with a `T`, as shown in the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will convert the `\t` into a tab character and you will get errors!
  prefs: []
  type: TYPE_NORMAL
- en: 'You must prefix it with the `@` symbol to use a verbatim literal `string`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'With C# 13 and later, you can represent the ESC character (Unicode U+001B)
    using the character literal escape sequence `\e`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the past, you might have used `\u001b` or `\x1b`. However, using `\x1b` was
    not recommended because any valid hexadecimal digits following `1b` would be incorrectly
    interpreted as part of the escape sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Raw string literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Introduced in C# 11, raw string literals are convenient for entering any arbitrary
    text without needing to escape the contents. They make it easy to define literals
    containing other languages like XML, HTML, or JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raw string literals start and end with three or more double-quote characters,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Why three *or more* double-quote characters? This is for scenarios where the
    content itself needs to have three double-quote characters; you can then use four
    double-quote characters to indicate the beginning and end of the content. Where
    the content needs to have four double-quote characters, you can then use five
    double-quote characters to indicate the beginning and end of the content. And
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous code, the XML is indented by 13 spaces. The compiler looks
    at the indentation of the last three or more double-quote characters, and then
    automatically removes that level of indentation from all the content inside the
    raw string literal. The results of the previous code would therefore not be indented
    as in the defining code but, instead, will be aligned with the left margin, as
    shown in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If the end three double-quote characters are aligned with the left margin,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'then the 13-space indentation would not be removed, as shown in the following
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Raw interpolated string literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can mix interpolated strings that use curly braces `{` `}` with raw string
    literals. You specify the number of braces that indicate a replaced expression
    by adding that number of dollar signs to the start of the literal. Any fewer braces
    than that are treated as raw content.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to define some JSON, single braces will be treated
    as normal braces, but the two dollar symbols tell the compiler that any two curly
    braces indicate a replaced expression value, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code would generate the following JSON document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The number of dollar symbols tells the compiler how many curly braces are needed
    to become recognized as an interpolated expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the braces `{}` around the `3`. This is intentional. In this example,
    the JSON document must generate a calculation that contains braces. To show this,
    the code uses three braces: the first open brace will output as a literal character.
    The next two braces will be interpreted as the beginning of an expression. The
    first two close braces will be interpreted as the end of an expression. The last
    close brace will be a literal character.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the code only used two braces, then those are treated as a delimiter for
    the expression `1 + 2` and do not appear in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Summarizing options for storing text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To summarize:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Literal string**: Characters enclosed in double-quote characters. They can
    use escape characters like `\t` for tab. To represent a backslash, use two: `\\`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Raw string literal**: Characters enclosed in three or more double-quote characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Verbatim string**: A literal string prefixed with `@` to disable escape characters
    so that a backslash is a backslash. It also allows the `string` value to span
    multiple lines because the whitespace characters are treated as themselves instead
    of instructions to the compiler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interpolated string**: A literal string prefixed with `$` to enable embedded
    formatted variables. You will learn more about this later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numbers are data that we want to perform an arithmetic calculation on, for example,
    multiplying. A telephone number is not a quantifiable number. To decide whether
    a variable should be stored as a number or not, ask yourself whether you need
    to perform arithmetic operations on the number or whether the number includes
    non-digit characters such as parentheses or hyphens to format the number, such
    as (414) 555-1234\. In this case, the “number” is a sequence of characters, so
    it should be stored as a `string`.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers can be natural numbers, such as 42, used for counting (also called whole
    numbers); they can also be negative numbers, such as -42 (called integers); or
    they can be real numbers, such as 3.9 (with a fractional part), which are called
    single- or double-precision floating-point numbers in computing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to add a new **Console App** / `console` project
    named `Numbers` to the `Chapter02` solution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Visual Studio, configure the startup project to the current selection.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing code, and then type statements to declare
    some number variables using various data types, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Storing whole numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might know that computers store everything as bits. The value of a bit is
    either `0` or `1`. This is called a **binary number system**. Humans use a **decimal
    number system**.
  prefs: []
  type: TYPE_NORMAL
- en: The decimal number system, also known as Base 10, has 10 as its **base**, meaning
    there are 10 digits, from 0 to 9\. Although it is the number base most used by
    human civilizations, other number base systems are popular in science, engineering,
    and computing. The binary number system, also known as Base 2, has 2 as its base,
    meaning there are two digits, 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows how computers store the decimal number 10\. Take
    note of the bits with the value 1 in the 8 and 2 columns: 8 + 2 = 10.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_02_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: How computers store the decimal number 10'
  prefs: []
  type: TYPE_NORMAL
- en: So, `10` in decimal is `00001010` in a binary byte (8 bits).
  prefs: []
  type: TYPE_NORMAL
- en: Improving legibility by using digit separators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two of the improvements seen in C# 7 and later are the use of the underscore
    character `_` as a digit separator and support for binary literals.
  prefs: []
  type: TYPE_NORMAL
- en: You can insert underscores anywhere into the digits of a number literal, including
    decimal, binary, or hexadecimal notation, to improve legibility.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you could write the value for 1 million in decimal notation, that
    is, Base 10, as `1_000_000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even use the 2/3 grouping common in India: `10_00_000`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using binary or hexadecimal notation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use binary notation, that is, Base 2, using only 1s and 0s, start the number
    literal with `0b`. To use hexadecimal notation, that is, Base 16, using 0 to 9
    and A to F, start the number literal with `0x`.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring whole numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s enter some code to see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Numbers` project, in `Program.cs`, type statements to declare some
    number variables using underscore separators, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the project and note the result is that all three numbers are the same,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Computers can always exactly represent integers using the `int` type or one
    of its sibling types, such as `long` and `short`.
  prefs: []
  type: TYPE_NORMAL
- en: Storing real numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Computers cannot always represent real, aka decimal or non-integer, numbers
    precisely. The `float` and `double` types store real numbers using single- and
    double-precision floating points.
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages implement the **Institute of Electrical and Electronics
    Engineers** (**IEEE**) Standard for Floating-Point Arithmetic. IEEE 754 is a technical
    standard for floating-point arithmetic established in 1985 by the IEEE.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows a simplification of how a computer represents the
    number `12.75` in binary notation. Note the bits with the value `1` in the 8,
    4, ½, and ¼ columns:'
  prefs: []
  type: TYPE_NORMAL
- en: 8 + 4 + ½ + ¼ = 12¾ = 12.75
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_02_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Computer representing the number 12.75 in binary notation'
  prefs: []
  type: TYPE_NORMAL
- en: So, `12.75` in decimal notation is `00001100.1100` in binary notation. As you
    can see, the number `12.75` can be exactly represented using bits. However, most
    numbers can’t, which is something that we’ll be exploring shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code to explore number sizes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# has an operator named `sizeof()` that returns the number of bytes that a
    type uses in memory. Some types have members named `MinValue` and `MaxValue`,
    which return the minimum and maximum values that can be stored in a variable of
    that type. We are now going to use these features to create a console app to explore
    number types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, at the bottom of the file, type statements to show the size
    of three number data types, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Warning!** The width of the printed pages in this book makes the `string`
    values (in double quotes) wrap over multiple lines. You must type them on a single
    line, or you will get compile errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the output, as shown in *Figure 2.6*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_02_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Size and range information for common number data types'
  prefs: []
  type: TYPE_NORMAL
- en: An `int` variable uses 4 bytes of memory and can store positive or negative
    numbers up to about 2 billion. A `double` variable uses 8 bytes of memory and
    can store much bigger values! A `decimal` variable uses 16 bytes of memory and
    can store big numbers, but not as big as a `double` type.
  prefs: []
  type: TYPE_NORMAL
- en: But you may be asking yourself, why might a `double` variable be able to store
    bigger numbers than a `decimal` variable, yet it’s only using half the space in
    memory? Well, let’s now find out!
  prefs: []
  type: TYPE_NORMAL
- en: Comparing double and decimal types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will now write some code to compare `double` and `decimal` values. Although
    it isn’t hard to follow, don’t worry about understanding the syntax right now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to declare two `double` variables, add them together, and compare
    them to the expected result. Then, write the result to the console, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In cultures that use a comma for the decimal separator, the result will look
    slightly different, as shown in the following output: `0,1 + 0,2 does NOT equal
    0,3`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `double` type is not guaranteed to be accurate because most numbers like
    `0.1`, `0.2`, and `0.3` literally cannot be exactly represented as floating-point
    values.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to try different values, like `0.1 + 0.3 == 0.4`, it would happen
    to return `true` because, with `double` values, some imprecise values happen to
    be exactly equal in their current representation even though they might not actually
    be equal mathematically. So, some numbers can be directly compared but some cannot.
    I deliberately picked `0.1` and `0.2` to compare to `0.3` because they cannot
    be compared, as proven by the result.
  prefs: []
  type: TYPE_NORMAL
- en: You could compare real numbers stored in the `float` type, which is less accurate
    than the `double` type, but the comparison would actually appear to be `true`
    because of that lower accuracy!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As a rule of thumb, you should only use `double` when accuracy, especially when
    comparing the equality of two numbers, is not important. An example of this might
    be when you’re measuring a person’s height; you will only compare values using
    greater than or less than, but never equals.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with the preceding code is illustrated by how the computer stores
    the number `0.1`, or multiples of it. To represent `0.1` in binary notation, the
    computer stores 1 in the 1/16 column, 1 in the 1/32 column, 1 in the 1/256 column,
    1 in the 1/512 column, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The number `0.1` in decimal notation is `0.00011001100110011`… in binary notation,
    repeating forever, as shown in *Figure 2.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_02_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Number 0.1 in decimal notation repeating forever in binary notation'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Never compare `double` values using `==`. During the Gulf
    War of 1990-1991, an American Patriot missile battery used `double` values in
    its calculations. The inaccuracy caused it to fail to track and intercept an incoming
    Iraqi Scud missile, and 28 soldiers were killed; you can read about this at [https://www.ima.umn.edu/~arnold/disasters/patriot.html](https://www.ima.umn.edu/~arnold/disasters/patriot.html).
    The Patriot missile system has improved since then. *“Forty years after it was
    brought into service, the Patriot air-defense system is finally doing what it
    was designed for.” “No one was 100% sure that the Patriot was capable of destroying
    a Kh-47 hypersonic missile,” said Col. Serhiy Yaremenko, commander of the 96th
    Anti-Aircraft Missile Brigade, which defends Kyiv. “Ukrainians proved it.”*: [https://archive.ph/2023.06.11-132200/https://www.wsj.com/amp/articles/u-s-patriot-missile-is-an-unsung-hero-of-ukraine-war-db6053a0](https://archive.ph/2023.06.11-132200/https://www.wsj.com/amp/articles/u-s-patriot-missile-is-an-unsung-hero-of-ukraine-war-db6053a0).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see the same code using the `decimal` number type:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy and paste the statements that you wrote before (which used the `double`
    variables).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the statements to use `decimal` and rename the variables to `c` and
    `d`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `decimal` type is accurate because it stores the number as a large integer
    and shifts the decimal point. For example, `0.1` is stored as `1`, with a note
    to shift the decimal point one place to the left. `12.75` is stored as `1275`,
    with a note to shift the decimal point two places to the left.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Use `int` for whole numbers. Use `double` for real numbers
    that will not be compared for equality to other values; it is okay to compare
    `double` values being less than or greater than, and so on. Use `decimal` for
    money, CAD drawings, general engineering, and wherever the accuracy of a real
    number is important.'
  prefs: []
  type: TYPE_NORMAL
- en: Special real number values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `float` and `double` types have some useful special values: `NaN` represents
    not-a-number (for example, the result of dividing zero by zero), `Epsilon` represents
    the smallest positive number that can be stored in a `float` or `double`, and
    `PositiveInfinity` and `NegativeInfinity` represent infinitely large positive
    and negative values. They also have methods for checking for these special values
    like `IsInfinity` and `IsNaN`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write some code statements to see what some of these special values look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to output some special `double` values, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NaN` outputs as `NaN`. (`NaN` means “not a number”.) It can be generated from
    an expression of zero divided by zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PositiveInfinity` value outputs as an `8`, which looks like an infinity
    symbol on its side. It can be generated from an expression of any positive real
    number divided by zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `NegativeInfinity` value outputs as `-8`, which looks like an infinity symbol
    on its side with a negative sign before it. It can be generated from an expression
    of any negative real number divided by zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero divided by any positive real number is zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero divided by any negative real number is negative zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Epsilon` is slightly less than `5E-324` represented using scientific notation:
    [https://en.wikipedia.org/wiki/Scientific_notation](https://en.wikipedia.org/wiki/Scientific_notation).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New number types and unsafe code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `System.Half` type was introduced in .NET 5\. Like `float` and `double`,
    it can store real numbers. It normally uses two bytes of memory. The `System.Int128`
    and `System.UInt128` types were introduced in .NET 7\. Like `int` and `uint`,
    they can store signed (positive and negative) and unsigned (only zero and positive)
    integer values. They normally use 16 bytes of memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'For these new number types, the `sizeof` operator only works in an unsafe code
    block, and you must compile the project using an option to enable unsafe code.
    Let’s explore how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, at the bottom of the file, type statements to show the size
    of the `Half` and `Int128` number data types, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Numbers.csproj`, add an element to enable unsafe code, as shown highlighted
    in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `Numbers` project and note the sizes of the two new number types, as
    shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**More Information**: The `sizeof` operator requires an unsafe code block,
    except for the commonly used types like `int` and `byte`. You can learn more about
    `sizeof` at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/sizeof](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/sizeof).
    Unsafe code cannot have its safety verified. You can learn more about unsafe code
    blocks at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/unsafe-code](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/unsafe-code).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Storing Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Booleans can only contain one of the two literal values `true` or `false`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: They are most used to branch and loop. You don’t need to fully understand them
    yet, as they are covered more in *Chapter 3*, *Controlling Flow, Converting Types,
    and Handling Exceptions*.
  prefs: []
  type: TYPE_NORMAL
- en: Storing any type of object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a special type named `object` that can store any type of data, but
    its flexibility comes at the cost of messier code and possibly poor performance.
    For those two reasons, you should avoid it whenever possible. The following steps
    show you how to use object types if you need to use them because you must use
    a Microsoft or third-party library that uses them:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `Variables` to the `Chapter02` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements and then type statements to
    declare and use some variables using the `object` type, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note that the fourth statement cannot compile because the
    data type of the `name` variable is not known by the compiler, as shown in *Figure
    2.8*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_02_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: The object type does not have a Length property'
  prefs: []
  type: TYPE_NORMAL
- en: Add double slashes to the beginning of the statement that cannot compile to
    comment out the statement, making it inactive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code again and note that the compiler can access the `length` of a
    `string` if the programmer explicitly tells the compiler that the `object` variable
    contains a `string` by prefixing the `name` variable with a cast expression like
    `(string)name`. The results can then successfully be written to the console, as
    shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will learn about cast expressions in *Chapter 3*, *Controlling Flow, Converting
    Types, and Handling Exceptions*.
  prefs: []
  type: TYPE_NORMAL
- en: The `object` type has been available since the first version of C#, but C# 2
    and later have a better alternative called **generics**, which we will cover in
    *Chapter 6*, *Implementing Interfaces and Inheriting Classes*. This will provide
    us with the flexibility we want but without the performance overhead.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Avoid declaring variables as a `System.Object`, aka `object`
    type. There are usually better alternatives that you can use instead, like generics.'
  prefs: []
  type: TYPE_NORMAL
- en: Storing dynamic types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is another special type named `dynamic` that can also store any type
    of data, but even more than `object`, its flexibility comes at the cost of performance.
    The `dynamic` keyword was introduced in C# 4\. However, unlike `object`, the value
    stored in the variable can have its members invoked without an explicit cast.
    Let’s make use of a `dynamic` type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to declare a `dynamic` variable. Assign a `string` literal value,
    and then an integer value, and then an array of integer values. Finally, add a
    statement to output the length of the `dynamic` variable, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will learn about arrays in *Chapter 3*, *Controlling Flow, Converting Types,
    and Handling Exceptions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note that it works because the last value assigned to something
    was a `string` value that does have a `Length` property, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Comment out the statement that assigns a `string` value to the `something` variable
    by prefixing the statement with two slashes, `//`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and note the runtime error because the last value assigned to
    `something` is an `int` that does not have a `Length` property, as shown in the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Comment out the statement that assigns an `int` to the `something` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and note the output because an array of three `int` values does
    have a `Length` property, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: One limitation of `dynamic` is that code editors cannot show IntelliSense to
    help you write the code. This is because the compiler cannot check what the type
    is during build time. Instead, the **CLR (Common Language Runtime)** checks for
    the member at runtime and throws an exception if it is missing.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions are a way to indicate that something has gone wrong at runtime. You
    will learn more about them and how to handle them in *Chapter 3*, *Controlling
    Flow, Converting Types, and Handling Exceptions*.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic types are most useful when interoperating with non-.NET systems. For
    example, you might need to work with a class library written in F#, Python, or
    some JavaScript. You might also need to interop with technologies like the **Component
    Object Model** (**COM**), for example, when automating Excel or Word.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring local variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Local variables are declared inside methods, and they only exist during the
    execution of that method. Once the method returns, the memory allocated to any
    local variables is released.
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, value types are released while reference types must wait
    for garbage collection. You will learn about the difference between value types
    and reference types and how to make sure that only one garbage collection is needed
    rather than two when releasing unmanaged resources in *Chapter 6*, *Implementing
    Interfaces and Inheriting Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the type of a local variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s explore local variables declared with specific types and using type inference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to declare and assign values to some local variables using
    specific types, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Depending on your code editor and color scheme, it will show green squiggles
    under each of the variable names and lighten their text color to warn you that
    the variable is assigned but its value is never used.
  prefs: []
  type: TYPE_NORMAL
- en: Inferring the type of a local variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the `var` keyword to declare local variables with C# 3 and later.
    The compiler will infer the type from the value that you assign after the assignment
    operator, `=`. This happens at compile time so using `var` has no effect on runtime
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'A literal number without a decimal point is inferred as an `int` variable,
    that is, unless you add a suffix, as described in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`L`: Compiler infers `long`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UL`: Compiler infers `ulong`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M`: Compiler infers `decimal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`D`: Compiler infers `double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F`: Compiler infers `float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A literal number with a decimal point is inferred as `double` unless you add
    the `M` suffix (in which case the compiler infers a `decimal` variable), or the
    `F` suffix, in which case it infers a `float` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Double quotes indicate a `string` variable, single quotes indicate a `char`
    variable, and the `true` and `false` values infer a `bool` type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the previous statements to use `var`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hover your mouse over each of the `var` keywords and note that your code editor
    shows a tooltip with information about the type that has been inferred.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, import the namespace for working with XML to enable
    us to declare some variables using types in that namespace, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom of `Program.cs`, add statements to create some new objects, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Although using `var` is convenient, some developers avoid
    using it to make it easier for a code reader to understand the types in use. Personally,
    I use it only when the type is obvious. For example, in the preceding code statements,
    the first statement is just as clear as the second in stating what the types of
    the `xml` variables are, but it is shorter. However, the third statement isn’t
    clear in showing the type of the `file` variable, so the fourth is better because
    it shows that the type is `StreamWriter`. If in doubt, spell it out!'
  prefs: []
  type: TYPE_NORMAL
- en: Note that `var` is converted to the actual type by the compiler when you build
    a project. A variable declared using `var` has a specific, known, fixed data type.
    This is different from `dynamic`, which the compiler does not change. It remains
    a `System.Dynamic` type that can reference any object of any data type. The actual
    type is only checked at runtime, so that’s when an exception might be thrown if
    you access a member on it that does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a Visual Studio refactoring feature to automatically convert uses
    of `var` into the specific type, as documented at the following link: [https://learn.microsoft.com/en-us/visualstudio/ide/reference/convert-var-to-explicit-type](https://learn.microsoft.com/en-us/visualstudio/ide/reference/convert-var-to-explicit-type).'
  prefs: []
  type: TYPE_NORMAL
- en: What does new do?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There have been a few examples of using the C# `new` keyword before this section,
    but so far, I haven’t explicitly explained what it does. The C# `new` keyword
    is used to allocate and/or initialize memory. To understand when you need to use
    `new`, you need to know a bit more about types.
  prefs: []
  type: TYPE_NORMAL
- en: Value and reference types and their relationship to memory are explained in
    more detail in *Chapter 6, Implementing Interfaces and Inheriting Classes*, so
    I will only introduce the minimum explanation for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two categories of types: **value types** and **reference types**.'
  prefs: []
  type: TYPE_NORMAL
- en: Value types are simple and do not need to use the `new` keyword to explicitly
    allocate memory. But value types can use the `new` keyword to initialize their
    value. This is useful when there is no way to use a literal to set the value.
  prefs: []
  type: TYPE_NORMAL
- en: Reference types are more complex and need to use the `new` keyword to explicitly
    allocate memory. At the same time, they can use the `new` keyword to initialize
    their state.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when you declare variables, space is only allocated in memory for
    value types like `int` and `DateTime` but not for reference types like `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code that declares some local variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the following about the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`age` has a value of `0` and 2 bytes of memory have been allocated in stack
    memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`population` has a value of `0` and 8 bytes of memory have been allocated in
    stack memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`birthdate` has a value of `0001-01-01` and 8 bytes of memory have been allocated
    in stack memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`location` has a value of `0, 0` and 8 bytes of memory have been allocated
    in stack memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bob` has a value of `null` and 4 bytes of memory have been allocated in stack
    memory. No heap memory has been allocated for the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let’s see when we might choose to use `new`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the following about the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`age`, `population`, `birthdate`, and `location` have already had memory allocated
    for them on the stack. We only need to use `new` to initialize their values if
    we want them to be different from their defaults.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bob` must use `new` to allocate heap memory for the object. The `=` assignment
    stores the memory address of that allocated memory on the stack. Reference types
    like `Person` often have multiple constructors that are called by `new`. A default
    constructor assigns default values to any state in the object. A constructor with
    arguments can assign other values to any state in the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors are covered in more detail in *Chapter 5, Building Your Own Types
    with Object-Oriented Programming*, so I have only introduced the minimum explanation
    for now.
  prefs: []
  type: TYPE_NORMAL
- en: Using target-typed new to instantiate objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With C# 9, Microsoft introduced another syntax for instantiating objects, known
    as **target-typed new**. When instantiating an object, you can specify the type
    first and then use `new` without repeating the type, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a type with a field or property that needs to be set, then the
    type can be inferred, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This way of instantiating objects is especially useful with arrays and collections
    because they have multiple objects, often of the same type, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: You will learn about arrays in *Chapter 3*, *Controlling Flow, Converting Types,
    and Handling Exceptions*, and collections in *Chapter 8*,*Working with Common
    .NET Types*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Use target-typed new to instantiate objects because it requires
    fewer characters; when reading a statement from left to right, as in English,
    you immediately know the type of the variable, and it is not limited to local
    variables like `var` is, in my opinion, the only reason not to use target-typed
    new is if you must use a pre-version 9 C# compiler. I do acknowledge that my opinion
    is not accepted by the whole C# community. I have used target-typed new throughout
    the remainder of this book. Please let me know if you spot any cases that I missed!
    There is a Visual Studio refactoring feature to use target-typed new, as documented
    at the following link: [https://learn.microsoft.com/en-us/visualstudio/ide/reference/use-new](https://learn.microsoft.com/en-us/visualstudio/ide/reference/use-new).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting and setting the default values for types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the primitive types except `string` are **value types**, which means
    that they must have a value. You can determine the default value of a type by
    using the `default()` operator and passing the type as a parameter. You can assign
    the default value of a type by using the `default` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The `string` type is a **reference type**. This means that `string` variables
    contain the memory address of a value, not the value itself. A reference type
    variable can have a `null` value, which is a literal that indicates that the variable
    does not reference anything (yet). `null` is the default for all reference types.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn more about value types and reference types in *Chapter 6*, *Implementing
    Interfaces and Inheriting Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore default values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to show the default values of an `int`, a `bool`, a `DateTime`,
    and a `string`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `??` operator means, if `null`, then return the following instead. So if
    `default(string)` is `null`, then the text, `<NULL>` will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result. Note that your output for the date and time
    might be formatted differently if you are not running it in the UK because date
    and time values are formatted using the current culture of your computer, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to declare a number, assign a value, and then reset it to its
    default value, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Exploring more about console apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already created and used basic console apps, but we’re now at a stage
    where we should delve into them more deeply.
  prefs: []
  type: TYPE_NORMAL
- en: Console apps are text-based and are run at the command prompt. They typically
    perform simple tasks that need to be scripted, such as compiling a file or encrypting
    a section of a configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Equally, they can also have arguments passed to them to control their behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this would be to create a new console app using the F# language
    with a specified name instead of using the name of the current folder, as shown
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Displaying output to the user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two most common tasks that a console app performs are writing and reading
    data. We have already used the `WriteLine` method to output, but if we didn’t
    want a carriage return at the end of a line, for example, if we later wanted to
    continue to write more text at the end of that line, we could have used the `Write`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to write three letters to the console without carriage returns
    after them, then call the `Write` method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'This will write the three characters on a single line and leave the cursor
    at the end of the line, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to write three letters to the console with carriage returns after
    them, then call the `WriteLine` method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This will write three lines and leave the cursor on the fourth line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Formatting using numbered positional arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One way of generating formatted strings is to use numbered positional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: This feature is supported by methods like `Write` and `WriteLine`. For methods
    that do not support the feature, the `string` parameter can be formatted using
    the `Format` method of `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `Formatting` to the `Chapter02` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements and then type statements to
    declare some number variables and write them to the console, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Warning!** We used the `CultureInfo` class to force the culture to US English
    so that the currency will be US dollars for all readers. In *Chapter 4, Writing,
    Debugging, and Testing Functions*, you will learn how to write a function to control
    the culture so that they can see US English by default, or override that to show
    your local computer culture or a specified culture.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `Write`, `WriteLine`, and `Format` methods can have up to three numbered
    arguments, named `arg0`, `arg1`, and `arg2`. If you need to pass more than three
    values, then you cannot name them. The `WriteToFile` method is a nonexistent method
    used to illustrate the idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, type statements to write three and then five arguments to
    the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Once you become more comfortable with formatting strings,
    you should stop naming the parameters, for example, stop using `format:`, `arg0:`,
    and `arg1:`. The preceding code uses a non-canonical style to show where the `0`
    and `1` came from while you are learning.'
  prefs: []
  type: TYPE_NORMAL
- en: Rider and its warnings about boxing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you use Rider and you have installed the Unity Support plugin, then it will
    complain a lot about boxing. A common scenario when boxing happens is when value
    types like `int` and `DateTime` are passed as positional arguments to `string`
    formats. This is a problem for Unity projects because they use a different memory
    garbage collector than the normal .NET runtime. For non-Unity projects, like all
    the projects in this book, you can ignore these boxing warnings because they are
    not relevant. You can read more about this Unity-specific issue at the following
    link: [https://docs.unity3d.com/Manual/performance-garbage-collection-best-practices.html#boxing](https://docs.unity3d.com/Manual/performance-garbage-collection-best-practices.html#boxing).'
  prefs: []
  type: TYPE_NORMAL
- en: Formatting using interpolated strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# 6 and later have a handy feature named **interpolated strings**. A `string`
    prefixed with `$` can use curly braces around the name of a variable or expression
    to output the current value of that variable or expression at that position in
    the `string`, as the following shows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a statement at the bottom of the `Program.cs` file, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For short, formatted `string` values, an interpolated `string` can be easier
    for people to read. But for code examples in a book, where statements need to
    wrap over multiple lines, this can be tricky. For many of the code examples in
    this book, I will use numbered positional arguments. Another reason to avoid interpolated
    strings is that they can’t be read from resource files to be localized.
  prefs: []
  type: TYPE_NORMAL
- en: The next code example is not meant to be entered in your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before C# 10, `string` constants could only be combined by using concatenation
    with the `+` operator, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'With C# 10, interpolated strings (prefixed with `$`) can now be used, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This only works for combining `string` constant values. It cannot work with
    other types like numbers, which would require runtime data type conversions. You
    cannot enter `private const` declarations in a top-level program like `Program.cs`.
    You will see how to use them in *Chapter 5*, *Building Your Own Types with Object-Oriented
    Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: If you are writing code that will be part of a Unity project,
    then interpolated string formats are an easy way to avoid boxing.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding format strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A variable or expression can be formatted using a format string after a comma
    or colon.
  prefs: []
  type: TYPE_NORMAL
- en: An `N0` format string means a number with thousands separators and no decimal
    places, while a `C` format string means currency. The currency format will be
    determined by the current thread.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if you run code that uses the number or currency format on a PC
    in the UK, you’ll get pounds sterling with commas as the thousands separators,
    but if you run it on a PC in Germany, you will get euros with dots as the thousands
    separators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full syntax of a format item is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Each format item can have an alignment, which is useful when outputting tables
    of values, some of which might need to be left- or right-aligned within a width
    of characters. Alignment values are integers. Positive integers mean right-aligned
    and negative integers mean left-aligned.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to output a table of fruit and how many of each there are, we
    might want to left-align the names within a column of 10 characters and right-align
    the counts formatted as numbers with zero decimal places within a column of six
    characters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, enter the following statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the effect of the alignment and number format, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Custom number formatting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can take complete control of number formatting using custom format codes,
    as shown in *Table 2.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Format code** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | Zero placeholder. Replaces the zero with the corresponding digit if
    present; otherwise, it uses zero. For example, `0000.00` formatting the value
    `123.4` would give `0123.40`. |'
  prefs: []
  type: TYPE_TB
- en: '| `#` | Digit placeholder. Replaces the hash with the corresponding digit if
    present; otherwise, it uses nothing. For example, `####.##` formatting the value
    `123.4` would give `123.4`. |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | Decimal point. Sets the location of the decimal point in the number.
    Respects culture formatting, so it is a `.` (dot) in US English but a `,` (comma)
    in French. |'
  prefs: []
  type: TYPE_TB
- en: '| `,` | Group separator. Inserts a localized group separator between each group.
    For example, `0,000` formatting the value `1234567` would give `1,234,567`. Also
    used to scale a number by dividing by multiples of 1,000 for each comma. For example,
    `0.00,,` formatting the value `1234567` would give `1.23` because the two commas
    mean divide by 1,000 twice. |'
  prefs: []
  type: TYPE_TB
- en: '| `%` | Percentage placeholder. Multiplies the value by 100 and adds a percentage
    character. |'
  prefs: []
  type: TYPE_TB
- en: '| `\` | Escape character. Makes the next character a literal instead of a format
    code. For example, `\##,###\#` formatting the value `1234` would give `#1,234#`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `;` | Section separator. Defines different format strings for positive, negative,
    and zero numbers. For example, `[0];(0);Zero` formatting: `13` would give `[13]`,
    `-13` would give `(13)`, and `0` would give `Zero`. |'
  prefs: []
  type: TYPE_TB
- en: '| Others | All other characters are shown in the output as is. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.7: Custom numeric format codes'
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: A full list of custom number format codes can be found
    at the following link: [https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-numeric-format-strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-numeric-format-strings).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply standard number formatting using simpler format codes, like `C`
    and `N`. They support a precision number to indicate how many digits of precision
    you want. The default is two. The most common are shown in *Table 2.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Format code** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `C` or `c` | Currency. For example, in US culture, `C` formatting the value
    `123.4` gives `$123.40`, and `C0` formatting the value `123.4` gives `$123`. |'
  prefs: []
  type: TYPE_TB
- en: '| `N` or `n` | Number. Integer digits with an optional negative sign and grouping
    characters. |'
  prefs: []
  type: TYPE_TB
- en: '| `D` or `d` | Decimal. Integer digits with an optional negative sign but no
    grouping characters. |'
  prefs: []
  type: TYPE_TB
- en: '| `B` or `b` | Binary. For example, `B` formatting the value `13` gives `1101`,
    and `B8` formatting the value `13` gives `00001101`. |'
  prefs: []
  type: TYPE_TB
- en: '| `X` or `x` | Hexadecimal. For example, `X` formatting the value `255` gives
    `FF`, and `X4` formatting the value `255` gives `00FF`. |'
  prefs: []
  type: TYPE_TB
- en: '| `E` or `e` | Exponential notation. For example, `E` formatting the value
    `1234.567` would give `1.234567000E+003`, and `E2` formatting the value `1234.567`
    would give `1.23E+003`. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.8: Standard numeric format codes'
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: A full list of standard number format codes can be found
    at the following link: [https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can take complete control of date and time formatting using custom format
    codes, as shown in *Table 2.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Format code** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | Date part separator. Varies by culture; for example, `en-US` uses `/`
    but `fr-FR` uses `-` (dash). |'
  prefs: []
  type: TYPE_TB
- en: '| `\` | Escape character. Useful if you want to use a special format code as
    a literal character; for example, `h \h m \m` would format a time of 9:30 AM as
    `9 h 30 m`. |'
  prefs: []
  type: TYPE_TB
- en: '| `:` | Time part separator. Varies by culture; for example, `en-US` uses `:`
    but `fr-FR` uses `.` (dot). |'
  prefs: []
  type: TYPE_TB
- en: '| `d`, `dd` | The day of the month, from `1` to `31`, or with a leading zero
    from `01` through `31`. |'
  prefs: []
  type: TYPE_TB
- en: '| `ddd`, `dddd` | The abbreviated or full name of the day of the week, for
    example, `Mon` or `Monday`, localized for the current culture. |'
  prefs: []
  type: TYPE_TB
- en: '| `f`, `ff`, `fff` | The tenths of a second, hundredths of a second, or milliseconds.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `g` | The period or era, for example, `A.D.` |'
  prefs: []
  type: TYPE_TB
- en: '| `h`, `hh` | The hour, using a 12-hour clock from `1` to `12`, or from `01`
    to `12`. |'
  prefs: []
  type: TYPE_TB
- en: '| `H`, `HH` | The hour, using a 24-hour clock from `0` to `23`, or from `01`
    to `23`. |'
  prefs: []
  type: TYPE_TB
- en: '| `K` | Time zone information. `null` for an unspecified time zone, `Z` for
    UTC, and a value like `-8:00` for local time adjusted from UTC. |'
  prefs: []
  type: TYPE_TB
- en: '| `m`, `mm` | The minute, from `0` through `59`, or with a leading zero from
    `00` through `59`. |'
  prefs: []
  type: TYPE_TB
- en: '| `M`, `MM` | The month, from `1` through `12`, or with a leading zero from
    `01` through `12`. |'
  prefs: []
  type: TYPE_TB
- en: '| `MMM`, `MMMM` | The abbreviated or full name of the month, for example, `Jan`
    or `January`, localized for the current culture. |'
  prefs: []
  type: TYPE_TB
- en: '| `s`, `ss` | The second, from `0` through `59`, or with a leading zero from
    `00` through `59`. |'
  prefs: []
  type: TYPE_TB
- en: '| `t`, `tt` | The first or both characters of the AM/PM designator. |'
  prefs: []
  type: TYPE_TB
- en: '| `y`, `yy` | The year of the current century, from `0` through `99`, or with
    a leading zero from `00` through `99`. |'
  prefs: []
  type: TYPE_TB
- en: '| `yyy` | The year with a minimum of three digits, and as many as needed. For
    example, 1 A.D. is `001`. The first sacking of Rome was in `410`. The year the
    first edition of this book was published in `2016`. |'
  prefs: []
  type: TYPE_TB
- en: '| `yyyy`, `yyyyy` | The year as a four- or five-digit number. |'
  prefs: []
  type: TYPE_TB
- en: '| `z`, `zz` | Hours offset from UTC, with no leading zeros, or with leading
    zeros. |'
  prefs: []
  type: TYPE_TB
- en: '| `zzz` | Hours and minutes offset from UTC, with a leading zero, for example,
    `+04:30`. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.9: Custom format codes for date and time values'
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: A full list of custom format codes can be found at the
    following link: [https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply standard date and time formatting using simpler format codes,
    like the `d` and `D` we used in the code example, as shown in *Table 2.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Format code** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `d` | Short date pattern. Varies by culture; for example, `en-US` uses `M/d/yyyy`
    and `fr-FR` uses `dd/MM/yyyy`. |'
  prefs: []
  type: TYPE_TB
- en: '| `D` | Long date pattern. Varies by culture; for example, `en-US` uses `mmmm,
    MMMM d, yyyy` and `fr-FR` uses `mmmm, dd MMMM yyyy`. |'
  prefs: []
  type: TYPE_TB
- en: '| `f` | Full date/time pattern (short time – hours and minutes). Varies by
    culture. |'
  prefs: []
  type: TYPE_TB
- en: '| `F` | Full date/time pattern (long time – hours, minutes, seconds, and AM/PM).
    Varies by culture. |'
  prefs: []
  type: TYPE_TB
- en: '| `m`, `M` | Month/day pattern. Varies by culture. |'
  prefs: []
  type: TYPE_TB
- en: '| `o,` `O` | A standardized pattern, suitable to serialize date/time values
    for roundtrips, for example, `2023-05-30T13:45:30.0000000-08:00`. |'
  prefs: []
  type: TYPE_TB
- en: '| `r`, `R` | RFC1123 pattern. |'
  prefs: []
  type: TYPE_TB
- en: '| `t` | Short time pattern. Varies by culture; for example, `en-US` uses `h:mm
    tt` and `fr-FR` uses `HH:mm`. |'
  prefs: []
  type: TYPE_TB
- en: '| `T` | Long time pattern. Varies by culture; for example, `en-US` uses `h:mm:ss
    tt` and `fr-FR` uses `HH:mm:ss`. |'
  prefs: []
  type: TYPE_TB
- en: '| `u` | Universal sortable date/time pattern, for example, `2009-06-15 13:45:30Z`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `U` | Universal full date/time pattern. Varies by culture; for example, `en-US`
    might be `Monday, June 15, 2009 8:45:30 PM`. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.10: Standard format codes for date and time values'
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: A full list of format codes can be found at the following
    link: [https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** Note the difference between `"m"` (a shorthand for the month/day
    format, like July 4 in USA or 4 July in UK, which omits the year and presents
    the month and day in a culture-specific manner) and `"d m"` (a custom format string
    that displays the day number and then the month number with a space in between,
    like 4 7 in any country for 4^(th) July).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to output a value using multiple formats:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to output a `decimal` value twice, first as currency using
    the current culture, and then as a percentage, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Getting text input from the user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can get text input from the user using the `ReadLine` method. This method
    waits for the user to type some text. Then, as soon as the user presses *Enter*,
    whatever the user has typed is returned as a `string` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get input from the user:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to ask the user for their name and age and then output what
    they entered, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, with .NET 6 and later, nullability checks are enabled, so the C#
    compiler gives two warnings because the `ReadLine` method could return a `null`
    value instead of a `string` value. But there is no practical scenario where this
    method would actually return `null`, so instead, we will see how to switch off
    these specific warnings in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `firstName` variable, append a `?` after `string`, as shown highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This tells the compiler that we are expecting a possible `null` value, so it
    does not need to warn us. If the variable is `null`, then when it is later output
    with `WriteLine`, it will just be blank, so that works fine in this case. If we
    were going to access any of the members of the `firstName` variable, then we would
    need to handle the case where it is `null`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the `age` variable, append a `!` before the semicolon at the end of the
    statement, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is called the **null-forgiving operator** because it tells the compiler
    that, in this case, `ReadLine` will not return `null`, so it can stop showing
    the warning. It is now our responsibility to ensure this is the case. Luckily,
    the `Console` type’s implementation of `ReadLine` always returns a `string` even
    if it is just an empty `string` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, and then enter a name and age, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have now seen two common ways to handle nullability warnings from the compiler.
    We will cover nullability and how to handle it in more detail in *Chapter 6*,
    *Implementing Interfaces and Inheriting Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: When does ReadLine return null?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ReadLine` method reads the next line of input from the standard input stream.
    If the user presses *Enter* without typing anything, `ReadLine` will return an
    empty string, not `null`.
  prefs: []
  type: TYPE_NORMAL
- en: In typical console apps, `ReadLine` returns `null` only if the **end of stream**
    (**EOF**) is reached. This is not something that can usually be achieved by user
    input in a standard console environment since EOF is typically signaled by the
    console being closed or redirected input being fully consumed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the conditions under which `name` might be `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: If the standard input stream is redirected and reaches EOF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are testing in an environment where you can simulate EOF, like some development
    environments or automated testing setups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, under normal user input conditions, `null` will “never” be returned
    by the `ReadLine` method.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the usage of the console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C# 6 and later, the `using` statement can be used not only to import a namespace
    but also to further simplify our code by importing a static class. Then, we won’t
    need to enter the `Console` type name throughout our code.
  prefs: []
  type: TYPE_NORMAL
- en: Importing a static type for a single file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use your code editor’s **Find and Replace** feature to remove the times
    we have previously written `Console`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the `Program.cs` file, add a statement to **statically import**
    the `System.Console` class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select the first `Console.` in your code, ensuring that you select the dot after
    the word `Console` too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Visual Studio, navigate to **Edit** | **Find and Replace** | **Quick Replace**;
    in VS Code, navigate to **Edit** | **Replace**; or in Rider, navigate to **Edit**
    | **Find** | **Replace**, and note that an overlay dialog appears ready for you
    to enter what you would like to replace `Console.` with, as shown in *Figure 2.9*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_02_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Using the Replace feature in Visual Studio to simplify your code'
  prefs: []
  type: TYPE_NORMAL
- en: Leave the **Replace** box empty, click on the **Replace all** button (the second
    of the two buttons to the right of the **Replace** box), and then close the **Replace**
    box by clicking on the cross in its top-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the console app and note the behavior is the same as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Importing a static type for all code files in a project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of statically importing the `Console` class just for one code file,
    it would probably be better to import it globally for all code files in the project:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the statement to statically import `System.Console`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `Formatting.csproj`, and after the `<PropertyGroup>` section, add a new
    `<ItemGroup>` section to globally and statically import `System.Console` using
    the implicit `using` .NET SDK feature, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: The `Label` attribute within an `<ItemGroup>` in .NET projects
    is optional but useful for several reasons, primarily revolving around organization,
    customization, and clarity in the build process. When multiple `<ItemGroup>` sections
    are used, labels provide a clear indication of what each group contains. Using
    labels, you can conditionally include or exclude certain items based on build
    configurations or other conditions. In this case, we are just using it for documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Run the console app and note that the behavior is the same as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice**: In the future, for all console app projects you create for
    this book, add the section above to simplify the code you need to write in all
    C# files to work with the `Console` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting key input from the user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can get key input from the user using the `ReadKey` method. This method waits
    for the user to press a key or key combination, which is then returned as a `ConsoleKeyInfo`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore reading key presses:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to ask the user to press any key combination and then output
    information about it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, press the *K* key, and note the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, hold down *Shift* and press the *K* key, and note the result,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, press the *F12* key, and note the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Warning!** When running a console app in a terminal within VS Code, some
    keyboard combinations will be captured by the code editor before they can be processed
    by your console app. For example, *Ctrl* + *Shift* + *X* in VS Code activates
    the **Extensions** view in the sidebar. To fully test this console app, open a
    command prompt or terminal in the project folder and run the console app from
    there.'
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments to a console app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you run a console app, you often want to change its behavior by passing
    arguments. For example, with the `dotnet` command-line tool, you can pass the
    name of a new project template, as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: You might have been wondering how to get any arguments that might be passed
    to a console app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In every version of .NET prior to version 6, the console app project template
    made it obvious, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The `string[] args` arguments are declared and passed in the `Main` method of
    the `Program` class. They’re an array used to pass arguments into a console app.
    But in top-level programs, as used by the console app project template in .NET
    6 and later, the `Program` class and its `Main` method are hidden, along with
    the declaration of the `args` array. The trick is that you must know it still
    exists.
  prefs: []
  type: TYPE_NORMAL
- en: Command-line arguments are separated by spaces. Other characters like hyphens
    and colons are treated as part of an argument value.
  prefs: []
  type: TYPE_NORMAL
- en: To include spaces in an argument value, enclose the argument value in single
    or double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we want to be able to enter the names of some colors for the foreground
    and background and the dimensions of the terminal window at the command line.
    We would be able to read the colors and numbers by reading them from the `args`
    array, which is always passed into the `Main` method, aka the entry point of a
    console app:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `Arguments` to the `Chapter02` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `Arguments.csproj`, and after the `<PropertyGroup>` section, add a new
    `<ItemGroup>` section to statically import `System.Console` for all C# files using
    the implicit usings .NET SDK feature, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Remember to use the implicit using .NET SDK feature to statically
    import the `System.Console` type in all future console app projects to simplify
    your code, as these instructions will not be repeated every time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements and then add a statement to
    output the number of arguments passed to the application, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are using Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **Project** | **Arguments** **Properties**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Debug** tab, click **Open debug launch profiles UI**, and in the
    **Command line arguments** box, enter the following arguments: `firstarg second-arg
    third:arg "fourth arg"`, as shown in *Figure 2.10*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_02_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: Entering command line arguments in the Visual Studio project properties'
  prefs: []
  type: TYPE_NORMAL
- en: Close the **Launch Profiles** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In **Solution Explorer**, in the `Properties` folder, open the `launchSettings.json`
    file and note it defines the command-line arguments when you run the project,
    as shown highlighted in the following configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `launchSettings.json` file can also be used by Rider. The equivalent for
    VS Code is the `.vscode/launch.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Run the console app project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are using VS Code, then in **Terminal**, enter some arguments after
    the `dotnet run` command, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'For all code editors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the result indicates four arguments, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, to enumerate or iterate (that is, loop through) the values
    of those four arguments, add the following statements after outputting the length
    of the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code again and note that the result shows the details of the four arguments,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Setting options with arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now use these arguments to allow the user to pick a color for the background,
    foreground, and cursor size of the output window. The cursor size can be an integer
    value from 1, meaning a line at the bottom of the cursor cell, up to 100, meaning
    a percentage of the height of the cursor cell.
  prefs: []
  type: TYPE_NORMAL
- en: We have statically imported the `System.Console` class. It has properties like
    `ForegroundColor`, `BackgroundColor`, and `CursorSize` that we can now set just
    by using their names without needing to prefix them with `Console`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `System` namespace is already imported so that the compiler knows about
    the `ConsoleColor` and `Enum` types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to warn the user if they do not enter three arguments, and then
    parse those arguments and use them to set the color and dimensions of the console
    window, as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the compiler warning that setting the `CursorSize` is only supported on
    Windows. For now, do not worry about most of this code like `(ConsoleColor)`,
    `Enum.Parse`, or `typeof`, as it will all be explained in the next few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio, change the arguments to `red yellow 50`. Run
    the console app and note that the cursor is half the size and the colors have
    changed in the window, as shown in *Figure 2.11*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B22322_02_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: Setting colors and cursor size on Windows'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using VS Code, then run the code with arguments to set the foreground
    color to red, the background color to yellow, and the cursor size to 50%, as shown
    in the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On macOS or Linux, you’ll see an unhandled exception, as shown in *Figure 2.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_02_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: An unhandled exception on unsupported macOS'
  prefs: []
  type: TYPE_NORMAL
- en: Although the compiler did not give an error or warning, at runtime, some API
    calls may fail on some platforms. Although a console app running on Windows can
    change its cursor size, on macOS, it cannot, and it complains if you try.
  prefs: []
  type: TYPE_NORMAL
- en: Handling platforms that do not support an API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So how do we solve this problem? We can solve this by using an exception handler.
    You will learn more details about the `try`-`catch` statement in *Chapter 3*,
    *Controlling Flow, Converting Types, and Handling Exceptions*, so for now, just
    enter the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the code to wrap the lines that change the cursor size in a `try` statement,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you were to run the code on macOS, then you would see the exception is caught,
    and a friendlier message is shown to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another way to handle differences in operating systems is to use the `OperatingSystem`
    class in the `System` namespace, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The `OperatingSystem` class has equivalent methods for other common operating
    systems, like Android, iOS, Linux, macOS, and even the browser, which is useful
    for Blazor web components.
  prefs: []
  type: TYPE_NORMAL
- en: A third way to handle different platforms is to use conditional compilation
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four preprocessor directives that control conditional compilation:
    `#if`, `#elif`, `#else`, and `#endif`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You define symbols using `#define`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Many symbols are automatically defined for you, as shown in *Table 2.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Target Framework** | **Symbols** |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Standard | `NETSTANDARD2_0`, `NETSTANDARD2_1`, and so on |'
  prefs: []
  type: TYPE_TB
- en: '| Modern .NET | `NET7_0`, `NET7_0_ANDROID`, `NET7_0_IOS`, `NET7_0_WINDOWS`,
    and so on |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.11: Predefined compiler symbols'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then write statements that will compile only for the specified platforms,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring the topics covered in this chapter with deeper
    research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.1 – Online material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Online materials can be extra content written by me for this book, or it can
    be references to content created by Microsoft or third parties.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding async and await
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# 5 introduced two C# keywords when working with the `Task` type that enable
    easy multithreading. You can read about them and see a code example at the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch02-async-await.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch02-async-await.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Explore Spectre
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'No, not the villainous organization from the James Bond films! **Spectre**
    is a package that enhances console apps. You can read about it at the following
    link: `https://spectreconsole.net/`.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.2 – Practice exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Practice exercises go deeper into the topics for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Explore number sizes and ranges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `Chapter02` solution, create a console app project named `Exercise_Numbers`
    that outputs the number of bytes in memory that each of the following number types
    uses and the minimum and maximum values they can have: `sbyte`, `byte`, `short`,
    `ushort`, `int`, `uint`, `long`, `ulong`, `Int128`, `UInt128`, `Half`, `float`,
    `double`, and `decimal`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of running your console app should look something like *Figure 2.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B22322_02_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: The result of outputting number type sizes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code solutions for all exercises are available to download or clone from the
    GitHub repository at the following link: [https://github.com/markjprice/cs13net9/tree/main/code](https://github.com/markjprice/cs13net9/tree/main/code).'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.3 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get the best answer to some of these questions, you will need to do your
    own research. I want you to “think outside the book,” so I have deliberately not
    provided all the answers in the book.
  prefs: []
  type: TYPE_NORMAL
- en: I want to encourage you to get into the good habit of looking for help elsewhere,
    following the principle of “teach a person to fish.”
  prefs: []
  type: TYPE_NORMAL
- en: What statement can you type in a C# file to discover the compiler and language
    version?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two types of comments in C#?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a verbatim string and an interpolated string?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you be careful when using `float` and `double` values?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you determine how many bytes a type like `double` uses in memory?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use the `var` keyword?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the newest syntax to create an instance of a class like `XmlDocument`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you be careful when using the `dynamic` type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you right-align a format string?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What character separates arguments for a console app?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Appendix*, *Answers to the Test Your Knowledge Questions*, is available to
    download from a link in the README in the GitHub repository: [https://github.com/markjprice/cs13net9](https://github.com/markjprice/cs13net9).'
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge of number types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What type would you choose for the following “numbers”?
  prefs: []
  type: TYPE_NORMAL
- en: A person’s telephone number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A person’s height
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A person’s age
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A person’s salary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A book’s ISBN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A book’s price
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A book’s shipping weight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A country’s population
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of stars in the universe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of employees in each of the small or medium businesses in the UK
    (up to about 50,000 employees per business)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise 2.4 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-2---speaking-c](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-2---speaking-c)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare variables with a specified or inferred type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use some of the built-in types for numbers, text, and Booleans.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose between number types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control output formatting in console apps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about operators, branching, looping, converting
    between types, and how to handle exceptions.
  prefs: []
  type: TYPE_NORMAL
