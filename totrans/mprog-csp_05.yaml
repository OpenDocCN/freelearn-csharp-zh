- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Leveraging Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We briefly touched on the concept of C# attributes in [*Chapter 2*](B19418_02.xhtml#_idTextAnchor026),
    *Metaprogramming Concepts*. They are an obvious choice for adding explicit metadata
    to your source code. This is what they are intended for. Attributes should not
    carry heavy logic with them and should be viewed as just metadata.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look into how you can leverage them in your code base,
    providing mechanisms for adorning types and members with valuable, rich information
    that can be used for different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is an attribute and how can it be applied?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding types with specific attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From this chapter, you should understand the power of attributes as a building
    block for metaprogramming, how to create your own custom attributes, and how you
    can discover them being used.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter5](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter5))
    and it builds on top of the **Fundamentals** code, which is found at [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals).
  prefs: []
  type: TYPE_NORMAL
- en: What is an attribute and how can it be applied?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **attribute** is a special type that the C# compiler understands. It can
    be used to associate metadata to assemblies, types, and any member of a type.
    During compilation, the compiler will pick up the attributes and add them to the
    compiled assembly as metadata. You can place more than one attribute on every
    item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating your own custom attribute is as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And then using it is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that you create the attribute with the **Attribute** postfix in the name.
    While using it, you don’t need it and you only have **[Custom]**. The C# compiler
    has a convention built into it saying you have to have the postfix, but it will
    ignore it when it’s used. This is a little bit weird and definitely violates the
    principle of least surprise.
  prefs: []
  type: TYPE_NORMAL
- en: The nice thing about attributes is that they live outside the scope of the element
    itself, meaning that you don’t have to create an instance of the type with the
    metadata to access the metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes can take parameters to give them specific information you want to
    capture. However, all parameters must be available at compile time. This means
    you can’t create new objects dynamically for any of the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can add a parameter to the attribute by taking the instance
    of another type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will allow the attribute to take the type – after all, it is a
    valid C# type. However, when you try to use it, you’re not allowed to create a
    new instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is because the compiler needs the values to be available at compile time.
    Even though attributes are ultimately instantiated at runtime, the information
    captured and added to the compiled assembly is never executed. This means that
    you’re limited to things the compiler can resolve, such as primitive types (for
    example, **int**, **float**, and **double**) and things such as strings – anything
    that can be represented as constants and not have to be created by the runtime
    to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'A valid parameter could be a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With the constructor now taking a string, it will work not just at compile time
    but also at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since strings can be literal constants, you are allowed to use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Already, you can see the power of attributes – the ability to have additional
    information sitting there that your code can reason about and you can use to make
    decisions or even use for reporting.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting attribute usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For attributes, you can also add metadata to them, which feels a little bit
    like inception; metadata for the metadata. The metadata that you add is to limit
    the scope of how the attribute can be used.
  prefs: []
  type: TYPE_NORMAL
- en: You can be very specific about what elements in your code the attribute is for
    (class, property, field, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'The **[AttributeUsage]** attribute allows you to be specific about the attribute.
    Let’s say you want to limit the usage to only classes – you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you then try to add the attribute to something else other than a class,
    you will get a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The **[AttributeUsage]** type is an enum holding different values for the different
    code elements attributes support. Every value in the enum represents a flag, making
    it possible to combine them and target multiple code element types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s limit the code elements to **Class**, **Method**, and **Property** by
    applying the **[AttributeUsage]** attribute with these specified for the custom
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using the bitwise **OR** construct (**|**) you can add all the
    elements you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: A little fun fact about **[AttributeUsage]** is that it uses itself to tell
    the compiler that it can only be used for classes. Again, a little bit of inception
    there; the **[AttributeUsage]** attribute is using **[AttributeUsage]** to provide
    metadata about itself.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to limiting the code elements an attribute can be associated with,
    you can also tell whether or not you allow multiple instances of the attribute
    to be applied. You can also specify whether or not you allow the attribute to
    be available as metadata for types inheriting from the type that has the attribute
    applied to it.
  prefs: []
  type: TYPE_NORMAL
- en: The **[AttributeUsage]** attribute does, however, only take one parameter in
    its constructor. That means we have to use its properties explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, attributes are limited to only being associated once per code element
    type. Trying to associate the attribute more than once will give you a compiler
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This behavior can be changed by simply using the **AllowMultiple** property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Compiling the same code will now be allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other property you can use for limiting the usage of the attributes is
    the **Inherited** property. Setting this to **false** will tell the compiler that
    the associated attribute is only the specific type it is being used explicitly
    and not for the derived type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you saw earlier, you can add the attribute in a normal way to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add a class that inherits from the type with the **[Custom]** attribute
    applied to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The metadata associated with the **MyClass** base type will not be associated
    with **MyOtherClass** when the **Inherited** property is set to **false**. This
    is, by default, turned on, meaning that the derived type will have the same metadata
    associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: To create an attribute, inheriting from **Attribute** and applying **[AttributeUsage]**
    is all you need to do. However, you might want to bring more clarity and explicitness
    to your metadata by not allowing inheritance from your attribute. Sealing your
    class will disable anyone inheriting from your custom attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Sealing your attribute class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since attributes represent specific metadata, they’re not a regular code construct
    that you use for holding logic. Therefore, you will find that you don’t need to
    create base attributes that other, more specific attributes inherit from. In fact,
    it could make your metadata unclear if you use inheritance as your metadata will
    lose explicitness and you would bring implicitness into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this, it is considered good practice to not allow for the inheritance
    of attributes and stop it at a compiler level by making the attribute class **sealed**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you then try to create a more specific attribute that inherits from it, you
    will get a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered all the mechanics involved in creating custom attributes
    and how you can make them very specific to your use case, you are probably eager
    to start actually discovering them and putting them to good use.
  prefs: []
  type: TYPE_NORMAL
- en: Finding types with specific attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since attributes are created at compile time and do not require you to have
    an instance of a type that has been associated with attributes, you can discover
    attributes using the type system.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the **System.Type** type, you’ll see that it implements a type
    called **MemberInfo** that sits in the **System.Reflection** namespace. This base
    class serves as the base class for **PropertyInfo**, **MethodInfo**, **FieldInfo**,
    and most of the specific info types representing code elements we can discover
    through the type system.
  prefs: []
  type: TYPE_NORMAL
- en: On the **MemberInfo** type, you find a method called **GetCustomAttributes()**.
    This lets you get a collection of attributes associated with the particular code
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the class we had before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then quite easily get to the custom attributes on a type and loop through
    them and perform the actions you want to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using **typeof()** is very explicit and can be used just for this type. For
    a more dynamic solution, you can discover what types have a specific attribute,
    which you can leverage for the work we did in [*Chapter 4*](B19418_04.xhtml#_idTextAnchor059),
    *Reasoning about Types* *Using Reflection*.
  prefs: []
  type: TYPE_NORMAL
- en: Personal Identifiable Information (PII)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s go back to the GDPR theme we touched on in previous chapters. In [*Chapter
    4*](B19418_04.xhtml#_idTextAnchor059), *Reasoning about Types Using Reflection*,
    we used types to discover what was personally identifiable information. Another
    approach could be to use custom attributes as an explicit metadata approach. With
    attributes, we can associate more than what we did with a base type in [*Chapter
    4*](B19418_04.xhtml#_idTextAnchor059), *Reasoning about Types Using Reflection*.
    You can add metadata about the reason for collecting the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can capture this with an attribute like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The code creates an attribute that can be applied to classes, properties, and
    parameters. It does not allow multiple instances of itself to be applied to the
    code element it will be applied to. It allows the metadata to be available for
    any type that inherits from the type that has this metadata applied to it or its
    members. One of the things it is interesting to know about GDPR is the reason
    the system collects specific data – the attribute, therefore, has this as optional
    metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find this implementation in the **Fundamentals** project in the GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a folder called [*Chapter 5*](B19418_05.xhtml#_idTextAnchor083).
    Change into this folder in your command-line interface and create a new console
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing you’ll need to do is to reference the Fundamentals project.
    If you have the project next to the **Chapter5** folder, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With that in place, let’s say you want to create an object that encapsulates
    an employee:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This type clearly holds properties that would be identifiable for the person;
    let’s add the appropriate metadata for its members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this, we now have enough information to discover any type in the system
    that holds this type of information.
  prefs: []
  type: TYPE_NORMAL
- en: Building on the assembly and type discovery system introduced in [*Chapter 4*](B19418_04.xhtml#_idTextAnchor059),
    *Reasoning about Types Using Reflection*, we can query specifically for this.
  prefs: []
  type: TYPE_NORMAL
- en: Since every member on a type inherits from the **MemberInfo** type found in
    the **System.Reflection** namespace, we can easily create a convenience extension
    method allowing us to check whether a member has a specific attribute associated
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then create a simple extension method that allows you to check whether
    an attribute is associated with a member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find this implementation in the **Fundamentals** project in the GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in place, you can discover all the types with this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The **HasAttribute<>** extension method is a powerful little helper that you’ll
    find handy in all scenarios where you want to do simple querying of type metadata
    based on attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a GDPR report with the reason for collecting information, change
    the **Program.cs** file look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The code leverages the type discovery introduced in [*Chapter 4*](B19418_04.xhtml#_idTextAnchor059),
    *Reasoning about Types Using Reflection*, and uses LINQ extension methods to select
    all the types that have properties with **[PersonalIdentifiableInformationAttribute]**
    applied. It then groups them by type so that you can easily loop through and present
    the members with the attribute per type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this will yield the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This type of metadata is very valuable for a business. If your business gets
    a query from the government about a GDPR audit, with your code fully loaded with
    metadata you can easily create a report on what type of data you’re collecting
    and the reason for collecting it.
  prefs: []
  type: TYPE_NORMAL
- en: You could also present this type of information to the end users of your system.
    It is very valuable for a user to know what the system collects about them. This
    builds a trusting relationship between the system and your users.
  prefs: []
  type: TYPE_NORMAL
- en: GDPR is a very good use case for getting very useful metadata into your code
    base, but it is just one of many use cases. You can, of course, make use of metadata
    in a more actionable way other than just for reporting.
  prefs: []
  type: TYPE_NORMAL
- en: Generic attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the limitations of C# attributes that we used to have is that attributes
    could not be generic types taking generic arguments. Prior to C# 11, you would
    get a compiler error if you added a generic argument to your attribute class.
    This limitation is lifted with the release of **C# 11**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up till C# 11, the only way you could collect type information was for the
    attribute to have parameters or properties that were of type **System.Type**.
    This became very verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And then adorning a type with the attribute would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With C# 11, now you can improve how you get type information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When you adorn a type with the attribute, you use the generic argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re looking to have a parameter that is dynamic in type, you can do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The code defines an attribute that takes a generic argument and it then requires
    a parameter for the attribute, which will then be of the generic type. It then
    uses the same generic type when exposing the metadata as a property on the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'When adorning types with the attribute, you specify the type and the parameter
    because the attribute has to be of the type specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Normally the C# compiler is very good at inferring the type for generic arguments
    based on the type passed in. But with generic attributes, you have to explicitly
    give it the generic type every time.
  prefs: []
  type: TYPE_NORMAL
- en: Generic attributes can be another powerful metadata collection approach. It
    adds flexibility to how you can construct your metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve looked at what C# attributes are and how powerful they
    are for describing explicit metadata in your code. We’ve looked at all the mechanics
    of how you can create your own custom attributes and apply them very to different
    code elements. From this type of metadata, you can now enrich your code.
  prefs: []
  type: TYPE_NORMAL
- en: With the enrichment looked at in this chapter, you’ve seen how you can quite
    easily discover this metadata and put it to good use for your business.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will dive further into the capabilities of the .NET
    runtime and look at how you can dynamically generate code based on metadata, making
    you more productive as a developer in doing so.
  prefs: []
  type: TYPE_NORMAL
