<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Implementing Design Patterns - Basics Part 2</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we introduced FlixOne and the initial development of a new inventory management application. Several patterns were used by the development team, ranging from patterns designed to limit the scope of a deliverable such as a <strong>Minimum Viable Product</strong> (<strong>MVP</strong>) to patterns to assist in the development of the project such as <strong>Test Driven Development</strong> (<strong>TDD</strong>). Several patterns from the <strong>Gang of Four</strong> (<strong>GoF</strong>) were also applied as a solution to leverage how others have solved similar problems in the past so that we don't repeat common mistakes. Single responsibility principle, Openâ€“closed principle, Liskov substitution principle, Interface Segregation principle, and Dependency inversion principle (SOLID principles) were applied to ensure we are creating a stable code base that will help in the management and future development of our application. </p>
<p>This chapter will continue to explain the building of the FlixOne inventory management application by incorporating more patterns. More of the GoF patterns will be used, including the singleton and factory patterns. A singleton pattern will be used to illustrate the repository pattern that is used to maintain the FlixOne collection of books. The factory pattern will further the understanding of the <strong>Dependency Injection</strong> (<strong>DI</strong>). Finally, we will use the .NET Core framework to facilitate an <strong>Inversion of Control</strong> (<strong>IoC</strong>) container that will be used to complete the initial inventory management console application.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The singleton pattern</li>
<li>The factory pattern</li>
<li>Features of .NET Core</li>
<li>Console application</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter contains various code examples to explain these concepts. The code is kept simple and is just for demonstration purposes. Most of the examples involve a .NET Core console application written in C#.</p>
<p>To run and execute the code, you will need the following:</p>
<ul>
<li>Visual Studio 2019 (you can also run the application using Visual Studio 2017<span> </span>version 3<span> </span>or later)</li>
<li>.NET Core</li>
<li>SQL Server (the Express Edition is used in this chapter)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Visual Studio</h1>
                </header>
            
            <article>
                
<p>To run these code examples, you need to install Visual Studio or later. You can use your preferred IDE. To do this, follow these instructions:</p>
<ol>
<li>Download Visual Studio from the following link:<span> </span><a href="https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio">https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio</a>.</li>
<li>Follow the installation instructions included. Multiple versions are available for the installation of Visual Studio; in this chapter, we are using Visual Studio for Windows.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up .NET Core</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you do not have .NET Core installed, you will need to follow these instructions:</p>
<ol>
<li class="mce-root">Download .NET Core from the following link:<span> </span><a href="https://www.microsoft.com/net/download/windows">https://www.microsoft.com/net/download/windows</a>.</li>
<li>Follow the installation instructions for the related library: <a href="https://dotnet.microsoft.com/download/dotnet-core/2.2">https://dotnet.microsoft.com/download/dotnet-core/2.2</a>.</li>
</ol>
<div class="packt_infobox"><span>The complete source code is available in GitHub. The source code that is shown in this chapter might not be complete, so it is recommended that you retrieve the source code in order to run the examples (<a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter4">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter4</a>). </span></div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The singleton pattern</h1>
                </header>
            
            <article>
                
<p>The singleton pattern is another GoF design pattern that is used to restrict the instantiation of a class to one object. It is used in situations where actions within a system need to be coordinated or access to data needs to be limited. For example, if access to a file needs to be restricted within an application to a single writer, then a singleton could be used to prevent multiple objects from trying to write to the file at the same time. In our scenario, we are going to use a singleton to maintain the collection of books and their inventory.</p>
<p>The value of the singleton pattern is more apparent when it is <span>illustrated using examples</span>. This section will start with a basic class and then go on to identify the different issues that the singleton <span>pattern </span>addresses. These issues will be identified, and the class will be updated and then verified by unit tests.</p>
<p>The singleton pattern should only be used when necessary as it can introduce a potential bottleneck for the application. Sometimes, the pattern is viewed as an anti-pattern as it introduces global state. With global state, unknown dependencies within an application are introduced and it then becomes unclear as to how many types might depend on the information. Additionally, m<span>any frameworks and repositories already limit access when required, so introducing an additional mechanism might limit the performance unnecessarily.</span></p>
<div class="packt_infobox"><span>.NET Core provides support for a number of the patterns discussed. In the next chapter, we will take advantage of the</span><span> </span><kbd>ServiceCollection</kbd><strong><span> </span></strong><span>class's support for both the factory method and the singleton pattern.</span></div>
<p>In our scenario, the singleton pattern will be used to hold an in-memory repository containing a collection of books. The singleton will prevent the collection of books from being updated by more than one thread at a time. This will require us to <em>lock</em> a section of the code to prevent unpredictable updates.</p>
<p>The complexity of introducing a singleton into an application can be subtle; so, to gain a solid understanding of the pattern, we will cover the following topics:</p>
<ul>
<li>.Net Framework's handling of processes and threads</li>
<li>The repository pattern</li>
<li>Race conditions</li>
<li>Unit testing to identify race conditions</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Processes and threads</h1>
                </header>
            
            <article>
                
<p>To understand the singleton pattern, we need to provide a little context. In the .Net Framework, an application will be composed of lightweight, managed subprocesses called application domains that can comprise one or more managed threads. For the purpose of understanding the singleton pattern, let's define this as a multithreaded application that contains one or more threads running simultaneously. Technically, the threads are actually not running simultaneously, but this is achieved by dividing the available processor time between the threads, so that each thread will execute for a small amount of time and then the thread will suspend activity, allowing for another thread to execute.</p>
<p>Going back to the singleton pattern, in a multithreaded application, special care needs to be taken to ensure that access to the singleton is limited so that only one thread enters specific areas of logic at a time. Because of this synchronization of threads, it is possible for one thread to retrieve a value and update it, and, before it can be stored, another thread also updates the value.</p>
<div class="packt_infobox">The potential for more than one thread to access the same shared data and update it with unpredictable results can be referred to as a <strong>race condition</strong>.<em> </em></div>
<p>To avoid data being updated incorrectly, some restriction is required to prevent more than one thread from executing the same block of logic at the same time. There are several mechanisms supported in the .Net Framework and, in the singleton <span>pattern</span>, the<span> </span><kbd>lock</kbd><span> </span>keyword is used. In the following code, the <kbd>lock</kbd> keyword is illustrated to show that only one thread at a time can execute the highlighted code while all other threads will be blocked:</p>
<pre>public class Inventory<br/>{<br/>   int _quantity;<br/>    private Object _lock = new Object();<br/><br/>    public void RemoveQuantity(int amount)<br/>    {<br/>        lock (_lock)<br/>        {<br/>            <strong>if (_quantity - amount &lt; 0)</strong><br/><strong>            {</strong><br/><strong>                throw new Exception("Cannot remove more than we have!");</strong><br/><strong>            }</strong><br/><strong>            _quantity -= amount;</strong><br/>        }<br/>    }<br/>}</pre>
<p>The lock is a simple way of restricting access to a section of code and can be applied to both object instances, as our previous example shows, and to the sections of code marked as static. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The repository pattern</h1>
                </header>
            
            <article>
                
<p>The singleton pattern that is introduced to the project is applied to a class being used to maintain the inventory's collection of books. The singleton will prevent access from multiple threads being handled incorrectly, and, another pattern, the repository pattern, will be used to create a facade over the data that is being managed. </p>
<p>The repository pattern provides an abstraction over a repository to provide a layer between the business logic of an application and the underlying data. This provides several advantages. By having a clean separation, our business logic can be maintained and unit tested independently of the underlying data. Often, the same repository pattern class can be reused by multiple business objects. An example of this could be <kbd>GetInventoryCommand</kbd>, <kbd>AddInventoryCommand</kbd>, and <kbd>UpdateInventoryCommand</kbd> objects<span>;</span> all of these <span>objects </span>use the same repository class. This allows us to test the logic in these commands in isolation from the repository. Another advantage of the pattern is that it enables centralized data-related policies to be more easily implemented, such as caching.</p>
<p>To begin, let's consider the following interface that describes the methods that the repository will implement; it contains a method for retrieving the books, adding a book, and updating <span>the quantity of the book</span>:</p>
<pre>internal interface IInventoryContext<br/>{<br/>    Book[] GetBooks();<br/>    bool AddBook(string name);<br/>    bool UpdateQuantity(string name, int quantity);<br/>}</pre>
<p>The initial version of the repository is as follows:</p>
<pre>internal class InventoryContext : IInventoryContext<br/>{ <br/>    public InventoryContext()<br/>    {<br/>        _books = new Dictionary&lt;string, Book&gt;();<br/>    }<br/>       <br/>    private readonly IDictionary&lt;string, Book&gt; _books; <br/><br/>    public Book[] GetBooks()<br/>    {<br/>        return _books.Values.ToArray();<br/>    }<br/><br/>    public bool AddBook(string name)<br/>    {<br/>        _books.Add(name, new Book { Name = name });<br/>        return true;<br/>    }<br/><br/>    public bool UpdateQuantity(string name, int quantity)<br/>    {<br/>        _books[name].Quantity += quantity;<br/>        return true;<br/>    }<br/>}</pre>
<div class="packt_infobox">In this chapter, the book collection is being maintained in the form of an in-memory cache, and, in later chapters, this will be moved to a repository providing persistent data. Of course, this implementation is not ideal, as, once the application ends, all the data will be lost. However, it serves to illustrate the singleton pattern.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit tests</h1>
                </header>
            
            <article>
                
<p>To illustrate the issues that the singleton pattern addresses, let's start with a simple unit test that adds 30 books to the repository, updates the quantity of the different books, and then verifies the result. The following code shows the overall unit test, and we will explain each step individually:</p>
<pre> [TestClass]<br/>public class InventoryContextTests<br/>{ <br/>    [TestMethod]<br/>    public void MaintainBooks_Successful()<br/>    { <br/>        var context = new InventoryContext();<br/><br/>        // add thirty books<br/>        ...<br/><br/>        // let's update the quantity of the books by adding 1, 2, 3, 4, 5 ...<br/>        ...<br/><br/>        // let's update the quantity of the books by subtracting 1, 2, 3, 4, 5 ...<br/>        ...<br/><br/>        // all quantities should be 0<br/>        ...<br/>    } <br/>}</pre>
<p>To add 30 books, the <kbd>context</kbd> instance is used to add books from <kbd>Book_1</kbd><em> </em>to <kbd>Book_30</kbd>:</p>
<pre>        // add thirty books<br/>        foreach(var id in Enumerable.Range(1, 30))<br/>        {<br/>            context.AddBook($"Book_{id}"); <br/>        }</pre>
<p>The next section updates the book quantity by adding the numbers <span>from</span> <kbd>1</kbd> to <kbd>10</kbd> to the quantity of each book:</p>
<pre>        // let's update the quantity of the books by adding 1, 2, 3, 4, 5 ...<br/>        foreach (var quantity in Enumerable.Range(1, 10))<br/>        {<br/>            foreach (var id in Enumerable.Range(1, 30))<br/>            {<br/>                context.UpdateQuantity($"Book_{id}", quantity);<br/>            }<br/>        }</pre>
<p>Then, in the next section, we will subtract the numbers from <kbd>1</kbd> to <kbd>10</kbd> from the quantity of each book:</p>
<pre>        foreach (var quantity in Enumerable.Range(1, 10))<br/>        {<br/>            foreach (var id in Enumerable.Range(1, 30))<br/>            {<br/>                context.UpdateQuantity($"Book_{id}", -quantity);<br/>            }<br/>        }</pre>
<p>As we have added and removed the same quantity for each book, the last part of our test will verify that the ending quantity is <kbd>0</kbd>:</p>
<pre>        // all quantities should be 0<br/>        foreach (var book in context.GetBooks())<br/>        {<br/>            Assert.AreEqual(0, book.Quantity);<br/>        }</pre>
<p>After running the test, we can see that the test passes:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9597d7f3-ef49-419f-b295-077228d9471e.png" style=""/></div>
<p>So, when the test is run in a single process, the repository works as desired. However, what if the update requests are performed in separate threads? In order to test this, the unit test will be refactored to perform calls to the <kbd>InventoryContext</kbd> class in separate threads. </p>
<p>The addition of the books is moved to a method that performs adding a book as a task (that is, in its own thread):</p>
<pre>public Task AddBook(string book)<br/>{<br/>    return Task.Run(() =&gt;<br/>    {<br/>        var context = new InventoryContext();<br/>        Assert.IsTrue(context.AddBook(book));<br/>    });<br/>}</pre>
<p>Additionally, the update quantity step is moved into another method with a similar approach:</p>
<pre>public Task UpdateQuantity(string book, int quantity)<br/>{<br/>    return Task.Run(() =&gt;<br/>    {<br/>        var context = new InventoryContext();<br/>        Assert.IsTrue(context.UpdateQuantity(book, quantity));<br/>    });<br/>}</pre>
<p>The unit test is then updated to call the new methods. It is worth noting that the unit test will wait until all books are added before updating the quantity. </p>
<p>The <kbd>add thirty books</kbd> section now looks as follows:</p>
<pre>    // add thirty books<br/>    foreach (var id in Enumerable.Range(1, 30))<br/>    {<br/>        <strong>tasks.Add(AddBook($"Book_{id}"));</strong><br/>    }<br/><br/>    <strong>Task.WaitAll(tasks.ToArray());</strong><br/>    tasks.Clear();</pre>
<p>Similarly, the update quantity is changed to call both the <kbd>Add</kbd> and <kbd>subtract</kbd> method in the tasks:</p>
<pre>    // let's update the quantity of the books by adding 1, 2, 3, 4, 5 ...<br/>    foreach (var quantity in Enumerable.Range(1, 10))<br/>    {<br/>        foreach (var id in Enumerable.Range(1, 30))<br/>        {<br/>            <strong>tasks.Add(UpdateQuantity($"Book_{id}", quantity));</strong><br/>        }<br/>    }<br/><br/>    // let's update the quantity of the books by subtractin 1, 2, 3, 4, 5 ...<br/>    foreach (var quantity in Enumerable.Range(1, 10))<br/>    {<br/>        foreach (var id in Enumerable.Range(1, 30))<br/>        {<br/>            <strong>tasks.Add(UpdateQuantity($"Book_{id}", -quantity));</strong><br/>        }<br/>    }<br/><br/>    // wait for all adds and subtracts to finish<br/>    <strong>Task.WaitAll(tasks.ToArray());</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>After the refactor, the unit test no longer successfully completes, and, when the unit test runs now, an error is reported indicating that the book was not found in the collection. This will be reported as <kbd>"The given key was not present in the dictionary."</kbd>. <span>This is because each time the context is instantiated, a new books collection is created. The first step is to restrict the creation of the context. This is done by changing the access of the constructor so that the class can no longer be instantiated directly. Instead, a new public <kbd>static</kbd> property that only supports a <kbd>get</kbd> operation is added. This property will return an underlying <kbd>static</kbd><strong> </strong>instance of the <kbd>InventoryContext</kbd> class and, if the instance is missing, will create it:</span></p>
<pre>internal class InventoryContext : IInventoryContext<br/>{ <br/>    protected InventoryContext()<br/>    {<br/>        _books = new Dictionary&lt;string, Book&gt;();<br/>    }<br/><br/>    <strong>private</strong> static InventoryContext _context;<br/>    <strong>public</strong> static InventoryContext Singleton<br/>    {<br/>        get<br/>        {<br/>            if (_context == null)<br/>            {<br/>                _context = new InventoryContext();<br/>            }<br/><br/>            return _context;<br/>        }<br/>    }<br/>    ...<br/>}    </pre>
<p><span>This is still not enough to fix the broken unit test, but this is due to a different reason. To identify the issue, the unit test is run in debug mode with a breakpoint set in the</span> <kbd>UpdateQuantity</kbd> <span>method. The first time this is run, we can see that 28 books have been created and loaded in the book collection, </span><span>as shown in the following screenshot</span><span>:</span></p>
<p> </p>
<div class="CDPAlignCenter CDPAlign"/>
<div class="CDPAlignCenter CDPAlign"/>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c1515640-71e6-43e4-a1f1-d0d8f21d063c.png" style=""/></div>
<p><span>At this point in the unit test, we would expect 30 books; however, before we start investigating, let's run the unit test a second time. This time, we get an <strong>Object reference not set to an instance of an object</strong> error when we try to access the books collection for adding a new book, as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/268b58d4-cbbe-4b12-9b77-df3b31df45db.png" style=""/></div>
<p>Moreover, when the unit test is run a third time, the <strong>Object reference not set to an instance of an object</strong> error is not encountered, but there are only 27 books in our collection,<span> as shown in the following screenshot</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-205 image-border" src="assets/46a4b8bc-48e9-4586-b1af-c64784920993.png" style=""/></div>
<p>This type of unpredictable behavior is typical of race conditions and indicates that the shared resource, that is, the <kbd>InventoryContext</kbd> singleton, is being handled by multiple threads without synchronizing the access. The construction of the static object still allows more than one instance of the <kbd>InventoryContext</kbd> singleton to be created:</p>
<pre>public static InventoryContext Singleton<br/>{<br/>    get<br/>    {<br/>        <strong>if (_context == null)</strong><br/>        {<br/>            _context = new InventoryContext();<br/>        }<br/><br/>        return _context;<br/>    }<br/>}</pre>
<p>The race condition is where multiple threads evaluate the<span> </span><kbd>if</kbd><span> </span>statement as true and they all try to construct the<span> </span><kbd>_context</kbd> object. All will succeed, but they will overwrite the previously constructed value by doing so. Of course, this is inefficient, especially when the constructor is a costly operation, but the issue discovered with the unit test is that the<span> </span><kbd>_context</kbd><span> </span>object is actually constructed by a thread after another thread or threads have updated the books collection. That is why the books collection,<span> </span><kbd>_books</kbd>, has a different number of elements between runs.</p>
<p>To prevent this issue, the pattern uses a lock around the constructor as follows:</p>
<pre><strong>private static object _lock = new object();</strong><br/>public static InventoryContext Singleton<br/>{<br/>    get<br/>    { <br/>        if (_context == null)<br/>        {<br/><strong>            lock (_lock)</strong><br/>            {<br/>                _context = new InventoryContext();<br/>            }<br/>        }<br/>        <br/>        return _context;<br/>    }<br/>}</pre>
<p>Unfortunately, the unit tests still fail. This is because although one thread at a time can enter the lock, all blocked instances will still enter the lock once the blocking thread has completed. The pattern handles this situation by having an additional check inside the lock in case the construction has already been completed:</p>
<pre>public static InventoryContext Singleton<br/>{<br/>    get<br/>    { <br/>        if (_context == null)<br/>        {<br/>            lock (_lock)<br/>            {<br/><strong>                if (_context == null)</strong><br/>                {<br/>                    _context = new InventoryContext();<br/>                }<br/>            }<br/>        }<br/>        <br/>        return _context;<br/>    }<br/>}</pre>
<p>The preceding lock is essential as it prevents the static <kbd>InventoryContext</kbd> object from getting instantiated multiple times. Unfortunately, our test still does not consistently pass; with each change, the unit test becomes closer to passing. Some unit test runs will complete without error but, occasionally, the test completes with a failed result, as indicated in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-206 image-border" src="assets/8cf03f40-50e7-4459-8209-60388b3b9a71.png" style=""/></div>
<p>Our instantiation of the static repository is now thread safe, but our access to the books collection is not. One thing to note is that the <kbd>Dictionary</kbd> class being used is not thread-safe. Fortunately, there are thread-safe collections available as part of the .Net Framework. These classes ensure that <strong>adds and removals</strong> from the collection are written for a multithreaded process. Note that only adds and removals are thread safe as this will become important a little bit later. The updated constructor is shown in the following code:</p>
<pre>protected InventoryContext()<br/>{<br/>    _books = new <strong>ConcurrentDictionary</strong>&lt;string, Book&gt;();<br/>}</pre>
<div class="packt_tip">Microsoft recommends using the thread-safe collections in <kbd>System.Collections.Concurrent</kbd> over the corresponding collections in <kbd>System.Collections</kbd>, unless the application is targeting .Net Framework 1.1 or earlier.</div>
<p>After running the unit test again, introducing a <kbd>ConcurrentDictionary</kbd> class is still not enough to prevent incorrectly maintaining the books. The unit test is still failing. The concurrent dictionary protects from multiple threads being added and removed unpredictably, but does not offer any protection on the items in the collection themselves. This means that updates to the objects in the collection are not thread safe.</p>
<p>Let's take a closer look at race conditions in a multithreaded environment to understand why this is the case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A race condition illustration</h1>
                </header>
            
            <article>
                
<p>The following sequence of diagrams visualize what is happening conceptually between two threads: <strong>ThreadA</strong> and <strong>ThreadB</strong>. The first diagram shows both threads without any values from the collection:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-207 image-border" src="assets/fe27049f-ade1-485f-a255-bcd56290bbc6.png" style=""/></div>
<p><span>The following diagram shows that </span>both threads read from the collection of the book with the name of <kbd>Chester</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-208 image-border" src="assets/b2b80704-df53-4c39-b3c5-e7176a6c2467.png" style=""/></div>
<p>The following diagram shows that <strong>ThreadA</strong> updates the book by increasing the quantity by <kbd>4</kbd>, while <strong>ThreadB</strong> updates the book by increasing the quantity by <kbd>3</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-209 image-border" src="assets/b5a8650f-1f3d-4414-9109-f15046958d42.png" style=""/></div>
<p>Then, when the updated book is persisted back to the collection, we have an unknown quantity as the result, as shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-210 image-border" src="assets/f4a99992-46d0-4eb7-a464-d82126476461.png" style=""/></div>
<p>To avoid this race condition, we need to block other threads while an update operation is taking place. In <kbd>InventoryContext</kbd>, blocking other threads takes the form of a lock around the update of the book quantity:</p>
<pre>public bool UpdateQuantity(string name, int quantity)<br/>{<br/>    <strong>lock (_lock)</strong><br/>    {<br/>        _books[name].Quantity += quantity;<br/>    }<br/><br/>    return true;<br/>}</pre>
<p>The unit test now completes without error, as the additional locks prevent unpredictable race conditions.</p>
<div class="packt_infobox">The <kbd>InventoryContext</kbd> class is still not complete as it has been completed just enough to illustrate the singleton and repository patterns. In later chapters, the <kbd>InventoryContext</kbd> class will be adapted to use Entity Framework, an <strong>Object Relational Mapping</strong> (<strong>ORM</strong>) <span>framework</span>. At this point, the <kbd>InventoryContext</kbd> class will be improved to support additional functionality.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AddInventoryCommand</h1>
                </header>
            
            <article>
                
<p>With our repository available, the three <kbd>InventoryCommand</kbd> classes can be completed. The first, <kbd>AddInventoryCommand</kbd>, is shown as follows:</p>
<pre>internal class AddInventoryCommand : NonTerminatingCommand, IParameterisedCommand<br/>{<br/>    private readonly IInventoryContext _context;<br/><br/>    internal AddInventoryCommand(IUserInterface userInterface, IInventoryContext context) <br/>                                                            : base(userInterface)<br/>    {<br/>        _context = context;<br/>    }<br/><br/>    public string InventoryName { get; private set; }<br/><br/>    /// &lt;summary&gt;<br/>    /// AddInventoryCommand requires name<br/>    /// &lt;/summary&gt;<br/>    /// &lt;returns&gt;&lt;/returns&gt;<br/>    public bool GetParameters()<br/>    {<br/>        if (string.IsNullOrWhiteSpace(InventoryName))<br/>            InventoryName = GetParameter("name");<br/><br/>        return !string.IsNullOrWhiteSpace(InventoryName);<br/>    }<br/><br/>    protected override bool InternalCommand()<br/>    {<br/>        return _context.AddBook(InventoryName); <br/>    }<br/>}</pre>
<p>The first thing to note is that the repository, <kbd>IInventoryContext</kbd>, is injected in the constructor along with the <kbd>IUserInterface</kbd> interface described in the previous chapter. The command also requires a single parameter, <kbd>name</kbd><em>, </em>to be supplied. This is retrieved in the <kbd>GetParameters</kbd> method that implements the <kbd>IParameterisedCommand</kbd> interface, which was also covered in the previous chapter. The command is then run in the <kbd>InternalCommand</kbd> method, which simply executes the <kbd>AddBook</kbd> method on the repository and returns a bool indicating whether the command has executed successfully.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TestInventoryContext</h1>
                </header>
            
            <article>
                
<p>Similar to <kbd><span>TestUserInterface</span></kbd><span> </span>used in the previous chapter, the <kbd>TestInventoryContext</kbd> class will be used to mock the behavior of our repository by implementing the <kbd>IInventoryContext</kbd> interface. This class will support the three methods of the interface, as well as supporting two additional methods for retrieving the books that have been added to the collection during the unit test and for retrieving the books that have been updated during the unit test.</p>
<p>To support the <kbd>TestInventoryContext</kbd> class, two collections will be used:</p>
<pre>private readonly IDictionary&lt;string, Book&gt; _seedDictionary;<br/>private readonly IDictionary&lt;string, Book&gt; _books;</pre>
<p>The first is used to store the starting collection of the books, while the second is used to store the final collection of the books. The constructor is shown in the following code; note how the dictionaries are copies of each other:</p>
<pre>public TestInventoryContext(IDictionary&lt;string, Book&gt; books)<br/>{<br/>    _seedDictionary = books.ToDictionary(book =&gt; book.Key,<br/>                                         book =&gt; new Book { Id = book.Value.Id, <br/>                                                            Name = book.Value.Name, <br/>                                                            Quantity = book.Value.Quantity });<br/>    _books = books;<br/>}</pre>
<p>The <kbd>IInventoryContext</kbd> methods are written to update and return just one of the collections, as follows:</p>
<pre>public Book[] GetBooks()<br/>{<br/>    return _books.Values.ToArray();<br/>}<br/><br/>public bool AddBook(string name)<br/>{<br/>    _books.Add(name, new Book() { Name = name });<br/><br/>    return true;<br/>}<br/><br/>public bool UpdateQuantity(string name, int quantity)<br/>{<br/>    _books[name].Quantity += quantity;<br/><br/>    return true;<br/>}</pre>
<p>At the end of the unit test, the two remaining methods can be used to determine the difference between the starting and ending collections:</p>
<pre>public Book[] GetAddedBooks()<br/>{<br/>    return _books.Where(book =&gt; !_seedDictionary.ContainsKey(book.Key))<br/>                                                    .Select(book =&gt; book.Value).ToArray();<br/>}<br/><br/>public Book[] GetUpdatedBooks()<br/>{ <br/>    return _books.Where(book =&gt; _seedDictionary[book.Key].Quantity != book.Value.Quantity)<br/>                                                    .Select(book =&gt; book.Value).ToArray();<br/>}</pre>
<div class="packt_infobox">There is some confusion in the software industry around the differences between mocks, stubs, fakes, and other terms used to identify and/or categorize types or services used in testing that are not suitable for production but are necessary for the unit test. These dependencies may have functionality that is different, missing, and/or the same as their <em>real</em> counterparts.<br/>
<br/>
For example, the <kbd>TestUserInterface</kbd> class could be referred to as a mock as it provides some expectation (for example, assert statements) of the unit test while the <kbd>TestInventoryContext</kbd> class would be a fake, as it provides a working implementation. In this book, we will not follow these classifications too strictly.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AddInventoryCommandTest</h1>
                </header>
            
            <article>
                
<p><kbd>AddInventoryCommandTest</kbd> was updated by the team to verify the <kbd>AddInventoryCommand</kbd> functionality. This test will verify the adding of a single book to an existing inventory. The first part of the test is to define what is expected of the interface, which is only a single prompt to receive the new book name (remember that the <kbd>TestUserInterface</kbd> class takes three parameters: expected input, expected messages, and expected warnings):</p>
<pre>const string expectedBookName = "AddInventoryUnitTest";<br/>var expectedInterface = new Helpers.TestUserInterface(<br/>    new List&lt;Tuple&lt;string, string&gt;&gt;<br/>    {<br/>        new Tuple&lt;string, string&gt;("Enter name:", expectedBookName)<br/>    },<br/>    new List&lt;string&gt;(),<br/>    new List&lt;string&gt;()<br/>);</pre>
<p class="mce-root"><span>The</span> <kbd>TestInventoryContext</kbd><span> class will be initialized with a single book simulating an existing book collection:</span></p>
<pre>var context = new TestInventoryContext(new Dictionary&lt;string, Book&gt;<br/>{<br/>    { "Gremlins", new Book { Id = 1, Name = "Gremlins", Quantity = 7 } }<br/>});</pre>
<p>The following code snippet shows the creation of <kbd>AddInventoryCommand</kbd>, the running of the command, and the assert statements used to validate that the command ran successfully:</p>
<pre>// create an instance of the command<br/>var command = new AddInventoryCommand(expectedInterface, context);<br/><br/>// add a new book with parameter "name"<br/>var result = command.RunCommand();<br/><br/>Assert.IsFalse(result.shouldQuit, "AddInventory is not a terminating command.");<br/>Assert.IsTrue(result.wasSuccessful, "AddInventory did not complete Successfully.");<br/><br/>// verify the book was added with the given name with 0 quantity<br/>Assert.AreEqual(1, context.GetAddedBooks().Length, "AddInventory should have added one new book.");<br/><br/>var newBook = context.GetAddedBooks().First();<br/>Assert.AreEqual(expectedBookName, newBook.Name, "AddInventory did not add book successfully."); </pre>
<p>After the command is run, the result is verified to have run without error and that the command is not a terminating command. The rest of the <kbd>Assert</kbd> statements validate the expectation that only one book was added with the expected name.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">UpdateQuantityCommand</h1>
                </header>
            
            <article>
                
<p><kbd>UpdateQuantityCommand</kbd> is very similar to <kbd>AddInventoryCommand</kbd> and its source is as follows:</p>
<pre>internal class UpdateQuantityCommand : NonTerminatingCommand, IParameterisedCommand<br/>{<br/>    private readonly IInventoryContext _context; <br/><br/>    internal UpdateQuantityCommand(IUserInterface userInterface, IInventoryContext context) <br/>                                                                            : base(userInterface)<br/>    {<br/>        _context = context;<br/>    }<br/><br/>    internal string InventoryName { get; private set; }<br/><br/>    private int _quantity;<br/>    internal int Quantity { get =&gt; _quantity; private set =&gt; _quantity = value; }<br/><br/>    ...<br/>}</pre>
<p>Like <kbd>AddInventoryCommand</kbd>, the <kbd>UpdateInventoryCommand</kbd> command is a non-terminating command with parameters. Therefore, it extends the <kbd>NonTerminatingCommand</kbd> base class and implements the <kbd>IParameterisedCommand</kbd> interface. Similarly, the dependencies for <kbd>IUserInterface</kbd> and <kbd>IInventoryContext</kbd> are injected in the constructor:</p>
<pre>    /// &lt;summary&gt;<br/>    /// UpdateQuantity requires name and an integer value<br/>    /// &lt;/summary&gt;<br/>    /// &lt;returns&gt;&lt;/returns&gt;<br/>    public bool GetParameters()<br/>    {<br/>        if (string.IsNullOrWhiteSpace(InventoryName))<br/>            InventoryName = GetParameter("name");<br/><br/>        if (Quantity == 0)<br/>            int.TryParse(GetParameter("quantity"), out _quantity);<br/><br/>        return !string.IsNullOrWhiteSpace(InventoryName) &amp;&amp; Quantity != 0;<br/>    }   </pre>
<p>The <kbd>UpdateQuantityCommand</kbd> class does have an additional parameter, <em>quantity</em>, which is determined as part of the <kbd>GetParameters</kbd> method.</p>
<p>Finally, the quantity of a book is updated via the repository's <kbd>UpdateQuantity</kbd> method in the <kbd>InternalCommand</kbd> override method:</p>
<pre>    protected override bool InternalCommand()<br/>    {<br/>        return _context.UpdateQuantity(InventoryName, Quantity);<br/>    }</pre>
<p>Now that the <kbd>UpdateQuantityCommand</kbd> class has been defined, the following section will add a unit test to validate the command.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">UpdateQuantityCommandTest</h1>
                </header>
            
            <article>
                
<p><kbd>UpdateQuantityCommandTest</kbd> contains a test to validate a scenario where a book is updated in an existing collection. The creation of the expected interface and existing collection are shown in the following code (note that the test involves adding <kbd>6</kbd> to the quantity of an existing book):</p>
<pre>const string expectedBookName = "UpdateQuantityUnitTest";<br/>var expectedInterface = new Helpers.TestUserInterface(<br/>    new List&lt;Tuple&lt;string, string&gt;&gt;<br/>    {<br/>        new Tuple&lt;string, string&gt;("Enter name:", expectedBookName),<br/>        <strong>new Tuple&lt;string, string&gt;("Enter quantity:", "6")</strong><br/>    },<br/>    new List&lt;string&gt;(),<br/>    new List&lt;string&gt;()<br/>);<br/><br/>var context = new TestInventoryContext(new Dictionary&lt;string, Book&gt;<br/>{<br/>    { "Beavers", new Book { Id = 1, Name = "Beavers", Quantity = 3 } },<br/>    <strong>{ expectedBookName, new Book { Id = 2, Name = expectedBookName, Quantity = 7 } },</strong><br/>    { "Ducks", new Book { Id = 3, Name = "Ducks", Quantity = 12 } }<br/>});</pre>
<p>The following code block shows the running of the command and the initial validation of the successful run of the non-terminating command:</p>
<pre>// create an instance of the command<br/>var command = new UpdateQuantityCommand(expectedInterface, context);<br/>            <br/>var result = command.RunCommand();<br/><br/>Assert.IsFalse(result.shouldQuit, "UpdateQuantity is not a terminating command.");<br/>Assert.IsTrue(result.wasSuccessful, "UpdateQuantity did not complete Successfully.");</pre>
<p>The expectation of the test is that no new books would be added and that the existing book's quantity of 7 will be increased by 6, resulting in a new quantity of 13:</p>
<pre>Assert.AreEqual(0, context.GetAddedBooks().Length, <br/>                    "UpdateQuantity should not have added one new book.");<br/><br/>var updatedBooks = context.GetUpdatedBooks();<br/>Assert.AreEqual(1, updatedBooks.Length, <br/>                    "UpdateQuantity should have updated one new book.");<br/>Assert.AreEqual(expectedBookName, updatedBooks.First().Name, <br/>                    "UpdateQuantity did not update the correct book.");<br/>Assert.AreEqual(13, updatedBooks.First().Quantity, <br/>                    "UpdateQuantity did not update book quantity successfully.");</pre>
<p>With the <kbd>UpdateQuantityCommand</kbd> class added, the ability to retrieve the inventory will be added in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GetInventoryCommand</h1>
                </header>
            
            <article>
                
<p>The <kbd>GetInventoryCommand</kbd> command differs from the previous two commands because it does not require any parameters. It does use the <kbd>IUserInterface</kbd> dependency and the <kbd>IInventoryContext</kbd> dependency to write the content of the collection. This is shown as follows:</p>
<pre>internal class GetInventoryCommand : NonTerminatingCommand<br/>{<br/>    private readonly IInventoryContext _context;<br/>    internal GetInventoryCommand(IUserInterface userInterface, IInventoryContext context) <br/>                                                           : base(userInterface)<br/>    {<br/>        _context = context;<br/>    }<br/><br/>    protected override bool InternalCommand()<br/>    {<br/>        foreach (var book in _context.GetBooks())<br/>        {<br/>            Interface.WriteMessage($"{book.Name,-30}\tQuantity:{book.Quantity}"); <br/>        }<br/><br/>        return true;<br/>    }<br/>}</pre>
<p>With the <kbd>GetInventoryCommand</kbd> command implemented, the next step is to add a new test.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GetInventoryCommandTest</h1>
                </header>
            
            <article>
                
<p><kbd>GetInventoryCommandTest</kbd> covers a scenario when the <kbd>GetInventoryCommand</kbd> command is used to retrieve the collection of books. The test will define the expected messages (remember that the first parameter is for the parameters, the second parameter is for messages, and the third parameter is for warnings) that will occur when testing the user interface:</p>
<pre>var expectedInterface = new Helpers.TestUserInterface(<br/>    new List&lt;Tuple&lt;string, string&gt;&gt;(),<br/>    new List&lt;string&gt;<br/>    {<br/>        "Gremlins                      \tQuantity:7",<br/>        "Willowsong                    \tQuantity:3",<br/>    },<br/>    new List&lt;string&gt;()<br/>);</pre>
<p>These messages will correspond to the mock repository, as follows:</p>
<pre>var context = new TestInventoryContext(new Dictionary&lt;string, Book&gt;<br/>{<br/>    { "Gremlins", new Book { Id = 1, Name = "Gremlins", Quantity = 7 } },<br/>    { "Willowsong", new Book { Id = 2, Name = "Willowsong", Quantity = 3 } },<br/>});</pre>
<p>The unit test runs the command with the mock dependencies. It verifies that the command executed without error and that the command is not a terminating command:</p>
<pre>// create an instance of the command<br/>var command = new GetInventoryCommand(expectedInterface, context); <br/>var result = command.RunCommand();<br/><br/>Assert.IsFalse(result.shouldQuit, "GetInventory is not a terminating command.");</pre>
<p>The expected messages are validating in <kbd>TestUserInterface</kbd> and, hence, the only thing that remains for the unit test to do is to make sure that no books were mysteriously added or updated by the command:</p>
<pre>Assert.AreEqual(0, context.GetAddedBooks().Length, "GetInventory should not have added any books.");<br/>Assert.AreEqual(0, context.GetUpdatedBooks().Length, "GetInventory should not have updated any books.");</pre>
<p>Now that suitable unit tests for the <kbd>GetInventoryCommand</kbd> class have been added, we'll introduce the factory pattern in order to manage the creation of specific commands.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The factory pattern</h1>
                </header>
            
            <article>
                
<p>The next pattern applied by the team is the GoF factory pattern. The pattern introduces a <strong>creator</strong> whose responsibility is the instantiation of implementations of a specific type. Its purpose is to encapsulate the complexity around constructing types. The factory pattern allows for more flexibility as the application changes, by limiting the amount of required change compared to whether the construction was in the calling class. This is because the complexity of the construction is in one location, instead of distributed in multiple locations across the application.</p>
<p>In the FlixOne example, <kbd>InventoryCommandFactory</kbd> implements the pattern and shields the details of constructing each of the different <kbd>InventoryCommand</kbd> instances. In this scenario, the input received from the console application will be used to determine the concrete implementation of <kbd>InventoryCommand</kbd> to return. It is important to note that the return type is the <kbd>InventoryCommand</kbd> <span>abstract class, </span>thus shielding the calling class from the details of the concrete class.</p>
<p><kbd>InventoryCommandFactory</kbd> is shown in the following code block. But, for now, focus on the <kbd>GetCommand</kbd> method as this implements the factory pattern:</p>
<pre>public class InventoryCommandFactory : IInventoryCommandFactory<br/>{<br/>    private readonly IUserInterface _userInterface;<br/>    private readonly IInventoryContext _context = InventoryContext.Instance;<br/><br/>    public InventoryCommandFactory(IUserInterface userInterface)<br/>    {<br/>        _userInterface = userInterface;<br/>    }<br/><br/>    ...<br/>}</pre>
<p><kbd>GetCommand</kbd><span> uses a given string to determine the specific implementation of </span><kbd>InventoryCommand</kbd><span> to return:</span></p>
<div>
<pre>public InventoryCommand GetCommand(string input)<br/>{<br/>    switch (input)<br/>    {<br/>        case "q":<br/>        case "quit":<br/>            return new QuitCommand(_userInterface);<br/>        case "a":<br/>        case "addinventory":<br/>            return new AddInventoryCommand(_userInterface, _context);<br/>        case "g":<br/>        case "getinventory":<br/>            return new GetInventoryCommand(_userInterface, _context);<br/>        case "u":<br/>        case "updatequantity":<br/>            return new UpdateQuantityCommand(_userInterface, _context);<br/>        case "?":<br/>            return new HelpCommand(_userInterface);<br/>        default:<br/>            return new UnknownCommand(_userInterface);<br/>    }<br/>}</pre></div>
<p>All commands require <kbd>IUserInterface</kbd> to be supplied, but some also require access to the repository. These will be supplied with the singleton instance of <kbd>IInventoryContext</kbd>.</p>
<div class="packt_infobox">The factory pattern is often used with an Interface as the return type. It is illustrated here as the <kbd>InventoryCommand</kbd> <span>base class</span>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit tests</h1>
                </header>
            
            <article>
                
<p>At first glance, the idea of building unit tests for such a simple class seemed like a waste of the team's time. Two important issues were uncovered by constructing the unit tests that might have gone undetected. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Issue one â€“ UnknownCommand</h1>
                </header>
            
            <article>
                
<p>The first issue was what to do when a command is received that does not match any of the defined <kbd>InventoryCommand</kbd> inputs. After reviewing the requirements, the team noticed they missed this requirement, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-211 image-border" src="assets/2609a169-37d7-4a74-8aac-65d25b8c1a77.png" style=""/></div>
<p>The team decided to introduce a new <kbd>InventoryCommand</kbd> class, <kbd>UnknownCommand</kbd>, to handle this situation. The <kbd>UnknownCommand</kbd> class should print a warning message to the console (via the <kbd>IUserInterface</kbd> <kbd>WriteWarning</kbd> method), should not cause the application to end, and should return false to indicate that the command was not run successfully. The implementation details are shown in the following code:</p>
<pre>internal class UnknownCommand : NonTerminatingCommand<br/>{ <br/>    internal UnknownCommand(IUserInterface userInterface) : base(userInterface)<br/>    {<br/>    }<br/><br/>    protected override bool InternalCommand()<br/>    { <br/>        Interface.WriteWarning("Unable to determine the desired command."); <br/><br/>        return false;<br/>    }<br/>}</pre>
<p>The unit test created for <kbd>UnknownCommand</kbd> will test for the warning message as well as the two Boolean values returned by the <kbd>InternalCommand</kbd> method:</p>
<pre>[TestClass]<br/>public class UnknownCommandTests<br/>{<br/>    [TestMethod]<br/>    public void UnknownCommand_Successful()<br/>    {<br/>        var expectedInterface = new Helpers.TestUserInterface(<br/>            new List&lt;Tuple&lt;string, string&gt;&gt;(),<br/>            new List&lt;string&gt;(),<br/>            new List&lt;string&gt;<br/>            {<br/>                "Unable to determine the desired command."<br/>            }<br/>        ); <br/><br/>        // create an instance of the command<br/>        var command = new UnknownCommand(expectedInterface);<br/>            <br/>        var result = command.RunCommand();<br/><br/>        Assert.IsFalse(result.shouldQuit, "Unknown is not a terminating command.");<br/>        Assert.IsFalse(result.wasSuccessful, "Unknown should not complete Successfully.");<br/>    }<br/>}</pre>
<p><kbd>UnknownCommandTests</kbd> covers the commands that require testing. Next, tests around <kbd>InventoryCommandFactory</kbd> will be implemented.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">InventoryCommandFactoryTests</h1>
                </header>
            
            <article>
                
<p><kbd>InventoryCommandFactoryTests</kbd> contains unit tests related to <kbd>InventoryCommandFactory</kbd>. Because each test will have a similar pattern of constructing <kbd>InventoryCommandFactory</kbd> and its <kbd>IUserInterface</kbd> dependency and then running the <kbd>GetCommand</kbd> method, a shared method is created that will run when the test initializes:</p>
<pre>[TestInitialize]<br/>public void Initialize()<br/>{<br/>    var expectedInterface = new Helpers.TestUserInterface(<br/>        new List&lt;Tuple&lt;string, string&gt;&gt;(),<br/>        new List&lt;string&gt;(),<br/>        new List&lt;string&gt;()<br/>    ); <br/><br/>    Factory = new InventoryCommandFactory(expectedInterface);<br/>}</pre>
<p class="mce-root"/>
<p>The <kbd>Initialize</kbd> method constructs a stubbed <kbd>IUserInterface</kbd> and sets the <kbd>Factory</kbd> <span>property</span>. The individual unit tests then take a simple form of validating that the object returned is the correct type. First, an instance of the <kbd>QuitCommand</kbd> <span><span>class </span></span>should be returned when the user enters <kbd>"q"</kbd> or <kbd>"quit"</kbd>, as follows:</p>
<pre>[TestMethod]<br/>public void QuitCommand_Successful()<br/>{ <br/>    Assert.IsInstanceOfType(Factory.GetCommand("q"), typeof(QuitCommand), <br/>                                                            "q should be QuitCommand");<br/>    Assert.IsInstanceOfType(Factory.GetCommand("quit"), typeof(QuitCommand), <br/>                                                            "quit should be QuitCommand");<br/>}</pre>
<p>The <kbd>QuitCommand_Successful</kbd> test method validates that when the <kbd>InventoryCommandFactory</kbd> method, <kbd>GetCommand</kbd>, is run, the object returned is a specific instance of the <kbd>QuitCommand</kbd> type. <kbd>HelpCommand</kbd> is only available when <kbd>"?"</kbd> is submitted:</p>
<pre>[TestMethod]<br/>public void HelpCommand_Successful()<br/>{<br/>    Assert.IsInstanceOfType(Factory.GetCommand("?"), typeof(HelpCommand), "h should be HelpCommand"); <br/>}</pre>
<p>The team did add a test for <kbd>UnknownCommand</kbd> that validated how <kbd>InventoryCommand</kbd> would respond when given a value not matching an existing command:</p>
<pre>[TestMethod]<br/>public void UnknownCommand_Successful()<br/>{<br/>    Assert.IsInstanceOfType(Factory.GetCommand("add"), typeof(UnknownCommand), <br/>                                                        "unmatched command should be UnknownCommand");<br/>    Assert.IsInstanceOfType(Factory.GetCommand("addinventry"), typeof(UnknownCommand), <br/>                                                        "unmatched command should be UnknownCommand");<br/>    Assert.IsInstanceOfType(Factory.GetCommand("h"), typeof(UnknownCommand), <br/>                                                        "unmatched command should be UnknownCommand");<br/>    Assert.IsInstanceOfType(Factory.GetCommand("help"), typeof(UnknownCommand), <br/>                                                        "unmatched command should be UnknownCommand");<br/>}</pre>
<p>With the test methods in place, we can now cover a scenario where a command is given that does not match a known command in the application. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Issue two â€“ case-insensitive text commands</h1>
                </header>
            
            <article>
                
<p>The second issue was uncovered when the requirements were reviewed again, stating that the commands should not be case-sensitive:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-212 image-border" src="assets/10cf9ef0-f9f0-459d-969c-1ded9e9e093e.png" style=""/></div>
<p>With the test for <kbd>UpdateInventoryCommand</kbd>, <kbd>InventoryCommandFactory</kbd> was found to be case-sensitive using the following test:</p>
<pre>[TestMethod]<br/>public void UpdateQuantityCommand_Successful()<br/>{<br/>    Assert.IsInstanceOfType(Factory.GetCommand("u"), <br/>                            typeof(UpdateQuantityCommand), <br/>                            "u should be UpdateQuantityCommand");<br/>    Assert.IsInstanceOfType(Factory.GetCommand("updatequantity"), <br/>                            typeof(UpdateQuantityCommand), <br/>                            "updatequantity should be UpdateQuantityCommand");<br/>    Assert.IsInstanceOfType(Factory.GetCommand("UpdaTEQuantity"), <br/>                            typeof(UpdateQuantityCommand), <br/>                            "UpdaTEQuantity should be UpdateQuantityCommand");<br/>}</pre>
<p>Fortunately, this test was easy to solve by applying a <kbd>ToLower()</kbd> method to the input before determining the command, as follows:</p>
<pre>public InventoryCommand GetCommand(string input)<br/>{<br/>    switch (input.ToLower())<br/>    {<br/>        ...<br/>    }<br/>}</pre>
<p>This scenario highlights both the value of the <kbd>Factory</kbd> method and the value of leveraging unit tests to help validate requirements during development and not relying on user testing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Features in .NET Core</h1>
                </header>
            
            <article>
                
<p><a href="3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml">Chapter 3</a><span>, </span><em>Implementing Design Patterns â€“ Basics Part 1,</em> and the first part of this chapter have illustrated the GoF patterns without using any frameworks. It is worth covering this as, sometimes, a framework is not available for a specific pattern or applicable in a particular scenario. Additionally, it is important to understand what functionality the framework is providing in order to know when a pattern should be used. The rest of this chapter will look at a couple of features that .NET Core provides that support some of the patterns we have covered so far.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IServiceCollection</h1>
                </header>
            
            <article>
                
<p>.NET Core was designed with <strong>Dependency Injection</strong> (<strong>DI</strong>) built-in to the framework. Typically, the start of a .NET Core application contains the set up of the DI for an application that primarily contains the creation of a collection of services. The framework uses these services to supply the dependencies when the application requires them. The services provide the foundation of a robust <strong>Inversion of Control</strong> (<strong>IoC</strong>) framework and are arguably one of the coolest features of .NET Core. This section will complete the console application and demonstrate how .NET Core supports building a sophisticated IoC framework based on the <kbd>IServiceCollection</kbd> interface.</p>
<p>The <kbd>IServiceCollection</kbd> interface is used to define the services available to the container that implements <kbd>IServiceProvider</kbd> <span>interface. </span>The services themselves are types that will be injected at runtime when required by the application. For example, <kbd>ConsoleUserInterface</kbd> <span>interface, </span>which was defined previously, will be a service injected at runtime. This is shown in the following code:</p>
<pre>IServiceCollection services = new ServiceCollection();<br/>services.AddTransient&lt;IUserInterface, ConsoleUserInterface&gt;();</pre>
<p>In the preceding code, <kbd>ConsoleUserInterface</kbd> <span>interface </span>is being added as a service that implements the <kbd>IUserInterface</kbd> interface. If the DI is providing another type that requires a <kbd>IUserInterface</kbd> <span>interface </span>dependency, then <kbd>ConsoleUserInterface</kbd> <span>interface </span>will be used. For example, <kbd>InventoryCommandFactory</kbd> is also added to the services, as shown in the following code:</p>
<pre>services.AddTransient&lt;IInventoryCommandFactory, InventoryCommandFactory&gt;();</pre>
<p><kbd>InventoryCommandFactory</kbd> has a constructor that requires an implementation of the <kbd>IUserInterface</kbd> interface:</p>
<pre>public class InventoryCommandFactory : IInventoryCommandFactory<br/>{<br/>    private readonly IUserInterface _userInterface;<br/><br/>    public InventoryCommandFactory(<strong>IUserInterface userInterface</strong>)<br/>    {<br/>        _userInterface = userInterface;<br/>    }<br/>    ...<br/>}</pre>
<p>Later, an instance of <kbd>InventoryCommandFactory</kbd> is requested, as follows:</p>
<pre>IServiceProvider serviceProvider = services.BuildServiceProvider();<br/>var service = serviceProvider.GetService&lt;<strong>IInventoryCommandFactory</strong>&gt;();<br/>service.GetCommand("a");</pre>
<p>Then, an instance of <kbd>IUserInterface</kbd> (in this application it is the registered <kbd>ConsoleUserInterface</kbd>) is instantiated and supplied to the constructor of <kbd>InventoryCommandFactory</kbd>.</p>
<div class="packt_infobox">There are different types of service <em>lifetimes </em>that can be specified when registering a service. A lifetime governs how the types will be instantiated and include Transient, Scoped, and Singleton. Transient means the service is created each time it is requested. Scope will be covered later when we look at website-related patterns and in particular where services are created per web request. Singleton behaves like the singleton pattern we covered earlier, <span>and will also be covered later in this chapter</span>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CatalogService</h1>
                </header>
            
            <article>
                
<p>The <kbd>CatalogService</kbd> <span>interface</span> represents the console application the team is building and is described as having a single <kbd>Run</kbd> method, as shown in the <kbd>ICatalogService</kbd> interface:</p>
<pre>interface ICatalogService<br/>{<br/>    void Run();<br/>}</pre>
<p>The service has two dependencies, <kbd>IUserInterface</kbd> and <kbd>IInventoryCommandFactory</kbd>, and they will be injected into the constructor and stored as local variables:</p>
<pre>public class CatalogService : ICatalogService<br/>{<br/>    private readonly IUserInterface _userInterface;<br/>    private readonly IInventoryCommandFactory _commandFactory;<br/><br/>    public CatalogService(IUserInterface userInterface, IInventoryCommandFactory commandFactory)<br/>    {<br/>        _userInterface = userInterface;<br/>        _commandFactory = commandFactory;<br/>    }<br/>    ...<br/>}</pre>
<p>The <kbd>Run</kbd> method is based on the earlier design by the team shown in <a href="3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml">Chapter 3</a>, <em>Implementing Design Patterns â€“ Basics Part 1.</em> It prints a greeting and then loops until the quit inventory command is entered by the user. Each loop will perform the command and, if the command is not successful, it will print a help message:</p>
<pre>public void Run()<br/>{<br/>    Greeting();<br/><br/>    var response = _commandFactory.GetCommand("?").RunCommand();<br/><br/>    while (!response.shouldQuit)<br/>    {<br/>        // look at this mistake with the ToLower()<br/>        var input = _userInterface.ReadValue("&gt; ").ToLower();<br/>        var command = _commandFactory.GetCommand(input);<br/><br/>        response = command.RunCommand();<br/><br/>        if (!response.wasSuccessful)<br/>        {<br/>            _userInterface.WriteMessage("Enter ? to view options.");<br/>        }<br/>    }<br/>}</pre>
<p>Now that we have the <kbd>CatalogService</kbd> interface ready, the next step will be to put everything together. The next section will do this using .NET Core.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IServiceProvider</h1>
                </header>
            
            <article>
                
<p>With <kbd>CatalogService</kbd> defined, the team is finally able to put everything together in .NET Core. The start of all applications, that is, EXE programs, is the <kbd>Main</kbd> method, and .NET Core is no exception. The program is shown in the following code:</p>
<pre>class Program<br/>{<br/>    private static void Main(string[] args)<br/>    {<br/>        IServiceCollection services = new ServiceCollection();<br/>        ConfigureServices(services);<br/>        IServiceProvider serviceProvider = services.BuildServiceProvider();<br/><br/>        var service = serviceProvider.GetService&lt;ICatalogService&gt;();<br/>        service.Run();<br/><br/>        Console.WriteLine("CatalogService has completed.");<br/>    }<br/><br/>    private static void ConfigureServices(IServiceCollection services)<br/>    {<br/>        // Add application services.<br/>        services.AddTransient&lt;IUserInterface, ConsoleUserInterface&gt;(); <br/>        services.AddTransient&lt;ICatalogService, CatalogService&gt;();<br/>        services.AddTransient&lt;IInventoryCommandFactory, InventoryCommandFactory&gt;(); <br/>    }<br/>}</pre>
<p>In the <kbd>ConfigureServices</kbd> method, different types are added to the IoC container including <kbd>ConsoleUserInterface</kbd>, <kbd>CatalogService</kbd>, and <kbd>InventoryCommandFactory</kbd> classes. The <kbd>ConsoleUserInterface</kbd> and <kbd><span>InventoryCommandFactory</span></kbd><span> class </span>will be injected as required and the <kbd>CatalogService</kbd> class will be explicitly retrieved from the <kbd>IServiceProvider</kbd> interface built from the <kbd>ServiceCollection</kbd> object containing the added types. The program <em>runs</em> until the <kbd>CatalogService</kbd> <kbd>Run</kbd> method completes. </p>
<div class="packt_infobox">In <a href="fd71001a-4673-4391-a10b-2490e07f135e.xhtml">Chapter 5</a>, <em>Implementing Design Patterns - .NET Core</em>, the singleton pattern will be revisited to use the .NET Core built-in capabilities by using the <kbd>IServiceCollection</kbd>, <kbd>AddSingleton</kbd> method to control the <kbd>InventoryContext</kbd> instance.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Console application</h1>
                </header>
            
            <article>
                
<p>The console application, when running from the command line, is simple, but it is a foundation of well-designed code adhering to the SOLID principles discussed in<span> </span><a href="3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml">Chapter 3</a>,<span> </span><em>Implementing Design Patterns â€“ Basics Part 1</em>. When run, the application provides a simple greeting and displays a help message, including the command's supports and examples:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2b227f12-9b64-4501-9190-7385cf1f6d34.png" style=""/></div>
<p class="mce-root"><span>The application then loops through the </span>commands<span> until a quit command is received. The following screenshot illustrates its functionality:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/23375dec-001c-4064-9278-19da5d745827.png" style=""/></div>
<p>This was not the most impressive of console applications, but it served to illustrated many principles and patterns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Similar to <a href="3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml">Chapter 3</a>, <em>Implementing Design Patterns â€“ Basics Part 1, </em>this chapter continued the description of building an inventory management console application for FlixOne, in order to show practical examples of using <strong>Object-Oriented Programming</strong> (<strong>OOP</strong>) <span>design </span>patterns. In this chapter,<em> </em>the GoF's singleton and factory patterns were the focus. These two patterns have a particularly important role to play in .NET Core applications and will be used often in the following chapters. An introduction to using the built-in framework to provide an IoC container was also covered in this chapter.</p>
<p>This chapter finished with a working inventory management console application based on the requirements determined in <a href="3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml">Chapter 3</a>, <em>Implementing Design Patterns â€“ Basics Part 1</em>. These requirements were the basis of the unit tests created in both chapters and were used to illustrate TDD. The team has a higher level of confidence that the application will pass the <strong>User Acceptance Testing</strong> (<strong>UAT</strong>) by having a suite of tests that verify the features required for this phase of development.</p>
<p>In the next chapter, we will continue with the description of building the inventory management application. The focus will move from basic OOP patterns to using the .NET Core framework to implement different patterns. For example, the singleton pattern introduced in this chapter will be refactored to use the capability of <kbd>IServiceCollection</kbd> to create a singleton, and we will also take a closer look at its DI capabilities. Additionally, the application will be extended to support logging using a variety of logging providers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>The following questions will allow you to consolidate the information contained in this chapter:</span></p>
<ol>
<li>Provide an example why using a singleton <strong>would not</strong> be a good mechanism for limiting access to a shared resource.</li>
<li>Is the following statement true? Why or why not? <kbd>ConcurrentDictionary</kbd> prevents items in the collection from being updated by more than one thread at a time.</li>
<li>What is a race condition and why should it be avoided?</li>
<li>How does the factory pattern help to simplify code?</li>
<li>Do .NET Core applications require third-party IoC containers? </li>
</ol>


            </article>

            
        </section>
    </body></html>