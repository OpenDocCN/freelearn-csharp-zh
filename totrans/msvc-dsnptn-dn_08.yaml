- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Implement Transactions across Microservices Using the Saga Pattern
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Saga 模式在微服务之间实现事务
- en: We have just looked at database development and what we need to consider when
    building an application developed using a microservices architecture. We discussed
    the pros and cons of creating individual databases per microservice. It does allow
    each microservice to have more autonomy, allowing us to choose the best technology
    needed for the service. While it is preferred and a recommended technique, it
    does have significant drawbacks when it comes to ensuring data consistency across
    the data stores.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论了数据库开发以及在使用微服务架构开发应用程序时需要考虑的因素。我们讨论了为每个微服务创建单独数据库的优缺点。这样做确实允许每个微服务拥有更多的自主权，使我们能够选择最适合该服务的最佳技术。虽然这是一种首选且推荐的技术，但在确保数据存储之间的数据一致性方面确实存在显著的缺点。
- en: Typically, we ensure consistency through transactions. Transactions, as discussed
    earlier in this book, ensure that all data is committed or none. That way, we
    can ensure that an operation will not partially write data and that what we see
    truly reflects the state of the data being tracked.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们通过事务来确保一致性。正如本书前面所讨论的，事务确保所有数据都提交或都不提交。这样，我们可以确保操作不会部分写入数据，而我们看到的内容确实反映了正在跟踪的数据的状态。
- en: It is difficult to enforce transactions across microservices with different
    databases, but that is when we employ the *saga pattern*. This pattern helps us
    to orchestrate database operations and ensure that our operations are consistent.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有不同数据库的微服务之间强制执行事务是困难的，但这就是我们使用 saga 模式的时候。这种模式帮助我们编排数据库操作并确保我们的操作是一致的。
- en: 'After reading this chapter, we will understand how to do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，我们将了解如何进行以下操作：
- en: Use the Saga pattern to implement transactions across microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Saga 模式在微服务之间实现事务
- en: Choreograph data operations across microservices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在微服务之间编排数据操作
- en: Implement orchestration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现编排
- en: Exploring the Saga pattern
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Saga 模式
- en: We have previously explored the *database-per-service* pattern, which encourages
    us to have individual data stores per service. With this in place, each microservice
    will handle its own database and transactions internally. This presents a new
    challenge where an operation that requires several services to take part and potentially
    modify their data runs the risk of partial failures and eventually leads to data
    inconsistency in our application. This is the major drawback of this pattern choice
    as we cannot guarantee that our databases will remain in sync at all times.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前探讨了“每个服务一个数据库”的模式，这鼓励我们为每个服务拥有单独的数据存储。有了这个模式，每个微服务将内部处理自己的数据库和事务。这提出了一个新的挑战，即需要多个服务参与并可能修改其数据的操作存在部分失败的风险，最终可能导致我们的应用程序中的数据不一致。这是这种模式选择的主要缺点，因为我们无法保证我们的数据库始终同步。
- en: This is where we employ the saga pattern. You may think of a saga as a predefined
    set of steps that outline the order in which the services should be called. The
    saga pattern will also have the responsibility of providing oversight across all
    our services watching and listening, so to speak, for any signs of failure in
    any service along the way.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们要使用 saga 模式的地方。你可以把 saga 看作是一系列预定义的步骤，概述了服务应该调用的顺序。saga 模式还将负责对所有服务进行监督，可以说是在观察和监听，任何服务在执行过程中的任何失败迹象。
- en: If a failure is reported by a service, the saga will also contain a rollback
    measure for each service. So, it will proceed, in a specific order, to prompt
    each service that might have been successful before the failure to undo the change
    it made. This comes in handy since our services are decoupled and ideally will
    not communicate directly with each other.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务报告了故障，saga 还将为每个服务包含一个回滚措施。因此，它将按照特定的顺序进行，提示每个在故障之前可能已经成功的服务撤销其所做的更改。这很有用，因为我们的服务是解耦的，理想情况下不会直接相互通信。
- en: A saga is a mechanism that spans multiple services and can implement transactions
    across various data stores. We have distributed transaction options such as *two-phase
    commit*, which can require that all data stores commit or rollback. This would
    be perfect, except some NoSQL databases and message brokers are not entirely compatible
    with this model.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Saga 是一种跨越多个服务的机制，可以在各种数据存储中实现事务。我们有分布式事务选项，如 *两阶段提交*，这可能要求所有数据存储都提交或回滚。这听起来很完美，但一些
    NoSQL 数据库和消息代理与这种模型并不完全兼容。
- en: Imagine that a new patient registered with our healthcare center. This process
    will require that the patient provides their information and some essential documents,
    and books an initial appointment, which requires payment. These actions require
    four different microservices to get involved and thus, four different data stores
    will be affected.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一位新患者在我们医疗中心进行了注册。这个过程将要求患者提供他们的信息和一些基本文件，并预约初步的会诊，这需要支付费用。这些操作需要四个不同的微服务参与，因此将影响四个不同的数据存储。
- en: We can refer to an operation that spans multiple services as a *saga*. Once
    again, a saga is a sequence of local transactions. Each transaction updates the
    data target database and produces a message or event that triggers the next transaction
    operation of the saga. If one of the local transactions fails along the chain,
    the saga will execute rollbacks across the databases that were affected by the
    preceding transactions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将跨越多个服务的操作称为 *叙事式*。再次强调，叙事式是一系列本地事务。每个事务都会更新数据目标数据库，并产生一个消息或事件，触发叙事式下一个事务操作的执行。如果链中的某个本地事务失败，叙事式将在受先前事务影响的所有数据库中执行回滚操作。
- en: 'Three types of transactions are generally implemented by a saga:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 叙事式通常实现三种类型的事务：
- en: '**Compensable**: These are transactions that can be reversed by another transaction
    with the opposite effect.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可补偿的**：这些事务可以通过具有相反效果的其他事务进行撤销。'
- en: '**Retryable**: These transactions are guaranteed to succeed and are implemented
    after pivot transactions.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重试的**：这些事务保证成功，并在枢纽事务之后实现。'
- en: '**Pivot**: As the name suggests, the success or failure of these transactions
    is pivotal to the continuation of the saga. If the transaction commits, then the
    saga runs until it is completed. These transactions can be placed as a final compensable
    transaction or the first retryable transaction of the saga. They may also be implemented
    as neither.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**枢纽**：正如其名所示，这些事务的成功或失败对叙事式的继续至关重要。如果事务提交，则叙事式将继续运行，直到完成。这些事务可以放置为最终的补偿事务或叙事式的第一个可重试事务。它们也可以既不是补偿事务也不是可重试事务。'
- en: '*Figure 8.1* shows the saga pattern:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.1* 展示了叙事式模式：'
- en: '![Figure 8.1 – Each local transaction sends a message to the next service in
    the saga until the saga is completed](img/Figure_8.1_B19100.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 每个本地事务都会向叙事式中的下一个服务发送消息，直到叙事式完成](img/Figure_8.1_B19100.jpg)'
- en: Figure 8.1 – Each local transaction sends a message to the next service in the
    saga until the saga is completed
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 每个本地事务都会向叙事式中的下一个服务发送消息，直到叙事式完成
- en: As we know with every pattern, we have advantages and disadvantages, and it
    is important to consider all angles so that we can adequately plan an approach.
    Let us review some known issues and considerations that need to be taken when
    implementing this pattern.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，每个模式都有其优点和缺点，因此考虑所有角度非常重要，以便我们能够充分规划方法。让我们回顾一些已知问题和在实现此模式时需要考虑的事项。
- en: Issues and considerations
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题与考虑事项
- en: Given the fact that, up until this chapter, we would have written off the possibility
    of implementing ACID transactions across our data stores in a microservices architecture,
    we can imagine that this pattern is not easy to implement. It requires absolute
    coordination and a good understanding of all the moving parts of our application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在本章之前，我们已将微服务架构中在数据存储中实现ACID事务的可能性排除在外，我们可以想象这种模式并不容易实现。它需要绝对的协调和对我们应用程序所有动态部分的良好理解。
- en: This pattern is also difficult to debug. Given that we are implementing a singular
    function across autonomous services, we have now introduced a new touch point
    and potential point of failure for which special effort must be made to track
    and trace where the failure may have been. This complexity increases with each
    added step to the participating services of the saga.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式也难以调试。由于我们正在实现跨自主服务的单一功能，我们现在引入了一个新的接触点和潜在的故障点，必须特别努力跟踪和追踪故障可能发生的位置。随着参与叙事式服务的步骤增加，这种复杂性也在增加。
- en: We need to make sure that our saga can handle transient failures in the architecture.
    These are errors that happen during an operation that might not be permanent.
    Thus, it is prudent of us to include retry logic to ensure that a single failure
    in an attempt does not end the saga prematurely. In doing so, we also need to
    ensure that our data is consistent with each retry.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保我们的传奇可以处理架构中的短暂故障。这些是在操作过程中发生的可能不是永久性的错误。因此，包括重试逻辑以确保单个尝试中的失败不会过早地结束传奇是明智的。这样做的同时，我们还需要确保我们的数据与每次重试保持一致。
- en: This pattern is certainly not without its challenges, and it will increase the
    complexity of our application code significantly. It is not foolproof as it will
    have its fallacies, but it will certainly assist us in ensuring that our data
    is more consistent across our loosely coupled services, by either rolling back
    or compensating for operational failures.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式当然不是没有挑战，它将显著增加我们应用程序代码的复杂性。它并非万无一失，因为它会有其谬误，但它确实会帮助我们确保我们的数据在松散耦合的服务中更加一致，通过回滚或补偿操作失败来实现。
- en: Sagas are usually coordinated using either *orchestration* or *choreography*.
    Both methods have their pros and cons. Let us begin with exploring choreography.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 传奇通常使用*编排*或*舞蹈*来协调。这两种方法都有其优缺点。让我们从探索舞蹈开始。
- en: Understanding and implementing choreography
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和实现舞蹈
- en: '**Choreography** is a method of coordinating sagas where participating services
    used messages or events to notify each other of completion or failure. In this
    model, the event broker sits in between the services but does not control the
    flow of messages or the flow of the saga. This means that there is no central
    point of reference or control, and each service is simply watching for a message
    that acts as a confirmation trigger for it to start its operation.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**舞蹈**是一种协调传奇的方法，其中参与服务使用消息或事件相互通知完成或失败。在这个模型中，事件代理位于服务之间，但不控制消息流或传奇流。这意味着没有中央参考点或控制点，每个服务只是等待一个作为其操作确认触发器的消息。'
- en: '*Figure 8.2* shows the choreography flow:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.2*显示了舞蹈流程：'
- en: '![Figure 8.2 – An application request sends a message to the queue to inform
    the first service in the saga to begin, and messages flow between all participating
    services](img/Figure_8.2_B19100.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 应用请求向队列发送消息，通知传奇中的第一个服务开始，消息在所有参与的服务之间流动](img/Figure_8.2_B19100.jpg)'
- en: Figure 8.2 – An application request sends a message to the queue to inform the
    first service in the saga to begin, and messages flow between all participating
    services
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 应用请求向队列发送消息，通知传奇中的第一个服务开始，消息在所有参与的服务之间流动
- en: The main takeaway from the choreography model is that there is no central point
    of control. Each service will listen to events and decide whether it is time to
    take an action. The contents of the message will inform the service it should
    act and if it acts, it will reply with a message stating the success or failure
    of its action. If the last service of the saga is successful, then no message
    is produced, and the saga will end.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从舞蹈模型中得出的主要启示是没有中央控制点。每个服务将监听事件并决定是否采取行动。消息的内容将通知服务它应该采取行动，如果它采取行动，它将以消息的形式回复其行动的成功或失败。如果传奇的最后一个服务成功，则不会产生任何消息，传奇将结束。
- en: 'If we were to visualize this process using our user registration and appointment
    booking example mentioned earlier in this chapter, we would have a flow looking
    like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用本章前面提到的用户注册和预约预订示例来可视化此过程，我们将有一个如下所示的流程：
- en: The user submits a registration and appointment booking request (client request).
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户提交注册和预约预订请求（客户端请求）。
- en: The *registration service* stores the new user’s data and then publishes an
    event with relevant appointment and payment details. This event could be called,
    for example, `USER_CREATED`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*注册服务*存储新用户的数据，然后发布包含相关预约和付款详情的事件。例如，这个事件可以称为`USER_CREATED`。'
- en: The *payment service* listens for `USER_CREATED` events and will attempt to
    process a payment as necessary. When successful, it will produce a `PAYMENT_SUCCESS`
    event.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*支付服务*监听`USER_CREATED`事件，并将尝试处理必要的付款。如果成功，它将产生一个`PAYMENT_SUCCESS`事件。'
- en: The *appointment booking* service processes `PAYMENT_SUCCESS` events and proceeds
    to add the appointment information as expected. This service makes the booking
    arrangements and produces a `BOOKING_SUCCESS` event for the next service.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*预约预订* 服务处理 `PAYMENT_SUCCESS` 事件，并继续按预期添加预约信息。此服务安排预订并产生一个 `BOOKING_SUCCESS`
    事件供下一个服务使用。'
- en: The *document upload service* receives the `BOOKING_SUCCESS` event and proceeds
    to upload the documents and add a record to the document service data store.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*文档上传服务* 收到 `BOOKING_SUCCESS` 事件，并继续上传文档并在文档服务数据存储中添加记录。'
- en: This example shows that we can track the processes along the chain. If we wanted
    to know each leg and the outcome, we can have the registration service listen
    to all events and make state updates or logs of the progress along the saga. It
    will also be able to communicate the success or failure of the saga back to the
    client.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明我们可以跟踪链中的过程。如果我们想知道每一步和结果，我们可以让注册服务监听所有事件，并在传奇故事中更新状态或记录进度。它还将能够将传奇故事的成功或失败传达给客户。
- en: What happens though when a service fails? How do we mitigate or reap the benefit
    of the the saga pattern's ability to reverse changes that have already gone? Let’s
    review that next.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当服务失败时会发生什么？我们如何减轻或利用传奇模式能够逆转已发生更改的能力？让我们接下来回顾一下。
- en: Rolling back on failure
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 失败时的回滚
- en: 'Sagas are necessary because they allow us to roll back the changes that have
    already happened when something fails. If a local transaction fails, the service
    will publish an event stating that it was unsuccessful. We then need additional
    code in the preceding service that will react with the rollback procedures accordingly.
    For example, if our payment service operation failed, then the flow would look
    something like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 传奇故事是必要的，因为它们允许我们在失败时回滚已经发生的更改。如果一个本地事务失败，服务将发布一个事件声明它未成功。然后我们需要在前面服务中添加额外的代码，以便根据回滚程序做出相应的反应。例如，如果我们的支付服务操作失败，流程可能看起来像这样：
- en: The appointment booking service failed to confirm the appointment booking and
    publishes a `BOOKING_FAILED` event.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预约预订服务未能确认预约预订，并发布了一个 `BOOKING_FAILED` 事件。
- en: The payment service receives the `BOOKING_FAILED` event and proceeds to issue
    a refund to the client. This would be a remediation step.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支付服务收到 `BOOKING_FAILED` 事件，并继续向客户发出退款。这将是一个补救步骤。
- en: The preceding registration service will see the `BOOKING_FAILED` event and notify
    the client that the booking was not successful.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的注册服务将看到 `BOOKING_FAILED` 事件，并通知客户预订未成功。
- en: In this situation, we are not completely reversing every step since we retain
    the user’s registration information for future reference. What is important, though,
    is that the next service in the saga, which uploads the documents, is not configured
    to listen for the `BOOKING_FAILED` event. So, it will have nothing to do unless
    it sees a `BOOKING_SUCCESS` event.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们并没有完全逆转每一步，因为我们保留了用户的注册信息以供将来参考。然而，重要的是，在传奇故事中的下一个服务，即上传文档的服务，并没有配置为监听
    `BOOKING_FAILED` 事件。因此，除非它看到 `BOOKING_SUCCESS` 事件，否则它将没有任何事情可做。
- en: We can also take note of the fact that our remediation steps are relative to
    the actual operation being carried out. Our *payment service* is likely a wrapper
    around a third-party payment engine that will also write a local database record
    of the payment operation. In its remediation steps, it will not remove the payment
    record, but simply mark it as a refunded payment or cancel the payment, given
    the lack of completion of the saga.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以注意，我们的补救步骤与实际执行的操作相关。我们的 *支付服务* 可能是围绕第三方支付引擎的一个包装，该引擎也会为支付操作写入本地数据库记录。在其补救步骤中，它不会删除支付记录，而是简单地将其标记为已退款支付或取消支付，考虑到传奇故事的未完成。
- en: While this is not *ACID* in the true sense of what a local database would do,
    and undo a database the effects of a write operation, a rollback might look different
    for each service, based on the business rules or nature of the operation. We also
    see that our rollback did not span every single service, since our business rules
    suggest that we keep the user registration information for future reference.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不是在真正意义上符合本地数据库会做的 *ACID*，并且撤销写入操作对数据库的影响，但每个服务的回滚可能看起来都不同，这取决于业务规则或操作的特性。我们还看到，我们的回滚并没有涵盖每个单一的服务，因为我们的业务规则建议我们保留用户注册信息以供将来参考。
- en: Another thing that we need to consider is whether there is a necessity in our
    rollback operations. Given the event-based nature of our services, if we want
    to implement an order, then we will need more event types that services will listen
    for specifically.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要考虑我们的回滚操作是否有必要性。鉴于我们服务的基于事件的本性，如果我们想实现一个顺序，那么我们将需要更多服务将专门监听的事件类型。
- en: Let us review the pros and cons of this choreography implementation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这种编排实现的优缺点。
- en: Pros and cons
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优缺点
- en: In the choreography model, we have a simple approach to implementing a saga.
    This method makes use of some of the previous patterns that we have discussed
    in *event sourcing* and *asynchronous service communication*. Each service retains
    its autonomy, and a rollback operation might look different per service. It is
    a clean way to implement a saga for a smaller operation with fewer participants
    and fewer potential outcomes based on success or failure.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在编排模型中，我们有一种简单的方法来实现叙事。这种方法利用了我们之前在*事件溯源*和*异步服务通信*中讨论的一些模式。每个服务保持其自主性，回滚操作可能每个服务看起来都不同。这是一种为较小操作、参与者较少和基于成功或失败有较少潜在结果的叙事实现方式。
- en: We can also take the asynchronous approach to the saga as some form of advantage,
    as we can trigger multiple simultaneous operations stemming from each service’s
    success. This is good for getting operations done quickly while the client is
    waiting on the outcome.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将异步方法视为叙事的一种优势，因为我们可以从每个服务的成功中触发多个同时操作。这对于在客户端等待结果时快速完成操作是有益的。
- en: We also see that we need to always be expanding our code base to facilitate
    the varying operations and their outcomes, especially if we intend to implement
    an order for the rollback operations. Given the asynchronous model that is used
    to implement this type of saga, it might be dangerous to use one event type to
    trigger operations simultaneously.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也看到，我们需要不断扩展我们的代码库以适应各种操作及其结果，尤其是如果我们打算实现回滚操作的顺序。鉴于实现此类叙事使用的异步模型，使用一种事件类型同时触发操作可能是危险的。
- en: As the number of participants grows, we run the risk of implementing a complex
    web of participants, events, and remediations. It grows increasingly difficult
    to properly monitor all the services and adequately trace the points of failure.
    If an operation is to be tested, all services must be running to properly troubleshoot
    our operations. The bigger the saga gets, the more difficult it is to monitor.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 随着参与者数量的增加，我们面临实施复杂参与者、事件和补救措施的网络的危险。正确监控所有服务并充分追踪故障点变得越来越困难。如果要对操作进行测试，所有服务都必须运行，以便正确排除我们的操作故障。叙事越大，监控就越困难。
- en: For this reason, we look to another saga pattern in the form of orchestration,
    which implements a central point of control. We will review it next.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们转向另一种叙事模式，即编排，它实现了一个中央控制点。我们将在下一节中对其进行回顾。
- en: Understanding and implementing orchestration
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和实现编排
- en: When we think of the word *orchestration*, we think of coordination. An orchestra
    is a coordinated combination of musicians all working towards producing the same
    kind of music. Each musician plays their part, but they are led by a conductor
    who guides each of them along the same path.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想到“编排”这个词时，我们会想到协调。一个管弦乐队是由协调一致的乐手组成的组合，他们共同努力创作出同一种类的音乐。每位乐手都演奏自己的部分，但他们都由一位指挥家引导，沿着相同的路径前进。
- en: The orchestration method of implementing a saga is not very different in terms
    of how we need a central point of control (like a conductor), and all the services
    are monitored by the central point of control to ensure that they play their part
    well, or report failure accordingly. The central control is referred to as an
    *orchestrator* and it is a microservice that sits between the client and all other
    microservices. It handles all the transactions, telling participating services
    when to complete an operation based on feedback it receives during the saga. The
    orchestrator executes the request, tracks and interprets the request’s state after
    each task, and handles the remediating operations, as necessary.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 实现剧情的编排方法在需要中央控制点（如指挥家）方面并没有很大不同，所有服务都由中央控制点监控，以确保它们很好地扮演自己的角色，或者相应地报告失败。中央控制被称为
    *编排器*，它是一个位于客户端和所有其他微服务之间的微服务。它处理所有事务，根据在剧情期间收到的反馈告诉参与服务何时完成操作。编排器执行请求，跟踪并解释每个任务后的请求状态，并在必要时处理补救操作。
- en: '*Figure 8.3* shows the orchestrator flow:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8.3* 展示了编排器流程：'
- en: '![Figure 8.3 – An application request sends a message to the orchestrator,
    which begins to coordinate and monitor the subsequent calls to the participating
    services](img/Figure_8.3_B19100.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 应用程序请求向编排器发送消息，编排器开始协调和监控后续对参与服务的调用](img/Figure_8.3_B19100.jpg)'
- en: Figure 8.3 – An application request sends a message to the orchestrator, which
    begins to coordinate and monitor the subsequent calls to the participating services
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 应用程序请求向编排器发送消息，编排器开始协调和监控后续对参与服务的调用
- en: 'Let us revisit our appointment booking operation from the perspective of the
    orchestration saga implementation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编排器剧情实现的角度回顾我们的预约操作：
- en: The user submits a registration and appointment booking request (client request).
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户提交注册和预约请求（客户端请求）。
- en: The client request is passed to the *orchestrator* service.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端请求传递给 *编排器* 服务。
- en: The *orchestrator* service centrally stores the data from the client request.
    This data will be used during the *User Registration* saga.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*编排器* 服务集中存储来自客户端请求的数据。这些数据将在 *用户注册* 剧情期间使用。'
- en: The *orchestrator* service begins the saga by passing the user’s information
    to the *registration* service, which will add a new record to its database and
    respond with a `201Created` HTTP response. The *orchestrator* will store the user’s
    ID, as it will be needed during the saga.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*编排器* 服务通过将用户信息传递给 *注册* 服务开始剧情，该服务将在其数据库中添加一条新记录并返回 `201Created` HTTP 响应。*编排器*
    将存储用户的 ID，因为它将在剧情期间需要。'
- en: The *orchestrator* then sends the user’s payment information to the *payment*
    service, which will respond with a `200OK` HTTP response. The *orchestrator* will
    store the payment response details, in the event that a rollback is needed and
    the payment should be canceled.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后 *编排器* 将用户的支付信息发送给 *支付* 服务，该服务将返回 `200OK` HTTP 响应。如果需要回滚并且应该取消支付，*编排器* 将存储支付响应详情。
- en: The *orchestrator* then sends a request to the *appointment booking* service,
    which processes the appointment booking accordingly and responds with a `201Created`
    HTTP response.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后 *编排器* 向 *预约* 服务发送请求，该服务相应地处理预约并返回 `201Created` HTTP 响应。
- en: The *orchestrator* will finally trigger the *document upload* service, which
    uploads the documents and adds records to the document service database.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*编排器* 最终将触发 *文档上传* 服务，该服务上传文档并将记录添加到文档服务数据库中。'
- en: The *orchestrator* then confirms that the saga has ended and will update the
    state of the operation. It will then respond to the client with the overall result.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后 *编排器* 确认剧情已结束，并将更新操作的状态。然后它将向客户端发送整体结果。
- en: We can see that the orchestrator is at the helm of every step of the operation
    and remains informed of each service’s outcome. It acts as the main authority
    on whether we should move to the next step or not. We can also see that a more
    *synchronous service communication* model is implemented in this saga pattern.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，编排器在操作的每一步都处于主导地位，并了解每个服务的输出结果。它作为是否应该进入下一步的主要权威机构。我们还可以看到，在这个剧情模式中实现了更
    *同步的服务通信* 模型。
- en: Let us review what a rollback operation might look like.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下回滚操作可能的样子。
- en: Rolling back on failure
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回滚失败
- en: 'Rolling back is the most important part of implementing a saga, and like the
    choreography pattern, we are governed by the business rules of the operation and
    induvial service operations. The main takeaway here is that the services will
    respond with failure to a central point, which will then coordinate the rollback
    operations across the various services. Reusing the failure scenario previously
    discussed, our orchestration would look something like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 回滚是实施叙事的最重要部分，就像编排模式一样，我们受操作和个别服务操作的业务规则所约束。这里的要点是，服务将向中心点响应失败，然后协调器将在各个服务之间协调回滚操作。重用之前讨论的失败场景，我们的编排看起来可能像这样：
- en: The *appointment booking* service sends a `400BadRequest` HTTP response to the
    *orchestrator*.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**预约预订**服务向**协调器**发送`400BadRequest` HTTP响应。'
- en: The *orchestrator* proceeds to call the *payment* service to cancel the payment.
    It already stored the relevant information about the payment during the saga.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**协调器**继续调用**支付**服务以取消支付。在叙事过程中，它已经存储了有关支付的相关信息。'
- en: The *orchestrator* will trigger additional clean-up operations such as flagging
    the user’s registration record as incomplete, as well as purging any additional
    data that may have been stored at the beginning of the operation.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**协调器**将触发额外的清理操作，例如将用户的注册记录标记为不完整，以及清除操作开始时可能存储的任何其他数据。'
- en: The *orchestrator* will notify the client of the operation’s failure.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**协调器**将通知客户端操作失败。'
- en: A rollback here is arguably easier to implement – not because we are changing
    how and what the services do, but because we can be sure of the order in which
    the remediations will happen in case the order is important, and we can accomplish
    that without introducing too much more complexity to the flow.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里进行回滚可以说是更容易实现——不是因为我们在改变服务和它们的行为方式，而是因为我们能够确保在顺序重要的情况下，补救措施将按照什么顺序发生，并且我们可以在不向流程中引入太多额外复杂性的情况下做到这一点。
- en: Let us discuss the benefits of using this pattern in more detail.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论使用此模式的好处。
- en: Pros and cons
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: One obvious advantage to using this implementation of the saga pattern is the
    level of control that we can be sure to implement. We can orchestrate our service
    calls and receive real-time feedback, which can be used to decide and have a set
    path along the saga that we can track and monitor. This makes it easier to implement
    complex workflows and extend the number of participants over time.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种叙事模式实现的明显优势是我们能够确保实施的控制水平。我们可以编排我们的服务调用并接收实时反馈，这可以用来决定并沿着叙事路径有一个可跟踪和监控的固定路径。这使得实现复杂的工作流程并随着时间的推移扩展参与者的数量变得更容易。
- en: This implementation is excellent for us if we need to control the exact flow
    of saga activities and be sure that we do not have services being triggered simultaneously
    and from information that they may think is relevant. Services only act when called
    upon, and misconfigurations are less likely. Services do not need to directly
    depend on each other for communication and are more autonomous, leading to simpler
    business logic. Troubleshooting also becomes easier since we can track what the
    singular code base is doing and more easily identify the point of failure.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要控制叙事活动的确切流程并确保我们没有服务被同时触发，并且它们可能认为相关的信息，这种实现对我们来说非常出色。服务只有在被调用时才会行动，配置错误的可能性较小。服务不需要直接相互依赖进行通信，更具有自主性，导致业务逻辑更简单。故障排除也变得更容易，因为我们能够跟踪单个代码库正在做什么，并更容易地识别失败点。
- en: Despite all these proposed benefits of orchestration, we need to remember that
    we are simply creating a central point of synchronous service calls. This can
    become a choke point along the saga if one of the services runs more slowly than
    desired. This can be managed, of course, through properly implemented *retry*
    and *circuit breaker* logic, but it remains a risk worthy of consideration.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有这些协调的优点，我们仍需记住，我们只是在创建一个同步服务调用的中心点。如果其中一个服务运行速度比预期慢，这可能会成为叙事中的瓶颈。当然，这可以通过正确实现的**重试**和**断路器**逻辑来管理，但这仍然是一个值得考虑的风险。
- en: We also run into a situation where we end up with yet another microservice to
    develop and maintain. We will introduce a new and more central point of failure
    since no other microservice gets called into action if the orchestrator is out
    of operation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还遇到了一个情况，我们最终又需要开发和维护另一个微服务。我们将引入一个新的、更中心的故障点，因为如果协调器停止工作，没有其他微服务会被调用。
- en: Let us review what we have learned in this chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本章所学的内容。
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Until now, we have seen several patterns surrounding microservices architecture
    and development. Each pattern’s purpose is to reduce the attrition that comes
    with this kind of architecture.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了围绕微服务架构和开发的一些模式。每个模式的目的都是为了减少这种架构带来的损耗。
- en: We saw a potential pain point and point of concern with our *database-per-service*
    pattern implementation and the difficulty that comes from having disparate data
    stores. We cannot always guarantee that all services will be successful in an
    operation and as such, we cannot guarantee that the data stores will reflect the
    same thing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*数据库按服务模式*的实现中看到了一个潜在的痛点和一个关注点，以及来自不同数据存储的困难。我们无法始终保证所有服务在操作中都能成功，因此，我们无法保证数据存储会反映相同的内容。
- en: To address this, we look to the saga pattern, which can either be leveraged
    through an event-based *choreography* implementation or a more centralized *orchestration*
    method. We have reviewed the pros, cons, and considerations surrounding either
    implementation and how they help us to more effectively help microservices maintain
    data consistency.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们转向了叙事模式，该模式可以通过基于事件的*编排*实现或更集中的*编排*方法来利用。我们已经回顾了围绕这两种实现的优势、劣势和考虑因素，以及它们如何帮助我们更有效地帮助微服务保持数据一致性。
- en: In the next chapter, we will review the potential flaws involved in communication
    between microservices, and review how we can implement more fault-tolerant communication
    between services using the *circuit breaker pattern*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾微服务之间通信中可能存在的缺陷，并讨论如何使用*断路器模式*实现更容错的服务间通信。
- en: 'Part 3: Resiliency, Security, and Infrastructure Patterns'
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：弹性、安全和基础设施模式
- en: Reliability is one of the most critical aspects of API design. This part discusses
    the technique surrounding robust API design, security, and hosting. By the end
    of this part, you should be able to design advanced and secure APIs that can communicate
    with a lower failure rate and be hosted efficiently.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠性是API设计中最关键的方面之一。本部分讨论了围绕健壮API设计、安全和托管的技术。在本部分的结尾，你应该能够设计出高级且安全的API，这些API可以以较低的失败率进行通信，并且可以高效地托管。
- en: 'This part has the following chapters:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 9*](B19100_09.xhtml#_idTextAnchor140), *Building Resilient Microservices*'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19100_09.xhtml#_idTextAnchor140), *构建弹性微服务*'
- en: '[*Chapter 10*](B19100_10.xhtml#_idTextAnchor156), *Performing Health Checks
    on Your Services*'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19100_10.xhtml#_idTextAnchor156), *对您的服务进行健康检查*'
- en: '[*Chapter 11*](B19100_11.xhtml#_idTextAnchor168), *Implementing the API and
    BFF Gateway Patterns*'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B19100_11.xhtml#_idTextAnchor168), *实现API和BFF网关模式*'
- en: '[*Chapter 12*](B19100_12.xhtml#_idTextAnchor184), *Securing Microservices with
    Bearer Tokens*'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B19100_12.xhtml#_idTextAnchor184), *使用令牌保护微服务*'
- en: '[*Chapter 13*](B19100_13.xhtml#_idTextAnchor202), *Microservice Container Hosting*'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B19100_13.xhtml#_idTextAnchor202), *微服务容器托管*'
- en: '[*Chapter 14*](B19100_14.xhtml#_idTextAnchor219), *Implementing Centralized
    Logging for Microservices*'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B19100_14.xhtml#_idTextAnchor219), *为微服务实现集中式日志记录*'
- en: '[*Chapter 15*](B19100_15.xhtml#_idTextAnchor231), *Wrapping It All Up*'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B19100_15.xhtml#_idTextAnchor231), *总结*'
