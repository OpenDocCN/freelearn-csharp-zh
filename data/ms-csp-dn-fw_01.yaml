- en: Chapter 1. Inside the CLR
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. CLR内部
- en: Since CLR is just a generic name for different tools and software based on well-known
    and accepted principles in computing, we'll begin with a review of some of the
    most important concepts of software programming that we often take for granted.
    So, to put things in context, this chapter reviews the most important concepts
    around the motivations for the creation of .NET, how this framework integrates
    with the Windows operating system, and what makes the so called CLR the excellent
    runtime it is.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CLR只是对基于计算机中已知和公认原则的不同工具和软件的通用名称，因此我们将从回顾一些我们经常视为理所当然的最重要的软件编程概念开始。因此，为了使事情更有背景，本章回顾了围绕.NET创建动机的最重要概念，该框架如何与Windows操作系统集成，以及是什么使得所谓的CLR成为如此优秀的运行时。
- en: 'In short, this chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，本章涵盖了以下主题：
- en: A brief, but carefully selected, dictionary of the common terms and concepts
    utilized in general and .NET programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简要但精心挑选的通用和.NET编程中使用的常见术语和概念词典
- en: A rapid review of goals after the creation of .NET and the main architects behind
    its construction
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对.NET创建后的目标和其主要构建者的快速回顾
- en: Explanations of each of the main parts that compose the CLR, its tools, and
    how the tools work
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对组成CLR的各个主要部分、其工具以及工具如何工作的解释
- en: A basic approach to the complexity of algorithms and how to measure it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法复杂性的基本方法及其度量方式
- en: A select list of the most outstanding characteristics related to the CLR that
    appeared in recent versions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与CLR相关的一些最突出的特性列表，这些特性出现在最近版本中
- en: An annotated reminder of some important computing terms
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些重要计算术语的注释提醒
- en: Let's check out some important concepts widely used in software construction
    that show up frequently in .NET programming.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在软件构建中广泛使用的一些重要概念，这些概念在.NET编程中经常出现。
- en: Context
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: 'As Wikipedia states:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如维基百科所述：
- en: In computer science, a task context is the minimal set of data used by a task
    (which may be a process or thread) that must be saved to allow a task interruption
    at a given date, and a continuation of this task at the point it has been interrupted
    and at an arbitrary future date.
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在计算机科学中，任务上下文是任务（可能是进程或线程）必须保存的最小数据集，以便在给定日期中断任务，并在中断点和任意未来日期继续此任务。
- en: In other words, context is a term related to the data handled by a thread. Such
    data is conveniently stored and recovered by the system as required.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，上下文是与线程处理的数据相关的术语。这些数据按需由系统方便地存储和恢复。
- en: Practical approaches to this concept include HTTP request/response and database
    scenarios in which the context plays a very important role.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 实际应用此概念的方法包括HTTP请求/响应和数据库场景，其中上下文起着非常重要的作用。
- en: The OS multitask execution model
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统的多任务执行模型
- en: A CPU is able to manage multiple processes in a period of time. As we mentioned,
    this is achieved by saving and restoring (in an extremely fast manner) the context
    of execution with a technique called context switch.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: CPU能够在一段时间内管理多个进程。正如我们提到的，这是通过使用称为上下文切换的技术来保存和恢复（以极快的方式）执行上下文来实现的。
- en: 'When a thread ceases to execute, it is said to be in the **Idle** state. This
    categorization might be useful at the time of analyzing processes execution with
    the tools that are able to isolate threads in the **Idle** state:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程停止执行时，它处于**空闲**状态。这种分类在分析能够隔离空闲状态的线程的工具处理进程执行时可能很有用：
- en: '![The OS multitask execution model](img/image00396.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![操作系统的多任务执行模型](img/image00396.jpeg)'
- en: Context types
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文类型
- en: In some languages, such as C#, we also find the concept of safe or secure context.
    In a way, this relates to the so-called thread safety.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，例如C#，我们也发现了安全或安全上下文的概念。在某种程度上，这与所谓的线程安全相关。
- en: Thread safety
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: A piece of code is said to be thread-safe if it only manipulates shared data
    structures in a manner that guarantees safe execution by multiple threads at the
    same time. There are various strategies used in order to create thread-safe data
    structures, and the .NET framework is very careful about this concept and its
    implementations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一段代码只以保证多个线程同时安全执行的方式操作共享数据结构，则称该代码为线程安全。为了创建线程安全的数据结构，使用了各种策略，而.NET框架对此概念及其实现非常谨慎。
- en: Actually, most of the MSDN (the official documentation) includes the indication
    *this type is thread-safe* at the bottom for those to whom it is applicable (a
    vast majority).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，大多数MSDN（官方文档）对于适用对象（大多数）都在底部包含指示“此类型是线程安全的”。
- en: State
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态
- en: The state of a computer program is a technical term for all the stored information,
    at a given instant in time, to which the program has access. The output of a computer
    program at any time is completely determined by its current inputs and its state.
    A very important variant of this concept is the program's state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序的状态是一个技术术语，指的是在某一时刻，程序可以访问的所有存储信息。计算机程序在任何时刻的输出完全由其当前输入和状态决定。这个概念的一个重要变体是程序的状态。
- en: Program state
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序状态
- en: This concept is especially important, and it has several meanings. We know that
    a computer program stores data in variables, which are just labeled storage locations
    in the computer's memory. The contents of these memory locations, at any given
    point in the program's execution, are called the program's state.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念特别重要，并且有几个含义。我们知道计算机程序在变量中存储数据，这些变量只是计算机内存中的标记存储位置。在任何给定程序执行点，这些内存位置的包含内容被称为程序的状态。
- en: In object-oriented languages, it is said that a class defines its state through
    fields, and the values that these fields have at a given moment of execution determine
    the state of that object. Although it's not mandatory, it's considered a good
    practice in OOP programming when the methods of a class have the sole purpose
    of preserving the coherence and logic of its state and nothing else.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的编程语言中，据说一个类通过字段定义其状态，而这些字段在执行过程中的值决定了该对象的状态。尽管这不是强制性的，但在面向对象编程中，当类的方法仅用于保持其状态的一致性和逻辑时，这被认为是一种良好的实践。
- en: 'In addition, a common taxonomy of programming languages establishes two categories:
    imperative and declarative programming. C# or Java are examples of the former,
    and HTML is a typical declarative syntax (since it''s not a language itself).
    Well, in declarative programming, sentences tend to change the state of the program
    while using the declarative paradigm, languages indicate only the desired result,
    with no specifications about how the engine will manage to obtain the results.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，编程语言的常见分类建立了两个类别：命令式编程和声明式编程。C#或Java是前者的例子，而HTML是典型的声明式语法（因为它本身不是一种语言）。在声明式编程中，句子倾向于使用声明性范式改变程序的状态，而语言仅指示所需的结果，没有关于引擎如何获得结果的说明。
- en: Serialization
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化
- en: Serialization is the process of translating data structures or the object state
    into a format that can be stored (for example, in a file or a memory buffer) or
    transmitted across a network connection and reconstructed later in the same or
    another computer environment.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化是将数据结构或对象状态转换为可以存储（例如，在文件或内存缓冲区中）或通过网络连接传输的格式的过程，稍后可以在同一或另一台计算机环境中重建。
- en: 'So, we used to say that serializing an object means to convert its state into
    a byte stream in such a way that the byte stream can be converted back into a
    copy of the object. Popular text formats emerged years ago and are now well known
    and accepted, such as XML and JSON, independently of other previous formats (binary
    included):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们过去常说，序列化一个对象意味着将其状态转换为字节流，这样字节流就可以被转换回对象的副本。流行的文本格式多年前出现，现在已知并得到广泛接受，例如XML和JSON，独立于其他之前的格式（包括二进制）：
- en: '![Serialization](img/image00397.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![序列化](img/image00397.jpeg)'
- en: Process
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程
- en: The OS fragments operations among several functional units. This is done by
    allocating different memory areas for each unit in execution. It's important to
    distinguish between processes and threads.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统在几个功能单元之间分配操作。这是通过为每个执行单元分配不同的内存区域来实现的。区分进程和线程很重要。
- en: 'Each process is given a set of resources by the OS, which—in Windows—means
    that a process will have its own virtual address space allocated and managed accordingly.
    When Windows initializes a process, it is actually establishing a context of execution,
    which implies a process environment block, also known as PEB and a data structure.
    However, let''s make this clear: the OS doesn''t execute processes; it only establishes
    the execution context.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统为每个进程分配一组资源，在Windows中这意味着进程将拥有自己的虚拟地址空间，并相应地进行分配和管理。当Windows初始化一个进程时，它实际上是在建立一个执行上下文，这暗示了一个进程环境块（也称为PEB）和数据结构。然而，让我们明确一点：操作系统不执行进程；它只建立执行上下文。
- en: Thread
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程
- en: 'A thread is the functional (or working) unit of a process. And that is what
    the OS executes. Thus, a single process might have several threads of execution,
    which is something that happens very often. Each thread has its own address space
    within the resources previously allocated by the creation of the process. These
    resources are shared by all threads linked to the process:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是进程的功能（或工作）单元。这就是操作系统执行的内容。因此，单个进程可能有多个执行线程，这是非常常见的事情。每个线程在进程创建时分配的资源中都有自己的地址空间。这些资源由所有链接到该进程的线程共享：
- en: '![Thread](img/image00398.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![线程](img/image00398.jpeg)'
- en: It's important to recall that a thread only belongs to a single process, thus
    having access to only the resources defined by that process. When using the tools
    that will be suggested now, we can look at multiple threads executing concurrently
    (which means that they start working in an independent manner) and share resources,
    such as memory and data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，线程只属于单个进程，因此只能访问该进程定义的资源。当使用现在将要建议的工具时，我们可以查看多个线程同时执行（这意味着它们以独立的方式开始工作）并共享资源，如内存和数据。
- en: Different processes do not share these resources. In particular, the threads
    of a process share its instructions (the executable code) and its context (the
    values of its variables at any given moment).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的进程不共享这些资源。特别是，进程中的线程共享其指令（可执行代码）和上下文（在任何给定时刻其变量的值）。
- en: Programming languages such as .NET languages, Java, or Python expose threading
    to the developer while abstracting the platform-specific differences in threading
    implementations at runtime.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如.NET语言、Java或Python等编程语言在运行时向开发者暴露线程，同时抽象了线程实现的具体平台差异。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that communication between threads is possible through the common set of
    resources initialized by the process creation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，线程之间的通信可以通过进程创建时初始化的公共资源集来实现。
- en: Of course, there is much more written about these two concepts, which go far
    beyond the scope of this book (refer to Wikipedia, [https://en.wikipedia.org/wiki/Thread_(computing)](https://en.wikipedia.org/wiki/Thread_(computing)),
    for more details), but the system provides us with mechanisms to check the execution
    of any process and also check what the threads in execution are.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，关于这两个概念有更多内容被撰写，这些内容远远超出了本书的范围（有关更多详细信息，请参阅维基百科，[https://en.wikipedia.org/wiki/Thread_(computing)](https://en.wikipedia.org/wiki/Thread_(computing)))，但系统为我们提供了检查任何进程执行情况的机制，也可以检查正在执行的线程。
- en: 'If you are curious about it or just need to check whether something is going
    wrong, there are two main tools that I recommend: the Task Manager (included in
    the operating system, which you''ll probably know), and—even better—one of the
    tools designed by the distinguished engineer and technical fellow Mark Russinowitch,
    available for free and composed of a set of more than 50 utilities.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对此感兴趣或只是需要检查是否有错误发生，我推荐两种主要工具：任务管理器（包含在操作系统中，你可能已经知道），以及——更好的是——由杰出的工程师和技术伙伴马克·拉辛诺维奇（Mark
    Russinowitch）设计的工具，免费提供，并包含50多个实用工具。
- en: Some have a Windows interface and others are console utilities, but all of them
    are highly optimized and configurable to monitoring and controlling the inner
    aspects of our operating system at any moment. They are available for free at
    [https://technet.microsoft.com/en-us/sysinternals/bb545021.aspx](https://technet.microsoft.com/en-us/sysinternals/bb545021.aspx).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有些具有Windows界面，而有些是控制台实用工具，但所有这些都非常优化且可配置，可以在任何时刻监控和控制我们操作系统的内部方面。它们可以在[https://technet.microsoft.com/en-us/sysinternals/bb545021.aspx](https://technet.microsoft.com/en-us/sysinternals/bb545021.aspx)免费获取。
- en: 'If you don''t want to install anything else, open **Task Manager** (just right-click
    on the task bar to access it) and select the **Details** tab. You will see a more
    detailed description of every process, the amount of CPU used by each process,
    the memory allocated for each process, and so on. You can even right-click on
    one of the processes and see how there is a context menu that offers a few possibilities,
    including launching a new dialog window that shows some properties related to
    it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想安装任何其他东西，请打开**任务管理器**（只需右键单击任务栏即可访问它）并选择**详细信息**选项卡。您将看到每个进程的更详细描述，每个进程使用的CPU量，每个进程分配的内存量等等。您甚至可以右键单击其中一个进程，并看到一个上下文菜单，它提供了一些可能性，包括启动一个显示与其相关的某些属性的新的对话框窗口：
- en: '![Thread](img/image00399.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![线程](img/image00399.jpeg)'
- en: SysInternals
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SysInternals
- en: If you really want to know how a process behaves in its entirety, the tools
    to use are SysInternals. If you go to the link indicated earlier, you'll see an
    item menu especially dedicated to process utilities. There, you have several choices
    to work with, but the most comprehensive are **Process Explorer** and **Process
    Monitor**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的想了解一个进程的整体行为，请使用SysInternals工具。如果您访问之前提到的链接，您将看到一个专门针对进程实用程序的菜单项。在那里，您有多个选择可供工作，但最全面的是**进程探索器**和**进程监视器**。
- en: '**Process Explorer** and **Process Monitor** don''t require installation (they''re
    written in C++), so you can execute them directly from any device for a Windows
    platform.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程探索器**和**进程监视器**无需安装（它们是用C++编写的），因此您可以直接在任何Windows平台上从任何设备执行它们。'
- en: For example, if you run **Process Explorer**, you'll see a fully detailed window
    showing every single detail of all the processes currently active in the system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您运行**进程探索器**，您将看到一个显示系统当前所有活动进程的每个细节的详细窗口。
- en: 'With **Process Explorer**, you can find out what files, registry keys, and
    other objects processes have opened, together with the DLLs they have loaded,
    who owns each process, and so on. Every thread is visible and the tool provides
    you with detailed information, available through a very intuitive user interface:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**进程探索器**，您可以找出进程打开了哪些文件、注册表键以及其他对象，以及它们加载的DLL，每个进程的所有者等等。每个线程都是可见的，并且该工具提供了一个非常直观的用户界面，提供详细的信息：
- en: '![SysInternals](img/image00400.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![SysInternals](img/image00400.jpeg)'
- en: 'It''s also very useful to check the system''s general behavior at real time,
    since it creates graphics of activities of CPU usage, I/O, Memory, among others,
    as shown in the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 检查系统的实时行为也非常有用，因为它创建了CPU使用率、I/O、内存等活动图形，如下面的截图所示：
- en: '![SysInternals](img/image00401.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![SysInternals](img/image00401.jpeg)'
- en: 'In a similar way, **Process Monitor**, focuses on monitoring the filesystem,
    the Registry, and all processes and threads with their activities in real time,
    since it actually is a mixture of two previous utilities merged together: **FileMon**
    (**File Monitor**) and **RegMon** (**Registry Monitor**), which are not available
    anymore.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，**进程监视器**专注于实时监控文件系统、注册表以及所有进程和线程的活动，因为它实际上是将两个之前的实用程序合并在一起：**FileMon（文件监视器**）和**RegMon（注册表监视器**），这些工具现在已不再可用。
- en: If you try out PM, you'll see some of the information included in PE, plus the
    specific information provided by PM—just conveyed in a different manner.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试使用PM，您将看到PE中包含的一些信息，以及PM提供的特定信息——只是以不同的方式传达。
- en: Static versus dynamic memory
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态内存与动态内存
- en: 'When a program starts execution, the OS assigns a process to it by means of
    scheduling: the method by which work specified by some means is assigned to resources
    that complete the work. This means that the resources for the process are assigned,
    and that implies memory allocation.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序开始执行时，操作系统通过调度将其分配给一个进程：通过某种方式指定的工作分配给完成工作的资源的方法。这意味着进程的资源被分配，这也就意味着内存分配。
- en: 'As we''ll see, there are mainly two types of memory allocation:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，主要有两种类型的内存分配：
- en: Fixed memory (linked to the stack), determined at compile time. Local variables
    are declared and used in the stack. Note that it is a contiguous block of memory
    allocated when the process resources are initially assigned. The allocation mechanism
    is very fast (although the access not so much).
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定内存（与堆栈链接），在编译时确定。局部变量在堆栈中声明和使用。请注意，这是一个在进程资源最初分配时分配的连续内存块。分配机制非常快（尽管访问速度并不快）。
- en: The other is dynamic memory (the heap), which can grow as the program required
    it, and it's assigned at runtime. This is the place where instance variables are
    allocated (those that point to an instance of a class or object).
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种是动态内存（堆），它可以随着程序的需求增长，并且是在运行时分配的。这是实例变量分配的地方（那些指向类或对象实例的变量）。
- en: Usually, the first type is calculated at compile time since the compiler knows
    how much memory will be needed to allocate the variables declared depending on
    its type (`int`, `double`, and so on). They are declared inside functions with
    a syntax such as `int x = 1;`
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，第一种类型是在编译时计算的，因为编译器知道根据其类型（例如`int`、`double`等）需要分配多少内存来声明变量。它们在具有如下语法的函数内部声明：`int
    x = 1;`
- en: 'The second type requires the `new` operator to be invoked. Let''s say there
    is a class named `Book` in our code, we create an instance of such `Book` with
    an expression of this type:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型需要调用`new`运算符。假设我们的代码中有一个名为`Book`的类，我们使用这种类型的表达式创建一个这样的`Book`实例：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This instructs the runtime to allocate enough space in the heap to hold an instance
    of that type along with its fields; the state of the class is allocated in the
    heap. This means that the whole state of a program will store its state in a different
    memory (and, optionally, disk) locations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示运行时在堆中分配足够的空间来容纳该类型的实例及其字段；类的状态在堆中分配。这意味着程序的全部状态将存储在不同的内存（和可选的磁盘）位置。
- en: Of course, there are more aspects to account for, which we'll cover in the *The
    Stack and the Heap* section in this chapter. Luckily, the IDE lets us watch and
    analyze all these aspects (and many more) at debug time, offering an extraordinary
    debugging experience.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有更多方面需要考虑，我们将在本章的*栈和堆*部分进行介绍。幸运的是，IDE允许我们在调试时观察和分析所有这些方面（以及更多），提供非凡的调试体验。
- en: Garbage collector
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾收集器
- en: '**Garbage collection** (**GC**) is a form of automatic memory management. The
    GC in .NET, attempts to reclaim garbage or the memory occupied by objects that
    are no longer in use by the program. Going back to the previous code declaration
    of `Book`, when there are no references to the `Book` object in the stack, the
    GC will reclaim that space to the system, liberating memory (it''s a bit more
    complex, in fact, and I''ll get into further detail later in this chapter—when
    we talk about memory management—but let''s put it that way for the moment).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**垃圾收集**（**GC**）是一种自动内存管理形式。.NET中的GC试图回收垃圾或程序不再使用的对象的内存。回到之前`Book`代码声明的例子，当栈中没有对`Book`对象的引用时，GC将回收该空间并归还给系统，从而释放内存（实际上要复杂一些，我将在本章后面的内存管理部分进一步详细说明——当我们讨论内存管理时，但暂时可以这样理解）。'
- en: It's important to note that garbage collectors are not something exclusive to
    the .NET platform. Actually, you can find it in all platforms and programs even
    if you're dealing with browsers. Current JavaScript engines, for instance, such
    as Chrome's V8, Microsoft's Chakra—and others—use a garbage collection mechanism
    as well.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，垃圾收集器并不仅限于.NET平台。实际上，你可以在所有平台和程序中找到它，即使你正在处理浏览器。例如，当前的JavaScript引擎，如Chrome的V8、Microsoft的Chakra以及其他一些引擎，也使用垃圾收集机制。
- en: Concurrent computing
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发计算
- en: 'Concurrency or concurrent computing is a very common concept nowadays, and
    we''ll discover it at several instances along this book. The official definition
    in Wikipedia ([https://en.wikipedia.org/wiki/Concurrent_computing](https://en.wikipedia.org/wiki/Concurrent_computing))
    says:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 并发或并发计算是当今一个非常常见的概念，我们将在本书的几个实例中了解到它。维基百科上的官方定义是：
- en: '"Concurrent computing is a form of computing in which several computations
    are executed during overlapping time periods—concurrently—instead of sequentially
    (one completing before the next starts). This is a property of a system—this may
    be an individual program, a computer, or a network—and there is a separate execution
    point or "thread of control" for each computation ("process"). A concurrent system
    is one where a computation can advance without waiting for all other computations
    to complete; where more than one computation can advance at the same time."'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “并发计算是一种在重叠时间段内执行多个计算的计算形式——并发——而不是顺序执行（一个完成后再开始下一个）。这是一个系统的属性——这可能是一个单独的程序、计算机或网络——并且每个计算都有一个单独的执行点或“控制线程”。一个并发系统是一个计算可以在等待所有其他计算完成之前继续进行；在多个计算可以同时进行的地方。”
- en: Parallel computing
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行计算
- en: 'Parallel computing is a type of computation in which many calculations are
    carried out simultaneously, operating on the principle that large problems can
    often be divided into smaller ones, which are then solved at the same time. .NET
    offers several variants of this type of computing, which we''ll cover over the
    next few chapters:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 并行计算是一种计算类型，其中许多计算是同时进行的，基于大问题通常可以分解成更小的部分，然后同时解决的原则。.NET提供了这种类型计算的好几种变体，我们将在接下来的几章中介绍：
- en: '![Parallel computing](img/image00402.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![并行计算](img/image00402.jpeg)'
- en: Imperative programming
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制性编程
- en: Imperative programming is a programming paradigm that describes computation
    in terms of the program's state. C#, JavaScript, Java, or C++ are typical examples
    of imperative languages.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 强制性编程是一种编程范式，它用程序的状态来描述计算。C#、JavaScript、Java或C++是强制语言典型的例子。
- en: Declarative programming
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明性编程
- en: In contrast to imperative programming, languages considered declarative describe
    only the desired results without explicitly listing commands or steps that must
    be performed. Many markup languages, such as HTML, XAML, or XSLT, fall into this
    category.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与强制性编程相反，被认为是声明性的语言只描述所需的输出结果，而不明确列出必须执行的命令或步骤。许多标记语言，如HTML、XAML或XSLT，都属于这一类别。
- en: The evolution of .NET
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET的演变
- en: Until the arrival of .NET, the Microsoft programming ecosystem had been ruled
    by a few classic languages, Visual Basic and C++ (with the Microsoft Foundation
    classes) being typical examples of this.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET到来之前，Microsoft的编程生态系统一直由少数经典语言统治，Visual Basic和C++（带有Microsoft Foundation
    Classes）是这种类型的典型例子。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Also known as **MFC**, **Microsoft Foundation Classes** is a library that wraps
    portions of the Windows API in C++ classes, including functionalities that enable
    them to use a default application framework. Classes are defined for many of the
    handle-managed Windows objects and also for predefined windows and common controls.
    It was introduced in 1992 with Microsoft's C/C++ 7.0 compiler for use with 16-bit
    versions of Windows as an extremely thin object-oriented C++ wrapper for the Windows
    API.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为**MFC**（**Microsoft Foundation Classes**），是一个将Windows API的部分功能封装在C++类中的库，包括使它们能够使用默认应用程序框架的功能。为许多句柄管理的Windows对象以及预定义的窗口和常见控件定义了类。它在1992年随着Microsoft的C/C++
    7.0编译器推出，用于与16位版本的Windows一起使用，作为Windows API的一个极其薄的面向对象C++包装器。
- en: However, the big changes proposed by .NET were started using a totally different
    component model approach. Up until 2002, when .NET officially appeared, such a
    component model was **COM** (**Component Object Model**), introduced by the company
    in 1993\. COM is the basis for several other Microsoft technologies and frameworks,
    including OLE, OLE automation, ActiveX, COM+, DCOM, the Windows shell, DirectX,
    **UMDF** (**User-Mode Driver Framework**), and Windows runtime.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，.NET提出的重大变化始于一种完全不同的组件模型方法。直到2002年.NET正式推出之前，这种组件模型是**COM**（**Component Object
    Model**），该公司在1993年引入。COM是包括OLE、OLE自动化、ActiveX、COM+、DCOM、Windows外壳、DirectX、**UMDF**（**User-Mode
    Driver Framework**）和Windows运行时在内的其他几个Microsoft技术和框架的基础。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A device-driver development platform (Windows Driver Development Kit) first
    introduced with Microsoft's Windows Vista operating system is also available for
    Windows XP. It facilitates the creation of drivers for certain classes of devices.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一种设备驱动程序开发平台（Windows Driver Development Kit）首次在Microsoft的Windows Vista操作系统中引入，也适用于Windows
    XP。它便于创建某些类别的设备的驱动程序。
- en: At the time of writing this, COM is a competitor with another specification
    named **CORBA** (**Common Object Request Broker Architecture**), a standard defined
    by the **Object Management Group** (**OMG**), designed to facilitate the communication
    of systems that are deployed on diverse platforms. CORBA enables collaboration
    between systems on different operating systems, programming languages, and computing
    hardware. In its life cycle, it has received a lot of criticism, mainly because
    of poor implementations of the standard.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，COM是另一个名为**CORBA**（**Common Object Request Broker Architecture**）的规范的竞争对手，这是一个由**对象管理组**（**OMG**）定义的标准，旨在促进部署在不同平台上的系统的通信。CORBA使不同操作系统、编程语言和计算硬件上的系统之间能够协作。在其生命周期中，它受到了很多批评，主要是因为标准的实现不佳。
- en: .NET as a reaction to the Java World
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET作为对Java世界的反应
- en: In 1995, a new model was conceived to supersede COM and the unwanted effects
    related to it, especially versions and the use of the Windows Registry on which
    COM depends to define accessible interfaces or contracts; a corruption or modified
    fragment of the registry could indicate that a component was not accessible at
    runtime. Also, in order to install applications, elevated permissions were required,
    since the Windows Registry is a sensible part of the system.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在1995年，为了取代COM及其相关的副作用，特别是版本和依赖于Windows注册表的COM的使用，注册表的损坏或修改片段可能表明组件在运行时不可访问；同时，为了安装应用程序，需要提升权限，因为Windows注册表是系统的一个敏感部分，一个新的模型被构想出来。
- en: A year later, various quarters of Microsoft started making contacts with some
    of the most distinguished software engineers, and these contacts remained active
    over the years. These included architects such as Anders Hejlsberg (who became
    the main author of C# and the principal architect of .NET framework), Jean Paoli
    (one of the signatures in the XML Standard and the former ideologist of AJAX technologies),
    Don Box (who participated in the creation of SOAP and XML Schemas), Stan Lippman
    (one of the fathers of C++, who was working at the time at Disney), Don Syme (the
    architect for generics and the principal author of the F# language), and so on.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一年后，微软的各个部门开始与一些最杰出的软件工程师取得联系，这些联系在多年中一直保持活跃。这些人包括像Anders Hejlsberg（成为C#的主要作者和.NET框架的主要架构师）、Jean
    Paoli（XML标准的签署者之一，也是AJAX技术的早期倡导者）、Don Box（参与了SOAP和XML Schema的创建）、Stan Lippman（C++之父之一，当时在迪士尼工作）、Don
    Syme（泛型的架构师和F#语言的主要作者）等等。
- en: The purpose of this project was to create a new execution platform, free from
    the caveats of COM and one that was able to hold a set of languages to execute
    in a secure and extensible manner. The new platform should be able to program
    and integrate the new world of web services, which had just appeared—based on
    XML—along with other technologies. The initial name of the new proposal was **Next
    Generation Windows Services** (**NGWS**).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的目的是创建一个新的执行平台，一个摆脱COM限制的平台，并且能够以安全和可扩展的方式运行一组语言。新的平台应该能够编程和集成刚刚出现的基于XML的Web服务世界，以及其他技术。新提议的初始名称是**下一代Windows服务**（**NGWS**）。
- en: By late 2000, the first betas of .NET framework were released, and the first
    version appeared on February 13, 2002\. Since then, .NET has been always aligned
    with new versions of the IDE (Visual Studio). The current version of the classic
    .NET framework at the time of writing this is 4.6.1, but we will get into more
    detail on this later in the chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到2000年底，.NET框架的第一个beta版本发布，第一个版本于2002年2月13日推出。从那时起，.NET始终与IDE（Visual Studio）的新版本保持一致。在撰写本文时，经典.NET框架的当前版本是4.6.1，但我们将在此章节的后面更详细地介绍这一点。
- en: An alternative .NET appeared in 2015 for the first time. In the `//BUILD/` event,
    Microsoft announced the creation and availability of another version of .NET,
    called .NET Core.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，首次出现了一个替代.NET。在`//BUILD/`活动中，微软宣布了另一个.NET版本（称为.NET Core）的创建和可用性。
- en: The open source movement and .NET Core
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开源运动和.NET Core
- en: 'Part of an idea for the open source movement and .NET Core comes from a deep
    change in the way software creation and availability is conceived in Redmond nowadays.
    When Satya Nadella took over as the CEO at Microsoft, they clearly shifted to
    a new mantra: *mobile-first, cloud-first*. They also redefined themselves as *a
    company of software and services*.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 开源运动和.NET Core的一部分灵感来源于现在在雷德蒙德对软件创建和可用性的深刻变化。当Satya Nadella成为微软的CEO时，他们明确转向了新的口号：“**移动优先，云优先**”。他们还重新定义了自己为**一家软件和服务公司**。
- en: This meant embracing the open source idea with all its consequences. As a result,
    a lot of the NET Framework has already been opened to the community, and this
    movement will continue until the whole platform is opened, some say. Besides,
    a second purpose (clearly stated several times at the `//BUILD/` event) was to
    create a programming ecosystem powerful enough to allow anyone to program any
    type of application for any platform or device. So, they started to support Mac
    OX and Linux as well as several tools to build applications for Android and iOS.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着接受开源理念及其所有后果。因此，NET Framework的很大一部分已经向社区开放，有人说这一运动将持续到整个平台完全开放。此外，第二个目的（在`//BUILD/`活动上多次明确陈述）是创建一个强大的编程生态系统，足以让任何人能够为任何平台或设备编写任何类型的应用程序。因此，他们开始支持Mac
    OS和Linux，以及为Android和iOS构建应用程序的几个工具。
- en: However, the implications run deeper. If you want to build applications for
    Mac OS and Linux, you need a different **Common Language Runtime** (**CLR**) that
    is able to execute in these platforms without losing out on performance. This
    is where .NET Core comes into play.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，影响更深。如果你想要为Mac OS和Linux构建应用程序，你需要一个不同的**公共语言运行时**（**CLR**），它能够在这些平台上执行而不损失性能。这正是.NET
    Core发挥作用的地方。
- en: 'At the time writing this, Microsoft has published several (ambitious) improvements
    to the .NET ecosystem, mainly based on two different flavors of .NET:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，微软已经发布了针对.NET生态系统的一些（雄心勃勃的）改进，主要基于.NET的两种不同版本：
- en: '![The open source movement and .NET Core](img/image00403.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![开源运动和.NET Core](img/image00403.jpeg)'
- en: The first one is the version that was last available—.NET (.NET framework 4.6.x)—and
    the second one is the new version, intended to allow compilations that are valid
    not only for Windows platforms, but also for Linux and Mac OSes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是最后一个可用的版本——.NET（.NET框架4.6.x），第二个是新版本，旨在允许编译不仅适用于Windows平台，还适用于Linux和Mac
    OS的编译。
- en: NET Core is the generic name for a new open source version of the CLR made available
    in 2015 (updated last November to version 1.1) intended to support multiple flexible
    .NET implementations. In addition, the team is working on something called **.NET
    Native**, which compiles to native code in every destination platform.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core是2015年（上次更新于2015年11月，更新到版本1.1）发布的CLR新开源版本的通用名称，旨在支持多种灵活的.NET实现。此外，该团队正在开发一个名为**.NET
    Native**的项目，它将编译成每个目标平台的本地代码。
- en: However, let's keep on going with the main concepts behind the CLR, from a version-independent
    point of view.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们继续探讨CLR背后的主要概念，从版本无关的角度来看。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The whole project is available on GitHub at [https://github.com/dotnet/coreclr](https://github.com/dotnet/coreclr).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 整个项目可在GitHub上找到：[https://github.com/dotnet/coreclr](https://github.com/dotnet/coreclr)。
- en: Common Language Runtime
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共语言运行时
- en: To address some of the problems of COM and introduce the bunch of new capabilities
    that were requested as part of the new platform, a team at Microsoft started to
    evolve prior ideas (and the names associated with the platform as well). So, the
    framework was soon renamed to **Component Object Runtime** (**COR**) prior to
    the first public beta, when it was finally given the name of Common Language Runtime
    in order to drive the fact that the new platform was not associated with a single
    language.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决COM的一些问题并引入作为新平台一部分所请求的一大批新功能，微软的一个团队开始演进先前的想法（以及与平台相关的名称）。因此，在第一个公开测试版之前，该框架很快被更名为**组件对象运行时**（**COR**），最终被命名为公共语言运行时，以强调新平台与单一语言无关。
- en: 'Actually, there are dozens of compilers available for use with the .NET framework,
    and all of them generate a type intermediate code, which—in turn—is converted
    into native code at execution time, as shown in the following figure:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有数十种编译器可用于.NET框架，它们都会生成类型中间代码，该代码在执行时被转换为本地代码，如下面的图所示：
- en: '![Common Language Runtime](img/image00404.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![公共语言运行时](img/image00404.jpeg)'
- en: The CLR, as well as COM, focuses on contracts between components, and these
    contracts are based on types, but that's where the similarities end. Unlike COM,
    the CLR establishes a well-defined form to specify contracts, which is generally
    known as metadata.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: CLR（公共语言运行时）以及COM（组件对象模型）都侧重于组件之间的契约，这些契约基于类型，但相似之处到此为止。与COM不同，CLR建立了一种明确的形式来指定契约，这通常被称为元数据。
- en: Also, the CLR includes the possibility of reading metadata without any knowledge
    of the underlying file format. Furthermore, such metadata is extensible by means
    of custom attributes, which are strongly typed themselves. Other interesting information
    included in the metadata includes the version information (remember, there should
    be no dependencies of the Registry) and component dependencies.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CLR 包括读取元数据而不需要了解底层文件格式的可能性。此外，这种元数据可以通过自定义属性进行扩展，这些属性本身是强类型的。元数据中包含的其他有趣信息包括版本信息（记住，不应该有对注册表的依赖）和组件依赖。
- en: Besides, for any component (called assembly), the presence of metadata is mandatory,
    which means that it's not possible to deploy the access of a component without
    reading its metadata. In the initial versions, implementations of security were
    mainly based on some evidence included in the metadata. Furthermore, such metadata
    is available for any other program inside or outside the CLR through a process
    called **Reflection**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于任何组件（称为程序集），存在元数据是强制性的，这意味着不可能在没有读取其元数据的情况下部署组件的访问。在初始版本中，安全性的实现主要基于元数据中包含的一些证据。此外，这种元数据通过称为
    **Reflection** 的过程对 CLR 内部的任何程序或外部程序都可用。
- en: Another important difference is that .NET contracts, above all, describe the
    logical structure of types. There are no in-memory representations, reading order
    sequences, alignment or parameter conventions, among other things, as Don Box
    explains in detail in his magnificent Essential .NET ([http://www.amazon.com/Essential-NET-Volume-Language-Runtime/dp/0201734117](http://www.amazon.com/Essential-NET-Volume-Language-Runtime/dp/0201734117)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的区别是，.NET 合同首先描述了类型的逻辑结构。正如 Don Box 在其杰出的《Essential .NET》中详细解释的那样，其中没有内存表示、读取顺序序列、对齐或参数约定等。
- en: Common Intermediate Language
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见中间语言
- en: The way these previous conventions and protocols are resolved in CLR is by means
    of a technique called contract virtualization. This implies that most of the code
    (if not all) written for the CLR doesn't contain the machine code but an intermediate
    language called **Common Intermediate Language** (**CIL**), or just **Intermediate
    Language** (**IL**).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些先前约定和协议在 CLR 中通过一种称为合同虚拟化的技术得到解决。这意味着为 CLR 编写的代码（如果不是所有代码）不包含机器代码，而是一种称为 **常见中间语言**（**CIL**）或简称为
    **中间语言**（**IL**）的中间语言。
- en: CLR never executes CIL directly. Instead, CIL is always translated into native
    machine code prior to its execution by means of a technique called **JIT** (**Just-In-Time**)
    compilation. This is to say that the JIT process always adapts the resulting executable
    code to the destination machine (independent from the developer). There are several
    modes of performing a JIT process, and we'll look at them in more detail later
    in this chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 永远不会直接执行 CIL。相反，CIL 总是通过一种称为 **JIT**（**即时**）编译的技术在执行之前转换为本地机器代码。这意味着 JIT
    过程始终将生成的可执行代码适应目标机器（独立于开发者）。执行 JIT 过程有几种模式，我们将在本章后面更详细地探讨它们。
- en: Thus, CLR is what we might call a type-centered framework. For CLR, everything
    is a type, an object, or a value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，CLR 可以被称为以类型为中心的框架。对于 CLR 来说，一切都是类型、对象或值。
- en: Managed execution
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 托管执行
- en: 'Another critical factor in the behavior of CLR is the fact that programmers
    are encouraged to forget about the explicit management of memory and the manual
    management of threads (especially associated with languages such as C and C++)
    to adopt the new way of execution that the CLR proposes: managed execution.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 行为的另一个关键因素是程序员被鼓励忘记对内存的显式管理和线程的手动管理（尤其是与 C 和 C++ 等语言相关），以采用 CLR 提出的新执行方式：托管执行。
- en: Under managed execution, CLR has complete knowledge of everything that happens
    in its execution context. This includes every variable, method, type, event, and
    so on. This encourages and fosters productivity and eases the path to debugging
    in many ways.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在托管执行下，CLR 对其执行上下文中发生的所有事情都有完全的了解。这包括每个变量、方法、类型、事件等。这鼓励并促进了生产力，并以多种方式简化了调试过程。
- en: '![Managed execution](img/image00405.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![托管执行](img/image00405.jpeg)'
- en: Additionally, CLR supports the creation of runtime code (or generative programming)
    by means of a utility called CodeDOM. With this feature, you can emit code in
    different languages and compile it (and execute it) directly in the memory.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CLR 通过一个名为 CodeDOM 的实用工具支持运行时代码（或生成式编程）的创建。有了这个特性，你可以在不同的语言中生成代码，并直接在内存中编译（和执行）它。
- en: 'All this drives us to the next logical questions: which languages are available
    to be used with this infrastructure, which are the common points among them, how
    is the resulting code assembled and prepared for execution, what are the units
    of stored information (as I said, they''re called assemblies), and finally, how
    is all this information organized and structured into one of these assemblies?'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都引导我们到下一个逻辑问题：可以使用此基础设施的语言有哪些，它们之间有哪些共同点，生成的代码是如何组装和准备执行，存储信息单元（如我所说，它们被称为程序集）是什么，最后，所有这些信息是如何组织并结构化到这些程序集中的？
- en: Components and languages
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件和语言
- en: Every execution environment has a notion of software components. For CLR, such
    components must be written in a CLI-compliant language and compiled accordingly.
    You can read a list of CLI languages on Wikipedia. But the question is what is
    a CLI-compliant language?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每个执行环境都有一个关于软件组件的概念。对于 CLR 来说，这些组件必须用 CLI 兼容的语言编写，并相应地编译。你可以在维基百科上找到 CLI 语言的列表。但问题是什么是
    CLI 兼容的语言？
- en: '**CLI** stands for **Common Language Infrastructure**, and it''s a software
    specification standardized by **ISO** and **ECMA** describing the executable code
    and a runtime environment that allows multiple high-level languages to be used
    on different computer platforms without being rewritten for specific architectures.
    The .NET framework and the free and open source Mono are implementations of CLI.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**CLI** 代表 **通用语言基础设施**，它是由 **ISO** 和 **ECMA** 标准化的软件规范，描述了可执行代码和运行时环境，允许多种高级语言在不同的计算机平台上使用，而无需为特定架构重写。.NET
    框架和免费开源的 Mono 都是 CLI 的实现。'
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that the official sites for these terms and entities are as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些术语和实体的官方网站如下：
- en: '**ISO**: [http://www.iso.org/iso/home.html](http://www.iso.org/iso/home.html)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**ISO**: [http://www.iso.org/iso/home.html](http://www.iso.org/iso/home.html)'
- en: '**ECMA**: [http://www.ecma-international.org/](http://www.ecma-international.org/)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**ECMA**: [http://www.ecma-international.org/](http://www.ecma-international.org/)'
- en: '**MONO**: [http://www.mono-project.com/](http://www.mono-project.com/)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**MONO**: [http://www.mono-project.com/](http://www.mono-project.com/)'
- en: '**CLI languages**: [https://en.wikipedia.org/wiki/List_of_CLI_languages](https://en.wikipedia.org/wiki/List_of_CLI_languages)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**CLI 语言**: [https://en.wikipedia.org/wiki/List_of_CLI_languages](https://en.wikipedia.org/wiki/List_of_CLI_languages)'
- en: 'The most relevant points in the CLI would be as follows (according to Wikipedia):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 中最相关的要点如下（根据维基百科）：
- en: First, to substitute COM, metadata is key and provides information on the architecture
    of assemblies, such as a menu or an index of what you can find inside. Since it
    doesn't depend on the language, any program can read this information.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，为了替代 COM，元数据是关键，它提供了关于组件架构的信息，例如菜单或索引，里面可以找到什么内容。由于它不依赖于语言，任何程序都可以读取这些信息。
- en: That established, there should be a common set of rules to comply in terms of
    data types and operations. This is the **Common Type System** (**CTS**). All languages
    that adhere to CTS can work with a set of rules.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于此，应该有一套共同的规则来遵守数据类型和操作。这就是 **公共类型系统**（**CTS**）。所有遵循 CTS 的语言都可以使用一套规则。
- en: For minimal interoperation between languages, there is another set of rules,
    and this should be common to all programming languages in this group, so a DLL
    made with one language and then compiled can be used by another DLL compiled in
    a different CTS language, for example.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了语言之间的最小互操作性，有一套规则，并且这些规则应该适用于这个组中的所有编程语言，因此用一种语言制作的 DLL 然后编译，可以由用不同 CTS 语言编译的另一个
    DLL 使用，例如。
- en: Finally, we have a Virtual Execution System, which is responsible for running
    this application and many other tasks, such as managing the memory requested by
    the program, organizing execution blocks, and so on.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有一个虚拟执行系统，它负责运行此应用程序以及许多其他任务，例如管理程序请求的内存、组织执行块等。
- en: With all this in mind, when we use a .NET compiler (from now on, compiler),
    we generate a byte stream, usually stored as a file in the local filesystem or
    on a web server.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，当我们使用 .NET 编译器（从现在起，称为编译器）时，我们生成一个字节流，通常以文件的形式存储在本地文件系统或 Web 服务器上。
- en: Structure of an assembly file
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序集文件的结构
- en: Files generated by a compilation process are called assemblies, and any assembly
    follows the basic rules of any other executable file in Windows and adds a few
    extensions and information suitable and mandatory for the execution in a managed
    environment.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过程生成的文件称为程序集，任何程序集都遵循Windows中任何其他可执行文件的基本规则，并添加了一些适合和必需的扩展和信息，以便在托管环境中执行。
- en: In short, we understand that an assembly is just a set of modules containing
    the IL code and metadata, which serve as the primary unit of a software component
    in CLI. Security, versioning, type resolution, processes (application domains),
    and so on, all work on a per-assembly basis.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们理解程序集只是一组包含IL代码和元数据的模块，它们是CLI中软件组件的主要单元。安全性、版本控制、类型解析、进程（应用程序域）等，都是在每个程序集的基础上工作的。
- en: 'The significance of this implies changes in the structure of executable files.
    This leads to a new file architecture represented in the following figure:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这的重要性意味着可执行文件结构的改变。这导致了一个新的文件架构，如下面的图所示：
- en: '![Structure of an assembly file](img/image00406.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![程序集文件的结构](img/image00406.jpeg)'
- en: 'Note that a PE file is one that conforms to the Portable/Executable format:
    a file format for executables, object code, DLLs, FON (Font) files, and others
    used in 32-bit and 64-bit versions of Windows operating systems. It was first
    introduced by Microsoft in Windows NT 3.1, and all later versions of Windows support
    this file structure.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，PE文件是符合可移植/可执行格式的文件：一种用于可执行文件、对象代码、DLLs、FON（字体）文件等文件格式，用于32位和64位版本的Windows操作系统。它最初由微软在Windows
    NT 3.1中引入，所有后续版本的Windows都支持这种文件结构。
- en: 'This is why we find a PE/COFF header in the format, which contains compatible
    information required by the system. However, from the point of view of a .NET
    programmer, what really matters is that an assembly holds three main areas: the
    CLR header, the IL code, and a section with resources (**Native Image Section**
    in the figure).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们在格式中找到一个PE/COFF头，它包含系统所需的兼容信息。然而，从.NET程序员的视角来看，真正重要的是程序集包含三个主要区域：CLR头、IL代码和一个包含资源（如图中的**原生映像部分**）的部分。
- en: Tip
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A detailed description of the PE format is available at [http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx](http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 关于PE格式的详细描述可在[http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx](http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx)找到。
- en: Program execution
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 程序执行
- en: 'Among the libraries linked with CLR, we found a few responsible for loading
    assemblies in the memory and starting and initializing the execution context.
    They''re generally referenced as CLR Loader. Together with some other utilities,
    they provide the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在与CLR链接的库中，我们发现了一些负责在内存中加载程序集、启动和初始化执行上下文的库。它们通常被称为CLR加载器。与其他一些实用工具一起，它们提供了以下功能：
- en: Automatic memory management
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动内存管理
- en: Use of garbage collector
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用垃圾回收器
- en: Metadata access to find information on types
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元数据访问以查找类型信息
- en: Loading modules
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载模块
- en: Analyzing managed libraries and programs
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析托管库和程序
- en: A robust exception management subsystem to enable programs to communicate and
    respond to failures in structured ways
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个强大的异常管理子系统，以使程序能够以结构化的方式通信和响应故障
- en: Native and legacy code interoperability
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生和遗留代码互操作性
- en: A JIT compilation of managed code into native code
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将托管代码即时编译成原生代码
- en: A sophisticated security infrastructure
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个复杂的安全基础设施
- en: 'This loader uses OS services to facilitate the loading, compilation, and execution
    of an assembly. As we''ve mentioned previously, CLR serves as an execution abstraction
    for .NET languages. To achieve this, it uses a set of DLLs, which acts as a middle
    layer between the OS and the application program. Remember that CLR itself is
    a collection of DLLs, and these DLLs work together to define the virtual execution
    environment. The most relevant ones are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此加载器使用OS服务来简化程序集的加载、编译和执行。正如我们之前提到的，CLR作为.NET语言的执行抽象。为了实现这一点，它使用一组DLLs，这些DLLs作为OS和应用程序程序之间的中间层。记住，CLR本身就是一个DLL集合，这些DLLs共同定义了虚拟执行环境。其中最相关的是以下内容：
- en: '`mscoree.dll` (sometimes called shim because it is simply a facade in front
    of the actual DLLs that the CLR comprises)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mscoree.dll`（有时被称为shim，因为它只是CLR所包含的实际DLLs前面的一个门面）'
- en: '`clr.dll`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clr.dll`'
- en: '`mscorsvr.dll` (multiprocessor) or `mscorwks.dll` (uniprocessor)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mscorsvr.dll`（多处理器）或`mscorwks.dll`（单处理器）'
- en: In practice, one of the main roles of `mscoree.dll` is to select the appropriate
    build (uniprocessor or multiprocessor) based on any number of factors, including
    (but not limited to) the underlying hardware.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '在实践中，`mscoree.dll`的主要作用之一是根据包括（但不限于）底层硬件在内的任何数量因素选择适当的构建（单处理器或多处理器）。 '
- en: 'The `clr.dll` is the real manager, and the rest are utilities for different
    purposes. This library is the only one of the CLRs that is located at `$System.Root$`,
    as we can find through a simple search:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`clr.dll`是真正的管理者，其余的都是用于不同目的的实用程序。这个库是CLR中唯一位于`$System.Root$`的库，正如我们可以通过简单的搜索找到的那样：'
- en: '![Program execution](img/image00407.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![程序执行](img/image00407.jpeg)'
- en: 'My system is showing two versions (there are some more), each one ready to
    launch programs compiled for 32-bit or 64-bit versions. The rest of the DLLs are
    located at another place: a secure set of directories generally called **Global
    Assembly Cache** (**GAC**).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我的系统显示两个版本（还有一些其他版本），每个版本都准备好启动为32位或64位版本编译的程序。其余的DLL位于另一个地方：通常称为**全局程序集缓存**（**GAC**）的安全目录集。
- en: Actually, the latest edition of Windows 10 installs files for all versions of
    such GAC, corresponding to versions 1.0, 1.1, 2.0, 3.0, 3.5, and 4.0, although
    several are just placeholders with minimum information, and we only find complete
    versions of .NET 2.0, .NET 3.5 (only partially), and .NET 4.0.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Windows 10的最新版本安装了所有此类GAC的文件，对应于1.0、1.1、2.0、3.0、3.5和4.0版本，尽管其中一些只是具有最少信息的占位符，而我们只找到了.NET
    2.0、.NET 3.5（仅部分）和.NET 4.0的完整版本。
- en: Also, note that these placeholders (for the versions not fully installed) admit
    further installations if some old software requires them to. This is to say that
    the execution of a .NET program relies on the version indicated in its metadata
    and nothing else.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，这些占位符（对于未完全安装的版本）允许进一步安装，如果某些旧软件需要它们的话。这意味着.NET程序的执行依赖于其元数据中指示的版本，而不是其他任何东西。
- en: 'You can check which versions of .NET are installed in a system using the `CLRver.exe`
    utility, as shown in the following figure:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`CLRver.exe`实用程序检查系统中安装的.NET版本，如下图所示：
- en: '![Program execution](img/image00408.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![程序执行](img/image00408.jpeg)'
- en: Internally, several operations take place before execution. When we launch a
    .NET program, we'll proceed just as usual, as if it were just another standard
    executable of Windows.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行之前，内部发生几个操作。当我们启动.NET程序时，我们将像往常一样进行，就像它是Windows的另一个标准可执行文件一样。
- en: Behind the scenes, the system will read the header in which it will be instructed
    to launch `mscore.dll`, which—in turn—will start the whole running process in
    a managed environment. Here, we'll omit all the intricacies inherent to this process
    since it goes far beyond the scope of this book.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，系统将读取包含指令以启动`mscore.dll`的标题，该`mscore.dll`反过来将在托管环境中启动整个运行过程。在这里，我们将省略此过程固有的所有复杂性，因为它远远超出了本书的范围。
- en: Metadata
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元数据
- en: We've mentioned that the key aspect of the new programming model is the heavy
    reliance on metadata. Furthermore, the ability to reflect against metadata enables
    programming techniques in which programs are generated by other programs, not
    humans, and this is where CodeDOM comes into play.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到，新编程模型的关键方面是大量依赖于元数据。此外，对元数据进行反射的能力使得程序可以通过其他程序（而不是人类）生成，这正是CodeDOM发挥作用的地方。
- en: We'll cover some aspects of CodeDOM and its usages when dealing with the language,
    and we'll look at how the IDE itself uses this feature frequently every time it
    creates source code from a template.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理语言时，我们将涵盖CodeDOM的一些方面及其用法，并探讨IDE本身在每次从模板创建源代码时如何频繁地使用此功能。
- en: 'In order to help the CLR find the various pieces of an assembly, every assembly
    has exactly one module whose metadata contains the assembly manifest: an additional
    piece of CLR metadata that acts as a directory of adjunct files that contain additional
    type definitions and code. Furthermore, CLR can directly load modules that contain
    an assembly manifest.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助CLR找到程序集的各个部分，每个程序集恰好有一个模块，其元数据包含程序集清单：这是CLR元数据的附加部分，充当包含附加类型定义和代码的辅助文件的目录。此外，CLR可以直接加载包含程序集清单的模块。
- en: So, what is the aspect of a manifest in a real program and how can we examine
    its content? Fortunately, we have a bunch of .NET utilities (which, technically,
    don't belong to CLR but to the .NET framework ecosystem) that allow us to visualize
    this information easily.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在真实程序中，清单的方面是什么，我们如何检查其内容呢？幸运的是，我们有一系列.NET实用工具（从技术上讲，它们不属于CLR，而是属于.NET框架生态系统），这些工具使我们能够轻松地可视化这些信息。
- en: Introducing metadata with a basic Hello World
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用基本的Hello World介绍元数据
- en: Let's build a typical Hello World program and analyze its contents once it is
    compiled so that we can inspect how it's converted into **Intermediate Language**
    (**IL**) and where the meta-information that we're talking about is.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个典型的Hello World程序，并在编译后分析其内容，这样我们就可以检查它如何转换为**中间语言**（**IL**）以及我们所讨论的元信息在哪里。
- en: Along the course of this book, I'll use Visual Studio 2015 Community Edition
    Update 1 (or higher if an updated version appears) for reasons that I'll explain
    later. You can install it for free; it's a fully capable version with tons of
    project types, utilities, and so on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我将使用Visual Studio 2015社区版更新1（或如果出现更新版本，则使用更高版本），原因我将在后面解释。你可以免费安装它；这是一个功能齐全的版本，拥有大量的项目类型、实用工具等。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Visual Studio 2015 CE update 1 is available at [https://www.visualstudio.com/vs/community/](https://www.visualstudio.com/vs/community/).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2015 CE更新1可在[https://www.visualstudio.com/vs/community/](https://www.visualstudio.com/vs/community/)获取。
- en: The only requirement is to register for free in order to get a developer's license
    that Microsoft uses for statistical purposes—that's all.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的要求是免费注册以获取微软用于统计目的的开发者许可证——仅此而已。
- en: 'After launching Visual Studio, in the main menu, select **New Project** and
    go to the **Visual C#** templates, where the IDE offers several project types,
    and select a console application, as shown in the following screenshot:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动Visual Studio后，在主菜单中选择**新建项目**，然后转到**Visual C#**模板，在那里IDE提供了几种项目类型，并选择一个控制台应用程序，如图所示：
- en: '![Introducing metadata with a basic Hello World](img/image00409.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![使用基本的Hello World介绍元数据](img/image00409.jpeg)'
- en: Visual Studio will create a basic code structure composed of several references
    to libraries (more about that later) as well as a namespace block that includes
    the `program` class. Inside that class, we will find an application entry point
    in a fashion similar to what we would find in C++ or Java languages.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio将创建一个基本的代码结构，由对库的几个引用（关于这一点稍后讨论）以及包含`program`类的命名空间块组成。在这个类内部，我们将找到一个类似于C++或Java语言中的应用程序入口点。
- en: 'To produce some kind of output, we''re going to use two static methods of the
    `Console` class: `WriteLine`, which outputs a string adding a carriage return,
    and `ReadLine`, which forces the program to stop until the user introduces a character
    and presses the return key so that we can see the output that is produced.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了产生某种输出，我们将使用`Console`类的两个静态方法：`WriteLine`，它输出一个字符串并添加换行符，以及`ReadLine`，它强制程序停止，直到用户输入一个字符并按下回车键，这样我们就可以看到产生的输出。
- en: 'After cleaning these references that we''re not going to use, and including
    the couple of sentences mentioned previously, the code will look like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在清理这些我们不会使用的引用，并包括之前提到的几句话后，代码将看起来像这样：
- en: '[PRE1]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To test it, we just have to press *F5* or the **Start** button and we'll see
    the corresponding output (nothing amazing, so we're not including the capture).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试它，我们只需按下*F5*或**启动**按钮，我们就会看到相应的输出（没有什么惊人的，所以我们不包括截图）。
- en: 'At the time of editing the code, you will have noticed several useful characteristics
    of the IDE''s editor: the colorizing of sentences (distinguishing the different
    purposes: classes, methods, arguments, literals, and so on); **IntelliSense**,
    which offers what makes sense to write for every class'' member; **Tooltips**,
    indicating every return type for methods; the value type for literals or constants;
    and the number of references made to every member of the program that could be
    found in your code.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑代码的时候，你会注意到IDE编辑器的几个有用特性：语句的着色（区分不同的目的：类、方法、参数、字面量等）；**IntelliSense**，为每个类的成员提供合理的内容；**工具提示**，指示每个方法的返回类型；字面量或常量的值类型；以及程序中每个成员的引用次数。
- en: Technically, there are hundreds of other useful features, but that's something
    we will have the chance to test starting from the next chapter, when we get into
    the C# aspects and discover how to prove them.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，还有数百个其他有用的功能，但这些都是我们将在下一章中测试的内容，当我们进入C#方面并发现如何证明它们时。
- en: 'As for this little program, it''s a bit more interesting to check what produced
    such output, which we''ll find in the `Bin/Debug` folder of our project. (Remember
    to press the **Show all files** button at the head of Solution Explorer, by the
    way):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个小程序，检查它产生了什么样的输出会更有趣一些，这些输出我们可以在我们项目的`Bin/Debug`文件夹中找到。（顺便提醒一下，记得在解决方案资源管理器顶部按下**显示所有文件**按钮）：
- en: '![Introducing metadata with a basic Hello World](img/image00410.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![使用基本的Hello World介绍元数据](img/image00410.jpeg)'
- en: As we can see, two executables are generated. The first one is the standalone
    executable that you can launch directly from its folder. The other, with the `.vshost`
    prefix before the extension, is the one Visual Studio uses at debug time and that
    contains some extra information required by the IDE. Both produce the same results.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，生成了两个可执行文件。第一个是你可以直接从其文件夹中启动的独立可执行文件。另一个，扩展名前有`.vshost`前缀，是Visual Studio在调试时使用的，它包含IDE所需的额外信息。两者产生相同的结果。
- en: Once we have an executable, it is time to link the .NET tool – that will let
    us view the metadata that we're talking about – to Visual Studio.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了可执行文件，就是时候将.NET工具链接到Visual Studio了——这将让我们查看我们正在讨论的元数据。
- en: 'To do this, we go to the **Tools** | **External Tools** option in the main
    menu, and we''ll see a configuration dialog window, presenting several (and already
    tuned) external tools available; press the **New** button and change the title
    to `IL Disassembler`, as shown in the following screenshot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个操作，我们需要在主菜单中选择**工具** | **外部工具**选项，然后我们会看到一个配置对话框窗口，其中展示了几个（并且已经调整好的）外部工具；按下**新建**按钮，并将标题更改为`IL反汇编器`，如图所示：
- en: '![Introducing metadata with a basic Hello World](img/image00411.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![使用基本的Hello World介绍元数据](img/image00411.jpeg)'
- en: 'Next, we need to configure the arguments that we''re going to pass to the new
    entry: the name of the tool and the required parameters.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置将要传递给新条目的参数：工具的名称和所需的参数。
- en: You'll notice that there are several versions of this tool. These depend on
    your machine.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这个工具有几个版本。这些取决于你的机器。
- en: 'For our purposes, it will suffice to include the following information:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，包含以下信息就足够了：
- en: The root of the tool (named `ILDASM.exe`, and located in my machine at `C:\Program
    Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.6.1 Tools`)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具的根目录（命名为`ILDASM.exe`，位于我的机器上`C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX
    4.6.1 Tools`）
- en: The path of the executable generated, for which I'm using a predefined macro
    expressed by `$targetpath`
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成的可执行文件的路径，我使用的是由`$targetpath`表示的预定义宏
- en: 'Given that our program is already compiled, we can go back to the **Tools**
    menu and find a new entry for `IL Disassembler`. Once launched, a window will
    appear, showing the IL code of our program, plus a reference called `Manifest`
    (which shows the metadata), and we can also double-click to show another window
    with this information, as shown in the following screenshot:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的程序已经编译，我们可以回到**工具**菜单，并找到一个名为`IL反汇编器`的新条目。一旦启动，会出现一个窗口，显示我们程序的IL代码，以及一个名为`Manifest`的引用（显示元数据），我们还可以双击以显示包含此信息的另一个窗口，如图所示：
- en: '![Introducing metadata with a basic Hello World](img/image00412.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![使用基本的Hello World介绍元数据](img/image00412.jpeg)'
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that I've modified ILDASM's font size for clarity.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经修改了ILDASM的字体大小以提高清晰度。
- en: 'The information included in the manifest comes from two sources: the IDE itself,
    configured to prepare the assembly for execution (we can view most of the lines
    if we take a more detailed look at the window''s content), and customizable information
    that we can embed in the executable''s manifest, such as descriptions, the assembly
    title, the company information, trademark, culture, and so on. We''ll explore
    how to configure that information in the next chapter.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在清单中的信息来自两个来源：IDE本身，配置为准备程序执行（如果我们更详细地查看窗口内容，我们可以查看大多数行），以及我们可以嵌入到可执行文件清单中的可自定义信息，例如描述、程序标题、公司信息、商标、文化等等。我们将在下一章中探讨如何配置这些信息。
- en: 'In the same manner, we can keep on analyzing the contents of every single node
    shown in the main ILDASM window. For instance, if we want to see the IL code linked
    to our `Main` entry point, the tool will show us another window where we can appreciate
    the aspect of the IL code (note the presence of the text `cil` managed next to
    the declaration of main):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，我们可以继续分析主ILDASM窗口中显示的每个单独节点的内容。例如，如果我们想查看与我们的`Main`入口点链接的IL代码，该工具将显示另一个窗口，我们可以欣赏IL代码的方面（注意声明main旁边的文本`cil`托管）：
- en: '![Introducing metadata with a basic Hello World](img/image00413.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![使用基本Hello World介绍元数据](img/image00413.jpeg)'
- en: As I pointed out in the screenshot, entries with the prefix `IL_` will be converted
    to the machine code at execution time. Note the resemblance of these instructions
    with the Assembly language.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在截图中所指出的，带有前缀`IL_`的条目将在执行时转换为机器代码。注意这些指令与汇编语言的相似性。
- en: 'Also, keep in mind that this concept has not changed since the first version
    of .NET: main concepts and procedures to generate CIL and machine code are, basically,
    the same as they used to be.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，这个概念自.NET的第一个版本以来没有改变：生成CIL和机器代码的主要概念和过程基本上与以前相同。
- en: PreJIT, JIT, EconoJIT, and RyuJIT
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PreJIT、JIT、EconoJIT和RyuJIT
- en: I have already mentioned that the process of converting this IL code into machine
    code is undertaken by another piece of the .NET framework, generically known as
    **Just-In-Time Compiler** (**JIT**). However, since the very beginning of .NET,
    this process can be executed in at least three different ways, which is why there
    are three JIT-suffixed names.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到，将此IL代码转换为机器代码的过程由.NET框架的另一部分执行，通常称为**即时编译器**（**JIT**）。然而，自从.NET的最初版本以来，这个过程可以以至少三种不同的方式执行，这就是为什么有三个以JIT后缀命名的名称。
- en: 'To simplify the details of these processes, we''ll say that the default method
    of compilation (and the preferred one in general terms) is the JIT compilation
    (let''s call it Normal JIT):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这些过程的细节，我们将说默认的编译方法（以及在一般术语中首选的方法）是JIT编译（让我们称之为正常JIT）：
- en: In the Normal JIT mode, the code is compiled as required (on demand) and not
    thrown away but cached for a later use. In this fashion, as the application keeps
    on running, any code required for execution at a later time that is already compiled
    is just retrieved from the cached area. The process is highly optimized and the
    performance penalty is negligible.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在正常JIT模式下，代码按需编译（按需）并且不会丢弃，而是缓存以供以后使用。以这种方式，随着应用程序的持续运行，任何以后需要执行且已经编译的代码只需从缓存区域检索即可。这个过程高度优化，性能损失可以忽略不计。
- en: In the PreJIT mode, .NET operates in a different manner. To operate using PreJIT,
    you need a utility called `ngen.exe` (which stands for native generation) to produce
    native machine code previous to the first execution. The code is then converted
    and `.exe` is rewritten into the machine code, which gives some optimization,
    especially at start time.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PreJIT模式下，.NET以不同的方式运行。要使用PreJIT运行，你需要一个名为`ngen.exe`（代表原生生成）的工具来在第一次执行之前生成原生机器代码。然后，代码被转换，`.exe`文件被重写为机器代码，这提供了一些优化，尤其是在启动时间方面。
- en: As for the EconoJIT mode, it's used mainly in applications deployed for low-memory
    devices, such as mobiles, and it's pretty similar to NormalJIT with the difference
    that the compiled code is not cached in order to save memory.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至于EconoJIT模式，它主要用于部署在低内存设备上的应用程序，如手机，并且它与NormalJIT非常相似，区别在于编译的代码不会被缓存以节省内存。
- en: In 2015, Microsoft continued to develop a special project called Roslyn, which
    is a set of tools and services to provide extra functionalities to the process
    of code management, compilation, and deployment, among others. In connection with
    this project (which will be treated in depth in [Chapter 4](part0028.xhtml#aid-QMFO2
    "Chapter 4. Comparing Approaches for Programming"), *Comparing Approaches for
    Programming*), another JIT appeared, called RyuJIT, which has been made available
    since the beginning as an open source project and is now included in the latest
    version of V. Studio by default (remember, V. Studio 2015 Update 1).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在2015年，微软继续开发一个名为Roslyn的特殊项目，这是一个提供额外功能（包括代码管理、编译和部署等）的工具和服务集合。与这个项目（将在[第4章](part0028.xhtml#aid-QMFO2
    "第4章。比较编程方法")中深入探讨，*比较编程方法*)相关联，另一个JIT出现了，称为RyuJIT，它从一开始就被作为一个开源项目提供，现在默认包含在最新的Visual
    Studio版本中（记住，Visual Studio 2015更新1）。
- en: 'Now, let me quote what the .NET team says about their new compiler:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我引用.NET团队关于他们新编译器的话：
- en: '"RyuJIT is a new, next-generation x64 compiler twice as fast as the one before,
    meaning apps compiled with RyuJIT start up to 30% faster (Time spent in the JIT
    compiler is only one component of startup time, so the app doesn''t start twice
    as fast just because the JIT is twice as fast.) Moreover, the new JIT still produces
    great code that runs efficiently throughout the long run of a server process.'
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"RyuJIT是一个新的、下一代x64编译器，比之前的编译器快一倍，这意味着使用RyuJIT编译的应用程序启动速度可以快达30%（JIT编译器花费的时间只是启动时间的一个组成部分，所以应用程序的启动速度不会因为JIT编译器快一倍而快两倍。）此外，新的JIT编译器仍然生成在整个服务器进程长时间运行中运行高效的代码。'
- en: ''
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This graph compares the compile time ("throughput") ratio of JIT64 to RyuJIT
    on a variety of code samples. Each line shows the multiple of how much faster
    RyuJIT is than JIT64, so higher numbers are better."
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此图比较了JIT64和RyuJIT在各种代码样本上的编译时间（"吞吐量"）比率。每一行显示了RyuJIT比JIT64快多少倍，所以数字越高越好。"
- en: '![PreJIT, JIT, EconoJIT, and RyuJIT](img/image00414.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![PreJIT, JIT, EconoJIT, 和 RyuJIT](img/image00414.jpeg)'
- en: 'They finish by saying that RyuJIT will be the basis for all their JIT compilers
    in the future: x86, ARM, MDIL, and whatever else comes along.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 他们最后说，RyuJIT将成为他们未来所有JIT编译器的基础：x86、ARM、MDIL以及未来可能出现的任何其他技术。
- en: Common Type System
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公共类型系统
- en: In the .NET framework, the **Common Type System** (**CTS**) is the set of rules
    and specifications established to define, use, and manage the data types used
    by any .NET application in a language-independent manner.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET框架中，**公共类型系统**（**CTS**）是一组规则和规范，用于以语言无关的方式定义、使用和管理任何.NET应用程序使用的数据类型。
- en: We must understand that types are the building blocks of any CLR program. Programming
    languages such as C#, F#, and VB.NET have several constructs for expressing types
    (for example, `classes`, `structs`, `enums`, and so on), but ultimately, all of
    these constructs map down to a CLR type definition.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须理解，类型是任何CLR程序的基本构建块。例如，C#、F#和VB.NET等编程语言都有几种表达类型的结构（例如，`类`、`结构体`、`枚举`等），但最终，所有这些结构都映射到CLR类型定义。
- en: Also, note that a type can declare private and non-private members. The latter
    form, sometimes known as the contract of the type (since it exposes the usable
    part of that type), is what we can access by programming techniques. This is the
    reason why we highlighted the importance of metadata in the CLR.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，类型可以声明私有和非私有成员。后一种形式，有时被称为类型的合约（因为它暴露了该类型的可用部分），是我们可以通过编程技术访问的。这就是为什么我们强调了在CLR中元数据的重要性。
- en: The common type system is much broader than what most programming languages
    can handle. In addition to the CTS, a subdivision named CLI selects a subset of
    the CTS that all languages compatible with CLI must endure. This subset is called
    **Common Language Specification** (**CLS**), and component writers are recommended
    to make their components' functionalities accessible through CLS-compatible types
    and members.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 公共类型系统比大多数编程语言能够处理的内容要广泛得多。除了CTS之外，一个名为CLI的子集选择CTS的一个子集，所有与CLI兼容的语言都必须遵守这个子集。这个子集被称为**公共语言规范**（**CLS**），建议组件编写者通过CLS兼容的类型和成员使他们的组件功能可访问。
- en: Naming conventions, rules, and type access modes
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 命名约定、规则和类型访问模式
- en: 'As for the naming rules for a type, this is what applies: any CLR type name
    has three parts: the assembly name, an optional namespace prefix, and a local
    name. In the previous example, `ConsoleApplication1` was the assembly name, and
    it was the same as the namespace (but we could have changed it without problems).
    Program was the name of the only type available, which happened to be a class
    in this case. So, the whole name of this class was `ConsoleApplication1.ConsoleApplication1.Program`.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 至于类型的命名规则，这是适用的：任何CLR类型名称都有三个部分：程序集名称、可选的命名空间前缀和本地名称。在先前的例子中，`ConsoleApplication1`是程序集名称，它与命名空间相同（但我们也可以在不出现问题的情况下更改它）。`Program`是唯一可用的类型的名称，在这个例子中恰好是一个类。因此，这个类的完整名称是`ConsoleApplication1.ConsoleApplication1.Program`。
- en: Namespaces are optional prefixes that help us define logical divisions in our
    code. Their purpose is to avoid confusion and the eventual overriding of members
    as well as allowing a more organized distribution of the application's code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是可选的前缀，有助于我们在代码中定义逻辑分区。它们的目的在于避免混淆和成员的最终覆盖，以及允许应用程序代码的更有组织的分布。
- en: For example, in a typical application (not the demo shown earlier), a namespace
    would describe the whole solution, which might be separated into domains (different
    areas in which the application is divided, and they sometimes correspond to individual
    projects in the solution), and every domain would most likely contain several
    classes, and each class would contain several members. When you're dealing with
    solutions that hold, for instance, 50 projects, such logical divisions are very
    helpful in order to keep things under control.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个典型的应用中（不是之前展示的演示），一个命名空间会描述整个解决方案，这可能被分为几个域（应用被划分的不同区域，有时它们对应于解决方案中的单个项目），每个域很可能包含几个类，每个类都包含几个成员。当你处理包含例如50个项目的解决方案时，这种逻辑划分对于保持事物在控制之下非常有帮助。
- en: As for the way that a member of a type can be accessed, each member manages
    how it can be used as well as how the type works. So, each member has its own
    access modifier (for example, `private`, `public`, or `protected`) that controls
    how it should be reached and whether that member is visible to other members.
    If we don't specify any access modifier, it is assumed that it is `private`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 至于类型成员的访问方式，每个成员都管理它如何被使用以及类型如何工作。因此，每个成员都有自己的访问修饰符（例如，`private`、`public`或`protected`），它控制了如何访问它以及该成员是否对其他成员可见。如果我们没有指定任何访问修饰符，则假定它是`private`。
- en: Besides, you can establish whether an instance of the type is required to reference
    a member, or you can just reference such a member by its whole name without having
    to call the constructor and get an instance of the type. In such cases, we prefix
    the declaration of these members with the `static` keyword.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以确定是否需要引用类型的实例来引用成员，或者你可以通过其完整名称直接引用这样的成员，而无需调用构造函数并获取类型的实例。在这种情况下，我们在这些成员的声明前加上`static`关键字。
- en: Members of a type
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类型成员
- en: 'Basically, a type admits three kinds of members: fields, methods, and nested
    types. By nested type, we understand just another type that is included as part
    of the implementation of the declaring type. All other type members (for example,
    properties and events) are simply methods that have been extended with additional
    metadata.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，一个类型接受三种类型的成员：字段、方法和嵌套类型。通过嵌套类型，我们理解的是作为声明类型实现的一部分包含的另一个类型。所有其他类型成员（例如，属性和事件）仅仅是扩展了额外元数据的简单方法。
- en: I know, you might be thinking, *so, properties are methods?* Well, yes; once
    compiled, the resulting code turns into methods. They convert into `name_of_class.set_method(value)`
    and `name_of_class.get_method()` methods in charge of assigning or reading the
    values linked to the method's name.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，你可能正在想，“所以，属性是方法吗？”嗯，是的；一旦编译，生成的代码就变成了方法。它们转换成了`name_of_class.set_method(value)`和`name_of_class.get_method()`方法，负责分配或读取与方法名称相关联的值。
- en: 'Let''s review this with a very simple class that defines a couple of methods:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个非常简单的类来回顾一下，这个类定义了一些方法：
- en: '[PRE2]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Well, once compiled, we can check out the resulting IL code using IL dissasembler
    as we did earlier, obtaining the following view:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，一旦编译，我们可以像之前一样使用IL反汇编器检查生成的IL代码，获得以下视图：
- en: '![Members of a type](img/image00415.jpeg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![类型成员](img/image00415.jpeg)'
- en: As we can see, the compiler declares `data` and `num` as instances of the `string`
    and `int` classes, respectively, and it defines the corresponding methods to access
    these properties.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，编译器将`data`和`num`声明为`string`和`int`类的实例，并定义了相应的访问这些属性的方法。
- en: 'How does the CLR manage the memory space occupied by a type at runtime? If
    you remember, we highlighted the importance of the concept of state at the beginning
    of this chapter. The significance is clear here: the kind of members defined in
    the type will determine the memory allocation required.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: CLR如何在运行时管理类型占用的内存空间？如果你记得，我们在本章开头强调了状态概念的重要性。其意义在这里很清楚：类型中定义的成员类型将决定所需的内存分配。
- en: 'Also, the CLR will guarantee that these members are initialized to their default
    values in case we indicate it in the declaring sentences: for numeric types, the
    default value is zero; for Boolean types, it''s `false`, and for object references,
    the value is `null`.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CLR将保证，如果我们在声明语句中指定了它，这些成员将被初始化为其默认值：对于数值类型，默认值是零；对于布尔类型，是`false`，对于对象引用，值是`null`。
- en: 'We can also categorize types depending on their memory allocation: value types
    are stored in the stack, while reference types will use the heap. A deeper explanation
    of this will be provided in the next chapter, since the new abilities of Visual
    Studio 2015 allow us to analyze everything that happens at runtime in great detail
    with our code under a bunch of different points of view.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以根据内存分配对类型进行分类：值类型存储在栈中，而引用类型将使用堆。关于这一点将更深入地解释，因为Visual Studio 2015的新功能允许我们以许多不同的视角详细分析代码在运行时发生的一切。
- en: A quick tip on the execution and memory analysis of an assembly in Visual Studio
    2015
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Visual Studio 2015中程序集执行和内存分析的快速提示
- en: 'All the concepts reviewed up until here are directly available using the new
    debugging tools, as shown in the following screenshot, which displays the execution
    threads of the previous program stopped in a breakpoint:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们回顾的所有概念都可以直接使用新的调试工具获得，如下面的截图所示，它显示了之前程序在断点处停止的执行线程：
- en: '![A quick tip on the execution and memory analysis of an assembly in Visual
    Studio 2015](img/image00416.jpeg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![Visual Studio 2015中程序集执行和内存分析的快速提示](img/image00416.jpeg)'
- en: 'Note the different icons and columns of the information provided by the tool.
    We can distinguish known and unknown threads, if they are named (or not), their
    location, and even `ThreadID`, which we can use in conjunction with SysInternals
    tools if we need some extra information that''s not included here:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意工具提供的信息中的不同图标和列。我们可以区分已知和未知的线程，如果它们被命名（或未命名），它们的位置，甚至`ThreadID`，如果我们需要一些这里未包含的额外信息，我们可以将其与SysInternals工具结合使用：
- en: '![A quick tip on the execution and memory analysis of an assembly in Visual
    Studio 2015](img/image00417.jpeg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![Visual Studio 2015中程序集执行和内存分析的快速提示](img/image00417.jpeg)'
- en: The same features are available for memory analysis. It even goes beyond the
    runtime periods, since the IDE is able to capture and categorize the usage of
    the memory required by the runtime in the application execution and keep it ready
    for us if we take a snapshot of the managed memory.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的功能也适用于内存分析。它甚至超越了运行时周期，因为IDE能够捕获并分类应用程序执行中运行时所需的内存使用情况，并在我们进行内存快照时为我们准备好。
- en: In this way, we can review it further and check out the possible bottlenecks
    and memory leaks. The preceding screenshot shows the managed memory used by the
    previous application at runtime.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以进一步审查它，并检查可能的瓶颈和内存泄漏。前面的截图显示了之前的应用程序在运行时使用的托管内存。
- en: A review of the capabilities of debugging found in Visual Studio 2015 will be
    covered in depth along the different chapters in this book, since there are many
    different scenarios in which an aid like this will be helpful and clear.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的不同章节将深入探讨Visual Studio 2015中发现的调试功能，因为有许多不同的场景，这种辅助工具将非常有帮助且清晰。
- en: The stack and the heap
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈和堆
- en: A quick reminder of these two concepts might be helpful since it transcends
    the .NET framework, and it's something that's common to many languages and platforms.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个概念的快速回顾可能很有帮助，因为它们超越了.NET框架，并且是许多语言和平台共有的。
- en: 'To start with, let''s remember a few concepts related to processes that we
    saw at the beginning of this chapter: when a program starts execution, it initializes
    resources based on the metadata that the CLR reads from the assembly''s manifest
    (as shown in the figure given in the *The structure of an assembly file* section).
    These resources will be shared with all the threads that such a process launches.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下本章开头提到的与进程相关的一些概念：当程序开始执行时，它会根据CLR从程序集的清单中读取的元数据初始化资源（如图*程序集文件结构*部分所示）。这些资源将与其他线程共享，这些线程是该进程启动的。
- en: 'When we declare a variable, a space in the stack in allocated. So, let''s start
    with the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明一个变量时，栈中会分配一个空间。所以，让我们从以下代码开始：
- en: '[PRE3]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we try to compile this, we'll obtain a compilation error message indicating
    the use of non-assigned variable `b`. The reason is that in memory, we just have
    a declared variable and it's assigned to null, since we didn't instantiate `b`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试编译它，我们会得到一个编译错误消息，指示使用了未分配的变量`b`。原因是，在内存中，我们只有一个已声明的变量，并且它被分配为null，因为我们没有实例化`b`。
- en: However, if we use the constructor of the class (the default one, since the
    class has no explicit constructor), changing the line to `Book b = new Book();`,
    then our code compiles and executes properly.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用类的构造函数（默认构造函数，因为该类没有显式构造函数），将行更改为`Book b = new Book();`，那么我们的代码可以正确编译和执行。
- en: Therefore, the role of the `new` operator is crucial here. It indicates to the
    compiler that it has to allocate space for a new instance of the `Book` object,
    call the constructor, and—as we'll discover soon—initialize the object's fields
    to their default value types.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`new`运算符在这里的作用至关重要。它向编译器指示它必须为`Book`对象的新实例分配空间，调用构造函数，并且——我们将很快发现——将对象的字段初始化为其默认值类型。
- en: 'So, what''s in the stack memory at the moment? Well, we just have a declaration
    called `b`, whose value is a memory address: exactly the address where `StackAndHeap.Book`
    is declared in the Heap (which I anticipate will be `0x2525910`).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，此刻栈内存中有什么？嗯，我们只有一个名为`b`的声明，其值为一个内存地址：正好是`StackAndHeap.Book`在堆中声明的地址（我预计将是`0x2525910`）。
- en: However, how in the world will I know this address and what's going on inside
    the execution context? Let's take a look at the inner workings of this small application
    as Visual Studio offers different debugging windows available in this version
    of the IDE. To do this, we'll mark a breakpoint in line 14, `Console.ReadLine();`,
    and relaunch the application so that it hits the breakpoint.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我究竟如何知道这个地址以及执行上下文中发生了什么？让我们看看这个小型应用程序的内部工作原理，因为Visual Studio提供了IDE本版本中可用的不同调试窗口。为此，我们将在第14行`Console.ReadLine();`处设置一个断点，并重新启动应用程序，以便它触碰到断点。
- en: Once here, there's plenty of information available. In the **Diagnostics Tools**
    window (also new in this version of the IDE), we can watch the memory in use,
    the events, and the CPU usage. In the **Memory Usage** tab, we can take a snapshot
    of what's going on (actually, we can take several snapshots at different moments
    of execution and compare them).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦到达这里，就有大量信息可供参考。在**诊断工具**窗口（也是IDE本版本的新功能），我们可以监视内存使用情况、事件和CPU使用率。在**内存使用**选项卡中，我们可以拍摄正在发生的事情的快照（实际上，我们可以在执行的不同时刻拍摄多个快照并比较它们）。
- en: 'Once the snapshot is ready, we''ll look at the time elapsed, the size of objects,
    and the Heap size (along with some other options to improve the experience):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦快照准备就绪，我们将查看经过的时间、对象的大小以及堆大小（以及一些其他选项以改善体验）：
- en: '![The stack and the heap](img/image00418.jpeg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![栈和堆](img/image00418.jpeg)'
- en: Note that we can choose to view the Heap sorted by the object size or the heap
    size. Also, if we choose one of these, a new window appears, showing every component
    actually in the execution context.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以选择按对象大小或堆大小对堆进行排序。此外，如果我们选择其中之一，将出现一个新窗口，显示执行上下文中实际存在的每个组件。
- en: If we want to check exactly what our code is doing, we can filter by the name
    of the desired class (`Book`, in this case) in order to get an exclusive look
    at this object, its instances, the references to the object alive in the moment
    of execution, and a bunch of other details.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想确切了解我们的代码正在做什么，我们可以通过选择所需类的名称（在这种情况下为`Book`）进行过滤，以便仅查看此对象、其实例、在执行时刻存活的对该对象的引用以及大量其他细节。
- en: 'Of course, if we take a look at the **Autos** or **Locals** windows, we''ll
    discover the actual values of these members as well:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们查看**自动变量**或**局部变量**窗口，我们也会发现这些成员的实际值：
- en: '![The stack and the heap](img/image00419.jpeg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![栈和堆](img/image00419.jpeg)'
- en: As we can see in the **Autos** window, the object has initialized the remaining
    values (those not established by code) using the default value for that type (0
    for integer values). This level of detail in the analysis of executables really
    helps in cases where bugs are fuzzy or only happen occasionally.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在**自动变量**窗口中所见，对象使用该类型的默认值（对于整数值为0）初始化了剩余的值（那些由代码未设置的值）。这种分析可执行文件的程度在出现模糊或偶尔发生的错误时非常有帮助。
- en: 'We can even see the actual memory location of every member by clicking on the
    **StackAndHeap.Book** entry:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过单击**StackAndHeap.Book**条目来查看每个成员的实际内存位置：
- en: '![The stack and the heap](img/image00420.jpeg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![栈和堆](img/image00420.jpeg)'
- en: 'Perhaps you''re wondering, can we even see further? (I mean the actual assembly
    code produced by the execution context). The answer, again, is yes; we can right-click
    on the instance, select **Add Watch**, and we''ll be adding an inspection point
    directly to that memory position, as shown in the following figure:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你在想，我们甚至能看到更远的地方吗？（我的意思是执行上下文实际产生的汇编代码）。答案是，是的；我们可以右键单击实例，选择**添加监视**，然后我们将在该内存位置直接添加一个检查点，如图所示：
- en: '![The stack and the heap](img/image00421.jpeg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![栈和堆](img/image00421.jpeg)'
- en: 'Of course, the assembly code is available as well, as long as we have enabled
    it by navigating to **Tools** | **Options** | **Debugger** in the IDE. Also, in
    this case, you should enable **Enable Address Level Debugging** in the same dialog
    box. After this, just go to **Debug** | **Windows** | **Dissasembly**, and you
    will be shown the window with the lowest level (executable) code marking the breakpoint,
    line numbers, and the translation of such code into the original C# statement:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，汇编代码也是可用的，只要我们在IDE中导航到**工具** | **选项** | **调试器**并启用它。此外，在这种情况下，你应在同一个对话框中启用**启用地址级调试**。之后，只需转到**调试**
    | **窗口** | **反汇编**，你将看到一个带有最低级别（可执行）代码的窗口，标记着断点、行号以及将这些代码翻译成原始C#语句：
- en: '![The stack and the heap](img/image00422.jpeg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![栈和堆](img/image00422.jpeg)'
- en: What happens when the reference to the `Book` object is reassigned or nulled
    (and the program keeps going on)? The memory allocated for `Book` remains in the
    memory as an orphan, and it's then when garbage collector comes into play.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当对`Book`对象的引用被重新分配或置为null（并且程序继续运行）时，为`Book`分配的内存将作为孤儿保留在内存中，这时垃圾收集器就会介入。
- en: Garbage collection
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 垃圾收集
- en: Basically, garbage collection is the process of reclaiming memory from the system.
    Of course, this memory shouldn't be in use; that is, the space occupied by the
    objects allocated in Heap should not have any variable pointing to them in order
    to be cleared.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，垃圾收集是从系统中回收内存的过程。当然，这些内存不应该在使用中；也就是说，堆中分配的对象占用的空间不应该有任何变量指向它们，以便清除。
- en: Among the numerous classes included in .NET framework, there's one that's specially
    dedicated to this process. This means that the garbage collection of objects is
    not just an automatic process undertaken by CLR but a true, executable object
    that can even be used in our code (GC is the name, by the way, and we will deal
    with it in some cases when we try to optimize execution in the other chapters).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET框架包含的众多类中，有一个专门用于此过程。这意味着对象的垃圾收集不仅仅是CLR执行的自动过程，而是一个真正的、可执行的对象，甚至可以用于我们的代码中（顺便说一下，GC是这个名称，我们将在尝试在其他章节中优化执行时处理它）。
- en: 'Actually, we can see this in action in a number of ways. For example, let''s
    say that we create a method that concatenates strings in a loop and doesn''t do
    anything else with them; it just notifies the user when the process is finished:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以以多种方式看到这一点。例如，假设我们创建一个在循环中连接字符串的方法，并且不对它们做任何其他操作；它只是在过程完成后通知用户：
- en: '[PRE4]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's something to remember here. Since strings are immutable (which means
    that they cannot be changed, of course), the process has to create new strings
    in every loop. This means a lot of memory that the process will use and that can
    be reclaimed since every new string has to be created anew, and the previous one
    is useless.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一点需要注意。由于字符串是不可变的（这意味着它们当然不能被改变），这个过程必须在每个循环中创建新的字符串。这意味着过程将使用大量内存，这些内存可以被回收，因为每个新的字符串都必须重新创建，而旧的字符串就变得无用了。
- en: 'We can use CLR Profiler to see what happens in CLR when running this application.
    You can download CLR Profiler from [http://clrprofiler.codeplex.com/](http://clrprofiler.codeplex.com/),
    and once unzipped, you''ll see two versions (32 and 64 bits) of the tool. This
    tool show us a more detailed set of statistics, which include GC interventions.
    Once launched, you''ll see a window like this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用CLR Profiler来查看在运行此应用程序时CLR中发生了什么。您可以从[http://clrprofiler.codeplex.com/](http://clrprofiler.codeplex.com/)下载CLR
    Profiler，一旦解压，您将看到两个版本（32位和64位）的工具。此工具向我们展示了一组更详细的统计数据，包括GC干预。一旦启动，您将看到一个类似这样的窗口：
- en: '![Garbage collection](img/image00423.jpeg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![垃圾收集](img/image00423.jpeg)'
- en: Ensure that you check the allocations and calls checkboxes before launching
    the application using **Start Desktop App**. After launching (if the application
    has no stops and is running at a stretch), without breaks, you'll be shown a new
    statistical window pointing to various summaries of execution.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用**启动桌面应用**启动应用程序之前，请确保您已勾选分配和调用复选框。启动后（如果应用程序没有停止并且连续运行），没有中断，您将看到一个指向执行各种摘要的新统计窗口。
- en: Each of these summaries lead to a different window in which you can analyze
    (even with statistical graphics) what happened at runtime in more detail as well
    as how garbage collector intervened when required.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些摘要都会引导到一个不同的窗口，您可以在其中更详细地分析（甚至使用统计图形）运行时发生的事情，以及垃圾收集器在需要时如何介入。
- en: 'The following figure shows the main statistical window (note the two sections
    dedicated to GC statistics and garbage collection handle statistics:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了主要的统计窗口（注意有两个部分专门用于GC统计和垃圾回收处理统计）：
- en: '![Garbage collection](img/image00424.jpeg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![垃圾回收](img/image00424.jpeg)'
- en: The screenshot shows two GC-related areas. The first one indicates three kinds
    of collections, named `Gen 0`, `Gen 1`, and `Gen 2`. These names are simply short
    names for generations.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 截图显示了两个与GC相关的区域。第一个区域指示了三种类型的收集，命名为`Gen 0`、`Gen 1`和`Gen 2`。这些名称只是代数的简称。
- en: This is because GC marks objects depending on their references. Initially, when
    the GC starts working, these objects with no references are cleaned up. Those
    still connected are marked as `Gen 1`. The second review of the GC is initially
    similar, but if it discovers that there are objects marked `Gen 1` that still
    hold references, they're marked as `Gen 2`, and those from `Gen 0` with any references
    are promoted to `Gen 1`. The process goes on while the application is under execution.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为GC根据对象的引用来标记对象。最初，当GC开始工作时，这些没有引用的对象会被清理。那些仍然连接的对象被标记为`Gen 1`。GC的第二次审查最初是相似的，但如果它发现仍然有标记为`Gen
    1`的对象持有引用，它们会被标记为`Gen 2`，而任何有引用的`Gen 0`对象会被提升到`Gen 1`。这个过程在应用程序执行期间持续进行。
- en: 'This is the reason we can often read that the following principles apply to
    objects that are subject to recollection:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是我们经常读到以下原则适用于可回收对象的原因：
- en: Newest objects are usually collected soon (they're normally created in a function
    call and are out of the scope when the function finishes)
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新创建的对象通常很快就会被回收（它们通常在函数调用中创建，并在函数结束时超出作用域）
- en: The oldest objects commonly last more (often because they hold references from
    global or static classes)
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最老的对象通常持续更久（通常是因为它们持有来自全局或静态类的引用）
- en: The second area shows the number of handles created, destroyed, and surviving
    (surviving due to garbage collector, of course).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区域显示了创建、销毁和存活的句柄数量（由于垃圾收集器的存在而存活）。
- en: 'The first one (**Time Line**) will, in turn, show statistics including the
    precise execution times in which GC operated, as well as the .NET types implied:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个（**时间线**）将显示GC操作的精确执行时间统计，以及隐含的.NET类型：
- en: '![Garbage collection](img/image00425.jpeg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![垃圾回收](img/image00425.jpeg)'
- en: As you can see, the figure shows a bunch of objects collected and/or promoted
    to other generations as the program goes on.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，随着程序的进行，图中显示了一组被回收和/或提升到其他代的对象。
- en: This is, of course, much more complex than that. The GC has rules to operate
    with different frequencies depending on the generation. So, `Gen 0` is visited
    more frequently that `Gen 1` and much less than `Gen 2`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这比那要复杂得多。GC根据代数有不同的操作频率规则。因此，`Gen 0`比`Gen 1`访问得更频繁，比`Gen 2`访问得少得多。
- en: 'Furthermore, in the second window, we see all the mechanisms implicit in the
    execution, allowing us different levels of details so that we can have the whole
    picture with distinct points of view:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在第二个窗口中，我们可以看到执行过程中隐含的所有机制，这使我们能够以不同的细节级别来获得整体图景，以便从不同的角度进行观察：
- en: '![Garbage collection](img/image00426.jpeg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![垃圾回收](img/image00426.jpeg)'
- en: This is a proof of some of the characteristics of GC. First of all, a de-referenced
    object is not immediately collected, since the process happens periodically, and
    there are many factors that influence this frequency. On the other hand, not all
    orphans are collected at the same time.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了GC的一些特性。首先，一个解除引用的对象不会立即被回收，因为这个过程是周期性的，并且有许多因素会影响这个频率。另一方面，并不是所有的孤儿对象都会同时被回收。
- en: One of the reasons for this is that the collection mechanism itself is computationally
    expensive, and it affects performance, so the recommendation, for most cases,
    is to just let GC do its work the way it is optimized to do.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的一个原因是收集机制本身计算成本较高，这会影响性能，因此建议在大多数情况下，只需让垃圾回收器按照其优化的方式执行其工作。
- en: Are there exceptions to this rule? Yes; the exceptions are in those cases where
    you have reserved a lot of resources and you want to make sure that you clean
    them up before you exit the method or sequence in which your program operates.
    This doesn't mean that you call GC in every turn of a loop execution (due to the
    performance reasons we mentioned).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有这个规则的例外？是的；例外情况是那些你预留了大量资源，并确保在退出程序操作的方法或序列之前清理它们的情况。这并不意味着你在循环执行的每次迭代中都调用GC（由于我们提到的性能原因）。
- en: One of the possible solutions in these cases is implementing the `IDisposable`
    interface. Let's remember that you can see any member of the CLR by pressing *Ctrl*
    + *Alt* + *J* or selecting **Object Explorer** in the main menu.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，可能的解决方案之一是实现`IDisposable`接口。让我们记住，你可以通过按*Ctrl* + *Alt* + *J*或选择主菜单中的**对象资源管理器**来查看CLR的任何成员。
- en: 'We''ll be presented with a window containing a search box in order to filter
    our member, and we''ll see all places where such a member appears:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一个包含搜索框的窗口，以便过滤我们的成员，我们将看到此类成员出现的位置：
- en: '![Garbage collection](img/image00427.jpeg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![垃圾回收](img/image00427.jpeg)'
- en: Note
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this interface is not available for .NET Core Runtime.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此接口在.NET Core运行时不可用。
- en: 'So, we would redefine our class to implement `IDisposable` (which means that
    we should write a `Dispose()` method to invoke the GC inside it). Or, even better,
    we can follow the recommendations of the IDE and implement `Dispose Pattern`,
    which is offered to us as an option as soon as we indicate that our program implements
    this interface, as shown in the following screenshot:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将重新定义我们的类以实现`IDisposable`（这意味着我们应该在内部编写一个`Dispose()`方法来调用GC）。或者，更好的是，我们可以遵循IDE的建议并实现`Dispose
    Pattern`，一旦我们表明我们的程序实现了此接口，它就会作为选项提供，如下面的截图所示：
- en: '![Garbage collection](img/image00428.jpeg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![垃圾回收](img/image00428.jpeg)'
- en: Also, remember that, in cases where we have to explicitly dispose a resource,
    another common and more suggested way is the `using` block within the context
    of a method. A typical scenario is when you open a file using some of the classes
    in the `System.IO` namespace, such as File. Let's quickly look at it as a reminder.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，在必须显式释放资源的情况下，另一种常见且更推荐的方式是在方法上下文中使用`using`块。一个典型的场景是使用`System.IO`命名空间中的某些类打开文件，例如File。让我们快速回顾一下，以作提醒。
- en: 'Imagine that you have a simple text file named `Data.txt` and you want to open
    it, read its content, and present it in the console. A possible way to do this
    rapidly would be by using the following code:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为`Data.txt`的简单文本文件，你想打开它，读取其内容，并在控制台中显示。一种快速实现的方法是使用以下代码：
- en: '[PRE5]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What's the problem with this code? It works, but it's using an external resource,
    since the `OpenText` method returns an `StreamReader` object, which we later use
    to read the contents, and it's not explicitly closed. We should always remember
    to close those objects that we open and take some time to process.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的问题是什么？它运行正常，但它使用了一个外部资源，因为`OpenText`方法返回一个`StreamReader`对象，我们稍后使用它来读取内容，并且它没有被显式关闭。我们应该始终记住关闭我们打开并处理的对象。
- en: One of the possible side effects consists of preventing other processes from
    accessing the file we opened.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的副作用之一是阻止其他进程访问我们打开的文件。
- en: 'So, the best and suggested solution for these cases is to include the declaration
    of the conflicting object within a `using` block, as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些情况的最佳和推荐解决方案是在`using`块中包含冲突对象的声明，如下所示：
- en: '[PRE6]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this way, garbage collector is automatically invoked to liberate the resources
    managed by `StreamReader`, and there's no need to close it explicitly.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，垃圾回收器会自动调用以释放`StreamReader`管理的资源，无需显式关闭。
- en: Finally, there's always another way of forcing an object to die, that is, using
    the corresponding finalizer (a method preceded by the `~` sign, which is right
    opposite to a destructor). It's not a recommended way to destroy objects, but
    it has been there since the very beginning (let's remember that Hejlsberg inspired
    many features of the language in C++). And, by the way, the advanced pattern of
    implementing `IDispose` includes this option for more advanced collectable scenarios.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，总是有另一种强制对象死亡的方法，即使用相应的终结器（一个以`~`符号开头的函数，与析构函数正好相反）。这不是推荐销毁对象的方法，但它从一开始就存在（让我们记住，Hejlsberg启发了语言中许多C++特性的功能）。顺便说一下，实现`IDispose`的高级模式包括这个选项，以处理更高级的收集场景。
- en: Implementing algorithms with the CLR
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在CLR中实现算法
- en: So far, we've seen some of the more important concepts, techniques, and tools
    available and related to CLR. In other words, we've seen how the engine works
    and how the IDE and other tools gives us support to control and monitor what's
    going on behind the scenes.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一些与CLR相关的重要概念、技术和工具。换句话说，我们已经了解了引擎的工作原理以及IDE和其他工具如何为我们提供支持，以控制和监控幕后发生的事情。
- en: Let's dig into some of the more typical structures and algorithms that we'll
    find in everyday programming so that we can understand the resources that .NET
    framework puts in our hands to solve common problems a bit better.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一些在日常生活中编程中常见的典型结构和算法，以便我们更好地理解.NET框架为我们提供的资源，以解决常见问题。
- en: We've mentioned that .NET framework installs a repository of DLLs that offer
    a large number of functionalities. These DLLs are organized by namespaces, so
    they can be used individually or in conjunction with others.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到.NET框架安装了一个包含大量功能的DLL库。这些DLL按命名空间组织，因此可以单独使用或与其他DLL一起使用。
- en: As it happens with other frameworks such as J2EE, in .NET, we will use the object-oriented
    programming paradigm as a suitable approach to programming problems.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他框架（如J2EE）一样，在.NET中，我们将使用面向对象编程范式作为解决编程问题的合适方法。
- en: Data structures, algorithms, and complexity
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据结构、算法和复杂度
- en: 'In the initial versions of .NET (1.0, 1.1), we could use several types of constructions
    to deal with collections of elements. All modern languages include these constructs
    as typical resources, and some of these you should know for sure: arrays, stacks,
    and queues are typical examples.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET的初始版本（1.0、1.1）中，我们可以使用几种构造来处理元素集合。所有现代语言都将这些构造作为典型资源，其中一些你肯定应该知道：数组、栈和队列是典型的例子。
- en: Of course, the evolution of .NET has produced many novelties, starting with
    generics, in version 2.0, and other types of similar constructions, such as dictionaries,
    `ObservableCollections`, and others in a long list.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，.NET的演变产生了许多新特性，从2.0版本的泛型开始，以及其他类似的结构，如字典、`ObservableCollections`等，在长长的列表中。
- en: But the question is, are we using these algorithms properly? What happens when
    you have to use one of these constructions and push it to the limits? And to cope
    with these limits, do we have a way to find out and measure these implementations
    so that we can use the most appropriate one in every situation?
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题是，我们是否正确地使用了这些算法？当你必须使用这些构造并将其推到极限时会发生什么？为了应对这些极限，我们是否有方法找出和测量这些实现，以便我们可以在每种情况下使用最合适的一个？
- en: These questions take us to the measure of complexity. The most common approach
    to the problem nowadays relies on a technique called *Big O Notation* or *Asymptotic
    Analysis*.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题带我们来到了复杂度的度量。如今，解决这个问题的最常见方法依赖于一种称为*大O符号*或*渐近分析*的技术。
- en: Big O Notation
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大O符号
- en: '**Big O Notation** (**Big Omicron Notation**) is a variant of a mathematical
    discipline that describes the limiting behavior of a function when a value leans
    toward a particular value or toward infinity. When you apply it to computer science,
    it''s used to classify algorithms by how they respond to changes in the input
    size.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**大O符号**（**大欧米茄符号**）是数学学科的一个变体，描述了函数在值趋向特定值或无穷大时的极限行为。当应用于计算机科学时，它用于根据算法对输入大小变化的响应来分类算法。'
- en: 'We understand "how they respond" in two ways: response in time (often the most
    important) as well as response in space, which could lead to memory leaks and
    other types of problems (eventually including DoS attacks and other threats).'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过两种方式理解“它们如何响应”：时间响应（通常是最重要的）以及空间响应，这可能导致内存泄漏和其他类型的问题（最终包括DoS攻击和其他威胁）。
- en: Tip
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: One of the most exhaustive lists of links to explanations of the thousands of
    algorithms cataloged up to date is published by **NIST** (**National Institute
    of Standards and Technology**) at [https://xlinux.nist.gov/dads/](https://xlinux.nist.gov/dads/).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，最详尽的链接列表，解释了数千个已编目算法的解释，由**NIST**（**国家标准与技术研究院**）发布，可在[https://xlinux.nist.gov/dads/](https://xlinux.nist.gov/dads/)找到。
- en: The way to express the response in relation to the input (the O notation) consists
    in a formula such as *O([formula])*, where formula is a mathematical expression
    that indicates the growth, that is the number of times the algorithm executes,
    as the input grows. Many algorithms are of type *O(n)*, and they are called linear
    because the growth is proportional to the number of inputs. In other words, such
    growth would be represented by a straight line (although it is never exact).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 表达响应与输入（O表示法）的关系的方式是一个如*O([公式]*)*的公式，其中公式是一个数学表达式，表示随着输入的增长，算法执行的次数，即增长。许多算法都是*O(n)*类型，它们被称为线性，因为增长与输入的数量成比例。换句话说，这种增长可以用一条直线表示（尽管它从不完全准确）。
- en: 'A typical example is the analysis of sorting algorithms, and NIST mentions
    a canonical case: quicksort is *O(n log n)* on average, and bubble offers *O(n²)*.
    This means that on a desktop computer, a quicksort implementation can beat a bubble
    one, which is running on a supercomputer when the numbers to be sorted grow beyond
    a certain point.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子是对排序算法的分析，NIST提到了一个典型情况：快速排序的平均时间复杂度为*O(n log n)*，冒泡排序为*O(n²)*。这意味着在桌面计算机上，快速排序的实现可以击败在超级计算机上运行的冒泡排序，当要排序的数字超过某个点时。
- en: Note
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As an example, in order to sort 1,000,000 numbers, the quicksort takes 20,000,000
    steps on average, while the bubble sort takes 1,000,000,000,000 steps!
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了排序1,000,000个数字，快速排序平均需要20,000,000步，而冒泡排序需要1,000,000,000,000步！
- en: The following graphic shows the growth in time of four classical sorting algorithms
    (bubble, insertion, selection, and shell). As you can see in the graph, the behavior
    is quite linear until the number of elements passes 25,000, in which the elements
    differ noticeably. The shell algorithm wins and has a factor of a worst case complexity
    of *O(n^1.5)*. Note that quicksort has a smaller factor *(n log n)*.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了四种经典排序算法（冒泡、插入、选择和希尔）的时间增长。如图所示，直到元素数量超过25,000，行为相当线性。希尔算法获胜，其最坏情况复杂度为*O(n^1.5)*。请注意，快速排序的因子较小，为*(n
    log n)*。
- en: Unfortunately, there's no mechanical procedure to calculate the Big-O, and the
    only procedures that can be found deal with a, more or less, empirical approach.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有机械的方法来计算大O，可以找到的只有一些更多或更少的经验方法。
- en: 'However, we can use some well-defined tables that categorize the algorithms
    and give us the *O(formula)* to get an idea of what we can obtain out of its usage,
    such as the one published by Wikipedia, which is accessible at [http://en.wikipedia.org/wiki/Big_O_notation#Orders_of_common_functions](http://en.wikipedia.org/wiki/Big_O_notation#Orders_of_common_functions):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用一些定义良好的表格来分类算法，并给出*O(公式)*，以了解其使用所能获得的结果，例如维基百科上发布的表格，可在[http://en.wikipedia.org/wiki/Big_O_notation#Orders_of_common_functions](http://en.wikipedia.org/wiki/Big_O_notation#Orders_of_common_functions)找到：
- en: '![Big O Notation](img/image00429.jpeg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![大O表示法](img/image00429.jpeg)'
- en: From the point of view of .NET framework, we can use all collections linked
    to the `System.Collections.Generics` namespace that guarantee optimized performance
    for a vast majority of situations.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 从.NET框架的角度来看，我们可以使用所有链接到`System.Collections.Generics`命名空间且保证在大多数情况下优化性能的集合。
- en: An approach to performance in the most common sorting algorithms
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最常见排序算法的性能方法
- en: You will find in `DEMO01-04` a .NET program that compares three classical algorithms
    (bubble, merge, and heap) to the one implemented in `List<T>` collections using
    integers. Of course, this approach is a practical, everyday approach and not a
    scientific one, for which the generated numbers should be uniformly randomly generated
    (refer to Rasmus Faber's answer to this question at [http://stackoverflow.com/questions/609501/generating-a-random-decimal-in-c/610228#610228](http://stackoverflow.com/questions/609501/generating-a-random-decimal-in-c/610228#610228)).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DEMO01-04`中，您将找到一个.NET程序，该程序比较了三种经典算法（冒泡、归并和堆）与使用整数在`List<T>`集合中实现的算法。当然，这种方法是一种实用且日常的方法，而不是科学方法，对于科学方法，生成的数字应该是均匀随机生成的（参考Rasmus
    Faber对此问题的回答，见[http://stackoverflow.com/questions/609501/generating-a-random-decimal-in-c/610228#610228](http://stackoverflow.com/questions/609501/generating-a-random-decimal-in-c/610228#610228)）。
- en: 'Besides that, another consideration should be made for the generators themselves.
    For practical purposes such as testing these algorithms, generators included in
    .NET framework do their job pretty well. However, if you need or are curious about
    a serious approach, perhaps the most documented and tested one is the Donald Knuth''s
    *Spectral Test*, published in the second volume of his world''s famous *The Art
    of Computer Programming, Volume 2: Seminumerical Algorithms (2nd Edition)*, by
    *Knuth, Donald E.*, published by Addison-Wesley.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还应该考虑生成器本身。对于测试这些算法等实际用途，.NET框架中包含的生成器做得相当不错。然而，如果您需要或对严肃的方法感兴趣，或许最被记录和测试的方法是Donald
    Knuth的*光谱测试*，该测试发表在他的世界著名作品《计算机程序设计艺术，第2卷：半数值算法（第2版）》的第二卷中，由*Knuth, Donald E.*编写，由Addison-Wesley出版。
- en: 'That said, the random generator class included in .NET can give us good enough
    results for our purposes. As for the sorting methods targeted here, I''ve chosen
    the most commonly recommended ones in comparison with to extremes: the slowest
    one (bubble with an *O(n²)* in performance) and the one included in the `System.Collections.Generic`
    namespace for the `List<T>` class (which is, internally, a quick sort). In the
    middle, a comparison is made between the heap and merge methods—all of them considered
    *O(n log n)* in performance.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，.NET中包含的随机生成器类可以为我们提供足够好的结果。至于这里针对的排序方法，我选择了与极端情况相比最常推荐的那些：性能最慢的一个（具有*O(n²)*性能的冒泡排序）和包含在`System.Collections.Generic`命名空间中的`List<T>`类中（在内部，这是一个快速排序）。在中间，对堆和归并方法进行了比较——所有这些方法在性能上都被认为是*O(n
    log n)*。
- en: The previously mentioned demo follows recommended implementations with some
    updates and improvements for the user interface, which is a simple Windows Forms
    application, so you can test these algorithms thoroughly.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的演示遵循推荐的实现，并对用户界面进行了一些更新和改进，这是一个简单的Windows Forms应用程序，因此您可以彻底测试这些算法。
- en: Also, note that you should execute these tests several times with different
    amounts of inputs to get a real glimpse of these methods' performance, and that
    .NET framework is built with optimized sorting methods for integers, strings,
    and other built-in types, avoiding the cost of calling delegates for comparisons,
    and so on. So, in comparison with built-in types, typical sorting algorithms are
    going to be much slower normally.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，您应该多次执行这些测试，使用不同数量的输入，以真正了解这些方法的性能，并且.NET框架是用针对整数、字符串和其他内置类型的优化排序方法构建的，避免了调用委托进行比较等开销。因此，与内置类型相比，典型的排序算法通常要慢得多。
- en: 'For example, for 30,000 integers, we obtain the following results:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于30,000个整数，我们得到以下结果：
- en: '![An approach to performance in the most common sorting algorithms](img/image00430.jpeg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![最常见排序算法的性能方法](img/image00430.jpeg)'
- en: As you can see, the results of bubble (even being an optimized bubble method)
    are far worse when the total numbers go beyond 10,000\. Of course, for smaller
    numbers, the difference decreases, and if the routine does not exceed 1,000, it's
    negligible for most practical purposes.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当总数超过10,000时，冒泡排序（即使是经过优化的冒泡排序方法）的结果要差得多。当然，对于较小的数字，差异会减小，如果程序不超过1,000，对于大多数实际用途来说可以忽略不计。
- en: As an optional exercise for you, we leave the implementation of these algorithms
    for string sorting.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项可选练习，我们留给您实现这些算法以进行字符串排序的实现。
- en: Tip
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'You can use some of these routines to quickly generate strings:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这些程序中的一些来快速生成字符串：
- en: '[PRE7]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This one is suggested by Ranvir at [http://stackoverflow.com/questions/1122483/random-string-generator-returning-same-string](http://stackoverflow.com/questions/1122483/random-string-generator-returning-same-string):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这个建议来自Ranvir在[http://stackoverflow.com/questions/1122483/random-string-generator-returning-same-string](http://stackoverflow.com/questions/1122483/random-string-generator-returning-same-string)：
- en: '[PRE8]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Remember that, for such situations, you should use generic versions of the merge
    and heap algorithms so that an invocation can be made to the same algorithm independently
    of the input values.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在这种情况下，你应该使用合并和堆算法的泛型版本，以便可以独立于输入值调用相同的算法。
- en: Relevant features appearing in versions 4.5x, 4.6, and .NET Core 1.0 and 1.1
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 出现在4.5x、4.6和.NET Core 1.0和1.1版本中的相关功能
- en: Among the new features that we can find in the latest versions of .NET framework
    and which we have not mentioned yet, some relate to the CLR (as well as many others
    that will be covered in the following chapters), and among those that relate to
    the core of .NET, we can find the ones mentioned in the next few sections.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET框架最新版本中可以找到的一些新功能，我们尚未提及，其中一些与CLR（以及以下章节中将要涵盖的许多其他内容）相关，而在与.NET核心相关的功能中，我们可以在接下来的几节中找到提到的那些。
- en: .NET 4.5.x
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET 4.5.x
- en: 'We can summarize the main improvements and new features that appeared in .NET
    4.5 in the following points:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将.NET 4.5中出现的主要改进和新功能总结如下：
- en: Reduction of system restarts
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少了系统重启
- en: Arrays larger than 2 gigabytes (GB) on 64-bit platforms
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 64位平台上的大于2GB（GB）的数组
- en: An improvement of background garbage collection for servers (with implications
    in performance and memory management)
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器背景垃圾收集的改进（对性能和内存管理有影响）
- en: JIT compilation in the background, optionally available on multicore processors
    (to improve the application performance, obviously)
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多核处理器上可选的背景JIT编译（显然可以提高应用程序性能）
- en: New console (`System.Console`) support for Unicode (UTF-16) encoding
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的控制台（`System.Console`）对Unicode（UTF-16）编码的支持
- en: An improvement in performance when retrieving resources (especially useful for
    desktop applications)
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在检索资源时的性能改进（特别是对桌面应用程序非常有用）
- en: The possibility of customizing the reflection context so that it overrides the
    default behavior
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以自定义反射上下文，以便它覆盖默认行为
- en: New asynchronous features were added to C# and Visual Basic languages in order
    to add a task-based model to perform asynchronous operations
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C#和Visual Basic语言中添加了新的异步功能，以便添加基于任务的模型来执行异步操作
- en: Improved support for parallel computing (performance analysis, control, and
    debugging)
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进了对并行计算的支持（性能分析、控制和调试）
- en: The ability to explicitly compact the **large object heap** (**LOH**) during
    garbage collection
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在垃圾收集期间可以显式压缩**大对象堆（LOH**）
- en: .NET 4.6 (aligned with Visual Studio 2015)
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET 4.6（与Visual Studio 2015对齐）
- en: 'In .NET 4.6, new features and improvements are not many, but they''re important:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 4.6中，新增功能和改进并不多，但它们很重要：
- en: 64-bit JIT compiler for managed code (formerly called RyuJIT in beta versions).
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 64位JIT编译器用于托管代码（在测试版中称为RyuJIT）。
- en: Assembly loader improvements (working in conjunction with NGEN images; decreases
    the virtual memory and saves the physical memory).
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合加载器改进（与NGEN图像协同工作；减少虚拟内存并节省物理内存）。
- en: 'Many changes in **Base Class Libraries** (**BCLs**):'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基类库（BCLs**）中的许多更改：'
- en: Several new capabilities in the Garbage Collection class
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾收集类中的几个新功能
- en: Improvements in SIMD support (for information on SIMD, refer to [https://en.wikipedia.org/wiki/SIMD](https://en.wikipedia.org/wiki/SIMD))
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SIMD支持的改进（有关SIMD的信息，请参阅[https://en.wikipedia.org/wiki/SIMD](https://en.wikipedia.org/wiki/SIMD)）
- en: Cryptography updates related to the Windows CNG cryptography APIs (a CNG reference
    is available at [https://msdn.microsoft.com/library/windows/desktop/aa376214.aspx](https://msdn.microsoft.com/library/windows/desktop/aa376214.aspx))
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Windows CNG加密API相关的加密更新（CNG参考信息可在[https://msdn.microsoft.com/library/windows/desktop/aa376214.aspx](https://msdn.microsoft.com/library/windows/desktop/aa376214.aspx)找到）
- en: .NET Native, a new technology that compiles apps to native code rather than
    IL. They produce apps characterized by faster startup and execution times, among
    other advantages.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Native，一种新技术，将应用程序编译成本地代码而不是IL。它们产生的应用程序具有更快的启动和执行时间等优势。
- en: Note
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: .NET Native has major improvements at runtime, but it has a few drawbacks as
    well, among some other considerations that may affect the way applications behave
    and should be coded. We'll talk about this in greater depth in other chapters.
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .NET Native在运行时进行了重大改进，但也存在一些缺点，以及其他可能影响应用程序行为和编码方式的考虑因素。我们将在其他章节中更深入地讨论这个问题。
- en: Open source .NET framework packages (such as Immutable Collections, SIMD APIs
    and networking APIs, which are now available on GitHub)
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开源.NET框架包（如不可变集合、SIMD API和网络API，现在可在GitHub上找到）
- en: .NET Core 1.0
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET Core 1.0
- en: .NET Core is a new version of .NET intended to execute in any operating system
    (Windows, Linux, MacOS), that can be used in device, cloud, and embedded/IoT scenarios.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core是.NET的新版本，旨在在任何操作系统（Windows、Linux、MacOS）上执行，可用于设备、云和嵌入式/IoT场景。
- en: 'It uses a new set of libraries, and –as Rich Lander mentions in the official
    documentation guide ([https://docs.microsoft.com/en-us/dotnet/articles/core/](https://docs.microsoft.com/en-us/dotnet/articles/core/))
    the set of characteristics that best define this version are:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用一组新的库，正如Rich Lander在官方文档指南([https://docs.microsoft.com/en-us/dotnet/articles/core/](https://docs.microsoft.com/en-us/dotnet/articles/core/))中提到的，最能定义这个版本的特征集是：
- en: '**Flexible deployment**: Can be included in your app or installed side-by-side
    user- or machine-wide.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活部署**：可以包含在您的应用程序中或并行安装到用户或机器范围内。'
- en: '**Cross-platform**: Runs on Windows, MacOS and Linux; can be ported to other
    OSes. The supported Operating Systems ([https://github.com/dotnet/core/blob/master/roadmap.md](https://github.com/dotnet/core/blob/master/roadmap.md)),
    CPUs and application scenarios will grow over time, provided by Microsoft, other
    companies, and individuals.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台**：在Windows、MacOS和Linux上运行；可以移植到其他操作系统。由微软、其他公司和个人提供的支持的操作系统([https://github.com/dotnet/core/blob/master/roadmap.md](https://github.com/dotnet/core/blob/master/roadmap.md))、CPU和应用程序场景将随着时间的推移而增长。'
- en: '**Command-line tools**: All product scenarios can be exercised at the command-line.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令行工具**：所有产品场景都可以在命令行中执行。'
- en: '**Compatible**: .NET Core is compatible with .NET Framework, Xamarin and Mono,
    via the.NET Standard Library ([https://docs.microsoft.com/en-us/dotnet/articles/standard/library](https://docs.microsoft.com/en-us/dotnet/articles/standard/library)).'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兼容性**：.NET Core通过.NET Standard库与.NET Framework、Xamarin和Mono兼容([https://docs.microsoft.com/en-us/dotnet/articles/standard/library](https://docs.microsoft.com/en-us/dotnet/articles/standard/library))。'
- en: '**Open source**: The .NET Core platform is open source, using MIT and Apache
    2 licenses. Documentation is licensed under CC-BY ([http://creativecommons.org/licenses/by/4.0/](http://creativecommons.org/licenses/by/4.0/)).
    .NET Core is a .NET Foundation project ([http://www.dotnetfoundation.org/](http://www.dotnetfoundation.org/)).'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开源**：.NET Core平台是开源的，使用MIT和Apache 2许可证。文档许可在CC-BY([http://creativecommons.org/licenses/by/4.0/](http://creativecommons.org/licenses/by/4.0/))下。.NET
    Core是.NET Foundation项目([http://www.dotnetfoundation.org/](http://www.dotnetfoundation.org/))。'
- en: '**Supported by Microsoft**: .NET Core is supported by Microsoft, per .NET Core
    Support ([https://www.microsoft.com/net/core/support/](https://www.microsoft.com/net/core/support/)).'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**由微软支持**：.NET Core由微软支持，请参阅.NET Core支持([https://www.microsoft.com/net/core/support/](https://www.microsoft.com/net/core/support/))。'
- en: .NET Core 1.1
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET Core 1.1
- en: Added support for Linus Mint 18, Open Suse 42.1, MacOS 10.12, and Windows Server
    2016, with side-by-side installation.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 增加了Linus Mint 18、Open Suse 42.1、MacOS 10.12和Windows Server 2016的支持，并支持并行安装。
- en: New API's (more than 1000) and bug fixes.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 新API（超过1000个）和错误修复。
- en: New documentation available at [https://docs.microsoft.com/en-us/dotnet/](https://docs.microsoft.com/en-us/dotnet/).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 新的文档可在[https://docs.microsoft.com/en-us/dotnet/](https://docs.microsoft.com/en-us/dotnet/)找到。
- en: A new version of ASP.NET Core 1.1.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 1.1的新版本。
- en: At the end of this book, we'll cover .NET Core so you can have an idea of its
    behavior and is advantages, specially in the cross-platform area.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的结尾，我们将介绍.NET Core，以便您对其行为和优势有一个了解，特别是在跨平台领域。
- en: Summary
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: CLR is the heart of .NET framework, and we have reviewed some of the most important
    concepts behind its architecture, design, and implementation in order to better
    understand how our code works and how it can be analyzed in the search for possible
    problems.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: CLR是.NET框架的核心，我们已经回顾了其架构、设计和实现背后的某些重要概念，以便更好地理解我们的代码是如何工作的，以及如何在寻找可能的问题时进行分析。
- en: So, overall, in this chapter, we saw an annotated (with commentaries, graphics,
    and diagrams) reminder of some important terms and concepts of computing that
    we will find within the book, and with this foundation, we went through a brief
    introduction to the motivations that rely on .NET framework's creation along with
    its fathers.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总体来说，在本章中，我们看到了一些重要计算术语和概念的注释（包括评论、图形和图表）提醒，这些术语和概念我们将在书中找到，并且基于这个基础，我们简要介绍了依赖于
    .NET 框架创建及其父辈的动机。
- en: Next, we covered the what's inside CLR and how we can view it in action using
    tools provided by CLR itself and others available in Visual Studio 2015 from the
    Update 1.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍了 CLR 的内部结构以及如何使用 CLR 自身提供的工具和 Visual Studio 2015 更新 1 中可用的其他工具来观察其运行情况。
- en: The third point was a basic review of the complexity of algorithms, the Big
    O Notation and the way in which we can measure it in practice by testing some
    sorting methods implemented in C# in order to finish with a short list of the
    most relevant features the latest versions of .NET offer and that we will cover
    in different chapters of this book.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个要点是对算法复杂性的基本回顾，包括大 O 表示法和我们在实践中如何通过测试在 C# 中实现的某些排序方法来衡量它，以便结束本章，简要列出最新版本的
    .NET 提供的最相关特性，这些特性将在本书的不同章节中介绍。
- en: In the next chapter, we will dig into the substance of the C# language from
    the very beginning (don't miss Hejlsberg's true reasons for the creation of delegates)
    and how it has evolved to simplify and consolidate programming techniques with
    generics, lambda expressions, anonymous types, and the LINQ syntax.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从 C# 语言的本质开始深入探讨（不要错过 Hejlsberg 创建代理的真实原因），以及它是如何通过泛型、lambda 表达式、匿名类型和
    LINQ 语法来简化并巩固编程技术的。
