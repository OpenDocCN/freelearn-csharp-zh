- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Your Own Conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Correlation is one of the most important parts of observability. Distributed
    tracing bring correlation by propagating trace context, allowing us to follow
    individual operations, and consistent attributes enable correlation across traces
    and other telemetry signals.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B19423_09.xhtml#_idTextAnchor148), *Best Practices*, we talked
    about the importance of reusing standard attributes and following OpenTelemetry
    semantic conventions. Sometimes we need to go further and define our own conventions.
    Here, we’re going to explore how to define custom attributes and conventions and
    use them across the system.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll list properties that should be standardized across the system,
    and then we’ll explore how to populate them with shared code. Finally, we’ll look
    at OpenTelemetry’s semantic convention schema and see how it can simplify documenting
    and validating custom conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify and document common attributes and conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share instrumentation and custom conventions across the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use OpenTelemetry tooling to create conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, you should be able to create easy-to-use processes and tools to keep
    custom telemetry and attributes consistent and stable.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter is available in the book’s repository on GitHub at
    [https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter14](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter14).
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the examples and perform analysis, we’ll need the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET SDK 7.0 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker and `docker-compose`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining custom conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple ways to express even the most basic things. If we take our
    meme application example from [*Chapter 5*](B19423_05.xhtml#_idTextAnchor083),
    *Configuration and Control Plane*, we enriched all spans with the meme name attribute
    so that we can find when the meme was uploaded or how frequently it’s accessed.
  prefs: []
  type: TYPE_NORMAL
- en: We chose that approach, but we could instead write a log with the meme name
    once, and then use slightly more complicated queries to find all traces related
    to that meme. We could come up with something else, but what’s important is to
    keep the approach consistent across the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even with a custom attribute added to each span, there are still plenty of
    things to consider when recording such an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '`meme_name`, `meme.name`, and `memeName` are different attributes. Unless we
    document the exact name and define it as a constant somewhere, someone will eventually
    use the wrong variation of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type**: The meme name is just a string. What if we wanted to capture the
    size or the image format? We need to document the type and maybe provide helper
    methods to record attributes so that it’s easier to set them correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image/png` or as an enumeration?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When recording a meme name, we extract it from the uploaded filename, and we
    need to document what should be recorded on the attribute value (absolute or relative
    path, filename, with or without extension). If, when writing business logic, we
    sanitize or escape the meme name, or generate a unique one, we probably want to
    capture the one used by the business logic. We may also record the original name
    just once for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '**When to populate the attribute**: Document on which metrics, spans, and logs
    the attribute should be recorded. For example, meme names have high cardinality
    and do not belong on metrics. The meme name attribute can be recorded on spans
    and logs, but which ones? In our example in [*Chapter 5*](B19423_05.xhtml#_idTextAnchor083),
    *Configuration and Control Plane*, we recorded the meme name on all spans and
    a couple of specific log records.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are other aspects you might want to document: relationships between spans,
    event names, whether to record exceptions on spans, attribute cardinality, stability,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll see how to formally define attributes in the *Using OpenTelemetry schemas
    and tools* section of this chapter. Now, let’s focus on naming.
  prefs: []
  type: TYPE_NORMAL
- en: Naming attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Naming is known to be one of the hardest problems in computer science.
  prefs: []
  type: TYPE_NORMAL
- en: If we named the meme name attribute `document.id`, it might precisely match
    a property in the database schema. However, it would be very generic and have
    a high chance of collision with another similar concept in the system. People
    who are not familiar with the internals but analyze business data might have a
    hard time understanding what `document.id` represents.
  prefs: []
  type: TYPE_NORMAL
- en: '`meme_name` seems to be intuitive, short, and descriptive, and the chances
    of a collision with something else are low. It seems fine, but we’ll probably
    have other attributes and should put them into an application-specific or company-specific
    namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Namespaces allow us to set unique, specific, descriptive, and consistent names.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have called our system `memes`, let’s use it as the root namespace.
    This will help us understand that all attributes in this space come from our customizations
    and are not set by some auto-instrumentation.
  prefs: []
  type: TYPE_NORMAL
- en: This helps us navigate between telemetry and makes it possible to do filtering,
    redaction, and other post-processing in telemetry pipelines. For example, if we
    want to remove unknown attributes from logs, we can consider everything in the
    `memes` namespace (http, `db`, and so on) to be known.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have nested namespaces. Since we’d like to record other meme properties,
    such as size and type, we can end up with the following set of attributes: `memes.meme.name`,
    `memes.meme.size`, and `memes.meme.type`. We can easily add other properties as
    we see fit, such as `memes.meme.author` or `memes.meme.description`.'
  prefs: []
  type: TYPE_NORMAL
- en: While `memes.meme` might look repetitive, it’ll start to make more sense once
    we add something such as `memes.user.name` or `memes.tag.description`.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenTelemetry naming convention (available at [https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/attribute-naming.md](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/attribute-naming.md))
    uses a dot (`.`) as a separator between namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'For multi-word namespaces or attributes, OpenTelemetry recommends `snake_case`:
    for example, we could introduce `memes.meme.creation_date`.'
  prefs: []
  type: TYPE_NORMAL
- en: Following this convention for our custom attributes allows us to stay consistent
    across all attributes. It will also reduce the chance of mistakes while writing
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: Having a schema defined and documented in some form is an essential step. But
    how can we keep it in sync with the code and ensure all services follow it? One
    way to do so is by capturing it in code and reusing it across the system.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing common schema and code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consistent telemetry reporting applies to telemetry collection configuration.
    First, we need to enable a basic layer of instrumentation on all services, which
    should include resource utilization metrics, traces, and metrics for HTTP, gRPC,
    or any other RPC protocol used in your system.
  prefs: []
  type: TYPE_NORMAL
- en: We should also configure sampling and resource attributes, add enrichment processors,
    and set up context propagators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Individual services should be able to customize configuration to some extent:
    add more instrumentations, enable custom activity sources and meters, or control
    log verbosity.'
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to unify configuration is to ship corresponding code as a common
    library (or a set of them) shared across all the services in your system. Such
    libraries would define configuration options, provide helper methods to enable
    telemetry collection, implement common enrichment processors, declare cross-service
    events, and so on. Let’s go ahead and implement such a configuration helper.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing setup code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B19423_05.xhtml#_idTextAnchor083), *Configuration and Control
    Plane*, and other chapters where we used meme application, we applied OpenTelemetry
    configuration individually in each service.
  prefs: []
  type: TYPE_NORMAL
- en: We’d never do this in production code – it’s hard to keep our configurations,
    instrumentation options, OpenTelemetry package versions, and anything else in
    sync.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, we can start extracting common pieces of instrumentation code into
    a shared library. Since the configuration can slightly vary from service to service,
    we’ll need to define some configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: We need are options that would help us to set the service name, specify the
    sampling rate or strategy, enable additional instrumentations, and more. You can
    find an example of such options in the `MemesTelemetryConfiguration` class in
    the book’s repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can declare a helper method that takes care of the OpenTelemetry configuration.
    Here’s an example of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: OpenTelemetryExtensions.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/OpenTelemetryExtensions.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/OpenTelemetryExtensions.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: All services that use this method will have the same basic level of instrumentation
    applied and enriched consistently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of using this method in the **storage** service:'
  prefs: []
  type: TYPE_NORMAL
- en: storage/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/storage/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/storage/Program.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we read the telemetry options from the `Telemetry` section of the ASP.NET
    Core configuration, which you can populate in any way that works for you.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we add the Entity Framework instrumentation. Only the **storage** service
    needs it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Having a central library that enables collection helps to reduce version hell.
    By having a dependency on it, individual service packages get a transitive dependency
    on OpenTelemetry packages and should never add them as direct dependencies. Services
    that need an uncommon instrumentation library would still need to install the
    corresponding NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a common setup, let’s see what we can do to help services follow
    our custom semantic conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Codifying conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, we started recording the meme name attribute – we enabled
    `MemeNameEnrichingProcessor`, which sets the `memes.meme.name` attribute on each
    span. Individual services don’t need to do anything to enable it and cannot set
    the wrong attribute name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, we might need to use the attribute directly in some other parts (for
    example, on logs), so it’s important to declare the attribute name as a constant
    and never use a string literal in the code. Here’s an example demonstrating how
    attribute names can be declared:'
  prefs: []
  type: TYPE_NORMAL
- en: SemanticConventions.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/SemanticConventions.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/SemanticConventions.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: OpenTelemetry also provides the `OpenTelemetry.SemanticConventions` NuGet package,
    which declares common attributes defined in the specification. It might make sense
    to add a dependency to it when reusing common attributes.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have now defined constants for the attribute names, and we have a processor
    that populates the meme name. Can we do more?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can provide helpers to report common events in a performant and consistent
    manner. Let’s look at how we can use the high-performance logging we explored
    in [*Chapter 8*](B19423_08.xhtml#_idTextAnchor131), *Writing Structured and Correlated
    Logs*, to populate our attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: EventService.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/EventService.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/Memes.OpenTelemetry.Common/EventService.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have some difficult-to-read code. It defines a log record representing
    the meme download event by following the OpenTelemetry conventions and our own
    conventions. We would not want to write this code every time we needed to log
    something.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing this event once in the common library and making it easy to reuse
    is the best way to record the event consistently and with a low performance overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, anyone can use the `DownloadMemeEvent` method, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: StorageService.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/frontend/StorageService.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/frontend/StorageService.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: This is easy to use and performant, and there is no need to worry about attributes,
    their types, or any conventions at all. If attributes are renamed, there is no
    need to update the service code – it’s all hidden in the shared library.
  prefs: []
  type: TYPE_NORMAL
- en: If we follow this approach, we can define other events and add helper methods
    to populate attribute groups on metrics and traces.
  prefs: []
  type: TYPE_NORMAL
- en: If we need any custom instrumentations, like we had for gRPC or messaging, we
    should put them into shared libraries and apply all the attributes there instead
    of in the service code.
  prefs: []
  type: TYPE_NORMAL
- en: Separating telemetry-related code from business logic makes them both easier
    to read and maintain. It also makes telemetry-related code testable and helps
    us to keep it in sync with documentation. It also becomes easy to enforce conventions
    with tests and notice during code review when shared code changes something controlled
    by semantic conventions and breaks them.
  prefs: []
  type: TYPE_NORMAL
- en: Defining semantic conventions in code is sufficient for some applications. Others,
    which may use different languages or have some other constraints, cannot rely
    on shared code alone. Either way, telemetry can be used by everyone in the company
    for business reporting and for any non-technical needs. So, it’s important to
    document it separately from code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how we can do this using OpenTelemetry tooling.
  prefs: []
  type: TYPE_NORMAL
- en: Using OpenTelemetry schemas and tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It does not really matter how we document custom semantic conventions. The goal
    is to have a consistent and specific convention that’s easy to read and follow.
    Let’s see how the OpenTelemetry semantic conventions schema may help with this.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic conventions schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, when we have talked about semantic conventions, we have referred to
    Markdown files such as [https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/http.md](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/http.md).
    These files are the source of truth, but here, we’re going to take a look at the
    implementation details behind them.
  prefs: []
  type: TYPE_NORMAL
- en: The tables describing the attributes in these files are usually auto-generated.
    Attributes are defined in YAML files that follow OpenTelemetry’s semantic convention
    schema.
  prefs: []
  type: TYPE_NORMAL
- en: YAML files could be shared across different semantic conventions and signals
    and then consistently written to all Markdown files with a script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how our meme attributes can be defined in a YAML file to get an impression
    of the schema:'
  prefs: []
  type: TYPE_NORMAL
- en: memes-common.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we defined the `name` attribute with a `string` type inside the `memes.meme`
    namespace (defined by the `prefix` property). It’s a required attribute since,
    in [*Chapter 5*](B19423_05.xhtml#_idTextAnchor083), *Configuration and Control
    Plane*, we decided to record the meme name attribute on all the spans.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenTelemetry supports several requirement levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '`required`: Any telemetry item that follows this convention must set the attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conditionally_required`: The attribute must be populated when a condition
    is met. For example, http.route is only populated when routing is enabled and
    a route is available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recommended`: The attribute should be populated, but may be removed or disabled.
    Observability backends and tools should not rely on it being available. This is
    the default level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opt_in`: The attribute is not populated by default, but is known and documented,
    and it can be added when it’s explicitly enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see how we can define the `size` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: memes-common.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml)'
  prefs: []
  type: TYPE_NORMAL
- en: The `size` attribute has the `int` type (and maps to `int64` or `long`) and
    an `opt-in` level as we don’t want to record it on all telemetry by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can define the `type` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: memes-common.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-common.yaml)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we define `type` as an enumeration. Instrumentation must use one of the
    values defined here or set `type` to `unknown`.
  prefs: []
  type: TYPE_NORMAL
- en: I hope your team won’t spend too much time deciding between JPEG and JPG – either
    is fine. What’s important is to pick and document one option.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the full schema definition in the OpenTelemetry build tools repository
    on GitHub (https://github.com/open-telemetry/build-tools/blob/main/semantic-conventions/syntax.md).
    It also contains the schema definition that your IDE may use to autocomplete and
    validate schema files.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined a few attributes, let’s use another OpenTelemetry tool
    to validate the schema file and generate content in a Markdown file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the raw `memes.md` file in the book repository, it contains
    documentation with the following annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: memes.md
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes.md](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes.md)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Content in between these lines is auto-generated from the YAML group that has
    the `memes.meme` identifier. We can regenerate this content with the following
    command (make sure to specify the path):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the Markdown generator from the `otel/semconvgen` image. We mount
    the `source` and `destination` volumes. The generator recursively parses all YAML
    files found in the `source` folder and then generates attribute tables in Markdown
    files available in the `destination` folder based on the `semconv` annotations
    we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The generation is the cherry on top of the cake, and you might not need it initially.
    Still, if you decide to use OpenTelemetry semantic convention schemas, make sure
    to use the `otel/semconvgen` tool to *validate* YAML files, which you can do as
    a part of your CI run; just add the `–md-check` flag to the previous command.
  prefs: []
  type: TYPE_NORMAL
- en: The tooling also supports generating attribute definitions in code using Jinja
    templates (https://jinja.palletsprojects.com). All we need is to create a Jinja
    template for the `SemanticConventions.cs` file and run the `otel/semconvgen` generator.
  prefs: []
  type: TYPE_NORMAL
- en: We can also define tracing, metrics, or event-specific conventions. Let’s do
    it for events.
  prefs: []
  type: TYPE_NORMAL
- en: Defining event conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Meme upload and download events are important for business reporting. We can’t
    really expose them as metrics – meme names have high cardinality and we’re interested
    in finding the most popular ones or measuring other per-meme things.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid breaking business reporting, we need to make sure events are defined
    precisely enough and are well documented. To achieve this, we can declare an event
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: memes-events.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-events.yaml](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter14/semconv/memes-events.yaml)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we declare a group with the `event` type (previously, we used `attribute_group`,
    which is signal agnostic). We provided a prefix (`download_name`) that documents
    the event name. We added references to attributes defined previously, but now
    require the presence of the `size` and `type` attributes on these events only.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the event name does not contain a namespace – here,
    we follow the `event` semantic convention. If you look at the corresponding code
    snippet for the `EventService` class, we also record the `event.domain` attribute,
    which serves as a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: With this approach, we can define spans or metric conventions that reuse the
    same common attributes.
  prefs: []
  type: TYPE_NORMAL
- en: These schemas or corresponding Markdown files would define and document the
    contract between telemetry producers and consumers regardless of the language
    they use.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about different ways to keep custom telemetry and
    attributes consistent across your system. We identified attribute properties to
    be documented and learned about attribute naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping telemetry consistent is a challenge. We explored how to make it easier
    by sharing common instrumentation code, including OpenTelemetry setup and utility
    methods that report attributes with the right names and types.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned about the OpenTelemetry semantic conventions schema and
    tooling, which may help you define, validate, and automate the documentation process
    for custom conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a common schema for telemetry during the early stages of a project
    is going to save your organization a lot of time down the road, and now you have
    the knowledge and tools to do it. In the next chapter, we’ll talk about brownfield
    systems, where new solutions coexist with legacy ones, and we’ll see how difficult
    it can be to align different standards and conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s likely that alerts, dashboards, and usage reporting depend on custom telemetry
    and rely on conventions. How would you approach evolving conventions to prevent
    breaking something critical?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to validate that telemetry coming from some service follows defined
    semantic conventions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
