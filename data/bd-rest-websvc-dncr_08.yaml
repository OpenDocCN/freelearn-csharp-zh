- en: Securing RESTful Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护RESTful Web服务
- en: In the world of web applications, where there are numerous request and response
    exchanges over HTTP, security is one of the most important cross-cutting concerns.
    Any unsecured service or web application can face datatampering issues.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序的世界中，在HTTP上存在大量的请求和响应交换，安全是其中一个最重要的横切关注点。任何不安全的服务或Web应用程序都可能面临数据篡改问题。
- en: '"Whenever data is modified (destroyed, manipulated, or edited) by an unauthorized
    channel, it is generally called data tempering."'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: “当数据被未经授权的渠道修改（销毁、篡改或编辑）时，通常被称为数据篡改。”
- en: Data can be tampered with when it is in transit or in another place. There might
    be several reasons why data is tampered with—unprotected data is the most common
    reason in the industry. To prevent such issues, you can protect your environment
    and application systems. Generally, a firewall is the best way to protect your
    environment (server). You can protect an application by implementing an authorization
    mechanism.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在传输或存储在其他地方时可能会被篡改。数据被篡改可能有几个原因——在行业中，未受保护的数据是最常见的原因。为了防止这些问题，您可以保护您的环境和应用程序系统。通常，防火墙是保护环境（服务器）的最佳方式。您可以通过实施授权机制来保护应用程序。
- en: Unfortunately, data breaches of well-known sites are commonplace these days.
    Taking this into account, information and application security has become critical
    to web applications. For the same reason, secure applications should no longer
    be an afterthought. Security is everyone's responsibility in an organization.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，知名网站的数据泄露事件如今司空见惯。考虑到这一点，信息和应用程序安全对Web应用程序变得至关重要。因此，安全的应用程序不应再是事后考虑的事情。在组织中，安全是每个人的责任。
- en: 'In this chapter, we will mainly be focused on security and the REST and OWASP
    security standards. By the end of this chapter, you will understand the concepts
    of authentication, single sign-on (SSO), token-based authentication, and authentication
    using a proxy server (such as Azure API Management). We will cover the following
    topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将主要关注安全和REST以及OWASP安全标准。到本章结束时，您将了解认证、单点登录（SSO）、基于令牌的认证以及使用代理服务器（如Azure
    API Management）进行认证的概念。我们将涵盖以下主题：
- en: OWASP standards for web security
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OWASP网络安全标准
- en: Securing RESTful web services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护RESTful web服务
- en: Authentication and authorization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证和授权
- en: Validations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证
- en: Data encryption and storing sensitive data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据加密和存储敏感数据
- en: OWASP security standards
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OWASP安全标准
- en: 'The **Open Web Application Security Project** (**OWASP**) is an online community
    that mainly works on web application security problems by creating various studies
    and standards. In this chapter, we will follow the security standards of OWASP
    that were released in 2017 ([https://www.owasp.org/index.php/Top_10-2017_Top_10](https://www.owasp.org/index.php/Top_10-2017_Top_10)):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放网络应用安全项目**（**OWASP**）是一个在线社区，主要通过创建各种研究和标准来解决Web应用程序安全问题。在本章中，我们将遵循2017年发布的OWASP安全标准（[https://www.owasp.org/index.php/Top_10-2017_Top_10](https://www.owasp.org/index.php/Top_10-2017_Top_10)）：'
- en: '![](img/968d6f59-d1c6-4c36-a56d-25182e578d50.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/968d6f59-d1c6-4c36-a56d-25182e578d50.png)'
- en: Application security risks
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应用安全风险
- en: The preceding diagram is a pictorial overview of an application's security risks.
    It depicts how an attacker might attack a weaker application. The attacker attacks
    application components by injecting scripts (mostly JavaScript) and impacting
    the system. In this image, you will notice that only an unsecured portion of the
    web application is under attack. A secure system is safe, even after it has been
    attacked.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表是应用程序安全风险的概述图。它描述了攻击者可能如何攻击一个较弱的程序。攻击者通过注入脚本（主要是JavaScript）并影响系统来攻击应用程序组件。在这张图片中，您会注意到只有未受保护的Web应用程序部分受到攻击。一个安全系统即使在遭受攻击后也是安全的。
- en: 'The following are application security risks as defined by OWASP:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由OWASP定义的应用程序安全风险：
- en: Injection
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入
- en: Broken authentication
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破坏性认证
- en: Sensitive data exposure
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏感数据泄露
- en: XML external entities (XXE)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML外部实体（XXE）
- en: Broken access control
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破坏性的访问控制
- en: Security misconfiguration
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全配置错误
- en: Cross-site scripting (XSS)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨站脚本（XSS）
- en: Insecure deserialization
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不安全的反序列化
- en: These are high-alarmed security risks that should be handled in every web application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是高警报的安全风险，应该在每个Web应用程序中处理。
- en: Securing RESTful web services
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护RESTful web服务
- en: 'Before you start with learning about securing RESTful web services, I would
    like to tell you about security in the world of the web. In general, the phrase
    *security* describes the measures that are taken to make sure that everything
    is secure. But what does *everything* include here? Let''s elaborate: security
    is a way or a process that stops unauthenticated and unauthorized access to confidential
    data over web applications.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始学习关于保护 RESTful Web 服务之前，我想告诉你关于 Web 世界中的安全性的情况。一般来说，短语“安全性”描述的是为确保一切安全而采取的措施。但这里的“一切”包括什么？让我们详细说明：安全性是一种阻止未经验证和未经授权访问通过
    Web 应用程序机密数据的方式或过程。
- en: The type of confidential data depends upon the nature of the web application—for
    example, if the web application is for medical and clinical services, then the
    confidential information consists of all the patients' data related to their tests,
    medical history, and so on.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 机密数据的类型取决于 Web 应用的性质——例如，如果 Web 应用程序是用于医疗和临床服务，则机密信息包括所有与患者测试、医疗历史等相关患者的数据。
- en: The first step towards the creation of a security process is to authenticate
    and authorize access to the web application. If the request is not authenticated,
    then it should not be accepted by the system. It should also not be accepted if
    the request is authenticated, but not authorized to access the data of the web
    application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 创建安全过程的第一个步骤是验证和授权对 Web 应用的访问。如果请求未进行身份验证，则系统不应接受该请求。如果请求已进行身份验证但未授权访问 Web 应用程序的数据，则也不应接受该请求。
- en: 'The following diagram shows an overview of the authentication process, using
    Auth services:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了使用 Auth 服务进行身份验证过程的概述：
- en: '![](img/5fd52e96-be02-4c61-aeca-ced31340e984.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5fd52e96-be02-4c61-aeca-ced31340e984.png)'
- en: In the preceding diagram, you can think about a typical ASP.NET Core API system
    that uses Auth services as a middleware server. There may be several clients or
    consumers who are using these services and can request access to the data. Here,
    Auth services play an important role in authenticating incoming requests from
    clients. If the Auth service identifies the request as authenticated, it generates
    a token and sends it to the API servers for further processing. If the request
    is not an authenticated request, then the Auth service notifies the client of
    the failed authentication. The preceding image is just an overview of a typical
    scenario. An actual scenario could be more complex, with the use of one or more
    middleware backend servers (typical API management servers).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，你可以考虑一个典型的使用 Auth 服务作为中间件服务器的 ASP.NET Core API 系统。可能有多个客户端或消费者正在使用这些服务并请求访问数据。在这里，Auth
    服务在验证来自客户端的传入请求方面发挥着重要作用。如果 Auth 服务识别请求为已验证，则生成一个令牌并将其发送到 API 服务器以进行进一步处理。如果请求未经验证，则
    Auth 服务会通知客户端身份验证失败。前面的图像只是一个典型场景的概述。实际场景可能更复杂，可能使用一个或多个中间件后端服务器（典型的 API 管理服务器）。
- en: 'In the following sections, you will get a better idea of the following two
    important security concepts:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，你将更好地了解以下两个重要的安全概念：
- en: '**Authentication**: Authentication is nothing but a process where a system
    verifies or identifies the incoming requests by some sort of credentials (generally
    a user ID and password). If the system finds that the provided credentials are
    wrong, then it notifies the user (generally via a message on the GUI screen) and
    terminates the authorization process.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：身份验证不过是一个通过某种凭证（通常是一个用户 ID 和密码）来验证或识别传入请求的过程。如果系统发现提供的凭证错误，则它会通知用户（通常通过
    GUI 屏幕上的消息），并终止授权过程。'
- en: '**Authorization**: Authorization always comes after authentication. It is a
    process that allows the authenticated user who raised the request to access resources
    or data after verifying they have access to the specific resources or data.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：授权总是在身份验证之后进行。这是一个允许已验证用户在验证他们有权访问特定资源或数据后访问资源或数据的过程。'
- en: From this, you can conclude that the security of RESTful services is the most
    important feature of the application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你可以得出结论，RESTful 服务的安全性是应用程序最重要的功能。
- en: How can you maintain sessions in RESTful web services?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何在 RESTful Web 服务中维护会话？
- en: RESTful web services work with the HTTP protocol, which is a stateless protocol
    ([https://stackoverflow.com/questions/13200152/why-say-that-http-is-a-stateless-protocol](https://stackoverflow.com/questions/13200152/why-say-that-http-is-a-stateless-protocol)),
    and treat every request as a new request. There is no way in which the HTPP protocol
    helps to maintain sessions in RESTful web services. But, we can achieve this programmatically
    with the help of authenticated tokens. This technique is known as token-based
    authorization (we will discuss it in detail in the coming sections). With the
    help of this technique, you can authorize an authenticated user to allow data
    or resources for a predefined period of time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful Web服务使用HTTP协议，这是一个无状态协议([https://stackoverflow.com/questions/13200152/why-say-that-http-is-a-stateless-protocol](https://stackoverflow.com/questions/13200152/why-say-that-http-is-a-stateless-protocol))，并将每个请求视为新的请求。HTTP协议没有提供在RESTful
    Web服务中维护会话的方法。但是，我们可以通过使用认证令牌程序化地实现这一点。这种技术被称为基于令牌的授权（我们将在接下来的章节中详细讨论）。借助这种技术，您可以授权经过认证的用户允许数据或资源在预定义的时间内。
- en: 'Every request that comes via services or any other mode should be authenticated
    and authorized before the system responds to the user or the client that made
    the call. This process mainly includes the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每个通过服务或其他任何方式发送的请求在系统响应用户或发起调用的客户端之前都应进行身份验证和授权。此过程主要包括以下内容：
- en: '**Confidentiality**: The secured system makes sure that any sensitive data
    is not exposed to unauthenticated and unauthorized access requests'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机密性**：安全系统确保任何敏感数据不会被未经验证和未经授权的访问请求暴露'
- en: '**Availability**: The security measures in the system make sure that the system
    is available for users who are genuine, as confirmed through the system''s authentication
    and authorization mechanism'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：系统的安全措施确保系统对经过系统验证和授权的合法用户可用'
- en: '**Integrity**: In a secured system, data tampering is not possible, so the
    data is secure'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**：在安全系统中，数据篡改是不可能的，因此数据是安全的'
- en: The vulnerable areas of an unsecured web application
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全Web应用程序的易受攻击区域
- en: In today’s web applications, the main vulnerable assets to protect from unauthorized
    access are the resources and data. If a site is unsecured, then the chances of
    vulnerability are high. According to the official website at[ https://docs.microsoft.com/en-us/aspnet/core/security/](https://docs.microsoft.com/en-us/aspnet/core/security/),
    the following areas are the main threats to any unsecured web application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的Web应用程序中，主要需要保护免受未经授权访问的易受攻击资产是资源和数据。如果一个网站不安全，那么漏洞的可能性就很高。根据官方网站[ https://docs.microsoft.com/en-us/aspnet/core/security/](https://docs.microsoft.com/en-us/aspnet/core/security/)，以下区域是任何不安全Web应用程序的主要威胁。
- en: Cross-site scripting attacks
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站脚本攻击
- en: 'Cross-site scripting attacks—or XSS attacks—typically happen as a result of
    bad input, where an attacker injects client scripts (JavaScript in most cases)
    into the web page. According to the official web page ([https://docs.microsoft.com/en-us/aspnet/core/security/cross-site-scripting](https://docs.microsoft.com/en-us/aspnet/core/security/cross-site-scripting)):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站脚本攻击——或称XSS攻击——通常是由于不良输入而发生的，攻击者将客户端脚本（通常是JavaScript）注入到网页中。根据官方网页([https://docs.microsoft.com/en-us/aspnet/core/security/cross-site-scripting](https://docs.microsoft.com/en-us/aspnet/core/security/cross-site-scripting))：
- en: '"Cross-Site Scripting (XSS) is a security vulnerability which enables an attacker
    to place client-side scripts (usually JavaScript) into web pages."'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '"跨站脚本（XSS）是一种安全漏洞，它允许攻击者将客户端脚本（通常是JavaScript）放入网页中。"'
- en: Here, I am using the example of a web client that consumes web services. You
    will learn more about web clients in [Chapter 10](9fcac4d2-710a-48a2-98be-ed0034525cee.xhtml), *Building
    a Web Client (Consuming Web Services)*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用了一个消费Web服务的Web客户端的例子。你将在第10章[9fcac4d2-710a-48a2-98be-ed0034525cee.xhtml]，*构建Web客户端（消费Web服务）*中了解更多关于Web客户端的内容。
- en: 'The following screenshot shows a scenario where the Create screen is under
    attack:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了一个攻击中创建屏幕的场景：
- en: '![](img/36cad43d-568a-4d96-b78c-540f91b92e34.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36cad43d-568a-4d96-b78c-540f91b92e34.png)'
- en: The preceding screenshot is a representation of an unsecure web application.
    Here, the user can inject the script tag, and when the user clicks on Create,
    it is posted back to the server.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图表示了一个不安全的Web应用程序。在这里，用户可以注入脚本标签，当用户点击创建时，它会被发送回服务器。
- en: 'The following screenshot shows the code''s debug mode, where we can see that
    our system is accepting script data:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了代码的调试模式，我们可以看到我们的系统正在接受脚本数据：
- en: '![](img/a485f149-a9f6-46d9-ab47-4767482077c4.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a485f149-a9f6-46d9-ab47-4767482077c4.png)'
- en: The preceding screenshot shows how it was posted to the server and was eventually
    saved in the database or any persistent repository.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了它如何被发送到服务器，并最终保存在数据库或任何持久存储库中。
- en: 'The following screenshot shows the affected page:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了受影响的页面：
- en: '![](img/a2f4336f-308f-4be5-97de-5cb9a92d72ab.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a2f4336f-308f-4be5-97de-5cb9a92d72ab.png)'
- en: Whenever anyone accesses a page with affected data, it will show an alert, as
    shown in the preceding screenshot.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何人访问受影响数据的页面时，它将显示一个警告，如前面的截图所示。
- en: You can build a system that stops such attacks by applying a few code changes.
    I will cover this in the *Validations* section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过应用一些代码更改来构建一个阻止此类攻击的系统。我将在*验证*部分中介绍这一点。
- en: SQL injection attacks
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL注入攻击
- en: An SQL injection attack is one of the most severe attacks that directly target
    the database. This is first in the list of OWASP application security risks. Attackers
    can steal a system's secured data with the help of SQL injection.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入攻击是直接针对数据库的最严重的攻击之一。这是OWASP应用程序安全风险列表中的第一个。攻击者可以利用SQL注入窃取系统的受保护数据。
- en: 'The following diagram shows the process of SQL injection:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了SQL注入的过程：
- en: '![](img/38261ad4-2792-4435-90bd-476e9af7d479.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/38261ad4-2792-4435-90bd-476e9af7d479.png)'
- en: In the preceding diagram, you can see a typical SQL injection scenario where
    the attacker has injected an `or` clause to fetch all of the data of a particular
    table. The actual code instruction was to return a single record based on the `EmpId`
    from the employee table. But as it was injected with an extra phrase, it returns
    the complete records of the employee table. This is the biggest problem with an
    unsecured system. Here, the attacker injected a simple clause into the statement.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到一个典型的SQL注入场景，攻击者注入了一个`or`子句来获取特定表的全部数据。实际的代码指令是根据员工表中的`EmpId`返回单个记录。但由于注入了额外的短语，它返回了员工表的完整记录。这是不安全系统最大的问题。在这里，攻击者将一个简单的子句注入到语句中。
- en: What is cooking here?
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这里在做什么？
- en: 'In the previous section, you saw an imaginary scenario and went through an
    SQL injection in action. Let’s look at an actual example by creating a RESTful
    product API using ASP.NET Core 2.0\. Before you start building this application,
    bear in mind the following prerequisites for this application:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，你看到了一个假设的场景，并进行了SQL注入的实际操作。现在，让我们通过创建一个使用ASP.NET Core 2.0的RESTful产品API来查看一个实际示例。在你开始构建这个应用程序之前，请记住以下应用程序的先决条件：
- en: Visual Studio 2017 update 3 or later
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2017更新3或更高版本
- en: ASP.NET Core 2.0 or later
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core 2.0或更高版本
- en: C#7.0 or later
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#7.0或更高版本
- en: Microsoft Entity Framework Core 2.0.0
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Entity Framework Core 2.0.0
- en: 'Go through the following steps to create our application:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建我们的应用程序：
- en: Open Visual Studio.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。
- en: Select File | New | Project or press *Ctrl* + *Shift* + *F5*.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择文件 | 新建 | 项目或按*Ctrl* + *Shift* + *F5*。
- en: Select ASP.NET Core Web Application.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择ASP.NET Core Web应用程序。
- en: From the template window, select ASP.NET Core API. Make sure you select .NET
    Core 2.0.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从模板窗口中选择ASP.NET Core API。确保你选择了.NET Core 2.0。
- en: Name the project, choose the path for the solution, and click OK.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名项目，选择解决方案的路径，然后单击确定。
- en: Add the `Models` folder. In Solution Explore, right-click, select Add New Folder from
    the drop-down menu, and name it `Models`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Models`文件夹。在解决方案资源管理器中右键单击，从下拉菜单中选择添加新文件夹，并将其命名为`Models`。
- en: Add a new class under the `Models` folder. Right-click on the `Models` folder
    in Solution Explorer and select Add New Item | Class from the drop-down menu,
    or use *Shift* + *Alt* + *C*.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Models`文件夹下添加一个新类。在解决方案资源管理器中右键单击`Models`文件夹，从下拉菜单中选择添加新项 | 类，或者使用*Shift*
    + *Alt* + *C*。
- en: Please note that the shortcut keys vary as per your settings for Visual Studio.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，快捷键会根据你的Visual Studio设置而有所不同。
- en: 'Name it `Product.cs`, and add the following code to this class:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名为`Product.cs`，并将以下代码添加到这个类中：
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Repeat steps 7 and 8, adding `Category.cs` and `ProductViewModel.cs`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤7和8，添加`Category.cs`和`ProductViewModel.cs`。
- en: Repeat step 6, adding the `Contexts` folder.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤6，添加`Contexts`文件夹。
- en: Add a new class under the `Contexts` folder. Right-click on the `Contexts` folder
    in Solution Explorer, select Add New Item, and in the dialog box, select Class,
    or use *Shift* + *Alt* + *C*
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Contexts` 文件夹下添加一个新类。在解决方案资源管理器中右键单击 `Contexts` 文件夹，选择添加新项，在对话框中，选择类，或使用
    *Shift* + *Alt* + *C*
- en: Name it `ProductContext.cs`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为 `ProductContext.cs`。
- en: 'Now, open the `appsettings.json` file and add the following code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `appsettings.json` 文件并添加以下代码：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Right-click on the project in Solution Explorer and select Manage NuGet Package.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中右键单击项目并选择管理 NuGet 包。
- en: Under NuGet Package Manager screen, search for `Swashbuckle.ASPNETCore` and
    install it.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 NuGet 包管理器界面下，搜索 `Swashbuckle.ASPNETCore` 并安装它。
- en: Add a new folder called `Persistence`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Persistence` 的新文件夹。
- en: Add an `IProductRepository` interface under the `Persistence` folder.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Persistence` 文件夹下添加一个 `IProductRepository` 接口。
- en: 'Add the following code to the `IProductRepository` interface:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `IProductRepository` 接口：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Refer to the GitHub repository link at [https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core) for
    the complete source code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 参考GitHub仓库链接 [https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core)
    以获取完整的源代码。
- en: Add the `ProductRepository.cs` class under the `Persistence` folder.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Persistence` 文件夹下添加 `ProductRepository.cs` 类。
- en: 'Add the following code to `ProductRepository.cs`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `ProductRepository.cs`：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Open the `Startup.cs` file and add the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Startup.cs` 文件并添加以下代码：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, you are ready to play with the application. Run the application from the
    menu or hit *F5*. In the web browser, add the `/swagger` suffix to the URL in
    the address bar, as shown in the following screenshot:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您已经准备好与该应用程序互动了。从菜单中运行应用程序或按 *F5* 键。在网页浏览器中，将 `/swagger` 后缀添加到地址栏中的 URL，如下面的截图所示：
- en: '![](img/f302dc09-ab8e-4e5d-ad35-c2c073964838.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f302dc09-ab8e-4e5d-ad35-c2c073964838.png)'
- en: 'It will show the Swagger API documentation, as shown in the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它将显示 Swagger API 文档，如下面的截图所示：
- en: '![](img/54ba2a0c-fe5e-482b-853b-fad4f7aab778.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54ba2a0c-fe5e-482b-853b-fad4f7aab778.png)'
- en: Swagger documentation for the Product APIs
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 产品 API 的 Swagger 文档
- en: I used Swagger for the documentation and to test API calls. You can use other
    API test clients, such as Advanced Rest Client and PostMan.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 Swagger 进行文档编写和测试 API 调用。您可以使用其他 API 测试客户端，例如 Advanced Rest Client 和 PostMan。
- en: 'To test our unsecured code, click on the `GET` `/api/product/{productid}` resource and
    pass the product ID, as shown in the following screenshot:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试我们的未加密代码，请点击 `GET` `/api/product/{productid}` 资源，并传递产品 ID，如下面的截图所示：
- en: '![](img/5b575d5b-c23a-4634-8eaf-0c4080a53e49.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b575d5b-c23a-4634-8eaf-0c4080a53e49.png)'
- en: 'Click Execute. You should see the following expected output:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击执行。您应该看到以下预期输出：
- en: '![](img/5dc3b253-3137-4adf-91e4-28b1ee7ab72f.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5dc3b253-3137-4adf-91e4-28b1ee7ab72f.png)'
- en: 'Now, let''s try to add the `OR` clause and see what happens. Here, I am entering
    the `productid` value as `4D261E4A-A657-4ADD-A0F6-DDE6E1464D55` or `1=1`. Execute
    it and look at the result:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试添加 `OR` 子句并看看会发生什么。在这里，我将 `productid` 值输入为 `4D261E4A-A657-4ADD-A0F6-DDE6E1464D55`
    或 `1=1`。执行它并查看结果：
- en: '![](img/acaaa4aa-09b4-45c1-8e0e-b4a20bf55a14.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/acaaa4aa-09b4-45c1-8e0e-b4a20bf55a14.png)'
- en: 'Here, we can see that our application is affected by SQL injection. You are
    seeing all the records from the table. It happened because of the raw SQL query
    (refer to [https://docs.microsoft.com/en-us/ef/core/querying/raw-sql](https://docs.microsoft.com/en-us/ef/core/querying/raw-sql) for
    more information) that we are using. You can find the reason for the earlier results
    after looking closer at the code. The following screenshot will remind you what
    the request URL was:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的应用程序受到了 SQL 注入的影响。您看到了表中的所有记录。这是由于我们使用的原始 SQL 查询（有关更多信息，请参阅 [https://docs.microsoft.com/en-us/ef/core/querying/raw-sql](https://docs.microsoft.com/en-us/ef/core/querying/raw-sql)）造成的。您可以在仔细查看代码后找到先前结果的原因。以下截图将提醒您请求
    URL 是什么：
- en: '![](img/793b6f47-ed4b-4448-9a62-4ea52998664a.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/793b6f47-ed4b-4448-9a62-4ea52998664a.png)'
- en: 'This is the injected URL. When our repository''s `GetByProduct(string id)` method executed,
    it created the following raw SQL query:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是注入的 URL。当我们的仓库的 `GetByProduct(string id)` 方法执行时，它创建了以下原始 SQL 查询：
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This shows that the attacker did the job very smartly and quietly. Our unsecured
    code bled and returned the entirety of the data of the targeted table. I used
    the SQL profiler ([https://docs.microsoft.com/en-us/sql/tools/sql-server-profiler/sql-server-profiler](https://docs.microsoft.com/en-us/sql/tools/sql-server-profiler/sql-server-profiler))
    to trace the queries.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明攻击者非常聪明且悄无声息地完成了工作。我们的不安全代码泄露并返回了目标表的全部数据。我使用了SQL分析器([https://docs.microsoft.com/en-us/sql/tools/sql-server-profiler/sql-server-profiler](https://docs.microsoft.com/en-us/sql/tools/sql-server-profiler/sql-server-profiler))来追踪查询。
- en: Fixing SQL injection attacks
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决SQL注入攻击
- en: There is nothing more dangerous than unsecured code. With unsecured code, the
    application is always in danger. Attackers can steal data at any time, forcefully
    manipulating things by tampering with requests.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比不安全的代码更危险了。使用不安全的代码，应用程序始终处于危险之中。攻击者可以随时窃取数据，通过篡改请求强制性地操纵事物。
- en: Saineshwar Bageri has written 10 tips for creating a secure ASP.NET web application.
    You can read them at [https://www.codeproject.com/Articles/1116318/Points-to-Secure-Your-ASP-NET-MVC-Applications](https://www.codeproject.com/Articles/1116318/Points-to-Secure-Your-ASP-NET-MVC-Applications).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Saineshwar Bageri 写了10个创建安全ASP.NET Web应用程序的技巧。您可以在[https://www.codeproject.com/Articles/1116318/Points-to-Secure-Your-ASP-NET-MVC-Applications](https://www.codeproject.com/Articles/1116318/Points-to-Secure-Your-ASP-NET-MVC-Applications)上阅读它们。
- en: 'You can stop an SQL injection attack with the following two techniques:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下两种技术停止SQL注入攻击：
- en: '**Validations**: We will discuss these later in the chapter.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证**：我们将在本章后面讨论这些问题。'
- en: '**Using parameters in raw SQL queries**: This is in addition to using a raw
    SQL query directly by concatenating values (refer to our example of unsecured
    code). In this way, you can rewrite the `GetByProduct(string id)` method as the
    following:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在原始SQL查询中使用参数**：这除了直接通过连接值使用原始SQL查询之外。这样，您可以重新编写`GetByProduct(string id)`方法如下：'
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code still contains a raw SQL query, but it is secure enough
    to handle any injected code. If you try the same parameter value we used earlier,
    then the modified code will not accept it. It will throw an exception, as shown
    in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码仍然包含原始SQL查询，但它足够安全，可以处理任何注入的代码。如果您尝试我们之前使用的相同参数值，则修改后的代码将不接受它。它将抛出异常，如下面的屏幕截图所示：
- en: '![](img/3aec9d30-804a-4095-a26a-f83a942b95cd.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3aec9d30-804a-4095-a26a-f83a942b95cd.png)'
- en: 'You can also use string the interpolation syntax with a raw SQL query if your
    EF Core version is 2.0.0 or above. With string interpolation, the code looks like
    the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的EF Core版本为2.0.0或更高版本，您也可以在原始SQL查询中使用字符串插值语法。使用字符串插值，代码看起来如下：
- en: '`public IEnumerable<Product> GetByProduct(string id) => _context.Products`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`public IEnumerable<Product> GetByProduct(string id) => _context.Products`'
- en: '`.FromSql($"SELECT * FROM dbo.Products WHERE id={id}")`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`.FromSql($"SELECT * FROM dbo.Products WHERE id={id}")`'
- en: '`.Include(p => p.Category)`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`.Include(p => p.Category)`'
- en: '`.ToList();`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`.ToList();`'
- en: '**Data encryption**: We will discuss this later in the chapter.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据加密**：我们将在本章后面讨论这个问题。'
- en: Cross-site request forgery
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站请求伪造
- en: '**Cross-site request forgery** (**CRSF**) can also be shortened to **XSRF**.
    This is a common attack where the attacker infuses an unwanted action while the
    client is interacting (request/response) with the hosted application. Generally,
    attackers use malicious code to influence the interaction.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站请求伪造**（**CRSF**）也可以简称为**XSRF**。这是一种常见的攻击方式，攻击者在客户端与托管应用程序交互（请求/响应）时注入不受欢迎的操作。通常，攻击者使用恶意代码来影响交互。'
- en: Malicious code is scripting code that downloads onto a web browser and executes,
    even without the knowledge of the authenticated user. For details, refer to [https://www.techopedia.com/definition/4013/malicious-active-content](https://www.techopedia.com/definition/4013/malicious-active-content).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意代码是下载到网页浏览器并执行的脚本代码，即使未经认证用户的知识，也会执行。有关详细信息，请参阅[https://www.techopedia.com/definition/4013/malicious-active-content](https://www.techopedia.com/definition/4013/malicious-active-content)。
- en: Attackers are very smart, and they use different platforms to provide spurious
    links to malicious code. These links are very similar to the domain (website)
    that is under attack. Financial websites are the main targets.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者非常聪明，他们使用不同的平台提供虚假链接到恶意代码。这些链接与受攻击的域（网站）非常相似。金融网站是主要的目标。
- en: 'The following diagram depicts an XSRF attack:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了一个XSRF攻击：
- en: '![](img/255cc01d-e689-42fc-a8d3-f7c365e5c71b.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/255cc01d-e689-42fc-a8d3-f7c365e5c71b.png)'
- en: Attackers could send a link via email, social media, or any other medium. When
    the user clicks on the link, he or she will be in the world of the attacker without
    knowing that it's a spurious site and not their intended site.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以通过电子邮件、社交媒体或其他任何媒介发送链接。当用户点击链接时，他们将会进入攻击者的世界，而不知道这是一个虚假的网站，而不是他们想要访问的网站。
- en: You can find the official web page at [https://docs.microsoft.com/en-us/aspnet/core/security/anti-request-forgery](https://docs.microsoft.com/en-us/aspnet/core/security/anti-request-forgery).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.microsoft.com/en-us/aspnet/core/security/anti-request-forgery](https://docs.microsoft.com/en-us/aspnet/core/security/anti-request-forgery)找到官方网页。
- en: CSRF vulnerabilities are fundamentally a problem with the web app, not the end
    user.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF漏洞本质上是Web应用程序的问题，而不是终端用户的问题。
- en: To handle this kind of attack, you need to build a system that is secure and
    properly authenticated. I will walk you through the details in the coming section
    focusing on authentication.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种攻击，你需要构建一个既安全又正确认证的系统。在接下来的章节中，我将详细介绍认证的细节。
- en: Authentication and authorization in action
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际操作中的身份验证和授权
- en: Up until now, you have learned about the basics of authentication and authorization.
    In this section, you will see these two most important ways of securing an application
    in action.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了身份验证和授权的基础知识。在本节中，你将看到这两种最重要的保护应用程序的方法在实际中的应用。
- en: Basic authentication, token-based authorization, and other authentications
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本身份验证、基于令牌的授权以及其他授权方式
- en: Whenever you’re talking about secured web services/web applications, you should
    think about the all the points I mentioned regarding authentication and authorization
    in the previous sections.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你谈论受保护的Web服务/应用程序时，你应该考虑我在前几节中提到的关于身份验证和授权的所有要点。
- en: In this section, I’m going to discuss authentication and authorization at the
    implementation stage.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将讨论实施阶段的身份验证和授权。
- en: Basic authentication
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本身份验证
- en: As is evident from the word *basic*, basic authentication involves a mechanism
    where the system asks for simple credentials (username and password) to authenticate
    or validate the user via incoming requests from the client to the web or application
    servers via RESTful web services (in our case, ASP.NET Core web APIs).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如“基本”一词所示，基本身份验证涉及一种机制，其中系统要求用户提供简单的凭证（用户名和密码），通过来自客户端到Web或应用程序服务器的请求（在我们的案例中，是ASP.NET
    Core Web API）来验证或验证用户。
- en: 'Consider the following diagram, which showcases basic authentication:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图表，它展示了基本身份验证：
- en: '![](img/56f71166-ffe5-435d-adff-942f05565884.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56f71166-ffe5-435d-adff-942f05565884.png)'
- en: The preceding diagram is of the basic HTTP authentication that I'm going to
    implement in our code. Here, the request comes from the client to access resources
    that are protected (resources that are kept from public access). The request contains
    a username and password in its header at the service end, and the service checks
    whether it is a validate request or not by validating the username and password
    from its repository, usually a database store. The service returns the data in
    its response to the client if the user is validated; otherwise, it returns invalid
    credentials with HTTP status code 401.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是我将要在我们的代码中实现的基本HTTP身份验证。在这里，请求来自客户端，以访问受保护的资源（从公共访问中保留的资源）。请求在其头部包含用户名和密码，服务通过验证其存储库（通常是数据库存储）中的用户名和密码来检查它是否是一个有效的请求。如果用户被验证，服务将在其响应中返回数据给客户端；否则，它将返回带有HTTP状态码401的无效凭证。
- en: You can find a complete list of HTTP status codes, along with their definitions,
    at [https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)找到完整的HTTP状态码列表及其定义。
- en: The security concerns of basic authentication
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本身份验证的安全问题
- en: 'Basic authentication, as its name suggests, is a very basic authentication
    mechanism, and is not too secure when it comes to stopping attackers. Here, I
    have jotted down the following security vulnerabilities in the authentication
    process:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 基本身份验证，正如其名所示，是一种非常基本的身份验证机制，在阻止攻击者方面并不太安全。在这里，我已经记录了以下身份验证过程中的安全漏洞：
- en: '**Credentials**: The required credentials are the most important security concern
    that could lead to security breaches, which could in turn further exploit the
    system''s weak security.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凭证**：所需的凭证是可能导致安全漏洞的最重要安全问题，这反过来又可能进一步利用系统薄弱的安全。'
- en: '**Request**: Requests can be tampered with, and could lead to a big security
    breach; with basic authentication, every request carries the credentials (username
    and password), which can be tampered with and used to further exploit the system.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：请求可能会被篡改，可能导致重大安全漏洞；使用基本身份验证时，每个请求都携带凭证（用户名和密码），这些凭证可能会被篡改并用于进一步利用系统。'
- en: '**Closing the browser session**: There is a concern that should be high priority—there
    is no ability to log out from an application using the basic authentication method,
    unless the user closes the browser to destroy the browser session themselves.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭浏览器会话**：这是一个应该优先考虑的问题——使用基本身份验证方法无法从应用程序中注销，除非用户自己关闭浏览器以终止浏览器会话。'
- en: You can look at the official web page at [https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/basic-authentication](https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/basic-authentication) for
    more information.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看官方网页[https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/basic-authentication](https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/basic-authentication)以获取更多信息。
- en: '"Basic authentication is also vulnerable to CSRF attacks. After the user enters
    credentials, the browser automatically sends them on subsequent requests to the
    same domain, for the duration of the session."'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: “基本身份验证也容易受到CSRF攻击。用户输入凭证后，浏览器会自动在会话期间将它们发送到同一域的后续请求中。”
- en: There might be more security concerns that make the basic authentication mechanism
    the weakest with respect to web application security.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有更多安全问题，使得基本身份验证机制在Web应用安全方面变得最弱。
- en: Basic authentication leads to various security concerns. I am not going to showcase
    these using code examples of basic authentication, but if you still want to test
    the basic authentication mechanism, then I suggest that you extract the code from
    the forked GitHub repository at [https://github.com/garora/Bazinga.AspNetCore.Authentication.Basic](https://github.com/garora/Bazinga.AspNetCore.Authentication.Basic).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 基本身份验证导致各种安全问题。我无意使用基本身份验证的代码示例来展示这些问题，但如果您仍然想测试基本身份验证机制，我建议您从GitHub仓库[https://github.com/garora/Bazinga.AspNetCore.Authentication.Basic](https://github.com/garora/Bazinga.AspNetCore.Authentication.Basic)中提取代码。
- en: Token-based authorization
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于令牌的授权
- en: I explained authorization in the earlier sections of this chapter, where you
    saw that authorization is the next step after authentication to access restricted
    resources.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的部分，我解释了授权，您可以看到授权是认证之后访问受限资源的下一步。
- en: 'Let''s consider the following diagram, which depicts token-based authentication:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下图示，它描述了基于令牌的认证：
- en: '![](img/7da675a0-34dc-4b93-a420-7ec91e588173.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7da675a0-34dc-4b93-a420-7ec91e588173.png)'
- en: The preceding diagram shows a token-based authentication. If the request is
    verified (depending upon the identification of the credentials), then the client
    sends a request with the credentials and the returned token. The client then stores
    this token. It then sends these tokens with the headers in every request until
    the token is valid. If it is authorized to access the secure resource, the server
    verifies the request check and responds with the data. In some cases, the client
    may request a new token or call a refresh token if the existing token expires.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示展示了基于令牌的认证。如果请求被验证（取决于凭证的识别），则客户端发送带有凭证和返回令牌的请求。然后客户端存储此令牌。它随后将这些令牌与每个请求的头部一起发送，直到令牌有效。如果它被授权访问受保护资源，服务器将验证请求检查并返回数据。在某些情况下，客户端可能会请求新的令牌或调用刷新令牌，如果现有令牌过期。
- en: 'Let’s add an `AuthRequet` model, as shown in our API project created in the
    previous sections:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在上一节创建的API项目中添加一个`AuthRequet`模型：
- en: '[PRE7]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add a new `GenerateTokenController.cs` controller in the `Controller` folder.
    Here is our `GetToken` POST resource:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Controller`文件夹中添加一个新的`GenerateTokenController.cs`控制器。以下是我们的`GetToken` POST资源：
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Did you notice the `[AllowAnonymous]`attribute in the preceding code? You will
    see it in later sections. In the preceding code, I simply validate the credentials,
    and if the credentials are valid, the `TokenUtility `middleware generates the
    token.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到前面的代码中的 `[AllowAnonymous]` 属性了吗？你将在后面的章节中看到它。在前面的代码中，我只是验证凭证，如果凭证有效，`TokenUtility`
    中间件将生成令牌。
- en: 'Here is the `TokenUtility` code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `TokenUtility` 代码：
- en: '[PRE9]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code is self-explanatory: it generates the token. In this code,
    I put `JwtKey` as a constant (for demonstration purposes only).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是自解释的：它生成令牌。在这段代码中，我将 `JwtKey` 作为常量（仅用于演示目的）。
- en: In production, `JwtKey` should be kept in the environment variable (for security
    reasons) and can be easily accessible, as in, for example, `string jwtKey = Environment.GetEnvironmentVariable("JwtKey");`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，`JwtKey` 应该保存在环境变量中（出于安全原因），并且可以轻松访问，例如，`string jwtKey = Environment.GetEnvironmentVariable("JwtKey");`。
- en: I am not going to discuss the repository model and other such approaches as
    these are self-explanatory. You can extract the entire source code from the GitHub
    repository at [https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会讨论仓库模型和其他类似的方法，因为这些都很直观。您可以从GitHub仓库[https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core)中提取整个源代码。
- en: To enable token-based authentication, you need to make a few changes in the
    `startup.cs` file by inserting `Add app.UseAuthentication();` in the `Configure`
    method before `app.UseMvc();`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用基于令牌的认证，您需要在 `startup.cs` 文件中进行一些更改，在 `Configure` 方法中 `app.UseMvc();` 之前插入
    `Add app.UseAuthentication();`。
- en: 'In the `ConfigureService` method, add the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ConfigureService` 方法中添加以下代码：
- en: '[PRE10]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Build and run the project. Let''s do a simple test using the Swagger documentation,
    as shown in the following screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行项目。让我们使用Swagger文档进行简单的测试，如下截图所示：
- en: '![](img/3bc17fec-d7e0-4571-8c5f-c54336168189.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3bc17fec-d7e0-4571-8c5f-c54336168189.png)'
- en: 'This will give the token upon a valid request:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在有效请求后提供令牌：
- en: '![](img/c572606c-1b51-4994-9717-94586ec3144d.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c572606c-1b51-4994-9717-94586ec3144d.png)'
- en: We will make a complex authorization process to access resources depending on
    the roles and access levels of the users in the coming sections.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将进行复杂的授权过程，根据用户的角色和访问级别来访问资源。
- en: Other authentication methods
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他认证方法
- en: Apart from basic and token-based authentications, you can also go with other
    available authentication mechanisms (we will not discuss these in detail, as they
    are beyond the scope of this book). IdentityServer4 is one of the most famous
    authentication servers and enables authentication as a service, single sign-in/sign-out,
    and many more options (refer to [https://identityserver4.readthedocs.io/en/release/](https://identityserver4.readthedocs.io/en/release/) for
    more information).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本和基于令牌的认证之外，您还可以选择其他可用的认证机制（我们不会详细讨论这些，因为它们超出了本书的范围）。IdentityServer4是最著名的认证服务器之一，它使认证成为一种服务，单点登录/注销，以及更多选项（更多信息请参阅[https://identityserver4.readthedocs.io/en/release/](https://identityserver4.readthedocs.io/en/release/)）。
- en: Securing services using annotations
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用注解保护服务
- en: ASP.NET Core provides various ways to make secure application annotations (data
    annotations). This option is one of the ways in which we can secure our models
    for a web application. Data annotations provide a way to validate the inputs at
    the client end or the server end.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core提供了多种方式来创建安全的应用程序注解（数据注解）。这是我们为Web应用程序安全模型的一种方式。数据注解提供了一种在客户端或服务器端验证输入的方法。
- en: Validations
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: It is self-explanatory from the name *validations* that they are nothing but
    validators of user/client inputs. The user input can be validated at the client
    end or at the API end (server side). In RESTful services, you can validate the
    input using model validations with the help of data annotations.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从名称 *validations* 可以直观地看出，它们不过是用户/客户端输入的验证器。用户输入可以在客户端或API端（服务器端）进行验证。在RESTful服务中，您可以使用数据注解来验证输入。
- en: If the model is validated, this does not guarantee that data that comes with
    the request is safe.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型经过验证，这并不保证随请求而来的数据是安全的。
- en: In this section, we will rewrite our model used in the code example of the previous
    section.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重写上一节代码示例中使用的模型。
- en: 'Here is the modified `ProductViewModel` code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是修改后的 `ProductViewModel` 代码：
- en: '[PRE11]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Do not forget to include the `System.ComponentModel.DataAnnotations` namespace
    while using annotations.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在使用注解时包含`System.ComponentModel.DataAnnotations`命名空间。
- en: In the preceding code, I used a very simple annotation, the `required` attribute.
    This makes sure that our model has the required properties.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我使用了一个非常简单的注解，即`required`属性。这确保了我们的模型具有所需的属性。
- en: 'Here is our `Post` resource to add a new product item:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的`Post`资源，用于添加新的产品项：
- en: '[PRE12]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Compile the application and run it to test the impact of the data annotation
    on our model. This time, you can try this using PostMan ([https://getpostman.com/](https://getpostman.com/))
    to test the API.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 编译应用程序并运行它以测试数据注解对我们模型的影响。这次，您可以使用PostMan ([https://getpostman.com/](https://getpostman.com/))来测试API。
- en: 'The following screenshot shows the `addproduct POST` resource; the `/api/product/addproduct` API is
    used to save the product:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了`addproduct POST`资源；使用`/api/product/addproduct` API 保存产品：
- en: '![](img/082343cc-d355-40bb-bb86-3629f41e0058.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/082343cc-d355-40bb-bb86-3629f41e0058.png)'
- en: POST request using Swagger
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Swagger进行POST请求
- en: The preceding input is valid; you have supplied all the required values. Let’s
    remove `Price` and `ProductName`. You will see that there is no change while you
    execute the request, even without supplying the required values. Here, the validation
    failed. The reason why these data annotations did not affect the process is that
    you did not direct the system to validate the input. To validate the input, you
    should tell the system explicitly what you want to validate, for example, the
    model state. We will fix this with the help of filters in the coming section.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输入是有效的；您已提供了所有必填的值。让我们移除`Price`和`ProductName`。您会发现，即使在未提供必填值的情况下执行请求，也不会有任何变化。在这里，验证失败了。这些数据注解没有影响处理过程的原因是您没有指导系统验证输入。要验证输入，您应该明确告诉系统您想要验证的内容，例如模型状态。我们将通过下一节中的过滤器来解决这个问题。
- en: Securing context
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护上下文
- en: With the help of the `filter` attribute, you can implement security at the context
    level. In this section, we will rewrite our model and API resources to implement
    filters/attributes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`filter`属性，您可以在上下文级别实现安全性。在本节中，我们将重写我们的模型和API资源以实现过滤器/属性。
- en: In the previous section, we used the `Required` attribute with our `Product`
    model, and this did not work for us. In this section, we will fix the problem
    with the help of filters (for more information on filters, go to [https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters](https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters)).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了`Required`属性与我们的`Product`模型一起，但这并没有为我们解决问题。在本节中，我们将借助过滤器（有关过滤器的更多信息，请访问[https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters](https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters)）来解决这个问题。
- en: 'Lets add a custom filter that validates the input, detecting whether any of
    the required fields are missing. If they are, it will just throw an exception.
    You need to modify the previous code, changing the `Product` model to the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个自定义过滤器来验证输入，检测是否有任何必填字段缺失。如果有，它将直接抛出异常。您需要修改之前的代码，将`Product`模型更改为以下内容：
- en: '[PRE13]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Simply add `ErrorMessage` in the required `ProductName `field; the rest of the
    properties of the model remain unchanged.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地在必填的`ProductName`字段中添加`ErrorMessage`；模型的其余属性保持不变。
- en: 'Now, add a new `Filters `folder in the project from Solution Explorer. To do
    this, go through the steps we followed in the previous section on *SQL injections *and
    add a new class in this folder named `ValidateInputAttribute.cs` using the following
    code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在解决方案资源管理器中从项目中添加一个新的`Filters`文件夹。为此，请按照上一节中关于*SQL注入*的步骤进行操作，并在该文件夹中添加一个名为`ValidateInputAttribute.cs`的新类，使用以下代码：
- en: '[PRE14]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Apply this filter as an attribute to the `Post` resource to add the product.
    Our code should look like the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 将此过滤器作为属性应用到添加产品的`Post`资源上。我们的代码应如下所示：
- en: '[PRE15]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the application and enter the new product values without the product name,
    as shown in the following screenshot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并输入新的产品值，但不包括产品名称，如下面的截图所示：
- en: '![](img/cf7edee1-eb93-4c37-a418-d3be5841ce85.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf7edee1-eb93-4c37-a418-d3be5841ce85.png)'
- en: Process the request and look at the response from the server, shown in the preceding
    screenshot. The request will not be processed, and a response will come from the
    server notifying you of a bad request with the relevant error message.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 处理请求并查看服务器返回的响应，如前面的截图所示。请求将不会被处理，服务器将返回一个通知您有错误请求的响应，并包含相关错误信息。
- en: 'The following screenshot shows the Bad Request response (HttpStatus Code 400):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了错误的请求响应（HttpStatus Code 400）：
- en: '![](img/2562185d-2e4d-4ffd-ba0e-c17d820d147d.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2562185d-2e4d-4ffd-ba0e-c17d820d147d.png)'
- en: 'To make any filter available anywhere, you should add the following code in
    the `startup.cs` configure method, like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要使任何过滤器在任何地方都可用，您应该在`startup.cs`配置方法中添加以下代码，如下所示：
- en: '[PRE16]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, let's come back to our token-based authorization method. In the previous
    application, you saw how we can build an API to validate the credentials. Now,
    let's make a policy to restrict a resource. A detailed explanation of this topic
    is beyond the scope of this book; I suggest that you refer to the official documentation
    at [https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies](https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的基于令牌的授权方法。在前一个应用程序中，您看到了我们如何构建一个API来验证凭证。现在，让我们制定一个策略来限制资源。对这个主题的详细解释超出了本书的范围；我建议您参考[https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies](https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies)的官方文档。
- en: Data encryption and storing sensitive data
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据加密和存储敏感数据
- en: Data security is always a big concern in any application, and it is a high priority
    while writing or designing applications. You can use any hashing algorithm to
    protect the data by encryption and decryption, but it would lead to a performance
    hit. ASP.NET Core provides a way to protect data with the help of the ASP.NET
    DataProtection ([https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/))
    NuGet package.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 数据安全在任何应用程序中都是一个重大关注点，在编写或设计应用程序时，它是一个高优先级。您可以使用任何哈希算法通过加密和解密来保护数据，但这会导致性能下降。ASP.NET
    Core提供了一个使用ASP.NET DataProtection ([https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/))
    NuGet包来保护数据的方法。
- en: A complete explanation of this topic is beyond the scope of this book. You can
    refer to [https://docs.microsoft.com/en-us/aspnet/core/security/data-protection/](https://docs.microsoft.com/en-us/aspnet/core/security/data-protection/)
    for further information.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个主题的完整解释超出了本书的范围。您可以参考[https://docs.microsoft.com/en-us/aspnet/core/security/data-protection/](https://docs.microsoft.com/en-us/aspnet/core/security/data-protection/)以获取更多信息。
- en: Sensitive data
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敏感数据
- en: 'While you work with APIs, you have to store sensitive data: the API key, secret
    key, username, password, and so on. The following are a few recommendations for
    you to take into consideration while you’re working with this data in the ASP.NET
    Core application:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当您与API一起工作时，您必须存储敏感数据：API密钥、秘密密钥、用户名、密码等等。以下是在您在ASP.NET Core应用程序中处理这些数据时的一些建议：
- en: You should separate the configuration files from code.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该将配置文件与代码分开。
- en: You should avoid storing this data in plain text files.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该避免将此数据存储在纯文本文件中。
- en: You can use a separate class file where you can store these data values in the
    form of constants.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在一个单独的类文件中存储这些数据值，以常量的形式。
- en: You should store confidential data in environment variables. For more information,
    refer to [http://www.dowdandassociates.com/blog/content/howto-set-an-environment-variable-in-windows-command-line-and-registry/](http://www.dowdandassociates.com/blog/content/howto-set-an-environment-variable-in-windows-command-line-and-registry/).
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该将机密数据存储在环境变量中。更多信息，请参考[http://www.dowdandassociates.com/blog/content/howto-set-an-environment-variable-in-windows-command-line-and-registry/](http://www.dowdandassociates.com/blog/content/howto-set-an-environment-variable-in-windows-command-line-and-registry/)。
- en: You can also use a secret manager to store your confidential data ([https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?tabs=visual-studio#secret-manager](https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?tabs=visual-studio#secret-manager)).
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以使用秘密管理器来存储您的机密数据 ([https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?tabs=visual-studio#secret-manager](https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?tabs=visual-studio#secret-manager))。
- en: Sensitive data varies from application to application and requirement to requirement.
    For more details, you can refer to [https://stormpath.com/blog/store-protect-sensitive-data-dotnet-core](https://stormpath.com/blog/store-protect-sensitive-data-dotnet-core).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 敏感数据因应用和需求而异。更多详情，您可以参考[https://stormpath.com/blog/store-protect-sensitive-data-dotnet-core](https://stormpath.com/blog/store-protect-sensitive-data-dotnet-core)。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have discussed data security, following the OWASP security
    standard, and looking at JWT authentication. We also discussed custom filters
    and input validations using a code example. Data protection is always a high priority
    for any web application. We discussed data protection methods when storing sensitive
    data in an ASP.NET Core application.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了数据安全，遵循OWASP安全标准，并探讨了JWT身份验证。我们还通过代码示例讨论了自定义过滤器和输入验证。数据保护对于任何Web应用来说始终是最高优先级。我们讨论了在ASP.NET
    Core应用程序中存储敏感数据时的数据保护方法。
- en: In the next chapter, we will discuss the performance of web services by looking
    at the scale-in, scale-out methodology and the implementation of a few caching
    mechanisms.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过观察缩放入和缩放出方法以及一些缓存机制的实现来讨论Web服务的性能。
