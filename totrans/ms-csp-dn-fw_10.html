<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Design Patterns</h1></div></div></div><p>In this chapter, we're not focusing on the architecture and tools required to manage a solution's life cycle (sometimes called the development ecosystem) but on the quality of the code and its structures in terms of efficacy, precision, and maintainability.</p><p>We'll start with the SOLID principles, proposed by Robert Martin, which are gaining more and more recognition and that we can see implemented in different frameworks and technologies.</p><p>A basic application will be used to illustrate the distinct principles, and as the requirements evolve, we'll apply different principles and patterns to solve the problems.</p><p>Finally, we'll go through the eight most used patterns of the Gang of Four (according to statistics), revising its definitions and purpose to finish with the current list of available patterns created and published after the GoF group published their book.</p><p>Therefore, the topics covered in this chapter are as follows:</p><div><ul class="itemizedlist"><li class="listitem">SOLID principles</li><li class="listitem">Open/Closed principle</li><li class="listitem">Liskov Substitution principle</li><li class="listitem">Interface Segregation principle</li><li class="listitem">Dependency Inversion principle</li><li class="listitem">Design patterns</li><li class="listitem">Other software patterns</li><li class="listitem">Other patterns</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec49"/>The origins</h1></div></div></div><p>With time, programming techniques<a id="id807" class="indexterm"/> have evolved, at the same pace as languages and hardware; so, from the initial confusion in the early 60s, when no foundations were established and few models were considered, the 70s marked the start of the adoption of other paradigms, such as procedural programming, and later on, <a id="id808" class="indexterm"/>
<strong>object oriented programming</strong> (<strong>OOP</strong>).</p><p>Ole-Johan Dahl and Kristen Nygaard originally proposed OOP with the Simula language, when they both worked at the Norwegian Computing Center. They were given the Turing Award for these achievements, among other recognitions.</p><p>A few years later (around 1979), Bjarne <a id="id809" class="indexterm"/>Stroustrup created C with Classes, the prototype of what C++ today is because he found valuable aspects in Simula, but he thought that it was too slow for practical purposes. C++ originally had imperative features and object-oriented and generic ones, while also providing the ability to program for low-level memory manipulation.</p><p>It was the first OOP language that became universal in adoption (though limited in number), due to its many virtues, but for many people, it was not adequate for business applications.</p><p>Later on, the appearance of Java and the .NET platforms proposed a much easier and affordable solution for many programmers while still moving within the ordered space that object oriented programming languages promote.</p><p>So, OOP was adopted, and up until this date, no other important programming paradigm has substituted these ideas. Surely, there are other approaches, such as functional programming, but even the most significant representative of this tendency, JavaScript, is becoming more object-oriented in the latest versions (ECMAScript 2015).</p><p>With the accelerated expansion of software solutions, many lessons were learned about how to correctly afford common software problems, and that will be our starting point.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec50"/>The SOLID principles</h1></div></div></div><p>Some <a id="id810" class="indexterm"/>programming guidelines have a wide, general-purpose intention, while some are designed to fix certain specific problems. Thus, before talking about the specific problems, we should review those features that can be applied in many different scenarios and solutions. I mean those principles that should be taken into consideration beyond the type of solution or specific platform to program for.</p><p>Moreover, this is where the SOLID principles (and other related problems) come into play. In 2001, Robert Martin published a foundational article on the subject (<a class="ulink" href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod</a>), in which he picked up a set of principles and guidelines that, in his own words, <em>focus very tightly on dependency management</em>, its inconveniences, and how to solve them.</p><p>To explain this further in his words, <em>poor dependency management leads to code that is hard to change, fragile, and non-reusable</em>. Reusability is one the main principles of OOP, along with maintainability (the capacity to change as the project grows: one of the purposes of inheritance).</p><p>Overall, there are 11 principles to consider, but they can be divided into three areas:</p><div><ul class="itemizedlist"><li class="listitem">The SOLID principles, which deal with class design</li><li class="listitem">The rest of the principles, which are about packages: three of them are about package cohesion and the other three study couplings between packages and how to evaluate the package structure</li></ul></div><p>We're going to start with the SOLID principles, which by extension not only affect the class design, but other architectures as well.</p><p>For instance, the application of <a id="id811" class="indexterm"/>some of these ideas paved the way for some of the most important modifications in the building of HTML5.</p><p>The application of the <a id="id812" class="indexterm"/>
<strong>SRP</strong> (<strong>Single Responsibility principle</strong>), from which the more general design principle of Separation of Concerns is derived, only highlighted the need to totally separate presentation (CSS) from content (HTML) and the subsequent deprecation of some tags (<code class="literal">&lt;cite&gt;</code>, <code class="literal">&lt;small&gt;</code>, <code class="literal">&lt;font&gt;</code>, and so on).</p><div><h3 class="title"><a id="note26"/>Note</h3><p>Some of the aforementioned tags are deprecated and not recommended as presentation features, but they are kept in the standard because of their semantic value instead, such as <code class="literal">&lt;b&gt;</code>, <code class="literal">&lt;i&gt;</code>, &lt;<code class="literal">small&gt;</code>, and so on.</p></div><p>This applies to some popular frameworks, such as AngularJS, which was designed not only with the Single Responsibility principle in mind, but also based on the Dependency Inversion principle (the <strong>D</strong> in SOLID).</p><p>The next graphic resumes the five principles' initials and its correspondences:</p><div><img src="img/image00629.jpeg" alt="The SOLID principles"/></div><p style="clear:both; height: 1em;"> </p><p>The explanation of every letter in the acronym as expressed in Wikipedia is as follows:</p><div><ul class="itemizedlist"><li class="listitem"><strong>S - Single Responsibility Principle</strong>: A class should have only a single responsibility (that is, only one potential change in the software's specification should be able to affect the specification of the class). Martin states that this <a id="id813" class="indexterm"/>principle is based on the principle of cohesion, previously defined by Tom de Marco in a book named <em>Structured Analysis and Systems Specification</em> and by Meilir Page-Jones in his work <em>The Practical Guide to Structured Systems Design</em>.</li><li class="listitem"><strong>O - Open/Closed Principle</strong>: Software entities should be open for extension, but closed for <a id="id814" class="indexterm"/>modification. Bertrand Meyer was the first to propose this principle.</li><li class="listitem"><strong>L - Liskov Substitution principle</strong>: <em>Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program</em>. Barbara <a id="id815" class="indexterm"/>Liskov first stated this.</li><li class="listitem"><strong>I - Interface Segregation principle</strong>: <em>Many client-specific interfaces are better than one general-purpose interface</em>. Robert C. Martin was the first to use and formulate <a id="id816" class="indexterm"/>this principle.</li><li class="listitem"><strong>D - Dependency inversion principle</strong>: <em>We should 'Depend on Abstractions'. Do not depend upon concretions</em>. This <a id="id817" class="indexterm"/>too is an idea developed by Robert C. Martin.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec103"/>Single Responsibility principle</h2></div></div></div><p>For<a id="id818" class="indexterm"/> <strong>Single Responsibility principle</strong> (<strong>SRP</strong>), the basic <a id="id819" class="indexterm"/>statement, in this case, is <em>there should never be more than one reason for a class to change</em>. In this context, responsibility is defined as <em>a reason for change</em>. If, under any circumstance, more than one reason comes up to change the class, the class' responsibilities are multiple and should be redefined.</p><p>This is, indeed, one of the most difficult principles to apply properly because as Martin says, <em>conjoining responsibilities is something that we do naturally</em>.</p><p>In his book <em>Agile Principles, Patterns, and Practices in C#</em> , Martin proposes a canonical example to show the differences, as follows:</p><div><pre class="programlisting">interface Modem
{
  public void dial(String phoneNumber);
  public void hangup();
  public void send(char c);
  public char recv();
}</pre></div><p>Given the previous interface, any class implementing this interface has two responsibilities: the connection management and the communication itself. Such responsibilities can be used from the different parts of an application, which, in turn, might change as well.</p><p>Instead of this code structure, Martin proposes a different diagram:</p><div><img src="img/image00630.jpeg" alt="Single Responsibility principle"/></div><p style="clear:both; height: 1em;"> </p><p>However, one <a id="id820" class="indexterm"/>wonders, should these two responsibilities be <a id="id821" class="indexterm"/>separated? It only depends on application changes. To be precise, the key here is to know whether changes in the application affect the signature of connection functions. If they do, we should separate both; otherwise, there's no need for separation because we would then create needless complexity.</p><p>So, overall, reason to change is the key, but keep in mind that a reason to change is applicable only if changes occur.</p><p>In other situations, there might be reasons to keep distinct responsibilities together as long as they are closely related to the business definitions or have to do with hardware requirements of the operating system.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec70"/>An example</h3></div></div></div><p>Let's imagine we need to <a id="id822" class="indexterm"/>create a simple Windows Forms application (we pick this model for simplicity in order to avoid unnecessary XAML), which has the ability to offer the user a few cars (actually, just three different brands), and the application should show maximum speed and a photo for the selected car.</p><p>Later on, we can derive from the class hierarchy to create different versions that are able to cover distinct characteristics, specific of business models, or legal conditions, among others.</p><p>So, the first step is to represent the user interface that will cover the requirements, mentioned previously, according to the indications. I came up with a very simple Windows form, as shown in the following screenshot:</p><div><img src="img/image00631.jpeg" alt="An example"/></div><p style="clear:both; height: 1em;"> </p><p>We're dealing <a id="id823" class="indexterm"/>with three (or more) brands, and optionally, we have a place to display the maximum speed value. We also included a button for acceleration so that we can verify that the car never goes faster than its maximum speed limit. Finally, the photo will remind us about the car we're dealing with.</p><p>So, we plan to define a class named <code class="literal">SportCar</code>, in which we will abstract the required elements to be managed from the UI, and to make things clearer, we start by creating an interface, <code class="literal">ISportCar</code>, which states the requisites.</p><p>We can use the Class Diagram tool to create an interface that defines four properties and one method: <code class="literal">Brand</code>, <code class="literal">MaxSpeed</code>, <code class="literal">Photo</code>, <code class="literal">Speed</code>, and <code class="literal">Accelerate</code> (which will change the Speed property from the user interface). So, the final code is as follows:</p><div><pre class="programlisting">interfaceISportCar
{
  bool Accelerate();
  System.Drawing.Bitmap Photo { get; }
  string Brand { get; }
  int Speed { get; }
  int MaxSpeed { get; }
}</pre></div><p>Using the Class Diagram tool, we can create a <code class="literal">SportCar</code> class and link it to the interface so it declares the dependency. Later on, with the basic class declaration created by the IDE, we can move on to the source code and indicate the <code class="literal">Implement Interface</code> option to have the class with the interface implemented for us.</p><p>A few touches for the sake of simplicity can have us end up with the following initial code:</p><div><pre class="programlisting">public class SportsCar : ISportCar
{
  public string Brand { get; }
  public int MaxSpeed { get; }
  public Bitmap Photo { get; }
  public int Speed { get;privateset; }
  public virtual bool Accelerate()
  {
    throw new NotImplementedException();
  }
}</pre></div><p>Observe that all <a id="id824" class="indexterm"/>properties are read-only, since all except one should be established at creation time, and the only method that changes (<code class="literal">Speed</code>) must only vary using the <code class="literal">Accelerate</code> method (declared as virtual in order to allow further inheritance). This method returns a Boolean value to indicate the limit conditions: <code class="literal">MaxSpeed</code> exceeded. This is why it's declared a private set.</p><p>On the graphic side, our (now modified) diagram should reveal dependencies and members of both code fragments:</p><div><img src="img/image00632.jpeg" alt="An example"/></div><p style="clear:both; height: 1em;"> </p><p>So, at first, the class has the sole responsibility of managing the state of a <code class="literal">SportCar</code> instance of the class. This implies business logic: a Ferrari looks like a Ferrari, not like a BMW, and each one has its own properties (<code class="literal">MaxSpeed</code> and <code class="literal">Speed</code> in this case). Nothing related to the user interface or storing state, among other things, should be considered here.</p><p>Next, we need a <a id="id825" class="indexterm"/>constructor that enforces some of the principles mentioned earlier. It should resolve all the immutable properties; so, when the class is created, they are assigned the proper value.</p><p>Here, we face another problem: how does our class know about the possible brands available? There are several approaches here, but a simple one would be to declare an internal array defining the allowed brands and have the constructor check whether the brand suggested in the construction is one of the brands our class can manage.</p><p>Note that I have included three simple pictures corresponding to the three brands inside the application's resource file. This is a dependency. If a fourth brand needs to be considered, we should change the constructor to supply this additional functionality, but for the sake of simplicity, let's assume that no changes in the business logic of the number of cars will happen for the moment.</p><p>With all this in mind, we will add the following code to our class:</p><div><pre class="programlisting">string[] availableBrands = new string[] { "Ferrari", "Mercedes", "BMW" };
public SportsCar(string brand)
{
  if (!availableBrands.Contains(brand)) return;
  else Brand = brand;
  switch (brand)
  {
    case "Ferrari":
      MaxSpeed = 350;
      Photo = Properties.Resources.Ferrari;
    break;
    case "Mercedes":
      MaxSpeed = 300;
      Photo = Properties.Resources.Mercedes;
    break;
    case "BMW":
      MaxSpeed = 270;
      Photo = Properties.Resources.BMW;
    break;
  }
}</pre></div><p>With this, we have an operational (although incomplete) version of our class. Now, in the user interface, we should declare a variable of the <code class="literal">SportCar</code> class and instantiate it every time the user changes the brand using the <code class="literal">cboPickUpCar</code> ComboBox.</p><p>Actually, we also<a id="id826" class="indexterm"/> need to update the UI once the car is instantiated so that it reflects the properties of the car (its state). And it should be consistent with the properties of every brand available.</p><p>This simple code does the trick:</p><div><pre class="programlisting">SportsCar theCar;
private void cboPickUpCar_SelectedIndexChanged(object sender, EventArgs e)
{
  theCar = new SportsCar(cboPickUpCar.Text);
  // refresh car's properties
  txtMaxSpeed.Text = theCar.MaxSpeed.ToString();
  pbPhoto.Image = theCar.Photo;
}</pre></div><p>Now, we have a first version that works properly, but our class needs to have the ability to change the <code class="literal">Speed</code> property. So we add some code to the <code class="literal">Accelerate</code> method:</p><div><pre class="programlisting">public virtual bool Accelerate()
{
  bool speedExceeded = Speed + SpeedIncr &gt; MaxSpeed;
  Speed = (speedExceeded) ? Speed: Speed + SpeedIncr;
  return speedExceeded;
}</pre></div><p>And that's it. We should now reflect these changes in the UI, which is pretty straightforward:</p><div><pre class="programlisting">private void btnAccelerate_Click(object sender, EventArgs e)
{
  theCar.Accelerate();
  updateUI();
}
private void updateUI()
{
  txtSpeed.Text = theCar.Speed.ToString();
}</pre></div><p>The final result should work as expected (refer to the screenshot). You can pick from the different brands available, and every new selection provokes a new instantiation of the <code class="literal">SportCar</code> class.</p><p>We can see all the properties at runtime, and the only mutable property (<code class="literal">Speed</code>) is changed exclusively from the <code class="literal">Accelerate</code> method, which now has a unique responsibility.</p><p>However, since<a id="id827" class="indexterm"/> this responsibility implies business logic, it also checks whether an attempt to exceed the allowed speed has taken place and avoids a case inspecting the possible value of an increase in the speed (we have assumed a constant value for that speed in the initial declarations of the class). You should see an output like the following:</p><div><img src="img/image00633.jpeg" alt="An example"/></div><p style="clear:both; height: 1em;"> </p><p>Now, let's consider some possible situations that arise when changes are proposed. This is when the next<a id="id828" class="indexterm"/> principle comes into action, and it deals with how to manage requisites when new conditions arise.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec51"/>Open/Closed principle</h1></div></div></div><p>We can detect the need to use this principle when a change in the module outcomes in a waterfall of changes that affect dependent modules. The design is said to be too inflexible.</p><p>The <strong>Open/Closed principle</strong> (<strong>OCP</strong>)<a id="id829" class="indexterm"/> advises us that we should <a id="id830" class="indexterm"/>refactor the application in a manner that future changes don't provoke further modifications.</p><p>The form to apply this principle correctly would be by extending the functionality with new code (for instance, using polymorphism) and never changing the old code, which is working already. We can find several strategies to achieve this goal.</p><p>Observe that <em>closed for modification</em> is especially meaningful when you have distinct, separate modules (DLLs, EXEs, and so on) that depend on the module to be changed.</p><p>On the other hand, using extension methods or polymorphic techniques allows us to perform changes in code without affecting the rest. Think, for example, about the extension methods available in the C# language since version 3.0. You can consider extension methods a special type of static method, with the difference that they are called as if they were instance methods of the extended type. You find a typical example in the LINQ standard query operators because they add a query functionality to the existing types, such as <code class="literal">System.Collections.IEnumerable</code> or <code class="literal">System.Collections.Generic.IEnumerable&lt;T&gt;</code>.</p><p>The classical and simplest example of this pattern is the client/server cohesion that is largely seen in development for many years. It is preferable that clients depend on servers' abstractions, not on their concretions.</p><p>This can be achieved with interfaces. Servers can implement a client interface that clients will use to connect to them. In this manner, servers can change without affecting the way clients use them (refer to the next diagram):</p><div><img src="img/image00634.jpeg" alt="Open/Closed principle"/></div><p style="clear:both; height: 1em;"> </p><p>Any subtype of client interface will be free to implement the interface in the way it deems more appropriate and as long as it doesn't break other clients' access.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec104"/>Back to our sample</h2></div></div></div><p>Now, let's imagine that the<a id="id831" class="indexterm"/> Mercedes corporation announces a change in their models, which allows you to receive a notification when the user is in danger due to the car approaching its speed limit.</p><p>On first view, some would think about modifying the <code class="literal">Accelerate</code> method to include an event that can communicate this circumstance to whatever user interface is using it.</p><p>However, that would violate the OCP, since the current version is already working properly. This is one case where polymorphism is useful.</p><p>We can create another overload of the <code class="literal">Accelerate</code> method to allow this. It could receive an argument (the brand) that identifies whether the call is being made from a Mercedes and launch an event call, so any client could act accordingly.</p><p>I'll duplicate the project in a new one with another name so that you always have distinct versions depending on the case (<code class="literal">Demo2-OCP</code>):</p><div><pre class="programlisting">public virtual bool Accelerate(bool advise)
{
  bool speedExceeded = Speed + SpeedIncr &gt; MaxSpeed;
  Speed = (speedExceeded) ? Speed : Speed + SpeedIncr;
  if (speedExceeded &amp;&amp; advise &amp;&amp; (SpeedLimit!= null))
  {
    SpeedLimit(this, newEventArgs());
  }
  return speedExceeded;
}
public event EventHandler SpeedLimit;</pre></div><p>As you can see, we declare a new event member (<code class="literal">SpeedLimit</code>) and invoke the event if the Boolean value is <code class="literal">true</code>.</p><p>Since events are notifications and not direct function calls to the user interface, the UI is free to subscribe to the events required.</p><p>In the user interface, we should subscribe to the <code class="literal">SpeedLimit</code> event and modify our <code class="literal">btnAccelerate_Click</code> event handler in this manner to handle this situation:</p><div><pre class="programlisting">private void btnAccelerate_Click(object sender, EventArgs e)
{
  if (theCar.Brand == "Mercedes")
  {
    theCar.Accelerate(true);
  }
  else { theCar.Accelerate(); }
  updateUI();
}</pre></div><p>In the instantiation process, the subscription is quite simple, and we can also have the IDE to create the <code class="literal">SpeedLimit</code> event handler for us:</p><div><pre class="programlisting">theCar.SpeedLimit += TheCar_SpeedLimit;
private void TheCar_SpeedLimit(object sender, EventArgs e)
{
  MessageBox.Show("Speed limit attempted");
}</pre></div><p>Observe that I'm <a id="id832" class="indexterm"/>simplifying the code as much as possible because the interest here is showing coding practices that align with the SOLID principles.</p><p>When we execute this code, we can observe that—just for the Mercedes—if we try to pass the speed limit, a MessageBox popup indicating the circumstance appears (refer to the screenshot). The other brands are not affected:</p><div><img src="img/image00635.jpeg" alt="Back to our sample"/></div><p style="clear:both; height: 1em;"> </p><p>However, as we <a id="id833" class="indexterm"/>mentioned, the .NET framework also uses these patterns and others in different namespaces, and that also includes the important LSP principle, as we'll see next.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec52"/>Liskov Substitution principle</h1></div></div></div><p>Let's<a id="id834" class="indexterm"/> remember this definition: subtypes must be substitutable for<a id="id835" class="indexterm"/> their base types. This means that this should happen without breaking the execution or losing any other kind of functionality.</p><p>You'll notice that this idea lies behind the basic principles of inheritance in the OOP programming paradigm.</p><p>If you have a method that requires an argument of the <code class="literal">Person</code> type (let's put it that way), you can pass an instance of another class (<code class="literal">Employee</code>, <code class="literal">Provider</code>, and so on) as long as these instances inherit from <code class="literal">Person</code>.</p><p>This is one of the main advantages of well-designed OOP languages, and the most popular and accepted languages support this characteristic.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec105"/>Back to the code again</h2></div></div></div><p>Let's take a look at<a id="id836" class="indexterm"/> the support inside our sample, where a new requisite arises. Actually, our demo simply calls the subscribers of Mercedes cars and notifies them that a <code class="literal">SpeedLimit</code> event took place.</p><p>However, what if we need to know the moment in time in which that circumstance happened and the resulting speed that we tried to obtain? That is, what if we need more information about the event?</p><p>In the current state, the <code class="literal">SpeedLimit</code> event does not pass any information to the caller beyond the sender (which refers to the origin of such call). But we can use the implementation of the Liskov Substitution principle inherent to the C# language in order to pass a derived class of <code class="literal">EventArgs</code> containing the required information, and the context should manage it just as well.</p><p>So, the first step is to inherit from <code class="literal">EventArgs</code> and create a new class capable of holding the solicited information:</p><div><pre class="programlisting">public class SpeedLimitData : EventArgs
{
  public DateTime moment { get; set; }
  public int resultingSpeed { get; set; }
}</pre></div><p>And we need to change the event invocation so that it recovers the necessary information before calling the event. In this way, the new version of <code class="literal">Accelerate</code>—which is still totally compatible with the previous one—will be as follows:</p><div><pre class="programlisting">public virtual bool Accelerate(bool advise)
{
  bool speedExceeded = Speed + SpeedIncr &gt; MaxSpeed;
  Speed = (speedExceeded) ? Speed : Speed + SpeedIncr;
  if (speedExceeded &amp;&amp; advise &amp;&amp; (SpeedLimit!= null))
  {
    SpeedLimitData data = newSpeedLimitData()
    {
      moment = DateTime.Now,
      resultingSpeed = Speed + SpeedIncr
    };
    SpeedLimit(this, data);
  }
  return speedExceeded;
}</pre></div><p>So, when we invoke <code class="literal">SpeedLimit</code>, we are sending business logic information to any subscriber, either from the UI or any other. So, we can pass a derived instance of the <code class="literal">EventArgs</code> class to the event without provoking any complain in the UI's editor (or the compiler).</p><p>The final step is to <a id="id837" class="indexterm"/>change the user interface to recover the data passed to it and present it in a modified version of the previous <code class="literal">MessageBox</code> call:</p><div><pre class="programlisting">private void TheCar_SpeedLimit(object sender, EventArgs e)
{
  var eventData = e as SpeedLimitData;
  MessageBox.Show("Attempt to obtain " + eventData.resultingSpeed +
  " Miles//hr at: " + eventData.moment.ToLongTimeString(), "Warning",
  MessageBoxButtons.OK, MessageBoxIcon.Warning);
}</pre></div><p>This time, when we select a Mercedes car and try to surpass the limit, we get a much more informative report in <code class="literal">MessageBox</code>:</p><div><img src="img/image00636.jpeg" alt="Back to the code again"/></div><p style="clear:both; height: 1em;"> </p><p>Thanks to the Liskov Substitution principle support, we were able to add behavior and information with minimum effort, knowing that the UI receiving the information would perform a simple casting to convert the basic <code class="literal">EventArgs</code> declaration into the extended <code class="literal">SpeedLimitData</code> event that we really passed to the event handler.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec106"/>Other implementations of LSP in .NET (Generics)</h2></div></div></div><p>This is not the <a id="id838" class="indexterm"/>only implementation<a id="id839" class="indexterm"/> of the LSP principle that we find inside .NET, since different areas of the framework have grown using this conception. For instance, generics are one of the benefits of LSP.</p><p>In our sample, we can create a generic version of the event in order to manage extra information very easily. Imagine that besides the private measures taken in the case of Mercedes, all the brands now want to support messaging when the legal speed limit is reached.</p><p>This affects any instance of <code class="literal">SpeedCar</code>. It's not mandatory (it doesn't force you to stop increasing the speed, but it shows you another warning about this condition).</p><p>Since it has an impact on all brands, we can add a new event to the <code class="literal">SpeedCar</code> class, only this time, we define it as generic in order to support the extra information:</p><div><pre class="programlisting">public eventEventHandler&lt;int&gt; LegalLimitCondition;</pre></div><p>Let's assume that the value for Speed Legal Limit is the maximum allowed in some states of the US (80 mi/h). We'll define a new constant, <code class="literal">MaxLegal</code>, with this value:</p><div><pre class="programlisting">const int MaxLegal = 80;</pre></div><p>Now, to reflect this new condition, we should modify our <code class="literal">Accelerate</code> methods to include a previous call in case the car exceeds the legal value, indicating the amount exceeded:</p><div><pre class="programlisting">public virtual bool Accelerate()
{
  bool speedExceeded = Speed + SpeedIncr &gt; MaxSpeed;
  bool legalExceeded = Speed + SpeedIncr &gt;MaxLegal;
  if (legalExceeded &amp;&amp; LegalLimitCondition != null)
  {
    LegalLimitCondition(this, (Speed + SpeedIncr) - MaxLegal);
  }
  Speed = (speedExceeded) ? Speed: Speed + SpeedIncr;
  return speedExceeded;
}
public virtual bool Accelerate(bool advise)
{
  bool speedExceeded = Speed + SpeedIncr &gt; MaxSpeed;
  bool legalExceeded = Speed + SpeedIncr &gt; MaxLegal;
  if (legalExceeded &amp;&amp; LegalLimitCondition != null)
  {
    LegalLimitCondition(this, (Speed + SpeedIncr) - MaxLegal);
  }
  if (speedExceeded &amp;&amp; advise &amp;&amp; (SpeedLimit!= null))
  {
    SpeedLimitData data = newSpeedLimitData()
    {
      moment = DateTime.Now,
      resultingSpeed = Speed + SpeedIncr
    };
    SpeedLimit(this, data);
  }
  Speed = (speedExceeded) ? Speed : Speed + SpeedIncr;
  return speedExceeded;
}</pre></div><p>That's all the work you need to do with the <code class="literal">SpeedCar</code> class. The rest will be an update to the user interface; so, for any car, when the condition launches, another <code class="literal">MessageBox</code> call warns the user about the condition.</p><p>In this way, we now register every car for the <code class="literal">LegalLimitCondition</code> event and let the IDE generate the associated event handler for us:</p><div><pre class="programlisting">theCar.LegalLimitCondition += TheCar_LegalLimitCondition;
private void TheCar_LegalLimitCondition(object sender, int e)
{
  updateUI(e);
}</pre></div><p>This time, we pass <a id="id840" class="indexterm"/>the argument <a id="id841" class="indexterm"/>to a revised version of the <code class="literal">UpdateUI</code> method, which now admits an optional argument, indicating the speed excess:</p><div><pre class="programlisting">private void updateUI(int speedExcess = 0)
{
  txtSpeed.Text = theCar.Speed.ToString();
  if (speedExcess &gt; 0)
  {
    MessageBox.Show( "Legal limit exceeded by " + speedExcess + " mi/h");
  }
}</pre></div><p>And that's it. Now, different event mechanisms inform the user interface about the business logic conditions via notifications with a custom event system.</p><p>Note that the sequence in calling events is important and the final assignment of the <code class="literal">Speed</code> value is performed at the end of the <code class="literal">Accelerate</code> method when all previous conditions have been processed.</p><p>Events are flexible enough as to be defined in a way that allows us to pass our own information via classic definitions, or—with the participation of generics—we can simply define a generic event handler that holds information of any kind. All these techniques foster the implementation of good practices, not just the SOLID principles.</p><p>Changes in the UI should not affect the <code class="literal">SportClass</code> definition; although its usage of the business logic differs, we keep the changes in the class to a minimum.</p><p>At runtime, we will <a id="id842" class="indexterm"/>now be warned<a id="id843" class="indexterm"/> about any excess in velocity over the <code class="literal">MaxLegal</code> constant previously established (refer to the screenshot):</p><div><img src="img/image00637.jpeg" alt="Other implementations of LSP in .NET (Generics)"/></div><p style="clear:both; height: 1em;"> </p><p>Let's review the other <a id="id844" class="indexterm"/>two principles remaining in the SOLID package now: <strong>Interface Segregation principle</strong> (<strong>ISP</strong>) <a id="id845" class="indexterm"/>and <strong>Dependency Inversion principle</strong> (<strong>DIP</strong>).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec53"/>Interface Segregation principle</h1></div></div></div><p>As <a id="id846" class="indexterm"/>Martin states, this principle <em>deals with the inconveniences of "fat" interfaces</em>. And the problem arises when the interfaces of the class can be logically <a id="id847" class="indexterm"/>fragmented into distinct groups or methods.</p><p>In this case, if there is more than a client of our application, chances are that some clients are connected to a functionality they never use.</p><p>Back to our demo again: the mere review of the definition reveals that our system has some defects from the point of view of this principle.</p><p>First, we're implementing a method that is only used by a type of a <code class="literal">SportCar</code> client: the Mercedes. The other brands don't use it. In case a new condition arises for a different brand, new options should be created.</p><p>So, this marks a difference in the way in which we can categorize our cars: those who notify the user interface about <code class="literal">SpeedLimit</code> and those who don't. We should start by redefining our <code class="literal">ISportCar</code> interface to cover only those aspects that are commonly used by any client. This <a id="id848" class="indexterm"/>includes the <code class="literal">LegalLimitCondition</code> event but not the <code class="literal">SpeedLimit</code> event.</p><p>So, we will have this implementation:</p><div><pre class="programlisting">interface ISportCar
{
  bool Accelerate();
  System.Drawing.Bitmap Photo { get; }
  string Brand { get; }
  int Speed { get; }
  int MaxSpeed { get; }
  eventEventHandler&lt;int&gt; LegalLimitCondition;
}</pre></div><p>The new version of <code class="literal">SportCar</code> would implement only an <code class="literal">Accelerate</code> overload of the method, launching the <code class="literal">LegalLimitCondition</code> event but not the <code class="literal">SpeedLimit</code> event, which is only suitable for the Mercedes:</p><div><pre class="programlisting">public virtualbool Accelerate()
{
  bool speedExceeded = Speed + SpeedIncr &gt; MaxSpeed;
  bool legalExceeded = Speed + SpeedIncr &gt; MaxLegal;
  if (legalExceeded &amp;&amp; LegalLimitCondition != null)
  {
    LegalLimitCondition(this, (Speed + SpeedIncr) - MaxLegal);
  }
  Speed = (speedExceeded) ? Speed: Speed + SpeedIncr;
  return speedExceeded;
}</pre></div><p>Note that we still <a id="id849" class="indexterm"/>control <code class="literal">MaxSpeed</code>, only that we don't take any action but avoid the speed beyond the maximum value.</p><p>This separation suggested by this principle also applies to the first principle, since now, the responsibilities of this class are focused on the group of clients that use this implementation.</p><p>On the other hand, we will create a new class <code class="literal">SportsCarWithN</code> (a sports car with notifications) that inherits from <code class="literal">SportsCar</code> but adds the functionality required by the Mercedes (or any other brand that would decide to do this in the future):</p><div><pre class="programlisting">public class SportsCarWithN : SportsCar, ISportCar
{
  public SportsCarWithN(string brand): base(brand) {}
  public new bool Accelerate()
  {
    base.Accelerate();
    bool speedExceeded = Speed + SpeedIncr &gt; MaxSpeed;
    if (speedExceeded &amp;&amp; (SpeedLimit!= null))
    {
      SpeedLimitData data = new SpeedLimitData()
      {
        moment = DateTime.Now,
        resultingSpeed = Speed + SpeedIncr
      };
      SpeedLimit(this, data);
    }
    Speed = (speedExceeded) ? Speed : Speed + SpeedIncr;
    return speedExceeded;
  }
  public event EventHandler SpeedLimit;
}</pre></div><p>In this manner, each part of the hierarchy takes care of its own duties. Any car that inherits from <code class="literal">SportCarWithN</code> will have the extra functionality, while the rest of the cars will behave in the standard manner.</p><p>In the user interface, things <a id="id850" class="indexterm"/>also get simplified. Now, we <a id="id851" class="indexterm"/>declare <code class="literal">theCar</code> to be of type <code class="literal">ISportCar</code> and decide which constructor to call at execution time:</p><div><pre class="programlisting">ISportCar theCar;
private void cboPickUpCar_SelectedIndexChanged(object sender, EventArgs e)
{
  if (cboPickUpCar.Text == "Mercedes")
  {
    theCar = new SportsCarWithN("Mercedes");
    // subscription to SpeedLimit depends on type
    ((SportsCarWithN)theCar).SpeedLimit += TheCar_SpeedLimit;
  }
  else
  {
    theCar = new SportsCar(cboPickUpCar.Text);
  }
  theCar.LegalLimitCondition += TheCar_LegalLimitCondition;
  // refresh car's properties
  txtMaxSpeed.Text = theCar.MaxSpeed.ToString();
  pbPhoto.Image = theCar.Photo;
  updateUI();
}</pre></div><p>The <code class="literal">btnAccelerate_Click</code> event handler is also simplified, since every instance of <code class="literal">ISportCar</code> will know how to call the appropriate method in the underlying model:</p><div><pre class="programlisting">private void btnAccelerate_Click(object sender, EventArgs e)
{
  theCar.Accelerate();
  updateUI();
}</pre></div><p>Now, at runtime, only the Mercedes brand receives both notifications, while the rest of the brands get only the <code class="literal">LegalLimitCondition</code> event.</p><p>You can check the <a id="id852" class="indexterm"/>results in Demo-ISP and check out <a id="id853" class="indexterm"/>both types of conditions.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec54"/>Dependency Inversion principle</h1></div></div></div><p>The last of the<a id="id854" class="indexterm"/> SOLID principles is based on two <a id="id855" class="indexterm"/>statements, that Wikipedia states in this form:</p><div><ul class="itemizedlist"><li class="listitem"><em>High-level modules should not depend on low-level modules. Both should depend on abstractions.</em></li><li class="listitem"><em>Abstractions should not depend upon details. Details should depend upon abstractions.</em></li></ul></div><p>As for the first statement, we should clarify what we understand by high-level and low-level modules. The terminology is related to the importance of the actions performed by the module.</p><p>Let's put it simply: if a module holds the business logic of a <code class="literal">Customers</code> class, and another includes the format that a list of the <code class="literal">Customers</code> class uses in a report, the first one would be high-class and the second would be low-class.</p><p>The second statement speaks by itself. If an abstraction depends on details, the usage as a definition contract is compromised.</p><p>In the case of our sample, we still have some code that will not grow appropriately: the <code class="literal">SportsCar</code> creation method depends much on what the user writes in the ComboBox. There are <a id="id856" class="indexterm"/>several situations that could show this<a id="id857" class="indexterm"/> inconvenience: writing the wrong name in the brand selection procedure, adding future new brands, and so on. There is some boilerplate code in the UI that we can improve.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec107"/>A final version of the sample</h2></div></div></div><p>Without pretending<a id="id858" class="indexterm"/> that the sample is perfect (at all), the creation procedure can be extracted from the UI and delegated to another class (<code class="literal">CarFactory</code>) that would be responsible for calling the appropriate constructor depending on the brand. (We'll see that this technique is actually implemented using one of the design patterns we'll study later on.)</p><p>In this way, the responsibility of calling the proper constructor would be on <code class="literal">CarFactory</code>, and additional brands can be added more easily.</p><p>In addition, our <code class="literal">SportsCar</code> class will now exclusively take care of its state and business logic related to the state and not the details of <code class="literal">Photo</code> associations or <code class="literal">MaxSpeed</code> values, which seem adequate for a factory.</p><p>So, we will now have a new class (located in the same file as the <code class="literal">SportsCar</code> file), containing these details:</p><div><pre class="programlisting">public class CarFactory
{
  SportsCar carInstance;
  public SportsCar CreateCar(string car)
  {
    switch (car)
    {
      case "Ferrari":
        carInstance = new SportsCar(car);
        carInstance.MaxSpeed = 230;
        carInstance.Photo = Properties.Resources.BMW;
        break;
      case "BMW":
        carInstance = new SportsCar(car);
        carInstance.MaxSpeed = 180;
        carInstance.Photo = Properties.Resources.BMW;
        break;
      case "Mercedes":
        carInstance = new SportsCarWithN(car);
        carInstance.MaxSpeed = 200;
        carInstance.Photo = Properties.Resources.Mercedes;
        break;
      default:
        break;
    }
    return carInstance;
  }
}</pre></div><p>With this new version, the <code class="literal">SportsCar</code> class is reduced to a minimum: it declares constants, its event, its state (properties), and the only action required (<code class="literal">Accelerate</code>). The rest is in the hands of the <code class="literal">CarFactory</code> class.</p><p>The user interface <a id="id859" class="indexterm"/>is also simplified in the creation method, since it doesn't need to know which brand the user selected in order to call either constructor; it simply calls the constructor inside <code class="literal">CarFactory</code> and checks the result of the process in order to assign the event handlers required to show the car's notifications:</p><div><pre class="programlisting">private void cboPickUpCar_SelectedIndexChanged(object sender, EventArgs e)
{
  var factory = new CarFactory();
  theCar = factory.CreateCar(cboPickUpCar.Text);
  // Event common to all cars
  theCar.LegalLimitCondition += TheCar_LegalLimitCondition;
  // Event specific to cars of type SportsCarWithN
  if (theCar is SportsCarWithN) {
    ((SportsCarWithN)theCar).SpeedLimit += TheCar_SpeedLimit;
  }
  // refresh car's properties
  txtMaxSpeed.Text = theCar.MaxSpeed.ToString();
  pbPhoto.Image = theCar.Photo;
  updateUI();
}</pre></div><p>The runtime behavior is just the same as earlier. The difference is that with this decoupling of components, maintenance and growing are much easier.</p><p>Let's imagine that a change happens and the application now has to deal with a new type of brand: Ford, which also incorporates <code class="literal">SpeedLimit</code> notifications.</p><p>The only work to do is to add a picture of a Ford (a Ford GT, not to detract from the other cases…) and retouch <code class="literal">CarFactory</code> to add the new case structure and its values:</p><div><pre class="programlisting">case"Ford":
  carInstance = new SportsCarWithN(car);
  carInstance.MaxSpeed = 210;
  carInstance.Photo = Properties.Resources.Ford;
  break;</pre></div><p>In the UI, only one thing is required: adding the new <code class="literal">Ford</code> string to the selection ComboBox, and it's <a id="id860" class="indexterm"/>ready. Now, we'll be offered the new brand, and when we select it, the behavior will be as expected:</p><div><img src="img/image00638.jpeg" alt="A final version of the sample"/></div><p style="clear:both; height: 1em;"> </p><p>Generally speaking, there are many ways in which the DIP principle can lead to a solution. One of them is through a dependency container, which is a component, which serves or provides you with some code, injecting it when required.</p><p>Some popular dependency containers for C# are Unity and Ninject, to name just a couple. In the code, you instruct this component to register certain classes of your application; so, later on, when you need an instance of one of them, it is served to your code automatically.</p><p>Other frameworks implement this principle as well, even if they're not purely object oriented. This is the case with AngularJS, in which, when you create a controller that requires access to a service, you ask for the service in the controller's function declaration, and the internal DI system of Angular serves a singleton instance of the service without the intervention of the client's code.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec55"/>Design patterns</h1></div></div></div><p>As <a id="id861" class="indexterm"/>we said, SOLID principles are beyond any specific consideration on how to resolve a certain coding problem and even beyond languages or paradigms. However, before Robert Martin defined these principles, other patterns were already in use related to very distinct aspects of coding and structuring applications.</p><p>In real life, a class can use one or more patterns, making it diffuse the boundary between the two. Additionally, you can begin to use a simple pattern and evolve into other more complex patterns depending on the needs of our application.</p><p>In 1995, Eric Gamma, Richard Helm, Ralph Johnson, and John Vlissides (since then, the <a id="id862" class="indexterm"/>
<strong>Gang of Four</strong> or <strong>GoF</strong> for short) published a book that has remained a reference point: <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>.</p><p>The authors analyze a total of 23 design patterns applicable in different coding scenarios in order to solve different coding problems.</p><p>They divide the 23 patterns into three categories:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Creational</strong>: It includes <a id="id863" class="indexterm"/>these patterns:<div><ul class="itemizedlist"><li class="listitem">Abstract Factory</li><li class="listitem">Builder</li><li class="listitem">Factory</li><li class="listitem">Prototype</li><li class="listitem">Singleton</li></ul></div></li><li class="listitem"><strong>Structural</strong>: It is composed<a id="id864" class="indexterm"/> of these patterns:<div><ul class="itemizedlist"><li class="listitem">Adapter</li><li class="listitem">Bridge</li><li class="listitem">Composite</li><li class="listitem">Decorator</li><li class="listitem">Façade</li><li class="listitem">Flyweight</li><li class="listitem">Proxy</li></ul></div></li><li class="listitem"><strong>Behavioral</strong>: It is made up of the <a id="id865" class="indexterm"/>following patterns:<div><ul class="itemizedlist"><li class="listitem">Chain of Responsibility</li><li class="listitem">Command</li><li class="listitem">Interpreter</li><li class="listitem">Iterator</li><li class="listitem">Mediator</li><li class="listitem">Memento</li><li class="listitem">Observer</li><li class="listitem">State</li><li class="listitem">Strategy</li><li class="listitem">Template method</li><li class="listitem">Visitor</li></ul></div></li></ul></div><p>Obviously, all these <a id="id866" class="indexterm"/>patterns are a lot to be covered in this chapter, even in a superficial way, but we're going to focus on the most frequently used ones and explain their advantages and programming in C#:</p><div><img src="img/image00639.jpeg" alt="Design patterns"/></div><p style="clear:both; height: 1em;"> </p><p>The .NET framework itself contains, among others, these patterns: Singleton, Strategy, Factory, Builder, Decorator, and several other patterns in different namespaces.</p><p>There are numerous statistic reports on the Internet about the GoF pattern's usage. Obviously, it's not a question of using this or that pattern because of general acceptance. On the contrary, the reasons to use them are based on the benefits these patterns offer in order to improve the quality of an application.</p><p>That said, I'll just review some of them to give you an idea about their possibilities of solving specific problems. However, an agreement seems to exist when placing the following eight patterns among the most used:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Construction</strong>: Singleton and Factory</li><li class="listitem"><strong>Structural</strong>: Adapter, Decorator, and Façade</li><li class="listitem"><strong>Behavioral</strong>: Command, Observer, and Strategy</li></ul></div><p>Note that some patterns, such as Iterator, are not included here just because they're already present in the vast majority of the collection's libraries (such as in the <code class="literal">System.Collections</code> and <code class="literal">System.Collections.Generic</code> namespaces in .NET). Another typical case is Abstract Factory, which is widely used in ADO.NET.</p><p>Let's start with the most common (and reviled) of them all: Singleton.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec108"/>Singleton</h2></div></div></div><p>The Singleton<a id="id867" class="indexterm"/> pattern prevents the creation of more than one <a id="id868" class="indexterm"/>instance of a class. It's the most popular pattern because its implementation is required in a great variety of situations and many different languages (also in non-compiled languages, such as JavaScript).</p><p>At the same time, it's one of the most reviled because of general abuse of the pattern in many situations in which other patterns would be preferred or even no pattern is required at all (not to mention the difficulties that sometimes arise when including it in unit tests).</p><p>The way it should be coded requires the following:</p><div><ul class="itemizedlist"><li class="listitem">The class should be responsible for creating the unique instance</li><li class="listitem">The unique instance has to be accessible through a method in the class</li><li class="listitem">The constructor should be private in order to avoid direct instantiation</li></ul></div><p>To apply this pattern in our sample, we can imagine a new requisite: for instance, imagine that the user interface requires that either from the current main window or from other future windows, some user information showing the name of the user and the date/time at which the car is selected is available.</p><p>The shape of the new class should reflect the pattern and the values required:</p><div><pre class="programlisting">public class UserInfoSingleton
{
  // A static variable for the instance, requires a lambda function,
  // since the constructor is private.
  private static readonly Lazy&lt;UserInfoSingleton&gt; instance =
  new Lazy&lt;UserInfoSingleton&gt;(() =&gt;newUserInfoSingleton());

  // Private Constructor to avoid direct instantiation
  private UserInfoSingleton() {
    UserName = System.Environment.UserName;
    CarBuyingTime = DateTime.Now;
  }

  // Property to access the instance
  public static UserInfoSingleton Instance
  {
    get { return instance.Value; }
  }
  private string UserName { get; }
  private DateTime CarBuyingTime { get; }
}</pre></div><p>Observe that this <a id="id869" class="indexterm"/>class is only for reading purposes, with no meaningful functionality. However, having it instantiated in this manner, no possible duplication is possible. There will always be a unique set of user information.</p><p>The class' instance is<a id="id870" class="indexterm"/> stored in the private static <code class="literal">instance</code> variable, and the constructor is private in order to avoid external instantiation. Actually, all members except the <code class="literal">Instance</code> property are private.</p><p>The other aspect of the class that you might wonder about is the <code class="literal">Lazy&lt;UserInfoSingleton&gt;</code> type of the <code class="literal">instance</code> member, which guarantees that the instance is thread-safe since it won't really be instantiated until it is used by a client of the class.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec109"/>The Factory pattern</h2></div></div></div><p>Wikipedia's <a id="id871" class="indexterm"/>definition of the Factory pattern states that, <em>a Factory is actually a creator of objects which have a common interface, without exposing the instantiation logic</em>.</p><p>Actually, this is what <a id="id872" class="indexterm"/>we did in the last modification in our sample, when we detached the instantiation into a <code class="literal">CarFactory</code> class.</p><p>With these changes, we divided the structure of the resulting objects into two parts:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">CarFactory</code> class decides the state structure of the resulting object depending on the brand field (remember that the state of a class is defined by the set of values that its properties hold in a given instant of its execution).</li><li class="listitem"><code class="literal">SportsCar</code> and <code class="literal">SportsCarWithN</code> are implementations of a behavior. Each one implements distinct behaviors with respect to the instant <code class="literal">Speed</code> value, and both share the same state structure (same field names and types).</li></ul></div><p>In our sample, there<a id="id873" class="indexterm"/> is a dependency between the fields, since <code class="literal">MaxSpeed</code> <a id="id874" class="indexterm"/>and <code class="literal">Photo</code> directly depend on <code class="literal">Brand</code>, so they should be resolved at construction time. Generally speaking, when there aren't any dependencies of this type, the structure can be more flexible.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec110"/>The Adapter pattern</h2></div></div></div><p>The Adapter<a id="id875" class="indexterm"/> pattern is one of the most versatile, and it's intended to allow two components that were not originally designed to work together in order to integrate them in the cleanest way possible.</p><p>It is, therefore, especially <a id="id876" class="indexterm"/>suitable when we have to deal with legacy code, in which it is quite difficult, if not impossible, to modify fragments of the code, but we have the requirement to include new functionality.</p><p>The following schema shows the most common way to visually prototype the indirect path that the Adapter pattern implements in order to achieve this goal:</p><div><img src="img/image00640.jpeg" alt="The Adapter pattern"/></div><p style="clear:both; height: 1em;"> </p><p>As you can see in the schema, there is a client that uses a certain interface. When the original class needs to change or extend some behavior with minimal or no changes, Adapter is one of the most accepted solutions.</p><p>Imagine that we have a class that lists all car brands and that we cannot modify, with the following code:</p><div><pre class="programlisting">class ShoppingCarsPortal
{
  static void Main(string[] args)
  {
    Console.Title = "Demo of the Adapter Pattern";
    ITarget adapter = new VendorAdapter();
    foreach (string brand in adapter.GetCars())
    {
      Console.WriteLine("Brand: " + brand);
    }
    Console.ReadLine();
  }
}</pre></div><p>On the other hand, a <a id="id877" class="indexterm"/>new class has to be used in order to get the list of the <a id="id878" class="indexterm"/>cars still calling to the same <code class="literal">adapter.GetCars()</code> function. This class, named <code class="literal">ListOfCarsProvider</code>, holds a method called <code class="literal">GetListOfCars</code>:</p><div><pre class="programlisting">public class ListOfCarsProvider
{
  public List&lt;string&gt; GetListOfCars()
  {
    List&lt;string&gt; carsList = newList&lt;string&gt;();
    carsList.Add("Ferrari");
    carsList.Add("Mercedes");
    carsList.Add("BMW");
    carsList.Add("Ford");
    return carsList;
  }
}</pre></div><p>We can define a simple interface (<code class="literal">ITarget</code>), which defines the same method signature that the final class requires:</p><div><pre class="programlisting">interface ITarget
{
  List&lt;string&gt; GetCars();
}</pre></div><p>The next step is to make <code class="literal">VendorAdapter</code> implement <code class="literal">ITarget</code>. The trick is that we make the implementation of <code class="literal">GetCars()</code> call the new list of cars in <code class="literal">ListOfCarsProvider</code>:</p><div><pre class="programlisting">class VendorAdapter : ITarget
{
  public List&lt;string&gt; GetCars()
  {
    ListOfCarsProvider adaptee = new ListOfCarsProvider();
    return adaptee.GetListOfCars();
  }
}</pre></div><p>As you can see, we preserve the functionality of the base class but allow a new way to obtain the list of available cars. We provide a level of indirection with minimal changes.</p><p>Of course, the list is<a id="id879" class="indexterm"/> obtained <a id="id880" class="indexterm"/>at runtime, as expected:</p><div><img src="img/image00641.jpeg" alt="The Adapter pattern"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec111"/>The Façade pattern</h2></div></div></div><p>Another <a id="id881" class="indexterm"/>useful (and quite used) pattern in many circumstances is the <a id="id882" class="indexterm"/>Façade pattern. It's quite simple, and its main purpose is to unify processes dispersed in distinct functions of a library, giving access to them through a more simple, concrete set of methods.</p><p>Wikipedia collects some typical usages of this pattern, for example, when you want to do the following:</p><div><ul class="itemizedlist"><li class="listitem">Make an external library easier to use</li><li class="listitem">Give access to a library in a more readable way or with a more organized structure</li><li class="listitem">Reduce the dependencies found in the management of an outside library</li></ul></div><p>The graphic schema that represents this structure is usually represented in this manner:</p><div><img src="img/image00642.jpeg" alt="The Façade pattern"/></div><p style="clear:both; height: 1em;"> </p><p>This means that the <a id="id883" class="indexterm"/>façade its just another layer between a set of classes<a id="id884" class="indexterm"/> that can either be saved inside a larger library or disaggregated along distinct files. In any case, the pattern allows the unification of that functionality included in the assemblies.</p><p>No interface implementation is required since it's only a matter of calling the required methods, thus providing the business logic. You'll find the source code corresponding to the preceding schema in the demo called <code class="literal">PatternFacade</code>. The runtime doesn't have much interest in this since you can easily deduct how it works.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec112"/>The Decorator pattern</h2></div></div></div><p>The <a id="id885" class="indexterm"/>Decorator pattern <a id="id886" class="indexterm"/>is frequently used when you need to add a functionality to a procedure (often obtaining extra data to accompany the standard implementation) but you have to keep the current behavior as it is and only add the new functionality for certain scenarios.</p><p>If you think about it, this pattern enforces the application of the Open/Closed principle. The main code remains intact, but the pattern allows the functionality to grow in a controlled manner.</p><p>The situation is<a id="id887" class="indexterm"/> similar to the first implementation of <a id="id888" class="indexterm"/>our <code class="literal">SportsClassWithN</code> type of cars in our sample. The current functionality of the main class (<code class="literal">SportsCar</code>) is not to be changed. But some extra requirements would be needed in case the brand were a Mercedes (and later on, for the Ford brand as well). In this case, the new class inherited from the base class and added some behavior:</p><div><img src="img/image00643.jpeg" alt="The Decorator pattern"/></div><p style="clear:both; height: 1em;"> </p><p>Finally, the user interface decides which class is to be implemented at runtime, and in the case of the exception, it instructs the event handler to manage that exception.</p><p>The pattern admits (like most of them) slight variations in the way you implement it.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec113"/>The Command pattern</h2></div></div></div><p>The<a id="id889" class="indexterm"/> Command pattern<a id="id890" class="indexterm"/> is one of the most used patterns in the behavioral category. GoF authors define the pattern in this way: <em>encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations</em>.</p><p>As always, a level of indirection is provided. Instead of immediately executing a call, we are allowed to queue it, which has many advantages in a bunch of scenarios, especially now, when more and more implementations require asynchronous processing.</p><p>The key part of this pattern is that it decouples the object that invokes an operation from the one that has the knowledge to perform it.</p><p>A typical<a id="id891" class="indexterm"/> example that GoF authors state as canonical is about the menu's<a id="id892" class="indexterm"/> implementation in a classic user interface: in this case, you can implement several user interface artifacts to perform the same action (such as <code class="literal">MenuItem</code> and a toolbar's button) by having both of them perform the same action, that is, making both implement the same concrete <code class="literal">Command</code> subclass.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec71"/>An example already implemented in .NET</h3></div></div></div><p>Again, we can find the Command pattern<a id="id893" class="indexterm"/> implemented in a variety of places within .NET Framework. Perhaps one of the most evident patterns is something as simple as the procedure to close a window: you can do it in four different ways:</p><div><ul class="itemizedlist"><li class="listitem">By clicking on the icon window to close it</li><li class="listitem">Using the window menu (not the user menu) and selecting <strong>Close</strong></li><li class="listitem">By pressing <em>Ctrl</em> + <em>F4</em></li><li class="listitem">By calling <code class="literal">this.close() </code>in some of the window's code</li></ul></div><p>All of the preceding ways provoke a command invocation, sending a <code class="literal">WM_CLOSE</code> message to the window.</p><div><h3 class="title"><a id="note27"/>Note</h3><p>You can check the whole list <a id="id894" class="indexterm"/>of window messages that a window can handle at the dedicated site, Platform Invoke (<a class="ulink" href="http://www.pinvoke.net/">http://www.pinvoke.net/</a>).</p></div><p>Invoking <code class="literal">this.close()</code> in a window is a command invocation itself. The .NET Framework also sends one of these messages to be managed by the message's dispatcher window function.</p><p>You can intervene in this call thanks to the implementation of the <code class="literal">Window.FormClosing</code> event, which carries information about the command to be executed and allows it to cancel it by assigning the value of the <code class="literal">e.Cancel</code> property (<code class="literal">EventArgs</code>)to <code class="literal">true</code>.</p><p>Besides, you can find out the reason for this event to be launched, examining the <code class="literal">e.CloseReason</code> property that the <code class="literal">e</code> argument holds.</p><p>These two possibilities are available thanks to the implementation of the command pattern in the internal mechanism used to send <code class="literal">WM_CLOSE</code> messages to a window inside .NET Framework.</p><div><h3 class="title"><a id="note28"/>Note</h3><p>We'll talk about the advanced aspects of .NET framework in the last chapter of this book, along with other techniques related to platform invocation.</p></div><p>The following capture<a id="id895" class="indexterm"/> resumes this window-closing scenario in the user interface of our initial demos:</p><div><img src="img/image00644.jpeg" alt="An example already implemented in .NET"/></div><p style="clear:both; height: 1em;"> </p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec114"/>The Observer pattern</h2></div></div></div><p>Again, we find <a id="id896" class="indexterm"/>another popular pattern that's widely implemented <a id="id897" class="indexterm"/>inside the .NET framework for distinct scenarios.</p><p>The MSDN documentation states that this pattern <em>enables a subscriber to register with and receive notifications from a provider. It is suitable for any scenario that requires push-based notification</em>.</p><p>A typical case of this pattern is implemented in order to link data in a model with the user interface, which shows it in distinct controls: DataGridViews, TextBoxes, and so on. When the user performs an action that implies a modification in the data shown in the UI—such as an update, a deletion, or a modification—the desired behavior is that these controls are automatically informed of the changes and they can update them in the UI.</p><p>This source suggests the steps to implement this pattern in .NET:</p><div><ul class="itemizedlist"><li class="listitem">A provider needs to be in charge of sending notifications to the observer. It should be a class or a structure that implements the <code class="literal">IObservable&lt;T&gt;</code> interface, although its only requisite is implementing the <code class="literal">IObservable&lt;T&gt;.Subscribe</code> method. This is the one called by client observers that wish to receive notifications.</li><li class="listitem">An observer that is the object that receives notifications from the provider. In this case, the class should implement the <code class="literal">IObserver&lt;T&gt;</code> interface, but it's required that it implement three methods that will be called by the provider:<div><ul class="itemizedlist"><li class="listitem"><code class="literal">IObserver&lt;T&gt;.OnNext</code>, which provides new or current information</li><li class="listitem"><code class="literal">IObserver&lt;T&gt;.OnError</code>, which is in charge of informing the observer about any error that has occurred</li><li class="listitem"><code class="literal">IObserver&lt;T&gt;.OnCompleted</code>, which always marks the ending of notifications</li></ul></div></li><li class="listitem">If you think about the scenario, we have the typical communication scheme between a sender and a receiver. So, we also need a channel to transmit the information. In this case, we need a mechanism that allows providers to keep track of observers.</li><li class="listitem">Such mechanism in .NET is usually assigned to an instance of <code class="literal">System.Collections.Generics.List&lt;T&gt;</code>, which is in charge of holding references to the implementations of <code class="literal">IObserver&lt;T&gt;</code>. This is a convenient way to handle references to an unlimited number of observers.</li><li class="listitem">Usually, there is <a id="id898" class="indexterm"/>another object that stores data that the provider sends to its subscribed observers.</li></ul></div><p>In a real-case<a id="id899" class="indexterm"/> scenario, it might depend on the solution you're building: Windows Presentation Foundation interfaces implement observable collections precisely with this purpose. Even other mechanisms that implement the MVC paradigm are capable of showing this behavior.</p><p>A well-known case outside the OOP world is the AngularJS Framework, which makes every data in the model observable and linkable to the user interface, implementing a double binding architecture that makes any change in the model automatically reflect in the user interface, using a special markup (the <em>moustache</em> syntax).</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec115"/>The Strategy pattern</h2></div></div></div><p>The Strategy pattern <a id="id900" class="indexterm"/>is officially <a id="id901" class="indexterm"/>defined as <em>a practice of defining a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it</em>.</p><p>Mainly, there are three participants:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">Strategy</code> (or compositor) component responsible for defining a common interface for all algorithms to be managed</li><li class="listitem"><code class="literal">ConcreteStrategy</code>, which implements the algorithm using the strategy interface</li><li class="listitem"><code class="literal">AContext</code>, which has three roles: it gets configured with the <code class="literal">ConcreteStrategy</code> object, maintains a reference to the <code class="literal">Strategy</code> object, and—optionally—it can define an interface to allow Strategy to access its data.</li></ul></div><p>In code, a typical example might be when you have to use different sorting strategies (in any collection), but depending on other circumstances, you might like to choose which sorting algorithm you'd like to use, for instance, QuickSort, Shell, or Bubble.</p><p>You can define an <a id="id902" class="indexterm"/>object (<code class="literal">SortingClass</code>) with a method responsible for<a id="id903" class="indexterm"/> sorting, but depending on a value, the instance is created from another instance of the actual sorting method.</p><p>The following code gives you an idea about how to use this pattern. The key is that <code class="literal">SortingClass</code> is called with distinct instances of the desired algorithm:</p><div><pre class="programlisting">SortingStrategy shell = newSortingClass(newShell());
SortingStrategy quick = newSortingClass(newQuickSort());
SortingStrategy bubble = newSortingClass(newBubble());</pre></div><p>With this approach, the user interface will always call the same method for sorting, whatever its name, but the actual sorting mechanism will be decided at runtime.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec56"/>Other software patterns</h1></div></div></div><p>As we mentioned, there <a id="id904" class="indexterm"/>is a total of 23 patterns linked to the original publication of the GoF group, but later on, other patterns belonging to the three main categories have appeared. Even a new category was defined: Concurrency patterns.</p><p>Among the three base categories, the additions are as follows:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Creational</strong>: The following <a id="id905" class="indexterm"/>are the sub types of this<a id="id906" class="indexterm"/> category:<div><ul class="itemizedlist"><li class="listitem"><strong>Multiton</strong>: Focalizes the <a id="id907" class="indexterm"/>creation of classes through a single, global point and ensures that instances are only named instances.</li><li class="listitem"><strong>Object Pool</strong>: Provides<a id="id908" class="indexterm"/> a cached system to avoid the expensive acquisition (or release) of resources. It does this by recycling any object that is not being used. Many specialists consider it a generalization of the connection pool and thread pool patterns.</li><li class="listitem"><strong>Resource Acquisition is Initialization</strong>: Wikipedia<a id="id909" class="indexterm"/> states that this <em>ensures that resources are properly released by tying them to the lifespan of suitable objects</em>.</li></ul></div></li><li class="listitem"><strong>Structural</strong>: The following are the<a id="id910" class="indexterm"/> sub types of this category:<div><ul class="itemizedlist"><li class="listitem"><strong>Extension object</strong>: Allows the addition of a functionality to a given hierarchy without <a id="id911" class="indexterm"/>changing it.</li><li class="listitem"><strong>Front controller</strong>: This one <a id="id912" class="indexterm"/>has to do with web application design. It's a way to unify entry points to handle requests in a single node.</li><li class="listitem"><strong>Marker</strong>: This is an <a id="id913" class="indexterm"/>empty interface to provide a way to link metadata to a class.</li><li class="listitem"><strong>Module</strong>: Wikipedia <a id="id914" class="indexterm"/>says that it's <em>intended to group several related elements, such as classes, singletons, methods, globally used, into a single conceptual entity</em>.</li><li class="listitem"><strong>Twin</strong>: A<a id="id915" class="indexterm"/> dangerous one; according to some specialists, this provides the modeling of multiple inheritance for languages that don't support this feature.</li></ul></div></li><li class="listitem"><strong>Behavioral</strong>: The following are the<a id="id916" class="indexterm"/> sub types of this <a id="id917" class="indexterm"/>category:<div><ul class="itemizedlist"><li class="listitem"><strong>Blackboard</strong>: This is a pattern for artificial intelligence systems that allow the merging of<a id="id918" class="indexterm"/> different data<a id="id919" class="indexterm"/> sources (refer to <a class="ulink" href="https://en.wikipedia.org/wiki/Blackboard_system">https://en.wikipedia.org/wiki/Blackboard_system</a>).</li><li class="listitem"><strong>Null object</strong>: This is intended to avoid null references by providing a default <a id="id920" class="indexterm"/>object. In C#, we've seen how it is implemented using different operators (such as Null Coalescence and Null-Conditional Operators, which we saw in the initial chapters).</li><li class="listitem"><strong>Servant</strong>: This defines<a id="id921" class="indexterm"/> common operations for a set of classes.</li><li class="listitem"><strong>Specification</strong>: Recombines business logic in a Boolean fashion. There is abundant documentation of the implementation of this pattern in C# and how it <a id="id922" class="indexterm"/>has improved along <a id="id923" class="indexterm"/>with new versions of the language (<a class="ulink" href="https://en.wikipedia.org/wiki/Specification_pattern">https://en.wikipedia.org/wiki/Specification_pattern</a>).</li></ul></div></li><li class="listitem"><strong>Concurrency patterns</strong>: These <a id="id924" class="indexterm"/>are specifically designed to deal with <a id="id925" class="indexterm"/>multithreading scenarios. The following table is inspired by the actual documentation of this subject available on Wikipedia:<div><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Name</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>Active object</p>
</td><td valign="top">
<p>Decouples <a id="id926" class="indexterm"/>method execution from the method invocation that resides in its own thread of control. The goal is to introduce concurrency using asynchronous method invocation and a scheduler to handle requests.</p>
</td></tr><tr><td valign="top">
<p>Balking</p>
</td><td valign="top">
<p>Only executes <a id="id927" class="indexterm"/>an action on an object when the object is in a particular state.</p>
</td></tr><tr><td valign="top">
<p>Binding properties</p>
</td><td valign="top">
<p>Combines multiple <a id="id928" class="indexterm"/>observers to force properties in different objects to be synchronized or coordinated in some way. </p>
</td></tr><tr><td valign="top">
<p>Block chain</p>
</td><td valign="top">
<p>A decentralized <a id="id929" class="indexterm"/>way to store data and agree on the ways to process it in a Merkle tree, optionally using a digital signature for any individual contributions.</p>
</td></tr><tr><td valign="top">
<p>Double-checked locking</p>
</td><td valign="top">
<p>Reduces the <a id="id930" class="indexterm"/>overhead of acquiring a lock by first testing the locking criterion (the lock hint) in an unsafe manner; only if that succeeds does the actual locking logic proceed.</p>
<p>Can be unsafe when implemented in some language/hardware combinations. It can, therefore, be considered an anti-pattern sometimes.</p>
</td></tr><tr><td valign="top">
<p>Event-based asynchronous</p>
</td><td valign="top">
<p>Addresses <a id="id931" class="indexterm"/>problems with the asynchronous pattern that occurs in multithreaded programs.</p>
</td></tr><tr><td valign="top">
<p>Guarded suspension</p>
</td><td valign="top">
<p>Manages<a id="id932" class="indexterm"/> operations that require both a lock to be acquired and a precondition to be satisfied before the operation can be executed.</p>
</td></tr><tr><td valign="top">
<p>Join</p>
</td><td valign="top">
<p>Provides a <a id="id933" class="indexterm"/>way to write concurrent, parallel, and distributed programs by passing messages. Compared to the use of threads and locks, this is a high-level programming model.</p>
</td></tr><tr><td valign="top">
<p>Lock</p>
</td><td valign="top">
<p>A thread<a id="id934" class="indexterm"/> puts a "lock" on a resource, preventing other threads from accessing or modifying it. </p>
</td></tr><tr><td valign="top">
<p>Messaging Design Pattern (MDP)</p>
</td><td valign="top">
<p>Allows the<a id="id935" class="indexterm"/> interchange of information (that is, messages) between components and applications.</p>
</td></tr><tr><td valign="top">
<p>Monitor object</p>
</td><td valign="top">
<p>An <a id="id936" class="indexterm"/>object whose methods are subject to mutual exclusion, thus preventing multiple objects from erroneously trying to use it at the same time.</p>
</td></tr><tr><td valign="top">
<p>Reactor</p>
</td><td valign="top">
<p>Provides <a id="id937" class="indexterm"/>an asynchronous interface to resources that must be handled synchronously.</p>
</td></tr><tr><td valign="top">
<p>Read-write lock</p>
</td><td valign="top">
<p>Allows <a id="id938" class="indexterm"/>concurrent read access to an object, but requires exclusive access for write operations.</p>
</td></tr><tr><td valign="top">
<p>Scheduler</p>
</td><td valign="top">
<p>Explicitly<a id="id939" class="indexterm"/> controls when threads may execute single-threaded code.</p>
</td></tr><tr><td valign="top">
<p>Thread pool</p>
</td><td valign="top">
<p>A number of <a id="id940" class="indexterm"/>threads are created to perform a number of tasks, which are usually organized in a queue. Typically, there are many more tasks than threads. Can be considered a special case of the object pool pattern.</p>
</td></tr><tr><td valign="top">
<p>Thread-specific storage</p>
</td><td valign="top">
<p>Static or "global" memory<a id="id941" class="indexterm"/> that is local to a thread.</p>
</td></tr></tbody></table></div></li></ul></div><p>Also, remember that often, there's no need to explicitly implement a pattern when the framework you use already supports it (such as how it happens in the .NET Framework), and chances are that at the time of implementing a real solution, not one but several of these patterns might be required in order to code things properly.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec57"/>Other patterns</h1></div></div></div><p>At the beginning of this chapter, we said that there are many different patterns, guides, and sets of good practices published by different specialists, either from academic environments or from corporations.</p><p>They can be also applied to distinct programming contexts, and for different programming paradigms: the integration of applications, data management, user interfaces, application testing (unit or behavioral), and so on. They are usually called <a id="id942" class="indexterm"/>Domain Specific patterns.</p><p>In any case, as technology evolves, so do the patterns. New patterns appear, and some others become less used, just because the technology or architecture they apply to also falls into disuse.</p><p>Some others, in turn, get revitalized as the technology grows, such as in the case of <em>Design and Implementation Guidelines for Web Clients</em>, which you can find at <a class="ulink" href="https://msdn.microsoft.com/en-us/library/ff650462.aspx">https://msdn.microsoft.com/en-us/library/ff650462.aspx</a>. However, if we consider other patterns very useful at the moment, such as<a id="id943" class="indexterm"/> Data patterns (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/ff648420.aspx">https://msdn.microsoft.com/en-us/library/ff648420.aspx</a>), chances are that you'll find them a little outdated just because it was published in 2003, and things have changed a lot since then, not to mention the appearance of other models and technologies, such as the Big Data revolution.</p><p>So, keep in mind the big principles first, and when you have to apply any of them for the sake of your application, take a look at the available patterns (classic or new) because they might offer you a trusted, proved solution.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec58"/>Summary</h1></div></div></div><p>In this chapter, we went through software guides and patterns. We started with the SOLID principles proposed by Robert Martin a few years ago, which are now gaining momentum among the programmers community, and we can see them implemented in the vast majority of frameworks in use today.</p><p>We used a simple application, and as the requirements evolved, we applied different principles or patterns to solve the problems.</p><p>Finally, we studied the eight most used GoF patterns (according to the statistics), revising their definitions and purposes in order to finish with the current list of available patterns created and published after the GoF group published their book.</p><p>In the next chapter, we'll deal with security issues, including the new proposals widely adopted in the industry, such as the <strong>OAuth</strong> (<strong>Open Authorization</strong>) protocol.</p></div></body></html>