- en: Unraveling a Mess
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all applications were written with testing in mind. Few were originally
    developed using TDD. Often, the original developers are long gone, and documentation
    is incorrect, incomplete, or missing entirely.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will gain an understanding of:'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with inherited code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Characterization tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring with tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a case study of legacy code that needs (what should be) a minor
    change. We will quickly find out that the change is not so minor. To begin, let's
    look at what the legacy application does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is some sample output from a run of this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the interactions, this program doesn't look that bad. In speaking
    with the business analyst, the application was explained as a game.
  prefs: []
  type: TYPE_NORMAL
- en: The game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This particular game is called *Mastermind* and is a code breaking puzzle. According
    to the business analyst, the code consists of the letters A through F and contains
    four of the letters chosen at random. It is the goal of the player to determine
    the passcode.
  prefs: []
  type: TYPE_NORMAL
- en: The player is given hints along the way. For a correctly placed letter, the
    player receives a plus symbol. For a correct letter in the wrong position, the
    player receives a minus symbol. If the letter is incorrect, the player receives
    no symbol.
  prefs: []
  type: TYPE_NORMAL
- en: A change is requested
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During play testing, it was determined that players were discovering the passcodes
    too quickly. As a result, the game wasn't as much fun as it could be. The suggested
    solution was to make the passcode more complex by allowing more than six letters
    to be used. It is our job to extend the character range to A through Z.
  prefs: []
  type: TYPE_NORMAL
- en: We can start by looking at the existing code to determine where we might have
    to make the change. That is where we discover this!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the file `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We now have several problems. Firstly, it's not exactly clear where the letters
    are coming from. Secondly, there is no way this code is tested. Lastly, even if
    making the change were straight forward, making sure we didn't break something
    would not be. We have to do a full manual regression test to verify that any of
    this is working, and trying to verify that all letters, A through Z, are possible
    may take a very long time.
  prefs: []
  type: TYPE_NORMAL
- en: Life sometimes hands you lemons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While I hope you never receive code this bad, we are going to walk through what
    is needed to turn even this into readable, maintainable, and fully tested code.
    The best part, the part you aren't going to believe, is that transforming this
    code is actually safe and fairly easy.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any code situation like this, the first thing we must do is remove the code
    in question from the environment where we have no control. In this case, we can't
    test the code if it is sitting in `Program.main`. So, let's grab the whole thing
    and put it into a class named `Mastermind`. We will have a single function named
    `Play` that will run the game. This is considered a safe refactoring, because
    we are not changing any of the existing code, simply moving it somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the file `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `Mastermind.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Running the code again at this point shows that everything still works. The
    next step is a cosmetic one; let's spread the `Play` method out into sections.
    This should help us determine what private methods exist inside the large public
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the file `Mastermind.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We have now used whitespace to split the program into several pieces and added
    comments explaining what we think each piece is doing. At this point, we are almost
    ready to begin testing. We have just a couple things in the way, the worst of
    which is the `Console` class.
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting a third-party class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we tried to test right now, the application would hit the first `ReadLine`
    call and the test would time out. Console has the ability to redirect the input
    and output, but we are not going to use this feature, because it is specific to
    Console and we want to demonstrate a more generic solution that you can apply
    anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: What we need is a class that gives us a similar interface to Console. Then we
    can dependency inject our class for the tests and a thin wrapper for the production
    code. Let's test drive that interface now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the file `InputOutputTests.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `ReadLineTests.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `ReadTests.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `WriteTests.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `WriteLineTests.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `IInputOutput.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `MockInputOutput.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That handles our mock input and output, but we need to create the production
    wrapper class for Console, and we need to use `Program.cs` to inject that class
    into the `Mastermind` class.
  prefs: []
  type: TYPE_NORMAL
- en: Unexpected Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While replacing calls to Console with calls to our injected class, we found
    two use cases that we did not plan for. The first use case is fairly involved
    and has a couple parameters we need to handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The second use case is more simple and doesn''t take any parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The second use case is the easiest to deal with, so let us write a quick test
    for that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the file `WriteLineTests.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `IInputOutput.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `MockInputOutput.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The next issue is slightly more complicated. If we want to handle it accurately,
    we will need to do quite a bit of regular expression and string manipulation.
    However, we don't need it to be "correct"; we only need it to work as expected
    by the application. In the singular case where this is being used, the value that
    should be placed into the string being written, isn't. The original developer
    abused the functionality of `Console.Write` to reduce the number of lines in the
    if statement so they could avoid brackets. So, all we need to do for the code
    to continue to work is allow for the input to take place. A simple interface extension
    should provide that for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the file `IInputOutput.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `MockInputOutput.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Back in the application code, we can finish making our changes. Here is the
    updated application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the file `ConsoleInputOutput.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `Mastermind.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick test run confirms that the application is working correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can write a gold standard or characterization test that will verify
    all the parts of the code are working correctly. The only piece of the code this
    test will not cover is the random password generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is an extremely long test, and it has an out of the ordinary structure,
    but this single test runs through almost all the logic in the application. You
    may not always be able to do this with a single test, but before beginning any
    heavy refactoring, these tests must exist.
  prefs: []
  type: TYPE_NORMAL
- en: Making sense of the madness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the gold standard test written, we can begin to safely refactor
    the code. Any changes that we try to make that break the gold standard test will
    have to be undone and a new approach will have to be taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the `Mastermind` class, all those variables at the top of the `Play`
    method can be moved out to be class level fields. This will make them available to
    all the code within the class and help to both figure out what they are for and
    how often they are used in the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will just work our way down the `Play` method, extracting all that
    we can into tiny private methods. We are only able to do some tiny refactoring
    before we need to switch gears and start fixing some of the antiquated logic in
    this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We were able to break out a password generation method. We were also able to
    simplify the structure of the success code. We cannot, however, proceed without
    addressing the complexity of the chosen looping structures. The developer that
    wrote this did not use general looping structures, such as while and for loops.
    We need to fix that in order to better understand and work with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a structure that we can begin to work with. Let''s start by making
    some sense of these variable names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We will want to make updates to the `Play` method that reflect our determinations
    for what the variables mean. Following we have replaced the single letter variable
    names with names that more appropriately represent what the variables are used
    for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Next, it would be nice if we could update the interface now that we understand
    the application a little better. Two things that we would like to change are the
    input and the very end of the game. It would be nice if the input was a simple
    string instead of a character array. The `Play` method could take a string and
    the program could figure out how to get the password string from the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Along those same lines, we could reduce the overall number of writes and turn
    the consecutive plus and minus `Write` commands into a single `WriteLine` command.
    This would break our gold standard test, but wouldn't actually change the functionality
    of the code. It would still print the pluses and minuses on a single line.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert the guess from a character array to a string, we must first understand
    what is happening on this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Analyzing the line, we see the numbers `65`, `26`, and `32`. If you are familiar
    with ASCII codes, then these lines might make sense to you. The number `65` is
    the starting point of the alphabet characters on the ASCII tables. There are 26
    letters in the English alphabet. And, there are 32 values between "a" and "A".
    So, it is to be assumed that this code is either uppercasing or lowercasing the
    character at the specified index. We can approximate this in C# using the `String.ToUpper()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: While we are doing a small bit of gold standard changes, we should also remove
    the last two lines of the `Play` method and move them to `Program.cs`, as they
    are more related to a Console application than anything else.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the file `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `Mastermind.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `GoldStandardTests.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Final beautification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that everything else is done and the code is working correctly, it is time
    for the last refactoring before we start our enhancement. We want our methods
    to be as small as possible. In this case, that means that the `Play` function
    should have practically no logic outside the main game loop.
  prefs: []
  type: TYPE_NORMAL
- en: In general, if a method has any kind of block in it (for example, if, while,
    for, and so on), we want that block to be the only thing in the method. Often,
    there are also guard statements checking input, but that should be it. Let's refactor
    to follow that convention and see what the code looks like afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the file `Mastermind.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There are many ways that this code could have been refactored; this is just
    one. Now that the code is refactored, we are ready to move on and begin working
    on enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: Ready for enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now to a point where the code makes enough sense that we can begin to
    work on our change requests. We have broken the random password generation portion
    of the code into its own method, so now we can work on it independently.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first things we need to do is to stop using `Random`. `Random` is,
    by nature, unpredictable and outside of our control. We need a way to feed the
    number generation to verify that we can get the expected outputs when `Random`
    provides specific inputs.
  prefs: []
  type: TYPE_NORMAL
- en: We will extract an interface and mock class similar to what we did for Console.
    Here is the first round of tests, the mock class, and the interface that were
    created.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the file `RandomNumberTests.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `IRandomGenerator.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `MockRandomGenerator.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, to create the production `RandomGenerator` class and inject it into our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the file `RandomGenerator.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `Mastermind.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: And lastly, let's modify the gold standard test to use random password generation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the file `GoldStandardTests.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to refactor the password generation method and extend it to
    provide us with the requested change. First, there is a looping structure that
    is not core to the language. Let''s focus in on the `CreateRandomPassword` method
    and fix the looping structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, for fun, let''s see if we can generalize and compress this loop, since
    we have a very similar loop in the `Check` method. While not necessary, this is
    fun example of reducing duplication of code. Here is what that refactoring looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now let's do one more refactoring before we extend the application. Looking
    at how the characters are generated, it is not very obvious what is going on.
    Instead, we would like the code to be as straightforward as possible. There is
    no reason that the random generator class can't just directly return letters,
    so let's add that functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the file `RandomLetterTests.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `MockRandomGenerator.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `IRandomGenerator.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `RandomGenerator.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `Mastermind.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `GoldStandardTests.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: That is the final refactoring for this exercise. We only have one thing to do,
    and that is to extend the application to generate passwords using the full range
    of the English alphabet. Because of the effort we put into testing and refactoring,
    this is now a trivial matter, and, in fact, only requires the removal of three
    characters in the `Mastermind` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the file `Mastermind.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now a more complicated password, consisting of the full range of the alphabet,
    is created. This causes a much more difficult password, and a game with output
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You now have a well-written example, covered by tests. The effort involved can
    be daunting, but for anything more than a trivial application, it can be well
    worth the effort.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 14](part0430.html#CQ2HS0-d186949d2da74f5c95dd1712efae1195), *A Better
    Foot Forward*, we'll summarize what we've learned as well as give you some pointers
    on how to rejoin the world as a TDD expert.
  prefs: []
  type: TYPE_NORMAL
