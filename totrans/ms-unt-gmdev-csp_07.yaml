- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Implementing Engaging Game Mechanics Using C# in Unity
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Unity中使用C#实现引人入胜的游戏机制
- en: Welcome to [*Chapter 4*](B22017_04.xhtml#_idTextAnchor058), where we invite
    you into the dynamic world of game development. As you delve into this chapter,
    your journey will begin by exploring the foundational principles that drive successful
    game mechanics. This initial step involves an introduction to game mechanics,
    allowing you to grasp the essential concepts that form the backbone of captivating
    gameplay.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到[*第4章*](B22017_04.xhtml#_idTextAnchor058)，我们将邀请您进入游戏开发的动态世界。随着您深入本章，您的旅程将从探索推动成功游戏机制的基础原则开始。这一初步步骤包括对游戏机制的了解，让您掌握构成引人入胜游戏玩法骨干的基本概念。
- en: Following this, you’ll seamlessly transition into the realm of player behavior
    and AI before delving into the topics of challenge and reward systems. This journey
    unravels the art of crafting interactive and responsive gaming experiences.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，您将无缝过渡到玩家行为和AI领域，然后再深入研究挑战和奖励系统。这段旅程揭示了制作互动和响应式游戏体验的艺术。
- en: By the end of this chapter, you’ll be equipped with not only theoretical insights
    but also practical skills to shape immersive gaming adventures in Unity using
    the power of C#.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将不仅具备理论洞察力，还将拥有使用C#在Unity中塑造沉浸式游戏冒险的实用技能。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introducing game mechanics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍游戏机制
- en: Implementing player behavior and AI logic using C#
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C#实现玩家行为和AI逻辑
- en: Implementing challenge and reward systems using C#
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C#实现挑战和奖励系统
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can access the code samples and project files on our dedicated GitHub repository:
    [https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2004](https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2004).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问我们的专用GitHub仓库中的代码示例和项目文件：[https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2004](https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2004)。
- en: Clone or download the repository so that you have easy access to the code demonstrated
    in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 复制或下载仓库，以便您能够轻松访问本章中展示的代码。
- en: Introducing game mechanics
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍游戏机制
- en: '**Game mechanics** are the rules and systems that shape how a game is played.
    Think of them as the behind-the-scenes mechanisms that define the player’s experience.
    They are vital for crafting engaging gameplay, influencing everything from movement
    and combat to how a story unfolds. Successful games, such as *Mario* with its
    jumping mechanics, or *Tetris* with its block arrangement challenges, showcase
    how well-crafted mechanics can create memorable and enjoyable experiences for
    players.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**游戏机制**是塑造游戏玩法规则的规则和系统。把它们想象成定义玩家体验的后台机制。它们对于制作引人入胜的游戏玩法至关重要，影响着从移动和战斗到故事展开的方方面面。成功的游戏，如拥有跳跃机制的*马里奥*或拥有方块排列挑战的*俄罗斯方块*，展示了精心设计的机制如何为玩家创造难忘且愉快的体验。'
- en: Game mechanics go beyond just making a game work; they subtly tell stories by
    how players interact. Whether it’s in fighting games with complex combat or in
    platformers with puzzle-solving, these mechanics add to the overall story. When
    players follow the game’s rules, they’re not just watching; they become part of
    the story.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏机制不仅使游戏能够运行，而且通过玩家如何互动来微妙地讲述故事。无论是在复杂的战斗游戏中还是在解谜的平台游戏中，这些机制都增添了整体故事。当玩家遵循游戏规则时，他们不仅仅是旁观者；他们成为了故事的一部分。
- en: So, understanding and creating game mechanics is like becoming skilled at interactive
    storytelling. Each button that’s pressed or moved in the game helps the story
    move along, making every playthrough a unique and personal journey.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，理解和创造游戏机制就像成为互动叙事的高手。游戏中每个按下的按钮或移动的动作都帮助故事推进，使每一次游玩都成为独特且个性化的旅程。
- en: In the following section, we will talk about the essential principles you need
    to know about game mechanics.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论您需要了解的游戏机制的基本原则。
- en: Essential principles of game mechanics
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏机制的基本原则
- en: Now, let’s get into the important stuff that makes games enjoyable. We’re talking
    about the basic rules that shape how players have fun. It’s all about finding
    the right balance, giving feedback, and making sure players feel in control. These
    simple things turn games into exciting adventures where every move adds to the
    fun.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈使游戏有趣的重要元素。我们谈论的是塑造玩家如何享受乐趣的基本规则。这一切都关于找到正确的平衡，提供反馈，并确保玩家感到掌控。这些简单的事情将游戏转变为激动人心的冒险，每个动作都增加了乐趣。
- en: Balance
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平衡
- en: '**Balance** in games is like ensuring everyone gets a fair shot at having fun.
    Picture a game where one character is super strong, making it impossible for others
    to enjoy. That wouldn’t be fair, right? Game developers work hard to create a
    balanced experience where each player or character has a chance to shine. Take
    *Overwatch*, for example. In this game, each hero boasts unique abilities, and
    no one is overwhelmingly powerful or weak. It’s this careful balance that ensures
    a level playing field, allowing everyone to have a good time and contribute to
    the game’s excitement.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的**平衡**就像确保每个人都能公平地享受乐趣。想象一下一款一个角色超级强大，其他人无法享受的游戏——这显然是不公平的，对吧？游戏开发者努力创造一个平衡的体验，让每个玩家或角色都有机会发光。以《守望先锋》为例。在这款游戏中，每个英雄都有独特的技能，没有哪个角色过于强大或弱小。正是这种谨慎的平衡确保了公平的竞技场，让每个人都能享受乐趣并为游戏的激动人心做出贡献。
- en: Furthermore, balance goes beyond characters; it extends to the overall gameplay.
    Imagine a game with levels that are either too easy or impossibly hard – players
    would quickly lose interest. Achieving balance in challenges, difficulty, and
    rewards keeps players engaged. Games that strike this delicate balance provide
    a satisfying and enjoyable experience for players of all skill levels, making
    them want to keep playing and exploring what the game has to offer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，平衡不仅体现在角色上；它还扩展到整体游戏体验。想象一下一款关卡要么过于简单要么难以置信地困难的游戏——玩家很快就会失去兴趣。在挑战、难度和奖励上实现平衡，可以保持玩家的参与度。能够达到这种微妙平衡的游戏，为所有技能水平的玩家提供令人满意和愉快的体验，使他们想要继续玩游戏并探索游戏所能提供的内容。
- en: Feedback
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反馈
- en: In the world of gaming, **feedback** is the game’s way of talking to you, letting
    you know how you’re doing. It’s like a pat on the back when you do something right
    or a gentle nudge when you could improve. In *Minecraft*, for instance, when you
    successfully mine resources, a satisfying sound accompanies the action. That sound
    is feedback, a small celebration telling you that you’ve accomplished a task.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏世界中，**反馈**是游戏与你交流的方式，让你知道你的表现。当你做得正确时，它就像一个鼓励；当你需要改进时，它就像一个温柔的提醒。例如，在《我的世界》中，当你成功开采资源时，伴随着动作会有一个令人满意的声响。那个声音就是反馈，一个小的庆祝，告诉你你已经完成了任务。
- en: Think about playing a racing game without any feedback – no cheering crowd,
    no speedometer ticking up – it would be a bit strange, right? Good feedback, whether
    it’s visual, auditory, or haptic, is essential for making players feel accomplished
    and guiding them through the game’s challenges.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下在没有任何反馈的情况下玩赛车游戏——没有欢呼的人群，没有速度表指针的上升——这会有些奇怪，对吧？良好的反馈，无论是视觉的、听觉的还是触觉的，对于让玩家感到成就感并引导他们通过游戏挑战都是至关重要的。
- en: Moreover, feedback extends to storytelling in games. Choices you make should
    have consequences, and the game should let you know how your decisions impact
    the story. Effective feedback creates a dynamic connection between the player
    and the game world, making every action feel meaningful. Whether it’s triumphant
    music after a successful quest or a subtle change in the environment based on
    your decisions, feedback adds depth to the gaming experience, ensuring players
    stay engaged and invested in the virtual world they’re exploring.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，反馈还扩展到游戏中的叙事。你做出的选择应该有后果，游戏应该让你知道你的决定如何影响故事。有效的反馈在玩家和游戏世界之间建立了一种动态的联系，使每个动作都感觉有意义。无论是成功任务后的胜利音乐，还是根据你的决定在环境中发生的微妙变化，反馈都为游戏体验增添了深度，确保玩家保持参与并投入到他们正在探索的虚拟世界中。
- en: Player agency
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玩家能动性
- en: '**Player agency** is like having a steering wheel in a game – you get to make
    choices and have control over your virtual adventure. In *The Elder Scrolls V:
    Skyrim*, this principal shines brightly. Right from the start, you decide who
    your character is going to be. Do you want to be a brave warrior, a sneaky thief,
    or a powerful wizard? The game doesn’t force you down a specific path; instead,
    it lets you carve out your own story.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家自主权**就像在游戏中拥有方向盘——你可以做出选择并控制你的虚拟冒险。在《上古卷轴V：天际》中，这一原则非常突出。从一开始，你就决定你的角色将成为谁。你想要成为一个勇敢的战士、一个狡猾的小偷，还是一个强大的法师吗？游戏不会强迫你走一条特定的道路；相反，它让你自己塑造自己的故事。'
- en: This freedom to make choices extends beyond character creation. As you progress
    through the game, you encounter various quests and challenges, and here, again,
    player agency takes center stage. You can decide how to approach a situation –
    do you want to negotiate, fight, or sneak past enemies? Your choices influence
    not just the immediate outcome but also the overall story. Your version of *Skyrim*
    might be entirely different from someone else’s because player agency allows for
    diverse experiences.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种选择自由不仅限于角色创建。随着你在游戏中前进，你会遇到各种任务和挑战，在这里，玩家自主权再次成为焦点。你可以决定如何应对情况——你想谈判、战斗还是悄悄绕过敌人？你的选择不仅影响直接的结果，还影响整个故事。你的《上古卷轴V：天际》版本可能与别人的完全不同，因为玩家自主权允许多样化的体验。
- en: Having player agency transforms a game into more than just a set path with predetermined
    outcomes. It transforms it into your story, where your decisions matter, and the
    game adapts to your choices. This sense of control and the ability to shape your
    unique adventure is what makes player agency a key principle in creating immersive
    and personally meaningful gaming experiences.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有玩家自主权将游戏转变为不仅仅是预设结果的固定路径。它将其转变为你的故事，你的决定至关重要，游戏会适应你的选择。这种控制感和塑造独特冒险的能力使得玩家自主权成为创造沉浸式和具有个人意义的游戏体验的关键原则。
- en: In the following section, we are going to understand the relationship between
    code and game mechanics.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解代码和游戏机制之间的关系。
- en: The connection between code and game mechanics
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码与游戏机制之间的联系
- en: Now, here’s the cool part – the code is what turns ideas into action in the
    game. It’s like a rulebook that tells the game what to do. If you want to create
    a game where players can shoot lasers, you’d write code to make it happen. So,
    the relationship between code and game mechanics is like a chef’s recipe for a
    delicious meal – the code guides the game to do exactly what we want.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里有个有趣的部分——代码是将想法转化为游戏行动的关键。它就像一本规则手册，告诉游戏该做什么。如果你想创建一个玩家可以射击激光的游戏，你需要编写代码来实现。因此，代码和游戏机制之间的关系就像厨师为美味佳肴准备的食谱——代码引导游戏做到我们想要的样子。
- en: Understanding these coding basics is like having the keys to the game-making
    kingdom. It allows you to bring your game ideas to life and create all sorts of
    cool stuff. Plus, the more you understand C#, the more you can make your games
    do awesome things. So, get ready to dive into the world of coding in this chapter
    – it’s not as tricky as it sounds, and it’s the secret sauce that makes games
    so much fun to play!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些编码基础就像是拥有了游戏制作王国的钥匙。它让你能够将你的游戏想法变为现实，并创造出各种酷炫的东西。此外，你越了解C#，你就能让你的游戏做更多令人惊叹的事情。所以，准备好进入本章的编码世界吧——它并没有听起来那么复杂，而且是让游戏如此有趣的关键因素！
- en: Implementing player behavior and AI logic using C#
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C#实现玩家行为和AI逻辑
- en: In this section, we’ll be getting into how games are made, looking at how players
    act and how computer-controlled characters (we call it AI) think in games. Figuring
    out how players act and how game characters react is a big deal in making games
    fun. It’s like giving players a script to follow, just like actors in a play.
    Players bring the game to life, a bit like how actors make a story interesting.
    We’ll look at different types of games, checking out how players act in all sorts
    of situations, from big adventures to tactical fights.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨游戏是如何制作的，观察玩家在游戏中的行为以及计算机控制的角色（我们称之为AI）是如何思考的。弄清楚玩家的行为和游戏角色的反应是制作有趣游戏的关键。这就像给玩家一个剧本去遵循，就像戏剧中的演员一样。玩家让游戏变得生动，有点像演员使故事变得有趣。我们将探讨不同类型的游戏，检查玩家在各种情况下的行为，从大冒险到战术战斗。
- en: Then, we’ll check out AI, the smart computer stuff that makes game enemies,
    friends, and other characters feel real. AI isn’t just code; it’s like magic that
    makes challenges exciting, enemies tricky, and friends helpful. We’ll explain
    the basic ideas behind this digital magic, kind of like understanding the cues
    a conductor gives to an orchestra, guiding all the actions and reactions in a
    game.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将检查AI，这是制作游戏中的敌人、朋友和其他角色感觉真实的智能计算机技术。AI不仅仅是代码；它就像魔法，使挑战变得有趣，敌人变得狡猾，朋友变得有帮助。我们将解释这种数字魔法的背后基本理念，有点像理解指挥家给管弦乐队提供的提示，引导游戏中的所有行动和反应。
- en: So, we’re on a journey to make player behavior and AI logic less mysterious
    using C# – a fancy way to talk to computers. You’ll be all set to make games that
    feel real, keeping players interested and making your game super exciting!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们正踏上使用C#——一种与计算机交流的时髦方式——使玩家行为和AI逻辑更不神秘的旅程。你将准备好制作感觉真实的游戏，保持玩家的兴趣，让你的游戏超级刺激！
- en: '**Understanding player behavior design**: In the realm of player behavior design,
    crafting a responsive game involves the fundamental aspect of **health management**.
    **Health**, being a universal concept for both players and enemies, is a core
    behavior that greatly influences the overall gaming experience. To achieve a modular
    and extensible system, we must introduce an **IHealth** interface that encapsulates
    essential functions, such as tracking maximum health, current health, taking damage,
    and healing. By adopting this interface, we can establish a unified approach to
    health management that applies to both players and enemies. This not only streamlines
    the code base but also allows for easy expansion and modification as the game
    evolves.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解玩家行为设计**：在玩家行为设计的领域，制作一个反应灵敏的游戏涉及到**健康管理**这一基本方面。**健康**，作为一个既适用于玩家也适用于敌人的通用概念，是极大地影响整体游戏体验的核心行为。为了实现一个模块化和可扩展的系统，我们必须引入一个**IHealth**接口，它封装了基本功能，例如跟踪最大健康值、当前健康值、受到伤害和恢复健康。通过采用这个接口，我们可以建立一个统一的方法来管理健康，这适用于玩家和敌人。这不仅简化了代码库，还允许随着游戏的演变轻松地进行扩展和修改。'
- en: '**Shooting mechanics**: In addition to health, we’ll delve into shooting mechanics,
    a pivotal player behavior in a shooting game. Rather than a simplistic shooting
    script, we’ll opt for a modular approach, creating separate components for bullets,
    projectiles, and weapons. This modular design enables flexibility and scalability,
    making it easier to introduce new weapons, tweak projectile behaviors, and enhance
    overall gameplay dynamics.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**射击机制**：除了健康之外，我们还将深入研究射击机制，这是射击游戏中一个关键玩家行为。我们不会选择一个简单的射击脚本，而是采用模块化方法，为子弹、弹丸和武器创建单独的组件。这种模块化设计提供了灵活性和可扩展性，使得引入新武器、调整弹丸行为和增强整体游戏动态变得更加容易。'
- en: '**Introduction to AI logic**: Transitioning to AI logic, we’ll explore fundamental
    concepts that breathe life into in-game adversaries. Basic AI principles encompass
    understanding the role of AI in creating dynamic and challenging gameplay. The
    AI system becomes a crucial component in determining enemy behaviors, ranging
    from simple wandering to complex attack patterns. By delving into these concepts,
    we’ll gain insights into the decision-making processes that drive AI-controlled
    entities, contributing to the overall richness of the gaming experience.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AI逻辑简介**：过渡到AI逻辑，我们将探讨赋予游戏中的敌人生命力的基本概念。基本的AI原则包括理解AI在创造动态和具有挑战性的游戏中的作用。AI系统成为决定敌人行为的关键组件，从简单的游荡到复杂的攻击模式。通过深入研究这些概念，我们将了解驱动AI控制实体的决策过程，从而丰富游戏体验的整体丰富性。'
- en: '**Coding player behavior and AI**: Moving from theory to practice, we’ll embark
    on the practical implementation of player behavior and AI logic using C# scripts.
    The **IHealth** and **IDamage** interfaces become the cornerstone for implementing
    health-related functionalities, ensuring a consistent and manageable approach
    across diverse game elements. The modular shooting system will take shape as we
    learn to handle bullets, projectiles, and weapons separately, promoting code reusability
    and maintainability.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编码玩家行为和AI**：从理论转向实践，我们将开始使用C#脚本实现玩家行为和AI逻辑的实际应用。**IHealth**和**IDamage**接口成为实现与健康相关的功能的基础，确保在多样化的游戏元素中保持一致和可管理的做法。随着我们学会分别处理子弹、弹丸和武器，模块化的射击系统将形成，这促进了代码的可重用性和可维护性。'
- en: To reinforce learning, we’ll engage in hands-on demonstrations, showcasing the
    step-by-step creation of C# scripts for player behavior and AI logic in the subsequent
    sections. We’ll gain proficiency in designing and implementing responsive player
    behaviors, fostering an understanding of how to bring dynamic AI characters to
    life within the Unity game development environment.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加强学习，我们将在接下来的章节中进行实际操作演示，展示创建用于玩家行为和AI逻辑的C#脚本的逐步过程。我们将熟练掌握设计和实现响应式玩家行为，并了解如何在Unity游戏开发环境中使动态AI角色栩栩如生。
- en: Let’s start by writing the `IHealth` interface and establishing the fundamental
    logic for it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写`IHealth`接口并建立其基本逻辑开始。
- en: Writing the IHealth and IDamage interfaces
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写IHealth和IDamage接口
- en: 'In the following code block, we’ve introduced the `IHealth` interface, which
    incorporates properties for maximum and current health, along with essential functions
    for setting maximum health, inflicting damage, and facilitating healing. Here,
    we’ll create an interface to manage the health logic throughout the entire game.
    I’ve designed it so that it oversees the health of each entity once they implement
    this interface. This approach will simplify communication between entities and
    prove beneficial when we also create the `IDamage` interface. Implementing `IDamage`
    in components responsible for dealing damage will allow us to affect the health
    component seamlessly:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们引入了`IHealth`接口，该接口包含最大和当前健康属性，以及设置最大健康、造成伤害和促进治疗的必要函数。在这里，我们将创建一个接口来管理整个游戏中的健康逻辑。我设计它，以便一旦实体实现此接口，它就会监督每个实体的健康。这种方法将简化实体之间的通信，并在我们创建`IDamage`接口时证明是有益的。在负责造成伤害的组件中实现`IDamage`将使我们能够无缝地影响健康组件：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we will create the `IDamage` interface, which will feature a central
    function for dealing damage. Subsequent classes will implement this interface,
    handling damage calculations internally and conveying the resulting damage value
    to other classes, as demonstrated in the following code block:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建`IDamage`接口，它将包含一个处理伤害的中心函数。后续的类将实现此接口，内部处理伤害计算，并将结果伤害值传递给其他类，如下面的代码块所示：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we must integrate the `IHealth` interface into the player. Therefore,
    we will generate the `PlayerHealth` component and affix it to the player’s `GameObject`.
    The `PlayerHealth` class will manage all functions related to the player’s health,
    including setting the maximum health and processing damage. When the player’s
    health falls to zero or below, the player dies. It’s designed as a separate class
    that you attach to the player’s GameObject, facilitating communication with enemies,
    as illustrated in the following code block:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须将`IHealth`接口集成到玩家中。因此，我们将生成`PlayerHealth`组件并将其附加到玩家的`GameObject`上。`PlayerHealth`类将管理与玩家健康相关的所有功能，包括设置最大健康和处理伤害。当玩家的健康降至零或以下时，玩家死亡。它被设计为一个独立的类，你可以将其附加到玩家的GameObject上，以便与敌人进行通信，如下面的代码块所示：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, I’ve included the required variables related to the
    player’s health and healing. Additionally, a coroutine will ensure the player
    heals gradually within the `PlayerHealth` class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我包含了与玩家健康和治疗相关的必需变量。此外，一个协程将确保玩家在`PlayerHealth`类中逐渐恢复健康：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s take a look at the preceding code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面的代码：
- en: '**OnDestroy**: This method ensures that the healing coroutine is stopped when
    the player object is destroyed to prevent memory leaks'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**销毁时**：此方法确保在玩家对象被销毁时停止治疗协程，以防止内存泄漏'
- en: '**Start**: This method initializes the player’s health parameters, sets their
    maximum health, creates a **WaitForSeconds** instance for healing intervals, and
    starts the healing coroutine:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始**：此方法初始化玩家的健康参数，设置其最大健康值，创建用于治疗间隔的**WaitForSeconds**实例，并启动治疗协程：'
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s break down the preceding code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析前面的代码：
- en: '**TakeDamage**: This method handles the logic for deducting health from the
    player when they take damage. It also checks if the player’s health has reached
    zero, triggering the **onPlayerDied** event if necessary.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受到伤害**：此方法处理玩家受到伤害时扣除健康的逻辑。它还会检查玩家的健康是否已达到零，如果需要，触发**onPlayerDied**事件。'
- en: '**SetMaxHealth**: This method sets the maximum health of the player to the
    specified starting maximum health value.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置最大健康**：此方法将玩家的最大健康设置为指定的起始最大健康值。'
- en: '**Heal**: This method restores the player’s health. It increments the current
    health by the specified healing amount and ensures that the player’s current health
    does not exceed the maximum health.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Heal**：这个方法恢复玩家的健康。它通过指定的治疗量增加当前健康值，并确保玩家的当前健康值不超过最大健康值。'
- en: '**StartHealingOverTime**: This method initiates the healing coroutine that’s
    responsible for gradually restoring the player’s health over time.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**StartHealingOverTime**：这个方法启动负责在一段时间内逐渐恢复玩家健康的协程。'
- en: '**HealOverTime**: This coroutine runs indefinitely, waiting for the specified
    healing interval and then invoking the **Heal** method to restore the player’s
    health.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HealOverTime**：这个协程无限期地等待指定的治疗间隔，然后调用**Heal**方法来恢复玩家的健康。'
- en: 'Now, let’s examine the `PlayerCollision` component and understand how the player
    incurs damage. The following code block demonstrates the process of the player
    taking damage either directly from the enemy or from their projectiles. This class
    acts as a bridge between the player’s health component and the `IDamage` interface
    of the colliding object. We can utilize `PlayerHealth` and obtain damage through
    the `IDamage` interface by using the `OnCollisionEnter` method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查`PlayerCollision`组件，了解玩家如何受到伤害。以下代码块展示了玩家直接从敌人或其投射物受到伤害的过程。这个类充当玩家健康组件和碰撞对象`IDamage`接口之间的桥梁。我们可以利用`PlayerHealth`并通过使用`OnCollisionEnter`方法通过`IDamage`接口获取伤害：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let’s look at the different variables we used here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这里使用的不同变量：
- en: '**private PlayerHealth playerHealth;**: This is a reference to the **PlayerHealth**
    component that’s attached to the same GameObject. This component manages the health
    of the player.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**private PlayerHealth playerHealth;**：这是同一GameObject上附加的**PlayerHealth**组件的引用。该组件管理玩家的健康。'
- en: '**private IDamage enemyDamage;**: This is an interface reference for handling
    damage inflicted by enemies or enemy projectiles.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**private IDamage enemyDamage;**：这是一个处理敌人或敌人投射物造成的伤害的接口引用。'
- en: '**Start**: This method retrieves the **PlayerHealth** component that’s attached
    to the same GameObject during initialization.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Start**：这个方法在初始化期间检索附加到同一GameObject上的**PlayerHealth**组件。'
- en: '**OnCollisionEnter**: This method is invoked automatically when a collision
    occurs that involves the GameObject. It checks if the collision involves an enemy
    or an enemy projectile by comparing tags. If the collision involves an enemy or
    an enemy projectile, it attempts to retrieve the **IDamage** component from the
    colliding object using **TryGetComponent**. If successful, it invokes the **TakeDamage**
    method of the **PlayerHealth** component to apply damage to the player’s health.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnCollisionEnter**：当发生涉及GameObject的碰撞时，这个方法会自动调用。它通过比较标签来检查碰撞是否涉及敌人或敌人投射物。如果碰撞涉及敌人或敌人投射物，它将尝试使用**TryGetComponent**从碰撞对象中检索**IDamage**组件。如果成功，它将调用**PlayerHealth**组件的**TakeDamage**方法来对玩家的健康造成伤害。'
- en: Overall, this script handles collisions between the player character and enemy
    entities or enemy projectiles. Upon collision, it retrieves the damage value from
    the colliding object and applies it to the player’s health, ensuring proper damage
    management in the game.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，这个脚本处理玩家角色与敌人实体或敌人投射物的碰撞。碰撞发生时，它会从碰撞对象中检索伤害值并将其应用于玩家的健康，确保游戏中的伤害管理得当。
- en: In the next section, we will explore how the player engages in shooting enemies.
    However, before delving into that, we’ll implement a shoot system to ensure both
    the player and the enemy can make use of it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨玩家如何射击敌人。然而，在深入探讨之前，我们将实现一个射击系统，以确保玩家和敌人都能使用它。
- en: Implementing a shoot system
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现射击系统
- en: In this section, we’ll create classes for shooting. Here, we’ll incorporate
    the `IDamage` interface into the `BaseProjectile` class, which serves as the foundation
    for all ammunition types. This allows us to compute the damage that will be applied
    to the health component.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建用于射击的类。在这里，我们将`IDamage`接口纳入`BaseProjectile`类中，该类作为所有弹药类型的基石。这允许我们计算将应用于健康组件的伤害。
- en: 'In the following code block, we’re configuring the damage value, which will
    be calculated for the player or enemies. This is a general system that can be
    applied to all objects:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码块中，我们正在配置伤害值，这将用于玩家或敌人。这是一个适用于所有对象的通用系统：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s look at the variables that were used here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里使用的变量：
- en: '**private float damage;**: This variable stores the damage value associated
    with the projectile.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**private float damage**；这个变量存储与弹体相关的伤害值。'
- en: '**public virtual void SetDamageValue(float value)**: This method allows subclasses
    to set the damage value for the projectile. It takes a float parameter value representing
    the damage to be set. When called, it assigns the provided value to the damage
    variable. The **virtual** keyword indicates that this method can be overridden
    by subclasses to provide specialized behavior if needed.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public virtual void SetDamageValue(float value)**：这个方法允许子类为弹体设置伤害值。它接受一个表示要设置的伤害的浮点参数`value`。当被调用时，它将提供的值分配给伤害变量。**virtual**关键字表示此方法可以被子类重写，以提供所需的专业行为。'
- en: '**GetDamageValue Method**: This method retrieves the damage value of the projectile.
    It simply returns the value stored in the damage variable.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GetDamageValue 方法**：这个方法检索弹体的伤害值。它简单地返回存储在伤害变量中的值。'
- en: Overall, this abstract class provides a blueprint for projectile objects in
    the game. Subclasses can inherit from this class and customize the behavior of
    projectiles by overriding the `SetDamageValue` method or adding additional functionality
    as needed. The `GetDamageValue` method allows other game components to access
    the damage value of projectiles when needed, enabling consistent damage handling
    throughout the game.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这个抽象类为游戏中的弹体对象提供了一个蓝图。子类可以继承这个类，并通过重写`SetDamageValue`方法或添加所需的其他功能来自定义弹体的行为。`GetDamageValue`方法允许其他游戏组件在需要时访问弹体的伤害值，从而在整个游戏中实现一致的伤害处理。
- en: Next, we can create the `BaseWeapon` script, which is versatile enough to be
    utilized by both players and enemies, considering that enemies will also possess
    weapons. Each weapon will be associated with an attached projectile, allowing
    for the creation of various projectile types.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建`BaseWeapon`脚本，它足够灵活，可以被玩家和敌人使用，考虑到敌人也将拥有武器。每个武器都将关联一个附加的弹体，从而允许创建各种弹体类型。
- en: Additionally, there is the concept of `weaponPower`, a variable that varies
    from one weapon to another, influencing the applied damage. `muzzleTransform`
    serves as the point for shooting projectiles, and `projectileForce` dictates the
    movement of the projectile.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个名为`weaponPower`的概念，这是一个变量，它因武器而异，影响施加的伤害。`muzzleTransform`作为射击弹体的点，而`projectileForce`决定了弹体的运动。
- en: 'Lastly, we must define the `Shoot` function, as illustrated in the following
    code block:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须定义`Shoot`函数，如下面的代码块所示：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s look at the serialized fields:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看序列化字段：
- en: '**protected BaseProjectile attachedProjectile**: This refers to the type of
    projectile attached to the weapon. It is serialized to allow assignment in Unity’s
    **Inspector** view.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**protected BaseProjectile attachedProjectile**：这指的是附加到武器上的弹体类型。它被序列化，以便在Unity的**Inspector**视图中进行赋值。'
- en: '**protected float weaponPower**: This refers to the power of the weapon. It
    is serialized to allow for adjustments in the **Inspector** view.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**protected float weaponPower**：这指的是武器的功率。它被序列化，以便在**Inspector**视图中进行调整。'
- en: '**protected Transform muzzleTransform**: This refers to the position where
    projectiles spawn, typically the muzzle of the weapon.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**protected Transform muzzleTransform**：这指的是弹体生成的位置，通常是武器的枪口。'
- en: '**protected float projectileForce**: This refers to the force that’s applied
    to the projectile when it’s shot from the weapon.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**protected float projectileForce**：这指的是当弹体从武器射出时施加的力。'
- en: '**Shoot**: This method is responsible for shooting the weapon. First, it attempts
    to get a pooled projectile object from Object Pool Manager. If a projectile object
    is retrieved, it sets its position to the muzzle of the weapon and adds force
    to propel it forward. This method also modifies the fire damage by adding the
    weapon’s power to it. Finally, it applies the modified damage and any other logic
    to the projectile, potentially by implementing an **IDamage** interface.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Shoot**：这个方法负责射击武器。首先，它尝试从对象池管理器中获取一个池化的弹体对象。如果检索到弹体对象，它将设置其位置为武器的枪口，并添加力以推动它向前。此方法还通过添加武器的功率来修改火灾伤害。最后，它将修改后的伤害和任何其他逻辑应用于弹体，可能通过实现**IDamage**接口。'
- en: Overall, this abstract class provides a foundation for implementing different
    types of weapons in the game. Subclasses can inherit from this class to create
    specific weapon types and customize their behavior as needed. The `Shoot` method
    handles the spawning and firing of projectiles, allowing for flexible and dynamic
    weapon functionality.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这个抽象类为在游戏中实现不同类型的武器提供了一个基础。子类可以继承这个类来创建特定的武器类型并按需自定义其行为。`Shoot` 方法处理项目的生成和发射，允许灵活和动态的武器功能。
- en: 'The following code block provides an example of utilizing `BaseWeapon` with
    the `SimpleGun` class. We’re going to use it with the player for shooting enemies,
    so it will be used as the player’s weapon:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块提供了一个使用 `BaseWeapon` 和 `SimpleGun` 类的示例。我们将用它来让玩家射击敌人，因此它将作为玩家的武器使用：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s break down the code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: '**SimpleGun**: This class represents a specific type of gun in the game. It
    inherits from the **BaseWeapon** class, indicating that it shares characteristics
    and functionality with other weapons but may have specialized behavior.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SimpleGun**：这个类代表游戏中的一种特定类型的枪。它继承自 **BaseWeapon** 类，表明它与其他武器共享特性和功能，但可能具有特定的行为。'
- en: '**Override Shoot**:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Override Shoot**：'
- en: '**public override void Shoot(float fireDamage)**: This method overrides the
    **Shoot** method defined in the **BaseWeapon** class'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public override void Shoot(float fireDamage)**：此方法覆盖了在 **BaseWeapon** 类中定义的
    **Shoot** 方法'
- en: The **base.Shoot(fireDamage)** statement calls the **Shoot** method from the
    base class (**BaseWeapon**), allowing the gun to perform the standard shooting
    behavior defined in the base class
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**base.Shoot(fireDamage)** 语句调用了基类（**BaseWeapon**）中的 **Shoot** 方法，允许枪支执行在基类中定义的标准射击行为'
- en: In summary, the `SimpleGun` class extends the functionality of the `BaseWeapon`
    class by providing its own implementation of the `Shoot` method. This allows for
    specialized behavior while leveraging the common functionality provided by the
    base class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`SimpleGun` 类通过提供自己的 `Shoot` 方法实现扩展了 `BaseWeapon` 类的功能。这允许在利用基类提供的通用功能的同时实现特定的行为。
- en: 'Now, let’s present the `PlayerShoot` component, which encompasses the shooting
    logic. In this context, the player awaits input actions and possesses the current
    weapon. In [*Chapter 6*](B22017_06.xhtml#_idTextAnchor098), which focuses on data
    handling, we’ll create scriptable objects for weapon statistics. This way, we
    can substitute the weapon’s power with the weapon’s stats, utilizing the power
    derived from it. We can also make different stats for the same weapon, as illustrated
    in the following code block:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们介绍 `PlayerShoot` 组件，它包含了射击逻辑。在这个上下文中，玩家等待输入动作并拥有当前武器。在 [*第6章*](B22017_06.xhtml#_idTextAnchor098)，该章节专注于数据处理，我们将为武器统计数据创建可脚本化的对象。这样，我们可以用武器的统计数据替换武器的力量，利用从它那里衍生出的力量。我们还可以为同一武器设置不同的统计数据，如下面的代码块所示：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s break down the preceding code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解前面的代码：
- en: '**onFire Event**:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onFire 事件**：'
- en: '**public static UnityAction onFire = delegate { };**: This static event is
    triggered whenever the player fires a shot. Other scripts can subscribe to this
    event to perform actions when the player shoots.'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public static UnityAction onFire = delegate { };**：这个静态事件在玩家射击时被触发。其他脚本可以订阅此事件，以便在玩家射击时执行操作。'
- en: '**Serialized fields**:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列化字段**：'
- en: '**currentWeapon**: This field holds a reference to the current weapon the player
    is using'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**currentWeapon**：此字段持有玩家当前使用的武器的引用'
- en: '**fireDamage**: This field represents the damage value of the player’s shots'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fireDamage**：此字段表示玩家射击的伤害值'
- en: '**shootingInterval**: This field specifies the time interval between consecutive
    shots'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**shootingInterval**：此字段指定了连续射击之间的时间间隔'
- en: '**Event subscriptions**:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件订阅**：'
- en: '**OnEnable()**: Subscribes the **OnShootFire** method to the **onShoot** event
    when the object is enabled'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnEnable()**：当对象启用时，将 **OnShootFire** 方法订阅到 **onShoot** 事件'
- en: '**OnDisable()**: Unsubscribes the **OnShootFire** method from the **onShoot**
    event when the object is disabled'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnDisable()**：当对象禁用时，从 **onShoot** 事件中取消订阅 **OnShootFire** 方法'
- en: '**OnShootFire**: This method is invoked when the player performs a shoot action
    (**onShoot event**). It checks if enough time has passed since the last shot.
    If so, it triggers the **Shoot** method of the current weapon, resets the shot
    timer, and invokes the **onFire** event.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnShootFire**：此方法在玩家执行射击动作（**onShoot 事件**）时被调用。它检查自上次射击以来是否已经过去了足够的时间。如果是这样，它将触发当前武器的
    **Shoot** 方法，重置射击计时器，并调用 **onFire** 事件。'
- en: Overall, the `PlayerShoot` class facilitates player shooting mechanics by controlling
    the shooting interval, managing events for shooting actions, and delegating the
    shooting logic to the current weapon.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，`PlayerShoot`类通过控制射击间隔、管理射击动作的事件以及将射击逻辑委托给当前武器来促进玩家的射击机制。
- en: Note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure that you assign distinct tags to projectiles associated with both
    the player and the enemies. This prevents conflicts when they collide with each
    other.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 确保为与玩家和敌人相关的弹道分配不同的标签。这可以防止它们相互碰撞时发生冲突。
- en: Currently, the player possesses the capability to both shoot and endure damage.
    In the following subsection, we will delve into the AI logic for our game.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，玩家具有射击和承受伤害的能力。在下一小节中，我们将深入探讨我们游戏的AI逻辑。
- en: Delving into the AI logic
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入AI逻辑
- en: Welcome to the world of **AI logic**! In this section, we’ll explore the algorithms
    and decision-making processes that bring intelligence to our game characters.
    We’ll discover how AI logic enhances navigation, strategy, and dynamic interactions,
    elevating the overall gaming experience. Join us as we unravel the secrets behind
    crafting smart behaviors for a more immersive virtual world. Plus, we’ll delve
    into the implementation of a finite state machine to create distinct states for
    all enemies, allowing seamless transitions between behaviors.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到**AI逻辑**的世界！在本节中，我们将探讨将智能带入游戏角色的算法和决策过程。我们将了解AI逻辑如何增强导航、策略和动态交互，提升整体游戏体验。加入我们，一起揭开为更沉浸式虚拟世界构建智能行为的秘密。此外，我们将深入研究有限状态机的实现，为所有敌人创建不同的状态，实现行为之间的无缝转换。
- en: 'In the upcoming steps, we’ll integrate the `NavMesh` package into our project.
    However, before delving into AI logic, it’s essential to include the navigation
    package in the project. Follow these steps to do so:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将把`NavMesh`包集成到我们的项目中。然而，在深入AI逻辑之前，将导航包包含到项目中是至关重要的。按照以下步骤操作：
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before Unity 2022, navigation was pre-implemented; however, starting from Unity
    2022, it must be added via Package Manager.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity 2022之前，导航是预实现的；然而，从Unity 2022开始，必须通过包管理器添加。
- en: 'Access **Package Manager** to install the **AI Navigation** package, as shown
    in *Figure 4**.1*:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过**包管理器**安装**AI导航**包，如图*图4*.1*所示：
- en: '![Figure 4.1 – Installing AI Navigation via Package Manager](img/B22017_04_01.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 通过包管理器安装AI导航](img/B22017_04_01.jpg)'
- en: Figure 4.1 – Installing AI Navigation via Package Manager
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 通过包管理器安装AI导航
- en: 'Following the installation, you’ll notice a new menu that allows you to toggle
    the visibility of **NavMesh** surfaces and access other options concerning **AI
    Navigation**. This menu is integrated into the *scene toolbar*, as illustrated
    in *Figure 4**.2*:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，您会注意到一个新菜单，该菜单允许您切换**NavMesh**表面的可见性并访问其他关于**AI导航**的选项。此菜单集成在*场景工具栏*中，如图*图4*.2*所示。2*：
- en: '![Figure 4.2 – The AI Navigation menu in the Scene view](img/B22017_04_02.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 场景视图中的AI导航菜单](img/B22017_04_02.jpg)'
- en: Figure 4.2 – The AI Navigation menu in the Scene view
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 场景视图中的AI导航菜单
- en: Additional reading
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读
- en: 'You can explore the **AI Navigation** settings or find more information in
    the official Unity documentation: [https://docs.unity3d.com/Packages/com.unity.ai.navigation@1.1/manual/index.html](https://docs.unity3d.com/Packages/com.unity.ai.navigation@1.1/manual/index.html).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以探索**AI导航**设置或在官方Unity文档中查找更多信息：[https://docs.unity3d.com/Packages/com.unity.ai.navigation@1.1/manual/index.html](https://docs.unity3d.com/Packages/com.unity.ai.navigation@1.1/manual/index.html)。
- en: 'To begin utilizing this feature, we’ll need to incorporate a **NavMesh Surface**
    property into the scene. You can choose this from the **Create** menu, as shown
    in *Figure 4**.3*:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始使用此功能，我们需要将一个**NavMesh Surface**属性集成到场景中。您可以从**创建**菜单中选择，如图*图4*.3*所示：
- en: '![Figure 4.3 – Choosing NavMesh Surface from the Create menu](img/B22017_04_03.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 从创建菜单中选择NavMesh Surface](img/B22017_04_03.jpg)'
- en: Figure 4.3 – Choosing NavMesh Surface from the Create menu
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 从创建菜单中选择NavMesh Surface
- en: 'Subsequently, **NavMesh Surface** will be included, at which point you can
    proceed to **Bake** the surface. This refers to the process of precomputing and
    storing navigation data for AI pathfinding, as demonstrated in *Figure 4**.4*:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随后，**NavMesh Surface**将被包含，此时您可以继续**烘焙**表面。这指的是预先计算并存储导航数据以供AI路径查找的过程，如图*图4*.4*所示：
- en: '![Figure 4.4 – The Bake action in the NavMeshSurface component](img/B22017_04_04.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.4 – NavMeshSurface 组件中的 Bake 操作](img/B22017_04_04.jpg)'
- en: Figure 4.4 – The Bake action in the NavMeshSurface component
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – NavMeshSurface 组件中的 Bake 操作
- en: Note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before initiating the baking process, it’s crucial to remove the player and
    dynamic objects to prevent the creation of empty spaces in the resulting baking.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始烘焙过程之前，移除玩家和动态对象至关重要，以防止在最终烘焙中创建空隙。
- en: 'You can also include additional AI agents by navigating to the **Navigation**
    tab under **Window** in the top bar. Choose **AI** and then **Navigation**, avoiding
    the **Navigation (Obsolete)** option, as illustrated in *Figure 4**.5*:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您也可以通过在顶部栏的 **Window** 下的 **Navigation** 选项卡中导航来包含额外的 AI 代理。选择 **AI** 然后选择 **Navigation**，避免选择
    **Navigation (Obsolete)** 选项，如图 *图 4.5* 所示：
- en: '![Figure 4.5 – Selecting Navigation](img/B22017_04_05.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.5 – 选择导航](img/B22017_04_05.jpg)'
- en: Figure 4.5 – Selecting Navigation
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 选择导航
- en: 'In the **Navigation** tab, you have the option to include more **Agents** with
    various settings, allowing for increased diversity in enemy behavior, as depicted
    in *Figure 4**.6*:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Navigation** 选项卡中，您可以选择包含更多具有各种设置的 **代理**，从而增加敌人行为的多样性，如图 *图 4.6* 所示：
- en: '![Figure 4.6 – Adding more agents via the Navigation tab](img/B22017_04_06.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.6 – 通过导航选项卡添加更多代理](img/B22017_04_06.jpg)'
- en: Figure 4.6 – Adding more agents via the Navigation tab
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 通过导航选项卡添加更多代理
- en: 'Additionally, you have the flexibility to introduce more **Areas**, providing
    variations in your gameplay. As shown in the following screenshot, you can designate
    areas as **Walkable**, **Not Walkable**, or even as **Jump** areas, tailoring
    them to the specific requirements of your game:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，您还有灵活性引入更多的 **区域**，为您的游戏提供不同的玩法。如图所示，您可以将区域指定为 **可通行**、**不可通行**，甚至作为 **跳跃**
    区域，以适应您游戏的具体需求：
- en: '![Figure 4.7 – Areas in the Navigation tab](img/B22017_04_07.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.7 – 导航选项卡中的区域](img/B22017_04_07.jpg)'
- en: Figure 4.7 – Areas in the Navigation tab
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 导航选项卡中的区域
- en: 'Now that we’ve familiarized ourselves with adding additional areas or agents,
    we won’t be making further modifications to them. I’ve mentioned them for informational
    purposes only. Now, let’s proceed with integrating AI into our game. To do so,
    we must attach the **Nav Mesh Agent** component to the enemies to enable navigation,
    as illustrated in *Figure 4**.8*. We have the flexibility to adjust values tailored
    to our game, such as changing the speed and when the AI will stop when the AI
    has reached its goal. For further details, please refer to the official *Unity
    documentation*:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了添加额外的区域或代理，我们不会对它们进行进一步修改。我仅提及它们作为信息。现在，让我们继续将 AI 集成到我们的游戏中。为此，我们必须将
    **Nav Mesh Agent** 组件附加到敌人上以启用导航，如图 *图 4.8* 所示。我们有灵活性调整适合我们游戏的值，例如更改速度和 AI 达到目标时停止的条件。有关更多详细信息，请参阅官方
    *Unity 文档*：
- en: '![Figure 4.8 – The Nav Mesh Agent component for one of the enemies](img/B22017_04_08.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.8 – 敌人之一的 Nav Mesh Agent 组件](img/B22017_04_08.jpg)'
- en: Figure 4.8 – The Nav Mesh Agent component for one of the enemies
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 敌人之一的 Nav Mesh Agent 组件
- en: After installing the package, we’ll kick off the AI logic. We’ll begin by establishing
    the `BaseEnemy` class and laying down the foundation for the state system since
    we intend to construct a finite state machine.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 安装包后，我们将启动 AI 逻辑。我们将首先建立 `BaseEnemy` 类，并为状态系统打下基础，因为我们打算构建一个有限状态机。
- en: 'Let’s start with the interface for states. The foundational structure is provided
    in the following code block:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从状态接口开始。以下代码块提供了基础结构：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s take a closer look at this code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这段代码：
- en: '**void** **EnterState(BaseEnemy enemy)**:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**void** **EnterState(BaseEnemy enemy)**:'
- en: This method is responsible for setting up the initial conditions and behaviors
    when the enemy enters this state. It takes a **BaseEnemy** object as a parameter,
    allowing us to access the enemy’s properties and methods.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法负责在敌人进入此状态时设置初始条件和行为。它接受一个 **BaseEnemy** 对象作为参数，使我们能够访问敌人的属性和方法。
- en: '**void** **UpdateState(BaseEnemy enemy)**:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**void** **UpdateState(BaseEnemy enemy)**:'
- en: This method is called repeatedly while the enemy is in this state. It defines
    the logic and actions that the enemy should perform during this state. Again,
    it takes a **BaseEnemy** object as a parameter to manipulate the enemy’s behavior.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法在敌人处于此状态时重复调用。它定义了敌人在此状态下应执行的逻辑和动作。同样，它接受一个 **BaseEnemy** 对象作为参数来操纵敌人的行为。
- en: '**void** **ExitState(BaseEnemy enemy)**:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**void** **ExitState(BaseEnemy enemy)**:'
- en: This method is called when the enemy exits this state. It is responsible for
    cleaning up any resources or resetting any variables associated with this state.
    As with the other methods, it also accepts a **BaseEnemy** object parameter.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当敌人退出此状态时，将调用此方法。它负责清理任何资源或重置与此状态相关的任何变量。与其他方法一样，它也接受一个 **BaseEnemy** 对象参数。
- en: By implementing this interface, different classes representing specific enemy
    states can define their unique behavior for entering, updating, and exiting those
    states. This approach allows for modular and organized management of enemy behavior,
    making it easier to add, remove, or modify states as needed within the game.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现此接口，代表特定敌人状态的类可以定义它们进入、更新和退出这些状态的独特行为。这种方法允许模块化和组织化地管理敌人行为，使得在游戏中根据需要添加、删除或修改状态变得更容易。
- en: 'Let’s move on to creating enemy components, starting with: `EnemyHealth`. This
    component will integrate the `IHealth` interface and handle all health-related
    logic for enemies. Check out the following code block:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建敌人组件，从 `EnemyHealth` 开始。此组件将集成 `IHealth` 接口，并处理所有与敌人相关的健康逻辑。查看以下代码块：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s understand the `EnemyHealth` component:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解 `EnemyHealth` 组件：
- en: '**startingMaxHealth**: Default starting maximum health for the enemy.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**startingMaxHealth**: 敌人的默认起始最大生命值。'
- en: '**healAmount**: Amount of healing per interval'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**healAmount**: 每个间隔的治疗量'
- en: '**healInterval**: Time interval for healing'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**healInterval**: 治疗的时间间隔'
- en: '**healIntervalWait**: Reusable **WaitForSeconds** instance for healing'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**healIntervalWait**: 用于治疗的可重用 **WaitForSeconds** 实例'
- en: '**healOverTimeCoroutine**: Coroutine for healing over time'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**healOverTimeCoroutine**: 治疗协程'
- en: '**maxHealth**: Maximum health of the enemy'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**maxHealth**: 敌人的最大生命值'
- en: '**currentHealth**: Current health of the enemy'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**currentHealth**: 敌人的当前生命值'
- en: '**TakeDamage(float damage)**: Handles damage taken by the enemy'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TakeDamage(float damage)**: 处理敌人受到的伤害'
- en: '**SetMaxHealth()**: Sets the maximum health of the enemy'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SetMaxHealth()**: 设置敌人的最大生命值'
- en: '**Heal()**: Heals the enemy over time'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Heal()**: 随时间治疗敌人'
- en: '**StartHealingOverTime()**: Starts the coroutine for healing over time'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**StartHealingOverTime()**: 启动治疗协程'
- en: '**HealOverTime()**: The coroutine method for healing over time'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HealOverTime()**: 治疗协程方法'
- en: 'Next up is the `EnemyAnimations` component, which is responsible for managing
    the animations of the enemy. Let’s delve into its code block:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `EnemyAnimations` 组件，它负责管理敌人的动画。让我们深入其代码块：
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, `StartAttackAnimations()` and `StopAttackAnimations()` manage attack animations.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`StartAttackAnimations()` 和 `StopAttackAnimations()` 管理攻击动画。
- en: 'Next, we’ll implement the collision logic for the enemy in the `EnemyCollision`
    class. This class will handle collisions with the player, allowing the enemy to
    take damage. Look at the following code block for details:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在 `EnemyCollision` 类中实现敌人的碰撞逻辑。此类将处理与玩家的碰撞，使敌人能够受到伤害。查看以下代码块以获取详细信息：
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s look at what the `EnemyCollision` class does:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `EnemyCollision` 类做了什么：
- en: '**playerDamage**: Represents the damage that’s inflicted by the player'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**playerDamage**: 表示玩家造成的伤害'
- en: '**damage**: Damage inflicted when the enemy collides with the player'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**damage**: 敌人与玩家碰撞时造成的伤害'
- en: '**OnCollisionEnter(Collision collision)**: Handles collisions with player projectiles'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnCollisionEnter(Collision collision)**: 处理与玩家投射物的碰撞'
- en: 'The final component in the enemy’s logic is `EnemyShoot`. It’s responsible
    for firing projectiles using the attached weapon. Implement the `IDamage` interface
    here so that it will pass the damage value to the player. Refer to the following
    code block for details:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人逻辑中的最后一个组件是 `EnemyShoot`。它负责使用附加武器发射投射物。在此处实现 `IDamage` 接口，以便将伤害值传递给玩家。请参阅以下代码块以获取详细信息：
- en: '[PRE14]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s look at what `EnemyShoot` does:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `EnemyShoot` 做了什么：
- en: '**fireDamage**: Damage inflicted when the enemy shoots the player'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fireDamage**: 敌人射击玩家时造成的伤害'
- en: '**attachedWeapon**: Reference to the attached weapon of the enemy'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**attachedWeapon**: 敌人附加武器的引用'
- en: '**FireProjectile()**: Initiates the firing of the attached weapon'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FireProjectile()**: 启动附加武器的射击'
- en: '**GetDamageValue()**: Retrieves the damage value'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GetDamageValue()**: 获取伤害值'
- en: 'Now, let’s create the `BaseEnemy` class is an abstract class that defines the
    basic functionality and attributes of an enemy in a game. It will utilize state
    machine logic and contain references for the shooting and animation components
    of the enemies. This class facilitates communication between different states
    of the enemy, making it suitable for use with all enemies:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个`BaseEnemy`类，它是一个抽象类，定义了游戏中敌人基本的功能和属性。它将利用状态机逻辑，并包含对敌人射击和动画组件的引用。这个类促进了敌人不同状态之间的通信，使其适用于所有敌人：
- en: '[PRE15]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s take a closer look at this code so that we understand it:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这段代码，以便我们理解它：
- en: '**player**: Reference to the player’s **Transform** value'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**player**: 对玩家**Transform**值的引用'
- en: '**navMeshAgent**: Reference to the **NavMeshAgent** component for navigation'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**navMeshAgent**: 对导航**NavMeshAgent**组件的引用'
- en: '**currentState**: Reference to the current state of the enemy'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**currentState**: 对敌人当前状态的引用'
- en: '**wanderState**, **idleState**, **attackState**, **deathState**, **chaseState**:
    Different states of the enemy (wandering, idle, attacking, dead, and chasing,
    respectively)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wanderState**, **idleState**, **attackState**, **deathState**, **chaseState**:
    敌人的不同状态（分别是游荡、空闲、攻击、死亡和追逐）'
- en: '**attackRange**: The range within which the enemy can attack'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**attackRange**: 敌人可以攻击的范围'
- en: '**chaseSpeed**: The speed at which the enemy chases the player'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**chaseSpeed**: 敌人追逐玩家的速度'
- en: '**rotationSpeed**: The speed of rotation for the enemy'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rotationSpeed**: 敌人旋转的速度'
- en: '**Start()Method**: Initializes states, sets the initial state, and gets references'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Start()方法**: 初始化状态，设置初始状态，并获取引用'
- en: '**Update()Method**: Updates the current state of the enemy'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Update()方法**: 更新敌人的当前状态'
- en: 'Now, let’s delve into the state machine logic that’s responsible for transitioning
    between states:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解负责在状态之间转换的状态机逻辑：
- en: '[PRE16]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To understand this code, let’s examine its functions:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这段代码，让我们检查它的函数：
- en: '**PlayerInSight()** and **PlayerInRange()**: These functions check if the player
    is in sight or range, respectively'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PlayerInSight()** 和 **PlayerInRange()**: 这些函数分别检查玩家是否在视线或范围内'
- en: '**IsIdleConditionMet()**: Checks if the conditions for idling have been met'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IsIdleConditionMet()**: 检查是否满足空闲的条件'
- en: '**TransitionToState()**: Transitions to a new state'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TransitionToState()**: 转换到新状态'
- en: '**OnDied()Method**: Transitions to the death state'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnDied()方法**: 转换到死亡状态'
- en: 'Now, let’s move on to the states. First, we’ll implement `IEnemyStates` so
    that we can include the base methods. Then, in the subsequent code block, we’ll
    develop the logic for `IdleState`, detailing the actions the enemy will take in
    this state. `IdleState` is the default state for all enemies. Here, we simply
    check for the conditions of other states so that we can transition to them when
    their respective logic is met:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向状态。首先，我们将实现`IEnemyStates`，这样我们就可以包含基本方法。然后，在随后的代码块中，我们将开发`IdleState`的逻辑，详细说明敌人在此状态下将采取的行动。`IdleState`是所有敌人的默认状态。在这里，我们只是检查其他状态的条件，以便在满足相应逻辑时转换到它们：
- en: '[PRE17]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s take a closer look at the preceding code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看前面的代码：
- en: '**Variables**:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Variables**:'
- en: '**idleTime**: This variable determines the duration for which the enemy remains
    idle'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**idleTime**: 这个变量决定了敌人保持空闲的时间长度'
- en: '**timer**: This variable tracks the elapsed time while the enemy is in the
    idle state'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**timer**: 这个变量跟踪敌人处于空闲状态时的经过时间'
- en: '**Methods**:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Methods**:'
- en: '**EnterState(BaseEnemy enemy)**: This method is called when the enemy enters
    the idle state. Here, it initializes the timer.'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EnterState(BaseEnemy enemy)**: 当敌人进入空闲状态时调用此方法。在这里，它初始化计时器。'
- en: '**ExitState(BaseEnemy enemy)**: This method is called when the enemy exits
    the idle state. Currently, it’s empty, but you can add logic here if needed.'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ExitState(BaseEnemy enemy)**: 当敌人退出空闲状态时调用此方法。目前它是空的，但如果有需要，你可以在这里添加逻辑。'
- en: '**UpdateState(BaseEnemy enemy)**: This method is called every frame to update
    the state of the enemy. Here’s what happens:'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UpdateState(BaseEnemy enemy)**: 这个方法在每一帧都会被调用以更新敌人的状态。以下是发生的情况：'
- en: The timer is incremented by the time elapsed since the last frame
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器通过自上一帧以来经过的时间增加
- en: If the idle time exceeds the specified duration (**idleTime**), the enemy transitions
    to the wander state, indicating it’s ready to move around
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果空闲时间超过指定的持续时间（**idleTime**），敌人将转换到游荡状态，表示它准备四处移动
- en: If the enemy detects the player within its line of sight (**PlayerInSight()**),
    it transitions to the chase state to pursue the player
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果敌人检测到玩家在其视线范围内（**PlayerInSight()**），它将转换到追逐状态以追捕玩家
- en: If the player is within the attack range (**PlayerInRange()**), the enemy transitions
    to the attack state to engage the player
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家在攻击范围内（**PlayerInRange()**），敌人将过渡到攻击状态以对抗玩家
- en: This code ensures that the enemy behaves as expected while in the idle state,
    transitioning to other states based on specific conditions, such as time elapsed
    and player proximity.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码确保在空闲状态下，敌人表现如预期，根据特定条件（如经过的时间和玩家接近度）过渡到其他状态。
- en: 'In the following class, `AttackState`, we also implement `IEnemyState` so that
    we can modify the base methods so that they fit the attack state. The attack state
    is the state that all enemies will enter when they are attacking the player. It
    includes logic for tracking the player’s position and firing projectiles toward
    the player, along with handling associated animations:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的 `AttackState` 类中，我们还实现了 `IEnemyState`，以便我们可以修改基方法，使其适合攻击状态。攻击状态是所有敌人在攻击玩家时都会进入的状态。它包括跟踪玩家位置并向玩家发射弹丸的逻辑，以及处理相关的动画：
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here’s an explanation for this code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对此代码的解释：
- en: '**Methods**:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：'
- en: '**EnterState**: Initializes the attack state, starts attack animations, and
    resets the attack timer.'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EnterState**：初始化攻击状态，开始攻击动画，并重置攻击计时器。'
- en: '**UpdateState**: Checks if it’s time to attack based on the time between attacks.
    It ensures that the enemy is facing the player and initiates the attack if conditions
    are met.'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UpdateState**：根据攻击之间的时间检查是否是攻击的时间。它确保敌人面向玩家，并在条件满足时启动攻击。'
- en: '**ExitState**: Stops attack animations when exiting the state.'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ExitState**：在退出状态时停止攻击动画。'
- en: '**LookAtPlayer**: Calculates the direction to look at the player and smoothly
    rotates the enemy toward the player.'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LookAtPlayer**：计算看向玩家的方向，并平滑地将敌人旋转到玩家方向。'
- en: '**AttackPlayer**: Causes the enemy to perform an attack action, such as firing
    a projectile.'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AttackPlayer**：使敌人执行攻击动作，例如发射弹丸。'
- en: With that, you’ve learned how to create states, enabling you to effortlessly
    add more states so that you can tailor your game.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，你已经学会了如何创建状态，使你可以轻松地添加更多状态，以便你可以定制你的游戏。
- en: Now that we’ve established the interaction loop between the enemy and the player,
    allowing them to shoot at each other, the next step involves creating a prefab
    for each enemy – for instance, implementing the `ShooterEnemy` base class and
    adding this component to the respective `GameObject`, turning it into a prefab.
    Similarly, for projectiles, remember that it’s essential to modify tags based
    on whether they’re for the player or the enemy.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了敌人和玩家之间的交互循环，允许他们互相射击，下一步涉及为每个敌人创建一个预制体 - 例如，实现 `ShooterEnemy` 基类并将此组件添加到相应的
    `GameObject` 中，将其转换为预制体。同样，对于弹丸，请记住，根据它们是为玩家还是敌人而修改标签是至关重要的。
- en: Implementing challenge and reward systems using C#
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 C# 实现挑战与奖励系统
- en: Challenges breathe life into the gaming experience, pulsating with excitement
    and unpredictability, guiding players through pivotal moments that require skill,
    strategy, and determination. These obstacles ensure players stay fully immersed
    in the gaming world, crafting a dynamic landscape that turns each gaming session
    into an adventure, complete with unexpected twists and turns.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战为游戏体验注入活力，充满激情和不可预测性，引导玩家通过需要技能、策略和决心的关键时刻。这些障碍确保玩家完全沉浸在游戏世界中，打造一个动态的景观，使每次游戏都变成一场冒险，充满意想不到的转折和变化。
- en: In games such as *Dark Souls*, challenges manifest in the form of formidable
    enemies and intricate level designs. Players are tested on their combat skills
    and adaptability, creating an intense and rewarding experience. *Super Mario Bros.*
    introduces challenges through precise platforming, timing, and defeating enemies.
    Each level presents a new set of challenges, gradually increasing in complexity.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 *Dark Souls* 这样的游戏中，挑战以强大的敌人和复杂的关卡设计的形式出现。玩家在战斗技能和适应性方面受到考验，创造了一个紧张而有益的经验。*超级马里奥兄弟*
    通过精确的平台跳跃、时机和击败敌人引入挑战。每个关卡都提供了一套新的挑战，逐渐增加复杂性。
- en: Challenges versus missions/quests
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挑战与任务/探险
- en: While challenges, missions, and quests share common ground in engaging players,
    they differ in their nature. **Challenges** often refer to specific obstacles
    or tasks that test a player’s abilities, such as completing a level within a time
    limit or defeating a powerful adversary. **Missions and quests**, on the other
    hand, are broader objectives that contribute to the game’s narrative and involve
    a series of tasks that may include challenges. The distinction lies in the focused,
    skill-testing nature of challenges, making them pivotal components of dynamic
    gameplay.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**挑战、任务和任务**在吸引玩家方面有共同点，但它们的性质不同。**挑战**通常指的是测试玩家能力的特定障碍或任务，例如在时间限制内完成一个关卡或击败一个强大的对手。另一方面，**任务和任务**是更广泛的目标，它们有助于游戏的叙事，并涉及一系列可能包括挑战的任务。区别在于挑战的专注和技能测试性质，使它们成为动态游戏的关键组成部分。
- en: 'In *The Legend of Zelda: Breath of the Wild*, a challenge might involve solving
    a complex puzzle shrine and testing the player’s problem-solving skills. In contrast,
    a mission could be part of the game’s overarching narrative, such as rescuing
    a character or retrieving a special item. Challenges offer immediate, skill-based
    hurdles, while missions contribute to the overall progression and storytelling.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在《塞尔达传说：荒野之息》中，挑战可能包括解决复杂的神殿谜题并测试玩家的解决问题的能力。相比之下，任务可能是游戏整体叙事的一部分，例如营救角色或找回特殊物品。挑战提供即时的、基于技能的障碍，而任务则有助于整体进度和叙事。
- en: Balancing difficulty levels for broad appeal
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平衡难度级别以吸引更广泛的受众
- en: Achieving a harmonious difficulty curve is essential to cater to players of
    varying skill levels. Balancing challenges ensures that both novice and experienced
    players find engagement without encountering excessive frustration. Games such
    as *Celeste* masterfully balance difficulty, starting with simple challenges and
    gradually introducing more complex ones, allowing players to grow alongside the
    game’s intricacies.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 实现和谐的难度曲线对于满足不同技能水平的玩家至关重要。平衡挑战确保新手和经验丰富的玩家都能找到乐趣，而不会遇到过多的挫折。例如，《Celeste》等游戏巧妙地平衡了难度，从简单的挑战开始，逐渐引入更复杂的挑战，让玩家随着游戏的复杂性一起成长。
- en: Successful games often employ techniques such as **adaptive difficulty scaling**
    or optional challenges to accommodate diverse player skill levels. This careful
    balance prevents discouragement for newcomers while providing a satisfying experience
    for seasoned players seeking greater challenges.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的游戏通常采用**自适应难度调整**或可选挑战等技术，以适应不同玩家的技能水平。这种谨慎的平衡既防止了新手感到气馁，也为寻求更大挑战的老玩家提供了满意的体验。
- en: Exploring reward systems
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索奖励系统
- en: '**Reward systems** in gaming are like treasured prizes waiting for triumphant
    players after they’ve overcome tough challenges. These systems are closely linked
    to the challenge dynamics, acting as the driving force that propels players forward.
    Rewards come in various forms – power-ups, upgrades, or in-game currency, along
    with narrative progress and cosmetic items, each with its unique appeal.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励系统**在游戏中就像是在玩家克服艰难挑战后等待胜利者的珍贵奖品。这些系统与挑战动态紧密相连，作为推动玩家前进的动力。奖励形式多样——包括增强、升级或游戏内货币，以及叙事进度和外观物品，每种都有其独特的吸引力。'
- en: In games such as *The Legend of Zelda*, conquering tricky dungeons or defeating
    tough bosses often rewards players with new tools or abilities to progress in
    the story. In RPGs such as *The Witcher 3*, completing side quests not only gives
    experience points and in-game money but also unlocks new storylines or equipment.
    The connection between challenges and rewards ensures that overcoming obstacles
    not only tests the player’s skills but also promises valuable incentives, boosting
    player engagement and satisfaction.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在《塞尔达传说》等游戏中，征服棘手的地下城或击败强大的Boss通常会奖励玩家新的工具或能力，以便在故事中前进。在《巫师3》等RPG游戏中，完成支线任务不仅提供经验点和游戏内货币，还能解锁新的故事线或装备。挑战与奖励之间的联系确保了克服障碍不仅考验玩家的技能，还承诺了有价值的激励，从而提高玩家的参与度和满意度。
- en: Successfully blending rewards into the gameplay loop ensures that challenges
    aren’t just hurdles but opportunities for growth. This fosters a sense of accomplishment
    and progression. Players are motivated to take on tougher challenges for the promise
    of more significant rewards, creating a satisfying gaming experience. The seamless
    integration of rewards makes the gaming journey fulfilling and enjoyable.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将奖励成功融入游戏循环确保挑战不仅仅是障碍，而是成长的机会。这培养了成就感与进步感。玩家为了获得更多重大奖励的承诺，会更有动力接受更具挑战性的挑战，从而创造令人满意的游戏体验。奖励的无缝集成使游戏之旅变得充实和愉快。
- en: C# implementation of challenges and rewards
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 挑战和奖励的实现
- en: Moving from theory to practice, our C# implementation of challenges and rewards
    brings coding insights to life. With illustrative code snippets, you’ll gain hands-on
    experience, bringing challenges to life and rewarding players meaningfully. We’ll
    discuss the delicate balance that’s needed to keep players engaged and motivated,
    understanding how challenge difficulty correlates with the magnitude of rewards.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论到实践，我们用 C# 实现挑战和奖励，将编码洞察力变为现实。通过示例代码片段，您将获得实践经验，使挑战变得生动，并给予玩家有意义的奖励。我们将讨论保持玩家参与和动力的微妙平衡，了解挑战难度与奖励幅度的相关性。
- en: Introducing the challenge logic
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍挑战逻辑
- en: 'Let’s begin by establishing the foundational data structure for challenges.
    This can be seen in the following class. Every challenge will share this common
    set of data, simplifying runtime tracking and allowing prizes to be assigned:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先建立挑战的基础数据结构。这可以在以下类中看到。每个挑战都将共享这组通用数据，简化运行时跟踪，并允许分配奖品：
- en: '[PRE19]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s proceed to the `BaseChallenge` class, which features the logic for starting
    and completing challenges. Refer to the following code block for details. All
    challenges will derive from this script, customizing their logic within its methods:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到 `BaseChallenge` 类，它包含开始和完成挑战的逻辑。有关详细信息，请参考以下代码块。所有挑战都将从这个脚本派生出来，在其方法内自定义其逻辑：
- en: '[PRE20]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s take a closer look:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解一下：
- en: '**public CommonChallengeData commonData**: This is a public variable of the
    **CommonChallengeData** type. It holds data that might be common across various
    types of challenges. It allows derived classes to access and modify shared challenge
    data.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public CommonChallengeData commonData**：这是一个公共变量，类型为 **CommonChallengeData**。它持有可能跨越各种类型挑战的通用数据。它允许派生类访问和修改共享的挑战数据。'
- en: '**public abstract void StartChallenge()**: This is an abstract method declaration
    without any implementation. It specifies that any class inheriting from **BaseChallenge**
    must provide its own implementation for the **StartChallenge** method. This method
    likely contains logic to initialize or begin the challenge.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public abstract void StartChallenge()**：这是一个没有实现的具体方法声明。它指定了任何从 **BaseChallenge**
    继承的类都必须为其 **StartChallenge** 方法提供自己的实现。此方法可能包含初始化或开始挑战的逻辑。'
- en: '**public abstract void CompleteChallenge()**: Similar to **StartChallenge()**,
    this is another abstract method that any derived class must implement. It is responsible
    for handling the completion of the challenge, which may involve updating the UI,
    awarding rewards, or triggering other game events.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public abstract void CompleteChallenge()**：与 **StartChallenge()** 类似，这也是一个任何派生类都必须实现的抽象方法。它负责处理挑战的完成，可能涉及更新用户界面、颁发奖励或触发其他游戏事件。'
- en: In summary, `BaseChallenge` serves as a template for creating different types
    of challenges in a game. It defines common functionality that all challenges should
    have, such as starting and completing the challenge, while allowing specific implementations
    to vary based on the type of challenge.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`BaseChallenge` 作为创建游戏不同类型挑战的模板。它定义了所有挑战应具备的通用功能，例如开始和完成挑战，同时允许特定实现根据挑战类型的不同而有所变化。
- en: Let’s transition to `ChallengeManager`, a central entity that houses all challenges
    and takes on the responsibility of initiating challenges. Currently, it includes
    a dictionary for storing all challenge components by their respective types, encompassing
    all challenge types. It also features a method to commence challenges, which will
    be invoked by `LevelManager`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们过渡到 `ChallengeManager`，这是一个中央实体，它存储所有挑战并承担启动挑战的责任。目前，它包括一个字典，用于按其相应类型存储所有挑战组件，涵盖所有挑战类型。它还包含一个开始挑战的方法，该方法将由
    `LevelManager` 调用。
- en: 'Consequently, each level can have a designated challenge, and the manager maintains
    a reference to the current challenge. All of these functionalities are detailed
    in the following code script:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个等级都可以有一个指定的挑战，并且管理器会维护对当前挑战的引用。所有这些功能都在以下代码脚本中详细说明：
- en: '[PRE21]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here’s an explanation of the `ChallengeManager` class:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对 `ChallengeManager` 类的解释：
- en: '**public enum ChallengeType**: This is an enumeration that defines different
    types of challenges available in the game. Each challenge type represents a specific
    kind of gameplay challenge, such as **EnemyWaves**, **TimeTrials**, **LimitedResources**,
    **NoDamageRun**, and **AccuracyChallenge**.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public enum ChallengeType**：这是一个枚举，定义了游戏中可用的不同类型挑战。每种挑战类型代表一种特定的游戏玩法挑战，例如
    **EnemyWaves**、**TimeTrials**、**LimitedResources**、**NoDamageRun** 和 **AccuracyChallenge**。'
- en: '**public GenericDictionary<ChallengeType**, **BaseChallenge> challengeDictionary**:
    This is a generic dictionary that maps **ChallengeType** enum values to corresponding
    **BaseChallenge** objects. It stores instances of different challenge scripts
    associated with their respective challenge types.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public GenericDictionary<ChallengeType**, **BaseChallenge> challengeDictionary**：这是一个泛型字典，将
    **ChallengeType** 枚举值映射到相应的 **BaseChallenge** 对象。它存储与各自挑战类型相关联的不同挑战脚本的实例。'
- en: '**public void StartChallenge(ChallengeType challengeType)**: This method is
    responsible for starting a challenge of the specified type. It retrieves the corresponding
    challenge script from the dictionary based on the provided challenge type and
    then calls the **StartChallenge()** method of the retrieved script.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public void StartChallenge(ChallengeType challengeType)**：此方法负责启动指定类型的挑战。它根据提供的挑战类型从字典中检索相应的挑战脚本，然后调用检索到的脚本中的
    **StartChallenge()** 方法。'
- en: '**private BaseChallenge currentChallenge**: This private field holds a reference
    to the currently active challenge. It is used to track and manage the state of
    the current challenge being played.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**private BaseChallenge currentChallenge**：这个私有字段持有当前活跃挑战的引用。它用于跟踪和管理正在进行的当前挑战的状态。'
- en: '**private void** **SetCurrentChallenge(BaseChallenge challenge** **Script)**:
    This method sets the current challenge to the one provided as an argument. Before
    setting the new challenge, it ensures that any existing challenge is completed
    by calling its **CompleteChallenge()** method.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**private void** **SetCurrentChallenge(BaseChallenge challenge** **Script)**：此方法将当前挑战设置为提供的参数。在设置新挑战之前，它通过调用其
    **CompleteChallenge()** 方法确保任何现有挑战已完成。'
- en: In summary, the `ChallengeManager` class facilitates the management and execution
    of different types of challenges in the game. It provides methods to start challenges,
    handle the completion of challenges, and track the current active challenge. The
    use of a singleton pattern ensures centralized control over challenge management
    operations.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`ChallengeManager` 类简化了游戏中不同类型挑战的管理和执行。它提供了启动挑战、处理挑战完成以及跟踪当前活跃挑战的方法。使用单例模式确保了对挑战管理操作的集中控制。
- en: 'Now, let’s shift our focus to the individual challenges. The following code
    block contains an example that implements the `BaseChallenge` class, integrating
    custom logic specific to the `Enemy Waves` challenge. When the challenge starts,
    enemies are spawned near the player. Additionally, it includes logic to reward
    the player upon completing the challenge. This is facilitated by the `RewardManager`
    class:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向单个挑战。以下代码块包含了一个实现 `BaseChallenge` 类的示例，它集成了针对 `Enemy Waves` 挑战的特定逻辑。当挑战开始时，敌人在玩家附近生成。此外，它还包括在完成挑战后奖励玩家的逻辑。这通过
    `RewardManager` 类来实现：
- en: '[PRE22]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here’s an explanation of the `EnemyWavesChallenge` class:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对 `EnemyWavesChallenge` 类的解释：
- en: '**public int totalWaves = 5**: This variable determines the total number of
    waves for the enemy challenge. Game designers can adjust this value to set the
    desired number of waves.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public int totalWaves = 5**：这个变量确定敌对挑战的总波数。游戏设计师可以调整此值以设置所需的波数。'
- en: '**private int currentWave = 0**: This variable keeps track of the current wave
    during the challenge. It starts at **0** and increments as waves are spawned.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**private int currentWave = 0**：这个变量跟踪挑战中的当前波次。它从 **0** 开始，随着波的生成而递增。'
- en: '**public override void StartChallenge()**: This method overrides the **StartChallenge()**
    method that’s inherited from the **BaseChallenge** class. It initiates the enemy
    waves challenge if it’s not already completed. Inside this method, a coroutine
    named **StartEnemyWavesChallenge()** is started to handle the wave spawning process.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public override void StartChallenge()**: 这个方法覆盖了从 **BaseChallenge** 类继承的
    **StartChallenge()** 方法。如果挑战尚未完成，它将启动敌军波次挑战。在此方法内部，启动一个名为 **StartEnemyWavesChallenge()**
    的协程来处理波次生成过程。'
- en: '**IEnumerator StartEnemyWavesChallenge()**: This coroutine function manages
    the spawning of enemy waves. It runs until the current wave count reaches the
    total number of waves specified. Inside the loop, it waits for a wave to be spawned
    using the **SpawnEnemyWave()** coroutine.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IEnumerator StartEnemyWavesChallenge()**: 这个协程函数管理敌军波次的生成。它运行直到当前波次计数达到指定的总波次数。在循环内部，它使用
    **SpawnEnemyWave()** 协程等待生成一个波次。'
- en: '**public override void CompleteChallenge()**: This method overrides the **CompleteChallenge()**
    method from the base class. It grants rewards for completing the challenge using
    **RewardManager** and marks the challenge as completed.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public override void CompleteChallenge()**: 这个方法覆盖了基类中的 **CompleteChallenge()**
    方法。它通过使用 **RewardManager** 为完成挑战提供奖励，并将挑战标记为已完成。'
- en: '**IEnumerator SpawnEnemyWave()**: This coroutine function represents the logic
    for spawning an enemy wave. Game designers can adjust spawn positions, enemy types,
    and other parameters to customize the wave spawning process. In this example,
    it logs a message indicating the wave being spawned and waits for a set duration
    before spawning the next wave.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IEnumerator SpawnEnemyWave()**: 这个协程函数代表了生成敌军波次的逻辑。游戏设计师可以调整生成位置、敌军类型和其他参数来自定义波次生成过程。在这个例子中，它记录了一条消息，表明正在生成波次，并在生成下一个波次之前等待设定的时间。'
- en: In summary, the `EnemyWavesChallenge` class defines a challenge where waves
    of enemies are spawned sequentially. It provides methods to start the challenge,
    spawn enemy waves, and handle the completion of the challenge by granting rewards.
    Game designers can customize the wave spawning process and adjust parameters according
    to the game’s requirements.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`EnemyWavesChallenge` 类定义了一个挑战，其中敌军波次是顺序生成的。它提供了启动挑战、生成敌军波次和处理挑战完成（通过提供奖励）的方法。游戏设计师可以根据游戏需求自定义波次生成过程并调整参数。
- en: 'The previous example is just one of the challenges provided. You can find all
    the challenges in this book’s GitHub repository (see the *Technical requirements*
    section). Lastly, here’s `LevelManager`, which is tasked with assigning a suitable
    challenge for the current level:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子只是提供的挑战之一。你可以在本书的 GitHub 仓库中找到所有挑战（见 *技术要求* 部分）。最后，这是 `LevelManager`，它负责为当前级别分配合适的挑战：
- en: '[PRE23]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here’s an explanation of the `LevelManager` class:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对 `LevelManager` 类的解释：
- en: '**public GenericDictionary<int**, **ChallengeType> levelChallengeMapping**:
    This dictionary stores mappings between levels and their corresponding challenge
    types. The key represents the level number, and the value represents the type
    of challenge associated with that level.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public GenericDictionary<int**, **ChallengeType> levelChallengeMapping**:
    这个字典存储了级别与其对应挑战类型之间的映射。键代表级别编号，值代表与该级别关联的挑战类型。'
- en: '**public int currentLevel**: This variable stores the current level of the
    game.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public int currentLevel**: 这个变量存储了游戏当前的级别。'
- en: '**private void Start()**: This method is called when the **LevelManager** object
    is initialized. It automatically starts the challenge associated with the current
    level.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**private void Start()**: 当 **LevelManager** 对象初始化时调用此方法。它自动启动与当前级别关联的挑战。'
- en: '**public void StartChallengeForCurrentLevel(int currentLevel)**: This method
    starts the challenge for the specified current level. It checks if a challenge
    has been mapped for the current level in the **levelChallengeMapping** dictionary.
    If a mapping is found, it retrieves the associated challenge type and starts the
    corresponding challenge using **ChallengeManager**.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public void StartChallengeForCurrentLevel(int currentLevel)**: 这个方法为指定的当前级别启动挑战。它检查
    **levelChallengeMapping** 字典中是否为当前级别映射了挑战。如果找到映射，它检索关联的挑战类型并使用 **ChallengeManager**
    启动相应的挑战。'
- en: '**ChallengeManager.Instance.StartChallenge(challengeType)**: This line of code
    invokes the **StartChallenge** method of the **ChallengeManager** singleton instance,
    passing the challenge type associated with the current level as an argument.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ChallengeManager.Instance.StartChallenge(challengeType)**：这一行代码调用**ChallengeManager**单例实例的**StartChallenge**方法，传递与当前级别关联的挑战类型作为参数。'
- en: In summary, the `LevelManager` class facilitates the initiation of challenges
    based on the current level of the game. It ensures that the correct challenge
    is started for each level by looking up the challenge type associated with the
    current level in the `levelChallengeMapping` dictionary and then invoking the
    `StartChallenge` method of the `ChallengeManager` singleton instance.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`LevelManager`类通过在`levelChallengeMapping`字典中查找与当前级别关联的挑战类型，然后调用`ChallengeManager`单例实例的`StartChallenge`方法，来促进基于游戏当前级别的挑战的启动。它确保每个级别都启动了正确的挑战。
- en: Implementing the reward system
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现奖励系统
- en: Now, let’s delve into the reward system, a crucial element in the gameplay flow
    that allows users to receive rewards. This feature is essential for user motivation
    and engagement
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解奖励系统，这是游戏流程中的关键元素，允许用户获得奖励。这个功能对于用户动机和参与度至关重要。
- en: 'Here’s `RewardManager`, which is tasked with providing the user with rewards
    based on the challenge data. As we can see, it communicates with other managers
    to enable the user to receive specific rewards:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`RewardManager`，它的任务是根据挑战数据为用户提供奖励。正如我们所见，它与其他管理者进行通信，以便用户能够获得特定的奖励：
- en: '[PRE24]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here’s an explanation of the `RewardManager` class:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对`RewardManager`类的解释：
- en: '**public enum RewardType**: This enumeration defines different types of rewards
    that can be granted to the player, such as power-ups, unlockable weapons, score
    multipliers, items found in secret areas, and coins.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public enum RewardType**：这个枚举定义了可以授予玩家的不同奖励类型，例如升级、可解锁武器、得分倍数、在秘密区域找到的物品和硬币。'
- en: '**public void GrantReward(CommonChallengeData commonData)**: This method is
    responsible for granting rewards to the player. It takes a **CommonChallengeData**
    object as a parameter, which contains information about the type and amount of
    reward to be granted.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public void GrantReward(CommonChallengeData commonData)**：这个方法负责授予玩家奖励。它接受一个**CommonChallengeData**对象作为参数，其中包含有关要授予的奖励类型和数量的信息。'
- en: '**switch (commonData.rewardType)**: This switch statement checks the type of
    reward specified in the **CommonChallengeData** object and executes the corresponding
    reward logic based on **RewardType**.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**switch (commonData.rewardType)**：这个switch语句检查**CommonChallengeData**对象中指定的奖励类型，并根据**RewardType**执行相应的奖励逻辑。'
- en: '**case RewardType.PowerUp**: This case allows temporary power-ups to be granted
    to the player.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**case RewardType.PowerUp**：这个情况允许临时授予玩家升级。'
- en: '**case RewardType.UnlockableWeapon**: This case allows new weapons to be unlocked
    for the player.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**case RewardType.UnlockableWeapon**：这个情况允许为玩家解锁新武器。'
- en: '**case RewardType.ScoreMultiplier**: This case applies a score multiplier to
    the player’s score by invoking the **ApplyScoreMultiplier** method with the specified
    multiplier value.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**case RewardType.ScoreMultiplier**：这个情况通过调用带有指定倍数值的**ApplyScoreMultiplier**方法，将得分倍数应用于玩家的得分。'
- en: '**case RewardType.SecretArea**: This case allows items to be found in secret
    areas.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**case RewardType.SecretArea**：这个情况允许在秘密区域找到物品。'
- en: '**case RewardType.Coins**: This case grants coins to the player by invoking
    the **GrantCoins** method with the specified coin amount.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**case RewardType.Coins**：这个情况通过调用带有指定硬币数量的**GrantCoins**方法，将硬币授予玩家。'
- en: '**private void ApplyScoreMultiplier(int multiplier)**: This method applies
    a score multiplier to the player’s score by invoking the **ApplyMultiplier** method
    of the **ScoreManager** singleton instance.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**private void ApplyScoreMultiplier(int multiplier)**：这个方法通过调用**ScoreManager**单例实例的**ApplyMultiplier**方法，将得分倍数应用于玩家的得分。'
- en: '**private void GrantCoins(int coinAmount)**: This method adds coins to the
    player’s currency balance by invoking the **AddCoins** method of the **CurrencyManager**
    singleton instance.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**private void GrantCoins(int coinAmount)**：这个方法通过调用**CurrencyManager**单例实例的**AddCoins**方法，将硬币添加到玩家的货币余额中。'
- en: Overall, the `RewardManager` class provides a centralized mechanism for managing
    and granting various types of rewards to the player upon completing challenges.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，`RewardManager`类提供了一个集中机制，用于管理和授予玩家在完成挑战后各种类型的奖励。
- en: 'The following code block contains `CurrencyManager`, which is responsible for
    overseeing in-game currency. However, the focus here is on a segment dedicated
    to adding coins to the player:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块包含 `CurrencyManager`，它负责监督游戏中的货币。然而，这里的重点是添加金币到玩家余额的部分：
- en: '[PRE25]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s an explanation of the `CurrencyManager` class:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对 `CurrencyManager` 类的解释：
- en: '**private int currentCoins**: This variable stores the current number of coins
    the player has.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**private int currentCoins**: 这个变量存储玩家当前拥有的金币数量。'
- en: '**public void AddCoins(int amount)**: This method allows you to add coins to
    the player’s currency balance. It takes an integer parameter amount, representing
    the number of coins to add to the current balance.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public void AddCoins(int amount)**: 这个方法允许您向玩家的货币余额中添加金币。它接受一个名为 amount 的整数参数，表示要添加到当前余额中的金币数量。'
- en: '**currentCoins += amount**: This line increments the **currentCoins** variable
    by the specified amount, effectively adding coins to the player’s balance.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**currentCoins += amount**: 这行代码将 **currentCoins** 变量增加指定的数量，从而向玩家的余额中添加金币。'
- en: Overall, the `CurrencyManager` class provides a simple yet essential functionality
    for managing the player’s currency balance, specifically adding coins to their
    total balance.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，`CurrencyManager` 类为管理玩家的货币余额提供了简单而基本的功能，特别是向他们的总余额中添加金币。
- en: 'The following code block contains `ScoreManager`, which is tasked with managing
    the player’s score and implementing a scoring multiplier:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块包含 `ScoreManager`，它负责管理玩家的分数并实现分数乘数：
- en: '[PRE26]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here’s an explanation of the `ScoreManager` class:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对 `ScoreManager` 类的解释：
- en: '**private float currentScore**: This variable stores the current score of the
    player.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**private float currentScore**: 这个变量存储玩家的当前分数。'
- en: '**private int scoreMultiplier = 1**: This variable represents the score multiplier,
    which starts at **1** by default.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**private int scoreMultiplier = 1**: 这个变量表示分数乘数，默认值为 **1**。'
- en: '**public void ApplyMultiplier(int multiplier)**: This method allows you to
    apply a score multiplier to the current score. It takes an integer parameter multiplier,
    which adjusts the score multiplier accordingly.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public void ApplyMultiplier(int multiplier)**: 这个方法允许您将分数乘数应用于当前分数。它接受一个名为
    multiplier 的整数参数，相应地调整分数乘数。'
- en: '***scoreMultiplier = multiplier**: This line multiplies the existing score
    multiplier by the specified multiplier, effectively adjusting the score multiplier.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**scoreMultiplier = multiplier**: 这行代码将现有的分数乘数乘以指定的乘数，从而有效地调整分数乘数。'
- en: '**private void ResetMultiplier()**: This method resets the score multiplier
    to its default value of **1**.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**private void ResetMultiplier()**: 这个方法将分数乘数重置为其默认值 **1**。'
- en: '**public void AddScore(int scoreValue)**: This method adds a specified score
    value to the player’s current score. It takes an integer parameter called **scoreValue**,
    representing the score to add to the current score.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**public void AddScore(int scoreValue)**: 这个方法将指定的分数值添加到玩家的当前分数。它接受一个名为 **scoreValue**
    的整数参数，表示要添加到当前分数的分数。'
- en: '**currentScore += scoreValue * scoreMultiplier**: This line adjusts the current
    score based on the score value and the current score multiplier. It multiplies
    the score value by the score multiplier and adds it to the current score.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**currentScore += scoreValue * scoreMultiplier**: 这行代码根据分数值和当前分数乘数调整当前分数。它将分数值乘以分数乘数，并将其添加到当前分数。'
- en: Overall, the `ScoreManager` class handles score calculations and updates, including
    applying multipliers and adding score values to the player’s total score.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，`ScoreManager` 类处理分数计算和更新，包括应用乘数和将分数值添加到玩家的总分数中。
- en: This example highlights the vital relationship between challenges and the reward
    system in game development. Challenges provide engaging obstacles and objectives,
    fostering player interaction and progression. Integrated with the reward system,
    completing challenges becomes not just an accomplishment but a satisfying experience,
    offering incentives that motivate players. This dynamic interplay enhances the
    overall gaming experience, ensuring players remain engaged, motivated, and fulfilled
    throughout their journey in the game world.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子突出了游戏开发中挑战和奖励系统之间的重要关系。挑战提供了吸引人的障碍和目标，促进了玩家的互动和进步。与奖励系统结合，完成挑战不仅是一种成就，也是一种令人满意的体验，提供了激励玩家继续前进的奖励。这种动态的互动增强了整体的游戏体验，确保玩家在整个游戏世界之旅中保持参与、动机和满足感。
- en: In [*Chapter 6*](B22017_06.xhtml#_idTextAnchor098), which focuses on data handling,
    I intend to introduce a save system that will store all pertinent data, encompassing
    the elements we’ve discussed so far. This chapter will delve into the specifics
    of implementing this system.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第六章*](B22017_06.xhtml#_idTextAnchor098)，本章专注于数据处理，我打算介绍一个存储所有相关数据的保存系统，包括我们迄今为止讨论过的所有元素。本章将深入探讨实现该系统的具体细节。
- en: The provided scripts serve as demonstrations, and you can find the complete
    logic in this book’s GitHub repository.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的脚本作为演示，你可以在本书的GitHub仓库中找到完整的逻辑。
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into essential Unity game development principles,
    specifically addressing game mechanics with a focus on C#. We underscored their
    significance in shaping engaging gameplay, encompassing aspects such as balance,
    feedback, and player agency. This provided you with practical skills in C# coding
    for implementing effective game mechanics. Transitioning to the next section,
    *Implementing player behavior and AI logic using C#*, we explored player behavior
    design and foundational AI concepts. Additionally, we emphasized the crucial role
    of challenges and reward systems in elevating the player experience and fostering
    engagement.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了Unity游戏开发的基本原则，特别是针对C#的游戏机制，我们强调了它们在塑造引人入胜的游戏玩法中的重要性，包括平衡、反馈和玩家自主权等方面。这为你提供了使用C#进行有效游戏机制实现的实用编程技能。过渡到下一节，*使用C#实现玩家行为和AI逻辑*，我们探讨了玩家行为设计和基础AI概念。此外，我们还强调了挑战和奖励系统在提升玩家体验和培养参与度中的关键作用。
- en: In [*Chapter 5*](B22017_05.xhtml#_idTextAnchor074)*,* *Designing Optimized User
    Interfaces with C# for Unity Games*, you will delve into the domain of UI design
    principles and responsive UI elements. By mastering UI design techniques using
    C#, you’ll be able to craft visually appealing and immersive interfaces. This
    chapter aims to augment your skills in designing effective visual hierarchies,
    layouts, and responsive UI elements, ultimately contributing to an enhanced user
    experience, including optimized UI elements.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B22017_05.xhtml#_idTextAnchor074)*，*使用C#为Unity游戏设计优化用户界面*中，你将深入UI设计原则和响应式UI元素领域。通过掌握使用C#的UI设计技术，你将能够制作出视觉上吸引人且沉浸式的界面。本章旨在增强你在设计有效视觉层次、布局和响应式UI元素方面的技能，最终有助于提升用户体验，包括优化UI元素。
- en: As you embark on this ongoing journey of skill-building, the upcoming chapter
    holds exciting challenges and discoveries. Happy coding!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你开始这段技能提升的持续旅程，接下来的章节将带来令人兴奋的挑战和发现。祝您编码愉快！
