- en: Managing Assemblies and Debugging Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we learned about cryptography and how we can encrypt and
    decrypt using different techniques available in C#. In this chapter, we will focus
    on how we can manage .NET assemblies, debugging applications, and how to do tracing.
    Writing a .NET application appears to be relatively simple; however, it is important
    to make sure your program serves its purpose, maintains quality standards, doesn't
    crash on exceptions, and behaves properly in all circumstances. To achieve such
    a quality output, it is important to test your application and check the input
    source and values generated at runtime, which are used in the application logic
    for further processing and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Assemblies are the fundamental units of .NET application deployment. They maintain
    the version, type, resources required, scope, and security details. We will discuss
    this in more detail in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging is the process of stepping through each and every line of code that
    seems to be problematic or code that you believe will throw errors. During this
    process, we can observe the values in the variables and parameters and whether
    the program is running as expected.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to understand whether we are creating a library or an independent
    application to distribute to clients. Based on this, we can decide what type (`.exe`
    or `.dll`) of application needs to be created.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing allows you to track through each and every line of code while it is
    executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'After reading this chapter, you will be able to understand assemblies in .NET
    and how we can manage them, as well as versioning and signing. We will also look
    at a number of ways to debug an application and how to write trace messages when
    an exception occurs. In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Assemblies
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging a C# application
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can practice the exercises from this chapter using Visual Studio 2012 or
    later with .NET Framework 2.0 or later. However, any new C# features from C# 7.0
    and later require you to have Visual Studio 2017.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have a license for any of these products, you can download the
    Community version of Visual Studio 2017 from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: The sample code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter13.](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter13)
  prefs: []
  type: TYPE_NORMAL
- en: Assemblies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assemblies in the .NET Framework can be of two types, `.exe` or `.dll`, and
    are termed as the building blocks of a .NET application.
  prefs: []
  type: TYPE_NORMAL
- en: These assemblies form the basic units of an application and allow a programmer
    to maintain versions, security, scope of usage, and reuse. Since an assembly contains
    all the information required to execute your application, it provides the runtime
    with information about what .NET types are used and what features of runtime are
    required to execute the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create an application in .NET using Visual Studio, it creates source
    code files (`.cs` files), properties of an assembly (`AssemblyInfo.cs`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9e5d21d-413c-4dfb-8eb0-a04b89d516fe.png)'
  prefs: []
  type: TYPE_IMG
- en: These projects allow programmers to associate other assemblies, which, in turn,
    allows them to create and maintain larger projects for multiple users to work
    on each project. When work on individual projects is completed, these projects
    can be created as one assembly unit to release for the customer.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an assembly is created, each assembly creates a manifest file that details
    information about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Each file that has been used in creating this assembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are any references that have been used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The version of the assembly with a unique name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assembly contents and manifest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An assembly in the .NET Framework contains the following four elements:'
  prefs: []
  type: TYPE_NORMAL
- en: Assembly manifest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MSIL code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These elements can be grouped into one assembly, as shown in the following
    screenshot. Here, the runtime requires manifest information in order to get the
    type information, the dependent assembly information, the version, and the unique
    name of the assembly in order to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d38c91ad-6f14-43d1-8ebb-82e3ef688f7c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The .NET Framework also allows us to group the four elements of the assemblies
    into multiple modules and create an assembly to refer them while executing the
    program block. When you refer such modules in an assembly, it is the manifest
    file that maintains all the links required to refer to these resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/783be34c-df17-4984-9e8f-3d8d000411fe.png)'
  prefs: []
  type: TYPE_IMG
- en: An assembly manifest contains the name of the assembly, the version of the assembly,
    which culture is used to build the assembly, the strong name information (that
    is, public key), the type information, a list of files and how they are associated
    with each other and the assembly, and, finally, a list of referenced assemblies
    and their versions. We can add more information by updating the `AssemblyInfo.cs`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: A manifest file can be part of the **portable executable** (**PE**) file along
    with MSIL or a standalone PE file. Each assembly file contains all the files that
    are required for an assembly; it governs how the mapping between these files,
    resources, and assemblies are maintained, and it also contains referenced assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: Target .NET Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create a C# application, you can specify which .NET Framework you want
    to target your application to. In a real-world scenario, not every customer updates
    their servers with the latest versions when new versions of the Framework are
    released. Additionally, when a new version is released, some of the old features
    might be deprecated and newer versions of the existing features are added. In
    these situations, your application should not fail. So, the .NET Framework allows
    you to target your application to a specific version of the .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can target the .NET Framework version while creating a new project using
    Visual Studio, or change the target framework using the property pages of the
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ec18630-b493-42d5-a3a4-859dd0886f99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, to change the target framework version using the property pages,
    select an existing project, right-click on it, and then navigate to Properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c06ae7e5-26ca-4308-b509-0e6e9a78cc07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Target framework drop-down menu, select your required version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18409511-c029-4f79-8589-9f4c7032e293.png)'
  prefs: []
  type: TYPE_IMG
- en: Signing assemblies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a unique identity for an assembly is referred to as signing or strong-naming
    an assembly. Providing a unique identity for an assembly avoids assembly conflicts.
    Each assembly maintains hashes of the modules, resources, and file information
    in its manifest. When you sign an assembly, the following is captured:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the assembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The version number of the assembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If available, the culture (also called *locale* for code development) of the
    assembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The public key that is used to sign the assembly to the assembly manifest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Signing an assembly provides the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows us to give a friend access to other signed assemblies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It allows us to run different versions of the same assembly side by side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It allows us to deploy our assembly into the GAC. This allows other applications
    to use our assembly as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can sign an assembly in two ways: the first is by using Visual Studio,
    and the second is by using the command-line tool. Visual Studio makes it simple
    to sign the assembly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will demonstrate how to sign an assembly using Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to Project Properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the Signing* tab on the left side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/71acc81d-2c4f-49e6-b573-ef151d920e96.png)'
  prefs: []
  type: TYPE_IMG
- en: Select the Sign the assembly checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose <New...> in the drop-down menu, and then choose a strong key filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7ae0ae8b-23f2-4248-9896-4a6334c79a7f.png)'
  prefs: []
  type: TYPE_IMG
- en: Give a key filename in the pop-up window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio allows you to choose an algorithm and provide a password for the
    key file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The password is optional; an algorithm can be changed as per your requirements
    from the available list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alternatively, we can sign an assembly using Command Prompt and Visual Studio
    tools that come with the following installation steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the Windows button on your system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate through the installed programs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the Visual Studio 20xx installation folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Developer Command Prompt for Visual Studio 20xx.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use `sn.exe` to generate a strong name pair into a `.snk` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once the key file is created, you can now use Visual Studio to sign the assembly
    or use the `al.exe` tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use `al.exe` to link the assembly and key pair generated in the preceding steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: More information about these commands is available on MSDN ([https://docs.microsoft.com/en-us/dotnet/framework/tools/sn-exe-strong-name-tool](https://docs.microsoft.com/en-us/dotnet/framework/tools/sn-exe-strong-name-tool)).
  prefs: []
  type: TYPE_NORMAL
- en: Versioning assemblies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are ready with an assembly and have signed it, you can version it.
    When you version an assembly, the current assembly and all the dependent assembly
    versions are maintained in the assembly manifest. When a versioned assembly is
    deployed into an environment, then that becomes the default version of your application
    and the system throws an assembly manifest mismatch error when either the current
    assembly or dependent assemblies do not match the default version. There is a
    way to override this using a configuration file, which tells the runtime to use
    a specific version instead of the default version.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an assembly is executed at runtime, it performs multiple steps to resolve
    assembly binding:'
  prefs: []
  type: TYPE_NORMAL
- en: It checks the current assembly for the version information and a unique name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It checks for configuration files to see whether any version override policies
    are defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the case of any policy changes, the runtime identifies and loads the redirected
    assembly as per the policy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It checks the GAC, or the path specified in configuration files, then the application
    directory, subdirectories, and serves the assembly binding request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Version number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every assembly maintains version information in two forms, identity and informational.
    The version number, name, and culture of the assembly form the identity of the
    assembly and the informational version is provided in a string format specified
    in the assembly info file and is for informational purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The version number of an assembly is represented as a four-part string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For example, if an assembly version is set to 2.1.1234.2, this indicates that
    the major version of the assembly is 2, the minor version is 1, the build number
    is 1234, and the revision number is 2\. When this version is created or updated,
    it is maintained in the manifest file along with a snapshot of all resources and
    dependent assembly files and their versions. In addition to this, versioning checks
    are applicable only when the assembly is signed.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to understand from a real-world scenario is that, when you
    build a product and release your assemblies for customers and later upgrade your
    assembly, then you have to maintain the previous versions. So, when a new version
    of an assembly is released, clients can still use the old version as long as it
    is supported.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the C# application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you build a C# application, you will have two options, debug mode and
    release mode. Debug mode helps you to step through each and every line of your
    code to check for errors and fix them if required. Release mode doesn''t allow
    us to step into code. Visual Studio makes it easy for developers by providing
    more tools, which allows us to `Step-in`, `Step-Over`, and `Step-Out` when a debug
    point is hit by the runtime. These tools are highlighted in a blue box in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8cf1510-0044-4384-8068-5794adbb58c4.png)'
  prefs: []
  type: TYPE_IMG
- en: Apart from these tools, Visual Studio also allows us to view stack trace, inspect
    variables, and much more. Let's explore this further in order to understand more
    about debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the basics. To place a breakpoint, just click on the left margin
    next to the line of code you want to debug or place your cursor on the line and
    press the *F9* key on the keyboard. Another way to place a breakpoint is to select
    the Debug menu option and select a new breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you set a breakpoint, the entire line of code is highlighted in the color
    brown. When the program starts the execution with breakpoints, the control halts
    at the breakpoint and highlights the line in yellow, which means the highlighted
    line is set to execute next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e62e947-ea7b-4de0-a6be-15db19645440.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Observe the preceding screenshot; we have a breakpoint at line 13\. When you
    start the program, the control halted at line 13 where the breakpoint is placed.
    When we step-over, the output is printed on the screen but the control stays at
    line 14 as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b12e200-d1f1-42ff-a118-ecd226d3906e.png)'
  prefs: []
  type: TYPE_IMG
- en: When a breakpoint is hit, though the application execution is halted, all the
    variables, functions, and objects remain in memory, allowing us to validate the
    values. When you want to debug an application, you build it in debug mode, which
    generates a `.pdb` file; this file is key for debugging. The `.pdb` file contains
    symbols (or source) that get loaded into memory to allow us to debug. If these
    symbols were not loaded, then you might see an error message stating that the
    symbols were not found. It is also important to maintain the versions of these
    `pdb` files, as any version mismatch between your assembly and the `.pdb` file
    will result in an assembly version mismatch error.
  prefs: []
  type: TYPE_NORMAL
- en: Let's jump into an example code and examine the different actions we can perform
    while debugging, as well as the features that Visual Studio provides us with.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example program that accepts two numbers and calculates
    the addition and subtraction of those numbers, and then invokes another method
    where 10 is added to the result. Let''s debug this application by placing a couple
    of breakpoints in the code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, two breakpoints were placed on lines 18 and 21\. When the program starts
    executing, it stops at line 18 for user input and when you select continue program
    execution, the control stops at line 21\. One of the important things to observe
    in the following screenshot is that when the control stops at line 21, you can
    view the value of the `number1` variable by just hovering the cursor over it.
    You can see that the `number1` variable has a value of 23:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b5d47b8-2511-42dc-9542-64f4d53e0155.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Visual Studio debugging tools allow us to watch a variable while the program
    is being executed in debug mode. You can right-click on a variable and select
    `Add Watch` to add the variable to the watch window. As you see can see at the
    bottom of the screen, there is a watch window where variable `number3` has been
    added, and we can see the value of 43, which is the output of the sum of `number1`
    and `number2`. The watch window allows you to view the values after the line of
    code executes. This comes in really handy when your application logic is performing
    complex calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8246f05-0ac9-4632-9ea7-4eb4254c8cb9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another window that comes in handy with debugging is Immediate Window (*Ctrl*
    + *Alt* + *I*), which can be opened by using the keyboard shortcut or the Debug
    menu. In contrast to the watch window, this window helps you to perform operations
    before executing the line of code. As you can see in the following screenshot,
    the control is at line 25 where the breakpoint was hit; however, if you look down,
    the Immediate Window was open where we performed the `number1 - number2` operation
    to check the value before executing the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e22f179-f671-4a0e-bd35-d05dfea5167c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you place a breakpoint and hover your cursor over the breakpoint in the
    left margin, the system displays a cogwheel, which allows you to add conditions
    to your breakpoint; for example, your program has a `for` loop, but you want your
    breakpoint to hit when the loop variable is, say, 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77f9d984-84ff-4937-9843-cb3194be2e4c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click on the cogwheel, you will be presented with the condition wizard
    where you can configure the condition of when the breakpoint should hit. By default,
    the condition is set to true, which can be changed by the developer. In the following
    screenshot, we selected `number4=3`, which means that this breakpoint will be
    hit when the number 4 value is equal to 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f513cd1-b8eb-4c1b-99ac-8f40c5123818.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another important feature to understand while debugging is that certain types
    of projects in Visual Studio allow you to change the variable values at runtime
    while debugging the application. When the following program was executed, we entered
    `60` as a numeric value to variable `number2`. You can see the value of variable
    2 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89927d5a-4ed2-4e35-97fd-838ba6cdd89e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, when you select the displayed value, the system allows you to change it
    (we changed it to 40), and then continue the execution of the block with the modified
    value. Please remember that not every project type will allow you to change values
    at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/827276d3-68e8-4aec-89fc-4528e6c844d2.png)'
  prefs: []
  type: TYPE_IMG
- en: As discussed earlier, there are many tools available while debugging a C# application
    using Visual Studio and some of them are highlighted in the following screenshot.
    The Continue and Stop Debugging buttons enable the developer to continue executing
    once a breakpoint is hit, or to stop the execution.
  prefs: []
  type: TYPE_NORMAL
- en: There are buttons to Step Into, Step Out, and Step Over. These buttons allow
    you to step into each and every line of code once a breakpoint is hit, or skip
    the execution of a method and continue the execution in the same context, or step
    into an external method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you debug your program block and fix all the issues you found, you can
    disable or delete all the breakpoints at once by using the Delete All Breakpoints
    or Disable All Breakpoints option in the Debug menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e89d54cf-518b-4b89-aaf3-8ece2e141ef5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A few more options are highlighted in the following screenshot, such as Attach
    to Process, QuickWatch..., Save Dump As..., Parallel Stacks, Immediate, and Watch
    windows, Call Stack, and many more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd92a1b4-55c0-4080-bd4f-a9104f8ff016.png)'
  prefs: []
  type: TYPE_IMG
- en: We structure our project in such a way that multiple assemblies are created,
    be it a helper or a dependent assembly. While debugging, it is important to load
    the symbols by attaching the process running those assemblies to the current debugging
    process using the Attach to Process... command. Otherwise, the system prompts
    that the source code is not available, so control cannot step into the code block.
  prefs: []
  type: TYPE_NORMAL
- en: In a real-project scenario, sometimes your application crashes suddenly; in
    such scenarios, you can save the memory dump and analyze the memory registers
    on what's happening. This might require you to have special skills to read and
    understand such dumps.
  prefs: []
  type: TYPE_NORMAL
- en: We read about parallel tasks and multithreading in previous chapters; when your
    code block is running a multithreaded application of parallel tasks, the Debug
    menu can help you understand the parallel stack and tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tracing enables us to monitor an application while it is executing. When a program
    is executed, the runtime allows us to write messages to monitor the control flow
    of the program. This will enable us to identify any incorrect behavior of the
    application logic. In the case of exceptions, we can identify where exactly the
    code failed and what variable values caused issues in smooth execution. These
    messages can be created by the `System.Diagnostics.Debug` class. When such messages
    are created, by default, these messages are displayed in the output window of
    Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from creating these messages, you can redirect these messages to a file
    or database using the `System.Diagnostics.Trace` class. You can register listeners
    using the trace class, which allows you to redirect your messages. Here, your
    debug class or trace class acts as the publisher and the listener class acts as
    a subscriber. We hope you remember [Chapter 5](66c957f7-4032-461e-91e4-00da1eb6a517.xhtml),
    *Creating and Implementing Events and Callbacks*, where we learned about the publisher
    and subscriber model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example to understand how we can use debug messages.
    In the following program, we are trying to accept two input parameters and perform
    actions such as addition and subtraction on those numbers. However, we added a
    few extra lines to monitor messages that record what''s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we used `Debug.WriteLine` to record the messages, these values are
    written in the output window. Observe the following output window where all `Debug.WriteLine`
    messages are written:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a6ff62f-d20c-41e9-861b-15be1758cad5.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding code block, you can see the last two `Debug.WriteLine` statements
    in the program block, where `Debug.WriteLineIf` is used. The system checks the
    condition that we provided, and, if it returns true, the system writes the message
    to the output window.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's go a step further and see how we can use tracing listeners to redirect
    your message to different channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the same program with five extra lines, where we add `Console.Out`
    and a `logfile.txt` file as two different trace listeners, and then attach these
    two listeners to the debug object. The last line is `Debug.Flush`, which pushes
    all messages from the object to the log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we added `Console.Out` as one of the listeners, `Debug.WriteLine` messages
    are now written on the screen when we execute the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e21a96aa-f660-4150-ae0b-bb2a2ab61805.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Additionally, as we added `logfile.txt` as one of the listeners, a new text
    file gets created in the program executing folder where `Debug.WriteLine` messages
    are written:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a740c00a-e4a4-4ad6-b061-02ea315c39f7.png)'
  prefs: []
  type: TYPE_IMG
- en: These listeners are not limited to text files and console. Based on the project
    requirement, you can add XML, database listeners, which might require some extra
    coding.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how a C# assembly can be managed, how to debug an
    assembly or a program block, what features Visual Studio gives us in performing
    these actions, and how to use tracing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the different functionalities provided
    in C# to access and utilize the data present in file objects and external web
    services, focusing on performing I/O operations on file objects and the different
    helper classes available in the `System.Net` namespace, which helps us with I/O
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does the version number of an assembly represent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Major version, minor version, build number, and revision.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Major build, major version, assembly number, and date.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Major build, major version, assembly number, and revision.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the important benefit of strong naming an assembly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It allows you to share your assembly.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It allows you to run more than two assemblies at the same time.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It allows you to get it installed in GAC.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the easiest way to log debug messages in a text file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file and use a text stream object to write messages.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a trace listener and attached it to the debug object.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a third-party logging assembly.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Major version, minor version, build number, and revision**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**All of the above**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create a trace listener and attached it to the debug object**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
