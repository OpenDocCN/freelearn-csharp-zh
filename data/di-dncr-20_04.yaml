- en: Dependency Injection in ASP.NET Core
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core中的依赖注入。
- en: In [Chapter 3](087ee78f-87f2-49ef-bfca-ae04dfa47880.xhtml), *Introducing Dependency
    Injection in .NET Core 2.0*, we were focusing on .NET Core exclusively, analyzing
    the possibilities the platform offers in relation to Dependency Injection and
    distinct ways to implement it. In this chapter, we'll continue analyzing DI, but,
    this time, focusing on the implementation of ASP.NET Core and the possibilities
    offered to the programmer at the time of configuring websites and other related
    functionality which spreads along the whole life cycle.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](087ee78f-87f2-49ef-bfca-ae04dfa47880.xhtml)“介绍.NET Core 2.0中的依赖注入”，我们专注于.NET
    Core，分析了该平台在依赖注入方面的可能性以及实现它的不同方式。在本章中，我们将继续分析DI，但这次将专注于ASP.NET Core的实现以及当时为程序员提供的配置网站和其他相关功能的可能性，这些功能贯穿了整个生命周期。
- en: The idea is to start with the CLI (command-line tools) and see how to modify
    a console application and turn it into a web app, so you can better understand
    the concept of middleware and the way it's used in ASP.NET Core.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是从命令行工具（CLI）开始，看看如何修改控制台应用程序并将其转换为Web应用程序，这样你可以更好地理解中间件的概念以及它在ASP.NET Core中的使用方式。
- en: With that, we will be ready to move onto an analysis of the default templates
    that Visual Studio 2017 offers for ASP.NET Core apps, and the specific features
    linked to DI in those initial models.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们将准备好分析Visual Studio 2017为ASP.NET Core应用程序提供的默认模板以及与DI相关的特定功能。
- en: Finally, we'll see how to tune up our own services and how to use them via Dependency
    Injection in registration options, controllers, and views.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看看如何调整我们自己的服务以及如何通过依赖注入在注册选项、控制器和视图中使用它们。
- en: 'In all, we will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，在本章中，我们将涵盖以下主题：
- en: Building ASP .NET Core apps using command-line tools.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行工具构建ASP.NET Core应用程序。
- en: Middleware architecture in ASP .NET Core.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core的中间件架构。
- en: Analyzing the default templates offered by Visual Studio.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析Visual Studio提供的默认模板。
- en: Features of DI in ASP.NET applications. Customized services.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET应用程序中DI的特性。定制服务。
- en: Notice the official documentation site uses the same code as the templates offered
    by Visual Studio 2017\. You can find it at [https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/start-mvc](https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/start-mvc).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意官方文档网站使用与Visual Studio 2017提供的模板相同的代码。你可以在[https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/start-mvc](https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/start-mvc)找到它。
- en: ASP.NET Core from the command-line tools
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从命令行工具使用ASP.NET Core。
- en: Once we have installed .NET Core in our boxes and updated (if necessary) to
    version 2.0, we can start a very simple, but explanatory, website from scratch
    using command-line tools and see how we can move from that minimum .NET Core Console
    app to an ASP.NET Core app in a few steps.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在我们的机器上安装了.NET Core并（如果需要）更新到2.0版本，我们就可以从头开始使用命令行工具启动一个非常简单但具有说明性的网站，并看看我们如何通过几个步骤将这个最小的.NET
    Core控制台应用程序转换为ASP.NET Core应用程序。
- en: This process will help you understand the profound changes in architecture that
    ASP.NET Core carries, and how some of the SOLID principles that we have seen are
    applied in a variety of ways to achieve this goal.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程将帮助你理解ASP.NET Core带来的架构上的深刻变化，以及我们看到的某些SOLID原则是如何以各种方式应用于实现这一目标的。
- en: Thus, the first step should be to check out our installed version of .NET Core,
    which we can do in a command-line window (remember that Visual Studio 2017 installs
    several links to these windows in the Windows menu, and that the Developer Command
    Prompt already has environment variables defined to suit the main needs of a programmer).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一步应该是检查我们安装的.NET Core版本，我们可以在命令行窗口中这样做（记住Visual Studio 2017在Windows菜单中安装了几个指向这些窗口的链接，并且开发者命令提示符已经定义了环境变量以适应程序员的
    主要需求）。
- en: 'If you do not already have the .NET Core command-line tools installed, remember
    that you can do it in a separate install from the site [https://www.microsoft.com/net/download/core](https://www.microsoft.com/net/download/core)
    in the Command-Line/Other section, which lets you download the installer for all
    versions currently supported. When run, the installer should look as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装.NET Core命令行工具，请记住你可以在命令行/其他部分中的网站[https://www.microsoft.com/net/download/core](https://www.microsoft.com/net/download/core)进行单独安装，这允许你下载所有当前支持版本的安装程序。运行安装程序时，它应该看起来如下：
- en: '![](img/b275b9f4-c822-417a-b523-a698ca3f9a57.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b275b9f4-c822-417a-b523-a698ca3f9a57.png)'
- en: After installation, a new folder should appear at `C:\Program Files\dotnet\sdk`
    named 2.0, (or whichever is the latest version available at the time).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，应该会在 `C:\Program Files\dotnet\sdk` 中出现一个名为 2.0 的新文件夹（或当时可用的最新版本）。
- en: 'So, we can just check the current version''s details with the `dotnet -version
    and dotnet --info` commands, and see if we have version 2.0 installed:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用 `dotnet -version` 和 `dotnet --info` 命令来检查当前版本的详细信息，并查看是否已安装版本 2.0：
- en: '![](img/7f441d89-37a8-487c-a579-975db3284c70.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f441d89-37a8-487c-a579-975db3284c70.png)'
- en: 'The window will show some basic commands, such as `--help` and `--version`.
    To check the types of templates available for the latest version, just type `dotnet
    new` (with no extra parameters), and you''ll be presented a list of this kind:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口将显示一些基本命令，例如 `--help` 和 `--version`。要检查最新版本可用的模板类型，只需输入 `dotnet new`（不带任何额外参数），你将看到一个类似于此的列表：
- en: '![](img/fa8e1542-c4ac-4f29-98dd-de37b409f4fa.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa8e1542-c4ac-4f29-98dd-de37b409f4fa.png)'
- en: Notice that the first time you type that command it will decompress some files
    (it takes a few seconds), to initially populate your local package cache. That
    will only happen once, improving restore speed and enabling offline access.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一次输入该命令时，它将解压缩一些文件（需要几秒钟），以最初填充你的本地包缓存。这只会发生一次，可以提高恢复速度并允许离线访问。
- en: Creating the minimum possible application
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可能的最小应用程序
- en: We have 11 default types of templates (you can install extra ones from GitHub)
    for as many project types, plus a solution option that creates a `.sln` file including
    the projects inside the depending folders, and distinct options related to configuration
    and Web/ASP.NET solutions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 11 种默认的模板类型（你可以从 GitHub 安装额外的模板），针对多种项目类型，还有一个创建包含依赖文件夹中项目的 `.sln` 文件以及与配置和
    Web/ASP.NET 解决方案相关的不同选项的解决方案选项。
- en: To test this latest version, inside the Command Prompt, create a new folder,
    move to it, and just type a `dotnet new console` command. This creates two files
    that define the simplest app (console app) for .NET Core.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个最新版本，在命令提示符中，创建一个新的文件夹，进入它，然后只需输入一个 `dotnet new console` 命令。这将创建两个文件，定义了
    .NET Core 的最简单应用程序（控制台应用程序）。
- en: At that moment, you should see a `program.cs` and a `[NameOfDirectory].csproj`
    file, which contains dependency information for your app.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在那一刻，你应该会看到一个 `program.cs` 文件和一个 `[NameOfDirectory].csproj` 文件，其中包含你的应用程序的依赖信息。
- en: Notice that previous versions used a `project.json` file instead, with the same
    information, but if you open any previous project with V. Studio 2017 it will
    recognize it and migrate it automatically.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，之前的版本使用了一个 `project.json` 文件，其中包含相同的信息，但如果你用 V. Studio 2017 打开任何之前的项目，它将识别它并自动迁移。
- en: The contents of the `.csproj` file, contain a few basic directives in XML format.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`.csproj` 文件的内容包含一些基本的 XML 格式指令。'
- en: To keep working with very basic resources in this initial demo, I'm going to
    use Notepad++ for code coloring and some other editing features.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在这个初始演示中使用非常基本的资源，我将使用 Notepad++ 进行代码着色和一些其他编辑功能。
- en: 'You should see the following content in the `.csproj` file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在 `.csproj` 文件中看到以下内容：
- en: '![](img/0be4c177-7e07-4c2f-ab76-a0d51b1513af.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0be4c177-7e07-4c2f-ab76-a0d51b1513af.png)'
- en: As you see, it indicates we're using the .NET SDK, the output is an `exe` file,
    and we're targeting NET Core 2.0.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这表明我们正在使用 .NET SDK，输出是一个 `exe` 文件，并且我们针对的是 NET Core 2.0。
- en: 'The contents of our `program.cs` file are as expected (no changes from a typical
    Console application, in a classical .NET Framework):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `program.cs` 文件的内容如预期（与典型的控制台应用程序在经典 .NET Framework 中没有变化）：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: But, still, we need to download the dependencies, a task that is performed using
    a `dotnet restore` command previous to any other options. After issuing that command,
    you'll see how it downloads all required packages, and a new `obj` directory shows
    up.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们仍然需要下载依赖项，这是一个使用 `dotnet restore` 命令在所有其他选项之前执行的任务。发出该命令后，你会看到它下载所有必需的包，并且会出现一个新的
    `obj` 目录。
- en: And that's it. You can finally issue the `dotnet run` command, which, in turn,
    compiles and executes the app, showing the expected message in the console (nothing
    new, I omited the output).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。你最终可以发出 `dotnet run` 命令，该命令会编译并执行应用程序，在控制台中显示预期的消息（没有新内容，我省略了输出）。
- en: Changing to ASP .NET Core
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换到 ASP .NET Core
- en: Now, to change our application into an ASP.NET Core app, the first thing to
    do is to install the package called `Microsoft.AspNetCore`. We can do this by
    issuing the `dotnet add package Microsoft.AspNetCore` command.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要将我们的应用程序更改为ASP.NET Core应用程序，首先要做的事情是安装名为 `Microsoft.AspNetCore` 的包。我们可以通过发出
    `dotnet add package Microsoft.AspNetCore` 命令来完成此操作。
- en: 'When we do that, the command-line tool will download the appropriate package
    and modify our `.csproj` accordingly, so it is included in our solution as well
    (see the new version of `csproj` after issuing the command):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，命令行工具将下载适当的包并相应地修改我们的 `.csproj` 文件，因此它也被包含在我们的解决方案中（在发出命令后查看 `csproj`
    的新版本）：
- en: '![](img/ef2bb94e-08b9-42aa-8ff6-3a586b085d2f.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ef2bb94e-08b9-42aa-8ff6-3a586b085d2f.png)'
- en: We see the presence of a new `<ItemGroup>` tag, indicating the reference to
    include and the version that has been downloaded and added to the project.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到一个新的 `<ItemGroup>` 标签的存在，它指示要包含的引用及其已下载并添加到项目中的版本。
- en: We're now ready to create our web starting now that will take the form of a
    class named `Startup.cs` (of course you can name it as you want as long as you
    configure it later. It's not a convention name).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好创建我们的网站了，它将以一个名为 `Startup.cs` 的类的形式出现（当然，只要你稍后进行配置，你可以将其命名为你想要的任何名称。这不是一个约定名称）。
- en: 'Inside that file, we''ll reference the three extra namespaces required to create
    a website (although a basic one):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个文件中，我们将引用创建网站所需的三个额外命名空间（尽管是一个基本的网站）：
- en: '`Microsoft.AspNetCore.Builder`: To actually build a web server using the `config`
    parameters we''ve defined'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore.Builder`：使用我们定义的 `config` 参数实际构建Web服务器'
- en: '`Microsoft.AspNetCore.Hosting`: To hold the web application'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore.Hosting`：用于持有Web应用程序'
- en: '`Microsoft.AspNetCore.Http`: For all HTTP-related activities'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore.Http`：用于所有HTTP相关活动'
- en: With those references, we need to add a method named `Configure` (and this is
    by convention), where we will indicate the minimum actions to perform when the
    server is launched.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有这些引用后，我们需要添加一个名为 `Configure` 的方法（这是通过约定），我们将指示服务器启动时需要执行的最小操作。
- en: 'Here, we will start seeing DI in action, because the shape of this very basic
    method is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将开始看到依赖注入（DI）的实际应用，因为这个非常基本的方法的形状如下：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: But, before we start explaining the inner details of that file, let's make sure
    it compiles correctly and that we redirect our application to the new website.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在我们开始解释该文件的内部细节之前，让我们确保它能够正确编译，并且将我们的应用程序重定向到新的网站。
- en: So, we will issue another `dotnet restore` command, so all new references are
    located properly, and the next step will be to modify our main entry point, to
    create a new web host that uses the `Startup` class just created.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将发出另一个 `dotnet restore` 命令，以便所有新的引用都正确定位，下一步将是修改我们的主入口点，创建一个新的使用刚刚创建的 `Startup`
    类的Web宿主。
- en: 'With that purpose, the new `Main()` entry point will use a reference to `Microsoft.AspNetCore.Hosting`
    namespace, and define the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，新的 `Main()` 入口点将使用对 `Microsoft.AspNetCore.Hosting` 命名空间的引用，并定义以下内容：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we can repeat the `dotnet run` command and we will see two different
    outputs. On one side, the CLI environment, we will generate a web host and run
    it (by default, using port number `5000`), indicating that in the console output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以重复执行 `dotnet run` 命令，我们将看到两个不同的输出。在一侧的CLI环境中，我们将生成一个Web宿主并运行它（默认情况下，使用端口号
    `5000`），在控制台输出中指示：
- en: '![](img/af29f757-4ed4-4201-85d3-1a87a2859dea.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/af29f757-4ed4-4201-85d3-1a87a2859dea.png)'
- en: 'That host will keep on running and listen on that port until we stop it using
    *Ctrl* + *C*. Now, we can open a browser and type the URL to see the following
    page:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 该宿主将持续运行并监听该端口，直到我们使用 *Ctrl* + *C* 停止它。现在，我们可以打开浏览器并输入URL以查看以下页面：
- en: '![](img/e08ab7b6-8bbb-41a9-b255-a85a7d515ce5.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e08ab7b6-8bbb-41a9-b255-a85a7d515ce5.png)'
- en: Of course, that page doesn't contain any HTML, only the text we order the server
    to send back to the user when a request is received on that port. Just take a
    look at the source code if you want to check this out.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，那个页面不包含任何HTML，只有我们命令服务器在接收到该端口的请求时发送给用户的文本。如果你想检查这一点，请查看源代码。
- en: But, before we continue the explanation of the previous code, it's important
    to understand the concept of Middleware, present from the beginning in ASP.NET
    Core.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在我们继续解释前面的代码之前，理解中间件的概念非常重要，它从ASP.NET Core一开始就存在。
- en: Middleware
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件
- en: Of course, middleware refers to software, but to a software that is assembled
    using an application pipeline in a manner that facilitates handling requests and
    responses.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，中间件指的是软件，但是指使用应用程序管道组装的软件，这种方式便于处理请求和响应。
- en: 'Obviously, you may wonder what an application pipeline is. Wikipedia defines
    the terms like this: "*In software engineering, a pipeline consists of a chain
    of processing elements (processes, threads, coroutines, functions, etc.), arranged
    so that the output of each element is the input of the next; the name is by analogy
    to a physical pipeline*".'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你可能想知道应用程序管道是什么。维基百科这样定义这些术语：“*在软件工程中，管道由一系列处理元素（进程、线程、协程、函数等）组成，排列得使得每个元素的输出是下一个元素的输入；名称是类比物理管道*”。
- en: These pipelines are common in many software languages, even in modern constructions
    as in JavaScript Promises, which define asynchronous pipelines for a sequence
    of calls, improving execution control.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些管道在许多软件语言中都很常见，甚至在现代构建中，如 JavaScript Promises，它们定义了异步管道以进行一系列调用，从而提高了执行控制。
- en: One important feature of pipelines is that each component of the pipeline can
    decide whether it passes information to the next component or returns directly,
    and has the ability to perform custom actions before and after that component
    is invoked.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 管道的一个重要特性是，管道中的每个组件都可以决定是否将信息传递给下一个组件或直接返回，并且能够在调用该组件前后执行自定义操作。
- en: In ASP.NET Core, to build a request pipeline, we use delegates to handle each
    request. And, again, we find some of the SOLID principles present in this architecture.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 中，为了构建请求管道，我们使用委托来处理每个请求。而且，再次发现这个架构中存在一些 SOLID 原则。
- en: Every time you need to configure one of these delegates, you use one method
    belonging to the method's families called `Use*`, `Run*` and `Map*` (they are
    sets of predefined extension methods starting with these prefixes, each one with
    a specific purpose).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每次需要配置这些委托之一时，你都会使用属于 `Use*`、`Run*` 和 `Map*` 方法家族的一个方法（它们是以这些前缀开始的预定义扩展方法集，每个都有特定的用途）。
- en: 'These methods are linked to the `IApplicationBuilder` object that the `Configure`
    method receives via Dependency Injection. The following schema visually explains
    this structure (notice that the thread of execution follows the black arrows):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法与 `Configure` 方法通过依赖注入接收到的 `IApplicationBuilder` 对象相关联。以下图表直观地解释了这种结构（注意执行线程遵循黑色箭头）：
- en: '![](img/e904ea53-abd1-4178-941b-77b86fa9fec2.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e904ea53-abd1-4178-941b-77b86fa9fec2.png)'
- en: In this manner, it's totally up to the programmer to keep on passing the `IApplicationBuilder`
    object to another middleware piece (notice the call to `next()`) or avoid any
    other call, in which case it returns to the calling method.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，程序员完全负责继续将 `IApplicationBuilder` 对象传递给另一个中间件组件（注意对 `next()` 的调用）或避免任何其他调用，在这种情况下，它将返回到调用方法。
- en: If one of these delegates decides not to pass a request to the next delegate,
    that's called **short-circuiting** the request pipeline. This is often convenient
    to avoid having to perform any unnecessary work.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些委托中的任何一个决定不将请求传递给下一个委托，那么就称为**短路**请求管道。这通常很方便，可以避免执行任何不必要的操作。
- en: In the case of exception handling delegates, they need to be called early in
    the pipeline, to allow them to catch exceptions that might occur later in the
    sequence.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在异常处理委托的情况下，它们需要在管道的早期调用，以便它们可以捕获可能在序列中稍后发生的异常。
- en: Let's go now for the explanation of the previous code with all this in mind.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们带着这些想法来解释之前的代码。
- en: The Startup class and Dependency Injection
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Startup 类和依赖注入
- en: The `Startup` class coded previously is, therefore, the component in charge
    of configuring the request pipeline and handling all requests made to the application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，之前编写的 `Startup` 类是负责配置请求管道并处理所有发送到应用程序的请求的组件。
- en: This class is mandatory (although, as mentioned, it could be named differently)
    because the runtime will look inside it for the methods that take care of configuration
    aspects, and that includes services as well. You can consider it as a convenient
    way to achieve independent configurations via the first SOLID principle (SoC).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是强制性的（尽管，如前所述，它可以有不同的名称），因为运行时会查找它内部的配置方面负责的方法，这包括服务。你可以将其视为通过第一个 SOLID 原则（SoC）实现独立配置的一种便捷方式。
- en: One of the interesting features linked to this separation of responsibility
    is that you can define distinct **Startup** classes depending on the environment
    (development, production, and so on). The appropriate one will be selected at
    runtime.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与这种责任分离相关的有趣特性之一是，你可以根据环境（开发、生产等）定义不同的 **Startup** 类。适当的类将在运行时被选中。
- en: This class is defined in such a way that accepts dependencies provided via Dependency
    Injection, as well. For instance, you can declare variables of types `IHostingEnvironment`
    or `ILoggerFactory` to gain the ability to configure diverse functionality related
    to hosting or logging (remember in, Chapter 3, *Introducing Dependency Injection
    in .Net Core 2.0*).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是以接受通过依赖注入提供的依赖项的方式定义的。例如，你可以声明 `IHostingEnvironment` 或 `ILoggerFactory`
    类型的变量，以获得配置与托管或日志相关的不同功能的能力（记住在第三章中介绍 .Net Core 2.0 中的依赖注入）。
- en: So, what is mandatory in this class and what is optional? The `Configure` method
    is mandatory. No matter what the name of the class, the runtime will look for
    it inside and call it to make sure the required conditions apply.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在这个类中什么是必需的，什么是可选的？`Configure` 方法是必需的。无论类的名称是什么，运行时都会在其内部查找它，并调用它以确保应用所需的条件。
- en: 'However, the `ConfigureServices()` method is optional, but if it is present,
    it will be called prior to `Configure()` during that initial process. The following
    schema illustrates this sequence:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`ConfigureServices()` 方法是可选的，但如果它存在，它将在初始过程中在 `Configure()` 之前被调用。以下图示说明了这个顺序：
- en: '![](img/c606338c-ce7b-447d-8d4c-ad99ecd6ffad.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c606338c-ce7b-447d-8d4c-ad99ecd6ffad.png)'
- en: '(Image courtesy: [http://developer.telerik.com/featured/understanding-asp-net-core-initialization/](http://developer.telerik.com/featured/understanding-asp-net-core-initialization/))'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: （图片来源：[http://developer.telerik.com/featured/understanding-asp-net-core-initialization/](http://developer.telerik.com/featured/understanding-asp-net-core-initialization/))
- en: Before going any further in demos, let's explain the previous code in more detail.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步进行演示之前，让我们更详细地解释之前的代码。
- en: Code explanation
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码解释
- en: Starting with the `Main()` method, after a reference to the `Hosting` subspace
    that we mentioned previously, we build a new web server by calling the `WebHostBuilder`
    class. This class permits configuration and building of a web server using various
    middleware pieces and entry point conditions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Main()` 方法开始，在提到之前提到的 `Hosting` 子空间之后，我们通过调用 `WebHostBuilder` 类来构建一个新的网络服务器。这个类允许使用各种中间件组件和入口点条件来配置和构建网络服务器。
- en: 'Thus, after calling the constructor, we piped another three calls:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在调用构造函数之后，我们管道了另外三个调用：
- en: One to `UseKestrel()`, which is the default, light-weight server for development
    that Visual Studio 2017 (and the CLI) uses (we'll explain that in a while)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `UseKestrel()` 方法，这是 Visual Studio 2017（以及 CLI）使用的默认轻量级开发服务器（我们稍后会解释这一点）
- en: Another call to `UseStartup<Startup>()`, to indicate where the server will find
    the `Configure()` method to initiate its process (remember the name of the class
    is irrelevant, as far as it contains the method `Kestrel` looks for initially)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一次调用 `UseStartup<Startup>()`，以指示服务器将在何处找到 `Configure()` 方法来启动其进程（记住类的名称无关紧要，只要它包含
    `Kestrel` 初始查找的方法即可）
- en: And, finally, another one to `Build()`, which creates and initializes the new
    server with those previous values
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，还有一个 `Build()` 方法，它使用之前设置的值创建并初始化新的服务器
- en: With all that in place, that last sentence simply calls the `Run()` method to
    launch the process.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些准备就绪之后，最后一句话只是调用了 `Run()` 方法来启动进程。
- en: When launching that process, the `Configure` method turns on. Its only parameter
    (in this case), is of type `IApplicationBuilder`, and, as you see, is served to
    this method by Dependency Injection (no previous references or instantiation were
    made by our code).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动该进程时，`Configure` 方法被激活。它的唯一参数（在这种情况下）是 `IApplicationBuilder` 类型，并且，正如你所看到的，它通过依赖注入（我们的代码没有进行任何先前的引用或实例化）传递给这个方法。
- en: Consequently, when a server is created, the main, basic objects implied in the
    communication process are served in this manner, expecting from the user all required
    behaviors in the form of subsequent calls to its methods.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当创建服务器时，在通信过程中隐含的主要基本对象以这种方式提供服务，期望用户以后续调用其方法的形式提供所有所需的行为。
- en: 'It''s pretty self-explanatory if we take a look at the interface definition:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看接口定义，这相当直观：
- en: '![](img/fa04f5a6-c91e-46c7-844a-ad9e9c73504a.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa04f5a6-c91e-46c7-844a-ad9e9c73504a.png)'
- en: By the time the `Configure` method receives an instance of the `IApplicationBuilder`
    class, a bunch of extra functionality is available. As mentioned previously, it
    has been made available via extension methods, adopting the form of `Use*`, `Run*`,
    and `Map*` methods, which help the programmer in coding configuration aspects
    and obtaining more independence and granularity.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Configure`方法接收到`IApplicationBuilder`类的实例时，将提供一些额外的功能。如前所述，这些功能是通过扩展方法提供的，采用`Use*`、`Run*`和`Map*`方法的形式，这些方法帮助程序员在编码配置方面获得更多独立性和粒度。
- en: 'Notice how the following screenshot shows different configuration options and
    suggests the use of middleware:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下截图如何显示不同的配置选项并建议使用中间件：
- en: '![](img/6e14830b-65c3-4608-afee-98d832519948.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e14830b-65c3-4608-afee-98d832519948.png)'
- en: Each of these extension methods supplies a way to call the implied delegate.
    Notice that while the `Use*` family of methods calls `Next()` implicitly many
    times to keep on going in the pipeline (actually it depends on other features),
    the `Run*` family stops the propagation and short-circuits the pipeline (therefore,
    it doesn't call a next request delegate).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每种扩展方法都提供了一种调用隐式委托的方式。请注意，虽然`Use*`方法族在管道中隐式地多次调用`Next()`以继续进行（实际上这取决于其他功能），但`Run*`方法族停止了传播并短路了管道（因此，它不会调用下一个请求委托）。
- en: Also, the `Map*` family allows branching the pipeline, making calls that return
    to that point and extending functionality accordingly.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Map*`方法族允许分支管道，执行返回该点的调用并相应地扩展功能。
- en: The New ASP.NET servers
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的ASP.NET服务器
- en: Let's quickly review some important aspects of the servers used when programming
    for ASP.NET Core since that is one of the main changes linked to this new platform.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下在为ASP.NET Core编程时使用的服务器的一些重要方面，因为这是与这个新平台相关的主要变化之一。
- en: First of all, an ASP.NET Core application runs an in-process HTTP server implementation.
    That implementation is listening for HTTP requests and sends those requests to
    the application wrapped in an object named `HttpContext` that holds a set of features
    composed into it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一个ASP.NET Core应用程序运行一个进程内的HTTP服务器实现。该实现正在监听HTTP请求，并将这些请求发送到名为`HttpContext`的对象中，该对象包含一组组合到其中的功能。
- en: 'This version of ASP.NET provides two distinct server implementations: `Kestrel`
    and `WebListener`. As the official documentation reminds us:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的ASP.NET提供了两种不同的服务器实现：`Kestrel`和`WebListener`。正如官方文档提醒我们的：
- en: Kestrel
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kestrel
- en: '`Kestrel` is a cross-platform HTTP server based on `libuv`, a cross-platform
    asynchronous I/O library:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kestrel`是一个基于`libuv`的跨平台HTTP服务器，`libuv`是一个跨平台的异步I/O库：'
- en: '`libuv` is defined as a multi-platform support library with a focus on asynchronous
    I/O. It was primarily developed for use by Node.js, but it''s also used by Luvit,
    Julia, pyuv, and others.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`libuv`被定义为一种多平台支持库，专注于异步I/O。它最初是为Node.js开发的，但也被Luvit、Julia、pyuv和其他使用。'
- en: Kestrel is the web server included by default in the ASP.NET Project templates.
    The advantage is that if your application accepts requests exclusively from an
    internal network, it can be used by itself.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Kestrel是包含在ASP.NET项目模板中的默认Web服务器。优点是，如果您的应用程序仅从内部网络接受请求，则可以单独使用它。
- en: 'This is the working scheme of a default scenario with Kestrel:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Kestrel默认场景的工作方案：
- en: '![](img/eda9b927-3790-45fd-b410-dad0faef0c7a.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eda9b927-3790-45fd-b410-dad0faef0c7a.png)'
- en: '(Image courtesy: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/))'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: （图片来源：[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/))
- en: However, if you expose the application to the internet, there are some security
    issues for which Kestrel is not prepared to cope (it's relatively new and still
    doesn't have the whole required set of defense resources). For those cases, the
    recommended configuration is to use a reverse proxy server, such as IIS, Apache,
    or Nginx, to provide functionality.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您将应用程序暴露给互联网，将存在一些Kestrel未准备好应对的安全问题（它相对较新，并且还没有整个所需的安全资源集）。对于这些情况，建议的配置是使用反向代理服务器，例如IIS、Apache或Nginx，以提供功能。
- en: 'Notice that a reverse proxy server, as the documentation states, *receives
    HTTP requests from the Internet and forwards them to Kestrel after some preliminary
    handling* (see the following screenshot):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，正如文档所述，反向代理服务器*从互联网接收HTTP请求，并在进行一些初步处理后将其转发到Kestrel*（请参阅以下截图）：
- en: '![](img/bcbed41a-719b-4b2f-a69e-ef755a25a391.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bcbed41a-719b-4b2f-a69e-ef755a25a391.png)'
- en: '(Image courtesy: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/))'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: （图片来源：[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/))
- en: Another important point is that you can't use any of those reverse proxy servers
    without Kestrel or a custom server implementation. This is because ASP.NET Core
    was designed to run in its own process so it can behave consistently across platforms.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的一点是，没有Kestrel或自定义服务器实现，您不能使用任何那些反向代理服务器。这是因为ASP.NET Core被设计为在其自己的进程中运行，以便它可以在各个平台上保持一致的行为。
- en: The problem that we might face here is that IIS, Nginx, and Apache prescribe
    their own startup process and environment. The consequence is that to use them
    directly it should adapt to the requirements of each one.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能面临的问题是我们可能遇到的是IIS、Nginx和Apache规定了它们自己的启动过程和环境。结果是，为了直接使用它们，应该适应每个的要求。
- en: In this way, Kestrel gives ASP.NET Core the ability to code `Program` and `Startup`
    classes in any required form to suit the user's needs, while avoiding another
    dependency on a concrete, specific server. That's one of the reasons why middleware
    is so important in this context.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，Kestrel赋予了ASP.NET Core以任何所需形式编码`Program`和`Startup`类的功能，以满足用户的需求，同时避免对具体、特定服务器的另一个依赖。这也是中间件在这个环境中如此重要的原因之一。
- en: WebListener
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebListener
- en: '`WebListener` is a Windows-only HTTP server based on the `Http.Sys` kernel
    driver. It serves as an alternative for those scenarios where exposing our app
    to the internet is mandatory, but we don''t wish to use IIS if we cannot do it
    for some reason.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebListener`是一个基于`Http.Sys`内核驱动器的Windows专用HTTP服务器。它作为那些场景的替代方案，在这些场景中，将我们的应用程序暴露给互联网是强制性的，但我们不希望使用IIS，如果出于某种原因不能这样做的话。'
- en: 'The following schema represents the role of WebListener in a similar scenario
    as the one presented previously with Kestrel:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下架构表示WebListener在类似之前Kestrel所展示的场景中的角色：
- en: '![](img/c4bb5714-625b-4f2c-ad9f-25e870db28dd.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c4bb5714-625b-4f2c-ad9f-25e870db28dd.png)'
- en: '(Image courtesy: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/))'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: （图片来源：[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/))
- en: 'In the same way, if you need some of the features that Kestrel doesn''t support
    while working on an internal network, you could use WebListener in a quite comparable
    configuration:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果您在内部网络中工作需要Kestrel不支持的一些功能，您可以使用WebListener进行相当类似的配置：
- en: '![](img/7796eaba-9226-486a-822e-513f4c0a8157.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7796eaba-9226-486a-822e-513f4c0a8157.png)'
- en: '(Image courtesy: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/))'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: （图片来源：[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/))
- en: Finally, keep in mind that for internal network scenarios, Kestrel is recommended
    because it provides improved performance. In any case, if you want to know more
    about the features provided by WebListener, the official documentation is available
    at [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/weblistener](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/weblistener).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，对于内部网络场景，Kestrel是推荐的，因为它提供了改进的性能。无论如何，如果您想了解更多关于WebListener提供的功能，官方文档可在[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/weblistener](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/weblistener)找到。
- en: Dependency Inversion in the architecture - OWIN
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构中的依赖倒置 - OWIN
- en: It's also possible to create your own server implementation to work with ASP.NET
    Core. **Open Web Interface for .NET** (**OWIN**) is the third possible implementation
    supported by the platform.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 还有可能创建自己的服务器实现，以与ASP.NET Core一起工作。**.NET开放Web接口**（**OWIN**）是平台支持的第三种可能的实现。
- en: In some ways, the implementation of OWIN also relates to the Dependency Inversion
    Principle. Its main goal is to make web applications decoupled from web servers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，OWIN的实现也与依赖倒置原则相关。其主要目标是使Web应用程序与Web服务器解耦。
- en: With that purpose, it defines standard ways to create middleware that can be
    used in the pipeline, to configure and tune your server.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，它定义了创建中间件的标准方式，这些中间件可以在管道中使用，以配置和调整您的服务器。
- en: Analyzing the default template
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析默认模板
- en: Now it's time to open Visual Studio 2017 (or 2015, with ASP.NET Core installed)
    and take a look at it and explain how the default templates behave.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候打开Visual Studio 2017（或安装了ASP.NET Core的2015版本）并查看它，并解释默认模板是如何工作的。
- en: 'Remember that ASP.NET Core can execute using the classical.NET Framework as
    well, so, when you create a new Web project you''ll be asked, initially, to choose
    between three main options: classical ASP.NET, ASP.NET Core with NET Core, and
    ASP.NET Core with classical .NET Framework:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，ASP.NET Core也可以使用经典的.NET Framework执行，因此，当你创建一个新的Web项目时，你最初会被要求在三个主要选项之间进行选择：经典ASP.NET、带有.NET
    Core的ASP.NET Core和带有经典.NET Framework的ASP.NET Core：
- en: '![](img/d5a62e2e-b436-405f-b72b-1ded0e64ec91.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d5a62e2e-b436-405f-b72b-1ded0e64ec91.png)'
- en: 'Once selected, you''ll be offered another choice window: Empty, Web API, Web
    Application, Web Application (Model-View-Controller), and some new options added
    to version 2.0 for third-party libraries, which include Angular, React.js, and
    React.js and Redux.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择，你将看到一个额外的选择窗口：空、Web API、Web应用程序、Web应用程序（模型-视图-控制器），以及为第三方库添加到2.0版本的一些新选项，包括Angular、React.js和React.js与Redux。
- en: In the first case, the one we're using now creates an application with the minimum
    configuration to be able to create and run a web server using Kestrel and present
    some text in the browser. It's simple, but it allows us to check out how it is
    done with more detail and to make some changes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们现在使用的是创建一个具有最小配置的应用程序，以便能够使用Kestrel创建和运行一个Web服务器，并在浏览器中显示一些文本。它很简单，但允许我们更详细地了解它是如何完成的，并做出一些更改。
- en: The other three (Web API, Web Application, and Web App MVC) remind their counterpart
    in classic ASP.NET, with the difference that they use the new architecture and
    configuration files. In this manner, we'll be able to better appreciate the migration
    process needed to pass from the old architecture to the new one.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 其他三个（Web API、Web应用程序和Web App MVC）与经典ASP.NET中的对应项相似，不同之处在于它们使用新的架构和配置文件。这样，我们将能够更好地欣赏从旧架构迁移到新架构所需的迁移过程。
- en: 'You should see the following dialog box:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下对话框：
- en: '![](img/ed226be6-21c8-4aae-b66f-e4f0e56055a2.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed226be6-21c8-4aae-b66f-e4f0e56055a2.png)'
- en: Notice that you can also change authentication as in previous versions and that
    you have a checkbox that allows enabling Docker support.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你也可以像以前版本一样更改身份验证，并且有一个复选框允许启用Docker支持。
- en: The resulting project is a bit more complex than the basic demo we did previously,
    although the basic pieces are the same. However, there are some noticeable changes
    in configuration.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 结果项目比我们之前做的基本演示要复杂一些，尽管基本组件是相同的。然而，在配置方面有一些显著的变化。
- en: Configuration files
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置文件
- en: Once you compile the application and activate the See all files option in the
    Solution Explorer, you'll notice some extra configuration files that take care
    of a few tasks, such as launching the browser on the default URL. These options
    are defined inside the `launchSettings.json` file available inside the `Properties`
    directory.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译了应用程序并激活了解决方案资源管理器中的“查看所有文件”选项，你将注意到一些额外的配置文件，它们负责一些任务，例如在默认URL上启动浏览器。这些选项定义在`Properties`目录中可用的`launchSettings.json`文件内。
- en: 'A look at it is also quite explanatory:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 看一看也是相当说明性的：
- en: '[PRE3]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you see, three main areas of configuration apply here: `iisSettings`, to
    indicate IIS behavior, including the URL to use, a `profiles` section that only
    contains one profile for `IISExpress`, indicating that a browser should be launched
    and a hint on the development mode, and a final one under the name of the application
    itself (`ASPNETCoreDemo1`), with similar information.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里应用了三个主要的配置区域：`iisSettings`，用于指示IIS行为，包括要使用的URL，一个只包含一个`IISExpress`配置文件的`profiles`部分，表示应该启动一个浏览器，以及关于开发模式的提示，以及一个名为应用程序本身（`ASPNETCoreDemo1`）的最终配置，包含类似的信息。
- en: 'Of course, if you dig into the `\bin` or `\obj` directories, you''ll see some
    more, such as `ASPNETCoreDemo1.runtimeconfig.json` with extra information. And,
    finally, if you examine the .`csproj` you''ll see some additions as well:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你深入到`\bin`或`\obj`目录，你会看到更多，例如带有额外信息的`ASPNETCoreDemo1.runtimeconfig.json`。最后，如果你检查`.csproj`文件，你也会看到一些添加项：
- en: Remember that on the project's context menu option at the Solution Explorer
    you now have an option that allows you to open it directly in Visual Studio 2017.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在解决方案资源管理器的项目上下文菜单选项中，你现在有一个选项可以直接在Visual Studio 2017中打开它。
- en: '[PRE4]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Not many changes, but now it indicates the use of the `wwwroot` folder and it
    adds the `ApplicationInsights` call. And, obviously, there's no indication of
    filetype, since, by default, the compiled assembly is a DLL.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 没有太多变化，但现在它表明了使用`wwwroot`文件夹，并添加了`ApplicationInsights`调用。显然，没有文件类型指示，因为默认情况下，编译的组件是一个DLL。
- en: The Entry Point
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入口点
- en: 'Let''s start with `program.cs`. Its `main()` method is similar, but it contains
    new middleware:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`program.cs`开始。它的`main()`方法类似，但它包含新的中间件：
- en: '[PRE5]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The three main differences are: `UseContentRoot()`, `UseIISIntegration()`,
    and `UseApplicationInsights()`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 三大主要区别是：`UseContentRoot()`、`UseIISIntegration()`和`UseApplicationInsights()`。
- en: '`UseContentRoot(Directory.GetCurrentDirectory())`, indicates that whenever
    the user requests a physical resource, that''s the directory to search in. By
    default, it''s going to point to the `wwwroot` directory.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseContentRoot(Directory.GetCurrentDirectory())`表示，当用户请求物理资源时，将搜索该目录。默认情况下，它将指向`wwwroot`目录。'
- en: '`UseIISIntegration()` is there to indicate that IIS will be used as a reverse
    proxy (as we mentioned previously), and finally, `UseApplicationInsights()` helps
    monitor and audit your application.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseIISIntegration()`用于指示将使用IIS作为反向代理（如我们之前提到的），而`UseApplicationInsights()`则有助于监控和审计您的应用程序。'
- en: As the official documentation states ([https://github.com/Microsoft/ApplicationInsights-aspnetcore/wiki/Getting-Started-with-Application-Insights-for-ASP.NET-Core](https://github.com/Microsoft/ApplicationInsights-aspnetcore/wiki/Getting-Started-with-Application-Insights-for-ASP.NET-Core))
    it allows us to *Monitor your live ASP.NET Core applications with Visual Studio
    Application Insights. Application Insights is an extensible analytics platform
    that monitors the performance and usage of your live web applications. With the
    feedback you get about the performance and effectiveness of your app in the wild,
    you can make informed choices about the direction of the design in each development
    lifecycle.*
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如官方文档所述（[https://github.com/Microsoft/ApplicationInsights-aspnetcore/wiki/Getting-Started-with-Application-Insights-for-ASP.NET-Core](https://github.com/Microsoft/ApplicationInsights-aspnetcore/wiki/Getting-Started-with-Application-Insights-for-ASP.NET-Core)），它允许我们使用Visual
    Studio Application Insights监控您的实时ASP.NET Core应用程序。Application Insights是一个可扩展的分析平台，它监控您的实时Web应用程序的性能和用法。通过您从应用程序在野外的性能和有效性获得的反馈，您可以在每个开发生命周期中做出明智的设计方向选择。
- en: So, we have an entry point reinforced with new middleware, and thus, we can
    use DI from the start. Let's see what it's done in the `Startup` class (the configuration).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个通过新的中间件加强的入口点，因此我们可以从开始使用DI。让我们看看`Startup`类（配置）中它做了什么。
- en: The default Startup class
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认的Startup类
- en: The first point to notice is the presence of `ConfigureServices` (even if it's
    empty). As you can see in the following screenshot, it allows adding distinct
    services to our pipeline, storing them in the `services` collection. This will
    be the place to register our own services as well.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是`ConfigureServices`的存在（即使它是空的）。如图所示，它允许向我们的管道添加不同的服务，并将它们存储在`services`集合中。这将是我们注册我们自己的服务的地方。
- en: 'Also notice that some of these methods are ready to add services with distinct
    lifetime configuration (`AddSingleton`, `AddScoped`, and `AddTransient`). Later,
    we''ll see how to add services at this point to allow applications to use a given
    functionality, such as Database Access, and so on, using this `IServiceCollection`
    object that it received through Dependency Injection (see the following screenshot):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，其中一些方法已经准备好添加具有不同生命周期配置的服务（`AddSingleton`、`AddScoped`和`AddTransient`）。稍后，我们将看到如何在此处添加服务，以便应用程序可以使用给定的功能，例如数据库访问等，使用它通过依赖注入接收到的`IServiceCollection`对象（请参阅以下截图）：
- en: '![](img/0d92032f-eea0-49fc-804b-c8bf0531f737.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d92032f-eea0-49fc-804b-c8bf0531f737.png)'
- en: 'As for the `Configure()` method, this time it receives (via Dependency Injection,
    of course), three instances of types `IApplicationBuilder`, `IHostingEnvironment`,
    and `ILoggerFactory` as the following code shows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`Configure()`方法，这次它通过依赖注入（当然，当然是通过依赖注入），接收了三个类型的实例：`IApplicationBuilder`、`IHostingEnvironment`和`ILoggerFactory`，如下代码所示：
- en: '[PRE6]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first one is used at the end to launch the application, only this time using
    the `async/await` structure to guarantee a formal asynchronous call, returning
    a string.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个在应用程序结束时使用，用于启动应用程序，这次使用`async/await`结构来保证正式的异步调用，返回一个字符串。
- en: '`ILoggerFactory` is used in a similar manner as we did in Chapter 3, *Introducing
    Dependency Injection in .NET Core 2.0*, to configure messages that will be output
    to the console.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`ILoggerFactory` 的使用方式与我们在第 3 章，“.NET Core 2.0 中的依赖注入介绍”中所做的方式相似，用于配置将输出到控制台的消息。'
- en: Finally, the `IHostingEnvironment` variable is used to check if the application
    is in development mode, and, in that case, to configure a developer exception
    page, which we can define elsewhere.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`IHostingEnvironment` 变量用于检查应用程序是否处于开发模式，如果是这样，则配置一个开发者异常页面，我们可以在其他地方定义它。
- en: 'ASP.NET Core distinguishes four possible development modes: `development`,
    `production`, `staging`, and a fourth one `environment` that allows defining your
    own. That value is configurable inside the `Project/Properties/Debug` window,
    where you can now add distinct environment variables, as you can see in the following
    screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 区分了四种可能的开发模式：`development`、`production`、`staging` 和一个第四个 `environment`
    模式，允许定义自己的模式。该值可以在 `Project/Properties/Debug` 窗口中配置，您现在可以添加不同的环境变量，就像您在下面的屏幕截图中所看到的那样：
- en: '![](img/67749781-f661-4470-910e-e6817c4b0d8c.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/67749781-f661-4470-910e-e6817c4b0d8c.png)'
- en: These values are read by the `IHostingEnvironment` object allowing the insertion
    of actions prior to the application launching process. Notice it's not a single
    value, but a collection, so you can add as many environment values as needed and
    use this object's methods to read whether some of them are true.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值由 `IHostingEnvironment` 对象读取，允许在应用程序启动过程之前插入操作。请注意，它不是一个单一值，而是一个集合，因此您可以添加所需的环境值，并使用该对象的方法来读取其中的一些是否为真。
- en: 'You could also use something like `ASPNETCORE_ENVIRONMENT"="MyCompany` to define
    your own and check this value easily, using the `IsEnvironment()` method, as you
    can see in the following screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用类似 `ASPNETCORE_ENVIRONMENT="MyCompany"` 这样的方式来自定义并轻松检查这个值，就像您在下面的屏幕截图中所看到的那样，使用
    `IsEnvironment()` 方法。
- en: '![](img/f9d6845f-e431-40aa-b5e7-8af821d6c4da.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9d6845f-e431-40aa-b5e7-8af821d6c4da.png)'
- en: 'So, if we change the previous `development` value for a customized one, such
    as `PACKT`, we can modify the exit in the browser with the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们将之前的 `development` 值更改为一个自定义值，例如 `PACKT`，我们可以在浏览器中用以下方式修改退出：
- en: '[PRE7]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output will be different in this case, so we''re free to configure anything
    and mix it with other values to have a totally customized, mode-dependent, experience:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出将不同，因此我们可以自由配置任何内容，并将其与其他值混合，以获得完全定制、模式依赖的体验：
- en: '![](img/029c6027-b9b3-4666-aeb9-0b9ebc5ec85e.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/029c6027-b9b3-4666-aeb9-0b9ebc5ec85e.png)'
- en: But, there's much more in relation to DI, as we're going to see in the next
    sections.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，关于依赖注入还有很多内容，我们将在接下来的几节中看到。
- en: Dependency Injection in ASP.NET Core
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 中的依赖注入
- en: 'Of course, this behavior is possible thanks to the presence of a DI Container
    inside the ASP.NET Core engine. The official documentation states it very clearly:
    *if a given type has declared that it has dependencies, and the container has
    been configured to provide the dependency types, it will create the dependencies
    as part of creating the requested instance*.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种行为得益于 ASP.NET Core 引擎内部存在一个依赖注入容器。官方文档非常清楚地说明了这一点：*如果给定类型已声明它有依赖项，并且容器已配置为提供依赖类型，它将在创建请求的实例时创建这些依赖项*。
- en: The container, in this way, manages an object's lifetime and avoids the need
    for hard-coded object construction.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，容器管理一个对象的生命周期，避免了硬编码对象构造的需要。
- en: Besides other built-in implementations, remember that ASP.NET Core provides
    a simple DI Container (that we already tested in Chapter 3, *Introducing Dependency
    Injection in .Net Core 2.0*), represented by the `IServiceProvider` interface.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其他内置实现之外，请记住 ASP.NET Core 提供了一个简单的依赖注入容器（我们在第 3 章，“.Net Core 2.0 中的依赖注入介绍”中已经测试过），它由
    `IServiceProvider` 接口表示。
- en: As we mentioned, the place to configure services using that interface in this
    platform is the `ConfigureServices` method, which we will analyze in the following
    section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所提到的，在这个平台上使用该接口配置服务的位置是 `ConfigureServices` 方法，我们将在下一节中分析它。
- en: Services provided by ASP.NET Core
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 提供的服务
- en: 'There''s quite a large list of services available inside ASP.NET Core via Dependency
    Injection. The following table shows these services together with an indication
    of its lifetime:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过依赖注入，ASP.NET Core 内部提供了相当多的服务。以下表格显示了这些服务及其生命周期的指示：
- en: '| **Service Type** | **Lifetime** |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| **服务类型** | **生命周期** |'
- en: '| `Microsoft.AspNetCore.Hosting.IHostingEnvironment` | Singleton |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.AspNetCore.Hosting.IHostingEnvironment` | 单例 |'
- en: '| `Microsoft.Extensions.Logging.ILoggerFactory` | Singleton |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.Extensions.Logging.ILoggerFactory` | 单例 |'
- en: '| `Microsoft.Extensions.Logging.ILogger<T>` | Singleton |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.Extensions.Logging.ILogger<T>` | 单例 |'
- en: '| `Microsoft.AspNetCore.Hosting.Builder.IApplicationBuilderFactory` | Transient
    |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.AspNetCore.Hosting.Builder.IApplicationBuilderFactory` | 请求范围
    |'
- en: '| `Microsoft.AspNetCore.Http.IHttpContextFactory` | Transient |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.AspNetCore.Http.IHttpContextFactory` | 请求范围 |'
- en: '| `Microsoft.Extensions.Options.IOptions<T>` | Singleton |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.Extensions.Options.IOptions<T>` | 单例 |'
- en: '| `System.Diagnostics.DiagnosticSource` | Singleton |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `System.Diagnostics.DiagnosticSource` | 单例 |'
- en: '| `System.Diagnostics.DiagnosticListener` | Singleton |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `System.Diagnostics.DiagnosticListener` | 单例 |'
- en: '| `Microsoft.AspNetCore.Hosting.IStartupFilter` | Transient |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.AspNetCore.Hosting.IStartupFilter` | 请求范围 |'
- en: '| `Microsoft.Extensions.ObjectPool.ObjectPoolProvider` | Singleton |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.Extensions.ObjectPool.ObjectPoolProvider` | 单例 |'
- en: '| `Microsoft.Extensions.Options.IConfigureOptions<T>` | Transient |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.Extensions.Options.IConfigureOptions<T>` | 请求范围 |'
- en: '| `Microsoft.AspNetCore.Hosting.Server.IServer` | Singleton |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.AspNetCore.Hosting.Server.IServer` | 单例 |'
- en: '| `Microsoft.AspNetCore.Hosting.IStartup` | Singleton |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.AspNetCore.Hosting.IStartup` | 单例 |'
- en: '| `Microsoft.AspNetCore.Hosting.IApplicationLifetime` | Singleton |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.AspNetCore.Hosting.IApplicationLifetime` | 单例 |'
- en: As you see, this is a pretty comprehensive list of choices, to which we have
    to add the functionality already available and "installable" via `Run*`, `Use*`,
    and `Map*` methods commented on previously.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一个相当全面的选项列表，我们必须添加通过 `Run*`, `Use*` 和 `Map*` 方法注释中提到的“已安装”和“可用”的功能。
- en: 'So, we can distinguish two flavors of method, here: those already available
    and ready to include at will (the ones shown in `Program/Main`), and those that
    you can customize (using the `Startup` class), either by addition or by creating
    your own classes and interfaces and adding them to the `ConfigureServices` initial
    process.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以区分两种方法类型，在这里：那些已经可用且可以随意包含的方法（在 `Program/Main` 中显示的），以及那些你可以自定义的方法（使用
    `Startup` 类），无论是通过添加还是通过创建自己的类和接口并将它们添加到 `ConfigureServices` 初始过程中。
- en: The relation of services available at startup
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动时可用服务的关联
- en: 'In summary, we have several ways to include functionality via Dependency Injection
    in ASP.NET Core 2.0, via the Startup class:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们有几种方式可以通过依赖注入在 ASP.NET Core 2.0 中通过 Startup 类包含功能：
- en: By creating your own constructor for the Startup class, which refers to a previously
    define map Interface => Class
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过为 Startup 类创建自己的构造函数，该构造函数引用先前定义的映射接口 => 类
- en: By referring to the service required in the `ConfigureServices` method
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引用 `ConfigureServices` 方法中所需的服务
- en: By using the `Configure()` method in the ways we've seen
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用我们看到的 `Configure()` 方法的方式
- en: 'If you consider the methods of `Startup` in the order they are executed, the
    following services are at your disposal:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照执行顺序考虑 `Startup` 的方法，以下服务可供使用：
- en: 'Constructor: `IHostingEnvironment`, `ILoggerFactory`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数：`IHostingEnvironment`, `ILoggerFactory`
- en: '`* ConfigureServices`: `IServiceCollection`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`* 服务配置`: `IServiceCollection`'
- en: 'Configure: `IApplicationBuilder`, `IHostingEnvironment`, `ILoggerFactory`,
    `IApplicationLifetime`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置：`IApplicationBuilder`, `IHostingEnvironment`, `ILoggerFactory`, `IApplicationLifetime`
- en: Identifying Services in the Web Application template
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Web 应用程序模板中识别服务
- en: The Web Application template is much more revealing regarding the use of services
    and the role of Dependency Injection, so we're going to create a project equivalent
    to the classic ASP.NET MVC 5 available for a classic .NET Framework so we can
    compare both, identifying this functionality.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用程序模板在展示服务和依赖注入的角色方面更为明显，因此我们将创建一个与经典 ASP.NET MVC 5 相当的项目，以便在经典 .NET Framework
    中进行比较，从而识别这些功能。
- en: 'Once you create one of these new projects, you''ll probably identify many of
    the elements that were present in the previous version: folders for controllers
    and views, Razor files defining the distinct views in the application, and so
    on.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个这样的新项目，你可能会发现许多在先前版本中存在的元素：用于控制器和视图的文件夹，定义应用程序中不同视图的 Razor 文件等。
- en: But, now that we've seen some of the main changes, a review of the critical
    files is quite enlightening. There are no changes in `Program/Main`, but we'll
    find a lot in the `Startup` class. The references (`using` statements) are the
    same as in the basic demo, so I'm omitting the code here.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，现在我们已经看到了一些主要的变化，对关键文件的回顾是非常有启发性的。在 `Program/Main` 中没有变化，但我们在 `Startup` 类中会发现很多。引用（`using`
    语句）与基本演示相同，所以我在这里省略了代码。
- en: 'The most interesting come inside the `Startup` class itself:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的部分在 `Startup` 类本身：
- en: '[PRE8]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Up to this point, the default template only initializes the MVC engine, considering
    it an extra service, totally optional to the user.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，默认模板只初始化 MVC 引擎，将其视为一个额外的服务，对用户来说完全是可选的。
- en: 'Further on, we''ll see how to use this method to register and configure other
    built-in or customized services:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何使用此方法注册和配置其他内置或自定义服务：
- en: '[PRE9]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First of all, we now have a constructor and a read-only private property (`Configuration`)
    of type `IConfigurationRoot`. Well, it happens that the `builder.Build()` method
    called at the end of the constructor, is of this type and provides a convenient
    way to include and access all configuration information loaded from several `.json`
    files in the distinct application's folders.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们现在有一个构造函数和一个只读私有属性（`Configuration`），其类型为 `IConfigurationRoot`。嗯，在构造函数末尾调用的
    `builder.Build()` 方法就是这种类型，并提供了一种方便的方式来包含和访问从多个 `.json` 文件中加载的所有配置信息。
- en: 'All that information is collected at the very beginning of the process of initialization,
    so whatever has to be read from the outside is ready before `ConfigureServices`
    and `Configure` come into play (see the following screenshot showing the value
    of `Configuration` after loading):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些信息都在初始化过程的非常开始时收集，所以任何需要从外部读取的内容都在 `ConfigureServices` 和 `Configure` 调用之前准备好（参见以下截图显示加载后的
    `Configuration` 值）：
- en: '![](img/973d5311-1183-457c-ad0f-8d1af9f5db9f.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/973d5311-1183-457c-ad0f-8d1af9f5db9f.png)'
- en: As you see, the `ConfigurationBuilder` class is created in the first sentence
    of the constructor, and takes care of loading and reading the content of all these
    .`json` files, and adding environment variables. This allows further access to
    any `json`-defined value, and the ability to tune-up the application with external
    information.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`ConfigurationBuilder` 类在构造函数的第一句话中被创建，并负责加载和读取所有这些 `.json` 文件的内容，并添加环境变量。这允许进一步访问任何
    `json` 定义的值，以及使用外部信息调整应用程序的能力。
- en: With all that info collected, the `ConfigureServices` method comes and registers
    a set of services, such as MVC, by adding a `UseMvc` call (yes, it's not available
    by default, and has to be explicitly added to the pipeline if we want to use that
    architecture).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 收集了所有这些信息后，`ConfigureServices` 方法出现并注册了一组服务，例如 MVC，通过添加 `UseMvc` 调用来实现（是的，它默认不可用，如果我们想使用该架构，必须显式将其添加到管道中）。
- en: As you've seen along these samples, this ASP.NET middleware, such as MVC, follows
    a convention of using a single `Add*ServiceName*` extension method to register
    all of the services required by that feature. Also, notice that this call only
    adds the service to the collection of services, but it does not configure it (that
    comes later).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在这些示例中看到的，这个 ASP.NET 中间件，如 MVC，遵循使用单个 `Add*ServiceName*` 扩展方法来注册该功能所需的所有服务的约定。注意，这个调用只将服务添加到服务集合中，但它并没有配置它（这将在稍后进行）。
- en: Then, the `Configure()` method comes in. It first recovers information from
    the `Configuration` object (`Logging` section) and adds debugging capabilities
    in the way we saw in the previous chapter.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Configure()` 方法出现。它首先从 `Configuration` 对象（`Logging` 部分）中恢复信息，并添加了我们之前章节中看到的方式的调试功能。
- en: It follows with error handling, by checking if we are in development mode or
    another one (it also enables `BrowserLink` capabilities), and goes on with a call
    to `UseStaticFiles()`, to allow recovering and serving local files (you guessed
    it, it's not available by default, either).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接着是错误处理，通过检查我们是否处于开发模式或其他模式（它还启用了 `BrowserLink` 功能），然后继续调用 `UseStaticFiles()`，允许恢复和提供本地文件（正如你所猜到的，它也默认不可用）。
- en: 'Notice that this feature can be configured to point someplace else (relative
    request path) on the server (see the screenshot):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个功能可以被配置为指向服务器上的其他位置（相对请求路径）：
- en: '![](img/3c44a65c-ad4a-4160-8695-e06c9ca28e45.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3c44a65c-ad4a-4160-8695-e06c9ca28e45.png)'
- en: The last step is configuring MVC routes with a call to `UseMvc()`, in which
    the route's configuration is provided. Notice how different this approach is in
    comparison to classical ASP.NET MVC 4/5, in which you would register these routes
    in a different file. However, the syntax is similar, only this time you define
    it via lambda expressions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是通过调用 `UseMvc()` 配置 MVC 路由，其中提供了路由的配置。注意，与传统的 ASP.NET MVC 4/5 相比，您会在不同的文件中注册这些路由，这种方法是如何不同的。然而，语法是相似的，只是这次您通过
    lambda 表达式定义它。
- en: 'As you can deduct from the code, the first lambda argument is given by Dependency
    Injection and it''s of type `IRootBuilder`. Take a look at the Intellisense information
    provided by the IDE to check this feature, which is shown in the following screenshot:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从代码中可以推断出的，第一个 lambda 参数是由依赖注入提供的，并且其类型为 `IRootBuilder`。查看 IDE 提供的 Intellisense
    信息以检查此功能，如下面的截图所示：
- en: '![](img/af2577e7-c2ee-40f8-a2ee-8d4ffc87c0b9.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af2577e7-c2ee-40f8-a2ee-8d4ffc87c0b9.png)'
- en: The default route is then configured to point to the `HomeController` class
    and the `Index` action method if no other combination is supplied by the request
    (the syntax has also been a bit simplified).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，默认路由被配置为指向 `HomeController` 类和 `Index` 动作方法，如果没有其他组合由请求提供（语法也略有简化）。
- en: So, our conclusion after this trip through the `Startup` class is that the most
    important architectural aspects of ASP.NET Core and its MVC variant are provided
    via Dependency Injection, and that it is the developer's duty to tune up their
    application in this manner having the ability to include/exclude only those pieces
    that are needed by the application, with the minimum overload.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们通过 `Startup` 类的这次旅行得出的结论是，ASP.NET Core 及其 MVC 变体的最重要的架构方面是通过依赖注入提供的，并且开发者有责任以这种方式调整他们的应用程序，以便只包含/排除应用程序需要的部分，以最小化过载。
- en: Using Dependency Injection in ASP.NET MVC Views
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 ASP.NET MVC 视图中使用依赖注入
- en: Steve Smith proposes a demo ([http://ardalis.com/how-to-list-all-services-available-to-an-asp-net-core-app](http://ardalis.com/how-to-list-all-services-available-to-an-asp-net-core-app))
    that can clarify the total of services available at a given moment.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫·史密斯提出一个演示（[http://ardalis.com/how-to-list-all-services-available-to-an-asp-net-core-app](http://ardalis.com/how-to-list-all-services-available-to-an-asp-net-core-app)），它可以阐明在特定时刻可用的服务总数。
- en: This gave me an idea for another demo about how to include the namespace `Microsoft.Extensions.DependencyInjection`
    inside a view, using MVC to obtain a list of all services available. So let's
    start with the default template we just analyzed, and make the proper modifications.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我一个关于如何使用 MVC 获取所有可用服务的列表的另一个演示的想法，即在视图中包含 `Microsoft.Extensions.DependencyInjection`
    命名空间。让我们从我们刚刚分析的默认模板开始，并进行适当的修改。
- en: 'First, if we want to integrate the list as a new option inside the main menu
    of the Web Application template, we need to add a new link inside the `_Layout.cshtml`
    file that points to the corresponding view that will show all our services. That''s
    quite straightforward (notice that there''s no `ActionLinks` here as in the previous
    version):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们想在 Web 应用程序模板的主菜单中集成列表作为新的选项，我们需要在 `_Layout.cshtml` 文件中添加一个新的链接，指向将显示所有服务的相应视图。这相当直接（注意，这里没有像上一个版本中的
    `ActionLinks`）：
- en: '![](img/7e975755-6c3a-42ad-8fae-71d1dd60d6cf.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e975755-6c3a-42ad-8fae-71d1dd60d6cf.png)'
- en: With this new line, we're creating a new application menu element and the corresponding
    view (later named `ServicesAvailable`) will take advantage of Bootstrap classes
    loaded in the `_Layout.cshtml` header, to format the output and make it more readable.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一新行，我们创建了一个新的应用程序菜单元素和相应的视图（稍后命名为 `ServicesAvailable`），它将利用在 `_Layout.cshtml`
    标题中加载的 Bootstrap 类来格式化输出并使其更易于阅读。
- en: Now, if we think about the controller (`HomeController` in this case), we can
    add a new action method, following the syntax of the other methods, using the
    `ViewData` object to pass the required information to our new view.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们考虑控制器（在这个例子中是 `HomeController`），我们可以添加一个新的动作方法，遵循其他方法的语法，使用 `ViewData`
    对象将所需信息传递给我们的新视图。
- en: The information we need is stored in the instance of the `IServiceCollection`
    object defined inside `Startup.cs`, and we want to make it available for the controller
    so we can later assign it to our `ViewData` messenger.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的信息存储在 `Startup.cs` 中定义的 `IServiceCollection` 对象的实例中，我们希望使其对控制器可用，以便我们可以在以后将其分配给我们的
    `ViewData` 传递者。
- en: 'Let''s revisit the `Startup`, and make a few changes (not many). Actually,
    only these are required:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下`Startup`，并进行一些更改（不多）。实际上，只需要以下这些：
- en: '[PRE10]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We create a public static variable (`_services`) to hold all services once they
    have been configured and assign the `services` variable to it with the sole purpose
    of accessing its content from the controller.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个公共静态变量`_services`来保存所有服务，一旦配置完成，就将`services`变量分配给它，其唯一目的是从控制器中访问其内容。
- en: 'Now, back to the `HomeController`, we can add a new controller with this code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`HomeController`，我们可以添加一个新的控制器，代码如下：
- en: '[PRE11]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With these few lines, our services are now available inside the controller,
    and we can pass them to the view in a very simple way (notice there's no data
    model here since it's just a simple collection of data and the `ViewData` object
    serves just fine for this purpose).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这几行代码，我们的服务现在在控制器中可用，并且我们可以以非常简单的方式将它们传递给视图（注意这里没有数据模型，因为它只是一个简单的数据集合，而`ViewData`对象正好可以满足这个目的）。
- en: 'Finally, the last step will be to add the `ServicesAvailable` view. The code
    will be the following (I''ll start with the header''s explanation):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步将是添加`ServicesAvailable`视图。代码如下（我将从头部的解释开始）：
- en: '[PRE12]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, recall that when we make a reference to a namespace inside a view, the
    `using` sentence shall not belong to a block of code. Instead, it will be a standalone
    sentence headed by the `@` sign (we need the `DependencyInjection` namespace to
    cast the information passed inside the `ViewData` object into a real `IServiceCollection`
    object).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，回想一下，当我们在一个视图中引用一个命名空间时，`using`语句不应属于一个代码块。相反，它将是一个以`@`符号为首的独立句子（我们需要`DependencyInjection`命名空间，以便将传递到`ViewData`对象中的信息转换为真正的`IServiceCollection`对象）。
- en: Next, we recover that info inside a variable (that will be available locally
    in the whole view). Observe that I'm using the `var` keyword instead of the interface
    name because otherwise the compiler will complain. It's easier to do it this way
    and make the casting later in the code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在变量中恢复该信息（该变量将在整个视图中本地可用）。请注意，我使用的是`var`关键字而不是接口名称，因为否则编译器会报错。这样做更简单，并且可以在代码中稍后进行类型转换。
- en: 'Finally, we''ll use a table to present some information hold in three of the
    services of `IServiceCollection` (called `_services` in the view). Notice also
    the casting is made here with the `as` operator to get a real `IServiceCollection`
    object:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用表格来展示`IServiceCollection`中的三个服务（在视图中称为`_services`）所保存的一些信息。注意，这里也使用了`as`运算符进行类型转换，以获取真正的`IServiceCollection`对象：
- en: '[PRE13]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And that''s all! Now we can launch the application and select the new menu
    element *List of Services*. A new view will show up containing a, pretty long
    list of services available in this architecture, showing at the same time how
    we can make use of the `DependencyInjection` namespace (or any other) inside a
    view (see the following screenshot):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在我们可以启动应用程序并选择新的菜单元素*服务列表*。一个新视图将显示出来，其中包含一个相当长的服务列表，同时展示了我们如何在视图中使用`DependencyInjection`命名空间（或任何其他命名空间）（请参见以下截图）：
- en: '![](img/a075f92c-562f-47fe-8bcb-068821d7d668.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a075f92c-562f-47fe-8bcb-068821d7d668.png)'
- en: Garbage Collection and Custom Services
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收和自定义服务
- en: In relation to Garbage Collection behavior, ASP.NET MVC automates some operations
    and leaves others to the user's discretion.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 与垃圾回收行为相关，ASP.NET MVC自动化了一些操作，并将其他操作留给用户的判断。
- en: 'The main rule is as follows: if you register a service and call its constructor
    inside the process, it''s your obligation to dispose of that object, otherwise
    if the container is in charge of creating the object, it will call `Dispose()`
    on any object it implements.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 主要规则如下：如果您在过程中注册了一个服务并调用了其构造函数，那么您有义务销毁该对象；否则，如果容器负责创建对象，它将调用实现的对象上的`Dispose()`。
- en: 'In practice, imagine we have a couple of services (`Service1` and `Service2`)
    located in a folder (`Services`), and that both implement the `Disposable` interface.
    To simplify this part, I collapsed the code, so I''m just showing the relevant
    lines to understand this idea (see the following screenshot):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，想象一下，我们有两个服务（`Service1`和`Service2`），它们位于一个文件夹（`Services`）中，并且这两个服务都实现了`Disposable`接口。为了简化这部分，我将代码折叠起来，所以我只显示理解这个想法的相关行（请参见以下截图）：
- en: '![](img/1359a310-8963-41da-ae98-a8389a0eb133.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1359a310-8963-41da-ae98-a8389a0eb133.png)'
- en: 'The behavior will be different depending on the instantiation of each service
    (I''ve commented on each case so you''ll see the difference):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 行为将根据每个服务的实例化而有所不同（我已经在每个情况下进行了注释，所以你会看到差异）：
- en: '[PRE14]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In all, it is a pretty convenient way to manage garbage collection of services.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这是一种管理服务垃圾回收相当方便的方法。
- en: Using Custom Services through Dependency Injection
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过依赖注入使用自定义服务
- en: With this architecture, it is very easy to create any class belonging to our
    data model, or any other part of the application, and have it ready and available
    for Dependency Injection, with all the advantages linked to it.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种架构，创建属于我们数据模型中的任何类，或者应用的其他任何部分，并将其准备好并可用于依赖注入，都是非常容易的，并且能够带来与之相关的所有优势。
- en: For example, imagine that we want some adornment in one of our views in the
    form of a random sentence (about programmers and software engineers, for instance),
    and that we would like the classes that hold the information to be treated as
    a service, via Dependency Injection, so we can use that content in distinct application's
    views.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想在某个视图中添加一些装饰，形式为随机句子（比如关于程序员和软件工程师的句子），并且我们希望包含这些信息的类通过依赖注入被当作服务处理，这样我们就可以在应用的不同视图中使用这些内容。
- en: 'We can rename the classes used in the previous sample as `ProgrammerSentenceSvc`
    and `EngineerSentenceSvc` and add some very simple information: a `List<string>`
    of sentences that will be used later inside our controller to randomly retrieve
    a couple of these sentences and pass them to the corresponding view.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将前一个示例中使用的类重命名为`ProgrammerSentenceSvc`和`EngineerSentenceSvc`，并添加一些非常简单的信息：一个`List<string>`的句子列表，稍后将在我们的控制器中使用这些句子随机检索几个句子并将它们传递给相应的视图。
- en: 'So let''s modify our services to hold the required information (I''m just showing
    these captures, to focus on the relevant code):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们修改我们的服务以保存所需的信息（我只是展示这些截图，以便专注于相关代码）：
- en: '![](img/a6432441-aa7a-425b-ab22-2004c42d6e48.png)![](img/0fbe71e2-7b9f-4116-bf79-1334804b7ca8.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6432441-aa7a-425b-ab22-2004c42d6e48.png)![](img/0fbe71e2-7b9f-4116-bf79-1334804b7ca8.png)'
- en: 'The next step will be to register these classes in the `Startup` class via
    `ConfigureServices`, as we''ve seen before (I''m using two distinct syntaxes just
    to show):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是通过`ConfigureServices`在`Startup`类中注册这些类，正如我们之前所看到的（我使用两种不同的语法只是为了展示）：
- en: '[PRE15]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That''s all we need to have our services available inside any controller. So,
    let''s revisit our `HomeController`, and add the following action method (remember
    that we have to make a reference to our Services namespace, via `using ASPNETCoreDisposeDemo.Services;`):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的，以便在任何一个控制器中都有我们的服务可用。所以，让我们回顾一下我们的`HomeController`，并添加以下操作方法（记住，我们必须通过`using
    ASPNETCoreDisposeDemo.Services;`来引用我们的服务命名空间）：
- en: '[PRE16]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: And that's it! Any service registered in that manner is automatically available
    inside a controller via Dependency Injection, merely by making a reference to
    it as a parameter of the corresponding action method.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！以这种方式注册的任何服务都通过依赖注入自动在控制器中可用，只需将其作为相应操作方法的参数引用即可。
- en: 'The last step is to create the view named `Sentences` to recover the information
    and present it to the user:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建名为`Sentences`的视图来恢复信息并向用户展示：
- en: '[PRE17]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we have added (just like before), a new link next to the default menu pointing
    to the name of this action method, we''ll see the following output:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加（就像之前一样），在默认菜单旁边添加一个指向此操作方法名称的新链接，我们将看到以下输出：
- en: '![](img/995a1979-bb06-4548-8fc9-ea56097b31b8.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/995a1979-bb06-4548-8fc9-ea56097b31b8.png)'
- en: As you see, the output is the expected one, and the general architecture of
    the application with respect to the MVC model is quite similar to previous versions.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，输出是预期的，并且与MVC模型相比，应用程序的一般架构与之前的版本相当相似。
- en: Services and data management
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务和数据管理
- en: Although data management is not the target of this book, I'd like to mention
    that the architecture proposed when accessing data inside ASP.NET Core MVC applications
    is relatively alike.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数据管理不是本书的目标，但我想要提到，当在ASP.NET Core MVC应用程序中访问数据时，所提出的架构相对类似。
- en: 'To test this feature and highlight those parts directly related to Dependency
    Injection, follow the initial instructions at [https://docs.microsoft.com/en-us/ef/core/get-started/aspnetcore/existing-db](https://docs.microsoft.com/en-us/ef/core/get-started/aspnetcore/existing-db).
    That creates a very simple database using SQLLocalDb called `Blogging`. It creates
    a `Blogs` table and adds three registers, just to have some data to work with.
    You''ll also find a link to the complete sample it proposes using several approaches:
    Database First, New Database, and so on.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个功能并突出与依赖注入直接相关的那部分，请遵循初始说明在 [https://docs.microsoft.com/en-us/ef/core/get-started/aspnetcore/existing-db](https://docs.microsoft.com/en-us/ef/core/get-started/aspnetcore/existing-db)。这将创建一个使用
    SQLLocalDb 的非常简单的数据库，名为 `Blogging`。它创建了一个 `Blogs` 表，并添加了三个记录，以便有一些数据可以操作。你还可以找到它提出的完整示例的链接，使用多种方法：数据库优先、新建数据库等。
- en: What I would like to point out here is those fragments of code that imply the
    use of DI inside that solution.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这里指出的是那些暗示在该解决方案中使用 DI 的代码片段。
- en: In the `Models'` application folder you'll find the definition of the model
    based on that database in a similar way to the usual result when you scaffold
    an existing database using classic Entity Framework. The main class inherits from
    `DbContext`, defines public virtual properties pointing to the existing entities,
    and names the `DBContext` instance `BloggingContext`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Models` 应用程序文件夹中，你可以找到基于该数据库的模型定义，其方式与使用经典 Entity Framework 搭建现有数据库时的常规结果相似。主要类继承自
    `DbContext`，定义了指向现有实体的公共虚拟属性，并将 `DBContext` 实例命名为 `BloggingContext`。
- en: 'Consequently, the first step is to register that context inside the `ConfigureServices`
    method, for which it does the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一步是在 `ConfigureServices` 方法中注册这个上下文，它执行以下操作：
- en: '![](img/58d934a3-79f8-442f-9b63-1cfd15f74918.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/58d934a3-79f8-442f-9b63-1cfd15f74918.png)'
- en: As you see, the connection string is defined directly so that it points to the
    newly created database (`Blogging`).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，连接字符串被直接定义，以便它指向新创建的数据库（`Blogging`）。
- en: Next, the services variable is populated with a new entry via the generic method
    `AddDbContext<BlogginContext>.` And, to link that `DbContext` to the `Blogging`
    database and `Action` delegate is passed to the method, allowing it to override
    the `OnConfiguring` method of the `BloggingContext` class. In this manner, the
    real connection configuration can be delayed until this method is called.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过泛型方法 `AddDbContext<BlogginContext>` 向服务变量中添加了一个新条目。然后，通过将 `Action` 委托传递给方法，将那个
    `DbContext` 连接到 `Blogging` 数据库，并允许它覆盖 `BloggingContext` 类的 `OnConfiguring` 方法。这样，实际的连接配置可以延迟到调用此方法时进行。
- en: 'Finally, how does the `BloggingController` class access this `BloggingContext`?
    By Dependency Injection in its constructor. It operates in a similar way to what
    we did in the previous sample:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`BloggingController` 类是如何访问这个 `BloggingContext` 的呢？通过构造函数中的依赖注入。它的操作方式与我们之前在示例中做的是类似的：
- en: '![](img/f9857b83-0a7e-46c5-a34b-3f7a5a705364.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9857b83-0a7e-46c5-a34b-3f7a5a705364.png)'
- en: 'The output shows the three entries loaded in the `Blogs` table, just as expected,
    with the typical CRUD options, presenting the information via Razor views, but
    it''s interesting to highlight the role of DI in this architecture as well (see
    the following screenshot):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了加载到 `Blogs` 表中的三个条目，正如预期的那样，具有典型的 CRUD 选项，通过 Razor 视图展示信息，但同样有趣的是强调 DI
    在这个架构中的作用（见以下截图）：
- en: '![](img/ff666b1a-21c5-4c90-96f0-f0ef01760a83.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ff666b1a-21c5-4c90-96f0-f0ef01760a83.png)'
- en: Again, you've seen how DI is also present in .NET Core-related platforms, such
    as Entity Framework Core.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '再次，你已经看到了在 .NET Core 相关平台，如 Entity Framework Core 中，DI 的存在。 '
- en: However, there's an interesting point we haven't covered yet. We saw how to
    make a reference to the `DependencyInjection Namespace` inside a view, but we
    were not really using DI. Let's see how to use the new `@inject` directive inside
    a view with a simple demo.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个我们还没有涉及到的有趣点。我们看到了如何在视图中引用 `DependencyInjection Namespace`，但我们实际上并没有使用
    DI。让我们通过一个简单的示例来看看如何在视图中使用新的 `@inject` 指令。
- en: Using Dependency Injection inside Views
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在视图中使用依赖注入
- en: For completeness, I'm going to explain a simple demo of how to use DI inside
    a Razor view. It's a quite interesting feature and it can be useful to access
    data, service-related information, or even your own Razor helpers.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我将解释一个简单的示例，说明如何在 Razor 视图中使用 DI。这是一个相当有趣的功能，它可以用来访问数据、服务相关的信息，甚至你自己的
    Razor 辅助工具。
- en: The idea is to create another view that is able to access the same data as our
    previous `Services` View, but this time without implying the controller in the
    business logic. Besides that, I'll create a Razor helper just to show how we can
    do both tasks thanks to the `@inject` directive.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是创建另一个视图，使其能够访问与之前的`Services`视图相同的数据，但这次不涉及业务逻辑中的控制器。除此之外，我将创建一个Razor辅助器，以展示我们如何通过`@inject`指令完成这两项任务。
- en: 'First, inside a new folder (`Helpers`), let''s create a simple helper that
    provides some kind of information (for instance the current system''s time):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在新的文件夹（`Helpers`）中，让我们创建一个简单的辅助器，提供某种信息（例如当前系统的时间）：
- en: '[PRE18]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With this new service in place, we need to register it as we did with the `Sentences*`
    services. The new version of the `ConfigureServices` method will look as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新服务到位后，我们需要像对`Sentences*`服务那样注册它。`ConfigureServices`方法的新版本将如下所示：
- en: '[PRE19]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is all we need on the business logic side since we can use the existing
    services, only in a different way. So, I'll create another action method as part
    of the `HomeController` named `ServicesDI`, and try to replicate the previous
    functionality.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在业务逻辑方面，我们需要的就这些，因为我们可以使用现有的服务，只是以不同的方式。所以，我将创建另一个名为`ServicesDI`的动作方法作为`HomeController`的一部分，并尝试复制之前的功能。
- en: 'We can also use the `[Route("key")]` attribute to redirect URL queries to this
    action method. Actually, it''s even simpler than the others:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`[Route("key")]`属性将URL查询重定向到这个动作方法。实际上，这比其他方法还要简单：
- en: '[PRE20]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The rest of the programming logic is deferred to the view itself. Thus, the
    `SentencesDI` View will have to reference the namespaces related to the services
    it is going to use, and declare any service required:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的编程逻辑将推迟到视图本身。因此，`SentencesDI`视图将需要引用与它将要使用的服务相关的命名空间，并声明任何所需的服务：
- en: '[PRE21]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, the rest of the code is pretty self-explanatory. Once services
    are registered and references made, we can use the `@inject` directive to instruct
    the DI container about the resources that our view is going to need. The syntax
    is:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，其余的代码相当直观。一旦服务注册并建立引用，我们可以使用`@inject`指令来指导DI容器关于我们的视图将要需要的资源。语法如下：
- en: '[PRE22]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this way, any functionality related to a service that is injected in a view
    can access the data inside the service without having to process it in the controller.
    You might say that this breaks in some way the architecture of the MVC foundations,
    but there are some circumstances in which it might be interesting to separate
    certain data from the controller if it is only related to a particular view.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，任何与注入到视图中的服务相关的功能都可以访问服务内部的数据，而无需在控制器中处理它。你可能会说这某种程度上打破了MVC基础的架构，但在某些情况下，如果某些数据仅与特定视图相关，将其从控制器中分离出来可能是有趣的。
- en: 'And, surely, you''ll find more useful possibilities. By the way, you can type
    `localhost:[port]/ServicesDI` in the browser to get the corresponding output:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，你肯定会发现更多有用的可能性。顺便说一句，你可以在浏览器中输入`localhost:[port]/ServicesDI`来获取相应的输出：
- en: '![](img/f711fe22-b931-4bf8-a799-3ee618634c7c.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f711fe22-b931-4bf8-a799-3ee618634c7c.png)'
- en: In short, another feature related to Dependency Injection, this time inside
    the Razor views, that we can use inside the ASP.NET Core platform.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这是与依赖注入相关的另一个功能，这次是在Razor视图中使用，我们可以在ASP.NET Core平台上使用它。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused on ASP.NET Core and Dependency Injection, analyzing
    how the whole architecture and configuration process is based on the internal
    DI Container of ASP.NET Core.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于ASP.NET Core和依赖注入，分析了整个架构和配置过程是基于ASP.NET Core内部DI容器的。
- en: We also saw how to move from a simple Console app to an ASP.NET Core app, and
    finally, how the distinct servers for development and production can be tuned
    up.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何从简单的控制台应用程序迁移到ASP.NET Core应用程序，以及如何调整开发和生产环境中不同的服务器。
- en: Then, we analyzed the main templates offered by Visual Studio 2017 in relation
    to ASP.NET Core apps and reviewed how they used DI in order to configure and manage
    the required information and functionality.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们分析了Visual Studio 2017为ASP.NET Core应用程序提供的主要模板，并回顾了它们如何使用DI来配置和管理所需的信息和功能。
- en: Finally, we saw how to use our own custom services and integrate them inside
    ASP.NET Core using DI, either in the controllers or in the Razor Views.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了如何使用我们自己的自定义服务，并通过DI将它们集成到ASP.NET Core中，无论是在控制器中还是在Razor视图中。
- en: In [Chapter 5](c2b6c427-7a04-43d9-93bf-076daeb0f024.xhtml), *Object Composition*,
    we will analyze Object Composition and its use within DI contexts.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](c2b6c427-7a04-43d9-93bf-076daeb0f024.xhtml)，*对象组合*，我们将分析对象组合及其在DI环境中的应用。
