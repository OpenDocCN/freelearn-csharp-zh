- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Creating Better Web APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建更好的 Web API
- en: Web APIs are the essence of the internet. They give developers the openness
    of the web and the ability to access any data on the internet. However, there
    are some best practices specific to APIs. The ability to select the right HTTP
    verb, how to document APIs, and testing APIs are just some of the topics we’ll
    cover.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Web API 是互联网的核心。它们为开发者提供了网络的开放性和访问互联网上任何数据的可能性。然而，有一些最佳实践是针对 API 的。选择正确的 HTTP
    动词、如何记录 API 以及测试 API 只是我们将要讨论的一些主题。
- en: With that said, the techniques covered in this chapter are vast and dense. We’ll
    try to pack as much information as possible to help build quality APIs. We’ll
    also provide relevant links for further research.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，本章中涵盖的技术广泛且密集。我们将尽量提供尽可能多的信息，以帮助构建高质量的 API。我们还将提供相关链接以供进一步研究。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Creating APIs quickly
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速创建 API
- en: Designing APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计 API
- en: Testing Web APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 Web API
- en: Standardized Web API techniques
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准化的 Web API 技术
- en: In this chapter, we’ll learn how to design, create, test, and document APIs
    and how to perform full end-to-end tests of our APIs through a CI/CD pipeline.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何设计、创建、测试和记录 API，以及如何通过 CI/CD 管道执行 API 的全面端到端测试。
- en: We’ll finish this chapter by reviewing some of the more common techniques for
    writing APIs, such as using the correct HTTP verbs and status codes, how to avoid
    large dependent resources, how to implement pagination into APIs, versioning an
    API, using DTOs instead of entities, and the best way to call other APIs from
    .NET.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过回顾一些编写 API 的更常见技术来结束本章，例如使用正确的 HTTP 动词和状态码、如何避免大型依赖资源、如何在 API 中实现分页、API
    版本控制、使用 DTO 而不是实体，以及从 .NET 调用其他 API 的最佳方式。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In .NET 8, Web APIs take a front seat. Visual Studio has added new features
    to make Web APIs easier to build and test. For this chapter, we recommend using
    Visual Studio 2022, but the only requirement to view the GitHub repository is
    a simple text editor.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 8 中，Web API 占据了主导地位。Visual Studio 增加了新功能，使构建和测试 Web API 更加容易。对于本章，我们建议使用
    Visual Studio 2022，但查看 GitHub 仓库的唯一要求是一个简单的文本编辑器。
- en: The code for *Chapter 09* is located in Packt Publishing’s GitHub repository,
    found at [https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 09 章* 的代码位于 Packt Publishing 的 GitHub 仓库中，网址为 [https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices)。'
- en: Creating APIs quickly
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速创建 API
- en: With .NET 8, APIs are integrated into the framework, making it easier to create,
    test, and document. In this section, we’ll learn a quick and easy way to create
    a minimal API using Visual Studio 2022 and walk through the code it generates.
    We’ll also learn why minimal APIs are the best approach to building REST-based
    services.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 .NET 8，API 已集成到框架中，这使得创建、测试和记录 API 更加容易。在本节中，我们将学习一种快速简单的方法来使用 Visual Studio
    2022 创建最小 API，并浏览它生成的代码。我们还将了解为什么最小 API 是构建基于 REST 的服务的最佳方法。
- en: Using Visual Studio
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Visual Studio
- en: 'One of the features of .NET 8 is the ability to create minimal REST APIs extremely
    fast. One way is to use the dotnet command-line tool and the other way is to use
    Visual Studio. To do so, follow these steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 8 的一个特性是能够极快地创建最小 REST API。一种方法是通过使用 dotnet 命令行工具，另一种方法是通过使用 Visual Studio。要这样做，请按照以下步骤操作：
- en: Open Visual Studio 2022 and create an **ASP.NET Core Web** **API** project.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 2022 并创建一个 **ASP.NET Core Web API** 项目。
- en: After selecting the directory for the project, click **Next**.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择项目目录后，点击 **下一步**。
- en: 'Under the project options, make the following changes:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目选项下，进行以下更改：
- en: Uncheck the **Use Controllers** option to use minimal APIs
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消选中 **使用控制器** 选项以使用最小 API
- en: 'Check **Enable OpenAPI support** to include support for API documentation using
    Swagger:'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选中 **启用 OpenAPI 支持** 以包括使用 Swagger 的 API 文档支持：
- en: '![Figure 9.1 – Options for a web minimal API project](img/B19493_09_1.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 网络最小 API 项目的选项](img/B19493_09_1.jpg)'
- en: Figure 9.1 – Options for a web minimal API project
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 网络最小 API 项目的选项
- en: Click **Create**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建**。
- en: That’s it – we have a simple API! It may not be much of one, but it’s still
    a complete API with Swagger documentation. Swagger is a tool for creating documentation
    for APIs and implementing the OpenAPI specification, whereas Swashbuckle is a
    NuGet package that uses Swagger for implementing Microsoft APIs. If we look at
    the project, there’s a single file called `Program.cs`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——我们得到了一个简单的 API！虽然它可能不是特别复杂，但仍然是一个完整的 API，带有 Swagger 文档。Swagger 是一个用于创建
    API 文档并实现 OpenAPI 规范的工具，而 Swashbuckle 是一个使用 Swagger 实现微软 API 的 NuGet 包。如果我们查看项目，会发现有一个名为
    `Program.cs` 的单个文件。
- en: 'Opening `Program.cs` will show the entire application. This is one of the strong
    points of .NET – the ability to create a scaffolded REST API relatively quickly:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Program.cs` 将会显示整个应用程序。这是 .NET 的一个优点——能够相对快速地创建一个脚手架式的 REST API：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we created our “application” through the `.CreateBuilder()`
    method. We also added the `EndpointsAPIExplorer` and `SwaggerGen` services. `EndpointsAPIExplorer`
    enables the developer to view all endpoints in Visual Studio, which we’ll cover
    later. The `SwaggerGen` service, on the other hand, creates the documentation
    for the API when accessed through the browser. The next line creates our application
    instance using the `.``Build()` method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过 `.CreateBuilder()` 方法创建了我们的“应用程序”。我们还添加了 `EndpointsAPIExplorer`
    和 `SwaggerGen` 服务。`EndpointsAPIExplorer` 允许开发者查看 Visual Studio 中的所有端点，我们将在后面介绍。另一方面，`SwaggerGen`
    服务在通过浏览器访问时创建 API 的文档。下一行使用 `.Build()` 方法创建我们的应用程序实例。
- en: Once we have our app instance and we are in development mode, we can add Swagger
    and the Swagger UI. `.UseHttpsRedirection()` is meant to redirect to HTTPS when
    the protocol of a web page is HTTP to make the API secure.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了应用程序实例并且处于开发模式，我们就可以添加 Swagger 和 Swagger UI。`.UseHttpsRedirection()` 的目的是在网页协议为
    HTTP 时重定向到 HTTPS，以使 API 安全。
- en: The next line creates our GET `weatherforecast` route using `.MapGet()`. We
    added the `.WithName()` and `.WithOpenApi()` methods to identify the primary method
    to call and let .NET know it uses the OpenAPI standard, respectively. Finally,
    we called `app.Run()`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一行使用 `.MapGet()` 创建我们的 GET `weatherforecast` 路由。我们添加了 `.WithName()` 和 `.WithOpenApi()`
    方法来标识要调用的主要方法，并让 .NET 知道它使用 OpenAPI 标准。最后，我们调用了 `app.Run()`。
- en: 'If we run the application, we will see the documented API on how to use our
    API and what’s available. Running the application produces the following output:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序，我们将看到有关如何使用我们的 API 以及可用的文档化的 API。运行应用程序会产生以下输出：
- en: '![Figure 9.2 – Screenshot of our documented Web API](img/B19493_09_2.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 我们文档化的 Web API 的屏幕截图](img/B19493_09_2.jpg)'
- en: Figure 9.2 – Screenshot of our documented Web API
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 我们文档化的 Web API 的屏幕截图
- en: If we call the `/weatherforecast` API, we see that we receive JSON back with
    a 200 HTTP status.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用 `/weatherforecast` API，我们会看到返回带有 200 HTTP 状态的 JSON。
- en: '![Figure 9.3 – Results of our /weatherforecast API](img/B19493_09_3.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 我们 /weatherforecast API 的结果](img/B19493_09_3.jpg)'
- en: Figure 9.3 – Results of our /weatherforecast API
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 我们 /weatherforecast API 的结果
- en: Think of this small API as middleware with API controllers combined into one
    compact file (`Program.cs`).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个小型 API 想象成将 API 控制器与中间件结合到一起的一个紧凑文件（`Program.cs`）。
- en: Why minimal APIs?
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么需要最小 API？
- en: 'I consider minimal APIs to be a feature in .NET 8, even though it’s a language
    concept. If the application is extremely large, adding minimal APIs should be
    an appealing feature in four ways:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为最小 API 是 .NET 8 的一个特性，尽管它是一个语言概念。如果应用程序非常大，添加最小 API 应该以以下四种方式吸引人：
- en: '**Self-contained**: Simple API functionality inside one file is easy to follow
    for other developers'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自包含**：一个文件内的简单 API 功能对其他开发者来说很容易理解'
- en: '**Performance**: Since we aren’t using controllers, the MVC overhead isn’t
    necessary when using these APIs'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：由于我们没有使用控制器，因此在使用这些 API 时不需要 MVC 的开销'
- en: '**Cross-platform**: With .NET, APIs can now be deployed on any platform'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台**：使用 .NET，API 现在可以部署在任何平台上'
- en: '**Self-documenting**: While we can add Swashbuckle to other APIs, it also builds
    the documentation for minimal APIs'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自文档化**：虽然我们可以将 Swashbuckle 添加到其他 API 中，但它也会为最小 API 构建文档'
- en: Moving forward, we’ll take these minimal APIs and start looking at Visual Studio’s
    testing capabilities.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用这些最小 API 并开始查看 Visual Studio 的测试功能。
- en: In this section, we created and reviewed a minimal API project in Visual Studio
    and why minimal APIs are important to our projects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们在 Visual Studio 中创建并审查了一个最小 API 项目，并讨论了为什么最小 API 对我们的项目很重要。
- en: In the next section, we’ll look at designing APIs to help eliminate long resource
    (URL) names and standardized API naming.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨设计API以帮助消除长资源（URL）名称和标准化API命名的最佳方法。
- en: Designing APIs
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计API
- en: In this section, we’ll cover the best approach for delivering intuitive and
    clear APIs to our users. The design of an API should be well thought-out and make
    sense when a user wishes to make a request.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍向用户提供直观和清晰的API的最佳方法。API的设计应该是经过深思熟虑的，当用户希望发起请求时，它应该是有意义的。
- en: To create a truly REST-based API, we must use a different mindset. We have to
    think of ourselves as a user and not a developer. When writing APIs, the users
    of the API *are* fellow developers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个真正基于REST的API，我们必须使用不同的思维方式。我们必须把自己当作用户，而不是开发者。在编写API时，API的用户是其他开发者。
- en: Disconnecting from existing schemas
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断开与现有模式的连接
- en: When designing APIs, we need a user’s perspective as opposed to basing an API
    on a class hierarchy or database schema. While developers may consider creating
    an API based on a class hierarchy or database schema as a shortcut, it could create
    more complexity as to which resource to use when retrieving data. One example
    is using an Order resource to find a contact. While an Order entity in Entity
    Framework Core could contain a `Company` property and we need the contact of the
    company, we wouldn’t write `https://www.myfakesite.com/Order/15/Company/Contact`.
    Basing a URL structure on an existing hierarchy or schema should be avoided.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计API时，我们需要从用户的角度出发，而不是基于类层次结构或数据库模式来构建API。虽然开发者可能会认为基于类层次结构或数据库模式创建API是一种捷径，但它可能会在检索数据时产生更多的复杂性。一个例子是使用订单资源来查找联系人。虽然Entity
    Framework Core中的订单实体可能包含一个`Company`属性，而我们需要公司的联系人信息，我们不会编写`https://www.myfakesite.com/Order/15/Company/Contact`。基于现有层次结构或模式构建URL结构应该避免。
- en: It’s crucial to disregard existing schemas when designing a sensible API. Look
    at the API with new eyes to get the best design. The most popular APIs are the
    cleanest and most intuitive as they use the `collection/item/collection` syntax.
    A good example of this would be `/orders/15/companys`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计合理的API时，忽略现有模式至关重要。用新的视角看待API以获得最佳设计。最受欢迎的API是最干净和最直观的，因为它们使用了`collection/item/collection`语法。一个很好的例子是
    `/orders/15/companys`。
- en: Identifying the resources
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别资源
- en: In a system, look at how the user interacts with the website and extract the
    nouns from specific scenarios. These will become the resources for the APIs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中，观察用户如何与网站交互，并从特定场景中提取名词。这些将成为API的资源。
- en: 'For example, a user can perform the following actions in a shopping cart system:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用户可以在购物车系统中执行以下操作：
- en: View a list of products
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看产品列表
- en: View a product
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看产品
- en: Add a product to the cart
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将产品添加到购物车
- en: Remove a product from the cart
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从购物车中移除产品
- en: Check out
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结账
- en: 'From these scenarios, we can extract the following resources:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些场景中，我们可以提取以下资源：
- en: Products
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品
- en: Product
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品
- en: Cart
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车
- en: We’re starting to identify and logically partition our APIs based on resources
    used throughout the system.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始根据系统中的资源识别和逻辑分区我们的API。
- en: From here, we can apply an HTTP verb to each resource based on each scenario.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以根据每个场景为每个资源应用一个HTTP动词。
- en: Relating HTTP verbs to resources
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将HTTP动词与资源相关联
- en: Once we have the primary resources, we can apply an HTTP verb to each resource
    based on the specific scenario we defined in the previous section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了主要资源，我们就可以根据上一节中定义的特定场景为每个资源应用一个HTTP动词。
- en: When creating an API, it may be tempting to use the noun/verb syntax – for example,
    [https://www.myurl.com/products/get](https://www.myurl.com/products/get) or [https://www.myurl.com/getproducts](https://www.myurl.com/getproducts).
    This approach is counterproductive since web standards already exist for this
    exact purpose.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个API时，可能会倾向于使用名词/动词语法——例如，[https://www.myurl.com/products/get](https://www.myurl.com/products/get)
    或 [https://www.myurl.com/getproducts](https://www.myurl.com/getproducts)。这种方法是适得其反的，因为网络标准已经存在用于此目的。
- en: While this does work, it violates some of the REST principles (which we’ll get
    into when we looked at standardized web API techniques in the following sections).
    For now, let’s take it step by step and create a simple shopping cart API.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做是可行的，但它违反了一些REST原则（我们将在以下部分讨论标准化的Web API技术）。现在，让我们一步一步来，创建一个简单的购物车API。
- en: 'Each HTTP verb has a default operation based on its context:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTTP动词都有基于其上下文的默认操作：
- en: '`GET`: Returns a resource'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：返回资源'
- en: '`POST`: Creates a new resource'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：创建新的资源'
- en: '`PUT`: Replaces an entire resource based on an identifier'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：根据标识符替换整个资源'
- en: '`PATCH`: Updates specific items in a resource based on an identifier'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`：根据标识符更新资源中的特定项'
- en: '`DELETE`: Deletes a resource'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：删除资源'
- en: 'For example, our scenarios in the previous section can begin to take shape
    based on the resources and their verbs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，上一节中的场景可以根据资源和它们的动词开始成形：
- en: '`GET /api/products`: View a list of products'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /api/products`：查看产品列表'
- en: '`GET /api/product/{id}`: View a product'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /api/product/{id}`：查看产品'
- en: '`POST /api/cart/{cartId}`: Add a product to the cart with `POST` data (that
    is, `new { ProductId = {productId}, Qty =` `1 }`)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /api/cart/{cartId}`：使用`POST`数据（即`new { ProductId = {productId}, Qty =
    ` `1 }`）将产品添加到购物车'
- en: '`PATCH /api/cart/{cartId}`: Remove a product from the cart with `POST` data
    (that is, `new { ProductId = {``productId} }`)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH /api/cart/{cartId}`：使用`POST`数据（即`new { ProductId = {productId}, Qty
    = {``productId} }`）从购物车中删除产品'
- en: '`GET /api/cart/{cartId}`: Retrieve a cart with all the products in the cart'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /api/cart/{cartId}`：检索包含购物车中所有产品的购物车'
- en: '`POST /api/cart/{cartId}/checkout`: Check out'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /api/cart/{cartId}/checkout`：结账'
- en: Once we have matched the resources to the scenarios that have been defined,
    we can move forward with returning status codes to the caller.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将资源与已定义的场景匹配，我们就可以继续返回状态码给调用者。
- en: Returning HTTP status codes
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回HTTP状态码
- en: With the resources defined, we need to know whether the request was successful
    or not. This is where we return HTTP status codes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了资源之后，我们需要知道请求是否成功。这就是我们返回HTTP状态码的地方。
- en: 'These status codes are broken into the following categories:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些状态码分为以下类别：
- en: '**1xx**: Information codes'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1xx**：信息代码'
- en: '**2xx**: Success codes'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2xx**：成功代码'
- en: '**3xx**: Redirection codes'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3xx**：重定向代码'
- en: '**4xx**: Client-side codes'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4xx**：客户端代码'
- en: '**5xx**: Server errors'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5xx**：服务器错误'
- en: Similar to unit tests, we look at a “happy” path and a broken path. But with
    APIs, we need to add an unrecoverable path in case an unrecoverable error occurs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与单元测试类似，我们查看“快乐”路径和“破损”路径。但是，对于API，我们需要添加一个不可恢复路径，以防发生不可恢复的错误。
- en: Let’s look at two of the URLs and what status codes they should return.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个URL及其应该返回的状态码。
- en: '`GET /api/products` will return the following status codes:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET /api/products` 将返回以下状态码：'
- en: '**200 Success**: Products were successfully returned'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**200 Success**：成功返回产品'
- en: '**500 Internal Server Error**: Optional if something caused a problem'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**500 Internal Server Error**：如果发生问题则可选'
- en: If the API was successful, it will return a list of the products with a 200
    status code. If there are issues, it will return a 500 status code. The API could
    also return additional status codes. For example, if an API call is made for specific
    users, the API could return a 401, which is an Unauthorized status code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果API成功，它将以200状态码返回产品列表。如果存在问题，它将返回500状态码。API还可以返回其他状态码。例如，如果对特定用户进行API调用，API可以返回401，这是一个未授权状态码。
- en: '`POST /api/cart/{cartId}` with a post body of (`new { ProductId = {productId},
    Qty = 1 }`) will return the following status codes:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST /api/cart/{cartId}`带有正文(`new { ProductId = {productId}, Qty = 1 }`)将返回以下状态码：'
- en: '**201 Created**: The item was created and added to the cart'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**201 Created**：项目已创建并添加到购物车'
- en: '**202 Accepted**: The item was added to the cart'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**202 Accepted**：项目已添加到购物车'
- en: '**404 Not Found**: The cart or product wasn’t found'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**404 Not Found**：购物车或产品未找到'
- en: '**500 Internal Server Error**: An unrecoverable error occurred'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**500 Internal Server Error**：发生了不可恢复的错误'
- en: With this API, we can return either a 201 Created or a 202 Accepted status code.
    If we couldn’t find the cart or product to add to the cart, return a 404 status
    code. Otherwise, return a 500 status code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此API，我们可以返回201 Created或202 Accepted状态码。如果我们找不到要添加到购物车的购物车或产品，则返回404状态码。否则，返回500状态码。
- en: While these two examples are not set in stone, they should provide a template
    for the team to discuss what business rules dictate the status codes that are
    returned to the user. Whatever status codes are returned, they should provide
    enough context as to the request made through the API.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个例子并不是一成不变的，但它们应该为团队提供一个讨论模板，以确定哪些业务规则决定了返回给用户的状态码。无论返回什么状态码，它们都应该提供足够的信息，以了解通过API发出的请求。
- en: Some APIs seen in the wild use an all-or-nothing approach; they either return
    a 200 or a 500\. It depends on how much information we want to send back to the
    client. These types of APIs feel like they’re missing more functionality, such
    as Unauthorized (401) or Not Found (404) status codes. It’s a best practice to
    include as much information as we can to the caller of the API.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一些在野外看到的 API 使用全有或全无的方法；它们要么返回 200，要么返回 500。这取决于我们想要向客户端发送多少信息。这类 API 好像缺少更多功能，例如未经授权（401）或未找到（404）状态码。将尽可能多的信息包含到
    API 的调用者中是一种最佳实践。
- en: HTTP status codes
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 状态码
- en: HTTP status codes are standard in web development and are presented through
    the RFC `HttpStatusCodeEnum` class with every status code at [https://learn.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode](https://learn.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode),
    along with `IActionResults` such as `Ok(object)`. Specific status codes can be
    found at [https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results.statuscode](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results.statuscode).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 状态码在 Web 开发中是标准的，并通过 RFC `HttpStatusCodeEnum` 类以及每个状态码在 [https://learn.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode](https://learn.microsoft.com/en-us/dotnet/api/system.net.httpstatuscode)
    以及 `IActionResults`，如 `Ok(object)` 来呈现。具体的状态码可以在 [https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results.statuscode](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results.statuscode)
    找到。
- en: In this section, we learned how to design APIs and broke down each step – that
    is, disconnecting from the technology, identifying the resources, knowing the
    right verbs to apply to resources, and providing the correct response codes to
    our API.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何设计 API，并分解了每个步骤——即断开与技术的连接，识别资源，知道应用于资源的正确动词，以及向我们的 API 提供正确的响应代码。
- en: 'In the next section, we will look at two ways to test our APIs: one in Visual
    Studio with the new Endpoints Explorer and the other by creating a complete integration
    test.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨两种测试我们的 API 的方法：一种是在 Visual Studio 中使用新的 Endpoints Explorer，另一种是通过创建完整的集成测试。
- en: Testing Web APIs
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Web API
- en: Once we have our APIs designed and created, we need a way to test them in our
    IDE and our integration tests. Luckily, Visual Studio has added the new Endpoints
    Explorer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设计和创建了我们的 API，我们需要一种方法在我们的 IDE 和集成测试中测试它们。幸运的是，Visual Studio 添加了新的 Endpoints
    Explorer。
- en: In this section, we’ll learn two ways to test our APIs. One way is through our
    development environment using Visual Studio. The second way we’ll test our API
    is through integration tests. If we have a CI/CD pipeline (which we should from
    [*Chapter 2*](B19493_02.xhtml#_idTextAnchor031)), these will automatically run
    to confirm our APIs work as expected.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习两种测试我们的 API 的方法。一种是通过我们的开发环境使用 Visual Studio。第二种测试我们的 API 的方法是通过集成测试。如果我们有一个
    CI/CD 管道（我们应该从 [*第 2 章*](B19493_02.xhtml#_idTextAnchor031) 开始），这些将自动运行以确认我们的 API
    如预期那样工作。
- en: Visual Studio Endpoints Explorer
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio Endpoints Explorer
- en: 'Historically, developers using Visual Studio had to run a separate tool to
    test their APIs, but with the latest version of .NET 8, the Visual Studio team
    added a new panel called **Endpoints Explorer**:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，使用 Visual Studio 的开发者必须运行一个单独的工具来测试他们的 API，但随着 .NET 8 最新版本的推出，Visual Studio
    团队增加了一个名为 **Endpoints Explorer** 的新面板：
- en: '![Figure 9.4 – Endpoints Explorer](img/B19493_09_4.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – Endpoints Explorer](img/B19493_09_4.jpg)'
- en: Figure 9.4 – Endpoints Explorer
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – Endpoints Explorer
- en: 'If we have a collection of APIs defined in the `Program.cs` file, our collection
    will appear as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `Program.cs` 文件中定义了一组 API，我们的集合将如下所示：
- en: '![Figure 9.5 – Collection of APIs in Endpoints Explorer](img/B19493_09_5.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – Endpoints Explorer 中的 API 集合](img/B19493_09_5.jpg)'
- en: Figure 9.5 – Collection of APIs in Endpoints Explorer
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – Endpoints Explorer 中的 API 集合
- en: 'Right-clicking on an API will generate a request in a new HTTP Editor. The
    HTTP Editor allows custom-defined variables for the APIs listed:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击一个 API 将在新的 HTTP 编辑器中生成一个请求。HTTP 编辑器允许为列出的 API 自定义定义变量：
- en: '![Figure 9.6 – Sample API collection in the HTTP Editor](img/B19493_09_6.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – HTTP 编辑器中的示例 API 集合](img/B19493_09_6.jpg)'
- en: Figure 9.6 – Sample API collection in the HTTP Editor
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – HTTP 编辑器中的示例 API 集合
- en: 'In *Figure 9**.6*, the HTTP Editor uses the following commands to issue HTTP
    requests:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **图 9.6** 中，HTTP 编辑器使用以下命令来发出 HTTP 请求：
- en: '`@`: Creates a variable for the file (for example, `@variable` = `value`)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@`: 为文件创建一个变量（例如，`@variable` = `value`)'
- en: '`//`: This specifies comments'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`//`: 这指定了注释'
- en: '`###`: This specifies the end of an HTTP request'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`###`: 这指定了 HTTP 请求的结束'
- en: '`<HTTP Verb>`: Creates a REST-based request, including `DELETE`, `GET`, `HEAD`,
    `OPTIONS`, `PATCH`, `POST`, `PUT`, and `TRACE` requests'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<HTTP Verb>`：创建基于REST的请求，包括`DELETE`、`GET`、`HEAD`、`OPTIONS`、`PATCH`、`POST`、`PUT`和`TRACE`请求'
- en: '`<Headers>`: Adds headers directly after defining the URL so that they’re included
    in the request'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Headers>`：在定义URL后直接添加标题，以便它们包含在请求中'
- en: 'Once we have defined the APIs, there are green arrows in the left gutter. Run
    the application to test the API locally. Pressing the arrow in the far left gutter
    *while the API is running* will produce results in the right-hand pane:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了API，左侧的空白区域会出现绿色箭头。运行应用程序以在本地测试API。当API正在运行时，按下左侧空白区域最远的箭头将在右侧面板中产生结果：
- en: '![Figure 9.7 – Results of the /attractions request](img/B19493_09_7.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – `/attractions`请求的结果](img/B19493_09_7.jpg)'
- en: Figure 9.7 – Results of the /attractions request
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – `/attractions`请求的结果
- en: In this example, we tested the `/attractions` request, received the data, and
    displayed it on the right.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们测试了`/attractions`请求，接收了数据，并在右侧显示它。
- en: Why is this important?
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么这很重要？
- en: 'By using this new Visual Studio feature, we gain the following advantages:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这个新的Visual Studio功能，我们获得了以下优势：
- en: '**Centralized APIs**: We have a catalog of all of our APIs in one place'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中式API**：我们在一个地方拥有所有API的目录'
- en: '`.http` file, execute sample requests, and understand what each API does in
    the system'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.http`文件，执行示例请求，并了解每个API在系统中的功能'
- en: '**IDE-integrated**: Additional tools aren’t necessary for testing our APIs'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成开发环境集成**：测试我们的API不需要额外的工具'
- en: This new feature is extremely helpful to developers looking to test existing
    APIs locally and also complements new minimal APIs introduced into the system.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新功能对于想要在本地测试现有API的开发者来说非常有帮助，同时也补充了系统中新引入的最小API。
- en: Additional Endpoints Explorer material
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 端点资源管理器额外材料
- en: For additional material on Endpoints Explorer, Sayed Ibrahim Hashimi has provided
    a great write-up about everything it can do at [https://devblogs.microsoft.com/visualstudio/web-api-development-in-visual-studio-2022/#endpoints-explorer](https://devblogs.microsoft.com/visualstudio/web-api-development-in-visual-studio-2022/#endpoints-explorer).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 关于端点资源管理器的额外材料，赛义德·易卜拉欣·哈希米提供了一篇关于它所能做一切的精彩文章，请参阅[https://devblogs.microsoft.com/visualstudio/web-api-development-in-visual-studio-2022/#endpoints-explorer](https://devblogs.microsoft.com/visualstudio/web-api-development-in-visual-studio-2022/#endpoints-explorer)。
- en: In this section, we learned about Endpoints Explorer, how we can use it to help
    test APIs locally, and why it’s important. In the next section, we’ll take our
    APIs and learn how to use integration tests to produce quick results.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了端点资源管理器，我们如何使用它来帮助本地测试API，以及为什么它很重要。在下一节中，我们将学习如何使用集成测试来快速生成结果。
- en: Integration testing APIs
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试API
- en: In the previous section, we learned about how to use Endpoints Explorer to test
    our APIs. However, we shouldn’t have to install Visual Studio on a server to test
    our APIs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使用端点资源管理器来测试我们的API。然而，我们不应该需要在服务器上安装Visual Studio来测试我们的API。
- en: In this section, we will look at applying an integration server for our APIs
    to achieve a complete end-to-end test.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨为我们的API应用集成服务器以实现完整的端到端测试。
- en: When we created unit tests back in [*Chapter 8*](B19493_08.xhtml#_idTextAnchor189),
    we created an in-memory representation of a database. We can create a similar
    environment where we can spin up and tear down the entire environment for API
    tests.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[*第8章*](B19493_08.xhtml#_idTextAnchor189)中创建单元测试时，我们创建了一个数据库的内存表示。我们可以创建一个类似的环境，在那里我们可以为API测试启动和关闭整个环境。
- en: In our CI/CD pipelines, we can build a disposable server for our integration
    tests to provide a full end-to-end test with APIs and services and a disposable
    database.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的CI/CD管道中，我们可以为我们的集成测试构建一个可丢弃的服务器，以提供API和服务以及可丢弃数据库的全端到端测试。
- en: Building the integration server
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建集成服务器
- en: Since .NET provides us with a simple `Program.cs` file for our applications,
    we can wrap the entire application and replace the services we want to mimic with
    a web and database server.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于.NET为我们提供了简单的`Program.cs`文件来构建应用程序，我们可以将整个应用程序包装起来，并用一个Web和数据库服务器替换我们想要模拟的服务。
- en: 'We can set up the environment using the `WebApplicationFactory` class. We include
    the minimal API project as a dependency in our `Api.Tests` project. Once we have
    our dependency in the program, we can create our `WebApplicationFactory` class:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`WebApplicationFactory`类来设置环境。我们将最小API项目作为依赖项包含在我们的`Api.Tests`项目中。一旦我们在程序中有了依赖项，我们就可以创建我们的`WebApplicationFactory`类：
- en: '[PRE1]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code example, we inherited from `WebApplicationFactory<Program>`.
    The generic `<Program>` comes from the included dependency we referenced. Then,
    we created a root for our in-memory database and proceeded to configure our services
    by removing all instances of `DbContextOptionsBuilder<ThemeParkDbContext>`. Once
    we’ve removed these, we can create a new scoped reference to the same type with
    our updated settings for the database.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们继承了`WebApplicationFactory<Program>`。泛型`<Program>`来自我们引用的包含的依赖项。然后，我们为我们的内存数据库创建了一个根，并继续通过删除所有`DbContextOptionsBuilder<ThemeParkDbContext>`实例来配置我们的服务。一旦我们删除了这些，我们就可以使用更新的数据库设置创建一个新的作用域引用到同一类型。
- en: Next, we added our new `ThemeParkDbContext` with our updated connection using
    a SQLite database. Remember, Entity Framework Core will automatically create the
    structure of our entire database with the `.EnsureCreated()` method. Finally,
    we added a dependency injection registration for `IThemeParkDbContext` for the
    services in our application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用SQLite数据库添加了我们的新`ThemeParkDbContext`和更新的连接。记住，Entity Framework Core会自动使用`.EnsureCreated()`方法创建我们整个数据库的结构。最后，我们为应用程序中的服务添加了对`IThemeParkDbContext`的依赖注入注册。
- en: 'That’s it for our integration server. Now, we can use `TestThemeParkApiApplication`
    in our integration test. For example, if we want to create a test for our `/attractions`
    API, our integration test will look as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的集成服务器就到这里。现在，我们可以在集成测试中使用`TestThemeParkApiApplication`。例如，如果我们想为我们的`/attractions`
    API创建一个测试，我们的集成测试将如下所示：
- en: '[PRE2]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code snippet, we initialized `TestThemeParkApiApplication`
    on setup so that every instance is new through the `.EnsureCreated()` method.
    `_app.CreateClient` gives us `HttpClient` to make a call to a URL. We make a call
    to our `/attractions` API and compare it with a resource string we created instead
    of cluttering our test methods with large JSON strings. Finally, our test compares
    the JSON results with what’s returned from an API.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在设置时初始化了`TestThemeParkApiApplication`，以便通过`.EnsureCreated()`方法确保每个实例都是新的。`_app.CreateClient`为我们提供了`HttpClient`来调用URL。我们调用我们的`/attractions`
    API，并将其与创建的资源字符串进行比较，而不是在我们的测试方法中添加大量的JSON字符串。最后，我们的测试将JSON结果与API返回的结果进行比较。
- en: The ability to create entire front-to-back integration tests proving the APIs,
    Entity Framework queries, and database code work as expected while running through
    a CI/CD pipeline with successful tests should instill confidence about the code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 能够创建整个前后端集成测试，证明API、Entity Framework查询和数据库代码在CI/CD管道中运行时按预期工作，应该会增加对代码的信心。
- en: In this section, we learned how to take APIs and test them in Visual Studio’s
    Endpoints Explorer. We also learned how to take those APIs and make them testable
    in a CI/CD pipeline by wrapping our API project using `WebApplicationFactory`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何在Visual Studio的端点资源管理器中测试API，以及如何通过使用`WebApplicationFactory`包装我们的API项目，使这些API在CI/CD管道中可测试。
- en: In the next section, we’ll cover some of the common practices used in the industry
    when building APIs.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍在构建API时行业常用的某些常见做法。
- en: Standardized Web API techniques
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准化的Web API技术
- en: In this section, we’ll learn how to use HTTP verbs and status codes properly,
    how to avoid large dependent resources, how to create paginations for APIs, how
    to version an API, using DTOs instead of entities, and the best way to make API
    calls from .NET.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何正确使用HTTP动词和状态码，如何避免大型依赖资源，如何为API创建分页，如何对API进行版本控制，使用DTO而不是实体，以及从.NET中调用API的最佳方式。
- en: Using the right HTTP verbs and status codes
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用正确的HTTP动词和状态码
- en: So far, we’ve looked at how to use HTTP verbs and how to return status codes.
    While this may seem like a trivial thing, some systems ignore these standards
    and use POSTs all the time, regardless of the function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了如何使用HTTP动词以及如何返回状态码。虽然这看起来可能是一件微不足道的事情，但一些系统忽略了这些标准，总是使用POST，无论功能如何。
- en: Swagger provides a great template for documenting APIs and with Visual Studio’s
    new Endpoints Explorer, Visual Studio brings this fundamental documentation down
    to the developer’s IDE, making the API easier to read and implement in other projects,
    showing developers what verbs to use and what status codes are expected.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger为API文档提供了一个很好的模板，而Visual Studio的新端点资源管理器将这一基本文档带到了开发者的IDE中，使得API更容易阅读和在其他项目中实现，向开发者展示了应该使用哪些动词以及预期的状态码。
- en: In our example of a shopping cart API earlier in this chapter, users were going
    to add products to a cart and proceed to check out. They were going to use a cart
    to begin this process. The function of checking out led us to use the cart API
    with a method of checkout (`/cart/checkout`), which makes perfect sense. We should
    take the user’s actions and match them to actions in the APIs.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面提到的购物车API示例中，用户本打算将产品添加到购物车并继续结账。他们将使用购物车开始这个过程。结账的功能让我们使用了购物车API，并采用结账方法（`/cart/checkout`），这非常合理。我们应该将用户的行为与API中的行为相匹配。
- en: Beware dependent resources
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小心依赖资源
- en: But how far do I take my API based on resources? What if one resource belongs
    to another resource and that’s dependent on another resource, and so on?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 但我如何根据资源来扩展我的API？如果一个资源属于另一个资源，而这个资源又依赖于另一个资源，依此类推怎么办？
- en: 'Here’s an example: `/users/{userId}/projects/{projectId}/tasks`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：`/users/{userId}/projects/{projectId}/tasks`。
- en: We want to get a user’s tasks for a project, but this URL seems a bit long,
    doesn’t it? How do we break this down into something a bit more manageable? Anything
    more than three levels deep is simply asking for trouble.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要获取一个用户的项目任务，但这个URL似乎有点长，不是吗？我们如何将其分解成更易于管理的东西？任何超过三个级别的都只是自找麻烦。
- en: This URL requires a more granular approach – that is, breaking out each resource.
    Instead of the preceding URL, a better approach would be to use `/users/{userId}/projects`
    to retrieve a list of projects a user is working on at a time. The next URL would
    provide the tasks based on the selected project and look like `/projects/{projectId}/tasks`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此URL需要一个更细粒度的方法——也就是说，将每个资源分离出来。而不是前面的URL，更好的方法是用`/users/{userId}/projects`来检索用户正在进行的项目的列表。下一个URL将根据所选项目提供任务，看起来像`/projects/{projectId}/tasks`。
- en: As developers, we all know everything is a compromise. In this case, we are
    providing a simpler API but requiring two calls instead of one.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们都知道一切都是妥协。在这种情况下，我们提供了一个更简单的API，但需要两次调用而不是一次。
- en: These are discussions to be had with team members, but essentially, the smaller
    the URL, the easier it is to implement. The longer the URL, the more resource
    lookups are necessary to fulfill the request.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是与团队成员讨论的话题，但基本上，URL越小，实现起来越容易。URL越长，为了满足请求，所需的资源查找就越多。
- en: Pagination in API results
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API结果中的分页
- en: For most API calls, results are returned in a raw, **JavaScript Object Notation**
    (**JSON**) format, usually as a collection or a single item. What if the client
    side needs paginated results and they only want one page of data for now?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数API调用，结果以原始的**JavaScript对象表示法**（**JSON**）格式返回，通常作为一个集合或单个项目。如果客户端需要分页结果，但现在只想获取一页数据怎么办？
- en: 'To assist client-side developers, a JSON result could contain the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了协助客户端开发者，JSON结果可以包含以下内容：
- en: '[PRE3]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'While returning results as a collection is usually required, some fields to
    return in the header are as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常需要将结果作为集合返回，但在头部返回的字段如下：
- en: '`Total`: Total number of records'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Total`: 记录总数'
- en: '`PageSize`: How many records are returned in this response'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PageSize`: 此响应中返回的记录数'
- en: '`TotalPages`: Specifies the total number of pages based on `PageSize`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TotalPages`: 根据页面大小指定总页数'
- en: '`CurrentPage`: Specifies what page we are currently on'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CurrentPage`: 指定我们当前所在的页面'
- en: '`Next` and `Previous`: Are there enough records to move back and forward?'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Next`和`Previous`：是否有足够的记录可以向前或向后移动？'
- en: '`Sort`: Specifies how the results are sorted'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sort`: 指定结果的排序方式'
- en: '`Filter`: Specifies what filter was applied to the results'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Filter`: 指定应用于结果中的过滤器'
- en: The header is meant to help our fellow client-side developer make the most of
    the response. While this isn’t a comprehensive list of fields to include, it should
    be implemented with consistency across every single response when displaying a
    subset of records on the client.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 头部旨在帮助我们的同行客户端开发者充分利用响应。虽然这不是包含字段的完整列表，但它应该在客户端显示记录子集时，在每次响应中保持一致性。
- en: A “status code” field or “success” field in the header should be avoided since
    HTTP status codes are considered the expected response.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在头部避免使用“状态码”字段或“成功”字段，因为HTTP状态码被认为是预期的响应。
- en: Versioning APIs
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API版本控制
- en: 'When creating APIs, by default, they’ll more than likely be in a raw state
    with no versioning in place. There are four types of versioning:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建API时，默认情况下，它们很可能会处于原始状态，没有版本控制。有四种类型的版本控制：
- en: '**No versioning**: When we create our first API'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无版本控制**：当我们创建第一个API时'
- en: '`/v1/users`)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （省略部分内容）
- en: '`/users/?version=1`)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （省略部分内容）
- en: '`custom-header` to place the version into the header:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`custom-header`将版本放入头部：
- en: '[PRE4]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The most common versioning technique that’s used is URI versioning. While everyone’s
    mileage may vary, this technique is appealing because it’s immediately obvious
    which version we’re using.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的版本化技术是URI版本化。虽然每个人的效果可能不同，但这种技术很有吸引力，因为它立即显而易见我们正在使用哪个版本。
- en: Use DTOs, not entities!
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用DTO而不是实体！
- en: While testing our API, we weren’t returning entities (`Attraction` or `Location`).
    Instead, we were returning **data transfer objects** (**DTOs**), which are a subset
    of properties.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试我们的API时，我们没有返回实体（`Attraction`或`Location`）。相反，我们返回的是**数据传输对象**（**DTOs**），这是属性的一个子集。
- en: Our security chapter ([*Chapter 4*](B19493_04.xhtml#_idTextAnchor086)) mentioned
    not to expose too much when it comes to primary keys or sensitive information.
    DTOs give the developer a chance to pick and choose which properties should be
    exposed to the client.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的安全章节（[*第4章*](B19493_04.xhtml#_idTextAnchor086)）提到，在涉及主键或敏感信息时不要暴露太多。DTOs（数据传输对象）给开发者提供了一个选择哪些属性应该暴露给客户端的机会。
- en: 'For example, our `Attraction` DTO is meant to provide a minimal amount of information;
    we’ll discuss this after we look at the following code example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的`Attraction` DTO旨在提供最小量的信息；我们将在查看以下代码示例之后讨论这一点：
- en: '[PRE5]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we have a simplified `AttractionDto` class containing simple properties.
    We also have a `LocationName` property based on our dependent `Location` class.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个简化版的`AttractionDto`类，包含简单的属性。我们还有一个基于我们依赖的`Location`类的`LocationName`属性。
- en: While we have this as a `.ToDto()` method, we could create other DTO extension
    methods to return different data in a `.ToDifferentDto()` method or whatever we
    want to call it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们有一个`.ToDto()`方法，但我们也可以创建其他DTO扩展方法，在`.ToDifferentDto()`方法（或我们想叫的任何名字）中返回不同的数据。
- en: Another reason to use DTOs instead of Entity Framework entities is the potentially
    recursive nature of navigational properties. When an entity is returned from an
    API, it’s turned into a JSON object. If we have a nested entity, it’ll follow
    it down the chain. It’s better to isolate and distill an entity’s properties down
    to their native types for basic consumption on the client side when they’re returned
    from the API.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DTO而不是Entity Framework实体另一个原因是导航属性的潜在递归性质。当一个实体从API返回时，它会被转换成一个JSON对象。如果我们有一个嵌套的实体，它将沿着链继续。当它们从API返回时，将实体属性隔离并提炼到它们的原生类型，以便在客户端进行基本消费，这会更好。
- en: Avoid new instances of HttpClient
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免创建新的HttpClient实例
- en: While the majority of this chapter discussed creating and testing APIs, I feel
    we need to mention how to consume them in a .NET application as well.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章的大部分内容讨论了创建和测试API，但我感觉我们还需要提到如何在.NET应用程序中消费它们。
- en: There are various ways to consume a web API, such as using `WebRequest` or `WebClient`,
    but for most purposes, the use of the `HttpClient` class is recommended because
    of its flexibility and modernization. The `WebRequest` and `WebClient` classes
    were included for the transition of legacy applications. With that said, it’s
    easy to create a new instance of `HttpClient`, but it’s not the best approach.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 消费Web API有多种方式，例如使用`WebRequest`或`WebClient`，但对于大多数目的，由于其灵活性和现代化，推荐使用`HttpClient`类。`WebRequest`和`WebClient`类被包含在内，是为了过渡到遗留应用程序。话虽如此，创建一个`HttpClient`的新实例很容易，但这并不是最佳方法。
- en: 'Microsoft states that `HttpClient` should only be used once per the lifetime
    of an application. If we create instances of `HttpClient` in multiple locations
    in our application, we are hindering the performance and scalability opportunities.
    It causes an issue called TCP port exhaustion if the rate of requests is too high,
    so it’s best to avoid code such as the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 微软表示，`HttpClient`应该在整个应用程序的生命周期中只使用一次。如果我们在我们应用程序的多个位置创建`HttpClient`的实例，我们将阻碍性能和可扩展性的机会。如果请求速率过高，这会导致TCP端口耗尽的问题，因此最好避免以下代码：
- en: '[PRE6]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Some developers may take this a step further and decide the following code
    snippet is better by wrapping a `using` statement to dispose of an `HttpClient`
    class properly:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者可能会更进一步，认为以下代码片段更好，因为它通过`using`语句正确地销毁了`HttpClient`类：
- en: '[PRE7]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The problem with this code is that we’re still creating another instance of
    `HttpClient`, still causing port exhaustion, and still disposing of it when we’ll
    more than likely need it later.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码的问题是我们仍在创建另一个`HttpClient`实例，仍然会导致端口耗尽，并且在我们很可能需要它的时候仍然会销毁它。
- en: In .NET Core 2.1, Microsoft created an `IHttpClientFactory` class to deliver
    a single instance of `HttpClient`. We can simply ask it for an `HttpClient` instance
    and we’ll receive one. The best news is it can be dependency injected.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET Core 2.1 中，Microsoft 创建了一个 `IHttpClientFactory` 类来提供单个 `HttpClient` 实例。我们可以简单地请求一个
    `HttpClient` 实例，并且我们会收到一个。最好的消息是它可以进行依赖注入。
- en: 'The code becomes easier to work with once we’ve injected the class through
    constructors, as shown in the following code snippet:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过构造函数注入了类，代码就会变得更容易处理，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we ask `HttpClientFactory` for a client using `.CreateClient()`, it won’t
    create a new instance of `HttpClient` unless it has to.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `.CreateClient()` 从 `HttpClientFactory` 获取客户端时，除非必须，否则它不会创建一个新的 `HttpClient`
    实例。
- en: 'Think of the `.CreateClient()` method as using a singleton design pattern behind
    the scenes, similar to the code shown here:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `.CreateClient()` 方法视为在幕后使用单例设计模式，类似于以下代码所示：
- en: '[PRE9]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As a side note, the preceding code is *not* thread-safe; it has been provided
    to show the concept of a singleton design pattern.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，前面的代码**不是**线程安全的；它被提供出来以展示单例设计模式的概念。
- en: We always get an instance of `HttpClient`, which is a better way to make server-side
    API calls.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是得到一个 `HttpClient` 实例，这是进行服务器端 API 调用的更好方式。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about several techniques, such as how to design
    an API by disconnecting from technology by becoming a user of the application,
    identifying the resources, and using the right HTTP verbs and correct status codes.
    We also learned how to create, test, and document APIs, along with why minimal
    APIs are important. After, we learned how to use the new Endpoints Explorer in
    Visual Studio 2022, as well as how to build an automated end-to-end test of our
    APIs in a CI/CD pipeline.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了几个技术，例如如何通过成为应用程序的用户、识别资源、使用正确的 HTTP 动词和状态码来设计 API。我们还学习了如何创建、测试和记录
    API，以及为什么最小 API 很重要。之后，我们学习了如何在 Visual Studio 2022 中使用新的端点探索器，以及如何在 CI/CD 管道中构建我们
    API 的自动化端到端测试。
- en: Once we understood the process of writing APIs, we examined what standards were
    used in the industry to create common and useful APIs, such as using the correct
    HTTP verbs and status codes, avoiding large URLs, how to use pagination with APIs,
    versioning our API, using DTOs instead of entities, and the optimal way to use
    `HttpClient` when making API calls from .NET.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了编写 API 的过程，我们就检查了在行业中用于创建通用和有用 API 的标准，例如使用正确的 HTTP 动词和状态码、避免大型 URL、如何使用
    API 进行分页、API 版本化、使用 DTO 而不是实体，以及从 .NET 进行 API 调用时使用 `HttpClient` 的最佳方式。
- en: In the next chapter, we’ll look at how to improve performance across various
    topics we’ve covered in this book, and we’ll also provide some new performance
    tips.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何提高本书中涵盖的各个主题的性能，并提供一些新的性能提示。
