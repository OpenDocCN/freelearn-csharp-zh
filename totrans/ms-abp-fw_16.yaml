- en: '*Chapter 12*: Working with MVC/Razor Pages'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：与 MVC/Razor Pages 一起工作'
- en: ABP Framework was designed to be modular, layered, and UI framework-agnostic.
    It is perfect for server-client architecture, and in theory, it can work with
    any kind of UI technology. The server-side uses the standard authentication protocols
    and provides standard-compliant HTTP APIs. You can use your favorite SPA framework
    and consume server-side APIs easily. In this way, you can utilize the entire server-side
    infrastructure of ABP Framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 框架被设计成模块化、分层且与 UI 框架无关。它非常适合服务器-客户端架构，从理论上讲，它可以与任何类型的 UI 技术一起工作。服务器端使用标准的身份验证协议并提供符合标准的
    HTTP API。您可以使用您喜欢的 SPA 框架并轻松地消费服务器端 API。这样，您就可以利用 ABP 框架的整个服务器端基础设施。
- en: However, ABP Framework helps with your UI development too. It provides systems
    so that you can build modular user interfaces, UI themes, layouts, navigation
    menus, and toolbars. It makes your development process easier while working with
    data tables, modals, and forms or authenticating and communicating with the server.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ABP 框架也帮助您进行 UI 开发。它提供系统，使您可以构建模块化用户界面、UI 主题、布局、导航菜单和工具栏。它使您在处理数据表、模态框和表单或与服务器进行身份验证和通信时的工作过程更加容易。
- en: 'ABP Framework is well integrated with, and provides startup solution templates
    for, the following UI frameworks:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 框架与以下 UI 框架良好集成，并提供启动解决方案模板：
- en: ASP.NET Core MVC/Razor Pages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC/Razor Pages
- en: Blazor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor
- en: Angular
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular
- en: In the fourth section of this book, I will cover working with the MVC/Razor
    Pages and Blazor UI options. In this chapter, you will learn how ABP Framework's
    MVC/Razor Page infrastructure is designed and how it can help you with your regular
    UI development cycle.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第四部分，我将介绍如何使用 MVC/Razor Pages 和 Blazor UI 选项。在本章中，您将学习 ABP 框架的 MVC/Razor
    Page 基础设施是如何设计的，以及它如何帮助您完成常规的 UI 开发周期。
- en: I call this UI type MVC/Razor Pages as it supports both the MVC and Razor Pages
    approaches. You can even use both in a single application. However, since Razor
    Pages (introduced with ASP.NET Core 2.0) is Microsoft's recommended approach for
    new applications, all pre-built ABP modules, samples, and documents use the Razor
    Pages approach.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这种 UI 类型称为 MVC/Razor Pages，因为它支持 MVC 和 Razor Pages 两种方法。你甚至可以在单个应用程序中使用两者。然而，由于
    Razor Pages（自 ASP.NET Core 2.0 以来引入）是微软推荐的新应用程序的方法，所有预构建的 ABP 模块、示例和文档都使用 Razor
    Pages 方法。
- en: 'This chapter covers the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Understanding the theming system
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解主题系统
- en: Using bundling and minification
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用打包和压缩
- en: Working with menus
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与菜单一起工作
- en: Working with Bootstrap tag helpers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Bootstrap 标签助手一起工作
- en: Creating forms and implementing validation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建表单并实现验证
- en: Working with modals
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与模态框一起工作
- en: Using the JavaScript API
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JavaScript API
- en: Consuming HTTP APIs
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费 HTTP API
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you want to follow along with the examples in this chapter, you will need
    to have an IDE/editor that supports ASP.NET Core development. We will use the
    ABP CLI at some points, so you will need to install the ABP CLI, as explained
    in [*Chapter 2*](B17287_02_Epub_AM.xhtml#_idTextAnchor026), *Getting Started with
    ABP Framework*. Finally, you will need to install Node.js v14+ to be able to install
    NPM packages.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想跟随本章中的示例，您将需要一个支持 ASP.NET Core 开发的 IDE/编辑器。在某些时候，我们将使用 ABP CLI，因此您需要安装 ABP
    CLI，如[*第2章*](B17287_02_Epub_AM.xhtml#_idTextAnchor026)中所述，*ABP 框架入门*。最后，您需要安装
    Node.js v14+ 以能够安装 NPM 包。
- en: 'You can download the example application from this book''s GitHub repository:
    [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).
    It contains some of the examples provided in this chapter.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从本书的 GitHub 仓库下载示例应用程序：[https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework)。它包含本章提供的一些示例。
- en: Understanding the theming system
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解主题系统
- en: UI styling is the most customized part of an application, and you have plenty
    of options. You can start with one of the UI kits such as Bootstrap, Tailwind
    CSS, or Bulma as the base for your application UI. You can then build a design
    language or buy a pre-built, cheap UI theme from a theme market. If you are building
    an independent application, you can make your selections and create your UI pages
    and components based on these selections. Your pages and styling don't have to
    be compatible with another application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: UI样式是应用程序中最具定制性的部分，您有很多选择。您可以从Bootstrap、Tailwind CSS或Bulma等UI工具包之一作为您应用程序UI的基础开始。然后，您可以构建一个设计语言或从主题市场购买一个预构建的、价格低廉的UI主题。如果您正在构建一个独立的应用程序，您可以根据这些选择进行选择，并基于这些选择创建您的UI页面和组件。您的页面和样式不需要与另一个应用程序兼容。
- en: On the other hand, if you want to build a modular application where each module's
    UI is independently developed (probably by a separate team) where the modules
    come together at runtime as a single application, you need to determine a design
    standard that should be implemented by all the module developers so that you have
    a consistent user interface.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您想构建一个模块化应用程序，其中每个模块的UI都是独立开发的（可能由不同的团队完成），模块在运行时作为一个单一的应用程序组合在一起，您需要确定一个设计标准，所有模块开发者都应该实施，以便您有一个一致的用户界面。
- en: Since ABP Framework provides a modular infrastructure, it provides a theming
    system that determines a set of base libraries and standards. This helps ensure
    that the application and module developers can build UI pages and components without
    depending on a particular theme or style set. Once the module/application code
    is theme-independent and the theme standards are explicit, you can build different
    themes and easily use that theme for an application with a simple configuration.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ABP框架提供了一个模块化基础设施，它提供了一个主题系统，该系统确定了一组基础库和标准。这有助于确保应用程序和模块开发者可以构建UI页面和组件，而无需依赖于特定的主题或样式集。一旦模块/应用程序代码与主题无关且主题标准明确，您就可以构建不同的主题，并可以通过简单的配置轻松地为应用程序使用该主题。
- en: 'ABP Framework provides two free pre-built UI themes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ABP框架提供了两个免费的预构建UI主题：
- en: The **Basic** theme is a minimalist theme that is built on the plain Bootstrap
    styling. It is ideal if you want to build styling from scratch.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本**主题是一个基于纯Bootstrap样式的简约主题。如果您想从头开始构建样式，它是最理想的。'
- en: The **LeptonX** theme is a modern and production-ready UI theme built by the
    ABP Framework team.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LeptonX**主题是由ABP框架团队构建的现代且适用于生产的UI主题。'
- en: 'This book uses the Basic theme in all examples. The following is a screenshot
    of the LeptonX theme:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本书在所有示例中都使用基本主题。以下是LeptonX主题的截图：
- en: '![Figure 12.1 – The LeptonX theme and the application layout'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 – LeptonX主题和应用程序布局'
- en: '](img/Figure_12.01_B17287.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.01_B17287.jpg)'
- en: Figure 12.1 – The LeptonX theme and the application layout
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – LeptonX主题和应用程序布局
- en: Pre-built UI themes are deployed as NuGet and NPM packages, so you can easily
    install and switch between them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 预构建的UI主题作为NuGet和NPM包部署，因此您可以轻松安装和切换它们。
- en: The next two sections will introduce the fundamental base libraries and layouts
    that are shared by these themes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两节将介绍这些主题共享的基本基础库和布局。
- en: The base libraries
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础库
- en: To make modules/applications independent of a particular theme, ABP determines
    some base CSS and JavaScript libraries that our module/application can rely on.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使模块/应用程序独立于特定的主题，ABP确定了一些基础CSS和JavaScript库，我们的模块/应用程序可以依赖这些库。
- en: The first and the most fundamental dependency of the ABP Framework MVC/Razor
    Pages UI is the *Twitter Bootstrap* framework. Starting with ABP Framework version
    5.0, Bootstrap 5.x is used.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ABP框架MVC/Razor Pages UI的第一个和最基本依赖是*Twitter Bootstrap*框架。从ABP框架版本5.0开始，使用Bootstrap
    5.x。
- en: Besides Bootstrap, there are some other core library dependencies such as Datatables.Net,
    JQuery, JQuery Validation, FontAwesome, Sweetalert, Toastr, Lodash, and more.
    No additional setup is needed if you want to use these standard libraries in your
    module or application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Bootstrap之外，还有一些其他的核心库依赖，例如Datatables.Net、JQuery、JQuery Validation、FontAwesome、Sweetalert、Toastr、Lodash等。如果您想在模块或应用程序中使用这些标准库，不需要额外的设置。
- en: The next section will explain the layout system that is needed to understand
    how a web page is built.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将解释所需的布局系统，以便理解网页是如何构建的。
- en: The layouts
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局
- en: 'A typical web page consists of two parts – the layout and the page''s content.
    The layout shapes the overall page and generally includes the main header, a company/product
    logo, the main navigation menu, a footer, and other standard components. The following
    screenshot shows these parts on an example layout:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Parts of a page layout'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.02_B17287.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – Parts of a page layout
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: In modern web applications, layouts are designed to be responsive, which means
    they change their shape and placing so that they are suitable for the device that's
    being used by the current user.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The layout's content almost remains the same across different pages – only the
    page's content changes. The page's content is generally a large part of the layout
    and may scroll if the content is larger than the height of the screen.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'A web application may have different layout requirements in different parts/pages.
    In ABP Framework, a theme can define one or more layouts. Every layout has a unique
    `string` name, and ABP Framework defines four standard layout names:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '`Application`: Designed for back-office-style web applications with a header,
    menu, toolbar, footer, and so on. An example is shown in *Figure 12.1*.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Account`: Designed for login, register, and other account-related pages.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Public`: Designed for public-facing websites, such as a landing page for your
    product.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Empty`: A layout without an actual layout. The page''s content covers the
    entire screen.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These strings are defined in the `Volo.Abp.AspNetCore.Mvc.UI.Theming. StandardLayouts`
    class. Every theme must define the `Application`, `Account`, and `Empty` layouts
    because they are common for most applications. The `Public` layout is optional
    and falls back to the `Application` layout if it's not implemented by the theme.
    A theme may define more layouts with different names.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The `Application` layout is the default unless you change it. You can change
    it per page/view or for a folder. If you change it for a folder, all the pages/views
    under that folder will use the selected layout.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'To change it for a page/view, inject the `IThemeManager` service and use the
    `CurrentTheme.GetLayout` method with a layout name:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, you can use the `StandardLayouts` class to get the standard layout names.
    For this example, we could use `GetLayout("Empty")` since the value of `StandardLayouts.Empty`
    is a constant `string` that's `Empty`. In this way, you can get your theme's non-standard
    layouts with their `string` names.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to change the layout for all the pages/views in a folder, you can
    create a `_ViewStart.cshtml` file in that folder and place the following code
    inside it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you place that `_ViewStart.cshtml` file in the `Pages` folder (or in `Views`
    for MVC views), all your pages will use the selected layout unless you select
    another layout for a subfolder or a particular page/view.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: We can easily select a layout for our page to place content in. The next section
    will explain how to import script/style files into our pages and utilize the bundling
    and minification system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松选择一个布局来放置页面内容。下一节将解释如何将脚本/样式文件导入到我们的页面中，并利用打包和压缩系统。
- en: Using the bundling and minification system
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用打包和压缩系统
- en: ABP offers an end-to-end solution for installing client-side packages, adding
    script/style files to the pages, and bundling and minifying these files in development
    and production environments.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ABP提供了一站式解决方案，用于安装客户端包、将脚本/样式文件添加到页面中，并在开发和生产环境中打包和压缩这些文件。
- en: Let's start by installing a client-side package for the application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装应用程序的客户端包开始。
- en: Installing NPM packages
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装NPM包
- en: 'NPM is the de facto package manager for JavaScript/CSS libraries. When you
    create a new solution with the MVC/Razor Pages UI, you will see a `package.json`
    file in the web project''s root folder. The initial content of the `package.json`
    file will look something like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: NPM是JavaScript/CSS库的事实上的包管理器。当您使用MVC/Razor Pages UI创建新解决方案时，您将在Web项目的根文件夹中看到一个`package.json`文件。`package.json`文件的初始内容可能看起来像这样：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Initially, we have a single NPM package dependency called `@abp/aspnetcore.mvc.ui.theme.basic`.
    This package has dependencies on all the base CSS/JavaScript libraries that are
    necessary for the Basic theme. If we want to install another NPM package, we can
    use the standard `npm install` (or `yarn add`) command.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们有一个名为`@abp/aspnetcore.mvc.ui.theme.basic`的单个NPM包依赖项。此包依赖于所有必要的基CSS/JavaScript库，以支持基本主题。如果我们想安装另一个NPM包，我们可以使用标准的`npm
    install`（或`yarn add`）命令。
- en: 'Let''s assume that we want to use the *Vue.js* library in our application.
    We can run the following command in the root directory of the web project:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在应用程序中使用*Vue.js*库。我们可以在Web项目的根目录下运行以下命令：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command installs the `vue` NPM package in the `node_modules/vue` folder.
    However, we can't use the files under the `node_modules` folder. We should copy
    the necessary files into the `wwwroot` folder of the web project to import them
    into the pages.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将`vue` NPM包安装到`node_modules/vue`文件夹中。然而，我们无法使用`node_modules`文件夹下的文件。我们应该将必要的文件复制到Web项目的`wwwroot`文件夹中，以便将它们导入到页面中。
- en: 'You can copy the necessary files manually, but this is not the best way. ABP
    provides an `install-libs` command to automate this process using a mapping file.
    Open the `abp.resourcemapping.js` file under the web project and add the following
    code to the `mappings` dictionary:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以手动复制必要的文件，但这不是最佳方式。ABP提供了一个`install-libs`命令，通过映射文件来自动化此过程。在Web项目下打开`abp.resourcemapping.js`文件，并将以下代码添加到`mappings`字典中：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The final content of the `abp.resourcemapping.js` file should look as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`abp.resourcemapping.js`文件的最终内容应如下所示：'
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can run the following command in a command-line terminal, in the root
    directory of the web project:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在命令行终端中，在Web项目的根目录下运行以下命令：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `vue.min.js` file should be copied under the `wwwroot/libs/vue` folder:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 应将`vue.min.js`文件复制到`wwwroot/libs/vue`文件夹下：
- en: '![Figure 12.3 – Adding the Vue.js library to the web project'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3 – 将Vue.js库添加到Web项目中'
- en: '](img/Figure_12.03_B17287.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.03_B17287.jpg]'
- en: Figure 12.3 – Adding the Vue.js library to the web project
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 将Vue.js库添加到Web项目中
- en: 'Mappings support glob/wildcard patterns. For example, you can copy all the
    files in the `vue` package with the following mapping:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 映射支持glob通配符模式。例如，您可以使用以下映射复制`vue`包中的所有文件：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `libs` folder is committed to the source control system (such as Git) by
    default. This means that if your teammate gets the code from your source control
    system, they don't need to run the `npm install` or `abp install-libs` commands.
    If you want, you can add the `libs` folder to the ignore file of your source control
    (such as `.gitignore` for Git). In this case, you need to run the `npm install`
    and `abp install-libs` commands before running the application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`libs`文件夹被提交到源代码控制系统（如Git）。这意味着如果您的队友从您的源代码控制系统中获取代码，他们不需要运行`npm install`或`abp
    install-libs`命令。如果您愿意，可以将`libs`文件夹添加到源代码控制系统的忽略文件中（如Git的`.gitignore`）。在这种情况下，您需要在运行应用程序之前运行`npm
    install`和`abp install-libs`命令。
- en: The next section explains the standard ABP NPM packages.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将解释标准ABP NPM包。
- en: Using the standard packages
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标准包
- en: Building a modular system has another challenge – all the modules should use
    the same (or compatible) version of the same NPM package. ABP Framework provides
    a set of standard NPM packages to allow the ABP ecosystem to use the same version
    of these NPM packages and automate the mapping to copy the resources to the `libs`
    folder.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 构建模块化系统还有一个挑战——所有模块都应该使用相同（或兼容）版本的同一NPM包。ABP框架提供了一套标准NPM包，以便ABP生态系统可以使用这些NPM包的相同版本，并自动映射到将资源复制到`libs`文件夹。
- en: '`@abp/vue` is one of these standard packages that can be used to install the
    Vue.js library in your project. You can install this package instead of the `vue`
    package:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`@abp/vue`是这些标准包之一，可以用来在你的项目中安装Vue.js库。你可以安装这个包而不是`vue`包：'
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, you can run the `abp install-libs` command to copy the `vue.min.js` file
    into the `wwwroot/libs/vue` folder. Notice that you don't need to define the mapping
    in the `abp.resourcemapping.js` file since the `@abp/vue` package already includes
    the necessary mapping configuration.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行`abp install-libs`命令将`vue.min.js`文件复制到`wwwroot/libs/vue`文件夹。注意，你不需要在`abp.resourcemapping.js`文件中定义映射，因为`@abp/vue`包已经包含了必要的映射配置。
- en: It is suggested that you use the standard `@abp/*` packages when they are available.
    In this way, you can depend on a standard version of the related library, and
    you don't need to configure the `abp.resourcemapping.js` file manually.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 建议当它们可用时使用标准的`@abp/*`包。这样，你可以依赖相关库的标准版本，而且你不需要手动配置`abp.resourcemapping.js`文件。
- en: However, when you install the library in your project, you will need to import
    it into the page to use it in your application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你在项目中安装库时，你需要将其导入页面才能在应用程序中使用它。
- en: Importing script and style files
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入脚本和样式文件
- en: 'Once we have installed a JavaScript or CSS library, we can include it in any
    page or bundle. Let''s start with the most simple case – you can import `vue.min.js`
    into a Razor Page or view it using the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了JavaScript或CSS库，我们就可以将其包含在任何页面或捆绑包中。让我们从最简单的情况开始——你可以使用以下代码将`vue.min.js`导入Razor页面或查看它：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, we are importing JavaScript files into the `scripts` section, so the
    theme is placing them at the end of the HTML document, after the global scripts.
    `abp-script` is a tag helper that''s defined by ABP Framework to include scripts
    to the page/view. It is rendered as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在将JavaScript文件导入到`scripts`部分，因此主题将它们放置在HTML文档的末尾，在全局脚本之后。`abp-script`是ABP框架定义的一个标签助手，用于将脚本包含到页面/视图中。它被渲染如下：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We could use a standard `script` tag, but `abp-script` has the following advantages:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标准的`script`标签，但`abp-script`有以下优点：
- en: It automatically minifies the file in the production (or staging) environment
    if the given file is not already minified. If it is not minified and ABP finds
    the minified file near the original file, it uses the pre-minified file instead
    of dynamically minifying at runtime.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果给定的文件尚未压缩，它会在生产（或预发布）环境中自动压缩该文件。如果文件未压缩且ABP在原始文件附近找到压缩文件，它将使用预压缩文件而不是在运行时动态压缩。
- en: It adds a query string parameter to add versioning information so that the browsers
    don't cache it when the file changes. This means that when you re-deploy your
    application, browsers don't accidentally cache the old versions of your script
    files.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它添加了一个查询字符串参数来添加版本信息，这样当文件更改时，浏览器不会缓存它。这意味着当你重新部署应用程序时，浏览器不会意外地缓存你的脚本文件的老版本。
- en: ABP ensures that the file is added to the page only once, even if you include
    it multiple times. This is a good feature if you wish to build a modular system
    since different module components may include the same library independent of
    each other, and ABP Framework eliminates this duplication.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ABP确保文件只添加到页面一次，即使你多次包含它。如果你希望构建模块化系统，这是一个很好的特性，因为不同的模块组件可能包含独立的相同库，而ABP框架消除了这种重复。
- en: 'Once we have included Vue.js in a page, we can utilize its power to create
    highly dynamic pages. Here is an example Razor Page, named `VueDemo.cshtml`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在页面中包含了Vue.js，我们就可以利用其力量创建高度动态的页面。以下是一个名为`VueDemo.cshtml`的Razor页面示例：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you run this page, a **Hello Vue!** message will be shown on the UI. I can
    recommend using Vue.js in some pages of your MVC/Razor Pages applications when
    you need to build complex and dynamic user interfaces.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个页面，UI上会显示一个**Hello Vue!**消息。我建议在你需要构建复杂和动态用户界面的MVC/Razor Pages应用程序的一些页面中使用Vue.js。
- en: 'Let''s take this example one step further and move the custom JavaScript code
    into a separate file. Create a JavaScript file named `VueDemo.cshtml.js` in the
    same folder:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步分析这个例子，并将自定义 JavaScript 代码移动到一个单独的文件中。在同一文件夹中创建一个名为 `VueDemo.cshtml.js`
    的 JavaScript 文件：
- en: '![Figure 12.4 – Adding a JavaScript file'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.4 – 添加 JavaScript 文件'
- en: '](img/Figure_12.04_B17287.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.04_B17287.jpg]'
- en: Figure 12.4 – Adding a JavaScript file
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – 添加 JavaScript 文件
- en: I prefer this naming convention, but you can set any name for the JavaScript
    file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢这种命名约定，但你可以为 JavaScript 文件设置任何名称。
- en: JavaScript/CSS Files Under the Pages Folder
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Pages 文件夹下的 JavaScript/CSS 文件
- en: In a regular ASP.NET Core application, you should place all the JavaScript/CSS
    files under the `wwwroot` folder. ABP allows you to add JavaScript/CSS files to
    the `Pages` or `Views` folder, near the corresponding `.cshtml` file. I find this
    approach to be pretty useful since we keep the related files together.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规 ASP.NET Core 应用程序中，你应该将所有 JavaScript/CSS 文件放置在 `wwwroot` 文件夹下。ABP 允许你将 JavaScript/CSS
    文件添加到 `Pages` 或 `Views` 文件夹，靠近相应的 `.cshtml` 文件。我发现这种方法非常实用，因为我们把相关的文件放在一起。
- en: 'The content of the new JavaScript file is shown in the following code block:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 JavaScript 文件的内容如下所示：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can update the `VueDemo.cshtml` file''s content, as shown in the following
    code block:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新 `VueDemo.cshtml` 文件的内容，如下所示：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It is good to keep JavaScript code in a separate file and include it on the
    page as an external file, as in the preceding example.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JavaScript 代码保存在单独的文件中，并将其作为外部文件包含在页面上，就像前面的例子一样，这是一个好习惯。
- en: 'Working with style (CSS) files is pretty similar to working with script files.
    The following example uses the `styles` section and the `abp-style` tag helper
    to import a style file on the page:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与样式（CSS）文件一起工作与脚本文件一起工作非常相似。以下示例使用 `styles` 部分 和 `abp-style` 标签助手在页面上导入一个样式文件：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can import multiple script or style files into a page. The next section will
    show you how to bundle these files as a single, minified file in production.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将多个脚本或样式文件导入到页面中。下一节将展示如何在生产中将这些文件捆绑成一个单一的、压缩的文件。
- en: Creating page bundles
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建页面 bundle
- en: 'When we use multiple `abp-script` (or `abp-style`) tags on a page, ABP individually
    includes the files on the page and includes the minified versions in production.
    However, we generally want to create a single bundled and minified file in production.
    We can use the `abp-script-bundle` and `abp-style-bundle` tag helpers to create
    bundles for a page, as shown in the following example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在页面上使用多个 `abp-script`（或 `abp-style`）标签时，ABP 会单独包含页面上的文件，并在生产中包含压缩版本。然而，我们通常希望在生产中创建一个单一的捆绑和压缩文件。我们可以使用
    `abp-script-bundle` 和 `abp-style-bundle` 标签助手为页面创建 bundle，如下例所示：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we are creating a bundle that includes two files. ABP automatically minifies
    these files and bundles them as a single file, and then versions this single file
    in the production environment. ABP makes the bundling operation in the first request
    to the page and then caches the bundled file in memory. It uses the cached bundle
    file for subsequent requests.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个包含两个文件的 bundle。ABP 会自动压缩这些文件，并将它们捆绑成一个文件，然后在生产环境中对这个单一文件进行版本控制。ABP
    在第一次请求页面时执行捆绑操作，并将捆绑的文件缓存到内存中。它使用缓存的捆绑文件来处理后续请求。
- en: 'You can use conditional logic or dynamic code inside the bundle tags, as shown
    in the following example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 bundle 标签内使用条件逻辑或动态代码，如下例所示：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This example adds a sample validation library to the bundle and conditionally
    adds the Turkish localization script. If the user's language is Turkish, then
    Turkish localization will be added to the bundle. Otherwise, it won't be added.
    ABP can understand the difference – it creates and caches two separate bundles,
    one for Turkish users and one for the rest.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例向 bundle 添加了一个示例验证库，并条件性地添加了土耳其本地化脚本。如果用户的语言是土耳其语，则将土耳其本地化添加到 bundle 中。否则，不会添加。ABP
    可以理解这种差异——它创建并缓存两个单独的 bundle，一个用于土耳其用户，另一个用于其他人。
- en: With that, we've learned how to create bundles for an individual page. In the
    next section, we will explain how to configure global bundles.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经学会了如何为单个页面创建 bundle。在下一节中，我们将解释如何配置全局 bundle。
- en: Configuring global bundles
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置全局 bundle
- en: The bundling tag helpers are very useful for page bundles. You can also use
    them if you are creating custom layouts. However, when we use themes, the layouts
    are controlled by the theme.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Bundling 标签助手对于页面 bundle 非常有用。如果你正在创建自定义布局，你也可以使用它们。然而，当我们使用主题时，布局由主题控制。
- en: 'Let''s assume that we''ve decided to use the Vue.js library on all the pages
    and want to add it to the global bundle instead of adding it to every page individually.
    For this, we can configure `AbpBundlingOptions` in `ConfigureServices` of our
    module (in the web project), as shown in the following code block:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经决定在所有页面上使用Vue.js库，并希望将其添加到全局捆绑中，而不是逐页添加。为此，我们可以在模块的`ConfigureServices`中配置`AbpBundlingOptions`（在Web项目中），如下面的代码块所示：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `options.ScriptBundles.Configure` method is used to manipulate a bundle
    with the given name. The first parameter is the name of the bundle. `StandardBundles.Scripts.Global`
    is a `constant string` whose value is the name of the global script bundle, which
    is imported by all the layouts. The preceding example also adds a CSS file to
    the global style bundle.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`options.ScriptBundles.Configure`方法用于操作具有给定名称的捆绑。第一个参数是捆绑的名称。`StandardBundles.Scripts.Global`是一个`常量字符串`，其值是全局脚本捆绑的名称，由所有布局导入。前面的示例还向全局样式捆绑添加了一个CSS文件。'
- en: The global bundles are just named bundles. We will explain these in the next
    section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 全局捆绑只是命名的捆绑。我们将在下一节中解释这些。
- en: Creating named bundles
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建命名的捆绑
- en: Page-based bundling is a simple way to create bundles for a single page. However,
    there are situations where you will need to define a bundle and reuse it on multiple
    pages. As explained in the previous section, the global style and script bundles
    were named bundles. We can also define custom-named bundles and import the bundle
    in any page or layout.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 基于页面的捆绑是创建单个页面捆绑的简单方法。然而，在某些情况下，您将需要定义一个捆绑并在多个页面上重用它。如前所述，全局样式和脚本捆绑是命名的捆绑。我们也可以定义自定义命名的捆绑，并在任何页面或布局中导入捆绑。
- en: 'The following example defines a named bundle and adds three JavaScript files
    inside it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例定义了一个命名的捆绑，并在其中添加了三个JavaScript文件：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can write this code in `ConfigureServices` of a module class (typically,
    the module class in the web layer). `options.ScriptBundles` and `options.StyleBundles`
    are two kinds of bundles. In this example, we've used the `ScriptBundles` property
    to create a bundle that includes some JavaScript files.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在模块类（通常是Web层的模块类）的`ConfigureServices`中编写此代码。`options.ScriptBundles`和`options.StyleBundles`是两种捆绑类型。在这个例子中，我们使用了`ScriptBundles`属性来创建一个包含一些JavaScript文件的捆绑。
- en: 'Once we have created a named bundle, we can use it in a page/view using the
    `abp-script-bundle` and `abp-style-bundle` tag helpers, as shown in the following
    example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了一个命名的捆绑，我们就可以使用`abp-script-bundle`和`abp-style-bundle`标签助手在页面/视图中使用它，如下面的示例所示：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When we use this code in a page or view, all the script files are individually
    added to the page at development time. They are automatically bundled and minified
    in the production environment by default. The next section explains how to change
    this default behavior.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在页面或视图中使用此代码时，所有脚本文件在开发时间单独添加到页面中。默认情况下，它们在生产环境中自动捆绑和压缩。下一节将解释如何更改此默认行为。
- en: Controlling the bundling and minification behavior
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制捆绑和压缩行为
- en: 'We can use the `AbpBundlingOptions` options class to change the default behavior
    of the bundling and minification system. See the following configuration:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`AbpBundlingOptions`选项类来更改捆绑和压缩系统的默认行为。请参见以下配置：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This configuration code disables the bundling and minification logic. This
    means that even in production, all the script/style files are individually added
    to the page without bundling and minification. `options.Mode` can take one of
    the following values:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置代码禁用了捆绑和压缩逻辑。这意味着即使在生产环境中，所有脚本/样式文件也是单独添加到页面中，而不进行捆绑和压缩。`options.Mode`可以取以下值之一：
- en: '`Auto` (default): Bundles and minifies in production and staging environments
    but disables bundling and minification at development time.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Auto`（默认）：在生产环境和预发布环境中捆绑和压缩，但在开发时间禁用捆绑和压缩。'
- en: '`Bundle`: Bundles the files (creates a file per bundle) but does not minify
    the styles/scripts.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bundle`: 将文件捆绑（为每个捆绑创建一个文件）但不会压缩样式/脚本。'
- en: '`BundleAndMinify`: Always bundles and minifies the files, even at development
    time.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BundleAndMinify`：始终捆绑和压缩文件，即使在开发时间也是如此。'
- en: '`None`: Disables the bundling and minification process.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`：禁用捆绑和压缩过程。'
- en: 'In this book, I''ve explained the basic usage of the bundling and minification
    system. However, it has advanced features, such as creating bundle contributor
    classes, inheriting a bundle from another bundle, extending and manipulating bundles,
    and more. These features are especially helpful when you want to create reusable
    UI modules. Please refer to the ABP Framework documentation for all the features:
    [https://docs.abp.io/en/abp/latest/UI/AspNetCore/Bundling-Minification](https://docs.abp.io/en/abp/latest/UI/AspNetCore/Bundling-Minification).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我已经解释了捆绑和最小化系统的基本用法。然而，它具有高级功能，例如创建捆绑贡献者类、从另一个捆绑继承、扩展和操作捆绑等。这些功能在你想创建可重用
    UI 模块时特别有帮助。请参阅 ABP 框架文档以了解所有功能：[https://docs.abp.io/en/abp/latest/UI/AspNetCore/Bundling-Minification](https://docs.abp.io/en/abp/latest/UI/AspNetCore/Bundling-Minification)。
- en: In the next section, you will learn how to work with navigation menus.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何与导航菜单一起工作。
- en: Working with menus
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与菜单一起工作
- en: Menus are rendered by the current theme, so the final application or modules
    can't directly change the menu items. You can see the main menu on the left-hand
    side of *Figure 12.1*. ABP provides a menu system, so the modules and the final
    application can dynamically add new menu items or remove/change the items that
    are added by those modules.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单由当前主题渲染，因此最终的应用程序或模块不能直接更改菜单项。你可以在 *图 12.1* 的左侧看到主菜单。ABP 提供了一个菜单系统，因此模块和最终应用程序可以动态添加新的菜单项或删除/更改由这些模块添加的项目。
- en: 'We can use `AbpNavigationOptions` to add contributors to the menu system. ABP
    executes all the contributors to build the menu dynamically, as shown in the following
    example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `AbpNavigationOptions` 来向菜单系统添加贡献者。ABP 会执行所有贡献者以动态构建菜单，如下面的示例所示：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, `MyMenuContributor` should be a class that implements the `IMenuContributor`
    interface. The ABP startup solution template already contains a menu contributor
    class that you can directly use. `IMenuContributor` defines the `ConfigureMenuAsync`
    method, which we should implement like so:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`MyMenuContributor` 应该是一个实现了 `IMenuContributor` 接口的类。ABP 启动解决方案模板已经包含了一个可以直接使用的菜单贡献者类。`IMenuContributor`
    定义了 `ConfigureMenuAsync` 方法，我们应该像这样实现它：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first thing we should consider is the menu''s name. Two standard menu names
    are defined as constants in the `StandardMenus` class (in the `Volo.Abp.UI.Navigation`
    namespace):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应该考虑的是菜单的名称。在 `StandardMenus` 类（在 `Volo.Abp.UI.Navigation` 命名空间中）中定义了两个标准菜单名称作为常量：
- en: '`Main`: The main menu of the application. It is shown on the left-hand side
    of *Figure 12.1*.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Main`：应用程序的主菜单。它在 *图 12.1* 的左侧显示。'
- en: '`User`: The user context menu. It is opened when you click your username on
    the header.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User`：用户上下文菜单。当你点击页眉上的用户名时，它会打开。'
- en: 'So, the preceding example checks the menu''s name and only adds items to the
    main menu. The following example code block adds a **Customer Relation Management**
    (**CRM**) menu item with two sub-menu items:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的示例检查了菜单的名称，并且只向主菜单添加了项目。下面的示例代码块添加了一个 **客户关系管理**（**CRM**）菜单项和两个子菜单项：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, we are getting an `IStringLocalizer` instance (`l`) to localize
    the display names of the menu items. `context.GetLocalizer` is a shortcut to getting
    localizer services. You can use `context.ServiceProvider` to resolve any service
    and apply your custom logic to build the menu.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们获取一个 `IStringLocalizer` 实例（`l`）以本地化菜单项的显示名称。`context.GetLocalizer`
    是获取本地化服务的一个快捷方式。你可以使用 `context.ServiceProvider` 来解析任何服务并将你的自定义逻辑应用于构建菜单。
- en: Every menu item should have a unique `name` (such as `MyProject.Crm.Customers`
    in this example) and a `displayName`. There are `url`, `icon`, `order`, and some
    other options available to control the appearance and behavior of the menu items.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每个菜单项都应该有一个唯一的 `name`（例如本例中的 `MyProject.Crm.Customers`）和一个 `displayName`。有 `url`、`icon`、`order`
    以及一些其他选项可用于控制菜单项的外观和行为。
- en: 'The basic theme renders the example menu, as shown in the following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 基本主题渲染了示例菜单，如下面的屏幕截图所示：
- en: '![Figure 12.5 – Menu items rendered by the Basic theme'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.5 – 由基本主题渲染的菜单项'
- en: '](img/Figure_12.05_B17287.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.05_B17287.jpg]'
- en: Figure 12.5 – Menu items rendered by the Basic theme
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – 由基本主题渲染的菜单项
- en: 'It is important to understand that the `ConfigureMenuAsync` method is called
    every time we render the menu. For a typical MVC/Razor Pages application, this
    method is called in every page request. In this way, you can dynamically shape
    the menu and conditionally add or remove items. You generally need to check permissions
    while adding the menu items, as shown in the following code block:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，每次我们渲染菜单时都会调用 `ConfigureMenuAsync` 方法。对于一个典型的 MVC/Razor Pages 应用程序，此方法在每次页面请求时都会被调用。这样，你可以动态地塑造菜单，并条件性地添加或删除项目。你通常需要在添加菜单项时检查权限，如下面的代码块所示：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`context.IsGrantedAsync` is a shortcut for checking the permissions for the
    current user with a permission name. If we want to resolve and use `IAuthorizationService`
    manually, we could rewrite the same code, as shown in the following code block:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`context.IsGrantedAsync` 是检查当前用户权限名称的快捷方式。如果我们想手动解析和使用 `IAuthorizationService`，我们可以重写相同的代码，如下面的代码块所示：'
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, I used `context.ServiceProvider` to resolve `IauthorizationService`.
    Then, I used its `IsGrantedAsync` method, just like in the previous example. You
    can safely resolve services from `context.ServiceProvider` and let ABP Framework
    release these services at the end of the menu's build process.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我使用了 `context.ServiceProvider` 来解析 `IauthorizationService`。然后，我像上一个示例一样使用了它的
    `IsGrantedAsync` 方法。你可以安全地从 `context.ServiceProvider` 解析服务，并让 ABP 框架在菜单构建过程的末尾释放这些服务。
- en: It is also possible to find existing menu items (added by the depending modules)
    in the `context.Menu.Items` collection to modify or remove them.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 `context.Menu.Items` 集合中找到现有的菜单项（由依赖模块添加），以修改或删除它们。
- en: In the next section, we will continue looking at Bootstrap tag helpers and learn
    how to render common Bootstrap components in a type-safe way.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续探讨 Bootstrap 标签辅助器，并学习如何以类型安全的方式渲染常见的 Bootstrap 组件。
- en: Working with Bootstrap tag helpers
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Bootstrap 标签辅助器
- en: Bootstrap is one of the most popular UI (HTML/CSS/JS) libraries in the world,
    and it is the fundamental UI framework that's used by all the ABP themes. As a
    benefit of using such a library as a standard library, we can build our UI pages
    and components based on Bootstrap and let the theme style them. In this way, our
    modules and even applications can be theme-independent and work with any ABP-compatible
    UI theme.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 是世界上最受欢迎的 UI（HTML/CSS/JS）库之一，它是所有 ABP 主题使用的根本 UI 框架。作为使用此类库作为标准库的好处，我们可以基于
    Bootstrap 构建我们的 UI 页面和组件，并让主题为其添加样式。这样，我们的模块甚至应用程序都可以与主题无关，并与任何 ABP 兼容的 UI 主题一起工作。
- en: 'Bootstrap is a well-documented and easy-to-use library. However, there are
    two problems while writing Bootstrap-based UI code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 是一个文档齐全且易于使用的库。然而，在编写基于 Bootstrap 的 UI 代码时存在两个问题：
- en: Some components require a lot of boilerplate code. Most parts of these codes
    are repetitive and tedious to write and maintain.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些组件需要大量的样板代码。这些代码的大部分都是重复的，编写和维护都很繁琐。
- en: Writing plain Bootstrap code in an MVC/Razor Pages web application is not very
    type-safe. We can make mistakes in class names and HTML structure that we can't
    catch at compile time.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 MVC/Razor Pages 网络应用程序中编写纯 Bootstrap 代码并不非常类型安全。我们可能会在类名和 HTML 结构中犯错误，这些错误在编译时无法捕获。
- en: ASP.NET Core MVC/Razor Pages has a *tag* *helper* system to define reusable
    components and use them as other HTML tags in our pages/views. ABP takes the power
    of tag helpers and provides a set of tag helper components for the Bootstrap library.
    In this way, we can build Bootstrap-based UI pages and components with less code
    and in a type-safe manner.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC/Razor Pages 有一个 *标签* *辅助器* 系统来定义可重用的组件，并将它们用作我们页面/视图中的其他 HTML
    标签。ABP 利用标签辅助器的力量，并为 Bootstrap 库提供了一套标签辅助器组件。这样，我们可以用更少的代码并以类型安全的方式构建基于 Bootstrap
    的 UI 页面和组件。
- en: 'It is still possible to write native Bootstrap HTML code with ABP Framework,
    and ABP''s Bootstrap tag helpers don''t cover Bootstrap 100%. However, we suggest
    using the Bootstrap tag helpers wherever possible. See the following example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ABP 框架仍然可以编写原生 Bootstrap HTML 代码，并且 ABP 的 Bootstrap 标签辅助器并不涵盖 Bootstrap 100%。然而，我们建议尽可能使用
    Bootstrap 标签辅助器。请参见以下示例：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, I used the `abp-button` tag helper to render a Bootstrap button. I used
    the `button-type` and `text` attributes with compile-time check support. This
    example code is rendered as follows at runtime:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用了 `abp-button` 标签辅助器来渲染 Bootstrap 按钮。我使用了具有编译时检查支持的 `button-type` 和 `text`
    属性。此示例代码在运行时渲染如下：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There are many Bootstrap tag helpers in ABP Framework, so I won''t explain
    all of them here. Please refer to ABP''s documentation to learn how to use them:
    [https://docs.abp.io/en/abp/latest/UI/AspNetCore/Tag-Helpers/Index](https://docs.abp.io/en/abp/latest/UI/AspNetCore/Tag-Helpers/Index).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 框架中有很多 Bootstrap 标签辅助工具，所以在这里我不会解释它们全部。请参考 ABP 的文档来学习如何使用它们：[https://docs.abp.io/en/abp/latest/UI/AspNetCore/Tag-Helpers/Index](https://docs.abp.io/en/abp/latest/UI/AspNetCore/Tag-Helpers/Index)。
- en: In the next two sections, we will use some of these Bootstrap tag helpers to
    build form items and open modals.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，我们将使用一些这些 Bootstrap 标签辅助工具来构建表单项和打开模态。
- en: Creating forms and implementing validation
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表单和实现验证
- en: ASP.NET Core provides a good infrastructure for preparing forms and submitting,
    validating, and processing them on the server side. However, it still requires
    writing some boilerplate and repeating code. ABP Framework simplifies working
    with forms by providing tag helpers and automating validation and localization
    wherever possible. Let's begin with how to render form elements using ABP's tag
    helpers.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 提供了良好的基础设施来准备表单，并在服务器端提交、验证和处理它们。然而，它仍然需要编写一些样板代码和重复的代码。ABP 框架通过提供标签辅助工具并在可能的情况下自动化验证和本地化来简化与表单的工作。让我们从如何使用
    ABP 的标签辅助工具渲染表单元素开始。
- en: Rendering form elements
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染表单元素
- en: The `abp-input` tag helper is used to render an appropriate HTML input element
    for a given property. It is better to show its usage in a complete example.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`abp-input` 标签辅助工具用于渲染给定属性的适当 HTML 输入元素。最好通过一个完整的示例来展示其用法。'
- en: 'Let''s assume that we need to build a form to create a new *movie* entity and
    have created a new Razor Page called `CreateMovie.cshtml`. First, let''s look
    at the code-behind file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要构建一个表单来创建一个新的 *电影* 实体，并且已经创建了一个名为 `CreateMovie.cshtml` 的新 Razor 页面。首先，让我们看看代码后置文件：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Page models are normally derived from the `PageModel` class. However, we are
    deriving from ABP's `AbpPageModel` base class since it provides some pre-injected
    services and helper methods. That's a simple page model class. Here, we are creating
    a new `MovieViewModel` instance in the `OnGet` method to bind it to the form elements.
    We also have an `OnPostAsync` method that we can use to process the posted form
    data. `[BindProperty]` tells ASP.NET Core to bind the post data to the `Movie`
    object.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 页面模型通常是从 `PageModel` 类派生的。然而，我们是从 ABP 的 `AbpPageModel` 基类派生的，因为它提供了一些预注入的服务和辅助方法。这是一个简单的页面模型类。在这里，我们在
    `OnGet` 方法中创建一个新的 `MovieViewModel` 实例，并将其绑定到表单元素。我们还有一个 `OnPostAsync` 方法，我们可以用它来处理提交的表单数据。`[BindProperty]`
    告诉 ASP.NET Core 将请求数据绑定到 `Movie` 对象。
- en: 'To explore this example, let''s look at the `MovieViewModel` class:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这个示例，让我们看看 `MovieViewModel` 类：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This object is used to render the form elements and bind the post data when
    the user submits the form. Notice that some properties have data annotation validation
    attributes to validate the values of these properties automatically. Here, the
    `Genre` property is an `enum`, as shown here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象用于渲染表单元素并在用户提交表单时绑定请求数据。请注意，一些属性具有数据注释验证属性，可以自动验证这些属性的值。在这里，`Genre` 属性是一个
    `enum`，如下所示：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, we can switch to the view part and try to render a form to get the movie
    information from the user.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以切换到视图部分，尝试渲染一个表单来获取用户的电影信息。
- en: 'First, I will you show how we can do this without ABP Framework to understand
    the benefits of using ABP Framework. First, we must open a `form` element, as
    shown in the following code block:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将向您展示在没有 ABP 框架的情况下如何做到这一点，以便理解使用 ABP 框架的好处。首先，我们必须打开一个 `form` 元素，如下面的代码块所示：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the `form` block, we write code for each `form` element, and then we add
    a `submit` button to post the form. Showing the full code of `form` would be too
    long for this book, so I will only show the code that is necessary for rendering
    the input element for the `Movie.Name` property:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `form` 块中，我们为每个 `form` 元素编写代码，然后添加一个 `submit` 按钮来提交表单。展示完整的 `form` 代码对于这本书来说会太长，所以我会只展示渲染
    `Movie.Name` 属性输入元素的必要代码：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding code block should seem very familiar to you if you have ever
    created a form with ASP.NET Core Razor Pages/MVC and Bootstrap. It puts a `label`,
    the actual input element, and a validation message area by wrapping them with
    a `form-group`. The following screenshot shows the rendered form:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经使用 ASP.NET Core Razor Pages/MVC 和 Bootstrap 创建过表单，前面的代码块应该非常熟悉。它通过将它们包裹在
    `form-group` 中来放置 `label`、实际的输入元素和验证消息区域。以下截图显示了渲染的表单：
- en: '![Figure 12.6 – A simple form with a single text input'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.6 – 带有一个单行文本输入的简单表单'
- en: '](img/Figure_12.06_B17287.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.06 – B17287.jpg](img/Figure_12.06_B17287.jpg)'
- en: Figure 12.6 – A simple form with a single text input
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – 带有一个文本输入的简单表单
- en: 'The form currently contains only a single piece of text input for the `Name`
    property. You could write similar code for each property of the `Movie` class,
    which would result in large and repetitive code. Let''s see how we can render
    the same input using ABP Framework''s `abp-input` tag helper:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当前表单只为 `Name` 属性包含一个单独的文本输入。你可以为 `Movie` 类的每个属性编写类似的代码，这将导致代码庞大且重复。让我们看看如何使用
    ABP 框架的 `abp-input` 标签助手渲染相同的输入：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'That''s pretty easy. Now, we can render all the form elements. The following
    is the finalized code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。现在，我们可以渲染所有表单元素。以下是将最终代码：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding code block is dramatically shorter compared to the standard Bootstrap
    form code. I used the `abp-select` tag helper for the `Genre` property. It understands
    that `Genre` is an `enum` and creates the dropdown element using the `enum` members.
    The following is the rendered form:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准的 Bootstrap 表单代码相比，前面的代码块显著更短。我使用了 `abp-select` 标签助手来处理 `Genre` 属性。它理解 `Genre`
    是一个 `enum`，并使用 `enum` 成员创建下拉元素。以下是被渲染的表单：
- en: '![Figure 12.7 – Full form for creating a new movie'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.7 – 创建新电影的完整表单'
- en: '](img/Figure_12.07_B17287.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.07 – B17287.jpg](img/Figure_12.07_B17287.jpg)'
- en: Figure 12.7 – Full form for creating a new movie
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – 创建新电影的完整表单
- en: ABP automatically adds ***** near the label of required form fields. It reads
    the types and attributes of the class properties and determines the form fields.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 自动在必填表单字段的标签附近添加 *****。它读取类属性的类型和属性，并确定表单字段。
- en: 'If all you want to do is render the input elements in order, you can replace
    the last code block with the following one:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想按顺序渲染输入元素，你可以将最后一个代码块替换为以下代码：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `abp-dynamic-form` tag helper gets a model and creates the entire form automatically!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`abp-dynamic-form` 标签助手获取一个模型并自动创建整个表单！'
- en: The `abp-input`, `abp-select`, and `abp-radio` tag helpers are mapped to a class
    property and render the corresponding UI element. You can use them if you want
    to control the layout of the form and place custom HTML elements between the form
    controls. On the other hand, `abp-dynamic-form` makes creating the form super
    simple while you have less control over the form's layout. However you create
    the form, ABP automates the validation and localization process for you, as I
    will explain in the next few sections.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`abp-input`、`abp-select` 和 `abp-radio` 标签助手映射到类属性并渲染相应的 UI 元素。如果你想控制表单布局并在表单控件之间放置自定义
    HTML 元素，可以使用它们。另一方面，`abp-dynamic-form` 在你较少控制表单布局的情况下使创建表单变得非常简单。无论你如何创建表单，ABP
    都会为你自动化验证和本地化过程，我将在接下来的几节中解释。'
- en: Validating user inputs
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证用户输入
- en: 'If you try to submit the form without filling in the required fields, the form
    won''t be submitted to the server, and an error message will be shown for each
    invalid form element. The following screenshot shows the error message when you
    leave the `Name` property empty and submit the form:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试不填写必填字段提交表单，表单将不会提交到服务器，并且每个无效表单元素都会显示错误消息。以下截图显示了当你留空 `Name` 属性并提交表单时的错误消息：
- en: '![Figure 12.8 – Invalid user input'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.8 – 无效的用户输入'
- en: '](img/Figure_12.08_B17287.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.08 – B17287.jpg](img/Figure_12.08_B17287.jpg)'
- en: Figure 12.8 – Invalid user input
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 – 无效的用户输入
- en: Client-side validation is automatically done based on the data annotation attributes
    in the `MovieViewModel.Name` property. So, you don't need to write any validation
    code for the standard checks. Users can't submit the form until all the fields
    are valid.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端验证是自动基于 `MovieViewModel.Name` 属性中的数据注释属性完成的。因此，你不需要为标准检查编写任何验证代码。用户必须确保所有字段有效后才能提交表单。
- en: 'Client-side validation is just for the user experience. It would be easy to
    bypass the client-side validation and submit an invalid form to the server (by
    manipulating or disabling the JavaScript code in the browser''s developer tools).
    So, you should always validate the user input on the server side, which should
    be done in the `OnPostAsync` method of the page model class. The following code
    block shows the common pattern that''s used while handling a form post:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端验证只是为了用户体验。很容易绕过客户端验证并将无效的表单提交到服务器（通过在浏览器的开发者工具中操作或禁用 JavaScript 代码）。因此，你应该始终在服务器端验证用户输入，这应该在页面模型类的
    `OnPostAsync` 方法中完成。以下代码块显示了处理表单提交时使用的常见模式：
- en: '[PRE36]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`ModelState.IsValid` returns `false` if any form field is invalid. This is
    a standard feature of ASP.NET Core. You should always process the input in such
    an `if` statement. Optionally, you can have logic in the `else` statement. In
    this example, I used ABP''s `Alerts` feature to show a client-side alert message
    to the user. The following screenshot shows the result of submitting the invalid
    form:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何表单字段无效，`ModelState.IsValid` 返回 `false`。这是 ASP.NET Core 的一个标准功能。你应该始终在 `if`
    语句中处理输入。可选地，你可以在 `else` 语句中添加逻辑。在这个例子中，我使用了 ABP 的 `Alerts` 功能向用户显示客户端警告消息。以下截图显示了提交无效表单的结果：
- en: '![Figure 12.9 – Invalid form result from the server'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.9 – 服务器端无效表单结果'
- en: '](img/Figure_12.09_B17287.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_12.09_B17287.jpg)'
- en: Figure 12.9 – Invalid form result from the server
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 – 服务器端无效表单结果
- en: 'If you look at the validation error message under the `IValidatableObject`
    interface for the `MovieViewModel` class, as shown in the following code block:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `MovieViewModel` 类的 `IValidatableObject` 接口下的验证错误消息，如下面的代码块所示：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: I'm performing complex custom validation logic in the `Validate` method. You
    can refer to the *Validating user inputs* section in [*Chapter 7*](B17287_07_Epub_AM.xhtml#_idTextAnchor213),
    *Exploring Cross-Cutting Concerns*, to learn more about server-side validation.
    Here, we should understand that we can use custom logic on the server and show
    validation messages on the client side.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 `Validate` 方法中执行复杂的自定义验证逻辑。你可以参考 [*第 7 章*](B17287_07_Epub_AM.xhtml#_idTextAnchor213)，*探索横切关注点*中的
    *验证用户输入* 部分，了解更多关于服务器端验证的信息。在这里，我们应该理解我们可以在服务器端使用自定义逻辑，并在客户端显示验证消息。
- en: In the next section, we will learn how to localize validation errors, as well
    as form labels.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何本地化验证错误以及表单标签。
- en: Localizing forms
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地化表单
- en: 'ABP Framework automatically localizes the validation error messages based on
    the current language. Try to switch to another language and submit the form without
    providing a movie name. The following screenshot shows this for the Turkish language:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 框架根据当前语言自动本地化验证错误消息。尝试切换到另一种语言，并提交表单而不提供电影名称。以下截图显示了土耳其语言的情况：
- en: '![Figure 12.10 – Auto-localized validation error messages'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.10 – 自动本地化的验证错误消息'
- en: '](img/Figure_12.10_B17287.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_12.10_B17287.jpg)'
- en: Figure 12.10 – Auto-localized validation error messages
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10 – 自动本地化的验证错误消息
- en: The error text has changed. However, you can still see **Name** as the field
    name because that's our custom field name, and we haven't localized it yet.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 错误文本已更改。然而，你仍然可以看到 **名称** 作为字段名称，因为这是我们自定义的字段名称，我们还没有对其进行本地化。
- en: 'ABP provides a convention-based localization system for the form fields. You
    just define a localization entry in your localization JSON file with the key formatted
    as `DisplayName:<property-name>`. I can add the following lines to the `en.json`
    file (in the *Domain.Shared* project) to localize all the fields of the movie
    creation form:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 为表单字段提供了一个基于约定的本地化系统。你只需在你的本地化 JSON 文件中定义一个本地化条目，键的格式为 `DisplayName:<属性名>`。我可以在
    *Domain.Shared* 项目中的 `en.json` 文件中添加以下行以本地化电影创建表单的所有字段：
- en: '[PRE38]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, I can localize these in the Turkish language with the following entries
    in the `tr.json` file:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我可以在 `tr.json` 文件中使用以下条目将这些内容本地化为土耳其语：
- en: '[PRE39]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we have a localized label and a more localized validation error message:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个本地化的标签和一个更本地化的验证错误消息：
- en: '![Figure 12.11 – Fully localized validation error message and the field label'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.11 – 完全本地化的验证错误消息和字段标签'
- en: '](img/Figure_12.11_B17287.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_12.11_B17287.jpg)'
- en: Figure 12.11 – Fully localized validation error message and the field label
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11 – 完全本地化的验证错误消息和字段标签
- en: 'Adding the `DisplayName:` prefix to the property name is a suggested convention
    for the `form` fields, but actually, it is not required. If ABP can''t find the
    `DisplayName:Price` entry, it will search an entry with the `Price` key, without
    any prefix. If you want to specify the localization key for a property, you can
    add the `[DisplayName]` attribute on top of the property, as shown in the following
    example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `DisplayName:` 前缀添加到属性名是 `form` 字段的建议约定，但实际上并非必需。如果 ABP 找不到 `DisplayName:Price`
    条目，它将搜索不带前缀的 `Price` 键的条目。如果你想指定属性的本地化键，你可以在属性顶部添加 `[DisplayName]` 属性，如下面的示例所示：
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With this setup, ABP will try to localize the field name using the `"MoviePrice"`
    key.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设置，ABP 将尝试使用 `"MoviePrice"` 键来本地化字段名称。
- en: The `abp-select` tag localizes the items in the dropdown for `enum` types by
    conventions. You can add entries to your localization file, such as `<enum-type>.<enum-member>`.
    For the `Action` member of the `Genre` enum type, we can add a localization entry
    with the `Genre.Action` key. It falls back to the `Action` key if the `Genre.Action`
    key is not found.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`abp-select` 标签根据约定将 `enum` 类型的下拉列表项本地化。你可以在本地化文件中添加条目，例如 `<enum-type>.<enum-member>`。对于
    `Genre` 枚举类型的 `Action` 成员，我们可以添加一个带有 `Genre.Action` 键的本地化条目。如果找不到 `Genre.Action`
    键，它将回退到 `Action` 键。'
- en: In the next section, we will discuss how to convert a standard form into a fully
    AJAX form.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何将标准表单转换为完全的 AJAX 表单。
- en: Implementing AJAX forms
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 AJAX 表单
- en: When the user submits a standard form, a full-page post is performed and the
    server re-renders the entire page. An alternative approach could be posting the
    form as an AJAX request and handling the response in JavaScript code. This approach
    is much faster than the regular post request since the browser doesn't need to
    reload the whole page and all the resources of the page. It is also a better user
    experience in many cases since you can show some animations on the waiting time.
    Also, in this way, you don't lose the page's state and can perform smart actions
    in your JavaScript code.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户提交标准表单时，会执行全页面的 POST 操作，服务器重新渲染整个页面。另一种方法是将表单作为 AJAX 请求发送，并在 JavaScript 代码中处理响应。这种方法比常规的
    POST 请求快得多，因为浏览器不需要重新加载整个页面和页面的所有资源。在许多情况下，这也能提供更好的用户体验，因为你可以显示一些等待时的动画。此外，这样你不会丢失页面的状态，可以在
    JavaScript 代码中执行智能操作。
- en: You can handle all the AJAX stuff manually, but ABP Framework provides built-in
    ways for such common patterns. You can add the `data-ajaxForm="true"` attribute
    to any `form` element (including the `abp-dynamic-form` element) to make it posted
    through an AJAX request.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以手动处理所有的 AJAX 事务，但 ABP 框架提供了内置的方式来处理这些常见模式。你可以在任何 `form` 元素（包括 `abp-dynamic-form`
    元素）上添加 `data-ajaxForm="true"` 属性，使其通过 AJAX 请求发送。
- en: 'The following example adds the AJAX feature to `abp-dynamic-form`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例为 `abp-dynamic-form` 添加了 AJAX 功能：
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When we convert a form into an AJAX form, the post handler on the server side
    should be implemented properly. The following code block shows a common pattern
    to implement the post handler:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将表单转换为 AJAX 表单时，服务器端应该正确实现 POST 处理器。以下代码块展示了实现 POST 处理器的常见模式：
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first line validates the user input and throws `AbpValidationException`
    if the input model is not valid. The `ValidateModel` method comes from the base
    `AbpPageModel` class. If you don't want to use it, you can check `if (ModelState.IsValid)`
    and take any action you need. If the form is valid, you normally save the new
    movie to a database. Finally, you can return the resulting data to the client.
    We don't need to return a response for this example, so a `NoContent` result is
    fine.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行验证用户输入，如果输入模型无效，则抛出 `AbpValidationException`。`ValidateModel` 方法来自基类 `AbpPageModel`。如果你不想使用它，你可以检查
    `if (ModelState.IsValid)` 并执行所需的任何操作。如果表单有效，你通常会将新电影保存到数据库中。最后，你可以将结果数据返回给客户端。对于这个例子，我们不需要返回响应，所以
    `NoContent` 结果是合适的。
- en: 'When you convert a form into an AJAX form, you typically want to take action
    when the form is successfully submitted. The following example handles the `abp-ajax-success`
    event of the form:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将表单转换为 AJAX 表单时，你通常希望在表单成功提交时采取行动。以下示例处理了表单的 `abp-ajax-success` 事件：
- en: '[PRE43]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this example, I registered a callback function for the `abp-ajax-success`
    event of the form. In this callback, you can do anything you need. For example,
    I used the `slideUp` JQuery function to hide the form, then used ABP's success
    UI message. We will return to the `abp.message` API in the *Using the JavaScript
    API* section of this chapter.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我为表单的 `abp-ajax-success` 事件注册了一个回调函数。在这个回调中，你可以执行任何需要的操作。例如，我使用了 `slideUp`
    JQuery 函数来隐藏表单，然后使用了 ABP 的成功 UI 消息。我们将在本章的 *使用 JavaScript API* 部分回到 `abp.message`
    API。
- en: 'Exception handling logic is different for AJAX requests. ABP handles all exceptions,
    returns a proper JSON response to the client, and then automatically handles the
    error on the client side. For example, suppose the form has a validation error
    that''s been determined on the server side. In this case, the server returns a
    validation error message, and the client shows a message box, as shown in the
    following screenshot:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AJAX请求，异常处理逻辑是不同的。ABP处理所有异常，向客户端返回适当的JSON响应，然后自动在客户端处理错误。例如，假设表单有一个在服务器端确定的验证错误。在这种情况下，服务器返回一个验证错误消息，客户端显示一个消息框，如下面的截图所示：
- en: '![Figure 12.12 – Server-side validation errors on the AJAX form submit'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.12 – AJAX表单提交时的服务器端验证错误'
- en: '](img/Figure_12.12_B17287.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.12_B17287.jpg](img/Figure_12.12_B17287.jpg)'
- en: Figure 12.12 – Server-side validation errors on the AJAX form submit
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 – AJAX表单提交时的服务器端验证错误
- en: The message box is shown in any exception, including your custom exceptions
    and `UserFriendlyException`. Go to the *Exception handling* section of [*Chapter
    7*](B17287_07_Epub_AM.xhtml#_idTextAnchor213), *Exploring Cross-Cutting Concerns*,
    to learn more about the exception handling system.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 消息框在任何异常中都会显示，包括你的自定义异常和`UserFriendlyException`。前往[*第7章*](B17287_07_Epub_AM.xhtml#_idTextAnchor213)的*异常处理*部分，*探索横切关注点*，以了解更多关于异常处理系统信息。
- en: In addition to converting the form into an AJAX form and handling exceptions,
    ABP also prevents double-clicking on the `data-busy-text` attribute on the **Submit**
    button to use another piece of text.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将表单转换为AJAX表单和处理异常之外，ABP还防止在**提交**按钮的`data-busy-text`属性上双击以使用另一段文本。
- en: In the next section, we will learn how ABP Framework helps us while working
    with modal dialogs.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习ABP框架如何帮助我们处理模态对话框。
- en: Working with modals
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与模态对话框一起工作
- en: A modal is one of the essential components when you want to create interactive
    user interfaces. It provides a convenient way to get a response from the user
    or show some information without changing the current page layout.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要创建交互式用户界面时，模态对话框是基本组件之一。它提供了一种方便的方式，可以在不改变当前页面布局的情况下获取用户的响应或显示一些信息。
- en: Bootstrap has a modal component, but it requires some boilerplate code. ABP
    Framework provides the `abp-modal` tag helper to render a modal component, which
    simplifies the modal's usage in most use cases. Another problem with modals is
    placing the modal code inside the page that opens the modal, which makes the modal
    hard to reuse. ABP provides a modal API on the JavaScript side to dynamically
    load and control these modals. It also works well with forms inside modals. Let's
    begin with the simplest usage.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap有一个模态组件，但它需要一些样板代码。ABP框架提供了`abp-modal`标签助手来渲染模态组件，这简化了在大多数用例中模态的使用。模态的另一个问题是将模态代码放在打开模态的页面中，这使得模态难以重用。ABP在JavaScript端提供了一个模态API，用于动态加载和控制这些模态。它也与模态内的表单很好地协同工作。让我们从最简单的用法开始。
- en: Understanding the basics of modals
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解模态的基础知识
- en: 'ABP suggests defining modals as separate Razor Pages (or views if you are using
    the MVC pattern). So, as the first step, we should create a new Razor Page. Let''s
    assume that we''ve created a new Razor Page called `MySimpleModal.cshtml` under
    the `Pages` folder. The code-behind file is simple:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ABP建议将模态定义为独立的Razor页面（或者如果你使用MVC模式，则是视图）。因此，作为第一步，我们应该创建一个新的Razor页面。假设我们在`Pages`文件夹下创建了一个名为`MySimpleModal.cshtml`的新Razor页面。后端代码很简单：
- en: '[PRE44]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We just have a `Message` property being shown inside the modal dialog. Let''s
    see the view side:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模态对话框中只显示一个`Message`属性。让我们看看视图方面：
- en: '[PRE45]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `Layout = null` statement is critical here. Because this page is loaded
    with an AJAX request, the result should only contain the modal's content, not
    the standard layout. `abp-modal` is the main tag helper that renders the HTML
    of the modal dialog. `abp-modal-header`, `abp-modal-body`, and `abp-modal-footer`
    are the main parts of the modal and have different options. The modal body is
    very simple in this example; it just shows `Message` on the model.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`Layout = null`语句是关键的。因为这个页面是通过AJAX请求加载的，结果应该只包含模态的内容，而不是标准布局。`abp-modal`是渲染模态对话框HTML的主要标签助手。`abp-modal-header`、`abp-modal-body`和`abp-modal-footer`是模态的主要部分，并且有不同的选项。在这个例子中，模态体非常简单；它只是在模型上显示`Message`。
- en: 'We''ve created the modal, but we should create a way to open it. ABP provides
    the `ModalManager` API on the JavaScript side to control a modal. Here, we need
    to create a `ModalManager` object on the page where we want to open the modal:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了模态，但我们应该创建一种打开它的方法。ABP 在 JavaScript 端提供了 `ModalManager` API 来控制模态。在这里，我们需要在想要打开模态的页面上创建一个
    `ModalManager` 对象：
- en: '[PRE46]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`abp.ModalManager` has a few options, but the most basic is `viewUrl`, which
    indicates the URL where the modal content will be loaded. Once we have a `ModalManager`
    instance, we can call its `open` method to open the modal:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`abp.ModalManager` 有几个选项，但最基本的是 `viewUrl`，它指示模态内容将被加载的 URL。一旦我们有一个 `ModalManager`
    实例，我们就可以调用它的 `open` 方法来打开模态：'
- en: '[PRE47]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This example assumes there is a button with an ID of `Button1` on the page.
    We are opening the modal when the user clicks the button. The following screenshot
    shows the opened modal:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例假设页面上有一个 ID 为 `Button1` 的按钮。当用户点击按钮时，我们将打开模态。以下截图显示了打开的模态：
- en: '![Figure 12.13 – A simple modal dialog box'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.13 – 一个简单的模态对话框](img/Figure_12.13_B17287.jpg)'
- en: '](img/Figure_12.13_B17287.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.13 – 一个简单的模态对话框](img/Figure_12.13_B17287.jpg)'
- en: Figure 12.13 – A simple modal dialog box
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.13 – 一个简单的模态对话框
- en: 'Typically, we create dynamic content in a modal, so we need to pass some arguments
    while opening the modal dialog box. To do this, you can pass an object to the
    `open` method that contains the modal arguments, as shown in the following example:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们在模态中创建动态内容，因此需要在打开模态对话框时传递一些参数。为此，您可以将一个包含模态参数的对象传递给 `open` 方法，如下例所示：
- en: '[PRE48]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, we passed a `productId` argument to the modal, so it may show details
    of the given product. You can add the same argument to the `OnGet` method of the
    `MySimpleModalModel` class to obtain the value and process inside the method:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向模态传递了一个 `productId` 参数，因此它可能会显示给定产品的详细信息。您可以将相同的参数添加到 `MySimpleModalModel`
    类的 `OnGet` 方法中，以获取值并在方法内部进行处理：
- en: '[PRE49]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You can get the product information from the database and render the product
    details in the modal body.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从数据库中获取产品信息，并在模态体中渲染产品详情。
- en: In the next section, we will learn how to place a form inside a modal to get
    data from the user.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何将表单放置在模态中，以从用户那里获取数据。
- en: Working with forms inside modals
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模态中处理表单
- en: 'Modals are widely used to show a form to users. ABP''s ModalManager API gracefully
    handles some common tasks for you:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 模态被广泛用于向用户显示表单。ABP 的 `ModalManager` API 优雅地为您处理一些常见任务：
- en: It focuses on the first input of the form.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将焦点放在表单的第一个输入上。
- en: It triggers a validation check when you press the *Enter* key or click the **Save**
    button. It doesn't allow you to submit the form unless the form is fully valid.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您按下 *Enter* 键或点击 **保存** 按钮时，它会触发验证检查。除非表单完全有效，否则不允许提交表单。
- en: It submits the form via an AJAX request, disables the modal buttons, and shows
    a progressing icon until the save operation is complete.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过 AJAX 请求提交表单，禁用模态按钮，并在保存操作完成前显示进度图标。
- en: If you've entered some data and click the **Cancel** button or close the modal,
    it warns you about unsaved changes.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您已输入一些数据并点击 **取消** 按钮或关闭模态，它会警告您有关未保存的更改。
- en: 'Let''s assume that we want to show a modal dialog to create a new movie and
    we''ve created a new Razor Page called `ModalWithForm.cshtml`. The code-behind
    file is similar to what we had in the *Implementing AJAX forms* section:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要显示一个用于创建新电影的模态对话框，并且我们已经创建了一个名为 `ModalWithForm.cshtml` 的新 Razor 页面。代码隐藏文件与我们在
    *实现 AJAX 表单* 部分中看到的内容类似：
- en: '[PRE50]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `OnPostAsync` method validates the user input first. If the form is not
    valid, an exception is thrown and handled by ABP Framework on the server side
    and the client side. You can return a response to the client, but we are returning
    a `NoContent` response in this example.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnPostAsync` 方法首先验证用户输入。如果表单无效，将抛出异常，并由 ABP 框架在服务器端和客户端处理。您可以向客户端返回一个响应，但在此示例中，我们返回一个
    `NoContent` 响应。'
- en: 'The view side of the modal is a bit different since we mix a form with a modal:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们混合了表单和模态，模态的视图侧略有不同：
- en: '[PRE51]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `abp-modal` tag is wrapped by a `form` element. We don't put the `form`
    tag inside the `abp-modal-body` element because the `form`. So, as a solution,
    we are placing `form` as the topmost element in this view. The rest of the code
    block should be familiar; we use ABP input tag helpers to render the form elements.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`abp-modal` 标签被 `form` 元素包裹。我们不会将 `form` 标签放在 `abp-modal-body` 元素内部，因为 `form`。因此，作为解决方案，我们将
    `form` 作为此视图的最高级元素放置。其余的代码块应该很熟悉；我们使用 ABP 输入标签助手来渲染表单元素。'
- en: 'Now, we can open the modal in our JavaScript code:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的 JavaScript 代码中打开模态：
- en: '[PRE52]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The opened dialog is shown in the following screenshot:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 打开的对话框如下截图所示：
- en: '![Figure 12.14 – A form inside a modal'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.14 – 模态内的表单'
- en: '](img/Figure_12.14_B17287.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.14_B17287.jpg)'
- en: Figure 12.14 – A form inside a modal
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.14 – 模态内的表单
- en: 'It is also possible to use the `abp-dynamic-form` tag helper within a modal.
    We could rewrite the modal''s view like so:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在模态内也可以使用 `abp-dynamic-form` 标签助手。我们可以像这样重写模态的视图：
- en: '[PRE53]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, I wrapped `abp-modal` with an `abp-dynamic-form` element, just like in
    the previous section. The main point of this example is that I used the `<abp-form-content/>`
    tag helper in the `abp-modal-body` element. `abp-form-content` is an optional
    tag helper that is used to place the form inputs of the `abp-dynamic-form` tag
    helper in the desired place.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我像在上一节中一样将 `abp-modal` 包裹在 `abp-dynamic-form` 元素中。这个示例的主要点是我在 `abp-modal-body`
    元素中使用了 `<abp-form-content/>` 标签助手。`abp-form-content` 是一个可选的标签助手，用于将 `abp-dynamic-form`
    标签助手的表单输入放置在所需的位置。
- en: 'You typically want to take action once the modal form has been saved. For this,
    you can register a callback function to the `onResult` event of `ModalManager`,
    as shown in the following code block:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你希望在模态表单保存后采取行动。为此，你可以将回调函数注册到 `ModalManager` 的 `onResult` 事件，如下面的代码块所示：
- en: '[PRE54]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`data.responseText` will be the data if the server sends any result. For example,
    you can return a `Content` response from the `OnPostAsync` method, as shown in
    the following example:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器发送任何结果，`data.responseText` 将是数据。例如，你可以从 `OnPostAsync` 方法返回一个 `Content`
    响应，如下面的示例所示：
- en: '[PRE55]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ABP simplifies all these common tasks. Otherwise, you would write a lot of boilerplate
    code.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 简化了所有这些常见任务。否则，你将需要编写大量的样板代码。
- en: In the next section, we will learn how to add client-side logic to our modal
    dialogs.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何向我们的模态对话框添加客户端逻辑。
- en: Adding JavaScript for modals
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为模态添加 JavaScript
- en: If your modal needs some advanced client-side logic, you may want to write some
    custom JavaScript code for your modal. You can write your JavaScript code on the
    page where you open the modal, but that is not very modular and reusable. It is
    good to write your modal's JavaScript code in a separate file, ideally near the
    `.cshtml` file of the modal (remember that ABP allows you to place JavaScript
    files under the `Pages` folder).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的模态需要一些高级客户端逻辑，你可能需要为你的模态编写一些自定义 JavaScript 代码。你可以在打开模态的页面中编写你的 JavaScript
    代码，但这不是非常模块化和可重用的。最好将你的模态 JavaScript 代码写在单独的文件中，理想情况下靠近模态的 `.cshtml` 文件（记住 ABP
    允许你将 JavaScript 文件放在 `Pages` 文件夹下）。
- en: 'For this, we can create a new JavaScript file and define a function in the
    `abp.modals` namespace, as shown in the following code:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了此，我们可以创建一个新的 JavaScript 文件并在 `abp.modals` 命名空间中定义一个函数，如下面的代码所示：
- en: '[PRE56]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Once we have created such a JavaScript class, we can associate it with the
    modal while creating the `ModalManager` instance:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了这样的 JavaScript 类，我们可以在创建 `ModalManager` 实例时将其与模态关联起来：
- en: '[PRE57]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`ModalManager` creates a new instance of the `abp.modals.MovieCreation` class
    for every time you open the modal and calls the `initModal` function if you define
    it. The `initModal` function takes two parameters. The first one is the `ModalManager`
    instance that''s associated with the modal so that you can use its functions.
    The second parameter is the arguments that you passed to the `open` function while
    opening the modal.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModalManager` 在每次打开模态时都会创建 `abp.modals.MovieCreation` 类的新实例，如果你定义了 `initModal`
    函数，它将调用该函数。`initModal` 函数接受两个参数。第一个参数是与模态关联的 `ModalManager` 实例，这样你就可以使用它的函数。第二个参数是你打开模态时传递给
    `open` 函数的参数。'
- en: The `initModal` function is a perfect place to prepare the modal's content and
    register some callbacks to the events of the modal components. In the preceding
    example, I got the modal instance and a JQuery object, found the `Movie.PreOrder`
    checkbox, and registered its `change` callback so that I'm informed when the user
    checks it.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`initModal` 函数是准备模态内容和将一些回调注册到模态组件事件的完美位置。在先前的示例中，我获取了模态实例和一个 JQuery 对象，找到了
    `Movie.PreOrder` 复选框，并注册了其 `change` 回调，以便在用户勾选它时得到通知。'
- en: 'This example still doesn''t work yet since we haven''t added the JavaScript
    file to the page. There are two ways to add it to the page:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例仍然不起作用，因为我们还没有将 JavaScript 文件添加到页面中。有两种方法可以将它添加到页面中：
- en: We can use the `abp-script` tag to include the modal's JavaScript file in the
    page where we open the modal.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `abp-script` 标签将模态的 JavaScript 文件包含在我们打开模态的页面中。
- en: We can set up `ModalManager` so that it lazy loads the JavaScript file.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以设置 `ModalManager` 以使其懒加载 JavaScript 文件。
- en: 'The first option is straightforward – just include the following line in the
    page where you want to use the modal:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项很简单——只需在你想使用模态的页面中包含以下行：
- en: '[PRE58]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If we want to lazy load the modal''s script, we can configure `ModalManager`
    like so:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想懒加载模态的脚本，我们可以这样配置`ModalManager`：
- en: '[PRE59]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, I added the `scriptUrl` option as the URL of the modal's JavaScript file.
    `ModalManager` lazy loads the JavaScript file the first time you open the modal.
    The script is not loaded again if you open the modal a second time (without refreshing
    the whole page).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我添加了`scriptUrl`选项作为模态的JavaScript文件的URL。`ModalManager`在第一次打开模态时懒加载JavaScript文件。如果你第二次打开模态（不刷新整个页面），则不会再次加载脚本。
- en: In this section, we learned how to work with forms, validation, and modals.
    They are essential parts of a typical web application. In the next section, we
    will learn about some useful JavaScript APIs that we need in every application.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何处理表单、验证和模态。它们是典型Web应用的必要部分。在下一节中，我们将了解一些在每项应用中都需要的有用JavaScript API。
- en: Using the JavaScript API
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript API
- en: In this section, we will explore some useful client-side APIs of ABP Framework.
    Some of these APIs provide simple ways to use server-side defined features such
    as authentication and localization, while others provide solutions for common
    UI patterns, such as message boxes and notifications.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索ABP框架的一些有用的客户端API。其中一些API提供了使用服务器端定义的功能（如身份验证和本地化）的简单方法，而其他API则提供了常见UI模式（如消息框和通知）的解决方案。
- en: All the client-side JavaScript APIs are global objects and functions that are
    declared under the `abp` namespace. Let's begin with accessing the current user's
    information in your JavaScript code.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 所有客户端JavaScript API都是声明在`abp`命名空间下的全局对象和函数。让我们从在你的JavaScript代码中访问当前用户信息开始。
- en: Accessing the current user
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问当前用户
- en: 'We are using the `ICurrentUser` service on the server side to get information
    about the currently logged-in user. In the JavaScript code, we can use the global
    `abp.currentUser` object, as shown here:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在服务器端使用`ICurrentUser`服务来获取当前登录用户的信息。在JavaScript代码中，我们可以使用全局的`abp.currentUser`对象，如下所示：
- en: '[PRE60]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'By doing this, we can get the user''s ID and username. The following JSON object
    is an example of the `abp.currentUser` object:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们可以获取用户的ID和用户名。以下JSON对象是`abp.currentUser`对象的示例：
- en: '[PRE61]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If the current user has not logged in yet, all these values will be `null` or
    `false`, as you would expect. The `abp.currentUser` object provides an easy way
    to get information about the current user. In the next section, we will learn
    how to check the permissions of the current user.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前用户尚未登录，所有这些值都将为`null`或`false`，正如你所期望的那样。`abp.currentUser`对象提供了一种简单的方法来获取有关当前用户的信息。在下一节中，我们将学习如何检查当前用户的权限。
- en: Checking user permissions
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查用户权限
- en: ABP's authorization and permission management system is a powerful way to define
    permissions and check them at runtime for the current user. Checking these permissions
    in your JavaScript code is effortless using the `abp.auth` API.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ABP的授权和权限管理系统是一种强大的方式，可以在运行时定义权限并检查当前用户的权限。使用`abp.auth` API在你的JavaScript代码中检查这些权限非常容易。
- en: 'The following example checks if the current user has the `DeleteProduct` permission:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例检查当前用户是否有`DeleteProduct`权限：
- en: '[PRE62]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`abp.auth.isGranted` returns `true` if the current user has given permission
    or a policy. If the user doesn''t have permission, we show a warning message using
    the ABP message API, which will be explained in the *Showing message boxes* section
    later in this chapter.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`abp.auth.isGranted`如果当前用户已授予权限或策略，则返回`true`。如果用户没有权限，我们将使用ABP消息API显示警告消息，这将在本章后面的*显示消息框*部分进行解释。'
- en: While these APIs are rarely needed, you can use the `abp.auth.policies` object
    when you need to get a list of all the available permissions/policies and the
    `abp.auth.grantedPolicies` object if you need to get a list of all the granted
    permissions/policies for the current user.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些API很少需要，但在你需要获取所有可用权限/策略的列表时，可以使用`abp.auth.policies`对象；如果你需要获取当前用户所有已授予权限/策略的列表，可以使用`abp.auth.grantedPolicies`对象。
- en: Hiding UI Parts Based on Permissions
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 基于权限隐藏UI部分
- en: A typical use case for client-side permission checking is to hide some UI parts
    (such as action buttons) based on the user's permissions. While the `abp.auth`
    API provides a dynamic way to do that, I suggest using the standard `IAuthorizationService`
    on your Razor Pages/views to conditionally render the UI elements wherever possible.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端权限检查的一个典型用例是根据用户的权限隐藏一些UI部分（例如操作按钮）。虽然`abp.auth` API提供了动态的方式来做到这一点，但我建议尽可能在你的Razor
    Pages/views中使用标准的`IAuthorizationService`来条件性地渲染UI元素。
- en: Note that checking permissions on the client side is just for the user experience
    and that it doesn't guarantee security. You should always check the same permission
    on the server side.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在客户端检查权限只是为了用户体验，并不能保证安全性。你应该始终在服务器端检查相同的权限。
- en: In the next section, we will learn how to check the feature rights of the current
    tenant in a multi-tenant application.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在多租户应用程序中检查当前租户的功能权限。
- en: Checking the tenant features
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查租户功能
- en: The feature system is used to restrict application functionalities/features
    based on the current tenant. We will explore ABP's multi-tenancy infrastructure
    in [*Chapter 16*](B17287_16_Epub_AM.xhtml#_idTextAnchor457), *Implementing Multi-Tenancy*.
    However, we will cover checking tenant features here for the ASP.NET Core MVC/Razor
    Pages UI.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 功能系统用于根据当前租户限制应用程序的功能/特性。我们将在[*第16章*](B17287_16_Epub_AM.xhtml#_idTextAnchor457)中探索ABP的多租户基础设施，*实现多租户*。然而，我们将在这里介绍如何检查ASP.NET
    Core MVC/Razor Pages UI的租户功能。
- en: 'The `abp.features` API is used to check feature values for the current tenant.
    Let''s assume that we have a feature for importing email lists from Mailchimp
    (a cloud email marketing platform) and that we''ve defined a feature named `MailchimpImport`.
    We can easily check if the current tenant has that feature enabled:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`abp.features` API用于检查当前租户的功能值。假设我们有一个从Mailchimp（一个云电子邮件营销平台）导入电子邮件列表的功能，并且我们已经定义了一个名为`MailchimpImport`的功能。我们可以轻松地检查当前租户是否启用了该功能：'
- en: '[PRE63]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`abp.features.isEnabled` only returns `true` if the given feature''s value
    is `true`. ABP''s feature system allows you to define non-boolean features too.
    In this case, you can use the `abp.features.get(…)` function to obtain the given
    feature''s value for the current tenant.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`abp.features.isEnabled`仅在给定的功能值是`true`时返回`true`。ABP的功能系统还允许你定义非布尔功能。在这种情况下，你可以使用`abp.features.get(…)`函数来获取当前租户给定功能的值。'
- en: Checking features on the client side makes it easy to perform dynamic client-side
    logic, but remember to check the features on the server side as well for a secure
    application.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端检查功能使得执行动态客户端逻辑变得容易，但请记住，为了确保应用程序的安全，也要在服务器端检查功能。
- en: In the next section, we will continue using the localization system in your
    JavaScript code.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续在你的JavaScript代码中使用本地化系统。
- en: Localizing strings
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地化字符串
- en: One powerful part of ABP's localization system is that you can reuse the same
    localization strings on the client side. In this way, you don't have to deal with
    another kind of localization library in your JavaScript code.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: ABP本地化系统的一个强大之处在于你可以在客户端重用相同的本地化字符串。这样，你就不必在JavaScript代码中处理另一种本地化库。
- en: 'The `abp.localization` API is available in your JavaScript code to help you
    utilize the localization system. Let''s begin with the simplest case:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`abp.localization` API在你的JavaScript代码中可用，以帮助你利用本地化系统。让我们从最简单的情况开始：'
- en: '[PRE64]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `localize` function, with that usage, takes a localization key and returns
    the localized value based on the current language. It uses the default localization
    resource. If you need to, you can specify the localization resource as the second
    parameter:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种用法中，`localize`函数接受一个本地化键，并根据当前语言返回本地化值。它使用默认的本地化资源。如果你需要，你可以将本地化资源作为第二个参数指定：
- en: '[PRE65]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Here, we''ve specified `MyResource` as the localization resource. If you want
    to localize lots of strings from the same resource, there is a shorter way to
    do this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已将`MyResource`指定为本地化资源。如果你想从同一资源中本地化大量字符串，有一个更简短的方法来做这件事：
- en: '[PRE66]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, you can use the `localizer` object to get texts from the same resource.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以使用`localizer`对象从相同的资源获取文本。
- en: The JavaScript localization API applies the same fallback logic to the server-side
    API; it returns the given key if it can't find the localized value.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript本地化API将相同的回退逻辑应用于服务器端API；如果找不到本地化值，它将返回给定的键。
- en: 'If the localized string contains placeholders, you can pass the placeholder
    values as parameters. Let''s assume that we have the following entry in the localization
    JSON file:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果本地化字符串包含占位符，你可以将占位符值作为参数传递。假设我们在本地化 JSON 文件中有以下条目：
- en: '[PRE67]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can pass a parameter to the `localizer` or `abp.localization.localize` function,
    as shown in the following example:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将参数传递给 `localizer` 或 `abp.localization.localize` 函数，如下例所示：
- en: '[PRE68]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The resulting `str` value will be `Hello John!` for this example. If you have
    more than one placeholder, you can pass the values to the `localizer` function
    in the same order.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，结果 `str` 值将是 `Hello John!`。如果你有多个占位符，你可以按相同顺序将值传递给 `localizer` 函数。
- en: Besides the localizing texts, you may need to know the current culture and language
    so that you can take extra actions. The `abp.localization.currentCulture` object
    contains detailed information about the current language and culture. In addition
    to the current language, the `abp.localization.languages` value is an array of
    all the available languages in the current application. Most of the time, you
    don't directly use these APIs since the theme you're using is responsible for
    showing a list of languages to the user and allows you to switch between them.
    However, it is good to know that you can access the language data when you need
    it.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本地化文本外，你可能还需要知道当前的文化和语言，以便你可以采取额外的行动。`abp.localization.currentCulture` 对象包含有关当前语言和文化的详细信息。除了当前语言外，`abp.localization.languages`
    值是当前应用程序中所有可用语言的数组。大多数时候，你不会直接使用这些 API，因为你所使用的主题负责向用户显示语言列表并允许你在它们之间切换。然而，了解你可以在需要时访问语言数据是很好的。
- en: So far, you've learned how to use some ABP server-side features on the client
    side. In the next section, you will learn how to show message and confirmation
    boxes to the user.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了如何在客户端使用一些 ABP 服务器端功能。在下一节中，你将学习如何向用户显示消息和确认框。
- en: Showing message boxes
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示消息框
- en: It is very common to show blocking message boxes to users to inform them about
    something important happening in the application. In this section, you will learn
    how to show nice message boxes and confirmation dialogs in your applications.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中向用户显示阻止消息框以通知他们发生的重要事情是非常常见的。在本节中，你将学习如何在应用程序中显示漂亮的消息框和确认对话框。
- en: 'The `abp.message` API is used to show a message box to inform the user easily.
    There are four types of message boxes:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`abp.message` API 用于显示消息框，以便轻松通知用户。有四种类型的消息框：'
- en: '`abp.message.info`: Displays an informative message'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abp.message.info`：显示信息消息'
- en: '`abp.message.success`: Displays a success message'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abp.message.success`：显示成功消息'
- en: '`abp.message.warn`: Displays a warning message'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abp.message.warn`：显示警告消息'
- en: '`abp.message.error`: Displays an error message'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abp.message.error`：显示错误消息'
- en: 'Let''s take a look at the following example:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE69]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In this example, I''ve used the `success` function to display a success message.
    The first parameter is a message text, while the optional second parameter is
    a message header. The result of this example is shown in the following screenshot:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我使用了 `success` 函数来显示成功消息。第一个参数是消息文本，而可选的第二个参数是消息标题。此示例的结果如下截图所示：
- en: '![Figure 12.15 – A success message box'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.15 – 成功消息框'
- en: '](img/Figure_12.15_B17287.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_12.15_B17287.jpg)'
- en: Figure 12.15 – A success message box
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.15 – 成功消息框
- en: Message boxes are blocked, which means the page is blocked (non-clickable) until
    the user clicks the **OK** button.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 消息框被阻止，这意味着页面被阻止（不可点击），直到用户点击**确定**按钮。
- en: 'Another kind of message box is used for confirmation purposes. The `abp.message.confirm`
    function shows some dialog to get a response from the user:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的消息框用于确认目的。`abp.message.confirm` 函数显示一些对话框以从用户那里获取响应：
- en: '[PRE70]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `confirm` function returns a promise, so we could chain it with the `then`
    callback to execute some code once the user closes the dialog by accepting or
    canceling it. The following screenshot shows the confirmation dialog that was
    created for this example:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`confirm` 函数返回一个承诺，因此我们可以将其与 `then` 回调链式调用，以便在用户通过接受或取消对话框关闭后执行一些代码。以下截图显示了为此示例创建的确认对话框：'
- en: '![Figure 12.16 – A confirmation dialog'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.16 – 确认对话框'
- en: '](img/Figure_12.16_B17287.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_12.16_B17287.jpg)'
- en: Figure 12.16 – A confirmation dialog
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.16 – 确认对话框
- en: Message boxes are a good way to grab a user's attention. However, there is an
    alternative way to do this, as we'll see in the next section.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 消息框是吸引用户注意的好方法。然而，还有另一种方法可以做到这一点，我们将在下一节中看到。
- en: Showing notifications
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示通知
- en: 'Notifications are a non-blocking way to inform users of certain events. They
    are shown on the bottom right corner of the screen and automatically disappear
    after a few seconds. Just like the message boxes, there are four types of notifications:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 通知是非阻塞的方式，用于通知用户某些事件。它们显示在屏幕的右下角，并在几秒钟后自动消失。就像消息框一样，有四种类型的通知：
- en: '`abp.notify.info`: Displays an informative notification'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abp.notify.info`: 显示信息通知'
- en: '`abp.notify.success`: Displays a success notification'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abp.notify.success`: 显示成功通知'
- en: '`abp.notify.warn`: Displays a warning notification'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abp.notify.warn`: 显示警告通知'
- en: '`abp.notify.error`: Displays an error notification'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abp.notify.error`: 显示错误通知'
- en: 'The following example shows an information notification:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了信息通知：
- en: '[PRE71]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The second parameter is the notification title and is optional. The result
    of this example code is shown in the following screenshot:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是通知标题，是可选的。以下截图显示了此示例代码的结果：
- en: '![Figure 12.17 – A notification message'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.17 – 通知消息'
- en: '](img/Figure_12.17_B17287.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.17_B17287.jpg)'
- en: Figure 12.17 – A notification message
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17 – 通知消息
- en: With the notification API, we are closing the JavaScript APIs.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通知API，我们正在关闭JavaScript API。
- en: 'Here, I covered the most used APIs. However, there are more APIs you can use
    in your JavaScript code, all of which you can learn about by reading the ABP Framework
    documentation: [https://docs.abp.io/en/abp/latest/UI/AspNetCore/JavaScript-API/Index](https://docs.abp.io/en/abp/latest/UI/AspNetCore/JavaScript-API/Index).
    In the next section, we will learn how to consume server-side APIs from JavaScript
    code.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我介绍了最常用的API。然而，您可以在JavaScript代码中使用更多API，所有这些您都可以通过阅读ABP框架文档来了解：[https://docs.abp.io/en/abp/latest/UI/AspNetCore/JavaScript-API/Index](https://docs.abp.io/en/abp/latest/UI/AspNetCore/JavaScript-API/Index)。在下一节中，我们将学习如何从JavaScript代码中消费服务器端API。
- en: Consuming HTTP APIs
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费HTTP API
- en: 'You can use any tool or technique to consume HTTP APIs from your JavaScript
    code. However, ABP provides the following ways as fully integrated solutions:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何工具或技术从JavaScript代码中消费HTTP API。然而，ABP提供了以下作为完全集成解决方案的方法：
- en: You can use the `abp.ajax` API as an extension of the `jQuery.ajax` API.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将`abp.ajax` API作为`jQuery.ajax` API的扩展使用。
- en: You can use dynamic JavaScript client proxies to call server-side APIs, just
    like you can with JavaScript functions.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用动态JavaScript客户端代理来调用服务器端API，就像使用JavaScript函数一样。
- en: You can generate static JavaScript client proxies at development time.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在开发时生成静态JavaScript客户端代理。
- en: Let's begin with the first one – the `abp.ajax` API.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个开始 – `abp.ajax` API。
- en: Using the abp.ajax API
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用abp.ajax API
- en: The `abp.ajax` API is a wrapper around the standard `jQuery.ajax` API. It automatically
    handles all errors and shows a localized message to the user on an error case.
    It also adds the anti-forgery token to the HTTP header to satisfy **Cross-Site
    Request Forgery** (**CSRF**) protection on the server side.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`abp.ajax` API是标准`jQuery.ajax` API的包装器。它在发生错误的情况下自动处理所有错误，并向用户显示本地化消息。它还向HTTP头中添加了反伪造令牌，以满足服务器端的**跨站请求伪造**（**CSRF**）保护。'
- en: 'The following example uses the `abp.ajax` API to get a list of users from the
    server:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用`abp.ajax` API从服务器获取用户列表：
- en: '[PRE72]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In this example, we've specified `GET` as the request's `type`. You can specify
    all the standard options of `jQuery.ajax` (or `$.ajax`) to override the defaults.
    `abp.ajax` returns a promise object, so we could add the `then` callback to handle
    the result that's sent by the server. We can also use the `catch` callback to
    handle errors and the `always` callback to perform an action at the end of the
    request.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们已将`GET`指定为请求的`type`。您可以指定所有`jQuery.ajax`（或`$.ajax`）的标准选项来覆盖默认值。`abp.ajax`返回一个承诺对象，因此我们可以添加`then`回调来处理服务器发送的结果。我们还可以使用`catch`回调来处理错误，以及使用`always`回调在请求结束时执行操作。
- en: 'The following example shows how to handle errors manually:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何手动处理错误：
- en: '[PRE73]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Here, I added a `catch` callback function after the `then` function. You can
    perform your error logic here. I also specified the `abpHandleError: false` option
    to disable ABP''s automatic error handling logic. Otherwise, ABP will handle the
    error and show an error message to the user.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我在 `then` 函数之后添加了一个 `catch` 回调函数。你可以在那里执行你的错误逻辑。我还指定了 `abpHandleError:
    false` 选项来禁用 ABP 的自动错误处理逻辑。否则，ABP 将处理错误并向用户显示错误消息。'
- en: '`abp.ajax` is a low-level API. You typically use dynamic or static client proxies
    to consume your own HTTP APIs.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`abp.ajax` 是一个低级 API。你通常使用动态或静态客户端代理来消费自己的 HTTP API。'
- en: Using dynamic client proxies
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用动态客户端代理
- en: You should have already used the dynamic JavaScript client proxy system if you
    applied the example application from [*Chapter 3*](B17287_03_Epub_AM.xhtml#_idTextAnchor044),
    *Step-By-Step Application Development*. ABP Framework generates JavaScript functions
    at runtime to easily consume all the HTTP APIs of your application.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你应用了示例应用程序的 *第 3 章* [步骤-by-步骤应用程序开发](B17287_03_Epub_AM.xhtml#_idTextAnchor044)，你应该已经使用了动态
    JavaScript 客户端代理系统。ABP 框架在运行时生成 JavaScript 函数，以便轻松消费应用程序的所有 HTTP API。
- en: 'The following code block shows two sample methods of `IProductAppService` that
    were defined in [*Chapter 3*](B17287_03_Epub_AM.xhtml#_idTextAnchor044), *Step-By-Step
    Application Development*:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块显示了在 *第 3 章* [步骤-by-步骤应用程序开发](B17287_03_Epub_AM.xhtml#_idTextAnchor044)
    中定义的两个 `IProductAppService` 样式方法：
- en: '[PRE74]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'All of these methods are available in the same namespace on the client side.
    For example, we can get a product by its ID, as shown in the following code block:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都在客户端的相同命名空间中可用。例如，我们可以通过其 ID 获取一个产品，如下面的代码块所示：
- en: '[PRE75]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`productManagement.products` is the camel case equivalent of the `ProductManagement.Products`
    namespace of the C# code. `product` is the conventional name of `IProductAppService`.
    The `I` prefix and the `AppService` suffix have been removed, and the remaining
    name is converted into camel case. Then, we can use the method name that''s been
    converted in camel case without the `Async` suffix. So, the `GetAsync` method
    is used as the `get` function in the JavaScript code. The `get` function takes
    the same parameters that the C# method takes. It returns a `Deferred` object so
    that we can chain it with the `then`, `catch`, or `always` callbacks, similar
    to what can do for the `abp.ajax` API. It internally uses the `abp.ajax` API.
    In this example, the `result` argument of the `then` function is the `ProductDto`
    object that''s sent by the server.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`productManagement.products` 是 C# 代码中 `ProductManagement.Products` 命名空间的驼峰式等效。`product`
    是 `IProductAppService` 的传统名称。`I` 前缀和 `AppService` 后缀已被移除，剩余的名称被转换为驼峰式。然后，我们可以使用不带
    `Async` 后缀的驼峰式方法名称。因此，`GetAsync` 方法在 JavaScript 代码中用作 `get` 函数。`get` 函数接受与 C#
    方法相同的参数。它返回一个 `Deferred` 对象，这样我们就可以使用 `then`、`catch` 或 `always` 回调函数来链式调用，类似于
    `abp.ajax` API 可以做到的那样。它内部使用 `abp.ajax` API。在这个例子中，`then` 函数的 `result` 参数是服务器发送的
    `ProductDto` 对象。'
- en: 'Other methods are used in a similar way. For example, we can create a new product
    with the following code:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法以类似的方式进行使用。例如，我们可以使用以下代码创建一个新产品：
- en: '[PRE76]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Here, we pass the `CreateUpdateProductDto` object with the JSON object format.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 JSON 对象格式传递了 `CreateUpdateProductDto` 对象。
- en: 'In some cases, we may need to pass additional AJAX options for the HTTP API
    calls. You can pass an object as the last parameter to every proxy function:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能需要为 HTTP API 调用传递额外的 AJAX 选项。你可以将一个对象作为每个代理函数的最后一个参数传递：
- en: '[PRE77]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here, I passed an object to change the URL and add a custom header to the request.
    You can refer to jQuery's documentation ([https://api.jquery.com/jquery.ajax/](https://api.jquery.com/jquery.ajax/))
    for all the available options.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我传递了一个对象来更改 URL 并向请求添加一个自定义头。你可以参考 jQuery 的文档 ([https://api.jquery.com/jquery.ajax/](https://api.jquery.com/jquery.ajax/))
    了解所有可用选项。
- en: Dynamic JavaScript client proxy functions are generated at runtime by the `/Abp/ServiceProxyScript`
    endpoint of your application. This URL is added to the layout by the themes so
    that you can directly use any proxy function in your pages without importing any
    script.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 动态 JavaScript 客户端代理函数由应用程序的 `/Abp/ServiceProxyScript` 端点在运行时生成。这个 URL 由主题添加到布局中，这样你就可以直接在你的页面中使用任何代理函数，而无需导入任何脚本。
- en: In the next section, you will learn about an alternative way to consume your
    HTTP APIs.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解消费 HTTP API 的另一种替代方法。
- en: Using static client proxies
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用静态客户端代理
- en: Unlike dynamic client proxies, which are generated at runtime, static proxies
    are generated at development time. We can use the ABP CLI to generate the proxy
    script file.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 与在运行时生成的动态客户端代理不同，静态代理是在开发时生成的。我们可以使用 ABP CLI 来生成代理脚本文件。
- en: 'First, we need to run the application that serves the HTTP APIs because the
    API endpoint data is requested from the server. Then, we can use the `generate-proxy`
    command, as shown in the following example:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要运行提供 HTTP API 的应用程序，因为 API 端点数据是从服务器请求的。然后，我们可以使用 `generate-proxy` 命令，如下例所示：
- en: '[PRE78]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `generate-proxy` command can take the following parameters:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`generate-proxy` 命令可以接受以下参数：'
- en: '`-t` (required): The type of the proxy. We use `js` for JavaScript here.'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t`（必需）：代理的类型。在这里我们使用 `js` 表示 JavaScript。'
- en: '`-u` (required): The root URL of the API endpoint.'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-u`（必需）：API 端点的根 URL。'
- en: '`-m` (optional): The module name to generate the proxy for. The default value
    is `app` and is used to generate proxies for your application. In a modular application,
    you can specify the module name here.'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-m`（可选）：生成代理的模块名称。默认值为 `app`，用于生成应用程序的代理。在模块化应用程序中，你可以在此处指定模块名称。'
- en: 'Static JavaScript proxies are generated under the `wwwroot/client-proxies`
    folder, as shown in the following screenshot:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 静态 JavaScript 代理在 `wwwroot/client-proxies` 文件夹下生成，如下截图所示：
- en: '![Figure 12.18 – The static JavaScript proxy file'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.18 – 静态 JavaScript 代理文件'
- en: '](img/Figure_12.18_B17287.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.18_B17287.jpg](img/Figure_12.18_B17287.jpg)'
- en: Figure 12.18 – The static JavaScript proxy file
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.18 – 静态 JavaScript 代理文件
- en: Then, you can import the proxy script file into any page and use the static
    proxy functions like you would the dynamic ones.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以将代理脚本文件导入任何页面，并像使用动态代理一样使用静态代理函数。
- en: 'When you use static proxies, you don''t need dynamic proxies. By default, ABP
    creates dynamic proxies for your application. You can configure `DynamicJavaScriptProxyOptions`
    to disable it for the application, as shown in the following example:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用静态代理时，不需要动态代理。默认情况下，ABP 为你的应用程序创建动态代理。你可以配置 `DynamicJavaScriptProxyOptions`
    来禁用它，如下例所示：
- en: '[PRE79]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The `EnabledModules` list contains `app` by default. If you are building a modular
    application and want to enable dynamic JavaScript proxies for your module, you
    need to add it to the `EnabledModules` list explicitly.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnabledModules` 列表默认包含 `app`。如果你正在构建模块化应用程序并希望为你的模块启用动态 JavaScript 代理，你需要将其显式添加到
    `EnabledModules` 列表中。'
- en: Summary
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the fundamental design points and the essential
    features of the MVC/Razor Pages UI of ABP Framework.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 ABP 框架 MVC/Razor Pages UI 的基本设计要点和基本功能。
- en: The theming system allows you to build theme/style independent modules and applications
    and easily switch between UI themes. It makes this possible by defining a set
    of base libraries and standard layouts.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 主题系统允许你构建与主题/样式无关的模块和应用程序，并轻松地在 UI 主题之间切换。它是通过定义一组基本库和标准布局来实现这一点的。
- en: You then learned about the bundling and minification system, which covers the
    entire development cycle of importing and using client-side dependencies in your
    applications and optimizing resource usage in a production environment.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了捆绑和压缩系统，它涵盖了在应用程序中导入和使用客户端依赖项的整个开发周期，并在生产环境中优化资源使用。
- en: ABP makes it easy to create forms and implement validation and localization
    using tag helpers and predefined conventions. You also learned how to convert
    a standard form into an AJAX-submitted form.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 使得使用标签辅助器和预定义约定创建表单以及实现验证和本地化变得简单。你还学习了如何将标准表单转换为 AJAX 提交的表单。
- en: We've also covered some JavaScript APIs that can utilize ABP features on the
    client side, such as authorization and localization, and easily show nice-looking
    message boxes and notifications.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了一些可以用于客户端并利用 ABP 功能的 JavaScript API，例如授权和本地化，以及轻松显示美观的消息框和通知。
- en: Finally, you learned about alternative ways to consume HTTP APIs from your JavaScript
    code.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你了解了从 JavaScript 代码中消费 HTTP API 的替代方法。
- en: In the next chapter, you will learn about the Blazor UI for ABP Framework to
    build interactive web UIs using C# instead of JavaScript.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于 ABP 框架的 Blazor UI，使用 C# 而不是 JavaScript 来构建交互式 Web UI。
