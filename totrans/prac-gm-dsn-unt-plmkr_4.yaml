- en: Chapter 4. Creating Your First Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](ch03.html "Chapter 3. Components and State Machines"), *Components
    and State Machines*, you made your first game mechanic for the air hockey game,
    which we are going to keep improving for the rest of this book. You made a puck
    and a mallet that is controlled using the mouse pointer and pushes the puck. The
    pushing mechanic was rather complex and requires some in-depth analysis, which
    will be the first thing we talk about in this chapter. This chapter is going to
    cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using vector geometry and physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Win/lose conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating artificial intelligence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playmaker debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end, I will give you a couple of exercises that you will be able to complete
    with skills and knowledge you will have acquired by the end of this chapter, as
    well as some advice on how to look for answers to your questions if you have any.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vector geometry and physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are anything like me, you found the title of this section intimidating.
    However, before you decide to skip it or start looking for a new book about Unity,
    I assure you that it will not expose you to a single mathematical formula. Instead,
    it will use the Playmaker actions and explain what each of them does, which, in
    turn, will lead us to a conclusion about the science behind it.
  prefs: []
  type: TYPE_NORMAL
- en: Practically no 3D video game is possible without vector geometry and physics
    of some kind, and naturally both are instrumental in explaining how the mallet-puck
    interaction works in your new air hockey game.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, let us select the **Push Puck** state in the Mallet FSM by clicking
    on it in the FSM view of the **playMaker** panel and open the **Variables** tab
    on the right. There are three variables of type **Vector3** and one of type **Float**
    in the list. The following variables are of interest to us, since they are used
    for the calculation of push force and direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '**hitPos** is a **Vector3** variable in which we store the **X**, **Y**, and
    **Z** coordinates of the collision point between the mallet and the puck'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pushDir** is a **Vector3** variable we store the **X**, **Y**, and **Z**
    direction in which the puck is going to be pushed when it collides with the mallet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pushMag** is a **Float** variable that is currently equal to 20 and corresponds
    to the magnitude of the push'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand how things work in video games, you will have to be comfortable
    using **Vector3** variables, because much of everything you will do is going to
    happen in 3D space. Each **Transform** component has three **Vector3** properties:
    **Position**, **Rotation**, and **Scale**, each of which has its own **X**, **Y**,
    and **Z** values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each point in 3D space has coordinates that can be written down in the form
    of three **Float** variables: a position on the X axis, a position on the Y axis,
    and a position on the Z axis. A **Vector3** variable can store these three position
    values at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: You can perform various actions over **Vector3**, you can add it to another
    vector, you can multiply it by a float (or an integer), you can store its **X**,
    **Y**, and **Z** in separate **Float** variables or write separate float values
    into its **X**, **Y**, and **Z**. Most of these actions are under the **Vector3**
    category of the **Actions** panel.
  prefs: []
  type: TYPE_NORMAL
- en: The first action that we use is called **Get Controller Hit Info**, and it gets
    the position of the last collision that happened to a game object. If you look
    at the **Collision Event** action in the **Move** state that triggers the **Push**
    event, you will see that this only happens when the mallet collides with the puck,
    so we do not have to worry about weeding out false collisions once we are already
    in the **Push Puck** state. All we have to do is save the contact point in a variable,
    which is exactly what happens.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Vector geometry and physics](img/8108OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we simply get the current position of the mallet and store it in the **pushDir**
    variable, for the time being using the **GetPosition** action. This variable is
    called **pushDir**, because later it will contain the direction in which the mallet
    will be pushed. We get this position simply by accessing the **Position** property
    of the mallet's **Transform** component.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Vector geometry and physics](img/8108OT_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If these are all positions, how do you get a direction? What is a direction
    and how can you write it down in **Vector3**? The answer is quite simple. A direction
    is the relative position of one point with respect to another point in space,
    which is another way of saying that it is the difference between **Position A**
    and **Position B**. The following figure shows two points and their relative directions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Vector geometry and physics](img/8108OT_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, in order to find the direction in which point B lies in relation to point
    A, you will have to subtract the position of point B from the position of point
    A. Then you need to normalize the result, which means writing it down as a **Vector3**
    variable that has its **X**, **Y**, and **Z** properties as numbers between `0`
    and `1` (that is, without a magnitude).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the original result of subtraction was (`-1`, `27`, `350`),
    the normalized vector of direction will be (`-0.00284867`, `0.076914`, `0.997034`),
    and the best part of it is that you do not need to know how this happens, because
    there is a Playmaker action that does it automatically for you. The following
    screenshot shows the two actions that are used to get the direction from the center
    of the mallet to the hit point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Vector geometry and physics](img/8108OT_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let us go through the things we have covered so far:'
  prefs: []
  type: TYPE_NORMAL
- en: We need the position of the mallet, because this is where we are going to push
    the puck from
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need the point of the impact between the mallet and the puck in order to
    find where the puck lies in space in relation to the mallet when the mallet hits
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these values are saved as **Vector3** variables, each of which contains
    an **X**, **Y**, and **Z** position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can find out in which direction the puck lies in relation to the mallet by
    subtracting the position of the impact from the position of the mallet and normalizing
    the resulting vector, that is, writing down its **X**, **Y**, and **Z** properties
    as numbers between `0` and `1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know how to find the direction in which the puck lies in relation
    to the mallet, we want to push it in that direction, so this is exactly what we
    are going to do. However, we cannot just assign the direction vector as the puck's
    velocity, because the direction vector does not have a magnitude, which means
    that the velocity of the puck will be way smaller than we want it to be.
  prefs: []
  type: TYPE_NORMAL
- en: In order to control the force with which the puck is being pushed, we have to
    multiply the direction by a magnitude, which is stored in the **pushMag** variable.
    This variable determines how fast the puck will move in the opposite direction
    once it meets the mallet.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you assign **pushMag** a negative value, the puck will be pushed towards
    the mallet every time it collides with it, which, in turn, means that it will
    stick to it. This too can be a useful game mechanic, albeit not in this case.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows the **Vector3 Multiply** action that multiplies
    the **pushDir** direction vector by **pushMag** magnitude as well as the **Add
    Force** action that applies the force to the puck at the impact point.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Vector geometry and physics](img/8108OT_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Win/Lose conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there are games where win/lose conditions are not necessary, air hockey
    is definitely not one of them. In classic air hockey, there are two goal slots
    on the opposite sides of the table. If the puck gets into the goal of player 1,
    then player 2 gets a point and vice versa. The game ends when one of the players
    has 7 points.
  prefs: []
  type: TYPE_NORMAL
- en: There is the short-term win condition (score once) and the long-term win condition
    (score seven times before your opponent does). We will only implement the short-term
    win condition, although you are highly encouraged to try and implement the long-term
    one once you are done with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start implementing the win/lose conditions, let us make sure that
    the puck cannot get stuck in the corner, because this kind of behavior will prevent
    the win/lose condition from being triggered. Make four new walls, rotate them
    45 degrees on the Y axis, and place them in the corners so as to get rid of the
    straight angles there, as shown in the next figure. This should solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Now that this is taken care of, let us make the goal slots. Change the puck's
    **Scale** property to (`1`, `0.7`, `1`) and place it in (`-3`, `0.3`, `0`).
  prefs: []
  type: TYPE_NORMAL
- en: Make one more wall on the left and one more wall on the right. The walls should
    be placed as shown in the following figure:![Win/Lose conditions](img/8108OT_04_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make two new cubes (**GoalLeft** and **GoalRight**) and place them in the gaps
    on the left and on the right, as shown in the next figure. Make the cube on the
    left green (`0`, `255`, `0`) and the cube on the right red (`255`, `0`, `0`) by
    making new materials for them. Both of them should be in `2.5` on the Y axis.
    These are there to block the mallet, but not the puck.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make two more cubes. Call them `GoalTriggerLeft` and `GoalTriggerRight`. Place
    them just behind the game field on either side of the table. These objects will
    act as triggers to detect which goal the puck has scored. Check the **Is Trigger**
    property of these game objects' **Box Collider** component. This property of the
    collider component makes sure that the object does not do any physics collisions
    (as opposed to the puck or the walls), but instead acts as a trigger, detecting
    when rigidbodies enter, stay inside, and exit it. These objects are the actual
    goals that will trigger the win/lose conditions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your **Scene** view should look something like the following screenshot at this
    point:![Win/Lose conditions](img/8108OT_04_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **GoalTriggerLeft** game object and add an FSM to it. Make two states
    and rename **State1** to `Scored` and **State2** to `LoadLevel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the **Scored** state and go to **Add Transition** | **System Events**
    | **TRIGGER ENTER** from the contextual menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a transition from **TRIGGER ENTER** to **LoadLevel**. When something enters
    the trigger (and it should only be the puck, because of the way things are placed
    in the scene), this event will get called, and the transition will be made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **LoadLevel** state and add a **Load Level** action to it. It should
    be located under the **Level** category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Level Name** property of the **Load Level** action, type the name of
    your game scene. It should be called `Scene1` if you haven't changed anything.
    To make sure, look at the top of the **Unity Editor** window. It always says `[SceneName].unity
    - [ProjectName] - [Platform]`, where the things in the brackets are **Scene1**,
    **UPMTutorial**, and **Web Player** for me, but can differ for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the same thing for **GoalTriggerRight**. For now, keep the FSM exactly the
    same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can add some finishing touches to our scene by importing a 3D model:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you have downloaded the project archive from the Packt Publishing
    website. If you haven't, do it now and unpack the archive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the empty space under the file list in the **Project** panel
    and select **Import New Asset...** from the contextual menu. A file browser should
    pop up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `WallVisual.fbx` file in the `UnityPlaymakerTutorial` directory and
    click on **Import**. The file browser will close and a `WallVisual` file will
    appear in the **Project** panel. Create a `Models` folder and drag it there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the `WallVisual` file and have a look at **Inspector**. There are three
    tabs in this **Inspector**: **Model**, **Rig**, and **Animations**. These are
    all responsible for changing import settings of your model.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the model that we have imported is not an animated one, only the **Model**
    tab is of interest to us. Set **Scale Factor** to `1.05` and uncheck **Import
    Materials**. Leave the rest of the properties at their default values. **Scale
    Factor** changes the scale of the model on import, meaning that the **Transform
    Scale** property will be equal to (`1`, `1`, `1`) while the actual size in 3D
    space may change. This is needed because the working scale in the 3D modeling
    software (such as Maya or 3DS Max) may differ from that in Unity. To make the
    model appear bigger, increase the scale factor. See the following screenshot to
    confirm that your import settings are set correctly:![Win/Lose conditions](img/8108OT_04_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag **WallVisual** into **Hierarchy** twice. Position the first instance in
    (`0`, `0.5`, `-3.5`) and the second one in (`0`, `0.5`, `3.5`). Set the first
    one's **Rotation** to (`0`, `0`, `0`) and the second one's to (`0`, `180`, `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The difference between a prefab and an imported model is that you cannot apply
    the changes that you made to one of the instances. You also cannot add or remove
    any components from the model. You can make a prefab from one of the instances
    of the model to be able to do that.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Set the material of both **WallVisual** game objects to **WallMaterial** that
    you created previously to be used on walls. Select all of the **Wall** objects
    and deactivate their **Mesh Renderer** components. The following figure shows
    what you should see in the **Game** view if you did everything right:![Win/Lose
    conditions](img/8108OT_04_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, when you hit play, you should be able to score in both goals. Doing so
    will reload the currently loaded level. We also made sure that the puck does not
    get stuck in the corners of the table and imported a model that covers our cubic
    walls and makes the game look more like an actual air hockey table. This means
    that the game is finally playable, if, admittedly, not very fun yet.
  prefs: []
  type: TYPE_NORMAL
- en: Creating artificial intelligence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having an **artificial intelligence** (**AI**) in the game, even a really simple
    one, will definitely make it more challenging and fun, so let us get to it with
    no further delay.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how our AI is going to work: it is going to constantly try and move
    to the point on the right side of the puck, pushing it to the left upon collision.
    We will keep the same collision logic that we use for the player''s mallet in
    order to keep the game fair. In order to make sure that the AI does not get stuck
    in a wall while pushing directly to the left, we will make adjustments to the
    direction based on the current position of the mallet. This way, the AI will appear
    to aim at the player''s goal slot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the given steps to implement the AI:'
  prefs: []
  type: TYPE_NORMAL
- en: Duplicate the **Mallet** game object by selecting it in **Hierarchy** and pressing
    *command* + *D* (*Ctrl* + *D* in Windows).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the copy to the right side of the table and put it next to the red goal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the original mallet on the left `MalletLeft`, and the copy on the right
    `MalletRight`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a new red material for **MalletRight** and assign it to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put both mallets on a new layer called **Player** using the **TagManager** menu
    accessible from **Inspector**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the main menu, go to **Edit** | **Project Settings** | **Physics**. You will
    see a matrix of checkboxes with names of layers written horizontally and vertically
    next to each row and column in the **Inspector** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the intersection between **Player** horizontally and **Player** vertically
    and uncheck that box. Make sure that the rest of the boxes stay checked. This
    matrix determines which layers can interact with each other and with themselves,
    so if you accidentally uncheck something else, such as **Default**/**Player**
    or **Default**/**Default**, the puck may no longer collide with the goal triggers
    and the mallets may stop colliding with the walls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **MalletRight** game object. In **Inspector**, remove the **Character
    Controller** component and add **Capsule Collider**. Add a **Rigidbody** component.
    Set **Freeze Rotation** on the **Rigidbody** component to X, Y and Z. If you don't,
    the red mallet will fall when you press play. **Rigidbody** is the component responsible
    for physics interactions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the FSM view of the **playMaker** panel, select the **Move** state. It is
    here that we are going to set up the AI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove all the actions except **Collision Event**. You can select multiple
    actions at the same time by *Shift*-clicking their headers. Open the **Actions**
    panel and add the following actions to the state, keeping in mind that the order
    of the actions matters, and moving **Collision Event** to the very bottom: **Get
    Property**, **Get Property**, **Get Property**, **Float Multiply**, **Float Add**,
    **Float Add**, **Set Vector3 XYZ**, and **Move Towards**. The following screenshot
    shows the exact order of the actions that you should have in the **Move** state
    of the FSM of **MalletRight**.![Creating artificial intelligence](img/8108OT_04_08.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Events** tab, add a new event, calling it `Return`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Variables** tab and add/remove variables until you have the variables
    shown in the following screenshot:![Creating artificial intelligence](img/8108OT_04_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are the variables used for collision calculations that were left from
    before, and some new ones used for the simple AI behavior that we discussed earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to the **State** tab and open the first **Get Property** action. Drag
    and drop the **Puck** game object into **Target Object**, and set **Property**
    to **transform** | **position** | **x** and **Store Float** to **puckX**. Check
    **Every Frame**. In fact, check **Every Frame** every time you see this checkbox
    in this state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the same for the second **Get Property** tab, but choose **z** instead of
    **x** and **puckZ** instead of **puckX**. These actions are used to retrieve the
    position of the puck on the two axes that matter to us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the third **Get Property** action and drag **MalletRight** into its **Target
    Object** property; store its Z position in the offset variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Float Multiply** action, set **Float Variable** to **offset** and **Multiply
    By** to `0.2`. This is where we define how hard the AI should try to aim the player's
    goal. If it tries too hard, it will miss. If it tries not hard enough, it will
    miss as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the first **Float Add** action, set **Float Variable** to **puckX** and the
    **Add** property to **offset**. You need to click on the option button on the
    right to do that. This is where the offset is actually applied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the second **Float Add** action, set **Float Variable** to **puckZ**, and
    **Add** to `0.9`. This value can be changed as you want later. It defines the
    distance between the actual center of the puck and the point to which the AI is
    going to move. It is very important that the AI aim somewhat to the right, because
    otherwise it will never be able to hit the player's goal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Set Vector3 XYZ**, set **Vector3 Variable** to **targetPos**, **X** to
    **puckX,** and **Z** to **puckZ**. Make sure that **Y** is set to **None**. This
    is where we define the actual position where the AI is going to try and go in
    the current frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Move Towards** is the action that applies movement to the AI. Set **Target
    Position** to **targetPos**, **Max Speed** to `5`, **Finish Distance** to `0.15,`
    and **Finish Event** to **Return**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, open **Collision Event** and change its **Collision** property to **On
    Collision Stay**; leaving everything else intact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you might have an error in the **Move Towards** action. That would be because
    there is no transition from the **Return** event. Right-click the **Move** state
    in the FSM view and add a transition from the **Return** event to **Move**. Yes,
    this is a state that loops on itself. The following figure shows the layout that
    you should see in the FSM view of **MalletRight** now.![Creating artificial intelligence](img/8108OT_04_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you click on the play button right now, the AI should be completely functional
    and, in fact, quite strong. Now, there are ways of improving it that will be discussed
    in the *Exercises* section of this chapter, but it should be enough to have a
    good bit of fun with the game debugging in Playmaker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have a player controller, a win/lose condition, and a functional
    AI in the game, it begins to get quite big, and if you want to add anything to
    it or if something goes wrong, you will be hard-pressed to know what exactly is
    going on in your actions in real time. This is what debugging is for: it is a
    diagnosis tool that lets you get additional information about your game or its
    specific systems that you can later use in order to fix something.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at an example. Select **MalletLeft** and open its **Move** state
    in the FSM view of the **playMaker** panel. If you look at the bottom of the **State**
    tab, you will see two checkboxes there: **Debug** and **Hide Unused**. The first
    one shows you the values of all your properties at all time, while the second
    one hides the unused ones. Check both of them and, keeping **MalletLeft** selected,
    press the play button.'
  prefs: []
  type: TYPE_NORMAL
- en: As you move the mallet around, observe the numbers that change under all the
    properties of the actions. When you implement a new gameplay feature, you will
    want to know in what range values change, and if they do at all.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the **Console** panel for debugging some things. Uncheck both
    **Debug** and **Hide Unused**, and then open the **Push Puck** state of the same
    FSM. Add a **Debug Log** action (under the **Debug** category) to the very top
    of it. Set **Log Level** to **Warning** and write `Hit!` in the text field.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should know that there are three types of debug logs: *Info*, *Warning*,
    and *Error*, each with a specific function. Warning is there to attract your attention
    to an issue, Info is a simple message that provides information about something,
    while Error lets you know that there is a problem. These are merely conventions,
    but you will see some Unity internal Info, Warnings, and Errors that follow them.'
  prefs: []
  type: TYPE_NORMAL
- en: Now open the **Console** panel. We have talked about it briefly before, but
    let us have a detailed look at various buttons in it now (from left to right).
  prefs: []
  type: TYPE_NORMAL
- en: '**Clear** is quite self-explanatory; it clears the log, removing all the messages
    from it, apart from compilation errors that were not fixed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collapse** is a toggle button that makes similar debug messages appear in
    the same line or separately'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clear on Play** is a toggle button that forces the **Console** to clear the
    log when you press play.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error Pause** automatically pauses the game when there is an error to give
    you a better look at it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the three toggle buttons on the right are filters for **Console**
    that let you focus on different types of debug messages: Info, Warning, and Error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you press play now and hit the puck with your mallet, a message with a yellow
    triangle should appear in Console saying something like **MalletLeft : FSM : Push
    Puck : DebugLog : Hit!** You might also have several of them. Stop the game and
    see what happens when you switch **Collapse** on and off and toggle the Warning
    filter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you press play now and hit the puck with your mallet, a message with a yellow
    triangle should appear in **Console** saying something like **MalletLeft : FSM
    : Push Puck : DebugLog : Hit!** You might also have several of them. Stop the
    game and see what happens when you switch **Collapse** on and off and toggle the
    Warning filter. You might also have several of them, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating artificial intelligence](img/8108OT_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can also debug variable values in the same way. Open **playMaker**, remove
    the **Debug Log** action, and put a **Debug Vector3** action right after **Get
    Controller Hit Info**, setting the **Log Level** to **Error** and **Vector3 Variable**
    to **hitPos**. Then open **Console** and test the game again, pushing the puck
    with your mallet. You should see red error messages appear in **Console** now.
    If you have **Error Pause** toggled, the game will pause and the **Console** panel
    will be revealed to show you the errors.
  prefs: []
  type: TYPE_NORMAL
- en: You can achieve a similar effect by using something called breakpoints. Get
    rid of the **Debug Vector3** action in the **Push Puck** state of the FSM of **MalletLeft**,
    then right-click on the **Push Puck** state in the FSM view and select **Toggle
    Breakpoint** from the contextual menu. A red line will appear next to the state's
    name in the FSM view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you press play and touch the puck with your mallet, the game will stop
    the same way it did when you used an **Error Debug** log and the **Error Pause**
    toggle in **Console**, except this time the pause will be triggered by Playmaker.
    A red circle with the name of the breakpoint''s state will appear in the FSM view.
    The following screenshot shows what it is supposed to look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating artificial intelligence](img/8108OT_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the transition arrow from the **Push** event to the **Push Puck**
    state became yellow. This means that the breakpoint was triggered after this particular
    transition and not something else.
  prefs: []
  type: TYPE_NORMAL
- en: You can unpause the game when it was paused because of a breakpoint, but it
    will be paused all over again if this or another breakpoint gets triggered. You
    can remove the breakpoint by right-clicking the state with a breakpoint and selecting
    **Toggle Breakpoint** from the contextual menu.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful debugging tool is step-by-step execution. When the game is paused
    (including when it was paused because of breakpoints or **Error Pause**), you
    can press the next step (![Creating artificial intelligence](img/8108OT_04_13.jpg))
    button in the toolbar or on the bottom of the **playMaker** panel. This will execute
    the next frame of the game. As you already know, some actions are executed in
    every frame so, using the **Debug** checkbox on the bottom of the **State** tab
    in the **playMaker** panel, you can see the exact values of each parameter of
    each action in any particular frame. You can press the next step button as you
    want to observe changes. When you are done debugging, just unpause or stop the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final debug tool that we are going to talk about is the Playmaker **FSM
    Log** panel that lets you see everything that happens to your objects that are
    under Playmaker control. You can open it by pressing the **Debug** button on the
    bottom of the **playMaker** panel next to the play/pause/next step buttons, then
    select **Open Log Window** from the drop-down menu. The following screenshot shows
    the **FSM Log** panel in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating artificial intelligence](img/8108OT_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It might be a good idea to keep this log handy, so you could attach it as the
    second panel to the same area of the screen as **Hierarchy** or **Project**.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some exercises that I would like to suggest that you try doing before
    you move on to the next chapters, which cover more advanced topics. You already
    know the basics of Unity and Playmaker—enough to make your game better or make
    a completely new one from scratch. Doing these exercises will improve your skills
    and help consolidate the new information that you have been exposed to in this
    book. Exercises are sorted by difficulty, from the easiest to the hardest one:'
  prefs: []
  type: TYPE_NORMAL
- en: Debug log all the important events in the game, including puck hits, goal hits,
    and wall collisions for both mallets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hit sounds: Your `Wall` prefab has a FSM. Use it to play some sounds when a
    mallet and/or a puck hits the wall. [Freesound.org](http://Freesound.org) is a
    good resource for free sound effects. If you are more into retro sounds, try [bfxr.net](http://bfxr.net).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Multiple levels: Try making multiple levels with obstacles/additional walls
    in the middle. You can just duplicate them all over the place and then, when the
    round is over, move on to the next level.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By now you have probably encountered a situation where the puck falls off of
    the table, and you are forced to restart the game using the play button. This
    is annoying for other players as well! You could try changing the table set up,
    detecting the puck position, or some other way of fixing this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When you are working on this, think about the way goal triggers work, or be
    creative and come up with your own solution.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You know how to manipulate the **Scene** view and make new materials for objects,
    and you also know how to change the size and the projection of the camera. You
    can make your game much prettier if you come up with a beautiful color scheme
    and/or camera projection/orientation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By now you have probably started wondering whether mouse controls are the best
    solution for this game. This is a perfectly valid question, and you should make
    this decision yourself. You will never know for sure until you try different ones,
    so take a look at the **Input** category in the **Actions** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you manage to implement keyboard controls, why not go a step further and
    make a level where instead of competing with an AI opponent you could play with
    your friend or family member while sitting at the same computer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have a close look at states and actions that control the AI. Try modifying some
    of the properties there or even replacing actions themselves in order to make
    the AI more intelligent and life-like. You could try and make the AI alternate
    its behavior based on the position of the puck by going back to its own goal slot
    in order to protect it. You can also try and figure out a way to stop the AI from
    being pushed backwards whenever the player pushes the puck that the AI is trying
    to push itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to do this, you will need to add a Playmaker variable to the puck and
    then use one of the **Get FSM** actions under the **StateMachine** category.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Introduce a new game mechanic to the game: how about rounds of seven games
    instead of one? Or power-ups? Or limiting the mallets to their side of the table?
    You choose, you can do them all if you like.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before you take up any of these challenges, you should know about some of the
    useful Unity and Playmaker online resources that can help you find answers to
    some, if not all, of the questions. You can be sure that questions will inevitably
    appear when you start implementing something on your own.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unity answers**: [http://answers.unity3d.com/](http://answers.unity3d.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unity wiki**: [http://wiki.unity3d.com/](http://wiki.unity3d.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unity forum**: [http://forum.unity3d.com/](http://forum.unity3d.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unity documentation**: [http://unity3d.com/learn/documentation](http://unity3d.com/learn/documentation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Playmaker manual**: [https://hutonggames.fogbugz.com/](https://hutonggames.fogbugz.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Playmaker forums**: [http://hutonggames.com/playmakerforum/](http://hutonggames.com/playmakerforum/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Unity answers and the Unity forums, you should not hesitate to ask questions;
    the Unity community is very active, and there are chances that your problem will
    be solved in a matter of minutes. Just make sure you explain it well. But before
    asking, I strongly advise you to use the search option first, since there is a
    good chance that most of the problems that you might encounter have already been
    solved.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the fundamentals of game development with Unity
    and Playmaker. You now know how to make objects, have them interact, make them
    respond to input, and even move on their own based on your algorithm. On top of
    that, you now know the fundamentals of vector geometry that you are going to use
    in most of the games you will make.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is about programming. You will learn how to code your own Unity
    component and then make it into a Playmaker action. We will also demonstrate that
    Playmaker is essentially visual programming that uses logic very similar to that
    of conventional scripts.
  prefs: []
  type: TYPE_NORMAL
