["```cs\n     public class Test \n     { \n       //---- Only Property this class has  \n       public int X { get; set; } \n       //----- This method will be invoked dynamically \n       public void Spit() \n       { \n         Console.WriteLine(\" X is \" + X); \n       } \n     } \n\n```", "```cs\n    class Program \n    { \n      static void Main(string[] args) \n    { \n      Test a = new Test(); \n      //------ Set the property \n      a.X = 0xBEEF; \n      //------ Retrieve the CLR Type \n      Type t = a.GetType(); \n      if (t == null)  return; \n      //---- Retrieve the Property Handle \n      PropertyInfo np = t.GetProperty(\"X\"); \n      //---- Retrieve the Property  Value \n      Console.WriteLine(np.GetValue(a)); \n      //------ Retrieve the Method Handle \n      MethodInfo mi = t.GetMethod(\"Spit\"); \n      //------ Invoke the method \n      mi.Invoke(a, null); \n\n      Console.Read(); \n    } \n  } \n\n```", "```cs\n    public class TaxableEntity \n    { \n      public int Id { get; set; } \n      public string Name { get; set; } \n      public int Age { get; set; } \n      public char Sex { get; set; } \n      public string Location { get; set; } \n      public TaxParamVO taxparams { get; set; } \n    } \n\n```", "```cs\n    public class TaxParamVO \n    { \n      public double Basic {get;set;} \n      public double DA { get; set; } \n      public double HRA { get; set; } \n      public double Allowance { get; set; } \n      public double Deductions { get; set; } \n      public double Cess { get; set; } \n      public double TaxLiability { get; set; } \n      public bool Computed { get; set; } \n    } \n\n```", "```cs\n    public class TaxDTO \n    { \n      public int id { } \n      public TaxParamVO taxparams { } \n    } \n\n```", "```cs\n    public class COMPUTATION_CONTEXT \n    { \n      private Dictionary<String, Object> symbols = new \n      Dictionary<String, Object>(); \n      public void Put(string k, Object value) { \n        symbols.Add(k, value); \n      } \n      public Object Get(string k) { return symbols[k]; } \n    } \n\n```", "```cs\n    Interface ComputationCommand \n    { \n      bool Execute(COMPUTATION_CONTEXT ctx); \n    } \n\n```", "```cs\n    public class SeniorCitizenCommand : ComputationCommand \n    { \n      public bool Execute(COMPUTATION_CONTEXT ctx) \n      { \n        TaxDTO td = (TaxDTO)ctx.Get(\"tax_cargo\"); \n        //---- Instead of computation, we are assigning \n        //---- constant tax for each archetypes \n        td.taxparams.TaxLiability = 1000; \n        td.taxparams.Computed = true; \n        return true; \n      } \n    } \n\n    public class OrdinaryCitizenCommand : ComputationCommand \n    { \n      public bool Execute(COMPUTATION_CONTEXT ctx) \n      { \n        TaxDTO td = (TaxDTO)ctx.Get(\"tax_cargo\"); \n        //---- Instead of computation, we are assigning \n        //---- constant tax for each archetypes \n        td.taxparams.TaxLiability = 1500; \n        td.taxparams.Computed = true; \n        return true; \n      } \n    } \n\n```", "```cs\n    class CommandDispatcher \n    { \n      public static bool Dispatch(string archetype,      \n      COMPUTATION_CONTEXT ctx) \n      { \n        if (archetype == \"SeniorCitizen\") \n        { \n          SeniorCitizenCommand cmd = new SeniorCitizenCommand(); \n          return cmd.Execute(ctx); \n        } \n        else if (archetype == \"OrdinaryCitizen\") \n        { \n          OrdinaryCitizenCommand cmd = new OrdinaryCitizenCommand(); \n          return cmd.Execute(ctx); \n        } \n        else {  \n          return false; \n        } \n      } \n    } \n\n```", "```cs\n    public static void ViewHandler(TaxCalcForm tf) \n    { \n      TaxableEntity te = GetEntityFromUI(tf); \n      if (te == null){ \n        ShowError(); \n        return; \n      } \n      string archetype = ComputeArchetype(te); \n      COMPUTATION_CONTEXT ctx = new COMPUTATION_CONTEXT(); \n      TaxDTO td = new TaxDTO { id = te.id, taxparams =    \n      te.taxparams}; \n      ctx.Put(\"tax_cargo\",td); \n      bool rs = CommandDispatcher.Dispatch(archetype, ctx); \n      if ( rs ) { \n        TaxDTO temp = (TaxDTO)ctx.Get(\"tax_cargo\"); \n        tf.Liabilitytxt.Text =        \n        Convert.ToString(temp.taxparams.TaxLiability); \n        tf.Refresh(); \n      } \n    } \n\n```", "```cs\n    <?xml version=\"1.0\"?> \n    <plugins> \n      <plugin archetype =\"OrindaryCitizen\"     \n      command=\"TaxEngine.OrdinaryCitizenCommand\"/>  <plugin   \n      archetype=\"SeniorCitizen\"    \n      command=\"TaxEngine.SeniorCitizenCommand\"/> \n    </plugins> \n\n```", "```cs\n    private Dictionary<string,string> LoadData(string xmlfile) \n    { \n       return XDocument.Load(xmlfile) \n      .Descendants(\"plugins\") \n      .Descendants(\"plugin\") \n      .ToDictionary(p => p.Attribute(\"archetype\").Value, \n      p => p.Attribute(\"command\").Value); \n    } \n\n```", "```cs\n    public class ObjectFactory \n    { \n      //--- A Dictionary to store  \n      //--- Plugin details (Archetype/commandclass) \n      private Dictionary<string, string> plugins = new   \n      Dictionary<string, string>(); \n      //--- A Dictionary to cache objects \n      //--- archetype/commandclassinstance \n      private Dictionary<string, ComputationCommand> commands = \n      new Dictionary<string, ComputationCommand>(); \n\n      public ObjectFactory(String xmlfile) \n      { \n        plugins = LoadData(xmlfile); \n      } \n\n      private Dictionary<string,string> LoadData(string xmlfile) \n      { \n        return XDocument.Load(xmlfile) \n        .Descendants(\"plugins\") \n        .Descendants(\"plugin\") \n        .ToDictionary(p => p.Attribute(\"archetype\").Value, \n        p => p.Attribute(\"command\").Value); \n      } \n      //---- Rest of the code omitted \n    } \n\n```", "```cs\n    public static T DeepClone<T>(this T a) { \n      using (MemoryStream stream = new MemoryStream()) { \n      BinaryFormatter formatter = new BinaryFormatter(); \n      formatter.Serialize(stream, a); \n      stream.Position = 0; \n      return (T)formatter.Deserialize(stream); \n      } \n    } \n\n```", "```cs\n    public ComputationCommand Get(string archetype,  \n    string mode = \"singleton\") \n    { \n      //---- We can create a new instance, when a  \n      //---- prototype is asked, otherwise we will \n      //---- return the same instance stored in the dictionary \n      if (mode != \"singleton\" && mode != \"prototype\") \n      return null; \n\n      ComputationCommand temp = null; \n      //--- if an instance is already found, return \n      // it (singleton) or clone (prototype \n      if (commands.TryGetValue(archetype, out temp)) \n      { \n        return (mode == \"singleton\") ? temp : \n        temp.DeepClone<ComputationCommand>(); \n      } \n\n      //---- retrieve the commandclass name \n      string classname = plugins[archetype]; \n      if (classname == null) \n      return null; \n      //------ retrieve the classname, if it \n      //------ is available with CLR \n      Type t = Type.GetType(classname); \n\n      if (t == null) \n      return null; \n      //---- Create a new Instance and store it \n      //---- in commandclass instance dictionary \n      commands[archetype]=       \n      (ComputationCommand)Activator.CreateInstance(t); \n      return commands[archetype]; \n    } \n\n```", "```cs\n    public class CommandDispatcher \n    { \n      private static ObjectFactory obj =  \n      new  ObjectFactory(\"Pluggins.xml\"); \n\n      public static bool Dispatch(string archetype,  \n      COMPUTATION_CONTEXT ctx) \n      { \n        ComputationCommand cmd = obj.Get(archetype); \n        return (cmd == null) ? false : cmd.Execute(ctx);  \n      } \n    } \n\n```", "```cs\n    public static void ViewHandler(TaxCalcForm tf) \n    { \n      TaxableEntity te = GetEntityFromUI(tf); \n      if (te == null) \n      { \n        ShowError(); \n        return; \n      } \n      string archetype = ComputeArchetype(te); \n      COMPUTATION_CONTEXT ctx = new COMPUTATION_CONTEXT(); \n      TaxDTO td = new TaxDTO { id = te.id, taxparams = te.taxparams}; \n      ctx.Put(\"tax_cargo\",td); \n      bool rs = CommandDispatcher.Dispatch(archetype, ctx); \n      if ( rs ) { \n        TaxDTO temp = (TaxDTO)ctx.Get(\"tax_cargo\"); \n        tf.Liabilitytxt.Text =          \n        Convert.ToString(temp.taxparams.TaxLiability); \n        tf.Refresh(); \n      } \n    } \n\n```", "```cs\n    public class SeniorCitizenFemaleCommand : ComputationCommand \n    { \n      public bool Execute(COMPUTATION_CONTEXT ctx) \n      { \n        TaxDTO td = (TaxDTO)ctx.Get(\"tax_cargo\"); \n        //---- Compute the Tax for Senior Females \n        //---- They belong to different Slabs \n        double accum = td.taxparams.Basic + \n        td.taxparams.DA + td.taxparams.Allowance + \n        td.taxparams.HRA; \n        double net = accum - td.taxparams.Deductions - \n        td.taxparams.Surcharge; \n        //---- Flat 10% Tax \n        td.taxparams.TaxLiability = net*0.1; \n        td.taxparams.Computed = true; \n        return true; \n      } \n    } \n\n```", "```cs\n    <?xml version=\"1.0\"?> \n    <plugins> \n      <plugin archetype =\"OrindaryCitizen\"       \n      command=\"TaxEngine.OrdinaryCitizenCommand\"/>  <plugin    \n      archetype=\"SeniorCitizen\"      \n      command=\"TaxEngine.SeniorCitizenCommand\"/>  <plugin  \n      archetype=\"SeniorCitizenFemale\"      \n      command=\"TaxEngine.SeniorCitizenFemaleCommand\"/> \n    </plugins> \n\n```", "```cs\n    public interface ComputationCommand \n    { \n      bool PreExecute(COMPUTATION_CONTEXT ctx); \n      bool Execute(COMPUTATION_CONTEXT ctx); \n      bool PostExecute(COMPUTATION_CONTEXT ctx); \n    } \n\n```", "```cs\n    public class BaseComputationCommand : ComputationCommand \n    { \n      public virtual bool PreExecute(COMPUTATION_CONTEXT ctx) { return      \n      true;  }  public virtual bool Execute(COMPUTATION_CONTEXT ctx) {  \n      return true; } public virtual bool  \n      PostExecute(COMPUTATION_CONTEXT ctx) { return true; } \n    } \n\n```", "```cs\n    public class SeniorCitizenCommand : BaseComputationCommand { \n      public override bool PreExecute(COMPUTATION_CONTEXT ctx) \n      { \n        TaxDTO td = (TaxDTO)ctx.Get(\"tax_cargo\"); \n        //--- Do Some Sanity Checks \n        //--- if some problems => return false; \n        return base.PreExecute(ctx); \n      } \n      public override bool Execute(COMPUTATION_CONTEXT ctx) \n      { \n        TaxDTO td = (TaxDTO)ctx.Get(\"tax_cargo\"); \n        //---- Compute the Tax for Senior Citizens \n        //---- They belong to different Slabs \n        td.taxparams.TaxLiability = 1000; \n        td.taxparams.Computed = true; \n        return true; \n      } \n\n      public override bool PostExecute(COMPUTATION_CONTEXT ctx) \n      { \n        //--- Do the Check on Invariants \n        //--- Return false, if there is violation \n        return base.PostExecute(ctx); \n      } \n    } \n\n```", "```cs\n    public class SeniorCitizenFemaleCommand : BaseComputationCommand \n    { \n      public override bool Execute(COMPUTATION_CONTEXT ctx) \n      { \n        TaxDTO td = (TaxDTO)ctx.Get(\"tax_cargo\"); \n        //---- Compute the Tax for Senior Females \n        //---- They belong to different Slabs \n        double accum = td.taxparams.Basic + \n        td.taxparams.DA + td.taxparams.Allowance + \n        td.taxparams.HRA; \n        double net = accum - td.taxparams.Deductions - \n        td.taxparams.Surcharge; \n        //---- Flat 10% Tax \n        td.taxparams.TaxLiability = net*0.1; \n        return true; \n      } \n    } \n\n```", "```cs\n    public class CommandDispatcher \n    { \n      private static ObjectFactory obj = new      \n      ObjectFactory(\"Pluggins.xml\");  public static bool  \n      Dispatch(string archetype,    COMPUTATION_CONTEXT ctx) \n      { \n        ComputationCommand cmd = obj.Get(archetype); \n        if (cmd == null)  \n        return false; \n\n        if (cmd.PreExecute(ctx)) \n        { \n          bool rs = cmd.Execute(ctx); \n          cmd.PostExecute(ctx); \n          return rs; \n        } \n        return false; \n      } \n    } \n\n```", "```cs\n    public class TaxComputationFacade \n    { \n       /// <summary> \n       ///  A Rule Engine can do Archetype detection \n       ///  One can write a small Expression Evaluator Engine  \n       ///  and GOF terms its Interpreter pattern \n       /// </summary> \n       /// <param name=\"te\"></param> \n       /// <returns></returns> \n       private static string ComputeArchetype(TaxableEntity te) \n       { \n         if ((te.Sex == 'F') && (te.age > 59)) \n         { \n           return \"SeniorCitizenFemale\"; \n         } \n         else if (te.age<18) { \n           return \"JuevenileCitizen\"; \n         } \n\n         return (te.age > 60) ? \"SeniorCitizen\" : \"OrdinaryCitizen\"; \n       } \n\n       public static bool Compute(TaxableEntity te) \n       { \n         string archetype = ComputeArchetype(te); \n         COMPUTATION_CONTEXT ctx = new COMPUTATION_CONTEXT(); \n         TaxDTO td = new TaxDTO { id = te.id, taxparams = te.taxparams         \n         }; \n         ctx.Put(\"tax_cargo\", td); \n         return CommandDispatcher.Dispatch(archetype, ctx); \n       } \n    } \n\n```", "```cs\n    public static void ViewHandler(TaxCalcForm tf) \n    { \n      TaxableEntity te = GetEntityFromUI(tf); \n      if (te == null) \n      { \n        ShowError(); \n        return; \n      } \n      bool rs = TaxComputationFacade.Compute(te); \n      if (rs)  \n      { \n        tf.Liabilitytxt.Text =       \n        Convert.ToString(te.taxparams.TaxLiability); \n        tf.Refresh(); \n      } \n    } \n\n```"]