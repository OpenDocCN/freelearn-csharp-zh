- en: Chapter 6.  Sequences - The Core of Data Processing Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 序列 - 数据处理模式的核心
- en: 'In this chapter, we will take a deep dive into one of the most essential and
    utterly important arrangements of functional programming, that is, sequences.
    The ability to represent any data transformation as a composition of atomic functions
    applied to the elements of an arbitrary enumerable data container is a must for
    a functional programmer. The goal of this chapter is to help you acquire this
    mental skill. The way towards this goal is paved by the following topics covered
    here:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨函数式编程中最基本且至关重要的安排之一，即序列。将任何数据变换表示为应用于任意可枚举数据容器元素的原子函数的组合的能力是函数程序员必须具备的。本章的目标是帮助您获得这种心理技能。通往这一目标的道路是由以下在这里涵盖的主题铺就的：
- en: Review the basic data transformations and partition the immense host of standard
    library data transformation functions by handful of underlying processing patterns
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾基本数据变换，并将庞大的标准库数据变换函数按少量底层处理模式进行划分
- en: Consider the duality of sequence data generators being at once a data and an
    on-demand calculation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑序列数据生成器的双重性，即它们既是数据又是按需计算
- en: Cover how a sequence generalizes arbitrary collections by enumerating them,
    which represents the pull data transformation pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍序列如何通过枚举任意集合来泛化它们，这代表了拉数据变换模式
- en: Further consider just another pattern of using generated sequences for data
    drilling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步考虑使用生成序列进行数据钻取的另一种模式
- en: Wrap up by practically exploring how the usage of sequences affects the code
    performance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实际探索序列的使用如何影响代码性能来总结
- en: Basic sequence transformations
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本序列变换
- en: 'Let''s revisit the functional solution of the sample problem from [Chapter
    1](text00015.html#page "Chapter 1. Begin Thinking Functionally") , *Begin Thinking
    Functionally* . It represents the common functional pattern of *finding a given
    property of the collection* as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下[第1章](text00015.html#page "第1章. 开始函数式思考")中样本问题的函数式解决方案，*开始函数式思考*。它代表了寻找集合的给定属性的常见函数式模式，如下所示：
- en: From the given string literal representing 1000 consecutive single digit characters,
    make a collection of the collections represented by chunks of just five consecutive
    single digit characters of the original collection. Each chunk takes the inner
    characters of a five character-wide stencil aligned first with the left-hand side
    border of the string literal. The stencil then gets moved to the right by a single
    character before extracting the next sub collection. This sliding of the stencil
    to the right is continued until the right-hand side borders of both the stencil
    and the literal get aligned. To be exact, the main sequence consists of 996 such
    five character sub sequences.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从表示1000个连续单个数字字符的给定字符串字面量中，制作一个由原始集合中仅五个连续单个数字字符的块表示的集合集合。每个块取一个五字符宽的模板的内字符，首先与字符串字面量的左侧边界对齐。然后模板向右移动一个字符，提取下一个子集合。这种将模板向右滑动的过程一直持续到模板和字面量的右侧边界对齐。确切地说，主序列由996个这样的五字符子序列组成。
- en: Note that the originally sought-for property of the maximal product of five
    consecutive digits at this point is substituted with a similar property of the
    sequence of elements, each representing a candidate group from which the sought-for
    property originates. It is worth pointing out that in order to solve the original
    problem, *all* elements of this secondary sequence must be taken into account
    (other patterns may differ in this respect, for example, *finding any sequence
    element with a given property* ).
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，此时原本寻求的最大五个连续数字的乘积属性被替换为序列元素的类似属性，每个元素代表一个候选组，所寻求的属性源于该组。值得注意的是，为了解决原始问题，必须考虑这个次级序列的**所有**元素（其他模式可能在这方面有所不同，例如，**寻找具有给定属性的任何序列元素**）。
- en: Perform a complete scan of the substitute sequence, looking for the maximal
    value of the sought-for property, which is the product of the constituents of
    the inner sequence representing an element of the outer sequence that substitutes
    the original string literal.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对替代序列进行完整扫描，寻找所寻求属性的极大值，即代表替代原始字符串字面量的外序列元素的内部序列组成部分的乘积。
- en: Those of you who are attentive to detail may have already spotted the similarity
    of the preceding solution approach to the  **MapReduce** ([https://en.wikipedia.org/wiki/MapReduce](https://en.wikipedia.org/wiki/MapReduce)
    ) pattern, just without the possible partitioning and parallelization of the **map**
    phase for now. This similarity is not coincidental. After implementing a serious
    amount of F# **ETL** ([https://en.wikipedia.org/wiki/Extract,_transform,_load](https://en.wikipedia.org/wiki/Extract,_transform,_load)
    ) tasks, big and small for enterprise **Line of Business** ( **LOB** ) applications,
    I can conclude that the part of the F# core library covering basic operations
    upon enumerable sequences, namely the `Collections.seq` library module of the
    **Microsoft.FSharp.Collections** ([https://msdn.microsoft.com/en-us/library/ee353635.aspx](https://msdn.microsoft.com/en-us/library/ee353635.aspx)
    ) namespace, has already distilled the typical functional patterns of data sequence
    processing. Any effective F# developer should be conversant in representing a
    sought-for data transformation solution at hand into a combination of these library
    functions from `Collections.seq` .
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那些关注细节的人可能已经注意到了先前解决方案方法与**MapReduce**([https://en.wikipedia.org/wiki/MapReduce](https://en.wikipedia.org/wiki/MapReduce))模式的相似性，但现在还没有可能的**map**阶段的分区和并行化。这种相似性并非偶然。在为企业**业务线**（**LOB**）应用的大大小小的F#
    **ETL**([https://en.wikipedia.org/wiki/Extract,_transform,_load](https://en.wikipedia.org/wiki/Extract,_transform,_load))任务实施之后，我可以得出结论，F#核心库中涵盖枚举序列基本操作的这部分，即**Microsoft.FSharp.Collections**([https://msdn.microsoft.com/en-us/library/ee353635.aspx](https://msdn.microsoft.com/en-us/library/ee353635.aspx))命名空间下的`Collections.seq`库模块，已经提炼了数据序列处理的典型函数式模式。任何有效的F#开发者都应该能够将所需的数据转换解决方案表示为`Collections.seq`库中这些库函数的组合。
- en: Based on my own experience, this set of 70 library functions (for version 4.0
    of F#) is hard to grok when you consider it as a list that is just alphabetically
    ordered by the function name. It is hard to memorize what exactly this or that
    function is doing without distinguishing their commonalities and differences.
    This perception can be facilitated if we start seeing a certain data transformation
    pattern being implemented by each of these functions. These patterns stem from
    years of accumulated experience in applying functional programming to data processing
    and are coined into the selection of functions that the F# designers have slated
    for inclusion into the core library.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的个人经验，当将这些70个库函数（针对F# 4.0版本）视为按函数名称字母顺序排列的列表时，很难理解。如果不区分它们的共性和差异，很难记住这个或那个函数的确切功能。如果我们开始看到每个函数都实现了某种特定的数据转换模式，这种认识可能会得到加强。这些模式源于将函数式编程应用于数据处理多年的积累经验，并被F#设计者选定为包含到核心库中的函数集合。
- en: 'I believe that by observing the `Collection.seq` library constituents from
    this data processing pattern relationship angle, the following function groups
    can be distinguished:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，通过从数据处理模式关系的角度观察`Collection.seq`库的组成部分，可以区分以下函数组：
- en: '**Aggregates** : These functions traverse the sequence in its entirety, returning
    a single value calculated upon the sequence elements.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合函数**：这些函数遍历序列的整个范围，返回基于序列元素计算出的单个值。'
- en: '**Generators** : These functions produce sequences "out of thin air", or seriously,
    sequences of special kinds (such as empty typed sequence) and sequences defined
    either by a quantitative relation between the element and its sequence order number
    or just by a recurrently defined function deriving the next element based on the
    previous element(s).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器**：这些函数能够“凭空”生成序列，或者更确切地说，生成特殊类型的序列（例如空类型序列）和由元素与其序列顺序号之间的定量关系或仅由递归定义的函数（基于前一个元素生成下一个元素）定义的序列。'
- en: '**Wrappers and Type Converters** : These functions either wrap the entire sequence
    into a useful property (caching is a good example of a wrap) or just convert the
    sequence to other collection types (lists or arrays).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包装器和类型转换器**：这些函数要么将整个序列包装成有用的属性（缓存是包装的一个好例子），要么将序列转换为其他集合类型（列表或数组）。'
- en: '**Appliers** : These functions just traverse the sequence, applying the given
    calculation to each element for the sake of a side effect, for example, to print
    out sequence elements as strings.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用函数**：这些函数只是遍历序列，为了副作用（例如，将序列元素作为字符串打印出来）而将给定的计算应用于每个元素。'
- en: '**Recombinators** : These functions shuffle the sequence or extract its elements
    in a type-uniform manner; in other words, for a sequence of type `''T` dealing
    exclusively with `seq<''T>` or `''T` objects. For example, create a new sequence
    by skipping the first 100 elements of the original one.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重组器**：这些函数以类型一致的方式洗牌序列或提取其元素；换句话说，对于仅处理 `seq<''T>` 或 `''T` 对象的 `''T` 类型序列。例如，通过跳过原始序列的前100个元素来创建一个新的序列。'
- en: '**Filters** : These functions are concerned with the selection of elements
    that conform to an arbitrary condition(s). For example, try to find the first
    element of a sequence for which a given predicate function returns true.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤器**：这些函数关注于选择符合任意条件（的）元素。例如，尝试找到序列中第一个使给定谓词函数返回 true 的元素。'
- en: '**Mappers** : These functions change shape and/or the type of the original
    sequence(s) by producing a transformed sequence(s), for example, a zipping function
    that takes two input sequences and produces the single result sequence with each
    element being a tuple that combines elements from both input sequences sharing
    the same order number.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射器**：这些函数通过生成转换后的序列（例如，一个将两个输入序列组合成一个结果序列的压缩函数，每个元素都是一个元组，它结合了来自两个输入序列的相同顺序号的元素）来改变原始序列（的）形状和/或类型。'
- en: Equipped with this classification approach, I've partitioned the library functions
    by the following set of patterns. Under each pattern, all the relevant library
    functions are listed along with their signatures. I encourage you to explore the
    signatures in order to spot the commonalities responsible for each group formation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种分类方法，我将库函数按照以下模式集进行划分。在每个模式下，列出所有相关的库函数及其签名。我鼓励您探索这些签名，以发现导致每个分组形成的共性。
- en: Additional information for those of you who are eager to dig deeper is given
    in the `Ch6_1.fsx` script of this book's accompanying code, where the use of each
    of the library functions is illustrated by a brief code sample.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些渴望深入了解的读者，本书附带代码的 `Ch6_1.fsx` 脚本中提供了额外信息，其中通过简短的代码示例说明了每个库函数的使用。
- en: The aggregation pattern
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合模式
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The generation pattern
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成模式
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The wrapping and type conversion pattern
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包装和类型转换模式
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The application pattern
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用模式
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The recombination pattern
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重组模式
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The filtering pattern
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤模式
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The mapping pattern
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射模式
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The sequence: Duality of data and calculation'
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列：数据和计算的二元性
- en: What makes the F# sequence so ambient and versatile is its dual nature. Being
    a strongly typed generic data collection, it exposes the contained data via two
    archetypal .NET interfaces of the `System.Collections.Generic` namespace, namely
    `IEnumerable<T>` ([https://msdn.microsoft.com/en-us/library/9eekhta0(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/9eekhta0(v=vs.110).aspx)
    ) and `IEnumerator<T>` ([https://msdn.microsoft.com/en-us/library/78dfe2yb(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/78dfe2yb(v=vs.110).aspx)
    ).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: F# 序列之所以如此灵活和通用，是因为其双重特性。作为一个强类型泛型数据集合，它通过 `System.Collections.Generic` 命名空间中的两个典型
    .NET 接口暴露包含的数据，即 `IEnumerable<T>` ([https://msdn.microsoft.com/en-us/library/9eekhta0(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/9eekhta0(v=vs.110).aspx)
    ) 和 `IEnumerator<T>` ([https://msdn.microsoft.com/en-us/library/78dfe2yb(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/78dfe2yb(v=vs.110).aspx)
    )。
- en: 'These interfaces personify the classic data pull protocol, where a data consumer
    actively pulls data from the producer. Indeed, the type of `seq<''T>` in the F#
    is defined as the following abbreviation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口体现了经典的数据拉取协议，其中数据消费者主动从生产者那里拉取数据。实际上，F# 中 `seq<'T>` 的类型被定义为以下缩写：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding line of code means in practice that each F# sequence is a data
    collection, which can be traversed by getting an *enumerator* that allows you
    to stir through the sequence from its head towards its tail, obtaining the values
    of its elements. The enumerator itself can be obtained using the `GetEnumerator()`
    method of the `IEnumerable<'T>` interface.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码在实践中意味着每个 F# 序列都是一个数据集合，可以通过获取一个允许您从序列的头部向尾部遍历的 *枚举器* 来遍历，从而获得其元素的值。枚举器本身可以通过
    `IEnumerable<'T>` 接口的 `GetEnumerator()` 方法获得。
- en: 'With the enumerator, which in turn implements the `IEnumerator<''T>` interface,
    the sequence can be traversed using the pair of members that constitute this interface:
    the `Current` property, which gets the value of the sequence element at the current
    position of the enumerator, and the `MoveNext()` method, which advances the position
    of the enumerator to the next element of the sequence.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用枚举器，它反过来实现了`IEnumerator<'T>`接口，可以通过构成此接口的成员对序列进行遍历：`Current`属性，它获取枚举器当前位置的序列元素的值，以及`MoveNext()`方法，它将枚举器的位置推进到序列的下一个元素。
- en: Rather boring, right? Well, it might be boring when being applied to *materialized*
    data collections such as the F# list, where all elements exist in the physical
    memory space. However, nothing in the preceding scheme insists upon the element
    materialization! It doesn't require much mental effort to imagine `IEnumerator<'T>`
    being implemented by a calculation that returns the freshly constructed value
    of `'T` in response to getting the `Current` property, and for `MoveNext()` ,
    it just advances the imaginable current position marker of the sequence. The whole
    arrangement is *immaterial* with regard to the memory space occupied by elements,
    as there is no need to keep more than just one materialized `Current` element,
    right? With that, you just rediscovered the inner workings of the F# sequences!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 很无聊，对吧？好吧，当应用于如 F# 列表这样的*实例化*数据集合时，其中所有元素都存在于物理内存空间中，可能确实很无聊。然而，前面的方案中没有任何内容坚持要求元素实例化！想象`IEnumerator<'T>`通过计算来返回`'T`的新构造值，以响应获取`Current`属性，对于`MoveNext()`，它只是推进序列的可想象当前位置标记。整个安排在元素占用的内存空间方面是*非实例化的*，因为不需要保留除一个实例化的`Current`元素之外的内容，对吧？有了这个，你刚刚重新发现了
    F# 序列的内部工作原理！
- en: Sequence as a lazy data collection
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列作为懒数据收集
- en: The F# sequences do not eagerly materialize data elements in the memory. This
    feature aligns very well with the data pull protocol. That is, the current sequence
    element is not required unless the sequence enumerator has reached its position
    in the sequence after a series of `MoveNext()` method invocations and the element
    value has been demanded via getting the enumerator's `Current` property.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: F# 序列不会在内存中积极实例化数据元素。这个特性与数据拉取协议非常吻合。也就是说，除非序列枚举器在一系列`MoveNext()`方法调用后到达序列中的位置，并且通过获取枚举器的`Current`属性来要求元素值，否则当前序列元素是不需要的。
- en: However, in order to really master the F# sequences, it is important that you
    understand its nuances. In particular, it is important to be aware of whether
    sequence elements are materialized or not. If a sequence has been calculated on
    the enumerator's demand and is not being converted from a materialized collection,
    such as a list or an array, or is not cached, then there is normally no backing
    memory where sequence element values are persisted. On the contrary, if a sequence
    has been produced from a concrete collection by a library function, for example,
    `Seq.ofList` , then at least one instance of the original list must be present
    for the entire lifespan of the derived collection, as this list can be completely
    arbitrary and no way exists to recreate it from scratch in a manner similar to
    a sequence being re-enumerated multiple times if the re-enumeration is cheap and
    performance considerations do not prompt for caching.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了真正掌握 F# 序列，了解其细微差别非常重要。特别是，重要的是要意识到序列元素是否被实例化。如果一个序列是在枚举器的请求下计算的，并且没有从实例化的集合（如列表或数组）或未缓存的内容转换，那么通常没有后端内存来持久化序列元素值。相反，如果一个序列是通过库函数（例如，`Seq.ofList`）从一个具体集合生成的，那么在派生集合的整个生命周期中，至少必须存在原始列表的一个实例，因为这个列表可能是完全任意的，并且没有方法可以从头开始以类似重新枚举多次的方式重新创建它，如果重新枚举成本低且性能考虑不要求缓存的话。
- en: Sequence as a calculation
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列作为计算
- en: As I've just mentioned, a sequence can be an enumeration atop a concrete data
    collection where the enumerator is implemented on the collection's side. However,
    more interesting cases represent sequences that have an enumerator that programmatically
    generates sequence elements upon the traversal pull demand. These might be different,
    syntactically sugared forms as sequence comprehensions, sequence computation expressions,
    or standard library functions representing the *generator pattern* considered
    at the beginning of the chapter. As a last resort, a sequence can be brought to
    life in a fully de-sugared manner by implementing some required interfaces. The
    last approach is the most tedious and error-prone; however, it grants unprecedented
    flexibility in comparison to other methods. In a majority of development situations,
    the custom sequence enumerator implementation is unwarranted; however, there might
    be some situations where there is simply no alternative to the custom implementation.
    This topic will be my next subject.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我刚才提到的，一个序列可以是一个具体数据集合上的枚举，枚举器在集合的一侧实现。然而，更有趣的情况是，序列具有一个枚举器，该枚举器在遍历拉取请求时程序性地生成序列元素。这些可能是不同的、语法糖化的形式，如序列推导式、序列计算表达式，或者代表章节开头考虑的*生成器模式*的标准库函数。作为最后的手段，可以通过实现一些必需的接口以完全去糖化的方式使序列变得活跃。这种方法最为繁琐且容易出错；然而，与其他方法相比，它提供了前所未有的灵活性。在大多数开发情况下，自定义序列枚举器实现是不必要的；然而，可能存在一些情况下，没有其他替代方案，只能采用自定义实现。这个主题将是我的下一个主题。
- en: Sequence as an enumerator interface wrapper
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列作为枚举器接口包装器
- en: Although implementing a custom sequence is a tedious task, it's not rocket science.
    I'm going to walk you through the process and make you *understand* it. No matter
    how simple or complex the custom sequence is, the implementation process will
    be the same.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实现自定义序列是一项繁琐的任务，但并非高不可攀。我将带你了解整个过程，让你*理解*它。无论自定义序列多么简单或复杂，实现过程都是相同的。
- en: 'To begin with, what do you think defines the sequence behavior? Apparently,
    it is not syntactic constructions used for sequence traversing, and it does not
    matter whether it''s sugared or not sugared. All implementation specifics are
    abstracted by the entity standing behind any sequence (and even more broadly,
    behind any .NET collection): the **enumerator** . Enumerator is a class that must
    implement the previously mentioned strongly typed interface `IEnumerator<''T>`
    ([https://msdn.microsoft.com/en-us/library/78dfe2yb(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/78dfe2yb(v=vs.110).aspx)
    ) of the `System.Collections.Generic` namespace. In turn, `IEnumerator<''T>` inherits
    from two other interfaces: the routine `System.IDisposable` interface and the
    legacy untyped `IEnumerator` interface of the `System.Collections` namespace.
    (Pay attention to the difference between typed `System.Collections.Generic` and
    untyped `System.Collections` namespaces). `IEnumerator<''T>` overrides the `Current`
    property and inherits the `MoveNext()` and `Reset()` methods of the `IEnumerator`
    interface. As these relationships between involved components are quite intricate,
    I have provided a component relationship diagram in the following figure to facilitate
    comprehension:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你认为什么定义了序列的行为？显然，它不是用于序列遍历的语法结构，也不论它是否是语法糖化的。所有实现细节都被任何序列背后的实体（以及更广泛地，任何.NET集合背后的实体）抽象化：**枚举器**。枚举器是一个必须实现之前提到的强类型接口`IEnumerator<'T>`的类（[https://msdn.microsoft.com/en-us/library/78dfe2yb(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/78dfe2yb(v=vs.110).aspx)）的`System.Collections.Generic`命名空间。反过来，`IEnumerator<'T>`从两个其他接口继承：`System.IDisposable`接口和`System.Collections`命名空间中的传统无类型`IEnumerator`接口。（注意强类型`System.Collections.Generic`和无类型`System.Collections`命名空间之间的区别）。`IEnumerator<'T>`重写了`Current`属性，并继承了`IEnumerator`接口的`MoveNext()`和`Reset()`方法。由于涉及组件之间的关系相当复杂，我在以下图中提供了一个组件关系图，以帮助理解：
- en: '![Sequence as an enumerator interface wrapper](img/Image00023.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![序列作为枚举器接口包装器](img/Image00023.jpg)'
- en: The relationship between components constituting the F# sequence implementation
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 构成F#序列实现的组件之间的关系
- en: 'Considering these intricacies, the implementation plan for any custom F# sequence
    is as following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些复杂性，任何自定义F#序列的实现计划如下：
- en: Provide a custom `Enumerator` class for the sequence that implements `System.Collections.Generic.IEnumerator<'T>`
    , `System.Collections.IEnumerator` , and `System.IDisposable` interfaces. For
    the first interface, just implement an override of the `Current` property, and
    the rest of the implementation goes into nongeneric `IEnumerator` .
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为序列提供一个自定义的`Enumerator`类，该类实现了`System.Collections.Generic.IEnumerator<'T>`、`System.Collections.IEnumerator`和`System.IDisposable`接口。对于第一个接口，只需实现`Current`属性的覆盖，其余的实现进入非泛型`IEnumerator`。
- en: Provide a factory function that is similar to the `GetEnumerator()` methods
    of generic .NET collections that have a `unit ->` `System.Collections.Generic.IEnumerator<'T>`
    signature. This function constructs the requested instance of the enumerator passing
    through its own arguments directly to the constructor, then it upcasts the constructed
    instance into `System.Collections.Generic.IEnumerator<'T>` and returns the result
    as a function of the previously listed signature.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个类似于泛型.NET集合的`GetEnumerator()`方法的工厂函数，这些方法具有`unit -> System.Collections.Generic.IEnumerator<'T>`签名。此函数通过将其自己的参数直接传递给构造函数来构建请求的枚举器实例，然后将构建的实例向上转换为`System.Collections.Generic.IEnumerator<'T>`，并将结果作为之前列出的签名的一个函数返回。
- en: Provide another factory function, this time to build a sought-for sequence out
    of the function built in Step 2.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供另一个工厂函数，这次是从第2步中构建的函数构建所需的序列。
- en: 'As this may still sound a bit complicated, let''s take a quick walk-through.
    I want us to implement the easiest thing: a strongly typed empty sequence, which
    is a sequence without elements, when its enumerator does not have anything to
    enumerate.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这仍然可能听起来有点复杂，让我们快速浏览一下。我想让我们实现最简单的事情：一个强类型空序列，这是一个没有元素的序列，当其枚举器没有可以枚举的内容时。
- en: At the same time, apparently, it must be a normal sequence similar to any other
    native sequence from .NET libraries or a sugared one constructed with the F# language
    facilities or core libraries. Let's do this.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，显然，它必须是一个类似于.NET库中任何其他原生序列的正常序列，或者是一个使用F#语言设施或核心库构建的糖化序列。让我们这样做。
- en: Step 1 - The custom enumerator implementation
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步 - 自定义枚举器实现
- en: 'The behavior of an empty sequence is pretty straightforward: both typed and
    untyped versions of the `Current` property never have a chance to work as any
    attempt to enumerate empty sequence must immediately terminate; `MoveNext()` always
    returns `false` , indicating that the end of the sequence has already been reached.
    Expressed in the F# code, these considerations are shown in the following snippet
    (`Ch6_2.fsx` ):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 空序列的行为相当直接：`Current`属性的类型化和无类型版本永远不会有机会工作，因为尝试枚举空序列必须立即终止；`MoveNext()`总是返回`false`，表示已经达到序列的末尾。用F#代码表达，这些考虑在以下片段（`Ch6_2.fsx`）中显示：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As mentioned earlier, `System.Collections.Generic.IEnumerator<'T>` overrides
    `Current` and inherits `MoveNext()` and `Reset()` of `System.Collections.IEnumerator`
    . Both `Current` properties use the typed default value; the `Current` property
    of the untyped enumerator boxes this default value according to the specification.
    Step 1 is now complete.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`System.Collections.Generic.IEnumerator<'T>`覆盖了`Current`，并继承自`System.Collections.IEnumerator`的`MoveNext()`和`Reset()`。两个`Current`属性都使用类型化的默认值；无类型枚举器的`Current`属性根据规范将此默认值装箱。第1步现在已完成。
- en: Step 2 - The custom enumerator factory
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 - 自定义枚举器工厂
- en: 'Step 2 is quite simple, especially in our case, where the implemented sequence
    does not have any specifics to be communicated to the enumerator at the time of
    construction as shown in the following code (`Ch6_2.fsx` ):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步相当简单，特别是在我们这种情况下，实现的序列在构建时没有需要传达给计数器的特定信息，如下面的代码（`Ch6_2.fsx`）所示：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Step 2 is now complete too.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步也已完成。
- en: Step 3 - The custom sequence factory
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步 - 自定义序列工厂
- en: 'This one is a breeze, thanks to the great **object expressions** ([https://msdn.microsoft.com/en-us/library/dd233237.aspx](https://msdn.microsoft.com/en-us/library/dd233237.aspx)
    ) feature of the F# as shown (`Ch6_2.fsx` ):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现很简单，多亏了F#的伟大**对象表达式**（[https://msdn.microsoft.com/en-us/library/dd233237.aspx](https://msdn.microsoft.com/en-us/library/dd233237.aspx)）功能，如下所示（`Ch6_2.fsx`）：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here we go; it is easy to spot that this particular piece does not in any way
    depend on the produced sequence and is a good candidate to be a member of a Helpers
    library. The implementation is complete.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里开始了；很容易看出这个特定的部分在任何方面都不依赖于生成的序列，并且是作为Helpers库成员的好候选。实现已经完成。
- en: 'Now is a perfect moment to give it a test drive to check whether everything
    is really OK and that I did not miss anything. The results of a concise testing
    are reflected in the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是进行测试的最佳时机，以检查一切是否真的正常，并且我没有遗漏任何东西。简洁测试的结果反映在以下屏幕截图上：
- en: '![Step 3 - The custom sequence factory](img/Image00024.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 3 - 自定义序列工厂](img/Image00024.jpg)'
- en: Testing the implemented empty sequence
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 测试实现的空序列
- en: 'The empty sequence is created with the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 空序列使用以下代码创建：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then some checks are performed as shown:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照以下方式进行一些检查：
- en: '`ss |> Seq.isEmpty` , as expected, returns `true`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ss |> Seq.isEmpty`，正如预期的那样，返回 `true`'
- en: '`ss |> Seq.length` , as expected, equals `0`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ss |> Seq.length`，正如预期的那样，等于 `0`'
- en: An attempt to skip some elements with `ss |> Seq.skip 10` fails with the expected
    diagnostics
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ss |> Seq.skip 10` 跳过一些元素的操作以预期的诊断失败
- en: 'Before we switch to the next topic, I want to reiterate this: the de-sugared
    custom sequence implementation using bare .NET interfaces is not much fun. The
    good thing about it is that in most situations, you simply do not need to descend
    to this level. Syntactically sugared language constructions and core library functions
    will do the same job. However, once in a while, you will need to do something
    special, such as counting the number of times your code traverses a sequence,
    and this technique will be at your service.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们切换到下一个主题之前，我想重申这一点：使用裸 .NET 接口去糖化的自定义序列实现并不有趣。它的好处是，在大多数情况下，你根本不需要下降到这个层面。语法糖化的语言构造和核心库函数会完成同样的工作。然而，偶尔，你需要做一些特别的事情，比如计算你的代码遍历序列的次数，这项技术将为你提供服务。
- en: Sequence of an indefinite length as a design pattern
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不定长度的序列作为设计模式
- en: 'The conventional engineering vision of data transformations is that they occur
    over finite collections materialized in the memory, hence allowing these collections
    to be enumerated with `Seq.length` , yielding a number of elements. However, the
    F# sequences (as well as .NET `IEnumerable<T>` per se) grant the following generalization:
    in some cases, a more math-centric vision might be useful, which suggests looking
    at sequences as countable but not necessarily finite.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 数据转换的传统工程视角是它们在内存中物化的有限集合上发生，因此允许使用 `Seq.length` 对这些集合进行枚举，从而得到元素的数量。然而，F# 序列（以及
    .NET `IEnumerable<T>` 本身）提供了以下泛化：在某些情况下，一个更以数学为中心的视角可能更有用，这表明将序列视为可计数的但不一定是有限的。
- en: 'A meticulous reader may immediately object that the  *countable* entity, when
    applied to practical computing, is necessarily finite because eventually, it is
    limited by underlying physical hardware, which comes out in boundary values, for
    example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个细致的读者可能会立即提出异议，即当应用于实际计算时，*可计数的*实体必然是有限的，因为最终它受底层物理硬件的限制，这在边界值中体现出来，例如：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, I would oppose this objection by saying that this mere consideration
    does not in any way limit the length of the F# sequences that might be produced.
    As a proof, let's implement at the low level without using any F# syntactic sugar
    the **repeater** , or sequence that when being given an element of any type returns
    the endless repetition of the given element.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我会通过以下说法反对这种异议：这种简单的考虑方式在任何方面都不会限制可能产生的 F# 序列的长度。作为证明，让我们在不使用任何 F# 语法糖的情况下在低级别实现
    **repeater**，或者序列，当被赋予任何类型的元素时，返回给定元素的无限重复。
- en: 'I will begin with a plain vanilla `IEnumerator<''T>` implementation as shown
    in the following code (`Ch6_3.fsx` ):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从以下代码（`Ch6_3.fsx`）中展示一个简单的 `IEnumerator<'T>` 实现开始：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding snippet is quite straightforward. The `Repeater<'T>` type defines
    a class with which the single default constructor obtains the element to be repeated
    as `repeated` and persists it within the class instance as `_repeated` .
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段相当直接。`Repeater<'T>` 类型定义了一个类，该类通过单个默认构造函数获取要重复的元素作为 `repeated`，并将其持久化在类的实例中作为
    `_repeated`。
- en: Then, as a fulfillment of the `System.Collections.Generic.IEnumerator<'T>` contract,
    this interface is implemented with the single property `Current` returning the
    persisted `_repeated` value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，作为实现 `System.Collections.Generic.IEnumerator<'T>` 协议的一部分，该接口通过单个属性 `Current`
    返回持久化的 `_repeated` 值。
- en: 'Then, the implementation of the nongeneric `System.Collections.IEnumerator`
    interface follows with its three contract methods. Here is the place where the
    desired sequence behavior is coined: the `Current` untyped property also returns
    a persisted `_repeated` value, but this time, it''s boxed according to the contract,
    yielding `obj` . The `MoveNext()` method, as Energizer Bunny says, should keep
    going, going, going... so that it always returns `true` , which means that the
    next element is available no matter what. The `Reset()` legacy method is just
    a stub.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，非泛型的 `System.Collections.IEnumerator` 接口的实现紧随其后，包括其三个合同方法。这就是期望的序列行为被定义的地方：`Current`
    无类型属性也返回一个持久化的 `_repeated` 值，但这次，它根据合同进行装箱，产生 `obj`。正如能量兔所说，`MoveNext()` 方法应该持续进行，持续进行……以至于它总是返回
    `true`，这意味着无论什么情况下，下一个元素都是可用的。`Reset()` 旧方法只是一个占位符。
- en: Finally, a bogus implementation of `System.IDisposable` that is required by
    the `IEnumerator<'T>` contract completes the implementation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个符合 `IEnumerator<'T>` 合同要求的 `System.IDisposable` 的虚假实现完成了实现。
- en: 'Now, for the usage convenience, I add a thin wrapper that upcasts the implemented
    interface of `Repeater<''T>` to the explicit `System.Collections.Generic.IEnumerator<''T>`
    as shown in the following code (`Ch6_3.fsx` ):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，为了方便使用，我添加了一个薄薄的包装器，将实现的 `Repeater<''T>` 接口向上转换为显式的 `System.Collections.Generic.IEnumerator<''T>`，如下面的代码所示
    (`Ch6_3.fsx`):'
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, a generic `makeSeq` shim function provides the conversion of any `IEnumerator<''T>`
    into the corresponding `seq<''T>` sequence by implementing both generic and nongeneric
    flavors of `IEnumerable` as shown in the following code (`Ch6_3.fsx` ):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，一个通用的 `makeSeq` 适配函数通过实现如以下代码所示的通用和非通用版本的 `IEnumerable`，将任何 `IEnumerator<''T>`
    转换为相应的 `seq<''T>` 序列 (`Ch6_3.fsx`):'
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, the `enumerator` argument provides the underlying `IEnumerator<'T>` for
    both implementations of `IEnumerable` constituting an arbitrary F# `seq` .
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`enumerator` 参数为构成任意 F# `seq` 的 `IEnumerable` 的两种实现提供了底层的 `IEnumerator<'T>`。
- en: 'It''s time for field tests! Executing the freshly created `makeSeq` function
    with three different arguments that represent the `repeat ''.''` , `repeat 42`
    , and `repeat` `"Hooray!"` enumerators in FSI yields sequences of indefinite length
    of the corresponding types, as demonstrated in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进行实地测试了！在 FSI 中执行新创建的 `makeSeq` 函数，使用代表 F# 中的 `repeat '.'`、`repeat 42` 和
    `repeat` `"Hooray!"` 枚举器的三个不同参数，可以得到相应类型的无限长序列，如下面的屏幕截图所示：
- en: '![Sequence of an indefinite length as a design pattern](img/Image00025.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![不定长序列作为设计模式](img/Image00025.jpg)'
- en: Generating sequences of indefinite length
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 生成不定长序列
- en: 'However, how can we prove that these sequences are indeed of indefinite length?
    Ironically, only by counting elements: if for any indiscriminately big number,
    the sequence yields that many elements, then that is the proof that these sequences
    are of indefinite length. Unfortunately, this is exactly where we hit the already
    mentioned counting problem: counting might be effectively limited by the underlying
    hardware.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们如何证明这些序列确实是不定长的呢？讽刺的是，只有通过计数：如果对于任何任意大的数字，序列返回那么多元素，那么这就是证明这些序列是不定长的证据。不幸的是，这正是我们遇到了已经提到的计数问题：计数可能被底层硬件有效限制。
- en: But wait a minute; .NET provides a numeric type that, for all practical purposes,
    represents an arbitrarily large countable **System.Numerics.BigInteger** ([https://msdn.microsoft.com/en-us/library/system.numerics.biginteger(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.numerics.biginteger(v=vs.110).aspx)
    ). So, it would be nice to base the counting on this type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等；.NET 提供了一种数值类型，在所有实际应用中，它代表了一个任意大的可计数 `System.Numerics.BigInteger` ([https://msdn.microsoft.com/en-us/library/system.numerics.biginteger(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.numerics.biginteger(v=vs.110).aspx))。所以，基于这种类型进行计数将是非常好的。
- en: 'Assuming that you are not afraid of challenges, it would be a good exercise
    to implement a generic technique of counting not limited by standard `int` . For
    F#, this task is not very complicated. I would suggest the following idiomatic
    approach (`Ch6_3.fsx` ):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '假设你并不害怕挑战，实现一个不限于标准 `int` 的泛型计数技术将是一个很好的练习。对于 F# 来说，这个任务并不复杂。我建议以下惯用方法 (`Ch6_3.fsx`):'
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `traverse` counting function is inlined in order to allow the compiler to
    build the compiled code aligned with the type on argument `n` picked for the counting.
    The `n` argument of `traverse` represents the amount of elements expected to be
    generated. The second `traverse` argument `s` represents a generic unlimited sequence
    generator. `makeSeq` with a given generic repetitive element makes a perfect second
    argument for `traverse` .
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许编译器构建与用于计数的参数 `n` 对应的类型对齐的编译代码，`traverse` 计数函数被内联。`traverse` 的 `n` 参数表示预期生成的元素数量。`traverse`
    的第二个参数 `s` 代表一个通用的无限序列生成器。`makeSeq` 与给定的通用重复元素一起，是 `traverse` 的完美第二个参数。
- en: The sequence counting enumerator can be elegantly expressed as `Seq.zip` zipping
    together the presumably unlimited length sequence of `makeSeq` and a limited length
    sequence that has exactly the expected arbitrarily large (within boundaries that
    the underlying type allows) number of elements. As zipping stops upon reaching
    the end of the shorter sequence, the `counter` value represents exactly the desired
    enumerator obtained from the zipper expression result.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 序列计数枚举器可以优雅地表示为 `Seq.zip`，将 `makeSeq` 的可能无限长序列与具有恰好预期任意大（在底层类型允许的范围内）元素数量的有限长序列组合在一起。由于组合在到达较短序列的末尾时停止，`counter`
    值正好代表从组合表达式结果中获得的所需枚举器。
- en: 'Finally, I traverse the obtained enumerator until it stops yielding elements
    keeping track of the last traversed element. This `last` element, which is apparently
    a tuple of the last element number and the unbound sequence element, is returned
    as the evidence of arbitrary length. The following screenshot demonstrates how
    the field tests passed. The first test shows how `traverse` worked with the `BigInteger`
    counter; the second test just illustrates how to produce the sequence that is
    10 elements longer than `System.Int32.MaxValue` :'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我遍历获取到的枚举器，直到它停止产生元素，同时记录最后一个遍历的元素。这个 `last` 元素显然是最后一个元素编号和未绑定序列元素的元组，它作为任意长度证据被返回。以下截图展示了如何通过字段测试。第一个测试显示了
    `traverse` 与 `BigInteger` 计数器一起工作的情况；第二个测试仅说明了如何生成比 `System.Int32.MaxValue` 长出
    10 个元素的序列：
- en: '![Sequence of an indefinite length as a design pattern](img/Image00026.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![不定长序列作为设计模式](img/Image00026.jpg)'
- en: Checking out unlimited sequence workings
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 检查无限序列的工作原理
- en: Another interesting experiment would be to generate a sequence longer than `System.Int64.MaxValue`
    , which I leave to you as an exercise. My only concern is the time duration it
    may take to complete. My rough estimate shows that at the rate of 1,000,000 elements
    traversed per second, it would take no less than the next 29 centuries to complete;
    so, some serious revisions of the method and optimizations of the implementation
    may be due.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的实验可能是生成一个长度超过 `System.Int64.MaxValue` 的序列，这个实验就留给你作为练习了。我唯一关心的是完成这个实验可能需要的时间。我的粗略估计显示，以每秒遍历
    1,000,000 个元素的速度，至少需要 29 个世纪才能完成；因此，可能需要对方法和实现进行一些重大的修改和优化。
- en: Generating the F# sequences
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成 F# 序列
- en: As you had a chance to notice recently, generating sequences with the de-sugared
    .NET way has a fair amount of moving parts and, frankly, is not the best *one
    fits all* use case. Fortunately, F# provides enough support through syntactic
    sugar as well as library functions, making the generation of sequences of finite
    and infinite lengths a breeze. Let's take a peek at them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你最近有机会注意到的，使用去糖化的 .NET 方式生成序列有很多组成部分，坦白说，并不是最佳的全能用例。幸运的是，F# 通过语法糖以及库函数提供了足够的支持，使得生成有限和无限长度的序列变得轻而易举。让我们来看看它们。
- en: Sequence comprehensions
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列推导式
- en: Sequence comprehensions allow you to represent a sequence as a special kind
    of expression, namely **sequence expression** ([https://msdn.microsoft.com/en-us/library/dd233209.aspx](https://msdn.microsoft.com/en-us/library/dd233209.aspx)
    ). Or, the other way around, sequence expression, when being evaluated, yields
    a sequence.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 序列推导式允许你将序列表示为一种特殊类型的表达式，即 **序列表达式** ([https://msdn.microsoft.com/en-us/library/dd233209.aspx](https://msdn.microsoft.com/en-us/library/dd233209.aspx)
    )。或者反过来，当序列表达式被评估时，它会产生一个序列。
- en: Sequence comprehensions may take plenty of forms. We'll be discussing some that
    are typical.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 序列推导式可以有多种形式。我们将讨论一些典型的形式。
- en: Ranges
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 范围
- en: 'These are the simplest forms of comprehensions, producing sequences from ranges.
    Observe that ranges are not limited to just numeric ones; any type supporting
    the `''get_One''` operator is fine too as shown here (`Ch6_4.fsx` ):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最简单的推导式形式，从范围生成序列。观察到的范围不仅限于数字；任何支持 `'get_One'` 操作符的类型都行，如下所示（`Ch6_4.fsx`）：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Maps
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 映射
- en: 'These expressions generalize ranges by allowing the projection of one or more
    enumerations into something of another type. Also, note that the enumeration definition
    can be very flexible: from a simple range to nested enumerations to just another
    sequence as shown here (`Ch6_4.fsx` ):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表达式通过允许将一个或多个枚举投影到另一种类型中，从而泛化了范围。此外，请注意，枚举定义可以非常灵活：从简单的范围到嵌套枚举，再到如这里所示（`Ch6_4.fsx`）的另一个序列：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Arbitrary sequence expressions
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 随意序列表达式
- en: 'All sequence comprehensions represent the idiomatic F# syntax sugar related
    to the extremely powerful mechanism of **computation expressions** ([https://msdn.microsoft.com/en-us/library/dd233182.aspx](https://msdn.microsoft.com/en-us/library/dd233182.aspx)
    ), in particular, providing a convenient syntax for dreaded *M-word things* ,
    also known as **monads** . **Computation expressions** represent the extremely
    powerful F# pattern of sequencing and combining computations. They may be custom
    built; however, F# also offers some built-in computation expressions: along with
    **sequence expressions** , there are **asynchronous workflows** and **query expressions**
    as well. I will be covering built-in computation expressions in the upcoming chapters
    of this book.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所有序列推导式都代表了与极其强大的 **计算表达式** 机制相关的 F# 语法糖（[https://msdn.microsoft.com/en-us/library/dd233182.aspx](https://msdn.microsoft.com/en-us/library/dd233182.aspx)），特别是，为令人讨厌的
    *M-word things* 提供了方便的语法，也称为 **单子**。**计算表达式**代表了 F# 中极其强大的顺序和组合计算的模式。它们可以是自定义构建的；然而，F#
    还提供了一些内置的计算表达式：除了 **序列表达式** 之外，还有 **异步工作流** 和 **查询表达式**。我将在本书的后续章节中介绍内置的计算表达式。
- en: 'Arbitrary sequence expressions are just computations wrapped by `seq { and
    }` tokens, although in contrast to the  **ranges** and **maps** covered earlier,
    computations can be pretty much anything. Two constructs within sequence expression
    tokens play a special role as shown here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 随意序列表达式只是由 `seq { and }` 符号包裹的计算，尽管与前面提到的 **范围** 和 **映射** 相比，计算可以是几乎任何内容。序列表达式符号内的两个结构在此处扮演着特殊角色，如下所示：
- en: '`yield <expression>` makes the expression value the next element of the final
    sequence'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield <expression>` 使表达式值成为最终序列的下一个元素'
- en: '`yield! <sequence expression>` (reads *yield-bang* ) appends the sequence expression
    operand to the end of the final sequence'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield! <sequence expression>`（读作 *yield-bang*）将序列表达式操作数追加到最终序列的末尾'
- en: The presence of `yield!` turns arbitrary sequence expressions into extremely
    powerful data transformations. In particular, as `seq {...}` is still an expression,
    being used as a return value of recursive functions, this pattern allows you to
    extremely succinctly and elegantly implement sequences of finite and infinite
    length, in particular, easily turn any finite sequence into an infinite circular
    one, which is often very convenient for the partitioning of other sequences through
    the element markup.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield!` 的存在将任意序列表达式转变为极其强大的数据转换。特别是，由于 `seq {...}` 仍然是一个表达式，可以用作递归函数的返回值，这种模式允许你极其简洁和优雅地实现有限和无限长度的序列，特别是，可以轻松地将任何有限序列转换为无限循环序列，这对于通过元素标记对其他序列进行分区通常非常方便。'
- en: Enough words; let's look at some code!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 言归正传；让我们看看一些代码！
- en: 'I begin with a sample demonstrating how the entire pattern match construct
    can be nested into a sequence expression in order to detect when the sequence
    should halt. The following snippet produces a descending sequence of an integer
    from any non-negative number down to zero (`Ch6_4.fsx` ):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我从一个示例开始，演示如何将整个模式匹配结构嵌套到序列表达式中，以检测序列何时应该停止。以下代码片段生成从任何非负整数到零的递减整数序列（`Ch6_4.fsx`）：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note how generation halting is achieved by returning `unit` instead of yielding
    the next element.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过返回 `unit` 而不是产生下一个元素，实现了生成停止。
- en: 'So far, so good. Now let''s generate just an endless sequence of alternating
    strings as shown (`Ch6_4.fsx` ):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。现在让我们生成一个交替字符串的无尽序列，如下所示（`Ch6_4.fsx`）：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To wrap up the theme, look at how elegantly the circularization of any arbitrary
    sequence can be achieved as shown here (`Ch6_4.fsx` ):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结这个主题，看看如何优雅地实现任何任意序列的循环化，如下所示（`Ch6_4.fsx`）：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Deserves two bangs that are required in the definition above to arrange the
    circularization indeed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 需要上面定义中要求的两个感叹号来安排确实的循环化。
- en: Library functions generating sequences
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成序列的库函数
- en: Now I turn to the support for sequence generation that the F# core libraries
    provide.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我转向F#核心库提供的序列生成支持。
- en: Seq.init
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Seq.init
- en: 'This method is for sequences of predefined length as the length sits right
    in the function signature. This is quite a simple function that assumes but does
    not prescribe a projection of the current element number. Here goes a sample with
    a projection of the sequence number in a string performed in the **tacit** ([https://en.wikipedia.org/wiki/Tacit_programming](https://en.wikipedia.org/wiki/Tacit_programming)
    ) manner (`Ch6_4.fsx` ):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法适用于长度预定义的序列，因为长度直接位于函数签名中。这是一个相当简单的函数，它假设但不指定当前元素数的投影。以下是一个示例，展示了以字符串形式在**隐式**([https://en.wikipedia.org/wiki/Tacit_programming](https://en.wikipedia.org/wiki/Tacit_programming))方式执行的序列号投影(`Ch6_4.fsx`)：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Seq.initInfinite
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Seq.initInfinite
- en: 'This function is very similar to the previous one, but it is missing the first
    argument indeed, as shown here (`Ch6_4.fsx` ):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与上一个非常相似，但它确实缺少第一个参数，如这里所示(`Ch6_4.fsx`)：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Pretty much nothing has changed, but the underlying abstraction is more powerful
    than the finite variant. Unfortunately, the power of abstraction can be easily
    hurt by the implementation limitation that shrewd F# programmers may guess: it
    has only as many element sequence numbers as the hardware architecture allows.
    This is easy to check with the following little hack (`Ch6_4.fsx` ):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有什么变化，但底层抽象比有限变体更强大。不幸的是，抽象的力量很容易受到实现限制的伤害，精明的F#程序员可能会猜到：它只有硬件架构允许的那么多元素序列号。这可以通过以下简单的技巧轻松检查(`Ch6_4.fsx`)：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Ouch, it hurts!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，这真让人痛苦！
- en: Seq.unfold
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Seq.unfold
- en: 'The `Seq.unfold` library function, which concludes the matter of sequence generation,
    is my favorite. Instead of bothering with sequence numbers, its projection function
    unwraps the recurrent relationship between the current and the next element. It
    also demonstrates a very smart manner of addressing the halt problem by prescribing
    the projection result as `option` when returning `None` signals to stop generating
    further elements. Let''s look at this library function in action using rather
    worn down by bloggers and Academia **Fibonacci numbers** ([https://en.wikipedia.org/wiki/Fibonacci_number](https://en.wikipedia.org/wiki/Fibonacci_number)
    ) as an example shown here (`Ch6_4.fsx` ):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Seq.unfold`库函数，作为序列生成问题的终结，是我最喜欢的。它不像其他函数那样需要处理序列号，其投影函数展开当前元素与下一个元素之间的递归关系。它还通过在返回`None`时将投影结果指定为`option`来非常巧妙地解决了停止问题。让我们通过以下示例来看看这个库函数的实际应用，这里使用了博客作者和学术界常用的**斐波那契数列**([https://en.wikipedia.org/wiki/Fibonacci_number](https://en.wikipedia.org/wiki/Fibonacci_number))，如这里所示(`Ch6_4.fsx`)：'
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After some years of using F#, I'm still excited what clarity of intent it allows!
    The projection function literally explains itself, so I do not have anything to
    add.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几年的F#使用，我仍然对它所允许的意图清晰感到兴奋！投影函数字面上就解释了自己，所以我没有什么要补充的。
- en: Sequence and the code performance
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列和代码性能
- en: 'Sequences are, without doubt, extremely powerful members of the functional
    programmer tool belt. However, they are not free of *gotchas* that may hurt the
    performance badly. It is best that they are known and avoided. A few of them are
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，序列是函数式程序员工具箱中极其强大的成员。然而，它们并非没有可能严重影响性能的“陷阱”。最好了解并避免它们。以下是一些例子：
- en: Unfortunate materialization, which may be either unnecessary/premature elements
    materialization or the other way around, missing elements materialization.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不幸的实例化，可能是不必要的/过早的元素实例化，或者相反，缺少元素实例化。
- en: Data laziness, in concert with the non-preserving once current element values,
    can severely hurt the performance in a situation where the algorithm requires
    multiple traversals or where calculating elements is expensive. The developer
    should be able to compensate for these detrimental factors by applying patterns
    such as **caching** and/or **memoization** .
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据惰性，与当前元素值不保留一起，在算法需要多次遍历或计算元素成本高昂的情况下，可能会严重损害性能。开发者应该能够通过应用诸如**缓存**和/或**记忆化**等模式来补偿这些有害因素。
- en: Often, when composing data processing pipelines, the developer may carelessly
    use a library function that unexpectedly requires them to enumerate the entire
    sequence. This is not necessarily a bad thing, but it should be used sparingly.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，在组合数据处理管道时，开发者可能会不小心使用一个意外需要他们枚举整个序列的库函数。这并不一定是一件坏事，但应该谨慎使用。
- en: With all the aesthetic beauty of sequences of indefinite length, if misdemeanors
    mentioned in the previous bullet point just hurt the performance of finite length
    sequences, the first such negligence upon an indefinite length sequence simply
    *kills!* Beware and proceed with due caution when dealing with unlimited length
    sequences!
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果前面提到的违规行为只是伤害了有限长度序列的性能，那么对无限长度序列的第一次这种疏忽就会简单地将它**杀死**！在处理无限长度序列时，务必小心谨慎！
- en: Sequence caching
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列缓存
- en: F# language creators were nice enough to provide an out-of-the-box tool for
    caching, namely the `Seq.cache` library function. It should be used in a situation
    where lazy materialization is not a killer, but element generation is not cheap
    and repetitive enumerations are really required. Let me demonstrate how easy putting
    caching to work would be.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: F#语言创建者足够友好，提供了一个现成的缓存工具，即`Seq.cache`库函数。它应该在懒加载不是杀手锏，但元素生成成本不低且重复枚举确实需要的情况下使用。让我演示一下使用缓存是多么简单。
- en: 'To begin with, I need an indicator of the enumerator consumption. This is not
    complicated for those who already have experience working with sequence guts.
    Let''s slightly modify our good old `makeSeq` function as following (`Ch6_5.fsx`
    ):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我需要一个枚举器消耗的指示器。对于那些已经与序列内部结构有经验的人来说，这并不复杂。让我们稍微修改一下我们古老的`makeSeq`函数，如下所示（`Ch6_5.fsx`）：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we are ready to see how the caching works as shown here (`Ch6_5.fsx` ):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备看到缓存是如何工作的，如下所示（`Ch6_5.fsx`）：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First, in the absence of any caching, `Seq.sum` and `Seq.length` each imposed
    an independent sequence traversal, which the presence of two enumerator alerts
    confirms.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在没有缓存的情况下，`Seq.sum`和`Seq.length`各自强制执行了独立的序列遍历，这一点由两个枚举器的存在得到了证实。
- en: Then, after wrapping the working sequence with `Seq.cache` , I repeat the calculation
    using the wrapper sequence. As expected, we notice only a single enumerator alert
    to populate the cache; the second traversal did not leave any traces as it went
    through the cache.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在用`Seq.cache`包装工作序列之后，我重复使用包装序列进行计算。不出所料，我们注意到只有一个枚举器警告来填充缓存；第二次遍历在通过缓存时没有留下任何痕迹。
- en: To be sure, just reissue the calculation. Now, all the data come from the cache,
    and no traversals of the original sequence take place at all.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，只需重新进行计算。现在，所有数据都来自缓存，根本不会对原始序列进行任何遍历。
- en: The fusion of sequence transformations
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列变换的融合
- en: 'I want to wrap up this chapter by demonstrating a pattern known as **fusion**
    . It is not conceptually difficult: imagine that you have a composition of functions
    that collectively transform a data sequence. At some point, your implementation
    requires multiple traversals of the sequence. However, the compiler in principle,
    or the human in practice, may optimize the transformation, so multiple traversals
    have now fused into just the single one.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我想通过展示一个被称为**融合**的模式来结束这一章。在概念上并不困难：想象一下，你有一个函数的组合，它共同转换数据序列。在某个时刻，你的实现需要多次遍历序列。然而，编译器原则上，或者人类在实践中，可能会优化转换，因此多次遍历现在融合成了单一的一次。
- en: 'Let''s perform fusion in practice, reusing our `makeSeq` implementation as
    the indicator of obtaining enumerators as shown in the following code (`Ch6_5.fsx`
    ):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在实践中进行融合，重用我们的`makeSeq`实现作为获取枚举器的指示符，如下面的代码所示（`Ch6_5.fsx`）：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding naive implementation of `average` traverses the sequence twice,
    of which the enumeration alerts give the evidence.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的天真实现中的`average`遍历了序列两次，枚举警告提供了证据。
- en: 'However, rewriting the implementation of `average` less naively as `averageFused`
    ends up in the fusion of these traversals as shown in the following code (`Ch6_5.fsx`
    ):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将`average`的实现重写为`averageFused`（不那么天真），最终导致这些遍历的融合，如下面的代码所示（`Ch6_5.fsx`）：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The single enumeration alert confirms my statement completely.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 单一的枚举警告完全证实了我的说法。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covers one of the cornerstones of the F# data processing, namely
    sequences. The existing F# core sequence library allows you to apply all typical
    patterns of functional data processing.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 F# 数据处理的基础之一，即序列。现有的 F# 核心序列库允许你应用所有典型的函数式数据处理模式。
- en: When you feel an urge to implement just another custom function for sequence
    processing, the first thing you need to do is determine which known pattern groups
    it would belong to and then check twice whether this function is really not implemented
    already or whether it can be simply composed from the remaining library functions.
    Recollect the *Minimizing moving parts over hiding them*  section from [Chapter
    1](text00015.html#page "Chapter 1. Begin Thinking Functionally") , *Begin Thinking
    Functionally* . Core libraries are minimalistic sets of such high-quality parts,
    so sticking to them eventually positively influences the quality and readability
    of your code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当你迫切想要实现另一个用于序列处理的定制函数时，你需要做的第一件事是确定它属于哪个已知的模式组，然后仔细检查两次这个函数是否真的尚未实现，或者是否可以简单地由剩余的库函数组合而成。回想一下[第1章](text00015.html#page
    "第1章. 开始函数式思考")中的*最小化移动部件而非隐藏它们*部分，*开始函数式思考*。核心库是这类高质量部件的最小化集合，因此坚持使用它们最终会积极影响代码的质量和可读性。
- en: You obtained plenty of details about the inner workings of the F# sequences
    and should now be able to produce sequences by a variety of means by dealing,
    when appropriate, with conceptually clean sequences of indefinite length.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经获得了大量关于 F# 序列内部工作原理的细节，现在应该能够通过多种方式生成序列，在适当的时候处理概念上干净的、不定长度的序列。
- en: Finally, I provided some sequence performance clues and considerations accompanied
    by some practical optimization coding, leaving you in a good position for further
    mastery.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我提供了一些序列性能提示和考虑因素，并伴随一些实用的优化编码，使你能够为进一步掌握打下良好的基础。
- en: In the next chapter, I will revisit the subject of functions as you should now
    be ready to pick up some advanced techniques on top of the already acquired skills.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将重新探讨函数的主题，因为你现在应该准备好在已经掌握的技能之上学习一些高级技术。
