- en: '*Chapter 4*: Variables, Lists, and Functions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter builds on multiple concepts that were introduced in [*Chapter 2*](B17597_02_Final_PG_ePub.xhtml#_idTextAnchor031)*,*
    *Knots, Diverts, and Looping Patterns*. In the first topic, we will examine how
    the keyword `VAR` works with a single value in ink, and how it can be combined
    with `LIST` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: In ink, we can group variables into a concept called a list. We will also examine
    how to create and change the values that are part of a list. We will then review
    when they are best used in a project and situations where multiple, single variables
    might work better. This discussion will move us on to the next topic, where we
    will look at working with functions.
  prefs: []
  type: TYPE_NORMAL
- en: Values that are part of a list can be changed by other concepts called **functions**.
    In the third topic, we will *call* some of the built-in functions to work with
    different list values. These will allow us to perform actions across a list, such
    as determining the number of entries or picking one out at random. Working with
    functions will help us prepare for the next step, which is creating functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the last topic, we will explore how to create our functions in ink. As we
    will see, functions allow us to define small tasks or series of actions we can
    use multiple times by calling the created function. Functions, as we will learn,
    are special forms of **knots** in ink. This means we can send data to a function
    as well as a knot. However, only functions can return data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing values using `VAR`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with `LIST`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making new functions and calling knots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The examples used in this chapter, in `*.ink` files, can be found online on
    GitHub: [https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter4](https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter4).'
  prefs: []
  type: TYPE_NORMAL
- en: Storing values using VAR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](B17597_02_Final_PG_ePub.xhtml#_idTextAnchor031), *Knots, Diverts,
    and Looping Patterns*, variables were introduced as a part of using labeled options
    within the weaves of looping structures in ink. By creating a label, an option
    could record whether it had been shown before. This allowed us to keep track of
    the number of loops within a knot easily. Within ink, labeled options are one
    form of a more general concept for storing and changing any kind of value. This
    more general form uses a special keyword: **VAR**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `VAR` keyword creates a variable that''s capable of storing different types
    of data. Variables created with the `VAR` keyword can store numbers (including
    decimal values), `true` or `false` values), and even diverts. Variables created
    using the `VAR` keyword are also *global*: they can be accessed by any code that
    is part of the overall project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable names that use the `VAR` keyword in ink follow the same rules as that
    of knots and stitches:'
  prefs: []
  type: TYPE_NORMAL
- en: They can contain numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can contain uppercase and lowercase letters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only special symbol that's allowed is an underscore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Like the naming conventions for knots and stitches, an underscore is often
    used between words within the name of the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1 (Example1.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Variables are given values by an operation called `=`) to assign the variable
    the value following the sign on the same line. It is common to include a single
    space between the name of the variable, the equals sign (`=`), and the value being
    assigned to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one explicit rule that must always be followed when using the `VAR`
    keyword and assigning a variable its initial value: whatever the value is, it
    must be static. In ink, this means that the first assignment of any variable cannot
    be a combination of other, existing values or the result of code performing mathematical
    operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Once created, however, the value of the variable can be changed, but the initial
    assignment must always exist first and not be the result of any computation.
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we will learn how to show and change variable values. Because
    alternatives (covered in [*Chapter 3*](B17597_03_Final_PG_ePub.xhtml#_idTextAnchor048),
    *Sequences, Cycles, and Shuffling Text*) produce values, we will also explore
    how to save what they produce and use that value as part of additional code.
  prefs: []
  type: TYPE_NORMAL
- en: Showing variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The use of opening, `{`, and closing, `}`, curly brackets in ink signals the
    use of code. When combined with the name of a variable, ink will substitute the
    value of the variable as part of the surrounding text. This allows an author to
    use variables as part of the text and have ink switch the name of the variable
    with its value in its final output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2 (Example2.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When the code in *Example 2* is run, ink creates a variable named `reader_name`.
    Next, it sets the variable to the value of `"Dan"`. When it encounters the text,
    ink understands that the curly brackets are code and switches the name of the
    variable for its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Screenshot of ink''s output for Example 2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.1_B17597.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Screenshot of ink's output for Example 2
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of curly brackets signals the use of *any* code in ink. This means
    that mathematical operations can also be performed inside curly brackets on variables.
    ink will substitute the resulting value as part of the final output, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 3 (Example3.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Example 3*, there are two variables. Each holds a separate, numerical value.
    When ink encounters the use of curly brackets, it substitutes the value of each
    variable with its name. Next, because the curly brackets also contain the addition
    symbol, ink adds the two numbers together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Screenshot of ink''s output for Example 3'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.2_B17597.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Screenshot of ink's output for Example 3
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the types of data involved, mathematical operations may not always
    produce the expected output based on experiences with other programming and scripting
    languages. For example, operations such as addition (using the plus symbol, `+`),
    subtraction (using the hyphen, `-`), multiplication (using the asterisk, `*`),
    and division (using the forward slash, `/`) will all work on numerical values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 4 (Example4.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Using mathematical operations with numerical and string values will produce
    errors. The only valid way to use mathematic symbols with string values is to
    use the plus symbol (`+`). This performs the **concatenation** operation: when
    a numerical or string value is *added* to an existing string value, it produces
    a new string value, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 5 (Example5.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When the code in *Example 5* is run, ink creates a variable with a string value.
    However, when it encounters text and curly brackets, it does not perform mathematics.
    Instead, it *concatenates* the value of the `example_string` variable with the
    number `3`. This produces a combination of both values in its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Screenshot of ink''s output for Example 5](img/Figure_4.3_B17597.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Screenshot of ink's output for Example 5
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move to the next part and understand how to update variables.
  prefs: []
  type: TYPE_NORMAL
- en: Updating variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Variables can change values. Once a variable is created in ink using the `VAR`
    keyword, it can be accessed and its value can be changed at any point within the
    same code. However, while ink understands that the initial assignment of a variable
    must be separate from text, we must use a special symbol when changing the value
    of a variable: a tilde (`~`). For example, we can create a variable using the
    `VAR` keyword and then change its value later in the same code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 6 (Example6.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If a line of code starts with a tilde (`~`), this lets ink know that some type
    of code will occur on this single line. For example, when an initial value is
    assigned to the variable, ink understands something code-related will be following
    the tilde (`~`).
  prefs: []
  type: TYPE_NORMAL
- en: We can create variables using the `VAR` keyword and update them with code lines
    starting with a tilde (`~`). However, as we saw in [*Chapter 3*](B17597_03_Final_PG_ePub.xhtml#_idTextAnchor048),
    *Sequences, Cycles, and Shuffling Text*, **alternatives** allow us to generate
    a value from a set. As we will see in the next section, we can save the generated
    value in variables and use it in later parts of the same code.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the current values of alternatives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Alternatives** were introduced in [*Chapter 3*](B17597_03_Final_PG_ePub.xhtml#_idTextAnchor048),
    *Sequences, Cycles, and Shuffling Text*. They are used to generate *alternative*
    text content based on the number of times they had been accessed during looping
    structures. Because alternatives generate text, their output can also be saved
    in variables:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 7 (Example7.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Instead of needing to rerun an alternative to generate new text, a **shuffle**
    can have its output saved for future use. This allows the value to be incorporated
    into other code without the need to recreate the alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives generate content when they're run. This means that they cannot
    be used as part of the initial assignment of a variable in ink. The reason for
    this is that ink handles the creation of variables *before* it runs any alternatives.
    The generated values of any alternative do not exist when variables are created
    initially. Because of this, a common pattern is to create a variable with an initial
    value and then overwrite this value with the generated output of an alternative
    later in the code.
  prefs: []
  type: TYPE_NORMAL
- en: In *Example 7*, quotation marks enclose the use of a shuffle alternative to
    create a string value. When run, the shuffle will generate a value that will then
    become a string, based on the quotation marks around it. As a string value, it
    will then be able to be used with the assignment line with the tilde (`~`).
  prefs: []
  type: TYPE_NORMAL
- en: Saving the output of an alternative in ink always requires at least two lines
    of code. The first is used to create a variable using the `VAR` keyword with its
    initial value, while the second is reassigned its value to what is generated by
    the alternative when the code is run. As was explained in the introduction to
    the *Storing values using VAR* topic, the explicit rule for using the `VAR` keyword
    is that the initial value must exist when the variable is created. The output
    that's produced by an alternative is considered dynamic, and the initial value
    of a variable using the `VAR` keyword must be static.
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we worked with single values. We started by creating new variables
    using the `VAR` keyword and then learned how to update their values with lines
    beginning with tildes (`~`). We also explored how the output from an alternative
    can be saved, but that the variable must be set to an initial value and then updated
    to the dynamic output produced by the alternative. In the next topic, we will
    build on the use of variables and create a collection of them using a new keyword
    called `LIST`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with LIST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each use of the `VAR` keyword creates a single value. In many projects, a handful
    of single values would be enough to track anything needed while running. However,
    there are contexts where a set of values might be needed. For these cases, ink
    has a special keyword called **LIST** that creates a *list* of possible values.
  prefs: []
  type: TYPE_NORMAL
- en: The values of a list can be thought of as possible *states* of its variable.
    For example, for a `LIST` named `days_of_week`, possible values might be the 7
    days of the week. These could be defined with `LIST` itself and then assigned
    as needed instead of the need to use string values for each day of the week.
  prefs: []
  type: TYPE_NORMAL
- en: In ink, a list defines a new collection of values within the context of the
    project. Once created, the values of a list can act as possible values for other
    variables using the `VAR` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: However, while powerful in its ability to create new possible values for variables,
    the values that are created have some limitations and often need extra functionality
    to perform some common operations that are available to other types of data in
    ink. (`LIST` functions will be covered in the *Using LIST functions* section,
    later in this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we will begin by creating a list of values. We will explore how
    to use the `LIST` keyword to create this collection. Then, we will change the
    values that are part of the collection by following the same pattern that we learned
    about for working with single values.
  prefs: []
  type: TYPE_NORMAL
- en: Making a LIST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A new list can be created by using the `LIST` keyword. On a line starting with
    the `LIST` keyword, the name of the list is followed by the equals sign (`=`),
    and its values are separated by commas. The name of a list, as with other variables
    in ink, must only contain numbers, letters, and an underscore character. It cannot
    contain other special symbols or spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the use of the `VAR` keyword, when values are assigned to a list, spaces
    are ignored, including additional new, empty lines between one value and the next.
    Variables that are created by the `VAR` keyword must be defined on a single line.
    The values of a list can be spread across multiple lines:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 8 (Example8.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Example 8*, a list was created with seven possible values. Next, one of
    its values, `Monday`, was assigned to the variable that was created with the `VAR`
    keyword. Finally, the last line of code shows the value of `day`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Screenshot of ink''s output for Example 8'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.4_B17597.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Screenshot of ink's output for Example 8
  prefs: []
  type: TYPE_NORMAL
- en: Like with a variable created with the `VAR` keyword, the values of a list, once
    created, can also be updated. This follows the pattern that we introduced as part
    of the *Updating variables* section. To update a list or one of its values, as
    we will learn in the next section, a line starting with a tilde (`~`) is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Updating LIST values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While values, as shown in *Example 8*, can seemingly be shown, the output that
    was created was the name of the value, `Monday`, and not the string, `"Monday"`.
    Regarding the output of a project, this is a small but important difference between
    a variable using the `VAR` keyword and those as part of a collection using the
    `LIST` keyword: only `LIST` values can be added to a list. To add a new value
    to an existing list, it must have been created by itself or another list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 9 (Example9.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Example 9*, the `Fish` value could be *added* to `current_pets` because
    it was created as part of another list, `all_pets`. This illustrates one of the
    major problems with using values from a list: while they can be very useful for
    introducing new possible values to a project, they must be defined before they
    can be accessed. Any new list is dependent on values that were previously defined
    or created within its assignment. However, it is possible to change the value
    to another type of data in ink:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 10 (Example10.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Example 10*, each of the values of the `standing_with_family_members` list
    is also assigned a number. This is allowed in ink and can be a useful way to create
    specific values of a list associated with numerical values in a project. However,
    accessing these numbers requires understanding another ink concept: **functions**.'
  prefs: []
  type: TYPE_NORMAL
- en: Calling functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Functions** are a foundational part of most programming languages. In ink,
    a function is a subset of code that can accept input separated by commas, may
    produce output, and can be accessed through an operation called **calling**.'
  prefs: []
  type: TYPE_NORMAL
- en: A function is *called* by using its name and then opening (`(`) and closing
    (`)`) parentheses. The operation of calling a function in ink temporarily moves
    the flow of the story to the code of a function and then returns it when the code
    finishes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Functions can only be called when used within code in ink. This means they either
    appear within opening and closing curly brackets or on lines starting with the
    tilde (~) as part of variable reassignment.
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we will start by reviewing some functions that are built into
    ink and how they can help us with common operations. Next, we will look at functions
    that have been designed to work exclusively with values created with the `LIST`
    keyword. These functions perform common operations on a list, such as letting
    us know the number of entries within it or picking a random entry from its collection.
  prefs: []
  type: TYPE_NORMAL
- en: Common mathematics functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most used functions in ink is `RANDOM()`. It accepts a minimum and
    a maximum whole number. It then picks a random number within the range specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'For many role-playing games, a common need is a number within a certain range,
    such as between 1 and 4 or 1 and 20\. The `RANDOM()` function allows us to set
    a range and then view the outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 11 (Example11.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When the *Example 11* code is run, ink will encounter a set of curly brackets.
    It will then see the `RANDOM()` function with a minimum of 1 and a maximum of
    20\. Each time it is run, a different number in this range will be chosen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Screenshot of ink''s output for Example 11](img/Figure_4.5_B17597.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Screenshot of ink's output for Example 11
  prefs: []
  type: TYPE_NORMAL
- en: 'ink also has functions for converting between different types of numbers. The
    `INT()` function converts a decimal number into a whole (integer) number, while
    the `FLOAT()` function converts an integer into a decimal (float) number. Each
    accepts a single number and produces the output of a different type of number:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 12 (Example12.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The values that are produced by functions can be saved in variables. This allows,
    for example, the use of the `RANDOM()` function and its value, which has been
    saved as part of a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 13 (Example13.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The *Example 13* code contains two variables and two uses of the same function.
    As was mentioned at the start of the *Storing values using VAR* topic, variables
    must start with a static value. In the *Example 13* code, each variable is initially
    assigned a value of `0`. They are immediately reassigned a value that's generated
    by the `RANDOM()` function. However, as part of the explicit rule with variables
    that are created using the `VAR` keyword, they must be set to a static value before
    they can be reassigned a dynamic variable that's been generated by a function
    such as `RANDOM()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When run, the *Example 13* code creates the necessary variables and reassigns
    their values from a call to the `RANDOM()` function with a minimum of `1` and
    a maximum of `6`. When ink encounters the text and use of curly brackets, it adds
    the two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Screenshot of ink''s output for Example 13'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.6_B17597.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – Screenshot of ink's output for Example 13
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  prefs: []
  type: TYPE_NORMAL
- en: Like using a shuffle alternative and the `VAR` keyword, the output of the `RANDOM()`
    function cannot be used as the initial value of a variable. It must be created
    first, and then reassigned the value produced by `RANDOM()`.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, there are multiple built-in functions in ink for working with
    single values. This is also true of values that are created using the `LIST` keyword.
    In the next section, we will review some of the functions that have been designed
    specifically for lists and their values.
  prefs: []
  type: TYPE_NORMAL
- en: Using LIST functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While there are functions that have been designed for a single value, most
    built-in functions in ink are used with a list. These all start with the  `LIST_`
    prefix and have the action or operation they perform or access as the second word.
    For example, to count the number of included values within a list, the `LIST_COUNT()`
    function can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 14 (Example14.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, the *Example 14* code creates a list containing seven values. In
    the curly brackets is a call to the `LIST_COUNT()` function. This function is
    then passed the `days_of_week` list. Based on the lines that were used in the
    assignment of the list, the default assumption would be that the output will be
    `7` based on the number of days in the list. However, this is not the case. Its
    output is `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Screenshot of ink''s output for Example 14](img/Figure_4.7_B17597.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Screenshot of ink's output for Example 14
  prefs: []
  type: TYPE_NORMAL
- en: The output produced by *Example 14* shows a hidden aspect of working with values
    from a list. Technically, all the values for creating a list are known as a `true`
    or `false` and by default, all values are set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of the `LIST_COUNT()` function *counts* the number of `true` values
    within the list. In *Example 14*, there are none. The count that was produced
    by the function is correct. To change a value from its default of `false` to `true`,
    it needs to be enclosed in opening (`(`) and closing (`)`) parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 15 (Example15.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In *Example 15*, the output includes the number `7`. This is correct. Each value
    within the list from *Example 14* is now enclosed within its own set of parentheses,
    changing its value from `false` to `true` for each.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the cases where every value, regardless of being `true` or `false`, is
    wanted from a list, the `LIST_ALL()` function returns *all* values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 16 (Example16.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Example 16*, the use of the `LIST_ALL()` function returns all the values
    that are currently part of the `days_of_week` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Screenshot of ink''s output for Example 16'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.8_B17597.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – Screenshot of ink's output for Example 16
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LIST_RANDOM()` function returns a random entry regarding the total number
    of `true` values in a list, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 17 (Example17.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In *Example 17*, only the `Monday`, `Tuesday`, and `Wednesday` values are set
    to `true`. The other values of `days_of_week`, because they are set to `false`
    by default, cannot be accessed by `LIST_RANDOM()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the code from *Example 10*, the `LIST_VALUE()` function can be
    used to access any data that''s been assigned to a value as part of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 18 (Example18.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this improved version of *Example 10*, known as *Example 18*, the `LIST_VALUE()`
    function can be used to access the data that's been assigned to the `sister` value.
  prefs: []
  type: TYPE_NORMAL
- en: While ink has many functions for performing different options, both mathematically
    and with the values of a list, it also provides authors with the ability to create
    their own. In the next topic, we will review how to create and call functions.
  prefs: []
  type: TYPE_NORMAL
- en: Making new functions and calling knots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Calling functions* topic introduced functions for accepting input, possibly
    producing output, and explained how ink's built-in functions can be called.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to create new functions in ink using the `function` keyword.
    Any new functions created in ink can be used like any others, and they are often
    a useful way to create separate lines of code that can be used across a project
    or multiple times without the need to write the same code again.
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we will explore how to create new functions using the `function`
    keyword. We will learn how they can be called, perform a small task, and even
    potentially return data. In [*Chapter 2*](B17597_02_Final_PG_ePub.xhtml#_idTextAnchor031)*,*
    *Knots, Diverts, and Looping Patterns*, we discussed knots initially. Different
    sections of a story are defined by a name. In ink, functions, as we will learn,
    are special types of knots. This relationship means knots can also be *called*
    and *passed* data.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function is created in ink using at least two equals signs (`=`), the `function`
    keyword, the name of the function, and then the opening (`(`) and closing (`)`)
    parentheses, which are put around its input (if any). The name of a function follows
    the same rules as variables and knots: they can contain numbers, letters, and
    an underscore character. They cannot contain other special symbols or spaces.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like variables, functions are also *global* in ink. They can be accessed by
    any other code within the project once they have been created. Because both variables
    and functions are global, a common pattern is to design a function that changes
    a single variable. This allows an author to define an action that takes place
    when calling the function, such as increasing or decreasing its current value:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 19 (Example19.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Example 19* uses three different functions. The first, `decreaseMoney()`,
    accepts a value called `amount`. This is an example of a **parameter**. When creating
    a function, different variables can be defined within its open and closing parentheses.
    These are known as its *parameters*, and they affect how it performs calculations
    or processes.'
  prefs: []
  type: TYPE_NORMAL
- en: When a function is called, the data that's passed to it is called its `decreaseMoney()`,
    that has a parameter and receives a single argument, and two functions, `increaseApples()`
    and `increaseOranges()`, that do not accept arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The placement of the `increaseApples()` and `increaseOranges()` functions also
    matches a common pattern in ink where functions for adjusting the values of variables
    are found at the bottom of the code. Because both are global, which means they
    can be accessed from anywhere in the project, functions can be defined anywhere
    in the project.
  prefs: []
  type: TYPE_NORMAL
- en: However, functions, like their sister concept knots, define themselves as being
    all the lines between when they start and the next knot or function. Placing them
    at the bottom of a file prevents issues where code might be confused or considered
    part of another knot or function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions are not the only concepts able to define parameters and accept arguments.
    In ink, **knots** can also be called as if they were functions. This is because
    functions are special types of knots that can return data. This also marks the
    difference between them. A knot can accept data, but only a function can return
    data. However, using knots in this way allows us to easily track values within
    a looping structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 20 (Example20.ink):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There is a single variable within *Example 20* that's created as a parameter
    of the `time_machine` knot. Before the loop starts, the `RANDOM()` function is
    used to select a value within the range of `20` to `80`. This value is passed
    to the knot in the first loop. Whenever the player selects the `loop` value is
    increased by one and its current value is passed to the `time_machine` knot. On
    any future loops, the `loop` variable is increased by one, and it sends its current
    value into the next loop.
  prefs: []
  type: TYPE_NORMAL
- en: The code in *Example 20* also shows how variables can be used without the `VAR`
    keyword. Within the knot, the `loop` variable exists as a parameter. This means
    it exists as a variable, but only within the `time_machine` knot. When used in
    this way, the `loop` variable will not be global. As a part of the `time_machine`
    knot, the `loop` variable cannot be used outside of its code.
  prefs: []
  type: TYPE_NORMAL
- en: Functions are a powerful concept in ink. However, they do have two major limitations
    compared to working with knots. The first is that functions cannot use choices
    of any kind. Functions cannot branch a story and must *return* to where they were
    called when they are finished. The second limitation is that functions cannot
    divert to another section of a story. Like the first limitation, a function should
    only perform a small task or change a value.
  prefs: []
  type: TYPE_NORMAL
- en: Calling knots as if they were functions can be very useful for many projects.
    However, unlike functions, knots cannot return values. As shown in *Example 20*,
    it is possible to use knots for some, but not all, of the same purposes as functions
    in ink. Authors must consider whether a function or a knot is a better way to
    complete a task or present information. If the goal is to process data and return
    a value, a function is best. If data is to be passed, options must be presented,
    or the story may divert in some way, a knot is the better way to organize your
    code and data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned more about how variables work, and how they can
    be created using the `VAR` keyword. With multiple types of data, variables must
    be created using static values. They can then be changed through an operation
    called assignment using lines starting with a tilde (`~`) for writing a single
    line of code.
  prefs: []
  type: TYPE_NORMAL
- en: In the second topic, for the cases where we needed multiple values, we saw that
    the `LIST` keyword can be used. This keyword allows us to create values other
    variables can use, but also comes with the limitations that only values created
    with `LIST` can be used with a list. We also examined how all the values of a
    list are part of a Boolean set and have either `true` or `false` values upon creation.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the third topic, we investigated how functions work in ink. With several
    built-in functions, we can create random numbers or convert between types of numbers.
    With `LIST` values, we compared the results of `LIST_COUNT()` and `LIST_ALL()`
    by examining how to change the values of a list from `true` to `false` when they
    are created.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the last topic, we wrote some functions with the `function` keyword
    to perform simple tasks, such as adjusting the value of a variable. Because both
    variables were created using the `VAR` keyword and functions are global, we saw
    that a common pattern is to use a function to change the value of a variable.
    As part of this topic, we also revisited knots and learned that functions are
    special types of knots. This allows both to receive data using parameters, though
    only a function can return data.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see in the coming chapters on combining ink and Unity, understanding
    how values are stored and accessed in ink will be vital to creating a unified
    project. We must understand how ink works with different values across both those
    created using the `VAR` keyword and the `LIST` keyword before we can work with
    code in Unity. By understanding the relationship between variables and functions,
    we can begin to write ink code and, much later, run it alongside C# code in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, [*Chapter 5*](B17597_05_Final_PG_ePub.xhtml#_idTextAnchor077)*,*
    *Tunnels and Threads*, we will look at the last two major concepts in ink: **tunnels**
    and **threads**. Using many of the concepts introduced over the last four chapters,
    we will use tunnels to create advanced structures in ink with very little code.
    With threads, we will break up a digital story into even more parts and have ink
    combine everything for us as a reader is diverted from one knot to another. This
    will create an intricate narrative experience based on understanding and managing
    story flow between sections of a story.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the operation called where a variable gets a value?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the operation called when a string is created by "adding" two other
    strings or a string and a number together?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the tilde (`~`) used with variables and code in ink?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What kind of set are the values of a list?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the technical term for a variable that's created as part of a function
    or knot and defined within its parentheses?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
