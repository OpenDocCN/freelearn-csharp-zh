- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a 3D First Person Shooter (FPS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B18347_09.xhtml#_idTextAnchor169), we created a global event
    system, a quest system, and components that were all loosely coupled and worked
    together to provide versatile quests for the player to complete. With the systems
    in place, we made quick work of being able to implement collecting items to notify,
    update, and satisfy a specific quest requirement. The components created are extensible
    and reusable for creating any number of quests.
  prefs: []
  type: TYPE_NORMAL
- en: We then imported and fixed the rendering for the **Universal Render Pipeline**
    (**URP**), and refactored the code of a third-party sliding puzzle asset as an
    example of how to leverage the Unity Asset Store for our games. We finished by
    setting up the puzzle in the scene with new artwork and triggering an event when
    the puzzle was solved that ended the level with a fade-to-black sequence.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will pick up right where the previous 2D adventure game left off
    by introducing a 3D FPS game for the habitat interior we just entered.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing for 3D while continuing the GDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greyboxing a 3D environment with ProBuilder and Prefabs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an FPS player character with the Unity Starter Asset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring environment interactions to 3D API methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code reuse in practice – Adding premade components to the player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to design and build a greybox 3D
    environment from a set of modular parts we’ll make right within the Unity Editor,
    quickly add an FPS character controller, and reuse and refactor 2D code for a
    3D project.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can download the complete project on GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  prefs: []
  type: TYPE_NORMAL
- en: Designing for 3D while continuing the GDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Level design for a 2D game is more straightforward because players navigate
    in only two dimensions. In contrast, 3D games involve that extra dimension – depth
    – in gameplay, contributing to more complex level design. In 2D, the screen space
    is represented by the **X** and **Y** coordinates. In 3D, the floor plane is represented
    by **X** and **Z** (depth), with **Y** still being used for the vertical axis
    – Unity’s 3D coordinate system is defined as a **Y-up environment**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – 2D versus 3D coordinates](img/B18347_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – 2D versus 3D coordinates
  prefs: []
  type: TYPE_NORMAL
- en: As we already know from our previous 2D work, the Z axis still exists but is
    represented straight on with the camera – either in the front or in the back –
    and only applies in some cases when layering objects in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, we’ll attempt to simplify the 3D design process using a modular approach,
    but it all starts with the game design again. Let’s review some gameplay changes
    to the GDD for a new 3D FPS project introduced in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now is our chance to update our blueprint of gameplay mechanics to reflect our
    evolved vision of the *Outer World* 3D FPS game. We can then ensure that all aspects
    of the production of the habitat’s interior-level design will align with this
    new experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Table 10.1*, you can see that I have updated the relevant gameplay sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Describe the gameplay, the core loop, and** **the progression** | Make
    your way to the central control system, peeking around corners and down long corridors
    to restore operations while dealing with a damaged power suit that must be recharged
    along the way. Beware of lingering infected maintenance robots! |'
  prefs: []
  type: TYPE_TB
- en: '| **What is the core game mechanic for the** **collection game?** | With a
    first-person perspective, the player will navigate the environment, recharge their
    power suit (health), and shoot the infected maintenance robots. |'
  prefs: []
  type: TYPE_TB
- en: '| **What systems need to be implemented to support the** **game mechanics?**
    | The player movement, a weapon with ammo reloading and shooting capabilities,
    and a health system with pickup (recharging) and damage capabilities. |'
  prefs: []
  type: TYPE_TB
- en: Table 10.1 – Updated relevant gameplay sections
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll need to update the player character and enemy backstories to be
    relevant, as described in *Table 10.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **What is the main character’s** **challenge structure?** | The habitat station’s
    environmental controls are offline, and the player character’s power suit has
    lost the ability to sustain the player due to damage.The player must seek *recharges*
    in the station to survive the journey to the central system while battling infected
    maintenance robots.The player will confront the evil plant entity boss. |'
  prefs: []
  type: TYPE_TB
- en: '| **Enemy B:****Describe the second enemy in the game and how they drive the
    story. Who is** **this enemy?** | Type: Maintenance Robot WheeledBackstory: Robot
    deployed on pre-colonization missions for habitat maintenance and support.Goals:
    Maintenance, personnel supportSkills: Quick chargingWeaknesses: Limited mobility
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Boss:** **Viridian Overmind****Describe the level boss and how they drive**
    **the story****Who is** **this boss?** | A sentient plant entity infecting the
    central control system of the habitat station compels the player to confront the
    evil alien. |'
  prefs: []
  type: TYPE_TB
- en: Table 10.2 – Updated character and enemy bios
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a new game level, so it will also need to be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Describe the environment the game takes place in. What does it look like,
    who inhabits it, and what are the points** **of interest?** | The game occurs
    within a habitation station on a remote planet’s surface. The habitat is deceptively
    large with its many small connecting corridors. There are maintenance robots that
    roam the station carrying out their autonomous duties. Recharge pickups are conveniently
    placed throughout the station at the corridor intersections. |'
  prefs: []
  type: TYPE_TB
- en: '| **Describe the** **game level(s)** | The game level is a modular constructed
    habitat station interior with many corridors and rooms serving different purposes
    and a central control system room. |'
  prefs: []
  type: TYPE_TB
- en: Table 10.3 – Environment and level definitions
  prefs: []
  type: TYPE_NORMAL
- en: 'And lastly, we’ll need to update the input control scheme so that it’s relevant
    for functioning in a 3D space:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Define the input/control** **methods actions** | Keyboard: *W*, *A*, *S*,
    *D* keys to move, mouse to aim, the left mouse button to shoot the primary weapon,
    and the *E* key to interact.Game controller: Left-stick/D-pad to move, right-stick
    to aim, right-trigger or *Y* to shoot, and button *A* to interact. |'
  prefs: []
  type: TYPE_TB
- en: Table 10.4 – Updated input/control methods actions
  prefs: []
  type: TYPE_NORMAL
- en: With these GDD revisions to the *Outer World* game’s conceptual design and gameplay
    mechanics for 3D, we have a foundation for transitioning into the level design
    phase – ensuring that the level will align with our overall concept and provide
    the intended player experience.
  prefs: []
  type: TYPE_NORMAL
- en: Greyboxing a 3D environment with ProBuilder and Prefabs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a 3D environment is similar to creating a 2D environment in some ways
    since you still need to place things meaningfully for the gameplay. Of course,
    we must consider the additional dimension and use 3D models instead of 2D image
    assets.
  prefs: []
  type: TYPE_NORMAL
- en: In Unity Hub, please create a new `Unity 2022` project and use the **3D (URP)
    Core** template as our starting point. We’ll continue to use the URP renderer
    from the previous 2D projects. This is still an excellent choice for 3D since
    it will be performant on the broadest range of devices, including mobile platforms.
    With that, even though it sounds like we may be robbing ourselves of some capability,
    we’re not, since URP is also very capable of producing beautiful 3D visuals.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'URP overview: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/index.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: We will speed up the design process by using a technique called **greyboxing**
    (which may also be referred to as **blockout**) – this will allow us to rough
    in the level design using simple geometry without getting distracted by details.
    We’ll also be able to playtest the level early on and identify any potential issues
    with the player navigating the environment and working out general playability
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by looking at what we’ll be making.
  prefs: []
  type: TYPE_NORMAL
- en: Habitat interior level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like in earlier chapters, I’ll provide an example-level design (subjecting you
    again to one of my sketches, although a bit more refined this time) that you can
    follow along with. The level map includes an entry point – where we entered the
    habitat station at the end of the previous 2D adventure game – and leads to a
    central control system where we’ll confront the evil plant entity!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Habitat interior level map sketch](img/B18347_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Habitat interior level map sketch
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be using a modular approach to designing the level, so following this
    setup, we’ll be able to adapt quickly to different layouts. As you can see, I’ve
    added a legend that identifies modules intended to be used – these will be our
    reusable components serving as the broad strokes to construct and build the level
    out with. Locations for *recharge* pickups (green), the starting position for
    the player (**P**), and the location of the boss character are also defined.
  prefs: []
  type: TYPE_NORMAL
- en: Great! Now we have an actionable plan. Next, we can start creating the required
    3D modules for our greyboxing kit. If you’re thinking, but I have no 3D modeler/artist
    skills! Don’t worry, as this will be a basic introduction – I also believe a game
    developer should have this as the minimum amount of 3D knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Installing ProBuilder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity provides more built-in tooling that we can use for our greyboxing process
    in the form of a simple 3D modeling feature called ProBuilder. Like most of Unity’s
    features, we’ll install ProBuilder from **Package Manager**. In Unity 2022, tooling
    is collected into feature sets, so open **Window** | **Package Manager**, select
    the **3D World Building** feature (including ProBuilder and related tooling),
    and install it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing the features, we have one additional step to complete the
    ProBuilder setup. We’re using the URP renderer, which requires the supporting
    Shaders and Materials to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: While still in **Package Manager**, find and select **ProBuilder** in the list
    on the left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the right side, select **Samples** and click the **Import** button for the
    **Universal Render Pipeline** **Support** item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the import is complete, go to **Edit** | **Preferences…** | **ProBuilder**
    and ensure that under **Mesh Settings**, **Material** is set to **ProBuilder**
    **Default URP**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing ProBuilder adds a new top menu item named **Tools** that allows opening
    the **ProBuilder** window and accessing additional functions, exporting, and debugging
    logging preferences. For our greyboxing, we’re going to focus on the object creation
    process within the **ProBuilder** window, but that’s not to say ProBuilder is
    limited to just creating simple greyboxing objects; it has grown into a full-fledged
    3D modeling and texturing product that, depending on the style of your game, could
    be used for final asset creation too.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'ProBuilder: [https://docs.unity3d.com/Packages/com.unity.probuilder@5.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.probuilder@5.0/manual/index.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s open the **ProBuilder** window now by going to **Tools** | **ProBuilder**
    | **ProBuilder**, and we’ll get set up to make the modular building blocks from
    our sketch’s legend.
  prefs: []
  type: TYPE_NORMAL
- en: Modular parts, Prefabs, and Variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike an exterior environment’s level design, where shapes are organic in nature
    regarding their placement and position in the world, we’re making an interior
    environment for a controlled space. So, we’ll be building with modules that will
    need to *snap* to one another as they are laid out (you know, with the precision
    an airtight habitat requires). This is generally the approach you’d use for any
    manufactured structural spaces not found in nature.
  prefs: []
  type: TYPE_NORMAL
- en: Unity handles modular design well by providing some supporting construction
    options.
  prefs: []
  type: TYPE_NORMAL
- en: Grid snapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unity provides a **grid snapping** system that works wonderfully with ProBuilder
    to simplify our lives for such a task as snapping modules together. Grid snapping
    allows for precisely positioning a GameObject on X, Y, or Z axis planes, and applies
    to move, rotate, or scale operations.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming a GameObject – that is, realizing the move, rotate, and scale operations
    – can also be performed in increments without aligning to predefined gridline
    snap spacing. Incremental snapping can be performed by holding down the *Ctrl*/*Cmd*
    key while using the object transform gizmo in the scene view (**Snap Increment**
    settings are found on the button to the right of the **Grid Snapping** settings,
    as seen in *Figure 10**.3*).
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Grid snapping: [https://docs.unity3d.com/2022.3/Documentation/Manual/GridSnapping.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/GridSnapping.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Our level sketch is free of any dimensions (I just used a grid for roughly sizing
    things consistently), so we aren’t limited in letting the creativity flow; now
    that we’re making the *precise* modular parts, we need to introduce some unit
    of measurement to allow for the snapping together of parts. Building modules that
    need to connect to create our enclosed interior-level design will be pretty tricky
    if we don’t control the size of the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get set up for grid snapping, we first need to activate the **Move** tool
    and ensure that the handle orientation in the **Tool Settings** overlay is set
    to **Global** (this is a requirement for the snapping to be enabled in the scene
    view), as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Grid Snapping toolbar](img/B18347_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Grid Snapping toolbar
  prefs: []
  type: TYPE_NORMAL
- en: Note that the **Transform** tool snaps the selected GameObject(s) to the grid
    along the active gizmo axis – using the **Grid Visual** button to the left of
    the **Grid Snapping** settings, which, as seen in *Figure 10**.3*, is currently
    set to the **Grid** **Plane** Y-axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ensure that the grid snap settings are set up for us to start creating
    the modular parts for the habitat interior. Referring to *Figure 10**.3*, set
    up the snapping grid with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Move** tool from the **Toolbar** overlay in the scene view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the handle orientation on the **Tool Settings** overlay to **Global**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify **Grid Visual** | **Grid Plane** = **Y**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify **Grid snapping** = **enabled**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Grid snapping** | **Grid size** = **2** (default value is **1**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Increment snapping** = **0.25**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I have experience with mechanical drawing and CAD, so I like knowing what dimensions
    I’m working with – even though, yes, we’ll be snapping to the grid units we just
    defined. ProBuilder’s default material also includes a grid texture, but it may
    still be challenging to establish the required sizes without some visible values.
    So, let’s use the visual dimensions of the objects we’ll be building. From the
    **File** menu, set the **Dimensions** overlay to **Show** by going to **Tools**
    | **ProBuilder** | **Dimensions**.
  prefs: []
  type: TYPE_NORMAL
- en: Grid snapping will be of tremendous help – ensuring consistent sizing of the
    modular parts – but we can take another step with a simple construction aid.
  prefs: []
  type: TYPE_NORMAL
- en: Construction plane
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will put down a reference plane to assist in creating modules. I’ve decided
    the standard module size will be 6 units in length (this is rather arbitrary for
    how large the base modules are that you’ll want to work with; I felt it would
    be better to work with smaller modules for this design), so we’ll base all the
    dimensions – modules as well as map dimensions – on this standard (and the divisible
    dimensions of it by the snap unit size of 2; so, hopefully, that all works out).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Scenes` folder, duplicate `SampleScene` and name it `Habitat`
    `Interior 1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, with the **ProBuilder** window open, select **New Shape** and then click
    the **Plane** selection icon in the **Create** **Shape** overlay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Grid snapping and dimensions showing are enabled, so click and drag out a plane
    that is 6 x 6 units in size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.4 – ProBuilder reference plane](img/B18347_10_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – ProBuilder reference plane
  prefs: []
  type: TYPE_NORMAL
- en: Click **New Shape** again to stop creating shapes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s reset the plane position to `(0, 0, 0)` in world space. With the
    plane selected, right-click the `(0, 0, 0)``Module` `Reference Plane`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip | Maximize Unity window
  prefs: []
  type: TYPE_NORMAL
- en: To maximize the currently active window in Unity, as seen with the scene view
    window in *Figure 10**.3*, you can use the keyboard shortcut *Shift* + *spacebar.*
  prefs: []
  type: TYPE_NORMAL
- en: And now, to make our first modular part!
  prefs: []
  type: TYPE_NORMAL
- en: Making modular parts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our modular parts will seamlessly snap together in numerous configurations
    to make the variations we need to create the larger complex space of the habitat
    station’s level design. So, let’s start making modular parts for our environment
    with a wall segment:'
  prefs: []
  type: TYPE_NORMAL
- en: To make a wall segment, click **New Shape**, but click the **Cube** selection
    icon this time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Starting at `(0, 0, 0)` drag out a shape that is the length of the reference
    plane (6 units) and -2 units in the **Z** direction (away from the reference plane;
    the blue gizmo axis).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, move up (in the `4` units in height.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As a result of snapping to the grid, it looks like the box is a bit too thick
    to represent a wall, so let’s edit the shape and make it a bit thinner:'
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Figure 10**.5*, rotate the camera to see the other side of the wall.
    We can rotate within the scene view by holding down the *Alt*/*Option* key and
    then clicking and dragging the mouse pointer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then click the **Face Selection** option in the **ProBuilder Selection** overlay
    (*A*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clicking on the facing side of the wall will now select just the face polygons.
    While holding down the *Ctrl*/*Cmd* key, drag the Z-axis handle (blue) of the
    move transform gizmo until the wall is 1 unit thick (*B*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.5 – ProBuilder incremental surface snap editing](img/B18347_10_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – ProBuilder incremental surface snap editing
  prefs: []
  type: TYPE_NORMAL
- en: When done editing the face, return to the **Object Selection** mode (*A*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Greyboxing doesn’t necessarily mean 100% void of all details; I generally like
    to add at least some small elements to my greyboxing kit parts to convey some
    design aesthetics, so we’ll add a few minor details to the wall segment before
    building up some additional parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add some geometry detail to the wall segment:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a new cube of 2 x 2 units with a height of 4 units. Then, using `1.5` x
    `0.25` x `4`. Position it at the end of the wall segment to provide an end cap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the **End Cap** cube and place it at the other end of the wall segment
    (like bookends). Note that both ends should be within the reference plane and
    will therefore intersect the wall segment (this is fine – we want to constrain
    the parts within our reference size so everything snaps together like Lego bricks).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a new cube of `6` x `2` units with a height of `2` units, then edit its
    size and position it to make a sort of connecting bar thing along the length of
    the wall segment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The results of our 3D modeling can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Wall section details added](img/B18347_10_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Wall section details added
  prefs: []
  type: TYPE_NORMAL
- en: Tip | Lighting
  prefs: []
  type: TYPE_NORMAL
- en: Note that the shadows on the lighting in the scene have been turned off to focus
    on the modeling task. You can do this by selecting the **Directional Light** object
    in the scene hierarchy, then, in the Inspector, find the **Shadows** section and
    set **Shadow Type** to **No Shadows**.
  prefs: []
  type: TYPE_NORMAL
- en: I would say this wall section is now complete for our first modular kit part.
    So, we’ll, of course, want to make it a Prefab so we can reuse it where needed,
    and should we need to modify it, all references in the scene will be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create the wall Prefab:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new empty GameObject and reset `(0, 0, 0)` . This will be our parent object
    and ensure that our modular parts maintain consistency for their snapping point
    – the individual objects that all make up the module will be transformed by this
    anchor pivot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select and drag all the parts of the wall assembly to be a child of the new
    empty GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, rename the parent object to `Wall 1` and drag it to a new `Assets/Prefabs`
    folder to make the Prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You now have all the tools and knowledge to make the rest of the modular parts
    needed for our greyboxing kit. That was easy, yay!
  prefs: []
  type: TYPE_NORMAL
- en: 'What are all the Prefabs we need for our greyboxing kit to produce a complete
    block out of the level? We can get our answer from the map legend (see *Figure
    10**.2*). There are only a few to make – minus one for the wall we just made:'
  prefs: []
  type: TYPE_NORMAL
- en: '| (A) | Wall 1 | 6 units length |'
  prefs: []
  type: TYPE_TB
- en: '| (B) | Wall 2 | 12 units length |'
  prefs: []
  type: TYPE_TB
- en: '| (C) | Doorway | 18 units length (equal wall, open space, wall) |'
  prefs: []
  type: TYPE_TB
- en: '| (D) | Connector 1 | 6 x 6 units with floor plane |'
  prefs: []
  type: TYPE_TB
- en: '| (E) | Connector 2 | 6 x 12 units with floor plane |'
  prefs: []
  type: TYPE_TB
- en: Table 10.5 – Greyboxing kit parts
  prefs: []
  type: TYPE_NORMAL
- en: '*Connector 1* (*D*) will be the same type of connector between rooms so that
    it can be created as a completed module and not have to be assembled from individual
    wall parts whenever we need one. It’s the same for the *Connector 2* (*E*) Prefab,
    just longer. Here, we can see all the modular parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Greyboxing kit Prefabs](img/B18347_10_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Greyboxing kit Prefabs
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and create the additional wall, door, and connector modular parts now;
    I’ll wait. Just be sure to always start from the origin of our construction plane
    to ensure the anchor pivot is at `(0, 0, 0)` – by creating a new empty GameObject
    there and parent the cubes to it – so that our kit parts will always snap into
    place properly. These anchor pivot instructions are based on what’s seen in *Figure
    10**.4* and not as seen in *Figure 10**.7*, where the wall parts were moved for
    better visibility after being created.
  prefs: []
  type: TYPE_NORMAL
- en: With our greyboxing kit complete, we can now start mapping out the level.
  prefs: []
  type: TYPE_NORMAL
- en: Greyboxing the level design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have our map sketch as a reference, but it would still be too abstract if
    we start haphazardly dragging in kit Prefabs to try and block it out. To streamline
    the process a bit more, we can use ProBuilder planes to lay out the map sketch
    according to our snapping grid. This will ensure that adding the kit modules will
    be straightforward and quick.
  prefs: []
  type: TYPE_NORMAL
- en: Another drawing aid (we take all the help we can get) is to set the **Grid Visual**
    setting for **Opacity** to the max value (as seen in *Figure 10**.7*) so the grid
    is fully visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following our sketch and considering the size of our modular kit parts in *Table
    10.5*, use the ProBuilder planes to map out the level: walls, doorways, and connectors.
    ProBuilder will create the planes at **Y**, **0** by default, which is right where
    we want them (floor level). It would then help to have the view locked to a top-down
    view while we draw out the level. So, using the scene gizmo (top-right corner
    of the scene view, (*A*) in *Figure 10**.8*), click the **Y** (green) handle,
    click the center cube to set the view to orthographic (no perspective), then click
    the little lock icon.'
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Scene view navigation: [https://docs.unity3d.com/2022.3/Documentation/Manual/SceneViewNavigation.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/SceneViewNavigation.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the start of our level map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Map layout planes](img/B18347_10_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Map layout planes
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll notice (and as seen in *Figure 10**.8*), the white ProBuilder planes
    are glowing a bit. This is because the post-processing volume was in the scene
    from when we duplicated **SampleScene**. If it’s a distraction, simply disable
    the **Global Volume** object in the hierarchy or, toggle off the effects via the
    **View Options** toolbar (*B*) while mapping out the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the completed level map with the entryway at location (*A*), and making
    our way to the central control system room at location (*B*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Completed map layout](img/B18347_10_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Completed map layout
  prefs: []
  type: TYPE_NORMAL
- en: I’m using the *of greatest importance* definition for the word central here,
    not the *in the middle of something* definition, just to clear up any possible
    confusion with the layout of the rooms.
  prefs: []
  type: TYPE_NORMAL
- en: All the hard stuff is done. All we have to do now is to drag our modular kit
    parts to the edges of the mapped floor planes – with the anchor pivots we ensured
    are at the origin of the module. We’ve guaranteed everything should snap in place
    and to each other. Once you have a modular Prefab in the scene, you can use *Ctrl*/*Cmd*
    + *D* to duplicate it quickly, then move and rotate it into place.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you will have to rotate modules to enclose the perimeter of the rooms
    and corridors. This is where the anchor pivot also plays a crucial role – the
    part will rotate at the pivot, ensuring proper snapping will be maintained. You
    can turn the parts by typing a value in the Inspector or using the **Rotate Transform**
    tool in the **Toolbar** overlay (hold the *Ctrl*/*Cmd* key to rotate incrementally
    and ensure precisely 90 or 180 degrees of rotation).
  prefs: []
  type: TYPE_NORMAL
- en: If we make any mistakes in the size or spacing of the map’s rooms and corridors,
    we’ll quickly find out, but rapidly making changes for corrections is trivial
    with this modular approach. Easy-peasy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results of my effort in bringing the interior habitat level together
    with our modular greyboxing kit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Finished habitat interior greyboxing](img/B18347_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Finished habitat interior greyboxing
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to block out a 3D environment made of simple
    ProBuilder model Prefabs used to create a simple greyboxing parts kit. We then
    discovered how to map out a level design and use Unity’s grid snapping system
    to make fitting everything together quick and easy.
  prefs: []
  type: TYPE_NORMAL
- en: For the next part, we need to playtest what we’ve built. Rather than coding
    a player controller from scratch, this time, we’ll be leveraging Unity’s Starter
    Assets to construct the player rapidly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an FPS player character with the Unity Starter Asset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s quickly look at some of the general benefits of using prebuilt assets
    – like Unity’s **Starter Asset character controller** – compared to coding ones
    ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: They save time and effort – complex systems take time to build and troubleshoot
    any issues that arise along the way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are tested and optimized for performance and generally use best practices
    – as they’re provided by Unity (they know a thing or two about creating components
    for use in their engine) and widely used by game developers of all levels, these
    assets will be performant and much less likely to have bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are built on Unity’s `CharacterController` component – these assets are
    built modularly, ensuring compatibility with other systems (such as camera and
    combat systems) and assets; they are a great starting foundation for an FPS game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They offer a learning opportunity – prebuilt assets can be a great learning
    tool because you can examine how they work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have plenty of customization options – Unity provides many customization
    options out of the box for most player controller uses (especially for an FPS
    in this case, which is fantastic for us!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These advantages are pretty significant to minimize problems getting your game
    up and running quickly; we will take full advantage of them right now. Let’s install
    the Unity Starter Assets.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Unity Starter Assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll use the `Starter Assets - FirstPerson CharacterController` | `URP` asset
    provided (for free) by Unity from the Asset Store for our 3D FPS game.
  prefs: []
  type: TYPE_NORMAL
- en: Starter Assets - FirstPerson CharacterController | URP (Unity Technologies)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find this asset in the Unity Asset Store here: [https://assetstore.unity.com/packages/essentials/starter-assets-first-person-character-controller-urp-196525](https://assetstore.unity.com/packages/essentials/starter-assets-first-person-character-controller-urp-196525).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing will be straightforward and similar to how we’ve already installed
    assets from the Package Manager. However, since the Starter Assets have some required
    dependencies, there will be a bit of a hiccup in the process. Don’t worry; it’s
    only a minor inconvenience, as you’ll soon see by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Save your scene now (*Ctrl*/*Cmd* + *S*) if you haven’t already – you’ll see
    why in a few steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the preceding URL to open the asset in the Unity Asset Store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sign in if not already signed in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Add to My Assets** button (accept **Asset Store Terms of Service**
    **and EULA**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the project already open in the Unity Editor, click the **Open in Unity**
    button that appears at the top of the browser window (you can also always click
    the **Open in Unity** button on the Asset Store page at any time later) and you’ll
    see the following dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Open in Unity dialog](img/B18347_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Open in Unity dialog
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the **Open Unity Editor** button will set the focus to the Unity Editor
    and open the Package Manager with the **Starter Assets - FirstPerson CharacterController**
    | **URP** package already selected (how convenient).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Download** button (top right of the window).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the download has finished, click the **Install** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Starter Assets packages require the new `PackageChecker` script), and we’ll
    be prompted concerning this, as seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Starter Assets dependencies warning](img/B18347_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Starter Assets dependencies warning
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we want to click **Install/Upgrade** so we can actually use the
    Starter Asset in our project! If you accidentally skip this step, you can still
    install the new **Input System** package and **Cinemachine** package through the
    Package Manager. When the **Input System** dependency is installed, however, we’ll
    be presented with this dialog for enabling the native platform backends:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Update native platform backends](img/B18347_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Update native platform backends
  prefs: []
  type: TYPE_NORMAL
- en: Click **Yes**, and the Unity Editor will restart (aren’t you glad I told you
    to save your scene in *step 1*?).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the Unity Editor reopens, return to the Package Manager and click the **Install**
    button again (just a bit annoying but it seems unavoidable with the current dependency
    requirements). This time, the installation will finish without a hitch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That takes care of the installation, so let’s look at what the Starter Assets
    provide.
  prefs: []
  type: TYPE_NORMAL
- en: Starter Assets Playground scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can quickly test the first-person character controller by opening the provided
    playground scene. Go to `Assets/StarterAssets/FirstPersonController/Scenes` to
    find the **Playground** scene. In the **Playground** scene, we have the necessary
    objects for the first-person character controller, as well as a simple environment
    we can test the character controller in.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can quickly manipulate the playground environment to provide some
    additional test geometry with the available parts by snapping them together using
    their mesh vertexes rather than trying to figure out a snapping grid setup. To
    snap objects together using their vertexes, select the mesh you want to transform
    with the **Move** tool active, then press and hold the *V* key to activate vertex
    snapping. Move to the vertex you want to use – generally a corner point of the
    mesh – then click and drag to any other vertex on another object. Simple and quite
    helpful!
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Positioning GameObjects and vertex snapping: [https://docs.unity3d.com/Manual/PositioningGameObjects.xhtml](https://docs.unity3d.com/Manual/PositioningGameObjects.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Of particular note, you can also use vertex snapping to place an object precisely
    on the surface of another object. To accomplish this, while already holding down
    the *V* key, hold down the *Shift* + *Ctrl*/*Cmd* keys while moving over the surface
    you want to snap to.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget that you can use the *F* key in the scene view window at any time
    to refocus on the currently selected object – this sets orbiting, panning, and
    zooming around that object.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let’s look at getting around with the first-person character controller
    we’ll use for our game.
  prefs: []
  type: TYPE_NORMAL
- en: Getting around
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First things first, enter Play Mode. Now, you can look around using the mouse,
    move the player with the *W*, *A*, *S*, *D* keys, hold *Shift* to sprint, and
    press the *spacebar* to jump. The *move*, *look*, *jump*, and *sprint* actions
    for both keyboard/mouse and gamepad input are established with the `StarterAssets`
    Input Action Asset (Input Actions) located in the `Assets/StarterAssets/InputSystem`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the scene **Hierarchy** window in the following screenshot, we have
    the objects that make up the Starter Assets first-person character controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Standard Assets Playground scene Hierarchy](img/B18347_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – Standard Assets Playground scene Hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PlayerCapsule` object is the primary object (Prefab) holding the modular
    components that provide the behavior for the first-person character controller.
    Starting with `PlayerCapsule`, the process flow for the components – from input
    to transform manipulation – looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PlayerCapsule` à [`StarterAssets` (Input Action Asset / Input Actions)] `Player`
    à `PlayerInput` [SendMessages] à `StarterAssetsInputs` à `FirstPersonController`
    à `CharacterController`'
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to look into each of the components to gain some familiarity
    with how things are connected to provide this functionality. We don’t actually
    need to dig into these components to get things working, so I won’t be covering
    it. We will, however, extend upon the base functionality the Starter Assets provide
    when required.
  prefs: []
  type: TYPE_NORMAL
- en: However, with this brief overview, we should understand what’s needed to bring
    the first-person character controller into our greybox habitat level.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the first-person controller to our level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve finished having some fun in the Starter Assets `Playground`
    scene, let’s go back to our habitat interior scene to add the player so we can
    progress further with our game. As we saw in the `Playground` scene hierarchy,
    a few Prefabs worked together to provide the first-person character controller
    functionality. So, we’ll use these Prefabs too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bringing this in is made simple with a provided nested Prefab. Here are the
    steps we’ll follow to bring the controller setup into the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/StarterAssets/FirstPersonController/Prefabs` folder, find the
    `NestedParent_Unpack` Prefab. As the name no doubt indicates, this is a nested
    Prefab containing everything we need to set up the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop `NestedParent_Unpack` into the scene hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the name indicates, we’ll want to unpack this nested Prefab, so we have just
    the child Prefabs. Right-click `NestedParent_Unpack`, and then select **Prefab**
    | **Unpack**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the prefab now unpacked, drag the child objects out into the root of the
    **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now delete `NestedParent_Unpack`, and we are ready to go!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see in the `UI_Canvas_StarterAssetsInputs_Joysticks` Prefab object
    in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Starter Assets mobile controls](img/B18347_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – Starter Assets mobile controls
  prefs: []
  type: TYPE_NORMAL
- en: I think it’s great that Unity has decided to include mobile support with the
    Starter Assets; again, this saves us a lot of time if we want to get a mobile
    game up and running quickly – as well as all the previous benefits noted.
  prefs: []
  type: TYPE_NORMAL
- en: We’re now ready to give the level a playtest!
  prefs: []
  type: TYPE_NORMAL
- en: Playtesting the level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get things started, we’ll have to move the `PlayerCapsule` object into a
    position at the start of our level map, assuming we just entered the habitat station
    after solving the entryway puzzle. You can see an example of placement in *Figure
    10**.15*.
  prefs: []
  type: TYPE_NORMAL
- en: The ProBuilder models include **Colliders** for the planes we used to map out
    the level floor and the cubes we used to make the modular wall Prefabs, so the
    level is already set! Enter Play Mode and have a look around.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Starter Assets documentation
  prefs: []
  type: TYPE_NORMAL
- en: Additional details for the Starter Assets package can be found in the documentation
    included with the package. The documentation is in PDF form and can be found in
    the **Assets/StarterAssets** folder.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to rapidly add a first-person character controller
    to our game’s level by leveraging the Unity Starter Assets.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll revisit some reusable components from the 2D game
    projects to use in our 3D FPS game project.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring environment interactions to 3D API methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the previous 2D game projects, we have a small library of components built
    up already, but they are 2D, and we are now in 3D, so it requires a bit of refactoring
    for us to use them. Let’s first revisit the `TriggeredEvent` component we created
    in [*Chapter 4*](B18347_04.xhtml#_idTextAnchor079).
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the TriggeredEvent component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Physics 2D API method we used for the `TriggeredEvent` component is `OnTriggerEnter2D()`.
    Its 3D counterpart simply drops the *2D* part, and so it’s just `OnTriggerEnter()`
    (Unity is 3D under the hood, and it would make sense that only the 2D-specific
    methods are indicated as such).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, considering the above, let’s look at how we’ll update the `TriggeredEvent`
    code. Provided that you copied in the `Assets/Scripts/TriggeredEvent.cs` file
    from the previous 2D project, only a few changes are required. Otherwise, you
    can first revisit the earlier code in the book or even download the 2D version
    of the script from the GitHub project repo: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/Unity%20Project/Assets/Scripts](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/Unity%20Project/Assets/Scripts).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the changes we’ll make:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Unity Physics message event from this appears as follows, but we will change
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And here it is after the change:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `[RequiredComponent]` attribute from the original, which looks like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I believe this one is self-explanatory – we don’t require the collider to be
    a `Collider2D` type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you save the script now, you’ll likely notice we have an error displayed
    in the Console window with the `Tags` type not being found: `Tags.Player`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can resolve this error by copying the `Assets/Scripts/Tags.cs` file again
    from the 2D project, creating the `Tags.cs` file manually and typing out the constant
    variable declaration, or using the IDE’s refactoring tools to generate `Tags.cs`.
    Either way, we’ll end up with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Concerning our `Player` tag, the `PlayerCapsule` object from the Unity Starter
    Assets first-person character controller is already tagged as `Player`. How convenient!
  prefs: []
  type: TYPE_NORMAL
- en: With the `TriggeredEvent` script all sorted, let’s implement it now by adding
    a triggered interaction to the interior habitat level.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a TriggeredEvent in our level design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve already seen how we can leverage editor tooling and reusable components
    to build out environments and add behavior or functionality to our games. This
    current implementation will be no exception. So, let’s see how we can use both
    ProBuilder and the `TriggeredEvent` component to add a door to the level design
    that automatically opens when the player gets near it:'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating a trigger volume using a ProBuilder cube. Using *Figure
    10**.16* as a reference, draw out a cube just in front of the first doorway of
    the room the player starts from – and don’t forget your *grid snapping*!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the cube is created, select it, then in the ProBuilder `OnTriggerEnter()`
    message event will be fired.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, we have quickly made a trigger volume visible at design time but
    hidden at runtime – another excellent feature ProBuilder provides.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go ahead and add the refactored `TriggeredEvent` component to our trigger
    volume ProBuilder cube object now. We can now use the `TriggeredEvent` component
    to wire up and trigger an animation.
  prefs: []
  type: TYPE_NORMAL
- en: Animating the door opening
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a `UnityEvent` that can be triggered when the player enters
    the trigger volume at our doorway, let’s add a closed door that will animate open.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll create the door following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new ProBuilder cube.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use face editing and incremental snapping to make the cube thin (you know, like
    a door).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the cube in the doorway to obstruct entry (as if it were closed).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the object `Door`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By assigning a color, let’s quickly differentiate the door mesh from our greyboxing
    kit parts. We can do that using the **Vertex Colors** command in the ProBuilder
    window. With the **Door** object selected, clicking **Vertex Colors** will open
    a new window with a default color palette shown. Clicking one of the colors’ related
    **Apply** button will set a new color on the object. Easy-peasy. (Oh… and as seen
    in *Figure 10**.16*, I chose blue.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now add an animation to the door that we can trigger to play from the
    `TriggeredEvent` component.
  prefs: []
  type: TYPE_NORMAL
- en: With the `.anim`) that we’ll name `Door-idle` and save to a new `Assets/Animation`
    folder. In the associated **Animator**, this sets the idle animation as the default
    state. Since we don’t want the door to do anything at all in its idle state, we’re
    done with it. Now, we want to create the animation for opening the door.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, follow these steps to create the door-opening animation:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Animation** window, with the **Door** object selected, click on the
    **Animation Clip** dropdown – currently set to **Door-idle** – then select **Create**
    **New Clip…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted, save the new animation clip and name it `Door-open`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the red `0.5` seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the **Move** tool, move the **Door** into an open position (or change
    the **Transform** position value in the Inspector for the open direction axis)
    wide enough for the player to pass through. This will create two keyframes in
    the timeline: one at the start and one at the current time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Record** button again now to stop animating.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, open the **Animator** window by going to **Window** | **Animation** | **Animator**.
    You’ll see both the **Door-idle** and **Door-open** nodes (the animations) already
    there and a **Default State Transition** line from **Entry** to **Door-idle**
    – precisely what we want. We don’t want the door to do anything when we start
    playing the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the **Door-open** animation, then, in the Inspector, uncheck **Loop
    Time**. We want the door to open and stop playing the animation, not continuously
    loop back and do it repeatedly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last thing to do is wire up `UnityEvent` on the `TriggeredEvent` component:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `TriggeredEvent` component, click the little plus (**+**) icon to
    add a new event listener.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Door** to the **Object** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the function selection dropdown, select `Door-open` in the provided field
    – and double-check your spelling! The spelling here must match the name of the
    animation node in the **Animator**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The preceding `TriggeredEvent` listener assignment, the **Door-open** animation
    timeline, the blue **Door** object, and the ProBuilder **Cube** trigger volume
    object can all be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Triggered door open animation](img/B18347_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Triggered door open animation
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make our triggered/animated door a Prefab as the final step:'
  prefs: []
  type: TYPE_NORMAL
- en: Parent the **Cube** and **Door** objects in the hierarchy to a new empty GameObject
    by selecting both objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then right-click and choose **Create** **Empty Parent**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new GameObject `Door_Triggered`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then drag it from the hierarchy to the `Assets/Prefabs` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that you may need to fix the **Door-open** animation since the **Door**
    object is now a child GameObject whose local position is offset in relation to
    the parent. If so, select **Door**, open the **Animation** window, and select
    the **Door-open** animation from the dropdown. You can now manually reset the
    values for each keyframe in the timeline. Use the **Preview** buttons to play
    the animation and test to adjust accordingly until resolved (you’ve got this).
  prefs: []
  type: TYPE_NORMAL
- en: You can now duplicate the `Door_Triggered` Prefab in the scene (*Ctrl*/*Cmd*
    + *D*), drag it in from the **Project** window, and place it throughout the level
    where it makes sense for the desired gameplay. For example, having a patrolling
    enemy behind a closed door is always fun.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to easily refactor a 2D API method to reuse
    some existing code and proceeded to use it and grasped some new learnings for
    rapidly creating 3D objects with ProBuilder to implement new functionality for
    the level. Next, we’ll look at more code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Code reuse in practice – Adding premade components to the player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to refactoring some existing code to work in our new project, we
    can also bring in our existing system code – this could then be considered premade
    components, ready for use. So, referring back to the GDD now, we will use `HealthSystem`
    from the 2D adventure game project to decrease and recharge the player’s power
    suit (i.e., health).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t already have the 2D adventure game scripts locally, you can download
    the project source from the GitHub repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, from the 2D adventure game project, copy the following files into the
    3D FPS game project (in the same locations):'
  prefs: []
  type: TYPE_NORMAL
- en: From `Assets/Scripts/Systems`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HealthSystem.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From `Assets/Scripts/Interfaces`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IHeal.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IDamage.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IHaveHealth.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that the health system has been added to the project, the first thing to
    do is refactor any of the 2D API methods and types to the non-2D counterparts
    just like we did in the previous section, *Refactoring environment interactions
    to 3D API methods*. This includes changing all references of `OnTriggerEnter2D`
    to `OnTriggerEnter` and `Collider2D` to `Collider`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s go ahead and add `HealthSystem` as a component on the **PlayerCapsule**
    Prefab (again, in the Unity Starter Assets first-person character controller,
    this is the **Player** object).
  prefs: []
  type: TYPE_NORMAL
- en: To satisfy the GDD requirement of decreasing the player’s power suit level (health),
    let’s write some code that extends upon the existing `HealthSystem` code that
    will slowly decrease health at an assigned rate. We’ll ensure we expose fields
    in the Inspector for the amount to reduce health by and the rate of decrease.
  prefs: []
  type: TYPE_NORMAL
- en: Constant damage script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new C# script named `ConstantDamage` in the `Assets/Scripts` folder
    and open it for editing. We’ll replace the script template code with the following
    code, which should look familiar since we will implement the `IDamage` interface.
    The difference is that we won’t be triggering the damage from an object collision
    (like before with the `ProjectileDamage` class). Instead, we’ll be applying damage
    directly to the `HealthSystem` over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the required implementations for `IDamage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick breakdown of the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ConstantDamage : MonoBehaviour, IDamage`: This class is inheriting the `IDamage`
    interface, which means we’ll have to implement the properties and methods defined
    (the contract): `DamageMask`, `DamageAmount`, and `DoDamage()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_damageMask`: This encapsulated private variable is serialized and assignable
    in the Inspector, with the `public DamageMask` getter (to satisfy the interface
    contract) referenced by `HealthSystem`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `_damageMask` is a `LayerMask` that determines what object **Layer** can
    be damaged by this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`_damageAmount`: This encapsulated private variable is serialized and assignable
    in the Inspector, with the `public DamageAmount` getter (to satisfy the interface
    contract) referenced by `HealthSystem.TakeDamage()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This determines the amount of damage that will be applied to the object over
    time (via **coroutine**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we’ll add the code for applying damage over a set time interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s a quick breakdown of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_damageInterval`: This is the private member variable that is serialized and
    assignable in the Inspector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It determines the time interval of the damage amount that will be applied to
    the object (the damage rate).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`StartCoroutine(ApplyDamageOverTime())`: This is how we start the coroutine
    in the `Start()` Unity message event, which will begin applying damage to the
    player right away.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ApplyDamageOverTime()`: This is our `IEnumerator` coroutine method that uses
    `while (true)` to loop indefinitely, calling `HandleDamageCollision()` then delaying
    5 seconds via `WaitForSeconds()` before looping again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HandleDamageCollision(null…`: Here, we’re passing in a value of `null` for
    the `Collider` parameter since, well, we don’t have a collision occurring. We’ll
    just have to ensure we do a `DoDamage()`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoDamage()`: This declaration is required for the interface implementation
    (to satisfy the contract), but we won’t use it now.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whew, that makes it seem like we have to do so much for only a dozen or so lines
    of code! And that’s the point. We introduce good architecture, patterns, and practices
    into our projects to accomplish more with less.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `ConstantDamage` as a component on the `PlayerCapsule` object (this will
    be a sibling component of `HealthSystem`) – so that the player’s health constantly
    decreases. Before we can test it out, assign the following values to the fields
    in the Inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Player` (you may have to add `Player` to the project’s layers list first,
    using the `PlayerCapsule` object in the hierarchy to the `Player` layer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5` (seconds)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now you can save (*Ctrl*/*Cmd* + *S*) and enter `PlayerCapsule` `FirstPersonController`
    values under the `Player` header until the movement feels right in the level.
  prefs: []
  type: TYPE_NORMAL
- en: It will be difficult to see if anything is happening right now because we don’t
    have any visual indicators in the scene, and the variable holding the current
    health value isn’t visible in the Inspector. No worries, Unity has a solution
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: Inspector Debug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Unity Inspector has a Debug mode that will peek into our components’ code
    and expose private member variable fields as read-only values. While still in
    Play Mode, go ahead and switch the Inspector into Debug mode by clicking the vertical
    ellipsis (**⋮**) **More Items** menu (also known as the kabab menu) button (*A*),
    then click **Debug** to switch from **Normal** mode, as seen in the following
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 - Applying damage to the player](img/B18347_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 - Applying damage to the player
  prefs: []
  type: TYPE_NORMAL
- en: And now, we can see the private `_healthCurrent` variable field as `HealthSystem`
    component, which, according to our `ConstantDamage` assignments, will decrease
    `_healthCurrent` by a value of `1` every `5` seconds. Be sure to switch the Inspector
    back to Normal Mode when you’ve finished inspecting the value (you won’t generally
    need to see all the additional debug information).
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Learn more about working in the Inspector: [https://docs.unity3d.com/Manual/InspectorOptions.xhtml](https://docs.unity3d.com/Manual/InspectorOptions.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also seen in *Figure 10**.17*, the **Console** warning message is (*C*): **HealthSystem
    on PlayerCapsule’ requires a sibling component that inherits** **from IHaveHealth!**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This console output results from a null check we had implemented in the original
    `HealthSystem` code when the `HealthChanged()` method is called. It just ensures
    that an object – that implements the `IHaveHealth` interface – exists before calling
    `HealthChanged()` or `Died()` methods on it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That takes care of the constantly decreasing health of the player. Now, how
    do we recharge this Kryk’zylx power suit?
  prefs: []
  type: TYPE_NORMAL
- en: Recharging aka healing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re going to create a pickup that will recharge (heal) the player, and this
    might be the quickest we’re going to add new functionality to our game yet! This
    is because we will again use previously written code and a similar approach to
    things we’ve already made.
  prefs: []
  type: TYPE_NORMAL
- en: From the previous 2D adventure game project, copy in the `PickupHeal.cs` and
    `Destroyer.cs` scripts. We’re going to place pickups for recharging/healing the
    player throughout the level – which is something we’ve made before, so maybe try
    making this on your own first? The only difference is that now we will create
    a ProBuilder object as a 3D pickup compared to the 2D sprite pickup we previously
    made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t worry; we’re still going to follow the below steps that you can check
    your work against. So, here we go. To make a 3D object as a healing pickup, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a ProBuilder object to use as a pickup (a cube, sphere, cone, etc.). With
    grid snapping enabled, you’ll want to use incremental snapping (hold *Ctrl*/*Cmd*)
    to make it a suitable size compared to the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the new object you’ve made for the pickup, set **MeshCollider** as **Convex**
    and **IsTrigger** as **Enabled** (don’t use the **SetTrigger** option from ProBuilder
    because we want the mesh to be visible as is).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use ProBuilder’s **Vertex Colors** to set a new color on the pickup object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add both `PickupHeal` and `Destroyer` as components on the ProBuilder object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign `Player` as the `Destroyer.DestroyMe` as a listener for `OnHealEvent`
    (ensure it’s set to **Runtime Only** and not **Off**).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the object to `Heal Pickup` (or `Recharge Pickup`) and drag it from the
    hierarchy to the `Assets/Prefabs` folder to make it a reusable Prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How’d you do on your own? With our healing pickup Prefab completed, we can now
    scatter them throughout the level in a strategic way to create good, challenging
    gameplay for the player. Enter Play Mode now and verify in the Inspector **Debug
    mode** that the current health value is restored when a pickup is collected. As
    always, you’ll continue to playtest – or better, enlist others to playtest as
    you observe – and balance values to provide the best player experience!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw how to reuse existing components to quickly add health
    system functionality to the player and extend functionality with a new component
    that applies constant damage. We also learned how to view and debug private member
    component values in the Inspector, then finished with more code reuse to rapidly
    create a 3D pickup object that recharges the player’s health.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter first covered a quick addition to our GDD to add specifics for
    our new 3D FPS game, including considerations for 3D-level design. We used the
    updated GDD to block out the interior habitat level environment from a greyboxing
    kit of modular parts that snap together and draw out a level map, all using Unity
    ProBuilder.
  prefs: []
  type: TYPE_NORMAL
- en: We continued by learning how to rapidly add an FPS player character to our game
    by leveraging the Unity Starter Assets first-person character controller. We also
    rapidly added behavior to our player with code reuse for the health system and
    healing pickups. Code reuse and refactoring 2D components to the 3D API method
    counterparts also allowed us to quickly make an animated door that opens when
    the player triggers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we’ll continue with the environment-level design by replacing
    the modular greybox kit Prefabs with art assets and decorating with more Unity-provided
    tooling: Polybrush and Decals. We will then finalize the environment design process
    by baking the 3D environment lighting to ensure high-performance rendering while
    comparing it with real-time lighting to evaluate the pros and cons of each.'
  prefs: []
  type: TYPE_NORMAL
