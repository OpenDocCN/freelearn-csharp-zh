- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Azure Functions and Triggers Available
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用的 Azure Functions 和触发器
- en: The first three chapters of the book covered the background of serverless and
    microservices, focusing on how to use these technologies to design an application
    that works with a microservice-based architecture. This and the following chapters
    will go deep into the options you have for writing code for this, using the car-sharing
    example presented in [*Chapter 2*](Chapter_2.xhtml#_idTextAnchor038), *Demystifying
    Microservices Applications*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的前三章涵盖了无服务器和微服务背景，重点介绍了如何使用这些技术来设计一个与基于微服务架构的应用程序。本章和接下来的章节将深入探讨您编写代码的选项，使用在[*第2章*](Chapter_2.xhtml#_idTextAnchor038)“揭秘微服务应用程序”中提出的共享汽车示例。
- en: To do so, in this chapter, we will present the different triggers available
    in Azure Functions. The point here is not just to write about it, but to also
    test it with each of the triggers presented. In [*Chapter 1*](Chapter_1.xhtml#_idTextAnchor022),
    *Demystifying Serverless Application*, we covered its basis, but we did not have
    the opportunity to implement them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，在本章中，我们将介绍 Azure Functions 中可用的不同触发器。这里的重点不仅仅是写关于它，还要测试每个触发器。在[*第1章*](Chapter_1.xhtml#_idTextAnchor022)，“揭秘无服务器应用程序”，我们介绍了其基础知识，但当时没有机会实现它们。
- en: In this chapter, we will focus on three important triggers that we can use when
    implementing Azure Functions – the HTTP, SQL, and Cosmos DB triggers. Together
    with their implementation, we will discuss their advantages, disadvantages, and
    when they are a good approach to be used. We will also see how they work using
    the car-sharing example as a basis for understanding the purpose of each trigger
    better. Let’s start!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注在实现 Azure Functions 时可以使用的三个重要触发器——HTTP、SQL 和 Cosmos DB 触发器。我们将讨论它们的优缺点以及何时是使用它们的良好方法。我们还将通过共享汽车示例来了解每个触发器的目的。让我们开始吧！
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the free *Community edition* of Visual Studio 2022, or
    Visual Studio Code. You will also need an Azure account to create the sample environment.
    You can find the sample code for this chapter at [https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp](https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要免费版的 *Visual Studio 2022 社区版* 或 Visual Studio Code。您还需要一个 Azure 账户来创建示例环境。您可以在
    [https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp](https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp)
    找到本章的示例代码。
- en: HTTP trigger
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 触发器
- en: The most used trigger in Azure Functions is certainly the HTTP trigger. The
    basis of this option is to enable you to have HTTP requests, so you can build
    APIs, webhooks, and integrations in a very fast way. The idea is that a method
    in Azure Functions is triggered as soon as an HTTP request is made, enabling the
    appropriate function to return the corresponding response.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure Functions 中，最常用的触发器无疑是 HTTP 触发器。此选项的基础是允许您拥有 HTTP 请求，因此您可以非常快速地构建 API、webhooks
    和集成。其理念是 Azure Functions 中的方法在收到 HTTP 请求时立即触发，使适当的函数返回相应的响应。
- en: Advantages, disadvantages, and when to use the HTTP trigger
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优势、劣势以及何时使用 HTTP 触发器
- en: The main advantage of the HTTP trigger is its ease of use. It is straightforward
    to implement and can be set up quickly. So, even if you are new to Azure Functions,
    you can get started with it quickly.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 触发器的最大优势是它的易用性。实现起来简单直接，可以快速设置。因此，即使您是 Azure Functions 的初学者，也可以快速开始使用它。
- en: Besides that, it supports multiple HTTP methods, such as `GET`, `POST`, `PUT`,
    and `DELETE`, allowing you to handle a variety of web requests and actions. You
    can also have more than one function running on the same application, so it is
    a great way of delivering a microservice.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它支持多种 HTTP 方法，如 `GET`、`POST`、`PUT` 和 `DELETE`，允许您处理各种网络请求和操作。您还可以在同一个应用程序上运行多个函数，因此这是一种交付微服务的绝佳方式。
- en: Another great advantage of HTTP triggers is that they can integrate with other
    Azure services and third-party APIs, so you can handle complex logic. All these
    benefits come on top of the scalability and cost-effectiveness delivered by Azure
    Functions, so your application will remain responsive under high traffic and you
    will only pay for the executions that you carry out.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 触发器的另一个巨大优势是它们可以与其他 Azure 服务和第三方 API 集成，因此您可以处理复杂的逻辑。所有这些好处都建立在 Azure Functions
    提供的可扩展性和成本效益之上，因此您的应用程序在高流量下将保持响应，并且您只需为执行的代码付费。
- en: 'When it comes to security, HTTP triggers enable us to implement different levels
    of authorization. These levels range from anonymous access up to the admin level,
    as described in the `AuthorizationLevel` enum:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到安全性时，HTTP 触发器使我们能够实现不同级别的授权。这些级别从匿名访问到 `AuthorizationLevel` 枚举中描述的管理员级别不等。
- en: '![Figure 4.1: Authorization level – source: Microsoft Learn](img/B31916_04_1.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：授权级别 – 来源：Microsoft Learn](img/B31916_04_1.png)'
- en: 'Figure 4.1: Authorization level – source: Microsoft Learn'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：授权级别 – 来源：Microsoft Learn
- en: It is worth mentioning that these keys are managed inside an Azure Functions
    app, as we can see in the following figure.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这些密钥在 Azure Functions 应用程序内部管理，正如我们在以下图中可以看到的。
- en: '![Figure 4.2: Azure Functions – App keys](img/B31916_04_2.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2：Azure Functions – 应用密钥](img/B31916_04_2.png)'
- en: 'Figure 4.2: Azure Functions – App keys'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：Azure Functions – 应用密钥
- en: When it comes to the disadvantages of HTTP triggers, there is what is called
    **cold-start latency**, where there must be a delay the first time the function
    is invoked after a period of inactivity. Also, you must consider that the idea
    of this kind of application is to deliver stateless solutions, so handling stateful
    operations or long-running processes can be more challenging with HTTP triggers
    alone. For this, you may consider using Azure Durable Functions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到 HTTP 触发器的缺点时，有一个被称为**冷启动延迟**的现象，即在一段时间的不活跃后第一次调用函数时必须有一个延迟。此外，你必须考虑到这种应用程序的理念是提供无状态解决方案，因此仅使用
    HTTP 触发器处理有状态操作或长时间运行的过程可能会更具挑战性。为此，你可能考虑使用 Azure Durable Functions。
- en: You may also encounter some resource limits, such as execution timeouts and
    memory used, but these limits usually mean that you are encountering a design
    issue.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会遇到一些资源限制，例如执行超时和使用的内存，但这些限制通常意味着你遇到了设计问题。
- en: Considering all the information provided, the HTTP trigger is best used in scenarios
    where you need to create lightweight, stateless functions that respond to web
    requests. This may include RESTful APIs to expose an application’s functionality
    or a microservice, webhooks for handling real-time notifications, or even drive
    integrations. HTTP triggers can also be great for rapidly testing a scenario,
    using it as a prototype.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到提供的信息，HTTP 触发器最适合在需要创建轻量级、无状态函数以响应用户 Web 请求的场景中使用。这可能包括暴露应用程序功能或微服务的 RESTful
    API、处理实时通知的 webhooks，甚至驱动集成。HTTP 触发器也可以用于快速测试场景，将其用作原型。
- en: Car-sharing HTTP trigger example
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享汽车 HTTP 触发器示例
- en: As we discussed in [*Chapter 2*](Chapter_2.xhtml#_idTextAnchor038), *Demystifying
    Microservices Applications*, the carholders’ requests can be called by a user
    throughout CRUD operations. The sample code provided in this chapter will give
    you an Azure Functions project with four HTTP trigger functions that represent
    these CRUD operations. Also, it is important to mention that today it is good
    practice to deliver APIs with OpenAPI documentation attached. To do so, this example
    will make use of the **OpenAPI extension for Azure Functions**. The result can
    be seen in the following figure, where we have described each Azure Functions
    HTTP trigger created.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第 2 章*](Chapter_2.xhtml#_idTextAnchor038)中讨论的，《揭秘微服务应用程序》，车主的请求可以在 CRUD
    操作中被用户调用。本章提供的示例代码将为你提供一个包含四个 HTTP 触发器函数的 Azure Functions 项目，这些函数代表这些 CRUD 操作。此外，重要的是要提到，今天将带有
    OpenAPI 文档的 API 交付视为一种良好的实践。为此，此示例将使用 **Azure Functions 的 OpenAPI 扩展**。结果可以在以下图中看到，其中我们描述了创建的每个
    Azure Functions HTTP 触发器。
- en: '![Figure 4.3: Car Holding API sample](img/B31916_04_3.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3：汽车持有 API 示例](img/B31916_04_3.png)'
- en: 'Figure 4.3: Car Holding API sample'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：汽车持有 API 示例
- en: The great thing about delivering APIs with this pattern is that you will be
    following the most common scenarios of APIs that the current industry is requesting.
    Also, delivering versioned APIs is considered a great practice to follow, so you
    can guarantee compatibility with other systems.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式交付 API 的好处是，你将遵循当前行业请求的最常见 API 场景。此外，交付版本化 API 被认为是一种很好的实践，这样你可以确保与其他系统的兼容性。
- en: Advantages, disadvantages, and when to use the Azure SQL trigger
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure SQL 触发的优点、缺点以及何时使用
- en: Imagine the possibility of having a function trigger as soon as an Azure SQL
    Database change happens. This is where the Azure SQL trigger can help you. With
    the possibility of monitoring rows that are inserted, updated, or deleted, this
    function is invoked as soon as the event happens, enabling real-time data processing
    and integration.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，当Azure SQL数据库发生更改时，立即触发一个函数的可能性。这就是Azure SQL触发器能帮助您的地方。有了监控插入、更新或删除的行的可能性，这个函数在事件发生时立即被调用，从而实现实时数据处理和集成。
- en: It is important to mention that this trigger is only available if you have SQL
    Server change tracking enabled in your database and in the table that you define
    to monitor.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要提到，此触发器仅在您的数据库和定义要监控的表中启用了SQL Server更改跟踪时才可用。
- en: Considering this possibility, real-time processing using this functionality
    is a great advantage. Since Azure Functions in general is a great way of achieving
    scalability only when needed, this functionality also gives us great architecture
    with great cost-efficiency, allowing us to integrate different scenarios and applications
    with it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这种可能性，使用此功能进行实时处理是一个巨大的优势。由于Azure Functions通常只在需要时才是一种实现可伸缩性的好方法，因此此功能也为我们提供了具有高成本效益的出色架构，使我们能够将其与不同的场景和应用集成。
- en: On the other hand, you need to pay attention to the complexity of setting these
    triggers. You must consider what will be easier to design, a timer trigger monitoring
    your data or the option provided by this kind of trigger. Latency can also be
    a problem, so be careful with that.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，您需要注意设置这些触发器的复杂性。您必须考虑什么更容易设计，是一个监控数据的计时器触发器，还是这种触发器提供的选项。延迟也可能成为一个问题，所以请小心。
- en: Certainly, the Azure SQL trigger is great to use in real-time data processing,
    where database changes can be critical to some operations. If you want to synchronize,
    audit, or even transform data, this can also be useful.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Azure SQL触发器在实时数据处理中非常适用，因为数据库的更改可能对某些操作至关重要。如果您想同步、审计甚至转换数据，这也会很有用。
- en: Car-sharing SQL trigger example
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Car-sharing SQL触发器示例
- en: 'For this demo, an Azure SQL database was created called `CarShareDB`. In addition,
    a table called `Carholder` was also created, and both the database and table were
    enabled to track their changes, as you can see in the following script:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个演示，创建了一个名为`CarShareDB`的Azure SQL数据库。此外，还创建了一个名为`Carholder`的表，数据库和表都启用了更改跟踪，如下面的脚本所示：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The idea behind this kind of Azure function is to be able to audit the changes
    made in the table that is being tracked. So, an Azure function with a SQL trigger
    was created.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种Azure函数背后的想法是能够审计正在跟踪的表中做出的更改。因此，创建了一个具有SQL触发的Azure函数。
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are three important things to observe in this code. The first one is
    that this Functions app needs a variable called `WEBSITE_SITE_NAME`. This variable
    needs to be placed in the `local.settings.json` file for debugging locally and
    will be stored in the environment variables of the app when published. The code
    block shown below is the content of the `json` file we have mentioned, defining
    the `WEBSITE_SITE_NAME` variable:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，有三件重要的事情需要注意。第一点是，这个Functions应用需要一个名为`WEBSITE_SITE_NAME`的变量。这个变量需要放置在`local.settings.json`文件中用于本地调试，并在发布时存储在应用的环镜变量中。下面显示的代码块是我们提到的`json`文件的内容，定义了`WEBSITE_SITE_NAME`变量：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Second, there is a connection between the code and SQL Server using the `CarShareConnectionString`
    variable, which is stored in the local user secret, as we can see in the following
    figure.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，代码和SQL Server之间通过`CarShareConnectionString`变量建立了连接，该变量存储在本地用户密钥中，如下面的图所示。
- en: '![Figure 4.4: Managing user secrets locally](img/B31916_04_4.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4：本地管理用户密钥](img/B31916_04_4.png)'
- en: 'Figure 4.4: Managing user secrets locally'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：本地管理用户密钥
- en: The last thing to observe is that you need to define the class that represents
    the entity that is monitored so that every single change made in the table will
    be triggered and the data related to the change will be available for usage. In
    the example that we are presenting, the class was named `Carholder`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的是，您需要定义表示被监控实体的类，以便表中的每个更改都会触发，并且与更改相关的数据将可用于使用。在我们提供的示例中，这个类被命名为`Carholder`。
- en: '![Figure 4.5: Function trigger](img/B31916_04_5.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5：函数触发器](img/B31916_04_5.png)'
- en: 'Figure 4.5: Function trigger'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：函数触发器
- en: The result of each trigger can be checked above. Notice that inserts and updates
    are sent with the object totally filled, while deletes returns only the ID of
    an object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个触发器的结果都可以在上面检查。请注意，插入和更新操作会发送完全填充的对象，而删除操作只返回对象的 ID。
- en: Advantages, disadvantages, and when to use the Cosmos DB trigger
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cosmos DB 触发器的优势、劣势以及何时使用
- en: In the same way that we have discussed the benefits and downsides when using
    Azure SQL triggers, we can also discuss Cosmos DB triggers. This is a powerful
    feature that allows you to execute serverless functions in response to changes
    in your Cosmos DB data. Regardless of whether the items are added, updated, or
    deleted in a Cosmos DB collection, the trigger will automatically invoke your
    function, which enables real-time data processing and integration.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论了使用 Azure SQL 触发器时的好处和缺点一样，我们也可以讨论 Cosmos DB 触发器。这是一个强大的功能，允许你在 Cosmos
    DB 数据发生变化时执行无服务器函数。无论在 Cosmos DB 集合中添加、更新还是删除项目，触发器都会自动调用你的函数，从而实现实时数据处理和集成。
- en: Considering this scenario, it is important to mention that Azure Cosmos DB gives
    you more flexibility with the data you are handling since it enables non-structured
    data. For instance, suppose you want to process telemetry sent by the car that
    is being shared. This kind of data would be a bit strange to be handled in Azure
    SQL Database. On the other hand, using this data in Cosmos DB can be a good approach.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个场景，重要的是要提到 Azure Cosmos DB 为你提供了处理数据的更多灵活性，因为它支持非结构化数据。例如，假设你想处理共享汽车发送的遥测数据。这种数据在
    Azure SQL 数据库中处理可能会有些奇怪。另一方面，在 Cosmos DB 中使用这些数据可能是一个好的方法。
- en: These great advantages can be analyzed together with some concerns that you
    may have while developing a solution using a Cosmos DB trigger. The most important
    one to consider is cost since Cosmos DB applications can be extremely expensive
    depending on the solution that is developed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些显著优势可以与你在使用 Cosmos DB 触发器开发解决方案时可能产生的某些担忧一起分析。其中最重要的一个考虑因素是成本，因为 Cosmos DB
    应用程序的成本可能会非常高，具体取决于所开发的解决方案。
- en: Car-sharing Cosmos DB trigger example
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汽车共享 Cosmos DB 触发器示例
- en: For high performance and globally distributed data storage, suppose the car-sharing
    app uses Cosmos DB to store real-time car telemetry data, with user activity logs
    and location information.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高性能和全球分布式的数据存储，假设汽车共享应用程序使用 Cosmos DB 存储实时汽车遥测数据，以及用户活动日志和位置信息。
- en: The following figure shows how an Azure Functions app was created to enable
    the connection to Azure Cosmos DB.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了如何创建一个 Azure Functions 应用程序，以实现与 Azure Cosmos DB 的连接。
- en: '![Figure 4.6: Creating an Azure Cosmos DB trigger function](img/B31916_04_6.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6：创建 Azure Cosmos DB 触发器函数](img/B31916_04_6.png)'
- en: 'Figure 4.6: Creating an Azure Cosmos DB trigger function'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：创建 Azure Cosmos DB 触发器函数
- en: It is great to mention that there is an Azure Cosmos DB emulator that you can
    use to test and debug your solution, saving costs for this step of development.
    For that, you will need to install Docker. It is important to remember that this
    is an alternative for testing only; production environments must use Azure Cosmos
    DB itself.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 提到这一点很棒，因为有一个 Azure Cosmos DB 模拟器，你可以用它来测试和调试你的解决方案，从而节省开发这一步骤的成本。为此，你需要安装 Docker。重要的是要记住，这仅是测试的替代方案；生产环境必须使用
    Azure Cosmos DB 本身。
- en: However, it should also be noted that Visual Studio can also help you create
    your Azure Cosmos DB. As you can see in the following figure, there is a wizard
    where you can set the common variables needed to create the resource in your Azure
    account inside the Visual Studio environment.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也应指出，Visual Studio 也可以帮助你创建 Azure Cosmos DB。正如你在以下图中可以看到的，有一个向导，你可以设置在 Visual
    Studio 环境中创建 Azure 账户中资源的常用变量。
- en: '![Figure 4.7: Creating Azure Cosmos DB](img/B31916_04_7.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7：创建 Azure Cosmos DB](img/B31916_04_7.png)'
- en: 'Figure 4.7: Creating Azure Cosmos DB'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7：创建 Azure Cosmos DB
- en: 'It takes a while to create Azure Cosmos DB. Once this step is done, it is time
    to analyze exactly how the function trigger works. Notice that it also works based
    on the connecting string to the database and the information you want to monitor.
    In the case of the example, `car-telemetry` is being monitored:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Azure Cosmos DB 需要一些时间。一旦完成这一步，就需要分析函数触发器的工作方式。请注意，它也是基于数据库的连接字符串和你要监控的信息来工作的。在示例中，正在监控
    `car-telemetry`：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To test the function, you can use the user interface provided by Azure Cosmos
    DB in the Azure portal.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试该函数，你可以使用 Azure 门户中提供的 Azure Cosmos DB 用户界面。
- en: '![Figure 4.8: Inserting data into Azure Cosmos DB](img/B31916_04_8.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8：向Azure Cosmos DB插入数据](img/B31916_04_8.png)'
- en: 'Figure 4.8: Inserting data into Azure Cosmos DB'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：向Azure Cosmos DB插入数据
- en: The result can be checked by inserting a breakpoint in the code of the Azure
    function, where we can check that the data sent can be seen in the code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以通过在Azure函数的代码中插入断点来检查，我们可以检查发送的数据是否可以在代码中看到。
- en: '![Figure 4.9: Azure Cosmos DB trigger](img/B31916_04_9.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9：Azure Cosmos DB触发器](img/B31916_04_9.png)'
- en: 'Figure 4.9: Azure Cosmos DB trigger'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：Azure Cosmos DB触发器
- en: Although the Azure Cosmos DB trigger is very similar to the Azure SQL trigger,
    it is important to mention that the Azure Cosmos DB trigger only monitors inserts
    and updates in Cosmos DB. So, if you need to monitor deletions, you will not have
    this option in this kind of trigger.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Azure Cosmos DB触发器与Azure SQL触发器非常相似，但重要的是要提到，Azure Cosmos DB触发器仅监控Cosmos DB中的插入和更新操作。因此，如果您需要监控删除操作，这种触发器类型将不会提供此选项。
- en: Azure Service Bus trigger
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure Service Bus触发器
- en: One of the most important components in a microservices solution is a service
    bus for enabling communication between the microservices. Azure Service Bus is
    one of the options presented on the market to do so.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务解决方案中，最重要的组件之一是用于在微服务之间启用通信的服务总线。Azure Service Bus是市场上提供的选项之一。
- en: Azure Functions provides two ways of connecting to Azure Service Bus. You can
    monitor a specific queue or a general topic. The concept behind the Azure Service
    Bus queue service is to deliver a solution that enables reliable communication
    between distributed applications and services. It operates on a **first-in, first-out**
    (**FIFO**) basis, ensuring that messages are processed in the order they were
    sent. If you need to decouple an application, enhance scalability, and maintain
    high availability by buffering messages during peak loads, you may decide to use
    it. It is important to remember that messages sent to the queue are stored until
    they are retrieved and processed by the receiving application, guaranteeing delivery
    even in the face of transient failures. It is great to mention that the Service
    Bus queue supports features such as message sessions for ordered processing, dead-letter
    queues for handling message failures, and duplicate detection to prevent the processing
    of duplicate messages.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions提供了两种连接到Azure Service Bus的方式。您可以监控特定的队列或通用的主题。Azure Service Bus队列服务的概念是提供一个解决方案，该解决方案能够确保分布式应用程序和服务之间可靠的通信。它基于**先进先出**（**FIFO**）的原则运行，确保消息按照发送的顺序进行处理。如果您需要通过在高峰负载期间缓冲消息来解耦应用程序、增强可伸缩性和保持高可用性，您可能决定使用它。重要的是要记住，发送到队列的消息将被存储，直到它们被接收应用程序检索和处理，即使在短暂故障的情况下也能保证交付。值得提及的是，Service
    Bus队列支持诸如按顺序处理的消息会话、处理消息失败时的死信队列以及防止处理重复消息的重复检测等功能。
- en: On the other hand, Azure Service Bus topics are designed for scenarios that
    require a publish/subscribe model. This feature enables multiple subscribers to
    receive copies of the same message, allowing for greater flexibility and scalability
    in your messaging infrastructure. With topics, you can filter messages based on
    specific criteria, ensuring that each subscriber only receives the messages relevant
    to them. This is particularly useful in complex workflows where different components
    or services need to react to different types of events.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Azure Service Bus主题是为需要发布/订阅模型的情况而设计的。这个特性使得多个订阅者可以接收相同消息的副本，从而在您的消息基础设施中提供更大的灵活性和可伸缩性。使用主题，您可以基于特定标准过滤消息，确保每个订阅者只接收与他们相关的消息。这在复杂的流程中特别有用，其中不同的组件或服务需要响应不同类型的事件。
- en: The Azure Service Bus trigger also enables scalability, reliability, integration,
    and flexibility for your solution, since this is something delivered by default
    for any Azure function. As a point of concern, again, the cost must be considered.
    It is worth noting that queues are cheaper than topics, so you may analyze if
    topics are really needed for your solution. Also, do not forget to check that
    the performance you need for your application will not be degraded with the service
    bus you have selected.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Service Bus触发器同样可以为您的解决方案提供可伸缩性、可靠性、集成和灵活性，因为这是任何Azure函数默认提供的服务。作为一个需要注意的点，再次强调，成本必须被考虑。值得注意的是，队列比主题便宜，因此您可能需要分析是否真的需要主题。此外，别忘了检查您所需的应用程序性能不会因为所选的服务总线而降低。
- en: The Azure Service Bus trigger can be used when you are developing an event-driven
    solution and you want to process messages or even design a workflow automation.
    For instance, in the car-sharing example, we will use the trigger to represent
    when someone is searching for a car.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在开发事件驱动的解决方案，并希望处理消息或设计工作流自动化时，可以使用 Azure 服务总线触发器。例如，在共享汽车的例子中，我们将使用触发器来表示有人正在寻找汽车。
- en: Comparison with the Kafka trigger and the RabbitMQ trigger
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Kafka 触发器和 RabbitMQ 触发器的比较
- en: The Azure Functions Service Bus trigger, Kafka trigger, and RabbitMQ trigger
    all serve similar purposes. However, depending on the scenario you are working
    on, you may decide to select a different bus.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 服务总线触发器、Kafka 触发器和 RabbitMQ 触发器都服务于类似的目的。然而，根据你正在处理的场景，你可能决定选择不同的总线。
- en: For example, Kafka is well known for scenarios where distributed streaming is
    required, and where you will have high throughput with real-time data processing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Kafka 因其在需要分布式流处理和实时数据处理的高吞吐量场景中而闻名。
- en: On the other hand, RabbitMQ is easier to use, and it is better for lightweight
    and flexible messages, especially if you need compatibility with multiple messaging
    protocols.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，RabbitMQ 更易于使用，对于轻量级和灵活的消息来说更好，特别是如果你需要与多个消息协议兼容的话。
- en: Azure Service Bus is well integrated with Azure services, although it supports
    various message patterns. If you need reliable delivery and processing, this may
    be the best option.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 服务总线与 Azure 服务集成良好，尽管它支持各种消息模式。如果你需要可靠的交付和处理，这可能是最佳选择。
- en: As you can see, each of these buses has its advantages and is suited for different
    types of applications. The triggers available in Azure Functions for them are
    very similar, so choosing the right trigger depends more on the specific requirements
    of the application you are designing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个总线都有其优势，适合不同类型的应用。Azure Functions 中为它们提供的触发器非常相似，因此选择正确的触发器更多地取决于你正在设计的应用程序的具体要求。
- en: Car-sharing example with the Azure Service Bus trigger
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Azure 服务总线触发器的共享汽车示例
- en: The Azure Service Bus trigger is used in our example for the subscription of
    the message that indicates a car-seeking request. The idea behind using a topic
    here is that many microservices of the solution may want to know that a car-seeking
    request is being made. The service that we are simulating in the example is the
    one that will start the route planner for the car that is needed, as we can see
    in the following figure.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，Azure 服务总线触发器用于订阅表示寻找汽车请求的消息。在这里使用主题的想法是，解决方案的许多微服务可能都想知道正在发起寻找汽车的请求。我们模拟的示例服务是启动所需汽车路线规划器的服务，如下面的图所示。
- en: '![Figure 4.10: Route handling subsystem of a car-sharing application](img/B31916_04_10.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10：共享汽车应用的路由处理子系统](img/B31916_04_10.png)'
- en: 'Figure 4.10: Route handling subsystem of a car-sharing application'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：共享汽车应用的路由处理子系统
- en: 'To do so, an Azure function for monitoring the Service Bus trigger in the topic
    `car-seeking-requests` is created. The messages that are subscribed from this
    topic are the ones named `routes`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，创建了一个用于监控主题 `car-seeking-requests` 中服务总线触发器的 Azure 函数。从这个主题订阅的消息被命名为
    `routes`：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once a message is sent for a route, the function is automatically triggered,
    and all the information presented in the body of the message, together with information
    about the content type of the message and its ID, is available in the Azure function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发送了路线消息，函数会自动触发，消息体中呈现的所有信息，以及关于消息内容类型和其 ID 的信息，都可在 Azure 函数中获取。
- en: '![Figure 4.11: Message triggered after Azure Service Bus received the content](img/B31916_04_11.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11：Azure 服务总线接收到内容后触发的消息](img/B31916_04_11.png)'
- en: 'Figure 4.11: Message triggered after Azure Service Bus received the content'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11：Azure 服务总线接收到内容后触发的消息
- en: It is important to note that once the message is processed by the Azure function,
    since there is no other subscriber, the message is cleared from the bus. It is
    also necessary to remember that if the function is not running, the bus service
    will retain them according to the settings configured in Azure Service Bus.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，一旦消息被 Azure 函数处理，由于没有其他订阅者，消息将从总线上清除。还需要记住，如果函数没有运行，总线服务将根据在 Azure 服务总线中配置的设置保留它们。
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided a comprehensive overview of various triggers available
    in Azure Functions, focusing on their advantages, disadvantages, and practical
    use cases. It then delved into specific triggers, starting with the HTTP trigger,
    which was highlighted for its ease of use and versatility in handling web requests.
    The support for multiple HTTP methods and integration with other Azure services
    were also advantages presented in the chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了 Azure Functions 中各种触发器的全面概述，重点关注它们的优缺点和实际用例。然后深入探讨了特定的触发器，从易于使用且在处理网络请求方面具有灵活性的
    HTTP 触发器开始。本章还提到了支持多种 HTTP 方法以及与其他 Azure 服务集成的优势。
- en: The chapter also covered Azure SQL triggers, emphasizing their real-time data
    processing capabilities and the requirement for SQL Server change tracking. Similarly,
    the Cosmos DB trigger was explained, with its benefits in handling non-structured
    data and real-time processing presented.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还涵盖了 Azure SQL 触发器，强调了它们的实时数据处理能力以及 SQL Server 变更跟踪的要求。同样，Cosmos DB 触发器也得到了解释，其处理非结构化数据和实时处理的优势也得到了展示。
- en: To finish, the chapter compared the Azure Service Bus, Kafka, and RabbitMQ services,
    presenting a demo using an Azure Service Bus trigger for the car-sharing application
    presented in the book.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章比较了 Azure 服务总线、Kafka 和 RabbitMQ 服务，展示了使用 Azure 服务总线触发器为书中提到的拼车应用程序进行演示。
- en: Questions
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the main advantages of using HTTP triggers in Azure Functions?
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Azure Functions 中使用 HTTP 触发器的主要优势是什么？
- en: HTTP triggers offer a straightforward and standardized way of exposing your
    functions as web endpoints, making it easy to create APIs and webhooks. They allow
    rapid development and integration with other web services and client applications,
    leveraging familiar HTTP methods and status codes for communication.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 触发器提供了一个简单且标准化的方式来将你的函数作为网络端点公开，这使得创建 API 和 webhook 变得容易。它们允许快速开发和与其他网络服务及客户端应用程序的集成，利用熟悉的
    HTTP 方法和状态码进行通信。
- en: In addition, HTTP triggers enable automatic scaling, so your functions can handle
    varying loads efficiently. This helps ensure that your applications remain responsive
    under fluctuating traffic while benefiting from a pay-as-you-go pricing model
    that optimizes costs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，HTTP 触发器还支持自动扩展，因此你的函数可以高效地处理变化的负载。这有助于确保在流量波动的情况下，你的应用程序保持响应，同时从优化成本的按需付费定价模型中受益。
- en: What are some potential disadvantages of using HTTP triggers, and how can they
    be mitigated?
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 HTTP 触发器的潜在缺点有哪些，以及如何减轻这些缺点？
- en: One potential disadvantage is the occurrence of cold starts, particularly on
    the Consumption plan, which may cause delays during initial HTTP requests. Additionally,
    exposing functions via HTTP requires careful attention to security, as misconfigured
    endpoints could become vulnerable to unauthorized access or abuse.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个潜在的缺点是冷启动的发生，尤其是在消耗计划中，这可能导致在初始 HTTP 请求期间出现延迟。此外，通过 HTTP 公开函数需要仔细关注安全性，因为配置错误的端点可能会变得容易受到未经授权的访问或滥用。
- en: These concerns can be mitigated by implementing strategies such as using Premium
    or Dedicated plans to reduce cold start delays, adding warm-up triggers, or enforcing
    robust authentication and authorization policies. Leveraging API Management or
    other gateway solutions can also help secure and manage HTTP-triggered functions
    effectively.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施策略，如使用高级或专用计划以减少冷启动延迟，添加预热触发器，或强制执行强大的身份验证和授权策略，可以减轻这些担忧。利用 API 管理或其他网关解决方案也可以有效地帮助保护和管理工作通过
    HTTP 触发的函数。
- en: How does the Azure SQL trigger enable real-time data processing, and what are
    its requirements?
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure SQL 触发器如何实现实时数据处理，以及它的要求是什么？
- en: Although Azure Functions does not include a native SQL trigger, real-time data
    processing can be achieved by combining database change detection (using SQL change
    tracking or change data capture) with a function that polls or listens for changes.
    This approach enables the system to react to data modifications almost immediately,
    triggering processing workflows as soon as a change is detected.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Azure Functions 不包含本机 SQL 触发器，但通过结合数据库变更检测（使用 SQL 变更跟踪或变更数据捕获）与轮询或监听变更的函数，可以实现实时数据处理。这种方法使系统能够几乎立即对数据修改做出反应，一旦检测到变更就触发处理工作流。
- en: To implement this, your Azure SQL database must have change tracking or CDC
    enabled, and you need to configure a reliable mechanism for querying changes at
    regular intervals. Proper connectivity, efficient query design, and handling of
    potential latency issues are key requirements for ensuring that real-time processing
    is both accurate and performant.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，您的 Azure SQL 数据库必须启用更改跟踪或 CDC，并且您需要配置一个可靠的机制，以便定期查询更改。适当的连接性、高效的查询设计以及处理潜在的延迟问题是确保实时处理既准确又高效的关键要求。
- en: What are the benefits and concerns associated with using Cosmos DB triggers
    in Azure Functions?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Azure Functions 中的 Cosmos DB 触发器有哪些好处和担忧？
- en: Cosmos DB triggers provide near real-time processing of data changes by leveraging
    the Cosmos DB change feed. This integration allows your functions to automatically
    respond to new or updated documents, enabling event-driven workflows and scalable
    data processing without requiring manual polling.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Cosmos DB 触发器通过利用 Cosmos DB 变更流提供近实时数据处理。这种集成允许您的函数自动响应新或更新的文档，从而实现事件驱动的流程和可扩展的数据处理，无需手动轮询。
- en: However, there are concerns such as potential throttling and cost implications
    if the throughput is not properly managed. Moreover, ensuring data consistency
    and handling high-volume change feeds can be challenging. These issues can be
    addressed through careful planning of request units (RUs), partitioning strategies,
    and monitoring the performance and load of your Cosmos DB account.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果吞吐量没有得到适当管理，可能会出现潜在的节流和成本影响。此外，确保数据一致性和处理高容量变更流可能具有挑战性。这些问题可以通过仔细规划请求单位（RUs）、分区策略以及监控
    Cosmos DB 账户的性能和负载来解决。
- en: How do Azure Service Bus triggers compare with Kafka and RabbitMQ triggers,
    and in what scenarios are they best used?
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure 服务总线触发器与 Kafka 和 RabbitMQ 触发器相比如何，它们在哪些场景下使用最佳？
- en: Azure Service Bus triggers are part of a fully managed messaging service that
    offers features like reliable message delivery, dead-lettering, sessions, and
    auto-scaling. They integrate seamlessly with the Azure ecosystem, making them
    ideal for enterprise scenarios where robust, secure, and managed message processing
    is required.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 服务总线触发器是完整托管消息服务的一部分，它提供可靠的消息传递、死信队列、会话和自动扩展等功能。它们与 Azure 生态系统无缝集成，使它们成为需要强大、安全和管理消息处理的企业的理想选择。
- en: In contrast, Kafka and RabbitMQ are often chosen for their high throughput (Kafka)
    or lightweight, flexible messaging (RabbitMQ) in environments where you might
    require more control over the infrastructure. Azure Service Bus triggers are best
    suited for scenarios that benefit from a managed service with deep integration
    into Azure, particularly when the application requires enterprise-level messaging
    reliability and scalability without the overhead of managing the messaging infrastructure.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，Kafka 和 RabbitMQ 通常因其高吞吐量（Kafka）或轻量级、灵活的消息传递（RabbitMQ）而被选择，在可能需要更多基础设施控制的环境中。Azure
    服务总线触发器最适合那些从与 Azure 深度集成的托管服务中受益的场景，尤其是当应用程序需要企业级消息可靠性和可扩展性而不需要管理消息基础设施的开销时。
- en: Further reading
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Azure Function HTTP trigger: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook-trigger](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook-trigger)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Function HTTP 触发器：[https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook-trigger](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook-trigger)
- en: 'Azure Function SQL trigger: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-azure-sql](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-azure-sql)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Function SQL 触发器：[https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-azure-sql](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-azure-sql)
- en: 'SQL Server change tracking: [https://learn.microsoft.com/en-us/sql/relational-databases/track-changes/about-change-tracking-sql-server](https://learn.microsoft.com/en-us/sql/relational-databases/track-changes/about-change-tracking-sql-server)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server 更改跟踪：[https://learn.microsoft.com/en-us/sql/relational-databases/track-changes/about-change-tracking-sql-server](https://learn.microsoft.com/en-us/sql/relational-databases/track-changes/about-change-tracking-sql-server)
- en: 'Azure Functions Cosmos DB trigger: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-cosmosdb](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-cosmosdb)'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions Cosmos DB 触发器：[https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-cosmosdb](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-cosmosdb)
- en: 'Azure Functions Service Bus trigger: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-service-bus](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-service-bus)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions 服务总线触发器：[https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-service-bus](https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-service-bus)
- en: 'Queue design pattern: [https://learn.microsoft.com/en-us/azure/architecture/patterns/queue-based-load-leveling](https://learn.microsoft.com/en-us/azure/architecture/patterns/queue-based-load-leveling)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列设计模式：[https://learn.microsoft.com/en-us/azure/architecture/patterns/queue-based-load-leveling](https://learn.microsoft.com/en-us/azure/architecture/patterns/queue-based-load-leveling)
- en: 'Publisher-Subscriber design pattern: https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者-订阅者设计模式：[https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber](https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber)
- en: 'Storing secrets: [https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets](https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储机密：[https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets](https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets)
- en: Join our community on Discord
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/PSMCSharp](https://packt.link/PSMCSharp)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/PSMCSharp](https://packt.link/PSMCSharp)'
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/B31916_Discord-QR-Code.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![带有黑色方块的二维码，AI生成的内容可能不正确。](img/B31916_Discord-QR-Code.png)'
