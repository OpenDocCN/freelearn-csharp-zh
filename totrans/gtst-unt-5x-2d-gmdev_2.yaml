- en: Chapter 2. Baking Cupcake Towers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this second chapter, we will begin to build our game. We will see how it's
    possible to place objects in 2D space and create templates for the most used objects.
    Furthermore, we will see how Unity deals with scripts, and we will write a couple
    of our own for our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Placing objects in 2D space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the map for our game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tags and layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Prefabs (templates for game objects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic concepts of scripting in Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing our first two scripts for our game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like all the other chapters of this book, you will find the *Homework* section
    at the end. It has a range of different exercises for you to do to improve your
    skills and implement a range of different functionalities into your game.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get started by learning how to place 2D objects into the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 2D objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw that 2D objects in Unity are Sprites. However,
    we didn't mention how to import them into the scene.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to bring your Sprites into the scene is to drag and drop them
    from the **Project** panel into the **Scene view**. Unity will automatically create
    a new game object with the same name of the Sprite along with a Sprite Renderer
    attached. We have already covered this component in the previous chapter. Since
    we will not use Sorting Layers (as we decided in the previous chapter), we don't
    need to change any settings when dragging a new Sprite into the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to add Sprites to the scene is by right-clicking on the **Hierarchy**
    panel and then **2D Object | Sprite**. However, in the Sprite Renderer, you need
    to specify which Sprite to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s bring the `Pink_Sprinkle` Sprite into our scene (you can find it in
    the `Graphics/projectiles` folder within the `projectiles_sheet_01` file). It
    appears like this in the **Scene** view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![2D objects](img/image00354.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since Sprites are also GameObjects, you can have access to their **Transform**
    properties, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![2D objects](img/image00355.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This means that you can change their position along the *x* axis and the *y*
    axis, as well as the scale and the rotation. Remember that the *z*-axis is used
    to determine the depth, as we discussed in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: By using the **Scale** parameter, it is possible to flip the Sprite. However,
    keep in mind that this will also flip its children. As we saw in the previous
    chapter, from Unity 5.3 to flip a Sprite it is preferable to use the **Flip**
    variable on the **Sprite Renderer**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can create an empty game object by navigating to the top bar menu and select
    **GameObject | Create Empty**. Alternatively, on the **Hierarchy** panel, click
    on **Create**, then select **Create Empty**. Creating an empty game object is
    a very useful when we need to create containers of other game objects, or if we
    want to build our game object from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Parenting game objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each game object can have a parent. This means that the game objects will move,
    rotate, and scale along with its parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'I could use many words to explain this concept, but there are things which
    videos can explain better than words. As such, there is a very short video explaining,
    *The Hierarchy and Parent-Child relationships *at: [https://unity3d.com/learn/tutorials/topics/interface-essentials/hierarchy-and-parent-child-relationships](https://unity3d.com/learn/tutorials/topics/interface-essentials/hierarchy-and-parent-child-relationships).'
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you to watch it before you continue reading this book. I'll
    wait for you here.
  prefs: []
  type: TYPE_NORMAL
- en: Difference between world coordinates and local coordinates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every game object in Unity has a position, but a position needs a reference
    frame (more about reference frames later in [Chapter 5](part0062.xhtml#aid-1R42S1
    "Chapter 5. The Secret Ingredient Is a Dash of Physics"), *The Secret Ingredient
    Is a Dash of Physics*). In particular, Unity offers two ways to see (and set)
    coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '**World coordinates**: These are absolute coordinates of where the game object
    is located (by absolute, I mean with respect to the world frame, which is considered
    to be absolute in the game)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local coordinates**: These are the coordinates of where the game object is
    with respect to its parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can easily switch between the two coordinates with a toggle in the upper-right
    part of the Unity interface, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Difference between world coordinates and local coordinates](img/image00356.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, they are both toggles, but the one to
    switch between world and local coordinates is the one on the left. At the moment,
    it is selected to be on **Global**, which means on world coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Ordering the different layers with Z-Buffering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we decided to use Z-Buffering instead of Sorting Layers.
    However, we need to decide which elements of our game will be in the foreground
    compared to the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, it is important to keep in mind how the camera is set. Select
    **Main Camera**, which should be the only camera in the scene. This is what the
    **Inspector** should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ordering the different layers with Z-Buffering](img/image00357.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, by default, its **Z** value on the the position is set to `-10`.
    This means you cannot have any greater negative values (that means smaller than
    `-10`) in the **Z** value of a Sprite, otherwise it will not be rendered. For
    our purpose, `-10` is perfect, and we will stick with it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to assign a **Z** value to all the elements that we have. We can
    start to place the map in the background, by assigning the lowest depth (maximum
    **Z** value) that we have in mind; in this case it's zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we would like to have the enemies. Therefore, we can set their **Z**
    value to `-1`. After them, the projectiles and the towers, respectively `-2` and
    `-3`. Finally, we need to add another value for the foreground. Here is a summary
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Elements** | **Z value (depth)** | **Reasons** |'
  prefs: []
  type: TYPE_TB
- en: '| Map | `0` | The map has the lowest value, since it will be behind everything.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Enemies | `-1` | Enemies are rendered after the map, since they may pass
    behind the towers, which we would like to keep visible. Furthermore, also the
    projectiles should be visible on the enemies, just before they hit them. |'
  prefs: []
  type: TYPE_TB
- en: '| Projectiles | `-2` | Projectiles are shot from the towers, so it may look
    odd having the projectiles on top of the tower, whereas appearing from the back
    appears more natural. |'
  prefs: []
  type: TYPE_TB
- en: '| Towers | `-3` | The towers don''t have any other layer on top of them, excluding
    the map overlay. |'
  prefs: []
  type: TYPE_TB
- en: '| Map Overlay | `-9` | This is in the foreground, so it has to be rendered
    last. We chose `-9` instead of `-4` because we may add some other layers, but
    the foreground is always the closest one to the camera. We will see what this
    layer contains in the next section. |'
  prefs: []
  type: TYPE_TB
- en: '| Main Camera | `-10` | As default. |'
  prefs: []
  type: TYPE_TB
- en: We need to keep these values in mind when we create the Prefabs for our game
    elements. This is important both for this chapter and the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will discuss what a Prefab is later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Unfolding the map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are finally ready to place the 2D map in our scene.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we have set the resolution to 16:9\. Therefore, the
    maps that we will find in our packages are ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by dragging the `sugar_mountain_map` Sprite from the `Graphics/maps`
    folder into our scene. We need to place it in (0,0,0). Please note that the *z*
    axis is set to zero.
  prefs: []
  type: TYPE_NORMAL
- en: It is a perfect map for what we need. For example, on the left side, there is
    the beginning of the path that the sweet-tooth pandas will follow. At the end
    of the path, there is the Sugar castle that the player needs to protect. Furthermore,
    there is enough space at the top to implement our user interface in [Chapter 3](part0043.xhtml#aid-190861
    "Chapter 3. Communicating with the Player – the User Interface"), *Communicating
    with the Player - the User Interface*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to modify the camera settings. What we want to do is to fit
    the entire map in the **Camera** view. To achieve this, just modify the **Size**
    properties to `22.5` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unfolding the map](img/image00358.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As a result, our map will be perfectly centered in the **Camera** view. This
    is what we should see in the **Scene** view with the camera selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unfolding the map](img/image00359.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s bring in one of the cupcake tower we sliced in the previous chapter;
    for instance, the `ChocolateChip_Cupcake_Tower_2`. If we drag it to the beginning
    of the path, we have the following problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unfolding the map](img/image00360.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Or also at the bottom of the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unfolding the map](img/image00361.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In fact, the cupcake tower is not supposed to be on the rock, but behind it,
    due to the perspective. Since we are working in a 2D world, we need to create
    a perspective. Luckily, our package contains an overlay of our map. It also contains
    all the assets that should be in the foreground, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unfolding the map](img/image00362.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that usually, all the assets are on different levels so we can customize
    their positions. However, in the package they are pre-placed as for your convenience,
    so we don't lose time to learn amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: So, let's add also this overlay to the scene. It is called `sugar_mountain_map_overlay`
    and can be found inside the `Graphics/maps` folder. Again, remember to set its
    *x* and *y* positions to zero. After we have done this, we don't see any difference,
    and the cupcake tower still hovers over the rock. In fact, we have decided from
    the previous section, that all of the *z*-axis values should be assigned to the
    different game elements. If you remember, the value for the map overlay is `-9`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have set the map overlay *z*-axis value, our cupcakes should behave
    as we wished:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unfolding the map](img/image00363.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It behaves in the right way here, as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unfolding the map](img/image00364.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The map is finally ready. One last touch; we should parent the map overlay to
    the map itself. Therefore, if we need to change the map, they will move and scale
    together.
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue our journey, remember to delete the cupcake tower, since
    we only needed it for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Layers and tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you already have in mind what are you going to do, it's good to set everything
    up at the beginning. In particular, Unity has some labels that can be given to
    game objects. These are layers and tags. Unity uses these two properties to discriminate
    amongst certain kinds of game objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, some of them are already defined, but we need a few more for our
    project. From the toolbar menu, we can access the layers and tags settings by
    navigating to **Edit** | **Project Settings** | **Tags and Layers**. As a result,
    the **Inspector** should now look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layers and tags](img/image00365.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this menu, we also have the possibility to change the sorting layers for
    rendering 2D objects. However, as mentioned earlier, we will use Z-Buffering to
    achieve the same effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s expand the **Tags** menu, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layers and tags](img/image00366.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To add a new tag, just press on the + button in the bottom-right corner. We
    need to add two tags, respectively `Enemy` and `**Projectile**`, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layers and tags](img/image00367.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In fact, we will need these two tags later on in the development of this game.
    In fact, when a cupcake tower searches for surrounding objects, it needs to discriminate
    between enemies and projectiles.
  prefs: []
  type: TYPE_NORMAL
- en: Prefabs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the scene begins to fill up with objects, some of these objects might become
    complex. By complex, I mean with a lot of components and children. If we need
    to use many of them in the game and maybe change all of them at once, Unity offers
    the possibility to create a Prefab.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, it is an object already assembled with all the necessary
    components and ready to be placed in the scene. The advantage is the possibility
    to reuse it often and to change all its instances quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If an object in the scene is a Prefab, its name in the **Hierarchy** panel is
    blue. If the name is red, instead, this means that there are some references missing.
  prefs: []
  type: TYPE_NORMAL
- en: To keep our project organized, let's create a folder named `Prefabs`, if we
    haven't done so yet. Inside the folder, right-click and then select `Create/Prefab`.
    You can name it as you want, but for this book, let's stick with `Pink_Sprinkle_Projectile_Prefab`.
  prefs: []
  type: TYPE_NORMAL
- en: We already have the sprinkle in the scene, so from the **Hierarchy** panel,
    drag it into the `Pink_Sprinkle_Projectile_Prefab`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can also erase the previous sprinkle from the scene, as we don't need
    it anymore. For testing purposes, you can try to add as many sprinkles as you
    want in the scene by dragging the Prefab into the **Scene** view. Of course, remember
    to erase them before continuing with the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we select an object that is an instance of a Prefab, three additional
    buttons appear in the **Inspector**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prefabs](img/image00368.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'These are their functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Select**: This is a shortcut to quickly select in the **Project** panel the
    Prefab of the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Revert**: If we did some changes in the instance of the Prefab (the current
    selected object), these do not affect the Prefab. By clicking on this button,
    we revert all the changes to the original Prefab.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apply**: If, on the other hand, you are satisfied with the changes you made
    to this instance of the Prefab, by clicking on this button, you can apply these
    changes to the Prefab. As a result, you may modify all of the other instances
    in the scene. So be careful when you use this function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should already know about the game view, but there might be some new types
    of functionality that you didn't know about before. So, a short recap might be
    useful, before we move on in our journey.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have our three main buttons, which you should be very familiar
    with, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The game view](img/image00369.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The first is the play button, which makes your game run. The second button pauses
    the game, and allows you to tweak some settings. The last one makes your game
    run for one frame only.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the top-left corner, we have the displays and the resolution tabs that we
    covered in the previous chapter. In the opposite corner (top-right), there are
    many different yet useful toggles, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The game view](img/image00370.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'These are their functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maximize on Play**: If this is on, every time you push the play button, the
    game view will be maximized to the largest window it can be. It''s useful for
    testing the game in almost full screen; otherwise, it can be a little bit hard
    to tweak values without having a second monitor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mute Audio**: If this is enabled, as the name suggests, it silences all the
    audio sources in the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stats**: If this is on, it provides some basic feedback about the performance
    of your game, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![The game view](img/image00371.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Gizmos**: These are used to identify objects in the scenes. However, we will
    see these later in [Chapter 6](part0077.xhtml#aid-29DRA1 "Chapter 6. Through a
    Sea of Sprinkles – Navigation in Artificial Intelligence"), *Through a Sea of
    Sprinkles - Navigation in Artificial Intelligence*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Math background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Either you like math or not; however, it is a fact that it is required for game
    development. We don't have time to go through all the math behind this game, since
    it is required to have a complete toolset for game development. However, this
    section introduces you to some basic concepts that we will need for the rest of
    the book. In addition, it also makes some references to the official documentation
    so that you can learn a bit more about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you feel confident with some of the following topics, you are free to skip
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vectors**: They are really important in game development, because they are
    able to describe spaces (both 3D and 2D). They can represent a position or a direction.
    You can read more about them at [https://docs.unity3d.com/Manual/VectorCookbook.html](https://docs.unity3d.com/Manual/VectorCookbook.html)
    and watch this video: [https://unity3d.com/learn/tutorials/topics/scripting/vector-maths](https://unity3d.com/learn/tutorials/topics/scripting/vector-maths).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Probability****:** This is very important when we want a sample to emerge
    from our game, by including uncertainty and chances for the player. A common example
    is in RTS or MMORPG games, where the amount of damage is often between a range
    (determined by the character''s stat), but the actual and real amount of damage
    uses random numbers. Another case is when an attack should be critical so to inflict
    double the damage. At the end of the chapter it is explained how to extract random
    numbers in Unity. However, consider buying a proper math book about probability;
    it might be worthwhile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Radians and Degrees**: Angles can have two unit of measurements. Radians
    are usually used to perform calculations, but Unity has some constants that by
    a multiplication can convert one to the other representation. You can read more
    about these at [https://docs.unity3d.com/ScriptReference/Mathf.Deg2Rad.html](https://docs.unity3d.com/ScriptReference/Mathf.Deg2Rad.html)
    and [https://docs.unity3d.com/ScriptReference/Mathf.Rad2Deg.html](https://docs.unity3d.com/ScriptReference/Mathf.Rad2Deg.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trigonometry**: This is really important, because the sine and the cosine
    functions are often used to achieve believable behavior, since Mother Nature uses
    them for our world. Unluckily, there are no shortcuts. Therefore, if you really
    want to understand them and get into them, you should read any book about trigonometry.
    However, the most important notion used is that they range the value of their
    arguments between `-1` and `+1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quaternions**: This is a math entity that''s not very intuitive, since it
    involves the analysis of complex numbers. However, it''s not important to know
    them in detail (except in really specific cases) when programming in Unity. In
    fact, it''s enough to know that Unity uses them to store rotations. Also, there
    are functions to convert from the Euler representations (the most intuitive of
    three angles). The reason of this choice is behind the scope of this book, but
    it''s due a numerical instability of the Euler representation. You can learn more
    about them by watching the following video: [https://unity3d.com/learn/tutorials/topics/scripting/quaternions](https://unity3d.com/learn/tutorials/topics/scripting/quaternions).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Atan2()**: This is a function that is really important in game development,
    because it is able to calculate the angle of a vector. You can read more about
    this function at [https://docs.unity3d.com/ScriptReference/Mathf.Atan2.html](https://docs.unity3d.com/ScriptReference/Mathf.Atan2.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn one of the toughest topics in game development!
    However, I strongly encourage you not to be scared, but try to practice a lot.
    As a result, you will be able to master every single detail of your game. And
    that is awesome!
  prefs: []
  type: TYPE_NORMAL
- en: Creating new scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, we need to understand how to create new scripts in Unity. The
    easiest way is to select a game object and in the **Inspector**, navigate to **Add
    Component** | **New Script**. In this way, you still have the possibility to rename
    it, but the script will be located in the `Asset` folder. Furthermore, it's not
    possible to create a class that cannot be attached to a game object.
  prefs: []
  type: TYPE_NORMAL
- en: A much better way is to create a folder called `Scripts` in the **Project**
    panel, if you haven't done so yet. Then, right-click and navigate to **Create**
    | **C# Script**. As a result, it will be in the right folder, and we don't have
    problems if we create a script that cannot be attached to game objects.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this book, it will be assumed that every new script will be
    created in this way, and always in the `Scripts` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the name of the script in mind is important, because the file should
    have the same name as the main class in the script. This means that if we change
    the name of the class later on, we need to rename the file accordingly as well.
    However, this may break some references in other scripts that will require correcting.
    So, be careful when changing names.
  prefs: []
  type: TYPE_NORMAL
- en: To open a script, you need to double-click on it. Unity will open a script editor.
    By default, it will be Monodevelop. However, it is possible to change this setting
    by navigating through **Edit | Preferences...**. In the **External Tool** tab,
    you can change the **External Script Editor**. Another commonly used script editor
    is Visual Studio, it can can be downloaded from [https://www.visualstudio.com/](https://www.visualstudio.com/).
  prefs: []
  type: TYPE_NORMAL
- en: However, if this is your first experience with Unity, I suggest that you stick
    with Monodevelop. In any case, for this book, we don't have any requirements (as
    far as you are able to edit the scripts), so feel free to choose the one you like
    best.
  prefs: []
  type: TYPE_NORMAL
- en: Basics about scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If this is your first time scripting in Unity, there is some information to
    know before we begin.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unity mainly supports two languages: C# and JavaScript. Since we created a
    C# script in the previous section, we are going to use this language for the rest
    of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variables can be public, private, or protected. We will not cover the last one,
    since we don't have enough time for that, and it's not really important when getting
    started with Unity development. Private variables can be used only within the
    script itself. Usually they are used to store internal data of the script that
    doesn't need to be shared among other components.
  prefs: []
  type: TYPE_NORMAL
- en: Public variables, instead, can be accessed from any script, so we need to pay
    attention where to use them. It's good practice to implement the `get` and `set`
    functions, when applicable. Even if we will not use them much in this book, it's
    worth learning what they are, which you can do at [https://msdn.microsoft.com/en-us/library/w86s7x04.aspx](https://msdn.microsoft.com/en-us/library/w86s7x04.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, public variables are visible in the **Inspector**. In fact, just
    for testing purposes, you can create a new script and add the following integer
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, after you have saved the script, you are able to set its value
    in the **Inspector**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Variables](img/image00372.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As a consequence, public variables don't need to be set within the script in
    order to be able to use them. Often, we would like to have a public variable,
    since it will be set from another script, but not visible on the **Inspector**.
    You can achieve that in Unity by using an attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before variables and functions, Unity allows us to insert an attribute. An
    attribute is enclosed between `[` and `]`, and can contain different parameters.
    Around 30 attributes exist and they really differ in functionality and usage.
    Since we don''t have the time to go through them all, we will just cover the most
    commonly used ones:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Header` attribute is formatted as `[Header("string")]`. It creates a header
    before the variables that follow it. Here is an example of adding the attribute
    to the variable of the test script we used earlier:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Attributes](img/image00373.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The `HideInInspector` attribute is formatted as `[HideInInspector]`. It hides
    the variable that follows it from the **Inspector**. Here it is in use, in the
    previous example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And this is the result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Attributes](img/image00374.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The `Range` attribute is formatted as `[Range(minValue, maxValue)]`. It captures
    the possible values of the variable in the range of numbers from `minValue` to
    `maxValue`. Again, we use the previous example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is the result we obtain:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Attributes](img/image00375.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Finally, The `Tooltip` attribute is formatted as `[Tooltip("string")]`. It
    creates a tooltip in the **Inspector** when the cursor is hovering over that variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the result (when the cursor hovers):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Attributes](img/image00376.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any script that derives from the `MonoBehaviour` class has two main functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Start()`: This function is called only once, when the game starts. It''s useful
    to set all the variables and get the references we need within this function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Update()`: This function is called every frame, and needs to compute things
    in real time, such as velocity or behaviors. However, since this is called so
    often, we need to pay attention to what we code inside, to avoid slowing down
    our game too often.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other functions that can be implemented and that will be automatically
    called. In actual fact, there are more than 60!
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use some of them later on, so we will introduce them here and see them
    in detail in later chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnTriggerEnter2D()`: This is called when another object with a collider enters
    the trigger collider attached to the game object. We will see this better later
    on, when we deal with physics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnMouseDown()`: This is called when the player has pressed the mouse button
    while over the game object if it has a collider attached. Furthermore, it can
    be a `Coroutine` and works with `GUIElements` too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnEnable()`: This is called when the object becomes enabled and active.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find out more about them at [https://docs.unity3d.com/ScriptReference/MonoBehaviour.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html).
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned in the previous chapter, game development is not an easy process,
    since it involves many stages. For this reason, it's really important to document
    everything that we do. This doesn't mean writing something that will be published,
    but just a couple of lines to remind yourself and your team what you have accomplished.
    In fact, human memory is great at remembering concepts, but not good for details!
    This is essential during the scripting stage. It is important to be able to read
    what the rest of your team or yourself have written a few days ago. When coding,
    it's easy to get lost among the many lines of code when you don't use comments!
  prefs: []
  type: TYPE_NORMAL
- en: Since Unity uses a C# compiler, it is possible to insert comments inside the
    code. Comments are lines that will be ignored (not compiled), and as the name
    suggests, they help to leave messages to those who will read the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main ways to comment in C#. The first is to insert `//` at the
    beginning of a line. As a result, everything that comes after until the next line
    will be ignored. The second one is used when we have more than one line. It consists
    to surround the comment with an opening tag `/*` and the closing tag `*/`. As
    a result, everything within these two tags will be ignored. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comments are also used to build automatic documentations and as markups for
    other things. However, this is out the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: I strongly suggest that you always try to insert comments in your code, so it
    is easier to read later on. For your convenience, all the code that comes with
    this book is provided with comments, helping you to understand what is happening
    and where.
  prefs: []
  type: TYPE_NORMAL
- en: Execution order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another important concept about scripting in Unity is the **Execution Order**.
    It may be fundamental that some scripts or parts of code are executed before others.
    As a result, this will affect how the shared resources are modified and the efficiency
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard ordering is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Editor**: In particular, the `Reset()` function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Scene Load**: Functions such as `Awake()`, `OnEnable()`, and `OnLevelWasLoaded()`
    are called.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Before the first frame update**: All the `Start()` functions in the scripts
    are called (if the object is active!).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**In between frames**: the `OnApplicationPause()` function is performed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Update**: All the different `Update()` functions are called.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Rendering**: Specific rendering functions are performed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Coroutines**: They are executed until a yield statement is found'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**When the object is destroyed**: The `Destroy()` function is called.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**When quitting**: Functions to be executed when disabling game objects or
    when quitting the game are called.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, this is just scratching the surface to give you an idea about the
    execution order. If you are interested in finding out more on this topic, you
    can find a detailed explanation of the execution order in the official documentation,
    at [https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity offers also the possibility to change the execution order within your
    scripts when you have specific needs. This can be done by navigating on the toolbar
    to, **Edit** | **Project Settings** | **Script Execution Order**. As a result,
    this window will appear on the **Inspector**, where it is possible to change the
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Execution order](img/image00377.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For more information about this, you can visit the following link: [https://docs.unity3d.com/Manual/class-ScriptExecution.html](https://docs.unity3d.com/Manual/class-ScriptExecution.html).
    However, the execution order for scripts is for specific needs that we don''t
    have, so we won''t touch any of these settings. However, I hope that this section
    helped you to get a better understanding of the logic behind Unity. Saying that,
    I encourage you to re-read this section when you gain a better understanding of
    scripting in Unity.'
  prefs: []
  type: TYPE_NORMAL
- en: Making sprinkles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Prefabs* section, we created the Prefab for our sprinkle projectile.
    In this section, we will see how to make sprinkles move into the 2D space. In
    particular, we will learn how to create and use scripts in Unity for 2D game elements.
  prefs: []
  type: TYPE_NORMAL
- en: The projectile class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since there might be different projectiles in our game that can be thrown against
    the sweet-tooth pandas, and not only sprinkles, we need to define a general class.
    All the different kinds of projectile will follow some general rules:'
  prefs: []
  type: TYPE_NORMAL
- en: They move in a straight line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They carry information about how much damage they will inflict on the enemies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whereas the first is identical for all the projectiles, the second depends on
    the specific kind of projectile that will be fired. So, we need to create a template.
    Once we attach this script to a game object, we can set some of its variables
    and tweak its behavior. In this specific case, we want to tweak how much damage
    is given and how fast.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the projectile mother class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, to begin, let''s create a new script and name it `ProjectileScript`. Next,
    we need to define four variables. The first is for the amount of damage, the second
    for its speed, and the third one, for its direction, since we need to know where
    the projectile is heading. The last variable stores its life duration expressed
    in seconds. As a consequence, it also sets, together with the speed variable,
    how far the projectile can reach. In fact, if the projectile misses the target,
    we don''t want it going straight on forever, because this would consume computational
    resources and slow down our game. So after this duration, we need to destroy it.
    To do this, we can add the following four variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing to do is to set some of these parameters in the `Start()` function.
    Since the direction will be given by the entity that will throw the projectile,
    we don''t have a guarantee that it has a unit norm. As consequence, we need to
    normalize the direction. Then, we need to rotate the graphic of our projectile,
    which in this case is the sprinkle, towards the right direction. In order to achieve
    this, we need to compute the angle using the `Atan2()` function. After we have
    transformed this in degrees, we use the `AngleAxis()` function in the `Quaternion`
    class to rotate our game object. Finally, we need to set a timer before the game
    object is destroyed. As a result, this will be our `Start()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Update()` function, we just need to move the sprinkle in that direction. If
    the sprinkle collides with something, such as a Panda, it''s a case that we will
    discuss in [Chapter 5](part0056.xhtml#aid-1LCVG1 "Chapter 4. No Longer Alone –
    Sweet-Toothed Pandas Strike"), *No Longer Alone - Sweet-Toothed Pandas Strike*.
    So, we need to update its position according to its direction and speed, keeping
    it dependent on the time. So, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: At the end, save the script. There is still a lot of work to do on this script.
    For instance, the direction should be only on the *x* and *y*, and not on the
    *z*, since it is used in the Z-Buffering method. However, for now it is fine,
    and we will look at all these issues later on in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Tons of sprinkles through Prefabs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a general script that achieves the behavior of a projectile,
    we need to actually make the Prefab of our sprinkles with such behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already created a Prefab for our sprinkle projectile, but we need to
    change it. So, go into the `Prefabs` folder in the **Project** panel, and select
    our `Pink_Sprinkle_Projectile_Prefab`. In the **Inspector**, we need to add the
    script that we have just created. So, navigate to **Add Component** | **Script**
    | **ProjectileScript**. As a result, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tons of sprinkles through Prefabs](img/image00378.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to tweak the values, at least for testing purposes, so that we can
    see our sprinkle moving. We can assign a direction such as (1, 1, 0) and any value
    to the **Damage** variable. At the end, we should have something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tons of sprinkles through Prefabs](img/image00379.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we press the play button, we can see our sprinkle leading in the direction
    we specified, and be destroyed after `10` seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we need to assign the **Z** value on the Prefab. Since it is a projectile,
    we can look at the table with all the **Z **values for our objects we made earlier.
    Therefore, we need to assign `-2` as the value. We also need to assign the tag
    to our projectile. We will use this tag later on, but it's better to assign it
    now to the Prefab.
  prefs: []
  type: TYPE_NORMAL
- en: 'To assign a tag, on top of the **Inspector**, just below the game object name,
    there is the **Tag** field, as highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tons of sprinkles through Prefabs](img/image00380.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once clicked, a drop-down menu appears, where it is possible to choose from
    the different tags, including the two we defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tons of sprinkles through Prefabs](img/image00381.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can assign the **Projectile** tag to our Prefab, and in the end, it should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tons of sprinkles through Prefabs](img/image00382.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: And this is all we need to do to fabricate our projectiles. In fact, we can
    now use this Prefab to spawn the sprinkles when we need to.
  prefs: []
  type: TYPE_NORMAL
- en: Baking cupcakes towers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how to create our towers. This is not an easy task,
    but by doing this we will acquire a lot of scripting skills.
  prefs: []
  type: TYPE_NORMAL
- en: What a cupcake tower does
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, it's useful to write down what we want to achieve and define what
    exactly a cupcake tower is supposed to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way is to write down a list, to have clear idea of what we are trying
    to achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: A cupcake tower is able to detect pandas within a certain range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A cupcake tower shoots a different kind of projectile according to its typology
    against the pandas within a certain range. Furthermore, within this range, it
    uses a policy to decide which panda to shoot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a reload time before the cupcake tower is able to shoot again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cupcake tower can be upgraded (to a bigger cupcake!), increasing its stats
    and therefore changing its appearance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting the cupcake tower
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen in the previous section, there are many things to implement.
    Let's start by creating a new script and naming it `CupcakeTowerScript`. As we
    already mentioned for the projectile script, in this chapter, we implement the
    main logic, but of course there is always space to improve, as we will see later
    in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Shooting to the pandas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if we don't have enemies yet, we can already start to program the behavior
    of the cupcake towers to shoot to the enemies. In this section, we will learn
    a bit about using physics to detect objects within a range. However, we will see
    colliders in more detail in [Chapter 5](part0056.xhtml#aid-1LCVG1 "Chapter 4. No
    Longer Alone – Sweet-Toothed Pandas Strike"), *No Longer Alone - Sweet-Toothed
    Pandas Strike*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining four variables. The first three are public, so we
    can set them in the Inspector. The last one is private, since we only need it
    to check how much time has elapsed. In particular, the first three variables store
    the parameters of our tower. There are the projectile Prefab, its range, and its
    reload time. We can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `Update()` function we need to check if enough time has elapsed
    in order to shoot. This can be easily done by using an if statement. In any case,
    at the end, the time elapsed should be increased:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `if` statement, we need to reset the elapsed time, so as to be able
    to shoot the next time. Then, we need to check whether there are some game objects
    within its range or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If there are enemies within range, we need to decide a policy about which enemy
    the tower should be targeted. There are different ways to do this and different
    strategies that the tower itself could choose. Here, we are going to implement
    one where the nearest enemy to the tower will be the one targeted. Different policies
    and strategies will be discussed in the last chapter of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this policy, we need to loop all all the game objects that we
    have found in range, check if they actually are enemies, and using distances,
    pick the nearest one. To achieve this, write the following code inside the previous
    if statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we find the target, we need to get the direction that the tower will throw
    the projectile. So, let''s write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to instantiate a new projectile, and assign to it the direction
    of the enemy, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Instantiating GameObjects is usually slow, and it should be avoided. However,
    for learning purposes, we can live with that. In the last chapter, we will see
    some optimization technique to get rid of this instantiation. And that is it for
    shooting the enemies.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading the cupcake tower, making it even tastier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to create a function to upgrade the tower, we first need to define
    a variable to store the actual level of the tower:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need an array with all the Sprites for the different upgrades, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A third variable is required to check when the cupcake tower is upgradable,
    so we can add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can create our upgrade function. The first thing to do is to check
    if the tower is actually upgradable and then increase its level. Then, we can
    check (based on how many different graphics we have), if the tower has reached
    its maximum level, and in that case is preventing the player from upgrading it
    anymore, by assigning the false value to the `isUpgradable` variable. After that,
    we need to upgrade the graphics, and increase the stats. Feel free to tweak these
    values as you prefer. However, don''t forget to assign the new Sprite. In the
    end, you should have something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Save the script, and for now, we are done with it. We will need to modify this
    function later in the book, but for now, let's create a Prefab for our cupcake.
  prefs: []
  type: TYPE_NORMAL
- en: A pre-baked cupcake tower through Prefabs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have done with the sprinkles, we need to do something similar for the
    cupcake tower. In the `Prefabs` folder in the **Project** panel, create a new
    Prefab by right-clicking and then navigating to **Create** | **Prefab**. Name
    it `SprinklesCupcakeTower`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, drag and drop `Sprinkles_Cupcake_Tower_0` from the `Graphics/towers` folder
    (within the `cupcake_tower_sheet-01` file) in the **Scene** View. Attach `CupcakeTowerScript`
    to the object by navigating to **Add Component** | **Script** | `CupcakeTowerScript`.
    The **Inspector** should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A pre-baked cupcake tower through Prefabs](img/image00383.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to assign `Pink_Sprinkle_Projectile_Prefab` to the **Projectile Prefab**
    variable. Then, we need to assign the different Sprites for the upgrades. In particular,
    we can use `Sprinkles_Cupcake_Tower_*` (replacing the `*` with the level of the
    cupcake tower) from the same sheet as earlier. Don''t worry too much about the
    other parameters of the tower, such as the range radius or the reload time, since
    we will see how to balance the game later on. At the end, this is what we should
    see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A pre-baked cupcake tower through Prefabs](img/image00384.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The last step is to drag this game object inside the Prefab. As a result, our
    cupcake tower is ready.
  prefs: []
  type: TYPE_NORMAL
- en: More about coding in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we continue, there are few more things to learn.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the book, we will use both static variables and inheritance. These
    are topics related with C# more than with Unity, but they are important if you
    want to become a good game developer. Next, you can find a very brief explanation,
    but I recommend that you learn them properly from a C# book.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is probability, which is a topic of math, as we discussed previously,
    and it is essential in game development. However, once you know the basics of
    probability, you should be able to generate random numbers in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Static variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some classes (or components, in the case of Unity), contain variables, which
    eventually can be set in the Inspector or changed at runtime. However, the whole
    class can share a variable among all its instances. Such variables are referred
    to as static variables and are declared with the `static` keyword. A common use
    is to share a reference to another component, which all the instances of the class
    should refer to. We will see this better later in the book, when we will use static
    variables
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If different classes share many features in common, we could give them an inheritance
    structure. This means, to have a parent class that holds the general and common
    features between these classes, and then they are implemented as children of the
    parent. A common example to clarify this is imagining the classes Fruit, Apple,
    and Banana. Fruit is the parent class, which holds all the properties of being
    a fruit (such as that it is edible), and the children share the same feature of
    the parent (since both an Apple and a Banana are fruits, and therefore edible).
    Then, they can implement the specific features of that fruit. For instance, the
    Apple is red, whereas the Banana is yellow.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the parent class can also have functions (such as `Eat()`) which
    all the children can give their own implementation. This leads to the difference
    between the abstract and virtual methods.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract methods are so abstract that the parent class cannot give an implementation
    of it, but its children have to. Virtual methods, instead, can be implemented
    in the parent class, since it offers general functionality, but children can override
    it to give a better implementation of it.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at inheritance in more detail, in [Chapter 7](part0088.xhtml#aid-2JTHG1
    "Chapter 7. Trading Cupcakes and the Ultimate Battle for the Cake – Gameplay Programming"), *Trading
    Cupcakes and the Ultimate Battle for the Cake - Gameplay Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Random numbers in Unity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generating random numbers in Unity is easy since Unity provides the class `Random`,
    which allows us to generate random numbers. The most used function of this class
    is `Range()`, which generates a random number between a min and a max value. Here
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For more information about the `Random` class, visit the official documentation
    here: [https://docs.unity3d.com/ScriptReference/Random.html](https://docs.unity3d.com/ScriptReference/Random.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Homework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to use Prefabs to quickly replicate and clone
    GameObjects. So, before you continue with the next chapter, let's get good at
    using Prefabs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two exercises are needed to have the game completed at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arming the Cupcakes Towers (Part I)**:Inside `projectiles_sheet_01` in the
    `Graphics/projectiles` folder, there are nine different projectiles; however,
    we used only one, `Pink_Sprinkle`. Create the other eight Prefabs, with meaningful
    names. Don''t forget to attach the projectile script to all of them. Do not worry
    too much about the values assigned inside the script, such as the damage, since
    we will see the balance of the game later on in the book. However, do not forget
    to assign the right **Z** value and the proper tag.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Arming the Cupcakes Towers (Part II)**: Inside `cupcake_tower_sheet-01` in
    the `Graphics/towers` folder, there are three different towers with their respective
    upgrading levels; however, we only used the sprinkle cupcake tower. Create the
    other two Prefabs for the chocolate and lemon cupcake towers. Don''t forget to
    attach the cupcake tower script to both of them and assign the respective projectiles
    and upgrade levels graphic. Again, don''t worry much about the values, such as
    the range radius, because we will see the balance of the game later in the book.
    However, don''t forget to assign the right **Z** value.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following exercises will help you to improve your skills by familiarizing
    yourself with best practices:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Formatting scripts for designers (Part I)**: In our scripts, we used many
    variables. Comments next to them help us to understand their function; however,
    these comments are hidden to designers. Therefore, it''s good practice to add
    tooltips to show up in the **Inspector**. If you want, you can use the text of
    the comments as parameter for the tooltips.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Formatting scripts for designers (Part II)**: Even if our scripts in the
    **Inspector** look good, they can be improved if we add some headings before groups
    of variables. So, assign meaningful headings and reorder the variables to fit
    in these headings.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Formatting scripts for designers (Part III)**: The `direction` variable inside
    the projectile script must be set to public since it is changed from the cupcake
    tower script. However, it should be visible in the **Inspector**. Use attributes
    to hide it from the **Inspector**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Formatting scripts for designers (Part IV)**: Some variables in our scripts
    are better to show with a slider rather than a numeric input field, especially
    those that cannot assume negative numbers. For these, transform their appearance
    to a slider and don''t allow negative values for them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Best Practices (Part I)**: Inside the cupcake tower script there is the `Upgrade
    Level` variable, which is private. However, it might be useful to create a get
    function to retrieve its value. By following the guidelines in the link shown
    in the *Variables* section of this chapter, implement the respective get function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Best Practices (Part II)**: Again inside the cupcake tower script, inside
    the `Upgrade()` function, the `GetComponent()` function is called to get the `SpriteRenderer`.
    Best practice suggests to call this function only once and store the reference
    inside a variable. Create a new variable to store the `SpriteRenderer` component
    attached to the cupcake tower game object. Assign its value inside the `Start()`
    function by using the `GetComponent()` function. Then, use this variable in the
    `Upgrade()` function to update the graphic of the cupcake tower.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Best Practices (Part III)**: We didn''t define a tag for the cupcake towers
    because we don''t need to distinguish between them. However, it''s good practice
    to assign a tag to them. This is because it might be needed later on when we would
    like to extend our game (for example, enemies that try to avoid cupcake towers
    within their limits). Therefore, create a new cupcake tower tag and assign it
    to all the cupcake tower Prefabs (there should be three, also counting the one
    created in the first exercise of this section).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to use Prefabs to quickly replicate and clone
    game objects. We also learned how to place 2D objects, order them with the Z-Buffering
    method, as well as how to set up tags and layers in Unity. Then, we created a
    couple of scripts, and learned along the way how to code complex behaviors with
    just a few lines. In fact, we explored how Unity handles scripts, their main functions
    and attributes, and the general execution order.
  prefs: []
  type: TYPE_NORMAL
- en: However, we will improve the scripts written in this chapter later on in the
    book, to improve the gameplay. In fact, the goal of this chapter was to get used
    to scripts, and to write down the main logic. Therefore, improving and tweaking
    is left for later.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into the UI world, and integrate it into our
    game.
  prefs: []
  type: TYPE_NORMAL
