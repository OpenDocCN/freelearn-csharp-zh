<html><head></head><body>
<div><div><div></div>
</div>
<div><h1 id="_idParaDest-278"><a id="_idTextAnchor314"/>8. Creating and Using Web API Clients</h1>
</div>
<div><p class="callout-heading">Overview</p>
<p class="callout">In this chapter, you will step into the world of HTTP practice by making calls to Web APIs. You will interact with Web APIs in a variety of ways using a web browser, your own HTTP client, and NuGet packages. You will learn the basics of security involved in Web APIs, use PayPal to make sandbox payments, and explore cloud services such as Azure Text Analytics and Azure Blob storage.</p>
<p class="callout">By the end of this chapter, you will be able to read HTTP requests and response messages, make calls to any Web API, and create your own HTTP client to simplify your work with complex APIs. You will also be able to dissect and learn both incoming HTTP requests and outgoing HTTP responses in any form and use development tools in the Chrome browser to inspect traffic moving back and forth when browsing your favorite websites.</p>
<h1 id="_idParaDest-279"><a id="_idTextAnchor315"/>Introduction</h1>
<p>The World Wide Web (WWW) (or just the web) is a big store of all sorts of documents (XML, JSON, HTML, MP3, JPG, etc.) accessible through Uniform Resource Locators (URLs). A document in the context of the web is often called a resource. Some resources do not change. They are stored somewhere, and with every request, the same resource will be returned. Such resources are called static. Other resources are dynamic, which means they will be generated on demand.</p>
<p>Communication on the web happens through protocols. In the context of retrieving documents, you use Hypertext Transfer Protocol (HTTP). Hypertext is a special text that holds a link to a resource on the web. Clicking on it opens the resource it points to. HTTP is based on a client-server architecture. In simple terms, a client sends requests, and the server responds. An example of this in practice is the communication between a browser (client) and a website (hosted on a server). Usually, a single server serves many clients:</p>
<div><div><img alt="Figure 8.1: Client-server architecture " height="867" src="img/B16835_08_01.jpg" width="1218"/>
</div>
</div>
<p class="figure-caption">Figure 8.1: Client-server architecture</p>
<p>When you navigate to a website, you send an <code>HTTP GET</code> request, and the server responds by displaying the relevant site content in the browser. <code>GET</code> is an HTTP verb—a method identifying how a request should be treated. Common HTTP verbs are the following:</p>
<ul>
<li><code>GET</code>: Get a resource.</li>
<li><code>POST</code>: Create a resource or send a complex query.</li>
<li><code>PUT</code>: Update all resource fields.</li>
<li><code>PATCH</code>: Update a single field.</li>
<li><code>DELETE</code>: Remove a resource.</li>
</ul>
<h1 id="_idParaDest-280"><a id="_idTextAnchor316"/>Browser</h1>
<p>A modern browser is more than just a tool to access content on the internet. It includes tools to dissect elements of a website, inspect traffic, and even execute code. This side of a browser is called developer tools. The exact key binds may vary but pressing <code>F12</code> or <code>Control + Shift + I</code> should call up the Developer Tools tab. Perform the following steps to get to know it better:</p>
<ol>
<li>Open Google Chrome or any other browser.</li>
<li>Navigate to <a href="http://google.com">google.com</a>. Press the keys <code>Control + Shift + I</code>.</li>
<li>Go to <code>Network</code> (<code>1</code>). The following window should be displayed:</li>
</ol>
<div><div><img alt="Figure 8.2: Chrome with developer tools open with google.com loaded " height="571" src="img/B16835_08_02.jpg" width="905"/>
</div>
</div>
<p class="figure-caption">Figure 8.2: Chrome with developer tools open with google.com loaded</p>
<ol>
<li value="4">Select the first entry, <a href="http://www.google.com">www.google.com</a> (<code>2</code>).</li>
<li>Click <code>Headers</code> (<code>3</code>).</li>
<li>In the <code>General</code> (<code>4</code>) section, you can observe the effects when you navigated to <a href="http://google.com">google.com</a>. The first thing that happened was <code>HTTP GET</code> request was sent to <a href="https://www.google.com/">https://www.google.com/</a>.</li>
<li>In the <code>Request Headers</code> section (<code>5</code>), you can see the metadata sent with the request.</li>
<li>To see how Google responded, click the <code>Response</code> section (<code>6</code>).</li>
</ol>
<p>This flow is called the client-server architecture, and the following applies:</p>
<ul>
<li>The client is the Chrome browser that sends a request to <a href="http://google.com">google.com</a>.</li>
<li>The server is a machine(s) hosting <a href="http://google.com">google.com</a> that responds with <a href="http://google.com">google.com</a> website contents.</li>
</ul>
<h1 id="_idParaDest-281"><a id="_idTextAnchor317"/>Web API</h1>
<p>An Application Programming Interface (API) is an interface through which you can call some functionality using code. It could be a class or an interface in C#, or a browser (you can interact with it through code provided by its own interface), but in the context of HTTP, it is a web service. A web service is an API hosted on a remote machine that is accessible through HTTP. An access point used to invoke a single piece of functionality on a Web API is called an endpoint. The most commonly used Web API type is RESTful.</p>
<h2 id="_idParaDest-282"><a id="_idTextAnchor318"/>RESTful API</h2>
<p>A Representational State Transfer (REST) API is an API built on the following six principles. Four principles are a given whatever framework you use implementing a RESTful API, and, as a client, they should be expected:</p>
<ul>
<li>Client-server: A connection is made between a client and server. The client sends a request in order to get a response from a server.</li>
<li>Stateless: The server will be able to process requests regardless of prior requests. This means that each request should contain all the information, rather than relying on a server to remember what happened before.</li>
<li>Cacheable: The ability to specify which requests can be cached using HTTP methods or headers.</li>
<li>Code on demand (optional): REST allows scripts to be downloaded and executed on the client side. Back when the internet was made mostly of static pages, this was useful, but nowadays it is either not needed or is seen as a security risk.</li>
</ul>
<p>However, the other two principles (Client-server and Stateless) depend on you, and thus you will want to pay more attention to them. A layered system is a system made of layers, and each layer communicates only with the layer directly below it. A typical example of this is a three-tier architecture, where you separate presentation, business logic, and the data store. From a practical point of view, this means that a RESTful API (business logic layer) should not send HTML as a response because the responsibility for rendering output lies with the client (the presentation layer).</p>
<p>The last principle is called a uniform interface. It defines a set of rules for an API:</p>
<ul>
<li>Identification of resources:</li>
</ul>
<p>Some examples of these are get all instances of a resource (<code>/resource</code>), create a resource (<code>/resource</code>), get a single resource (<code>/resource/id</code>), and get all instances of a subresource in a resource (<code>/resource/subresource/</code>).</p>
<ul>
<li>Manipulation of resources through these representations:</li>
</ul>
<p>Resources are manipulated using HTTP verbs representing Create, Read, Update, and Delete (CRUD)—<code>GET</code>, <code>UPDATE</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>.</p>
<ul>
<li>Self-descriptive messages:</li>
</ul>
<p>A response that includes all the required information, without any extra documentation, and indicates how the message should be processed (headers, mime type, etc.).</p>
<ul>
<li>Hypermedia as the engine of application state (HATEOAS):</li>
</ul>
<p>Hyperlinks are included in response to all the related resources so that you can navigate to them. This guideline is usually ignored.</p>
<p>REST is not the same as HTTP. REST is a set of guidelines, while HTTP is a protocol. The two might be confused because HTTP constraints heavily overlap with REST constraints (methods, headers, etc.). However, a RESTful API does not have to use HTTP to be RESTful, and at the same time HTTP can violate REST constraints by using a session or query parameters to provide actions to perform. A RESTful API can work with both XML and JSON data formats. However, almost all scenarios involve JSON.</p>
<h2 id="_idParaDest-283"><a id="_idTextAnchor319"/>Postman</h2>
<p>Postman is one of the most popular tools used for testing different kinds of Web APIs. It is easy to set up and use. Postman, just like a browser, acts as an HTTP client. In order to download Postman, go to <a href="https://www.postman.com/">https://www.postman.com/</a>. You will need to sign up and then download the installer. Once you have installed Postman, perform the following steps:</p>
<ol>
<li value="1">Open Postman.</li>
<li>Create your workspace by clicking <code>Workspaces</code> and then click on <code>Create Workspace</code>.</li>
<li>In the new window, go to the <code>Collections</code> tab (<code>2</code>) and click the <code>Create new Collection</code> (<code>+</code>) button (<code>3</code>).</li>
<li>Create a <code>New Collection</code> (<code>4</code>).</li>
<li>Click on <code>Add a request</code> (<code>5</code>):</li>
</ol>
<div><div><img alt="Figure 8.3: New Postman collection without requests " height="533" src="img/B16835_08_03.jpg" width="907"/>
</div>
</div>
<p class="figure-caption">Figure 8.3: New Postman collection without requests</p>
<p>A new request window will open.</p>
<ol>
<li value="6">Click the edit symbol beside <code>New Request</code> and name the new request <code>Users</code> (<code>6</code>).</li>
<li>Select the <code>GET</code> HTTP verb and copy-paste the URL <a href="https://api.github.com/users/github-user">https://api.github.com/users/github-user</a> (<code>7</code>).<p class="callout-heading">Note</p><p class="callout">Here, and in all places that follow, replace <code>github-user</code> with your own GitHub username.</p></li>
<li>Click the <code>Send</code> button (<code>8</code>).</li>
<li>Now scroll down to see the response result returned (<code>9</code>):</li>
</ol>
<div><div><img alt="Figure 8.4: GET GitHub user request in Postman " height="484" src="img/B16835_08_04.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 8.4: GET GitHub user request in Postman</p>
<p>Postman is superior to a browser when it comes to acting as an HTTP client. It is focused on forming HTTP requests and displays response information compactly, offering multiple output formats. In Postman, you can use multiple environments, set up pre-and post-conditions for requests, automated calls, and a lot more, but going through those advanced features is beyond the scope of this chapter. For now, it is enough to learn that Postman is a go-to tool for testing Web APIs by hand.</p>
<h2 id="_idParaDest-284"><a id="_idTextAnchor320"/>Client</h2>
<p>REST requires communication between a client and a server. In the previous examples, the client role was taken by either a browser or Postman. However, neither a browser nor Postman can replace a client in your code. Instead, you'll need to create an HTTP request using C#.</p>
<p>Popular Web APIs often have a client created for you (in most common languages as well). The purpose of a Web API client is to simplify interactions with the underlying API. For example, instead of sending a <code>DELETE</code> request on an endpoint that does not support it and getting the response <code>Method Not Allowed</code>, you won't even have such an option on a custom client.</p>
<h2 id="_idParaDest-285"><a id="_idTextAnchor321"/>Octokit</h2>
<p>Octokit is a GitHub API client. It exposes a C# class through which you can pass objects to make calls to GitHub. The benefit of such a client is that you don't need to worry about which headers to pass or how to name things so that they are properly serialized. An API client handles all that for you.</p>
<p>You can install the Octokit client in your project by running the following command in the VS Code terminal or command prompt:</p>
<pre>dotnet add package Octokit</pre>
<p>Once you have the Octokit client installed, you can use it to create a GitHub client, as follows:</p>
<pre>var github = new GitHubClient(new ProductHeaderValue("Packt"));</pre>
<p>In the preceding snippet, you needed a new <code>ProductHeaderValue</code> because GitHub expects a <code>UserAgent</code> header. As mentioned earlier, custom HTTP clients prevent a mistake from happening before you can even make a request. In this case, not providing a <code>UserAgent</code> header (through <code>ProductHeaderValue</code>) is not an option.</p>
<p>To see whether the client works, try to get information on the username <code>github-user</code>:</p>
<pre>const string username = "github-user";
var user = await github.User.Get(username);</pre>
<p class="callout-heading">Note</p>
<p class="callout">In GitHub, <code>github-user</code> is displayed as <code>Almantask</code>. It is better to change it to your individual GitHub username for the code to work.</p>
<p>To print the date when the user was created, type the following code:</p>
<pre>Console.WriteLine($"{username} created profile at {user.CreatedAt}");</pre>
<p>You will see the following output:</p>
<pre>github-user created profile at 2018-06-22 07:51:56 +00:00</pre>
<p>Every method available on the GitHub API is also available on <strong class="bold">GitHub client Octokit</strong>. You don't need to worry about the endpoint, mandatory headers, a response, or the request format; it is all defined by the strongly typed client.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/DK2n2">https://packt.link/DK2n2</a>.</p>
<h2 id="_idParaDest-286"><a id="_idTextAnchor322"/>API Key</h2>
<p>With many public free APIs, you may be faced with concerns such as the following:</p>
<ul>
<li>How can you control an overwhelming number of requests?</li>
<li>At what point should which client be charged?</li>
</ul>
<p>If all these public APIs offered only anonymous access, you would not be able to identify the clients or determine how many calls each of them has made. An API key serves as the most basic means of authentication (identifying the client) and authorization (granting them access to do something with an API). Simply put, an API key allows you to call an API. Without it, you would have little to no access to an API.</p>
<p>To help you grasp the use of API keys better, the next section will look at a Web API that requires one, that is, Azure Text Analytics.</p>
<h2 id="_idParaDest-287"><a id="_idTextAnchor323"/>Azure Text Analytics</h2>
<p>Azure Text Analytics is an Azure API used to analyze text in the following ways:</p>
<ul>
<li>Identify named entities (people, events, organizations)</li>
<li>Interpret the mood of the text (positive, negative, neutral)</li>
<li>Produce a summary of a document or highlight key phrases</li>
<li>Process unstructured medical data, such as recognizing people, classifying diagnoses, and so on</li>
</ul>
<p>In order to demonstrate the Azure Text Analytics API, you will focus on sentimental analysis. This is the process of evaluating text according to a positive, negative, or neutral confidence score:</p>
<ul>
<li>The score of 1, which means 100%, is the probability that the prediction (negative, positive, neutral) is correct.</li>
<li>The score of 0, which means 0%, is an impossible prediction.<p class="callout-heading">Note</p><p class="callout">Using Azure Text Analytics is free until you analyze more than 5,000 words per 30 days.</p></li>
</ul>
<p>Before you begin coding, you'll need to set up Azure Text Analytics on the Azure cloud. After all, you need both an endpoint and an API key to make a call to this API.</p>
<p class="callout-heading">Note</p>
<p class="callout">Make sure you have set up an Azure subscription. If you don't have one, go to <a href="https://azure.microsoft.com/en-gb/free/search">https://azure.microsoft.com/en-gb/free/search</a> and follow the instructions there to create a <strong class="bold">free</strong> subscription. An Azure free trial offers many services for free. Some of those services will remain free even after a year. A student subscription is an option for getting Azure credits and free services for a longer period. A credit or debit card is required to create an Azure subscription; however, you won't be charged unless you exceed the given Azure credits of the free service limitations.</p>
<p>One way in which Azure Text Analytics could be used to sort positive and negative feedback is by determining whether what you wrote sounds passive-aggressive or friendly. To see this in action, follow the steps to create a small application that analyzes any text you input into a console:</p>
<ol>
<li value="1">First, go to <a href="https://portal.azure.com/#create/Microsoft.CognitiveServicesTextAnalytics">https://portal.azure.com/#create/Microsoft.CognitiveServicesTextAnalytics</a>.</li>
<li>Click <code>Continue to create your resource</code> without using any additional features:</li>
</ol>
<div><div><img alt="Figure 8.5: Azure Text Analytics resource creation " height="697" src="img/B16835_08_05.jpg" width="874"/>
</div>
</div>
<p class="figure-caption">Figure 8.5: Azure Text Analytics resource creation</p>
<ol>
<li value="3">In the Create text analytics window, click the <code>Basics</code> tab. This is the first tab opened at the start of the creation of a new resource.</li>
<li>Select an option in the <code>Subscription</code> and <code>Resource group</code> fields:</li>
</ol>
<div><div><img alt="Figure 8.6: Entering the project details for new resource creation " height="175" src="img/B16835_08_06.jpg" width="1106"/>
</div>
</div>
<p class="figure-caption">Figure 8.6: Entering the project details for new resource creation</p>
<ol>
<li value="5">Then, select the region, for example, <code>North Europe</code>.</li>
<li>Enter the name, for example, <code>Packt-Test</code>.</li>
<li>After that, select the <code>Free F0</code> pricing tier and click the <code>Review + create</code> button:</li>
</ol>
<div><div><img alt="Figure 8.7: Azure Text Analytics pricing tier " height="431" src="img/B16835_08_07.jpg" width="1112"/>
</div>
</div>
<p class="figure-caption">Figure 8.7: Azure Text Analytics pricing tier</p>
<p>A new window gets displayed confirming your input.</p>
<ol>
<li value="8">Click the <code>Create</code> option. The Text Analytics API will start deploying. After the deployment of the service is done, a new window will open saying <code>Your deployment is complete</code>.</li>
<li>Click on the <code>Go to resource</code> button:</li>
</ol>
<div><div><img alt="Figure 8.8: The Text Analytics API showing the deployment as complete " height="344" src="img/B16835_08_08.jpg" width="1189"/>
</div>
</div>
<p class="figure-caption">Figure 8.8: The Text Analytics API showing the deployment as complete</p>
<p>The Text Analytics resource window gets displayed.</p>
<ol>
<li value="10">Click the <code>Keys and Endpoint</code> option. You will see the <code>Endpoint</code> option along with <code>KEY 1</code> and <code>KEY 2</code> to make calls to this API. You can choose from either of the keys:</li>
</ol>
<div><div><img alt="Figure 8.9: Azure Text Analytics quick start window with API key hyperlink " height="688" src="img/B16835_08_09.jpg" width="1530"/>
</div>
</div>
<p class="figure-caption">Figure 8.9: Azure Text Analytics quick start window with API key hyperlink</p>
<ol>
<li value="11">Keep track of <code>KEY 1</code> (an API key). An API key is a secret and should not be exposed in plain text. You will once again be using the environment variables to store it.</li>
</ol>
<p>Create an environment variable with key and value pair. The value will be the endpoint API key required to connect to Azure Text Analytics. To help identify the missing environment variable, use a helper class. The <code>GetOrThrow</code> method will get a user environment variable, and if it doesn't exist, will throw an exception:</p>
<pre>    public static class EnvironmentVariable
    {
        public static string GetOrThrow(string environmentVariable)
        {
            var variable = Environment.GetEnvironmentVariable(environmentVariable, EnvironmentVariableTarget.User);
            if (string.IsNullOrWhiteSpace(variable))
            {
                throw new ArgumentException($"Environment variable {environmentVariable} not found.");
            }
            return variable;
        }
    }</pre>
<ol>
<li value="12">Keep track of the <code>Endpoint</code> option. You will use it in the upcoming exercise to call the API you have just deployed.</li>
</ol>
<p>This section helped you to set up Azure Text Analytics on the Azure cloud, in addition to setting both an endpoint and an API key to make a call to the API. In the following exercise, you will be using the Azure Text Analytics client to make calls to the API.</p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor324"/>Exercise 8.01: Performing Sentimental Text Analysis on Any Text</h2>
<p>Azure Text Analytics is just another REST API. Once again, you make HTTP calls to it and get a response. This time, you will send over a text to get its sentimental analysis. Do another practice run of using a strongly typed client and make calls to a RESTful API from C#.</p>
<p>Using a recently deployed Azure Text Analytics service (<code>Pack-Test</code>, in this case), perform sentimental analysis on any text you want. Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">Install the <code>Azure.AI.TextAnalytics</code> NuGet package to get an Azure Text Analytics API client as follows:<pre>dotnet add package Azure.AI.TextAnalytics</pre></li>
<li>Add the <code>TextAnalysisApiKey</code> environmental variable.</li>
<li>Then add the <code>TextAnalysisEndpoint</code> environmental variable.</li>
<li>Create a <code>Demo</code> class and add references to the two environmental variables that you have recently added:<pre>public class Demo
{
    private static string TextAnalysisApiKey { get; } = EnvironmentVariable.GetOrThrow("TextAnalysisApiKey");
    private static string TextAnalysisEndpoint { get; } = EnvironmentVariable.GetOrThrow("TextAnalysisEndpoint");</pre></li>
</ol>
<p>These properties are used to hide sensitive values of the API key and endpoint.</p>
<ol>
<li value="5">Create a new <code>BuildClient</code> method to build an API client:<pre>static TextAnalyticsClient BuildClient()
{
    var credentials = new AzureKeyCredential(TextAnalysisApiKey);
    var endpoint = new Uri(TextAnalysisEndpoint);
    var client = new TextAnalyticsClient(endpoint, credentials);
    return client;
}</pre></li>
</ol>
<p>The API client requires both a base URL—a kind of Unified Resource Identifier (URI)—and an API key to operate, both of which are passed to it during initialization.</p>
<ol>
<li value="6">Using the client, create the <code>PerformSentimentalAnalysis</code> method to analyze the text:<pre>private static async Task&lt;DocumentSentiment&gt; PerformSentimentalAnalysis(TextAnalyticsClient client, string text)
{
    var options = new AnalyzeSentimentOptions { IncludeOpinionMining = true };
    DocumentSentiment documentSentiment = await client.AnalyzeSentimentAsync(text, options: options);
    return documentSentiment;
}</pre></li>
</ol>
<p>Here, you are using the configuration object <code>AnalyzeSentimentOptions</code> to extract targets and opinions on them. The client has both the <code>AnalyzeSentimentAsync</code> and <code>AnalyzeSentiment</code> methods. For public client libraries, exposing both async and non-async versions of the same method is a very common scenario. After all, not everyone will be comfortable with an async API. However, when making calls to another machine (DB, API, and similar) it's best to use an async API. This is because an async call will not block the thread on which the call is made while it is waiting for a response from an API.</p>
<ol>
<li value="7">Now create a <code>DisplaySentenceSymmary</code> function to display the sentence's overall evaluation:<pre>private static void DisplaySentenceSummary(SentenceSentiment sentence)
{
    Console.WriteLine($"Text: \"{sentence.Text}\"");
    Console.WriteLine($"Sentence sentiment: {sentence.Sentiment}");
    Console.WriteLine($"Positive score: {sentence.ConfidenceScores.Positive:0.00}");
    Console.WriteLine($"Negative score: {sentence.ConfidenceScores.Negative:0.00}");
    Console.WriteLine($"Neutral score: {sentence.ConfidenceScores.Neutral:0.00}{Environment.NewLine}");
}</pre></li>
<li>Create a <code>DisplaySentenceOpinions</code> function to display the message <code>Opinions</code> for every target in a sentence:<pre>private static void DisplaySentenceOpinions(SentenceSentiment sentence)
{
    if (sentence.Opinions.Any())
    {
        Console.WriteLine("Opinions: ");
        foreach (var sentenceOpinion in sentence.Opinions)
        {
            Console.Write($"{sentenceOpinion.Target.Text}");
            var assessments = sentenceOpinion
                .Assessments
                .Select(a =&gt; a.Text);
            Console.WriteLine($" is {string.Join(',', assessments)}");
            Console.WriteLine();
        }
    }
}</pre></li>
</ol>
<p>The target of a sentence is a subject that has an opinion (grammatical modifier) applied to it. For example, with the sentence, <strong class="bold">a beautiful day</strong>, <strong class="bold">day</strong> would be a target and <strong class="bold">beautiful</strong> an opinion.</p>
<ol>
<li value="9">To perform a sentimental analysis on text typed in a console, create a <code>SentimentAnalysisExample</code> method:<pre>static async Task SentimentAnalysisExample(TextAnalyticsClient client, string text)
{
    DocumentSentiment documentSentiment = await PerformSentimentalAnalysis(client, text);
    Console.WriteLine($"Document sentiment: {documentSentiment.Sentiment}\n");
    foreach (var sentence in documentSentiment.Sentences)
    {
        DisplaySentenceSummary(sentence);
        DisplaySentenceOpinions(sentence);
    }
}</pre></li>
</ol>
<p>The analysis text, in the preceding code snippet, evaluates the overall text's sentiment and then breaks it down into sentences, evaluating each.</p>
<ol>
<li value="10">To demonstrate how your code works, create a static <code>Demo.Run</code> method:<pre>public static Task Run()
{
    var client = BuildClient();
    string text = "Today is a great day. " +
                       "I had a wonderful dinner with my family!";
    return SentimentAnalysisExample(client, text);
}</pre></li>
</ol>
<p>With the environment variable set correctly, the following output should be displayed:</p>
<pre>Document sentiment: Positive
Text: "Today is a great day."
Sentence sentiment: Positive
Positive score: 1,00
Negative score: 0,00
Neutral score: 0,00
Text: "I had a wonderful dinner with my family!"
Sentence sentiment: Positive
Positive score: 1,00
Negative score: 0,00
Neutral score: 0,00
Opinions:
dinner is wonderful</pre>
<p>You did not hardcode the value of an API key here because an API key, exposed publicly, poses a risk of being used not the way it was intended to. If stolen, it could have disastrous consequences (for example, being overused, creating a false resource, leaking data, deleting data, etc.). That is why when dealing with secrets, use the minimal possible countermeasures, that is, environmental variables.</p>
<p>Another benefit of environment variables is the ability to have a different value in different environments (local, integration, system test, production, etc.). Different environments often use different resources. So, pointing to those resources through environment variables will not require any changes to the code.</p>
<p>In order to run this exercise, go to <a href="https://packt.link/GR27A">https://packt.link/GR27A</a> and comment all lines within the <code>static void</code> <code>Main(string[] args)</code> body, except <code>await Exercises.Exercise01.Demo.Run();</code>. Similarly, uncomment the respective exercises'/examples'/activities' code lines in <code>Program.cs</code> before executing each of them.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/y1Bqy">https://packt.link/y1Bqy</a>.</p>
<p>This exercise is just one of the many in which you consumed a public Web API. Azure is full of services like this. Calling an API using a strongly typed client is simple; however, not all APIs have one. In the next section, you will learn how to create your own Web API client.</p>
<h1 id="_idParaDest-289"><a id="_idTextAnchor325"/>Your Own Client</h1>
<p>So far, you've only used a premade client to consume a Web API. However, for less popular APIs, there will not be any client for you to use. In those cases, you will have to make HTTP calls yourself. In .NET, the way of making calls has evolved quite a lot. If you don't want any third-party libraries, you can use the <code>HttpClient</code> class.</p>
<h2 id="_idParaDest-290"><a id="_idTextAnchor326"/>HttpClient</h2>
<p>In this section, you'll repeat the GitHub <code>Users</code> example (from the <em class="italic">Postman</em> section), but this time using <code>HttpClient</code>. The flow for this is quite simple and is described for you in detail in the following example:</p>
<ol>
<li value="1">Within the <code>GitHttp</code> static class, create the <code>GetUser</code> method:<pre>public static async Task GetUser()</pre></li>
<li>Within the <code>GitExamples</code> method, first, create a client:<pre>client = new HttpClient { BaseAddress = new Uri("https://api.github.com") };
client.DefaultRequestHeaders.Add("User-Agent", "Packt");</pre></li>
</ol>
<p>Creating a client almost always involves specifying a specific base URL. Often, Web APIs require mandatory headers to be passed, or else they will invalidate the request (<code>400 Bad Request</code>). For GitHub, you need to send the <code>User-Agent</code> header identifying the client that calls the API. Adding the <code>Packt</code> user agent header to default headers will send that header with every request to the client.</p>
<ol>
<li value="3">You then create a request as follows:<pre>const string username = "github-user"; //replace with your own
var request = new HttpRequestMessage(HttpMethod.Get, new Uri($"users/{username}", UriKind.Relative));</pre></li>
</ol>
<p>Remember to replace <code>github-user</code> with your own GitHub username. Here, you've specified that you want to create a <code>GET</code> request. You did not specify a full path, but rather only the endpoint you want to hit; therefore, you had to flag <code>UriKind</code> as <code>Relative</code>.</p>
<ol>
<li value="4">Next, send a request using the client:<pre>var response = await client.SendAsync(request);</pre></li>
</ol>
<p>There is only an async version of sending an HTTP request message, so you need to wait for it. The result of sending <code>HttpRequestMessage</code> is <code>HttpResponseMessage</code>.</p>
<ol>
<li value="5">Then, deserialize the content to a usable object as follows:<pre>var content = await response.Content.ReadAsStringAsync();
var user = JsonConvert.DeserializeObject&lt;User&gt;(content);</pre></li>
</ol>
<p>Deserializing is the act of converting a structured text such as JSON into in-memory objects. For this, you need to convert the content to a string and then deserialize it. You could use a user model from Octokit NuGet. Since you are already making custom calls, you might as well use a custom model. For the bare minimum (only the fields you use), your model could look like this:</p>
<pre>public class User
{
    public string Name { get; set; }
    [JsonProperty("created_at")]
    public DateTime CreatedAt { get; set; }
}</pre>
<p>The line <code>[JsonProperty("created_at")]</code>, above <code>public DateTime CreatedAt { get; set; }</code>, binds the JSON field to the C# property. This binding is needed because the names don't match.</p>
<p>If you want to create your own client (for making GitHub calls), it's your responsibility to expose all data that the API returns and not just the data you may need for a particular scenario by letting the consumer choose.</p>
<ol>
<li value="6">Use the message from a previous call from Postman to get the GitHub user response body to generate models to deserialize to. In this case, the response message is as follows (message truncated for clarity):<pre>{
   "login":"github-user",
   "id":40486932,
   "node_id":"MDQ6VXNlcjQwNDg2OTMy",
   "name":"Kaisinel",
   "created_at":"2018-06-22T07:51:56Z",
   "updated_at":"2021-08-12T14:55:29Z"
}</pre></li>
</ol>
<p>There are many tools available that can convert JSON to the C# model.</p>
<ol>
<li value="7">In this case, use <a href="https://json2csharp.com/">https://json2csharp.com/</a> to convert JSON to the C# model code.</li>
<li>Copy the response (<code>GET github/user</code>) and go to <a href="https://json2csharp.com/">https://json2csharp.com/</a>.</li>
<li>Paste the response into the textbox on the left and click the <code>Convert</code> button:</li>
</ol>
<div><div><img alt="Figure 8.10: Converting JSON to the C# model code " height="758" src="img/B16835_08_10.jpg" width="1232"/>
</div>
</div>
<p class="figure-caption">Figure 8.10: Converting JSON to the C# model code</p>
<p>The left side displays a model for the JSON, while the right side displays the code (C# class) that is generated from JSON.</p>
<ol>
<li value="10">Copy the content on the right and paste it into your code:<pre>public class Root
{
    public string login { get; set; }
    public int id { get; set; }
    public string node_id { get; set; }
    public string name { get; set; }
    public DateTime created_at { get; set; }
    public DateTime updated_at { get; set; }
}</pre></li>
</ol>
<p>This is your model. Observe in the preceding code that <code>Root</code> is an unreadable class name. This is because the converter didn't have a way to know what class JSON represents. The <code>Root</code> class represents a user; therefore, rename it <code>User</code>.</p>
<p>Lastly, the converter was probably created prior to .NET 5, which is why it didn't have a feature for records. A record is a great class for serialization purposes and a great candidate for a data transfer object (DTO). A DTO is a class that has no logic but simply data, and sometimes attributes for binding serialization. The benefits you get are the following:</p>
<ul>
<li>Value equality</li>
<li><code>ToString</code> will return properties and their values</li>
<li>The ability to define them with a less verbose syntax</li>
</ul>
<p>So, use a record for defining DTOs in your applications whenever possible.</p>
<ol>
<li value="11">Rename the (<code>Root</code> to <code>User</code>) and change the type from <code>class</code> to <code>record</code>. The code line looks like this with no changes needed to the properties:<pre>public record User</pre></li>
<li>Finally, run the following line of code:<pre>Console.WriteLine($"{user.Name} created profile at {user.CreatedAt}");</pre></li>
</ol>
<p>The output gets displayed as follows:</p>
<pre>Kaisinel created profile at 2018-06-22 07:51:56</pre>
<p>In order to run this exercise, go to <a href="https://packt.link/GR27A">https://packt.link/GR27A</a> and comment all lines within the <code>static void</code> <code>Main(string[] args)</code> body, except <code>await Examples.GitHttp.Demo.Run();</code>. Similarly, uncomment the respective exercises'/examples'/activities' code lines in <code>Program.cs</code> before execution.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/UPxmW">https://packt.link/UPxmW</a>.</p>
<p>Now that you have seen the benefits of using the <code>HttpClient</code> class in lieu of third-party libraries, you can now explore the <code>IDisposable</code> pattern in the following section.</p>
<h3 id="_idParaDest-291"><a id="_idTextAnchor327"/>HttpClient and IDisposable</h3>
<p><code>HttpClient</code> implements the <code>IDisposable</code> pattern. In general, right after you are done using an object that implements <code>IDisposable</code>, you should clean up and call the <code>Dispose</code> method or wrap the calls within a <code>using</code> block. However, <code>HttpClient</code> is special in that you should not frequently create and dispose of it all over again. The problem with disposing and re-initializing <code>HttpClient</code> is that <code>HttpClient</code> manages connections it makes to other APIs and disposing of <code>HttpClient</code> does not properly close those connections (or sockets).</p>
<p>The most dangerous part about that is that you will not notice any difference in developing your application locally, due to the massive number of connections available. However, when deploying an application to a live environment, you risk running out of free socket connections. Once again, avoid calling a <code>Dispose</code> method and reinitializing <code>HttpClient</code>. If you must, use <code>HttpClientFactory</code>. Not only does <code>HttpClientFactory</code> manage the lifetime of socket connections by managing <code>HttpClientMessageHandler</code> (the component responsible for sending the HTTP request and receiving the response) but it also provides logging capability, allows centralized management of clients' configuration, supports injecting middleware to clients, etc. The mentioned benefits are important if you use <code>HttpClient</code> in an enterprise setting. You can learn more about <code>HttpClientFactory</code> in <em class="italic">Chapter 9</em>, <em class="italic">Creating API Services</em>.</p>
<p>Ideally, you should have one static <code>HttpClient</code>, which you can reuse for calls to Web APIs throughout your application. However, you should not have a single <code>HttpClient</code> for everything. The point about not disposing of <code>HttpClient</code> and having a static one is not a hard rule. If you call many different APIs, they will have their own base addresses, mandatory headers, and so on. Having a single object for all is not a viable scenario.</p>
<p>The requests you've handled so far were publicly accessible and did not have security. However, expensive or private operations in Web APIs are usually protected. Typically, protection is set up using an Authorization header. In many cases, an Authorization header involves some sort of an ID and secret. In the case of the GitHub API, it involves a client ID and client secret. But to get them, you will need to create an OAuth app.</p>
<p>Before you can do this though, you need to get familiar with OAuth.</p>
<h2 id="_idParaDest-292"><a id="_idTextAnchor328"/>OAuth</h2>
<p>OAuth is an open-standard authorization protocol that allows delegating access on behalf of a user. This section will explore two examples:</p>
<ul>
<li>Real-life analogy</li>
<li>API analogy</li>
</ul>
<h3 id="_idParaDest-293"><a id="_idTextAnchor329"/>Real-life Analogy</h3>
<p>Imagine a child at school. The teacher of that child is organizing a trip to another city. A permission slip from the parents is needed. The parents give a note: <em class="italic">It's okay for my child to go to place X.</em> The child gives the note to the teacher and gets permission to travel to a field trip to destination X.</p>
<h3 id="_idParaDest-294"><a id="_idTextAnchor330"/>API Analogy</h3>
<p>Many applications are interconnected, with integrations to each other. For example, the famous social platform Discord allows you to display whatever accounts you have on other social media. But to do that, you need to connect to the platform of social media you want to display. For example, when you are on Discord and try to link a Twitter account, you will be required to log in on Twitter. A login will require a certain scope of access (your profile name, in this case). A successful login is proof that access is given, and Discord will be able to display your profile information on Twitter on your behalf.</p>
<h2 id="_idParaDest-295"><a id="_idTextAnchor331"/>OAuth App for GitHub</h2>
<p>Returning to the subject of GitHub, what is an OAuth app? It is a registration for a single point of security. It acts as your application identity. A GitHub user might have zero or more applications. As mentioned before, an OAuth app includes a client ID and secret. Through them, you can use the GitHub API. In other words, you can set it up to request access to secure features of GitHub, such as changing your personal data on GitHub.</p>
<p>GitHub has an interesting API limitation. If more than 60 unauthenticated requests come from the same IP, it will block subsequent requests for up to an hour. However, the rate limitation can be removed by authorizing requests. That is the prime reason why you will be using authorization for an otherwise public endpoint.</p>
<p>OAuth usually involves two client applications:</p>
<ul>
<li>One that requests permission on behalf of someone</li>
<li>Another that grants that permission</li>
</ul>
<p>Therefore, when setting up OAuth, you will most likely be required to create a URL to return to after the permission is granted from the client that can grant access. Setting up an OAuth app on GitHub involves these steps:</p>
<ol>
<li value="1">In the top-right corner, click on your profile picture and click <code>Settings</code>:</li>
</ol>
<div><div><img alt="Figure 8.11: Account settings in GitHub " height="815" src="img/B16835_08_11.jpg" width="1034"/>
</div>
</div>
<p class="figure-caption">Figure 8.11: Account settings in GitHub</p>
<ol>
<li value="2">On the left side, scroll down almost to the bottom of the menu and click the <code>Developer settings</code> option:</li>
</ol>
<div><div><img alt="Figure 8.12: Developer settings in GitHub " height="445" src="img/B16835_08_12.jpg" width="888"/>
</div>
</div>
<p class="figure-caption">Figure 8.12: Developer settings in GitHub</p>
<ol>
<li value="3">Now select the <code>Oauth Apps</code> option:</li>
</ol>
<div><div><img alt="Figure 8.13: Selecting OAuth apps in Developer settings in GitHub " height="299" src="img/B16835_08_13.jpg" width="995"/>
</div>
</div>
<p class="figure-caption">Figure 8.13: Selecting OAuth apps in Developer settings in GitHub</p>
<ol>
<li value="4">Then click the <code>Register a new application</code> button:</li>
</ol>
<div><div><img alt="Figure 8.14: Creating a new OAuth app in GitHub " height="494" src="img/B16835_08_14.jpg" width="1516"/>
</div>
</div>
<p class="figure-caption">Figure 8.14: Creating a new OAuth app in GitHub</p>
<p class="callout-heading">Note</p>
<p class="callout">If you have previously created an OAuth app, then this window will display all those listed. In order to create a new one, you will have to click <code>New OAuth App</code>.</p>
<ol>
<li value="5">In the next window, you will complete the form. Start by filling in <code>Application name</code> (<code>5</code>). Avoid using special characters.</li>
<li>Next, fill in <code>Homepage URL</code> (<code>6</code>).</li>
</ol>
<p>This URL usually points to a website that describes the use of OAuth for a particular case and why it is required. Even if you don't have a website that describes such a case, you can type a placeholder URL (in this case, <code>myapp.com</code>). The field accepts anything as long as it is a valid URL.</p>
<ol>
<li value="7">Fill in the <code>Authorization callback URL</code> (<code>7</code>) field. This can be whatever you want. Here, <code>myapp.com/home</code> is used. Use a valid callback URL.</li>
<li>Click <code>Register application</code> (<code>8</code>):<div><img alt="Figure 8.15: New OAuth app window in GitHub " height="828" src="img/B16835_08_15.jpg" width="828"/></div></li>
</ol>
<p> </p>
<p class="figure-caption">Figure 8.15: New OAuth app window in GitHub</p>
<ol>
<li value="9">In the new window, you will see <code>Client ID</code> and <code>Client secrets</code>:</li>
</ol>
<p> </p>
<div><div><img alt="Figure 8.16: Details of a new OAuth app on GitHub with app  credentials—Client ID and Client secrets " height="763" src="img/B16835_08_16.jpg" width="1068"/>
</div>
</div>
<p class="figure-caption">Figure 8.16: Details of a new OAuth app on GitHub with app credentials—Client ID and Client secrets</p>
<p>It is best to store a client secret in a safe place for future reference because you will see it only once on GitHub. If you forget it, you will have to create a new secret and delete the old one.</p>
<p>Now you have successfully created an OAuth app on GitHub. The client secret is partly hidden in this screenshot for a reason. You should never expose it publicly. In order to use it in a demo, you will use environmental variables first to hide them.</p>
<ol>
<li value="10">So, store the values in environmental variables <code>GithubClientId</code> and <code>GithubSecret</code>.</li>
<li>Then expose the two through static properties in <code>Demo.cs</code> (explained earlier) as follows:<pre>private static string GitHubClientId { get; } = Environment.GetEnvironmentVariable("GithubClientId", EnvironmentVariableTarget.User);
private static string GitHubSecret { get; } = Environment.GetEnvironmentVariable("GithubSecret", EnvironmentVariableTarget.User);</pre></li>
</ol>
<p>This section covered the steps to set up an OAuth app in GitHub that can be used to request access to secure features of GitHub, such as changing your personal data. With this knowledge, you can now use a client ID and client secret to create authorized calls on the GitHub API, as demonstrated in the following section.</p>
<h2 id="_idParaDest-296"><a id="_idTextAnchor332"/>Authorization Header</h2>
<p>Authorization headers come in three forms—basic, API key (or personal access token), and third-party authentication. The GitHub API does not allow an unlimited number of calls from the same source. Like the Azure Text Analytics client, it uses an API key as well. However, in this case, the API key is used for rate limiting (how many calls you can make in an hour). For anonymous calls, it only allows 60 calls an hour. However, by using a valid Authorization header, the amount is increased to 5,000.</p>
<p>In the following example, you'll make one more call than the rate limit allows (60 + 1 = 61). That way, you will get user information 61 times. For that to happen, you will also make sure that the <code>CacheControl</code> header is set to <code>NoCache</code> because you don't want a request to be ignored after 60 consecutive calls:</p>
<pre>public static as<a id="_idTextAnchor333"/>ync Task GetUser61Times()
{
    const int rateLimit = 60;
    for (int i = 0; i &lt; rateLimit + 1; i++)
    {
        const string username = "github-user";
        var request = new HttpRequestMessage(HttpMethod.Get, new Uri($"users/{username}", UriKind.Relative));
        request.Headers.CacheControl = new CacheControlHeaderValue(){NoCache = true};
        
        var response = await client.SendAsync(request);
        if (!response.IsSuccessStatusCode)
        {
            throw new Exception(response.ReasonPhrase);
        }</pre>
<p>This block of code is an adaptation of the <code>GetUser</code> method from the <em class="italic">HttpClient</em> section. There are three main adjustments here:</p>
<ul>
<li>The first is that everything in a loop runs 61 times.</li>
<li>You have also added an error handler, which means if a response is not a success, you will print an error message returned by the API.</li>
<li>Lastly, you add a <code>CacheControl</code> header to ignore caching (because you do want 61 calls to the server).</li>
</ul>
<p>Running this code results in an error message on the sixty-first call, which proves the API rate limitation (the error message has been truncated for clarity):</p>
<pre>60) Kaisinel created profile at 2018-06-22 07:51:56
Unhandled exception. System.Exception: rate limit exceeded</pre>
<p>To fix this, you will need to add an <code>Authorization</code> header (you will add it just under the <code>CacheControl </code>header):</p>
<pre>GitHttp.cs
public static async Task GetUser61Times(string authHeader)
{
    const int rateLimit = 60;
            for (int i = 0; i &lt; rateLimit + 1; i++)
            {
                const string username = "github-user"; // replace with your own
                var request = new HttpRequestMessage(HttpMethod.Get, new Uri($"users/{username}", UriKind.Relative));
               request.Headers.CacheControl = new CacheControlHeaderValue(){NoCache = true};
               request.Headers.Add("Authorization", authHeader);
               var response = await client.SendAsync(request);
                if (!response.IsSuccessStatusCode)
                {
                    throw new Exception(response.ReasonPhrase);
                }
The complete code can be found here: <a href="https://packt.link/1C5wb">https://packt.link/1C5wb</a>.</pre>
<p>Due to GitHub's limitations on anonymous calls (for example, the fact that you can make only 60 requests per hour to get user profile information), you will find it more efficient to provide an Authorization header so that you are identified and therefore released from such strict constraints. In the examples that follow, you will get an authorization token that you will feed to this method, thus showing how authorization will help you overcome the rate limit.</p>
<p>When running the demo code placed at <a href="https://packt.link/Uz2BL">https://packt.link/Uz2BL</a>, it is recommended that you run one example at a time (i.e., uncomment one line and comment the rest within the <code>Run</code> method). This is because the <code>Demo.cs</code> file is a mix of authorized and anonymous calls, and you might get unexpected results. However, keep the line where you get a token as it may be required by individual examples.</p>
<p>At the end of this section, you should have grasped the logic behind the Authorization header and its three forms—basic, API key (or personal access token), and third-party authentication—and learned that, like the Azure Text Analytics client, the GitHub API uses an API key. Now you can move on to basic authentication.</p>
<h2 id="_idParaDest-297"><a id="_idTextAnchor334"/>Basic Authentication</h2>
<p>Basic authentication involves a username and password. The two are usually combined in a single string and encoded using the following format:</p>
<pre>Basic username:password</pre>
<p>Here is the code used to generate an authorization taken for basic authentication:</p>
<pre>public static string GetBasicToken()
{
    var id = GitHubClientId;
    var secret = GitHubSecret;
    var tokenRaw = $"{id}:{secret}";
    var tokenBytes = Encoding.UTF8.GetBytes(tokenRaw);
    var token = Convert.ToBase64String(tokenBytes);
    return "Basic " + token;
}</pre>
<p>Use a username and password to get a basic token. Then pass it to the <code>GetUser61Times</code> method:</p>
<pre>var basicToken = GitExamples.GetBasicToken();
await GitExamples.GetUser61Times(basicToken);</pre>
<p>Calling <code>GetUser61Times</code> no longer displays an error because the rate limitation is avoided by supplying an Authorization header.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/Uz2BL">https://packt.link/Uz2BL</a> and <a href="https://packt.link/UPxmW">https://packt.link/UPxmW</a>.</p>
<p>The next section will cover the more specialized API key and personal access token, which are similar as they both grant access to otherwise protected data.</p>
<h3 id="_idParaDest-298"><a id="_idTextAnchor335"/>API Key and Personal Access Token</h3>
<p>A personal access token is limited to personal data. However, an API key can be used for the whole API. Other than the scope of what can be accessed, the two have no difference in how they are used. You can add an API key or a personal access token to an Authorization header as is.</p>
<p>But, of course, to use an access token of a certain API, you first need to create it. You can do this through the following steps:</p>
<ol>
<li value="1">Go to GitHub's <code>Developer settings</code> option under <code>Settings</code> window.</li>
<li>Navigate to <code>Personal access tokens</code> (<code>1</code>).</li>
<li>Select <code>Generate new token</code> button (<code>2</code>):</li>
</ol>
<div><div><img alt="Figure 8.17: Creating a new personal access token " height="450" src="img/B16835_08_17.jpg" width="1564"/>
</div>
</div>
<p class="figure-caption">Figure 8.17: Creating a new personal access token</p>
<ol>
<li value="4">Next, enter your GitHub password.</li>
<li>Add a note (this can be anything) and scroll down. This screen will help you to modify user data, so check the <code>user</code> checkbox (<code>4</code>) to get access to it.</li>
<li>Click the <code>Generate token</code> button (<code>5</code>):</li>
</ol>
<div><div><img alt="Figure 8.18: Scope of access configured for a personal access token " height="682" src="img/B16835_08_18.jpg" width="833"/>
</div>
</div>
<p class="figure-caption">Figure 8.18: Scope of access configured for a personal access token</p>
<p>In the new window, you will see all the personal access tokens, along with the newly added ones:</p>
<div><div><img alt="Figure 8.19: A new personal access token created on GitHub " height="313" src="img/B16835_08_19.jpg" width="1100"/>
</div>
</div>
<p class="figure-caption">Figure 8.19: A new personal access token created on GitHub</p>
<p class="callout-heading">Note</p>
<p class="callout">Remember that you will see the value of a token only once. So, make sure you copy and store it securely. Also, be aware that the personal access token expires after a month, at which point you need to regenerate it.</p>
<ol>
<li value="7">Create an environmental variable called <code>GitHubPersonalAccess</code>.</li>
<li>Add the personal access token to <code>Demo.cs</code>:<pre>private static string GitHubPersonAccessToken { get; } = Environment.GetEnvironmentVariable("GitHubPersonalAccess", EnvironmentVariableTarget.User);</pre></li>
<li>Run the following code:<pre>await GetUser61Times(GitHubPersonAccessToken);</pre></li>
</ol>
<p>You will observe that calling the <code>GetUser61Times</code> method does not fail.</p>
<p>Access tokens, authorization tokens, API keys, and JWTs (which will be further covered in the following sections) are different means to prove to an API that you have been granted access to it and have rights to a resource you want. But regardless of which specific kind of authorization you use, they will usually all go to the same place—that is, the Authorization header.</p>
<p>The next section will detail an authorization protocol called OAuth2.</p>
<h2 id="_idParaDest-299"><a id="_idTextAnchor336"/>Third-Party Authentication—OAuth2</h2>
<p>GitHub is an example of an authorization server. It allows access to a resource or functionality in the name of the owner. For example, updating the user's employment status is only available to a logged-in user. However, this can be done directly given the user has been granted the access to do so. A program getting access on behalf of someone is what OAuth2 is all about.</p>
<p>Perform the following steps to modify the user's employment status:</p>
<ol>
<li value="1">Navigate to this URL or send an HTTP <code>GET</code> request:<pre>https://github.com/login/oauth/authorize?client_id={{ClientId}}&amp;redirect_uri={{RedirectUrl}}</pre></li>
</ol>
<p>Here, <code>{{ClientId}}</code> and <code>{{RedirectUrl}}</code> are the values that you have set in the OAuth2 GitHub app.</p>
<p class="callout-heading">Note</p>
<p class="callout">Replace the placeholders <code>{{ClientId}}</code> and <code>{{RedirectUrl}}</code> with the ones from your GitHub OAuth app.</p>
<p>The following screen prompts you to log in to your GitHub app:</p>
<div><div><img alt="Figure 8.20: Signing in to OAuth2 GitHub app " height="443" src="img/B16835_08_20.jpg" width="733"/>
</div>
</div>
<p class="figure-caption">Figure 8.20: Signing in to OAuth2 GitHub app</p>
<ol>
<li value="2">Complete <code>Username</code> and <code>Password</code>.</li>
<li>Next, click the <code>Sign in</code> button to log in.</li>
</ol>
<p>After a successful login, you will be redirected to a URL specified in your OAuth2 app.</p>
<ol>
<li value="4">Create a request for the token by sending an HTTP <code>POST</code> request to a URI in the following format:<pre>{tokenUrl}?client_id={clientId}&amp;redirect_uri={redirectUri}&amp;client_secret={secret}&amp;code={code}:</pre></li>
</ol>
<p>The code for it is as follows:</p>
<pre>private static HttpRequestMessage CreateGetAccessTokenRequest()
{
    const string tokenUrl = "https://github.com/login/oauth/access_token";
    const string code = "2ecab6ecf412f28f7d4d";
    const string redirectUri = "https://www.google.com/";
    var uri = new Uri($"{tokenUrl}?client_id={GitHubClientId}&amp;redirect_uri={redirectUri}&amp;client_secret={GitHubSecret}&amp;code={code}");
    var request = new HttpRequestMessage(HttpMethod.Post, uri);
    return request;
}</pre>
<p>In this case, the redirect URL was <a href="https://www.google.com">https://www.google.com</a>. The URI you ended up with was <a href="https://www.google.com/?code=a681b5126b4d0ba160ba">https://www.google.com/?code=a681b5126b4d0ba160ba</a>. The <code>code=</code> part is the code needed to get the <code>OAuth</code> access token. The token is returned in the following format:</p>
<pre>access_token=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&amp;scope=user&amp;token_type=bearer</pre>
<ol>
<li value="5">Before this token can be used, you need to parse it from the response. So, create a function to parse the token response:<pre>private static Dictionary&lt;string, string&gt; ConvertToDictionary(string content)
{
    return content
        .Split('&amp;')
        .Select(kvp =&gt; kvp.Split('='))
        .Where(kvp =&gt; kvp.Length &gt; 1)
        .ToDictionary(kvp =&gt; kvp[0], kvp =&gt; kvp[1]);
}</pre></li>
</ol>
<p>This takes every <code>=</code> property and puts it into a dictionary. The string before <code>=</code> is a key and the string after <code>=</code> is a value.</p>
<ol>
<li value="6">Use the <code>GetToken</code> function to create and send a request and parse a response, then format the token and return it:<pre>private static async Task&lt;string&gt; GetToken()
{
    HttpRequestMessage request = CreateGetAccessTokenRequest();
    var response = await client.SendAsync(request);
    var content = await response.Content.ReadAsStringAsync();
    Dictionary&lt;string, string&gt; tokenResponse = ConvertToDictionary(content);
    // ValidateNoError(tokenResponse);
    var token = $"{tokenResponse["token_type"]} {tokenResponse["access_token"]}";
    return token;
}</pre></li>
</ol>
<p>Here, you created a request, sent it to a client, parsed the response as a token, and then returned it. <code>ValidateNoError</code> is commented out for now. You will come back to it later. The returned token should look something like this:</p>
<pre>bearer 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</pre>
<p>This token is a bearer token, which is a token generated by an authorization server (in this case, GitHub) that grants access to GitHub on behalf of you (or any other username used for logging in to GitHub). You can use it to send requests that require special access. For example, update the employment status of a user.</p>
<ol>
<li value="7">To update the employment status of a user, use the <code>UpdateEmploymentStatus</code> function:<pre>public static async Task UpdateEmploymentStatus(bool isHireable, string authToken)
{
    var user = new UserFromWeb
    {
        hireable = isHireable
    };
    var request = new HttpRequestMessage(HttpMethod.Patch, new Uri("/user", UriKind.Relative));
    request.Headers.Add("Authorization", authToken);
    var requestContent = JsonConvert.SerializeObject(user, new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore });
    request.Content = new StringContent(requestContent, Encoding.UTF8, "application/json");
    var response = await client.SendAsync(request);
    var responseContent = await response.Content.ReadAsStringAsync();
    Console.WriteLine(responseContent);
}</pre></li>
</ol>
<p>This block of code sets the user's property <code>isHireable</code> to <code>true</code> and prints the updated user information. The important part here is content; when sending <code>PUT</code>, <code>PATCH</code>, or a <code>POST</code> request, you often need a body with a request (or content in other words).</p>
<p>The act of converting an in-memory object into structured text (for example, JSON) is called serialization. In this case, a body is a user update. You send a <code>PATCH</code> request because you only want to change the updated values. If a value is not provided in the content, it should not change. That's the key difference between a <code>PATCH</code> and <code>POST</code> request—a successful request overrides all values (even if you don't provide them).</p>
<p>You used <code>new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore }</code> in order to avoid providing <code>null</code> values. This is because you do not want to update all the fields; just the ones you have supplied.</p>
<p>When creating HTTP content, you also need to supply a MIME type (a type of media sent over with the request). It is needed so that the server has a hint for how it is expected to process the request. A MIME type follows this format:</p>
<pre>type/subtype</pre>
<p>In this case, <code>application/json</code> means that the client should expect JSON from a server. <code>application</code> is the most common MIME type, which means binary data.</p>
<p>There is also <code>StringContent</code>, which is a type of serialized content, usually as JSON or XML. Alternatively, you could use <code>StreamContent</code> or <code>ByteContent</code>, but those are slightly rarer and are used when performance or the volume of data is of concern.</p>
<p>The following code shows the full demo:</p>
<pre>public static async Task Run()
{
    var oathAccessToken = await GitExamples.GetToken();
    await GitExamples.UpdateEmploymentStatus(true, oathAccessToken);
}</pre>
<p>In the <code>GetToken</code> method (used in <em class="italic">Step 6</em> of the <em class="italic">Third-Party Authentication (OAuth2)</em> section), there was one commented line of code, <code>ValidateNoError</code>. Uncomment it and implement the <code>GetToken</code> method, because you won't always get a successful response, and parsing a token in that case will fail (i.e., it won't exist). Therefore, it is always a good idea to validate the server response and throw an exception when the unexpected happens. Look at the following GitHub error format:</p>
<pre>error=bad_verification_code&amp;error_description=The+code+passed+is+incorrect+or+expired.&amp;error_uri=https%3A%2F%2Fdocs.github.com%2Fapps%2Fmanaging-oauth-apps%2Ftroubleshooting-oauth-app-access-token-request-errors%2F%23bad-verification-code</pre>
<p>It is not very readable. <code>ValidateNoError</code> will format the response and throw that as an exception, instead of letting it fail silently:</p>
<pre>private static void ValidateNoError(Dictionary&lt;string, string&gt; tokenResponse)
{
    if (tokenResponse.ContainsKey("error"))
    {
        throw new Exception(
            $"{tokenResponse["error"].Replace("_", " ")}. " +
            $"{tokenResponse["error_description"].Replace("+", " ")}");
    }
}</pre>
<p>If you run the code again and it fails for the same reasons, the error message will now read as follows:</p>
<pre>bad verification code. The code passed is incorrect or expired.</pre>
<p>This section covered the basics of how to send HTTP requests with some sort of security in place. In the sections that follow (<em class="italic">Restsharp</em> and <em class="italic">Refit</em>), you will create clients using third-party libraries to remove some of the boilerplate code required by <code>HttpClient</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/UPxmW">https://packt.link/UPxmW</a>.</p>
<h2 id="_idParaDest-300"><a id="_idTextAnchor337"/>Request Idempotency</h2>
<p>An idempotent HTTP request is a request that always results in the same outcome. Only <code>GET</code>, <code>PUT</code>, and <code>PATCH</code> requests are idempotent because they either make no change or make the same change all over again, but that change does not ever cause an error and results in the same data. <code>DELETE</code> is not idempotent because deleting an already deleted item will produce an error. <code>POST</code> may or may not be idempotent, but that solely depends on the implementation.</p>
<h3 id="_idParaDest-301"><a id="_idTextAnchor338"/>PUT, PATCH, or POST</h3>
<p>The difference between <code>PUT</code>, <code>PATCH</code>, and <code>POST</code> can be summed up as follows:</p>
<ul>
<li><code>PUT</code> is used for overriding fields in a model. Even if a single value is explicitly provided, the whole model will have the unprovided values (or at least that's the expectation). For example, if you wanted to update user details by first getting the old details and then sending a modified version, you would use <code>PUT</code>.</li>
<li><code>PATCH</code> is used for updating only a single value that was provided explicitly. For example, if you wanted to update a username, it would make sense to send <code>PATCH</code> over a <code>PUT</code> request.</li>
<li><code>POST</code> is used for creating items or sending a complex query. Either way, the default expectation of this verb is to have side effects. For example, if you wanted to create a user, you would use a <code>POST</code> request.</li>
</ul>
<h2 id="_idParaDest-302"><a id="_idTextAnchor339"/>Exercise 8.02: HttpClient Calling a Star Wars Web API</h2>
<p>You might be familiar with Star Wars. There are movies, games, and TV series. However, did you know that it also has multiple APIs to retrieve data? The upcoming exercise will introduce you to a different format of an API and will make you familiar with deserializing slightly more complex responses.</p>
<p>In this exercise, you will create a strongly typed API client that will, under the hood, use <code>HttpClient</code>. The client will be used to return Star Wars movies. You will be using Star Wars API (SWAPI) (<a href="https://swapi.dev/">https://swapi.dev/</a>). The required endpoint is <a href="https://swapi.dev/api/films/">https://swapi.dev/api/films/</a>. Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">Create a new class to hold <code>HttpClient</code> with a base URL:<pre>public class StarWarsClient
    {
        private readonly HttpClient _client;
        public StarWarsClient()
        {
            _client = new HttpClient {BaseAddress = new Uri("https://swapi.dev/api/")};
        }</pre></li>
</ol>
<p>This will act as a strongly typed API client.</p>
<p class="callout-heading">Note</p>
<p class="callout">The <code>/</code> at the end of the URI indicates that more text will be appended to the URI (after <code>api</code> rather than after <code>dev</code>).</p>
<ol>
<li value="2">Create a type for representing a movie:<pre>Film.cs
public record Film
{
    public string Title { get; set; }
    public int EpisodeId { get; set; }
    public string OpeningCrawl { get; set; }
    public string Director { get; set; }
    public string Producer { get; set; }
    [JsonProperty("release_date")]
    public string ReleaseDate { get; set; }
    public string[] Characters { get; set; }
    public string[] Planets { get; set; }
    public string[] Starships { get; set; }
    public string[] Vehicles { get; set; }
    public string[] Species { get; set; }
    public DateTime Created { get; set; }</pre></li>
</ol>
<pre>The complete code can be found here: <a href="https://packt.link/tjHLa">https://packt.link/tjHLa</a>.</pre>
<p>This is a class you will use for deserializing movies within a response. The <code>ReleaseDate</code> property has <code>[JsonProperty("release_date")]</code> above it to specify that the <code>"release_date"</code> JSON field will map to the <code>ReleaseDate</code> C# property.</p>
<ol>
<li value="3">Create a type for storing results:<pre>public record ApiResult&lt;T&gt;
{
    public int Count { get; set; }
    public string Next { get; set; }
    public string Previous { get; set; }
    [JsonProperty("results")]
    public T Data { get; set; }
}</pre></li>
</ol>
<p>This is also a type for deserializing a movie response; however, the Star Wars API returns results in paginated format. It contains <code>Previous</code> and <code>Next</code> properties pointing to previous and next pages. For example, if you don't provide the page you want, it will return a value of <code>null</code>. However, the next property will point to the next page only if there are any elements left (otherwise it will also be <code>null</code>). Querying the API using next or previous as a URI will return the resources of that page. You used the <code>JsonProperty</code> attribute above <code>T Data</code> to provide JSON-to-property mapping because the property and JSON names do not match (the JSON field name is <code>results</code> while <code>Data</code> is the property name).</p>
<p class="callout-heading">Note</p>
<p class="callout">You could have changed <code>ApiResult</code> to have the <code>Results</code> property instead of <code>Data</code>. However, <code>ApiResult.Results</code> is a bit confusing. When writing code, instead of ease of automation (in this case, serialization), choose ease of maintainability and readability. For this reason, the name chosen in <em class="italic">Step 3</em> is different but clearer.</p>
<ol>
<li value="4">Now, create a method to get multiple films:<pre>public async Task&lt;ApiResult&lt;IEnumerable&lt;Film&gt;&gt;&gt; GetFilms()
{</pre></li>
</ol>
<p>You've returned a task so that others can await this method. Almost all HTTP calls will be <code>async Task</code>.</p>
<ol>
<li value="5">Create an HTTP request to get all movies:<pre>var request = new HttpRequestMessage(HttpMethod.Get, new Uri("films", UriKind.Relative));</pre></li>
</ol>
<p>The URI is relative because you're calling it from <code>HttpClient</code> that already has a base URI set.</p>
<ol>
<li value="6">To query the Star Wars API for movies, send this request:<pre>var response = await _client.SendAsync(request);</pre></li>
<li>It returns <code>HttpResponseMessage</code>. There are two important parts to this: status code and response body. C# has a method to determine whether there were any errors based on the status code. To handle errors, use the following code:<pre>if (!response.IsSuccessStatusCode)
{
      throw new HttpRequestException(response.ReasonPhrase);
}</pre></li>
</ol>
<p>Error handling is important because a failed HTTP request will often result in an error status code rather than an exception. It's recommended you do something similar before trying to deserialize the response body as, if it fails, you might get an unexpected body.</p>
<ol>
<li value="8">Now, call the <code>ReadAsStringAsync</code> method:<pre>var content = await response.Content.ReadAsStringAsync();
var films = JsonConvert.DeserializeObject&lt;ApiResult&lt;Film&gt;&gt;(content);
    return films;
}</pre></li>
</ol>
<p>The response has content that is more likely to be a kind of stream. To convert <code>HttpContent</code> to a string, call the <code>ReadAsStringAsync</code> method. This returns a string (JSON), which allows you to convert JSON to a C# object and deserialize the results. Lastly, you get the results by deserializing the response content body and converting it all to <code>ApiResult&lt;Film&gt;</code>.</p>
<ol>
<li value="9">For a demo, create the client and use it to get all the Star Wars films, then print them:<pre>public static class Demo
{
    public static async Task Run()
    {
        var client = new StarWarsClient();
        var filmsResponse = await client.GetFilms();
        var films = filmsResponse.Data;
        foreach (var film in films)
        {
            Console.WriteLine($"{film.ReleaseDate} {film.Title}");
        }
    }
}</pre></li>
</ol>
<p>If everything is fine, you should see the following result:</p>
<pre>1977-05-25 A New Hope
1980-05-17 The Empire Strikes Back
1983-05-25 Return of the Jedi
1999-05-19 The Phantom Menace
2002-05-16 Attack of the Clones
2005-05-19 Revenge of the Sith</pre>
<p>This exercise illustrates how to create strongly typed HTTP clients for simplicity.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/2CHpb">https://packt.link/2CHpb</a>.</p>
<p>You might have noticed that sending an HTTP request and using an HTTP client is very similar to the way a simple text file is sent to the GitHub API. Even if it was different, endpoints throughout the same API usually share the same requirements. However, if you manually craft an HTTP request every time you need to call an API, you are not being very efficient. A better way is to create something reusable. A common approach is to create <code>BaseHttpClient</code>. You will put this into practice in the following activity.</p>
<h2 id="_idParaDest-303"><a id="_idTextAnchor340"/>Activity 8.01: Reusing HttpClient for the Rapid Creation of API Clients</h2>
<p>The problem with <code>HttpClient</code> is that you still have to manage many things by yourself:</p>
<ul>
<li>Error handling</li>
<li>Serializing and deserializing</li>
<li>Mandatory headers</li>
<li>Authorization</li>
</ul>
<p>When working in a team or on a bigger project, you are likely to be making more than just one HTTP call. The consistency and same requirements between different calls need to be managed.</p>
<p>The aim of this activity is to show one of many ways you can simplify working with repetitive HTTP calls. You will be using the <code>BaseHttpClient</code> class, which you will create first. The class will generalize error handling and deserializing responses and requests, which will significantly simplify different HTTP calls that you make. Here, you will learn how to implement a base client by rewriting <code>StarWarsClient</code> using <code>BaseHttpClient</code>.</p>
<p>Perform the following steps to complete this activity:</p>
<ol>
<li value="1">Create a base <code>HttpClient</code> class. A base client wraps <code>HttpClient</code>. Therefore, you will hold a private reference to it and allow it to be created from a URL. The inner <code>HttpClient</code> often also includes base headers, but they are not required in this case.</li>
<li>Define a way to create requests for every method. For brevity, stick to a <code>GET</code> request. Within a <code>GET</code> request, it is a common practice to define the default headers, but once again, it is not mandatory in this example.</li>
<li>Create a method to send requests and include error handling and deserialization.</li>
<li>In SWAPI, if you are querying multiple results, you get back <code>ApiResult&lt;IEnumerable&lt;T&gt;&gt;</code> for pagination. Create a <code>SendGetManyRequest</code> method.</li>
<li>Use the base client you have created and simplify the client from <em class="italic">Exercise 8.02</em>.</li>
<li>Run the code through the same demo code but using the new version of <code>StarWarsClient</code>.</li>
<li>If you run the demo once again with the new <code>StarWarsClient</code>, you should see the same films returned:<pre>1977-05-25 A New Hope
1980-05-17 The Empire Strikes Back
1983-05-25 Return of the Jedi
1999-05-19 The Phantom Menace
2002-05-16 Attack of the Clones
2005-05-19 Revenge of the Sith</pre></li>
</ol>
<p>In order to run this activity, go to <a href="https://packt.link/GR27A">https://packt.link/GR27A</a> and comment all lines within the <code>static void</code> <code>Main(string[] args)</code> body, except <code>await Activities.Activity01.Demo.Run();</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found at <a href="https://packt.link/qclbF">https://packt.link/qclbF</a>.</p>
<p>Reusing <code>HttpClient</code> like that is very useful because it removes code duplication. However, calling a Web API and removing duplicate code is a common problem and is likely to be solved in some way by some libraries. The following section will explore how to simplify calls to a Web API using two popular NuGet packages:</p>
<ul>
<li>RestSharp</li>
<li>Refit</li>
</ul>
<h1 id="_idParaDest-304"><a id="_idTextAnchor341"/>RestSharp</h1>
<p>The idea behind RestSharp is very similar to the base <code>HttpClient</code>—reducing code duplicity. It simplifies the creation of a request and provides a lot of the utility for making HTTP calls. Redo <code>StarWarsClient</code> using <code>RestSharp</code>, but first, you'll install the <code>RestSharp</code> NuGet:</p>
<pre>dotnet add package RestSharp</pre>
<p>Now create a client that is very similar to the one you created in <em class="italic">Activity 8.01</em>:</p>
<pre>    public class StarWarsClient
    {
        private readonly RestClient _client;
        public StarWarsClient()
        {
            _client = new RestClient("https://swapi.dev/api/");
        }</pre>
<p>Having <code>RestSharp</code> created gives you a response serialization out of the box. It is also able to guess which HTTP method you will use:</p>
<pre>        public async Task&lt;ApiResult&lt;IEnumerable&lt;Film&gt;&gt;&gt; GetFilms()
        {
            var request = new RestRequest("films");
            var films = await _client.GetAsync&lt;ApiResult&lt;IEnumerable&lt;Film&gt;&gt;&gt;(request);
            return films;
        }
    }</pre>
<p>You passed the minimum required information to make an HTTP request (calling films, returning <code>ApiResult&lt;IEnumerable&lt;Film&gt;&gt;</code>) and the rest is done. This is very much like the base client you wrote previously.</p>
<p class="callout-heading">Note</p>
<p class="callout"><code>ApiResult</code> is the same type used in <em class="italic">Exercise 8.02</em>.</p>
<p>However, if you run this code against your demo, you will notice that the <code>Data</code> property (on JSON) comes back as <code>null</code>. This is because you had a <code>JsonProperty</code> attribute on the <code>response</code> and <code>film</code> classes. RestSharp uses a different serializer, which does not know about those attributes. To make it work, you could either change all the attributes to what RestSharp comprehends or use the same serializer as before. You are using <code>Newtonsoft.Json</code> and, in order to use that in RestSharp, you need to call the <code>UseSerializer</code> method, selecting <code>JsonNetSerializer</code>:</p>
<pre>        public StarWarsClient()
        {
            _client = new RestClient("https://swapi.dev/api/");
            _client.UseSerializer(() =&gt; new JsonNetSerializer());
        }</pre>
<p>On running the demo, the following output gets displayed:</p>
<pre>1977-05-25 A New Hope
1980-05-17 The Empire Strikes Back
1983-05-25 Return of the Jedi
1999-05-19 The Phantom Menace
2002-05-16 Attack of the Clones
2005-05-19 Revenge of the Sith</pre>
<p>The results are the same as those in <em class="italic">Exercise 8.02</em>; however, the difference is using the <code>Newtonsoft</code> serializer in the preceding example. <code>RestSharp</code> is probably the best abstraction for <code>HttpClient</code> as it minimizes the amount of code you need to write to make HTTP calls even while keeping its similarities with <code>HttpClient</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/f5vVG">https://packt.link/f5vVG</a>.</p>
<p>The example aims to communicate with Web APIs using HTTP requests. Even though the demo files look the same, they are using either a different library or design pattern. In the following activity, you will practice consuming more APIs using RestSharp.</p>
<h2 id="_idParaDest-305"><a id="_idTextAnchor342"/>Activity 8.02: The Countries API Using RestSharp to List all Countries</h2>
<p>The address <a href="https://restcountries.com/v3/">https://restcountries.com/v3/</a> is a public web API that provides a list of all existing countries. Suppose that using that API, you need to get a list of all countries, find a country by its capital city (for example, Vilnius), and find all the countries that speak in a given language (for example, Lithuanian). You need to print only the first two country names, their regions, and their capitals, and implement a strongly typed client to access this API using <code>RestSharp</code>.</p>
<p>The aim of this activity is to make you feel more comfortable using third-party libraries (<code>RestSharp</code>) when making HTTP calls. Using third-party libraries often saves a lot of time. It allows you to reuse something that is already available.</p>
<p>Perform the following steps to complete this activity:</p>
<ol>
<li value="1">Create a base client class using the URL <a href="https://restcountries.com/v3/">https://restcountries.com/v3/</a>.<p class="callout-heading">Note</p><p class="callout">Navigating to <a href="https://restcountries.com/v3/">https://restcountries.com/v3/</a> will return the HTTP status code <code>404</code> with a <code>Page Not Found</code> message. This is because the base API URI doesn't contain any information on a resource; it is yet to be completed and is just the beginning of a full URI for a resource.</p></li>
<li>Create models for serialization.</li>
<li>Use the example <a href="https://restcountries.com/v3/name/peru">https://restcountries.com/v3/name/peru</a> to get a response.</li>
<li>Copy the response and then use a class generator, such as <a href="https://json2csharp.com/">https://json2csharp.com/</a>, to make models out of JSON (response).</li>
<li>Within the client, create the following methods: <code>Get</code>, <code>GetByCapital</code>, and <code>GetByLanguage</code>.</li>
<li>Create a demo calling all three methods.</li>
<li>Print the countries within each response.</li>
</ol>
<p>The result should be as follows:</p>
<pre>All:
Aruba Americas Oranjestad
Afghanistan Asia Kabul
Lithuanian:
Lithuania Europe Vilnius
Vilnius:
Lithuania Europe Vilnius</pre>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found at <a href="https://packt.link/qclbF">https://packt.link/qclbF</a>.</p>
<p>You now know that RestSharp simplifies the creation of a request and provides a lot of the utilities for making HTTP calls. The next section will help you practice using Refit, which is another way to consume an API.</p>
<h1 id="_idParaDest-306"><a id="_idTextAnchor343"/>Refit</h1>
<p>Refit is the smartest client abstraction because it generates a client from an interface. All you have to do is provide an abstraction:</p>
<ol>
<li value="1">To use the <code>Refit</code> library, first install the <code>Refit</code> NuGet:<pre>dotnet add package Refit</pre></li>
<li>To create a client in Refit, first create an interface with HTTP methods:<pre>public interface IStarWarsClient
{
    [Get("/films")]
    public Task&lt;ApiResult&lt;IEnumerable&lt;Film&gt;&gt;&gt; GetFilms();
}</pre></li>
</ol>
<p>Please note that the endpoint here is <code>/films</code> rather than <code>films</code>. If you run the code with <code>films</code>, you will get an exception suggesting that you change the endpoint with a preceding <code>/</code>.</p>
<ol>
<li value="3">To resolve the client, simply run the following code:<pre>var client = RestService.For&lt;IStarWarsClient&gt;("https://swapi.dev/api/");</pre></li>
</ol>
<p>On running the demo, the following output gets displayed:</p>
<pre>1977-05-25 A New Hope
1980-05-17 The Empire Strikes Back
1983-05-25 Return of the Jedi
1999-05-19 The Phantom Menace
2002-05-16 Attack of the Clones
2005-05-19 Revenge of the Sith</pre>
<p>The results are the same as the ones you saw in <em class="italic">Exercise 8.02</em>; however, the difference is in the implementation.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/cqkH5">https://packt.link/cqkH5</a>.</p>
<p>Use Refit only when your scenarios are trivial. Though Refit might seem like the easiest solution, it comes with its own complications when you need custom authorization for more complex scenarios. You will simplify the solution further in the following activity.</p>
<h2 id="_idParaDest-307"><a id="_idTextAnchor344"/>Activity 8.03: The Countries API Using Refit to List all Countries</h2>
<p>The more different ways you know of doing the same thing, the easier you can make a choice and pick the best tool for the job. Different teams may use different tools and Refit is quite a unique, minimalistic approach that you may encounter. Others may say it complicates work because there is too much hidden in the client interface (less code often does not mean that you can grasp the code easily). It doesn't matter whether you are for Refit or against it; it's good to have practiced things first-hand and formed your own opinion. This activity will help you do exactly that. Here, you will access the Countries API to display all countries, countries by their language, and by their capital city.</p>
<p>The aim of this activity is to show how practical Refit can be for rapid prototyping when it comes to consuming simple APIs. The steps for this are as follows:</p>
<ol>
<li value="1">Create models for serialization. For that, use the example <a href="https://restcountries.com/v3/name/peru">https://restcountries.com/v3/name/peru</a> to get a response.</li>
<li>Now copy the response.</li>
<li>Then use a class generator, such as <a href="https://json2csharp.com/">https://json2csharp.com/</a>, to make models out of JSON (response).</li>
<li>Define an interface with methods: <code>Get</code>, <code>GetByCapital</code>, and <code>GetByLanguage</code>.</li>
<li>Create a demo printing a country name, region, and country status.</li>
</ol>
<p>The result will be displayed as follows:</p>
<pre>All:
Aruba Americas Oranjestad
Afghanistan Asia Kabul
Lithuanian:
Lithuania Europe Vilnius
Vilnius:
Lithuania Europe Vilnius</pre>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found at <a href="https://packt.link/qclbF">https://packt.link/qclbF</a>.</p>
<p>.NET has a few other native ways of creating HTTP requests, and for that, you can use <code>HttpWebRequest</code> or <code>WebClient</code>. The two are not deprecated and it is fine to use them, but they are older alternatives compared to the newer <code>HttpClient</code>. The next section covers all these.</p>
<p>In the following section, you'll find out about other libraries that solve the problem of code duplication when using <code>HttpClient</code>.</p>
<h1 id="_idParaDest-308"><a id="_idTextAnchor345"/>Other Ways of Making HTTP Requests</h1>
<p>Refit and RestSharp are just two of many libraries solving the problem of code duplication when using <code>HttpClient</code>. Flurl and TinyRest are another two popular alternatives. New libraries are created every year and they are ever evolving. There is no one best way that suits all scenarios. To be sure you make the right choice, you'll want to do a little research first as there are some pitfalls to these alternatives to consider.</p>
<p><code>HttpClient</code> was designed for the lowest-level HTTP calls in .NET. It is the safest option because it is well-documented, tested, and allows the most freedom. Though there are many libraries that are much simpler to use than <code>HttpClient</code>, they often target basic scenarios (no authorization, no dynamically set headers). When it comes to creating advanced HTTP calls, they often turn out to be quite complicated.</p>
<p>When it comes to choosing which client to use, first go for the one provided natively by the API. If there is no client for the API, think about the complexity and scope of your project. For simple, small-scope projects, use whatever NuGet <code>HttpClient</code> alternative you find the most convenient. But if the scope of a project is big and the calls are complex, use the native <code>HttpClient</code> offered by the framework.</p>
<p>In the next exercise, you will implement an example where using Refit will turn it into a complication. To fix that complication, you will use both <code>HttpClient</code> and RestSharp.</p>
<h2 id="_idParaDest-309"><a id="_idTextAnchor346"/>Exercise 8.03: A Strongly Typed HTTP Client for Testing Payments in a PayPal Sandbox</h2>
<p>A common scenario in programming is making payments. However, during the development stage, you don't want to use a real bank account and thus look for ways to process payments in a test environment—that is, a sandbox. In this exercise, you will learn how to call a payments sandbox API. You will use PayPal's sandbox API (<a href="https://developer.paypal.com/docs/api/orders/v2/">https://developer.paypal.com/docs/api/orders/v2/</a>) to create an order and get the order that you have created.</p>
<p>This exercise will use <code>Refit</code> for the client interface and the implementation resolution. It will also use <code>HttpClient</code> to provide a way of getting <code>auth</code> headers for Refit. Lastly, you will use RestSharp to get an access token from within <code>HttpClient</code>. Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">Go to <a href="https://www.paypal.com/tt/webapps/mpp/account-selection">https://www.paypal.com/tt/webapps/mpp/account-selection</a>.</li>
<li>Create a PayPal account (either personal or business).</li>
<li>Choose your location and click the <code>Get Started</code> button.</li>
<li>Provide your mobile number.</li>
<li>Click the <code>Next</code> button and enter the code.</li>
<li>Set up your profile by entering an email address and password.</li>
<li>Provide your address details.</li>
<li>Now link your credit or debit card. You can also do this for free by following the instructions given at <a href="https://www.paypal.com/tt/webapps/mpp/account-selection">https://www.paypal.com/tt/webapps/mpp/account-selection</a>.<p class="callout-heading">Note</p><p class="callout">Creating an account on PayPal is free. The linking of credit (or debit) card requirement is just a part of account creation, and it doesn't charge you. The payment gets refunded as soon as the authentication is confirmed.</p></li>
<li>Now log out of the account and go to <a href="https://developer.paypal.com/developer/accounts/">https://developer.paypal.com/developer/accounts/</a>.</li>
<li>Click the <code>Log in to Dashboard</code> button and proceed ahead:</li>
</ol>
<div><div><img alt="Figure 8.21: Log in to the PayPal dashboard to manage both sandbox and live environments " height="289" src="img/B16835_08_21.jpg" width="1116"/>
</div>
</div>
<p class="figure-caption">Figure 8.21: Log in to the PayPal dashboard to manage both sandbox and live environments</p>
<ol>
<li value="11">Then enter the requested credentials and proceed to the next screen.</li>
<li>Click the <code>Accounts</code> option under the <code>Sandbox</code> option. You will see two test accounts created for you:</li>
</ol>
<div><div><img alt="Figure 8.22: Sandbox PayPal accounts for testing " height="716" src="img/B16835_08_22.jpg" width="1026"/>
</div>
</div>
<p class="figure-caption">Figure 8.22: Sandbox PayPal accounts for testing</p>
<p>You will use these accounts to do testing in the next steps.</p>
<p class="callout-heading">Note</p>
<p class="callout">The PayPal sandbox is free.</p>
<ol>
<li value="13">Go to <a href="https://developer.paypal.com/developer/applications">https://developer.paypal.com/developer/applications</a> to get your client ID and secret. Just like the GitHub example, PayPal uses an OAuth app to provide you with a client ID and a secret.</li>
<li>For one of the default accounts, PayPal also generates a default OAuth app. So, click the <code>Sandbox</code> tab and select <code>Default Application</code>:</li>
</ol>
<div><div><img alt="Figure 8.23: OAuth app creation for PayPal " height="486" src="img/B16835_08_23.jpg" width="1342"/>
</div>
</div>
<p class="figure-caption">Figure 8.23: OAuth app creation for PayPal</p>
<ol>
<li value="15">In the new window, inspect both <code>Client ID</code> and <code>Secret</code>.</li>
<li>Take note of both and store them in environmental variables:</li>
</ol>
<div><div><img alt="Figure 8.24: Default application details displaying Client ID and Secret " height="808" src="img/B16835_08_24.jpg" width="1138"/>
</div>
</div>
<p class="figure-caption">Figure 8.24: Default application details displaying Client ID and Secret</p>
<ol>
<li value="17">Create properties for accessing the PayPal client ID and secret in a new empty class, <code>Exercise03.AuthHeaderHandler.cs</code>:<pre>public static string PayPalClientId { get; } = EnvironmentVariable.GetOrThrow("PayPalClientId");
public static string PayPalSecret { get; } = EnvironmentVariable.GetOrThrow("PayPalSecret");</pre></li>
</ol>
<p>Here, the <code>EnvironmentVariable.GetOrThrow</code> helper methods are used to get the user's environment variable or throw it if it doesn't exist. You will use these properties to make a connection to the sandbox PayPal API.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for environment variables at <a href="https://packt.link/y2MCy">https://packt.link/y2MCy</a>.</p>
<ol>
<li value="18">In the <code>Demo.cs</code> class, add a <code>const</code> variable for the <code>BaseAddress</code> of a PayPal sandbox:<pre>public const string BaseAddress = "https://api.sandbox.paypal.com/";</pre></li>
</ol>
<p><code>BaseAddress</code> will be used for initializing different clients (RestSharp and Refit) with the PayPal URL.</p>
<ol>
<li value="19">Use <code>Refit</code> to create a client with <code>CreateOrder</code> and <code>GetOrder</code> methods:<pre>public interface IPayPalClient
{
    [Post("/v2/checkout/orders")]
    public Task&lt;CreatedOrderResponse&gt; CreateOrder(Order order);
    [Get("/v2/checkout/orders/{id}")]
    public Task&lt;Order&gt; GetOrder(string id);
}</pre></li>
</ol>
<p>To get a sample request, refer to the documentation of the API that you want to call. Usually, they have an example request. In this case, the PayPal <code>CreateOrder</code> request can be found at <a href="https://developer.paypal.com/docs/api/orders/v2/">https://developer.paypal.com/docs/api/orders/v2/</a>:</p>
<pre>{
   "intent":"CAPTURE",
   "purchase_units":[
      {
         "amount":{
            "currency_code":"USD",
            "value":"100.00"
         }
      }
   ]
}</pre>
<div><div><img alt="Figure 8.25: PayPal CreateOrder example request with highlighted body " height="518" src="img/B16835_08_25.jpg" width="676"/>
</div>
</div>
<p class="figure-caption">Figure 8.25: PayPal CreateOrder example request with highlighted body</p>
<p>In <em class="italic">Figure 8.25</em>, <code>-d</code> is an argument and does not belong to the request body.</p>
<ol>
<li value="20">Use <a href="https://json2csharp.com/">https://json2csharp.com/</a> and generate C# classes out of the JSON. The corresponding C# classes will be generated for you.</li>
<li>Rename <code>RootObject</code> to <code>Order</code> and change all classes to the <code>record</code> type because it's a more suitable type for DTO:<pre>IPayPalClient.cs
public record Order
{
    public string intent { get; set; }
    public Purchase_Units[] purchase_units { get; set; }
}
public record Name
{
    public string name { get; set; }
}
public record Purchase_Units
{
    public Amount amount { get; set; }
    public Payee payee { get; set; }</pre></li>
</ol>
<pre>The complete code can be found here: <a href="https://packt.link/GvEZ8">https://packt.link/GvEZ8</a>.</pre>
<ol>
<li value="22">Using the same PayPal docs (<a href="https://developer.paypal.com/docs/api/orders/v2/">https://developer.paypal.com/docs/api/orders/v2/</a>), copy the example response:<pre>{
    "id": "7XS70547FW3652617",
    "intent": "CAPTURE",
    "status": "CREATED",
    "purchase_units": [
        {
            "reference_id": "default",
            "amount": {
                "currency_code": "USD",
                "value": "100.00"
            },
            "payee": {
                "email_address": "sb-emttb7510335@business.example.com",
                "merchant_id": "7LSF4RYZLRB96"
            }
        }
    ],
    "create_time": "2021-09-04T13:01:34Z",
    "links": [
        {
            "href": "https://api.sandbox.paypal.com/v2/checkout/orders/7XS70547FW3652617",
            "rel": "self",
            "method": "GET"
        }
     ]
}</pre></li>
<li>Use <a href="https://json2csharp.com/">https://json2csharp.com/</a> and generate C# classes out of the JSON. Here, you will get classes very similar to the ones from request JSON. The only difference is the response (simplified for brevity):<pre>public class CreateOrderResponse
{
    public string id { get; set; }
}</pre></li>
<li>Use <code>AuthHeaderHandler</code> to fetch an access token when you make a request and make sure it inherits <code>DelegatingHandler</code>:<pre>public class AuthHeaderHandler : DelegatingHandler
{</pre></li>
</ol>
<p>To make calls to PayPal, you will need an <code>auth</code> header with every request. The <code>auth</code> header value is retrieved from yet another endpoint. Refit cannot just add a header on a whim. You can, however, set up Refit using a custom <code>HttpClient</code> with a custom <code>HttpMessageHandler</code> that fetches an access token whenever you make a request. The <code>AuthHeaderHandler</code> is used for that reason.</p>
<p><code>DelegatingHandler</code> is a class that allows intercepting <code>HttpRequest</code> when it's being sent and doing something before or after it. In this case, before you send an HTTP request, you will fetch an <code>auth</code> header and add it to the request sent.</p>
<ol>
<li value="25">Now, override <code>SendRequest</code> by adding a bearer token to <code>AuthenticationHeader</code>:<pre>protected override async Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
{
                var accessToken = await GetAccessToken(CreateBasicAuthToken());
                request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", accessToken);
                return await base.SendAsync(request, cancellationToken).ConfigureAwait(false);
}</pre></li>
<li>To get an access token, you first need to get an OAuth token using basic <code>auth</code> (the client ID and secret):<pre> private static string CreateBasicAuthToken()
      {
                var credentials = Encoding.GetEncoding("ISO-8859-1").GetBytes(PayPalClientId + ":" + PayPalSecret);
                var authHeader = Convert.ToBase64String(credentials);
                return "Basic " + authHeader;
      }</pre></li>
<li>Getting an access token will require an <code>auth</code> token. Use the <code>RestSharp</code> client and add an <code>Authorization</code> header to the request.</li>
<li>Next, set <code>content-type</code> to <code>application/x-www-form-urlencoded</code> as per the PayPal API spec.</li>
<li>Add the body content <code>grant_type=client_credentials</code> as follows:<pre>            private static async Task&lt;string&gt; GetAccessToken(string authToken)
            {
                var request = new RestRequest("v1/oauth2/token");
                request.AddHeader("Authorization", authToken);
                request.AddHeader("content-type", "application/x-www-form-urlencoded");
                request.AddParameter("application/x-www-form-urlencoded", "grant_type=client_credentials", ParameterType.RequestBody);</pre></li>
<li>Execute the preceding request and return the response using the private nested class <code>Response</code> to simplify your work:<pre>                var response = await RestClient.ExecuteAsync&lt;Response&gt;(request, Method.POST);
                return response.Data.access_token;
            }
        private class Response
        {
            public string access_token { get; set; }
        }
      }</pre></li>
</ol>
<p>Why is the nested class needed? Here, the access token is nested within the response. It's not just a string that it returns, but rather an object. To parse it yourself from JSON would be a little complicated. However, you already know how to deserialize objects. So, even if it's just one property, deserializing still helps.</p>
<ol>
<li value="31">Now, create <code>RestClient</code> for the <code>GetAccessToken</code> method. Do so in the <code>AuthHandler</code> class:<pre>private static readonly RestClient RestClient = new RestClient(baseAddress);</pre></li>
<li>In the <code>Demo</code> class, create the method <code>Run</code>:<pre>public static async Task Run()
        	{</pre></li>
<li>Resolve a <code>Refit</code> client with a custom <code>AuthHeaderHandler</code> provider:<pre>            var authHandler = new AuthHeaderHandler {InnerHandler = new HttpClientHandler() };
            var payPalClient = RestService.For&lt;IPayPalClient&gt;(new HttpClient(authHandler)
                {
                    BaseAddress = new Uri(baseAddress)
                });</pre></li>
<li>Assuming that a payment was made by creating an <code>Order</code> object, run the following code:<pre>var order = new Order
            {
                intent = "CAPTURE",
                purchase_units = new[]
                {
                    new Purchase_Units
                    {
                        amount = new Amount
                        {
                            currency_code = "EUR", value = "100.00"
                        }
                    }
                }
            };</pre></li>
<li>Now, call PayPal API and create an order endpoint with the order you've just created.</li>
<li>Get the created order to see if it works and print the retrieved order payment information:<pre>var createOrderResponse = await payPalClient.CreateOrder(order);
var payment = await payPalClient.GetOrder(createOrderResponse.id);
var pay = payment.purchase_units.First();
Console.WriteLine($"{pay.payee.email_address} - " +
                              $"{pay.amount.value}" +
                              $"{pay.amount.currency_code}");</pre></li>
</ol>
<p>With the environment variables set correctly, you should see the following output:</p>
<pre>sb-emttb7510335@business.example.com - 100.00EUR</pre>
<p>As mentioned earlier, this is a sandbox API. However, a switch to a live environment with real money would just be a matter of setting up new PayPal accounts in that environment and calling a different endpoint: <a href="https://api-m.paypal.com">https://api-m.paypal.com</a>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You won't be able to access <a href="https://api-m.paypal.com">https://api-m.paypal.com</a> because it is for production PayPal use and is paid. However, that should be the only change in code (a different base URI) when you are ready to move on to real integration with PayPal.</p>
<p>Please make sure you have the environment variables set and are using your own client and secret. Otherwise, some unhandled exception errors may be displayed.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/cFRq6">https://packt.link/cFRq6</a>.</p>
<p>You now know how to do simple CRUD operations with Web APIs. However, you have only worked with text so far. So, will calling an API with an image be any different? Find that out in the next activity.</p>
<h2 id="_idParaDest-310"><a id="_idTextAnchor348"/>Activity 8.04: Using an Azure Blob Storage Client to Upload and Download Files</h2>
<p>Azure Blob Storage is a cloud service on Azure for storing different files (logs, images, music, and whole drives). Before you can use any Azure Storage services, you will need a storage account. Blobs are just files, but they cannot be directly stored within an account; instead, they need a container.</p>
<p>An Azure Storage Container is like a directory where other files are stored. However, unlike a directory, a container cannot contain other containers. Use an Azure Storage Account to create two containers, upload an image and a text file, and then download the uploaded files locally. All this will be done in your own client, which wraps around the Azure Blob storage client.</p>
<p>The aim of this activity is to familiarize yourself with working on files through cloud storage while putting all that you have learned so far to the test. Perform the following steps to complete this activity:</p>
<ol>
<li value="1">Navigate to <code>Azure Storage Accounts</code>.</li>
<li>Create a new Azure Storage Account.</li>
<li>Store a blob storage access key in environmental variables with the name <code>BlobStorageKey</code>.</li>
<li>Install the <code>Azure Blob Storage</code> client.</li>
<li>Create the <code>FilesClient</code> class for storing fields for blobs client and default container client (where blobs will be stored by default).</li>
<li>Create a constructor to initialize the two clients (to support access to different containers).</li>
<li>Add a method to create a container or get an existing one if it already exists.</li>
<li>Create a method to upload a file to a specific container.</li>
<li>Create a method to download a file from a specific container.</li>
<li>Create a <code>Demo</code> class with paths to download and upload directories.</li>
<li>Add test data, namely the two files—that is, an image and a text file (<em class="italic">Figure 8.26</em>, <em class="italic">Figure 8.27</em>, and <em class="italic">Figure 8.28</em>):</li>
</ol>
<div><div><img alt="Figure 8.26: Two Azure Storage containers, exercise04 and exercise04b,  in your storage account " height="770" src="img/B16835_08_26.jpg" width="1257"/>
</div>
</div>
<p class="figure-caption">Figure 8.26: Two Azure Storage containers, exercise04 and exercise04b, in your storage account</p>
<p>Text file:</p>
<div><div><img alt="Figure 8.27: Test1.txt file uploaded in exercise04 container " height="564" src="img/B16835_08_27.jpg" width="1152"/>
</div>
</div>
<p class="figure-caption">Figure 8.27: Test1.txt file uploaded in exercise04 container</p>
<p>Image file:</p>
<div><div><img alt="Figure 8.28: Morning.jpg file uploaded in exercise04b container " height="569" src="img/B16835_08_28.jpg" width="1163"/>
</div>
</div>
<p class="figure-caption">Figure 8.28: Morning.jpg file uploaded in exercise04b container</p>
<ol>
<li value="12">Create the method <code>Run</code> to upload a text file and then download it locally.</li>
<li>Run the code. If you did everything correctly, you should see the following output with both files downloaded locally:</li>
</ol>
<div><div><img alt="Figure 8.29: Morning.jpg and Test1.txt files downloaded from the two containers  after the demo code execution " height="327" src="img/B16835_08_29.jpg" width="1213"/>
</div>
</div>
<p class="figure-caption">Figure 8.29: Morning.jpg and Test1.txt files downloaded from the two containers after the demo code execution</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found at <a href="https://packt.link/qclbF">https://packt.link/qclbF</a>.</p>
<p>It is near impossible to create a perfect client that is suitable for everyone. Therefore, even when there is a solution for some problem given to you, you will often still need to further abstract it away, adapting it to solve exactly the problem you have. The problem you had was in uploading and downloading a file from and to a specific folder. To solve the problem, you abstracted away layers of clients exposing just two functions—one for uploading a file and another for downloading a file.</p>
<h1 id="_idParaDest-311"><a id="_idTextAnchor349"/>Summary</h1>
<p>No matter the kind of programmer you are, there will be many scenarios in which you will have to consume a web service. There are different kinds of services online, but the most common type is RESTful. REST is just a set of guidelines and should therefore not be mixed up with HTTP. REST APIs are simple, self-documented, well-structured, and are currently a golden standard of Web APIs. However, in most cases in the context of RESTful APIs, a request is sent over HTTP and your message contains JSON.</p>
<p>The main tool for making HTTP calls using C# is <code>HttpClient</code>, however, before you try to implement HTTP calls yourself, you should look for a NuGet package of the Web API you're trying to consume. Azure Blob storage, Azure Text Analytics, PayPal, and GitHub are just a few examples of Web APIs.</p>
<p>In this chapter, you learned about a lot of functionality on the web that is done for you. It's not hard to consume; all you need to know now is how to communicate with the third-party RESTful Web APIs. In the next chapter, you will learn how to create your own RESTful web services using the ASP.NET Core Web API template as well as being introduced to Azure Functions and the special tools Swagger and NuGet.</p>
</div>
<div><div></div>
</div>
</div>
</body></html>