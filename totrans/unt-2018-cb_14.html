<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Design Patterns</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover:</p>
<ul>
<li>State-driven behavior DIY states</li>
<li>State-driven behavior State Design Pattern classes</li>
<li>State-driven behavior with Unity Scriptable Objects</li>
<li>Publisher-Subscriber pattern C# delegates and events</li>
<li>Model-View-Controller (MVC) pattern</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In computer programming in general, some types of features and requirements occur commonly. For computer game programming, there are often features for new games that have things in common with existing games. Software <strong>D<span class="KeyWordPACKT">esign Patterns</span></strong> are reusable, computer-language-independent templates for how to solve common problems.</p>
<p>Not all design patterns are needed for all languages (for example, some computer languages may have features that already provide an easy way to solve a common problem). In this chapter, we'll explore several common design patterns in the context of Unity game programming in the C# programming language.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The big picture</h1>
                </header>
            
            <article>
                
<p>There is no need to reinvent the wheel, and there are many advantages for game programmers to adopt tried-and-tested approaches to solving common features for game projects. Design patterns have been designed by experience, and refined to encourage good programming practice and well-designed architectural software solutions. A common theme in design patterns is the independence of code components, and clearly-defined interfaces for when components do need to know about each other and the protocols for their interactions.</p>
<p>In this chapter, the recipes focus on three main design patterns, all of which are well known and found not only in game software designs but in the design of many interactive software systems, such as web applications and mobile phone programming. The design patterns explored in this chapter are:</p>
<ul>
<li><strong>The <span class="KeyWordPACKT">State</span> pattern</strong>: States and their transitions</li>
<li><strong>The <span class="KeyWordPACKT">Publisher-Subscriber</span> pattern</strong>: Observers subscribing to event-publishing objects</li>
<li><strong>The <span class="KeyWordPACKT">Model-View-Controller</span> (MCV) pattern</strong>: Separating internal workings from UI components and display representations</li>
</ul>
<p>In this chapter, examples are presented in generic object-oriented designs, also there are C#-specific features (such as <strong><span class="KeyWordPACKT">delegates</span></strong> and <strong><span class="KeyWordPACKT">events</span></strong>), and some Unity-specific features (such as <strong>s<span class="KeyWordPACKT">criptable objects</span></strong>). While generic approaches have the advantage that programmers from other languages or domains will be instantly familiar with their Unity game implementations, the most significant game memory-speed improvements are found through exploiting language- and engine-specific features.</p>
<p>C# <strong>D<span class="KeyWordPACKT">elegate</span></strong> variables are like a container for a function (or collection of functions) that can be passed around and invoked. They have values assigned to them and can be changed at <span class="KeyWordPACKT">runtime</span>. <strong><span class="KeyWordPACKT">Delegates</span></strong> can multicast through the use of the <kbd><span class="ScreenTextPACKT">+=</span></kbd> operator, multiple methods can be assigned a single delegate, and all will be invoked when the delegate is invoked. C# <strong>e<span class="KeyWordPACKT">vents</span></strong> are a special, more secure kind of delegate. By defining public static event variables, we restrict other script classes to only be allowed to:</p>
<ul>
<li>Subscribe one of their methods</li>
<li>Unsubscribe one of their methods</li>
</ul>
<p>Events ensure a good separation of our code logic, and mean that the script class publishing events does not need to know anything about, or how many, other script classes are subscribing to published events.</p>
<p>Here are some sources where you can learn more about <strong>D<span class="KeyWordPACKT">esign Patterns</span></strong> and Unity:</p>
<ul>
<li>The Unity tutorial about <strong><span class="KeyWordPACKT">Scriptable Objects</span></strong> for enemy state-driven AI: <a href="https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern"><span class="URLPACKT">https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern</span></a></li>
<li>The Unity tutorial about <strong><span class="KeyWordPACKT">delegates</span></strong> and <strong><span class="KeyWordPACKT">events</span></strong>:
<ul>
<li><a href="https://unity3d.com/learn/tutorials/topics/scripting/delegates?playlist=17117"><span class="URLPACKT">https://unity3d.com/learn/tutorials/topics/scripting/delegates?playlist=17117</span></a></li>
<li><a href="https://unity3d.com/learn/tutorials/topics/scripting/events"><span class="URLPACKT">https://unity3d.com/learn/tutorials/topics/scripting/events</span></a></li>
</ul>
</li>
<li>Prime[31]'s video about Unity delegates and events (from 2011, but still a nice introduction): <a href="http://www.youtube.com/watch?v=N2zdwKIsXJs"><span class="URLPACKT">http://www.youtube.com/watch?v=N2zdwKIsXJs</span></a></li>
<li>Eric Nordeus' tutorial on Unity and <strong><span class="KeyWordPACKT">Design Patterns</span></strong>: <a href="http://www.habrador.com/tutorials/programming-patterns/"><span class="URLPACKT">http://www.habrador.com/tutorials/programming-patterns/</span></a></li>
<li>Unity <strong><span class="KeyWordPACKT">Model-View-Controller</span></strong> tutorials:
<ul>
<li>Gameasutra: <a href="https://www.gamasutra.com/blogs/TabeaIseli/20160926/282062/MVC_in_Unity.php"><span class="URLPACKT">https://www.gamasutra.com/blogs/TabeaIseli/20160926/282062/MVC_in_Unity.php</span></a></li>
<li>Eduardo Dias Da Costa: <a href="https://www.toptal.com/unity-unity3d/unity-with-mvc-how-to-level-up-your-game-development"><span class="URLPACKT">https://www.toptal.com/unity-unity3d/unity-with-mvc-how-to-level-up-your-game-development</span></a></li>
<li>Jackson Dunstan: <a href="https://jacksondunstan.com/articles/3092"><span class="URLPACKT">https://jacksondunstan.com/articles/3092</span></a></li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">State-driven behavior DIY states</h1>
                </header>
            
            <article>
                
<p>Games as a whole, and individual objects or characters, can often be thought of (or modeled as) passing through different states or modes. Modeling states and changes of state (due to events or game conditions) is a very common way to manage the complexity of games and game components. In this recipe, we create a simple three-state game (game playing/game won/game lost) using a <kbd>GameManager</kbd> class. Buttons and a timer are provided to simulate the events that would allow a player to win or lose the game:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/db3d658f-f2bb-45a7-b80a-21f607df37ec.png" style="width:25.75em;height:7.58em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To use states to manage object behavior, follow these steps:</p>
<ol>
<li>Create two <span class="KeyWordPACKT">UI Buttons</span> at the top-middle of the screen. Name one <kbd><span class="ScreenTextPACKT">Button-win</span></kbd> and edit its text to read <kbd><span class="ScreenTextPACKT">Win Game</span></kbd>. Name the second <kbd><span class="ScreenTextPACKT">Button-lose</span></kbd> and edit its text to read <span class="ScreenTextPACKT"><kbd>Lose Game</kbd>.</span></li>
<li>Create a <span class="KeyWordPACKT">UI Text</span> object at the top left of the screen. Name this <kbd><span class="ScreenTextPACKT">Text-state-messages</span></kbd>, and set its <span class="packt_screen">Rect Transform</span> height property to <kbd>300</kbd> and its <span class="ScreenTextPACKT"><span class="packt_screen">Text (Script) Paragraph Vertical Overflow</span></span> property to <kbd><span class="ScreenTextPACKT">Overflow</span></kbd>.</li>
<li>Create a new C# script class,&amp;nbsp;<kbd><span class="CodeInTextPACKT">GameStates.cs</span></kbd>:</li>
</ol>
<pre style="padding-left: 30px">    public class GameStates<br/>     {<br/>         public enum GameStateType<br/>         {<br/>             GamePlaying,<br/>             GameWon,<br/>             GameLost,<br/>         }<br/>     } </pre>
<ol start="4">
<li>Create the&amp;nbsp;<span class="CodeInTextPACKT"><kbd>MyGameManager.cs</kbd>&amp;nbsp;</span>C# script class, and add an instance object as a component to the <span class="ScreenTextPACKT"><span class="packt_screen">Main Camera</span></span>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/>     using System;<br/>     using UnityEngine.UI;<br/> <br/>     public class MyGameManager : MonoBehaviour<br/>     {<br/>         public Text textStateMessages;<br/>         public Button buttonWinGame;<br/>         public Button buttonLoseGame;<br/> <br/>         private GameStates.GameStateType currentState;<br/>         private float timeGamePlayingStarted;<br/>         private float timeToPressAButton = 5;<br/> <br/>         void Start()<br/>         {<br/>              currentState = GameStates.GameStateType.GamePlaying;<br/>         }<br/> <br/>         //--------- Update[ S ] - state specific actions<br/>         void Update()<br/>         {<br/>             switch (currentState)<br/>             {<br/>                 case GameStates.GameStateType.GamePlaying:<br/>                     UpdateStateGamePlaying();<br/>                     break;<br/>                 case GameStates.GameStateType.GameWon:<br/>                     // do nothing<br/>                     break;<br/>                 case GameStates.GameStateType.GameLost:<br/>                     // do nothing<br/>                     break;<br/>             }<br/>         }<br/> <br/>         public void NewGameState(GameStates.GameStateType newState)<br/>         {<br/>             // (1) state EXIT actions<br/>             OnMyStateExit(currentState);<br/> <br/>             // (2) change current state<br/>             currentState = newState;<br/> <br/>             // (3) state ENTER actions<br/>             OnMyStateEnter(currentState);<br/> <br/>             PostMessageDivider();<br/>         }<br/> <br/>         public void PostMessageDivider()<br/>         {<br/>             string newLine = "\n";<br/>             string divider = "--------------------------------";<br/>             textStateMessages.text += newLine + divider;<br/>         }<br/> <br/>         public void PostMessage(string message)<br/>         {<br/>             string newLine = "\n";<br/>             string timeTo2DecimalPlaces =<br/>     String.Format("{0:0.00}", Time.time);<br/>             textStateMessages.text += newLine +<br/>     timeTo2DecimalPlaces + " :: " + message;<br/>         }<br/> <br/>         private void DestroyButtons()<br/>         {<br/>             Destroy(buttonWinGame.gameObject);<br/>             Destroy(buttonLoseGame.gameObject);<br/>         }<br/> <br/>         //--------- OnMyStateEnter[ S ] - state specific actions<br/>         private void OnMyStateEnter(GameStates.GameStateType state)<br/>         {<br/>             string enterMessage = "ENTER state: " +<br/>             state.ToString();<br/>             PostMessage(enterMessage);<br/> <br/>             switch (state)<br/>             {<br/>                 case GameStates.GameStateType.GamePlaying:<br/>                     OnMyStateEnterGamePlaying();<br/>                     break;<br/>                 case GameStates.GameStateType.GameWon:<br/>                     // do nothing<br/>                     break;<br/>                 case GameStates.GameStateType.GameLost:<br/>                     // do nothing<br/>                     break;<br/>             }<br/>         }<br/> <br/>         private void OnMyStateEnterGamePlaying()<br/>         {<br/>             // record time we enter state<br/>             timeGamePlayingStarted = Time.time;<br/>         }<br/> <br/>         //--------- OnMyStateExit[ S ] - state specific actions<br/>         private void OnMyStateExit(GameStates.GameStateType state)<br/>         {<br/>             string exitMessage = "EXIT state: " + state.ToString();<br/>             PostMessage(exitMessage);<br/> <br/>             switch (state)<br/>             {<br/>                 case GameStates.GameStateType.GamePlaying:<br/>                     OnMyStateExitGamePlaying();<br/>                     break;<br/>                 case GameStates.GameStateType.GameWon:<br/>                     // do nothing<br/>                     break;<br/>                 case GameStates.GameStateType.GameLost:<br/>                     // do nothing<br/>                     break;<br/>             }<br/>         }<br/> <br/>         private void OnMyStateExitGamePlaying()<br/>         {<br/>             // if leaving gamePlaying state then destroy the 2 buttons<br/>             DestroyButtons();<br/>         }<br/> <br/> <br/>         private void UpdateStateGamePlaying()<br/>         {<br/>             float timeSinceGamePlayingStarted =<br/>             Time.time - timeGamePlayingStarted;<br/>             if (timeSinceGamePlayingStarted &gt; timeToPressAButton)<br/>             {<br/>                 string message = "User waited too long - automatically   <br/>                 going to Game LOST state";<br/>                   PostMessage(message);<br/>                 NewGameState(GameStates.GameStateType.GameLost);<br/>             }<br/>         }<br/>     } </pre>
<ol start="5">
<li>Create the&amp;nbsp;<span class="CodeInTextPACKT"><kbd>ButtonActions.cs</kbd>&amp;nbsp;</span>C# script class, and add an instance object as a component to the <span class="ScreenTextPACKT"><span class="packt_screen">Main Camera</span></span>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class ButtonActions : MonoBehaviour<br/>     {<br/>         private MyGameManager myGameManager;<br/> <br/>         private void Start()<br/>         {<br/>             myGameManager = GetComponent&lt;MyGameManager&gt;();<br/>         }<br/> <br/>         public void BUTTON_CLICK_ACTION_WIN_GAME()<br/>         {<br/>             string message = "Win Game BUTTON clicked";<br/>             myGameManager.PostMessage(message);<br/>             myGameManager.NewGameState<br/>             (GameStates.GameStateType.GameWon);<br/>         }<br/> <br/>         public void BUTTON_CLICK_ACTION_LOSE_GAME()<br/>         {<br/>             string message = "Lose Game BUTTON clicked";<br/>             myGameManager.PostMessage(message);<br/>             myGameManager.NewGameState<br/>             (GameStates.GameStateType.GameLost);<br/>         }<br/> <br/>     } </pre>
<ol start="6">
<li>In the <span class="packt_screen">Hierar<span class="KeyWordPACKT">chy</span></span>, select the <span class="ScreenTextPACKT"><span class="packt_screen">Button-win</span></span> button, and for its <span class="ScreenTextPACKT"><span class="packt_screen">Button (Script)</span></span> component, add an <span class="ScreenTextPACKT"><span class="packt_screen">OnClick</span></span> action to call the <kbd>BUTTON_CLICK_ACTION_WIN_GAME()</kbd> method from the <span class="ScreenTextPACKT"><span class="packt_screen">ButtonsActions</span></span> component in the <span class="ScreenTextPACKT"><span class="packt_screen">Main Camera</span></span> GameObject.</li>
<li>In the <span class="KeyWordPACKT"><span class="packt_screen">Hierarchy</span></span>, select the <span class="ScreenTextPACKT"><span class="packt_screen">Button-lose</span></span> button, and for its <span class="ScreenTextPACKT"><span class="packt_screen">Button (Script)</span></span> component, add an <span class="ScreenTextPACKT"><span class="packt_screen">OnClick</span></span> action to call the <kbd><span class="ScreenTextPACKT">BUTTON_CLICK_ACTION_LOSE_GAME()</span></kbd> method from the <span class="ScreenTextPACKT"><span class="packt_screen">ButtonActions</span></span> component in the <span class="ScreenTextPACKT"><span class="packt_screen">Main Camera</span></span> GameObject.</li>
<li>In the <span class="KeyWordPACKT"><span class="packt_screen">Hierarchy</span></span>, select the <span class="ScreenTextPACKT"><span class="packt_screen">Main Camera</span></span> GameObject. Drag this GameObject into the <span class="KeyWordPACKT"><span class="packt_screen">Inspector</span></span> to ensure that all three <span class="ScreenTextPACKT"><span class="packt_screen">GameManager (Script)</span></span> public variables (<span class="ScreenTextPACKT"><span class="packt_screen">Text State Messages</span></span>, <span class="ScreenTextPACKT"><span class="packt_screen">Button Win Game</span></span>, and <span class="ScreenTextPACKT"><span class="packt_screen">Button Lose Game</span>)</span>&amp;nbsp;have the corresponding <span class="KeyWordPACKT">Canvas</span> GameObjects dragged into them (the two buttons and the <span class="KeyWordPACKT">UI Text</span> GameObject).</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As can be seen in the following state chart figure, this recipe models a simple game, which starts in the <kbd><span class="CodeInTextPACKT">GamePlaying</span></kbd> state; then, depending on the button clicked by the user, the game moves either into the <kbd><span class="CodeInTextPACKT">GameWon</span></kbd> state or the <kbd><span class="CodeInTextPACKT">GameLost</span></kbd> state. Also, if the user waits too long (five seconds) to click on a button, the game moves into the <kbd><span class="CodeInTextPACKT">GameLost</span></kbd> state.</p>
<p>The possible states of the system are defined using the enumerated&amp;nbsp;<kbd><span class="ScreenTextPACKT">GameStateType</span></kbd>&amp;nbsp;type in the&amp;nbsp;<span class="CodeInTextPACKT"><kbd>GameStates</kbd> class</span>, and the current state of the system at any point in time is stored in the&amp;nbsp;<span class="CodeInTextPACKT"><kbd>currentState</kbd> variable of GameManager:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/618d0afd-9a1a-42b7-878d-22f91b072349.png" style="width:22.17em;height:10.83em;"/></div>
<p>The initial state,&amp;nbsp;<kbd><span class="CodeInTextPACKT">GamePlaying</span></kbd>, is set in the <kbd><span class="CodeInTextPACKT">Start()</span></kbd> method of <kbd><span class="CodeInTextPACKT">MyGameManager</span></kbd>.</p>
<div class="packt_infobox"><kbd><span class="CodeInTextPACKT">GameManager</span></kbd> seems to now be a special asset name in Unity, for that reason, we have named our game manager script classes <kbd><span class="CodeInTextPACKT">MyGameManager</span></kbd> to avoid any issues.</div>
<p>When the <kbd><span class="CodeInTextPACKT">MyGameManager</span></kbd> object receives messages (for example, every frame for <kbd><span class="CodeInTextPACKT">Update()</span></kbd>), its behavior must be appropriate for the current state. So, we see a <kbd>Switch</kbd> statement in the&amp;nbsp;<span class="CodeInTextPACKT"><kbd>Update()</kbd> method</span>&amp;nbsp;that calls state-specific methods. For example, if the current state is <kbd>GamePlaying</kbd>, when an <kbd><span class="CodeInTextPACKT">Update()</span></kbd> message is received, the <kbd>UpdateStateGamePl<span class="CodeInTextPACKT">aying()</span></kbd> method will be called.</p>
<p>The <kbd><span class="CodeInTextPACKT">NewGameState(...)</span></kbd> method first calls the <kbd><span class="CodeInTextPACKT">OnMyStateExit(...)</span></kbd> method with the current state, since there may be actions to be performed when a particular state is exited; for example, when the <kbd><span class="CodeInTextPACKT">GamePlaying</span></kbd> state is exited, it destroys the two buttons. Next, the <kbd><span class="CodeInTextPACKT">NewGameState(...)</span></kbd> method sets the <kbd><span class="CodeInTextPACKT">currentState</span></kbd> variable to be assigned the new state. Next, the <kbd><span class="CodeInTextPACKT">OnMyStateEnter(...)</span></kbd> method is called, since there may be actions to be performed immediately when a new state is entered. Finally, a message divider is posted to the <span class="KeyWordPACKT">UI Text</span> box, with a call to the <kbd><span class="CodeInTextPACKT">PostMessageDivider()</span></kbd> method.</p>
<p>The <kbd><span class="CodeInTextPACKT">BUTTON_CLICK_ACTION_WIN_GAME()</span></kbd> and <kbd><span class="CodeInTextPACKT">BUTTON_CLICK_ACTION_LOSE_GAME()</span></kbd> methods are executed if their corresponding buttons have been clicked. They move the game into the corresponding <kbd><span class="CodeInTextPACKT">GameWon</span></kbd> or <kbd><span class="CodeInTextPACKT">GameLost</span></kbd> state.</p>
<p>Logic has been written in the <kbd><span class="CodeInTextPACKT">UpdateStateGamePlaying()</span></kbd> method, so once&amp;nbsp;<kbd><span class="CodeInTextPACKT">MyGameManager</span></kbd> has been in the <kbd><span class="CodeInTextPACKT">GamePlaying</span></kbd> state for more than a certain time (defined in the&amp;nbsp;<span class="CodeInTextPACKT"><kbd>timeToPressAButton</kbd> variable</span>), the game will automatically change into the <kbd><span class="CodeInTextPACKT">GameLost</span></kbd> state.</p>
<p>So, for each state, we may need to write methods for state exit, state entry, and update events, and also a main method for each event with a Switch statement to determine which state method should be called (or not). As can be imagined, the size of our methods and the number of methods in our <kbd><span class="CodeInTextPACKT">MyGameManager</span></kbd> class will grow significantly as more states and a more complex game logic are needed for non-trivial games.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The next recipe takes a more sophisticated approach to state-driven games, where each state has its own class. The next recipe in this chapter illustrates how to manage the complexity of states with class inheritance and the <span class="KeyWordPACKT">State Design Pattern</span>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">State-driven behavior using the State Design Pattern</h1>
                </header>
            
            <article>
                
<p>The previous pattern illustrated not only the usefulness of modeling game states, but also how a game manager class can grow in size and become unmanageable. To manage the complexity of many states and complex behaviors of states, the <span class="KeyWordPACKT">State pattern</span> has been proposed in the software-development community. <span class="KeyWordPACKT">Design patterns</span> are general-purpose software component architectures that have been tried and tested and found to be good solutions to commonly-occurring software-system features. The key features of the <span class="KeyWordPACKT">State pattern</span> are that each state is modeled by its own class and that all states inherit (are subclassed) from a single parent state class. The states need to know about each other in order to tell the game manager to change the current state. This is a small price to pay for the division of the complexity of the overall game behavior into separate state classes.</p>
<p>Note: Many thanks to the contribution from Bryan Griffiths, which has helped improve this recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe builds upon the previous recipe. So, make a copy of that project, open it, and then follow the steps for this recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To manage an object's behavior using the <span class="KeyWordPACKT">State pattern</span> architecture, perform the following steps:</p>
<ol>
<li>Create a new C# script class called <kbd><span class="CodeInTextPACKT">GameState</span></kbd>:</li>
</ol>
<pre style="padding-left: 30px">    public class GameState<br/>     {<br/>         public enum EventType<br/>         {<br/>             ButtonWinGame,<br/>             ButtonLoseGame<br/>         }<br/> <br/>         protected MyGameManager gameManager;<br/>         public GameState(MyGameManager manager)<br/>         {<br/>             gameManager = manager;<br/>         }<br/> <br/>         public virtual void OnMyStateEntered() {}<br/>         public virtual void OnMyStateExit() {}<br/>         public virtual void StateUpdate() {}<br/>         public virtual void OnEventReceived(EventType eventType) {}<br/>     } </pre>
<ol start="2">
<li>Create a new C# script class called <kbd><span class="CodeInTextPACKT">StateGamePlaying</span></kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class StateGamePlaying : GameState<br/>     {<br/>         public StateGamePlaying(MyGameManager manager) : <br/>         base(manager) { }<br/> <br/>         public override void OnMyStateEntered()<br/>         {<br/>             string stateEnteredMessage = "ENTER state: <br/>             StateGamePlaying";<br/>             gameManager.DisplayStateEnteredMessage<br/>             (stateEnteredMessage);<br/>             Debug.Log(stateEnteredMessage);<br/>         }<br/> <br/>         public override void OnEventReceived(EventType eventType)<br/>         {<br/>             switch(eventType){<br/>                 case (EventType.ButtonWinGame):<br/>                     gameManager.NewGameState(gameManager.stateGameWon);<br/>                     break;<br/>                 case (EventType.ButtonLoseGame):<br/>                 case (EventType.TimerFinished):<br/>                     gameManager.NewGameState<br/>                     (gameManager.stateGameLost);<br/>                     break;<br/>             }<br/>         }<br/>     } </pre>
<ol start="3">
<li>Create a new C# script class called <kbd><span class="CodeInTextPACKT">StateGameWon</span></kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class StateGameWon : GameState<br/>     {<br/>         public StateGameWon(MyGameManager manager) : base(manager) { }<br/> <br/>         public override void OnMyStateEntered()<br/>         {<br/>             string stateEnteredMessage = "ENTER state: StateGameWon";<br/>             gameManager.DisplayStateEnteredMessage<br/>             (stateEnteredMessage);<br/>             Debug.Log(stateEnteredMessage);<br/>         }<br/>     } </pre>
<ol start="4">
<li>Create a new C# script class called <kbd><span class="CodeInTextPACKT">StateGameLost</span></kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class StateGameLost : GameState<br/>     {<br/>         public StateGameLost(MyGameManager manager) : base(manager) { }<br/> <br/>         public override void OnMyStateEntered()<br/>         {<br/>             string stateEnteredMessage = "ENTER state: StateGameLost";<br/>             gameManager.DisplayStateEnteredMessage<br/>             (stateEnteredMessage);<br/>             Debug.Log(stateEnteredMessage);<br/>         }<br/>     } </pre>
<ol start="5">
<li>Replace the contents of the&amp;nbsp;<kbd><span class="CodeInTextPACKT">MyGameManager</span></kbd>&amp;nbsp;C# script class with the following:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/>     using UnityEngine.UI;<br/> <br/>     public class MyGameManager : MonoBehaviour<br/>     {<br/>         public Text textGameStateName;<br/>         public Button buttonWinGame;<br/>         public Button buttonLoseGame;<br/> <br/>         [HideInInspector]<br/>         public StateGamePlaying stateGamePlaying;<br/> <br/>         [HideInInspector]<br/>         public StateGameWon stateGameWon;<br/> <br/>         [HideInInspector]<br/>         public StateGameLost stateGameLost;<br/> <br/>         private GameState currentState;<br/> <br/>         private void Awake()<br/>         {<br/>             stateGamePlaying = new StateGamePlaying(this);<br/>             stateGameWon = new StateGameWon(this);<br/>             stateGameLost = new StateGameLost(this);<br/>         }<br/> <br/>         private void Start()<br/>         {<br/>             NewGameState(stateGamePlaying);<br/>         }<br/> <br/>         private void Update()<br/>         {<br/>             if (currentState != null)<br/>                 currentState.StateUpdate();<br/>         }<br/> <br/>         public void NewGameState(GameState newState)<br/>         {<br/>             if (null != currentState)<br/>                 currentState.OnMyStateExit();<br/> <br/>             currentState = newState;<br/>             currentState.OnMyStateEntered();<br/>         }<br/> <br/>         public void DisplayStateEnteredMessage(string  <br/>         stateEnteredMessage)<br/>         {<br/>             textGameStateName.text = stateEnteredMessage;<br/>         }<br/> <br/>         public void PublishEventToCurrentState(GameState.EventType <br/>         eventType)<br/>         {<br/>             currentState.OnEventReceived(eventType);<br/>             DestroyButtons();<br/>         }<br/> <br/>         private void DestroyButtons()<br/>         {<br/>             Destroy(buttonWinGame.gameObject);<br/>             Destroy(buttonLoseGame.gameObject);<br/>         }<br/>     } </pre>
<ol start="6">
<li>In the <span class="packt_screen">Hier<span class="KeyWordPACKT">archy</span></span>, select the <span class="ScreenTextPACKT"><span class="packt_screen">Button-win</span></span> button, and for its <span class="ScreenTextPACKT"><span class="packt_screen">Button (Script)</span></span> component, add an <span class="ScreenTextPACKT"><span class="packt_screen">OnClick</span></span> action to call the <kbd><span class="ScreenTextPACKT">BUTTON_CLICK_ACTION_WIN_GAME()</span></kbd> method from the <span class="packt_screen">GameManager</span> component in the <span class="ScreenTextPACKT"><span class="packt_screen">Main Camera</span></span> GameObject.</li>
<li>In the <span class="KeyWordPACKT"><span class="packt_screen">Hierarchy</span></span>, select the <span class="ScreenTextPACKT"><span class="packt_screen">Button-lose</span></span> button, and for its <span class="ScreenTextPACKT"><span class="packt_screen">Button (Script)</span></span> component, add an <span class="ScreenTextPACKT"><span class="packt_screen">OnClick</span></span> action to call the <kbd><span class="ScreenTextPACKT">BUTTON_CLICK_ACTION_LOSE_GAME()</span></kbd> method from the <span class="packt_screen">GameManager</span> component in the <span class="ScreenTextPACKT"><span class="packt_screen">Main Camera</span></span> GameObject.</li>
<li>In the <span class="KeyWordPACKT"><span class="packt_screen">Hierarchy</span></span>, select the <span class="ScreenTextPACKT"><span class="packt_screen">Main Camera</span></span> GameObject. Drag&amp;nbsp;it into the <span class="packt_screen">Inspector</span> to ensure that all three <span class="ScreenTextPACKT"><span class="packt_screen">GameManager (Script)</span></span> public variables (<span class="ScreenTextPACKT"><span class="packt_screen">Text State Messages</span></span>, <span class="ScreenTextPACKT"><span class="packt_screen">Button Win Game</span></span>, and <span class="ScreenTextPACKT"><span class="packt_screen">Button Lose Game</span>)</span>&amp;nbsp;have the corresponding <span class="KeyWordPACKT">Canvas</span> GameObjects dragged into them (the two buttons and the <strong><span class="KeyWordPACKT">UI Text</span></strong> GameObject).</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The scene is very straightforward for this recipe. There is the single <span class="ScreenTextPACKT"><span class="packt_screen">Main Camera</span></span> GameObject that has the <kbd><span class="CodeInTextPACKT">MyGameManager</span></kbd> script object component attached to it.</p>
<p>A C# scripted class is defined for each state that the game needs to manage—for this example,&amp;nbsp;<kbd><span class="CodeInTextPACKT">StateGamePlaying</span></kbd>, <kbd><span class="CodeInTextPACKT">StateGameWon</span></kbd>, and <kbd><span class="CodeInTextPACKT">StateGameLost</span></kbd>. Each of these state classes is a subclass of <kbd><span class="CodeInTextPACKT">GameState</span></kbd>. <kbd><span class="CodeInTextPACKT">GameState</span></kbd> defines properties  and methods that all subclass states will possess:</p>
<ul>
<li>An enumerated type <kbd><span class="CodeInTextPACKT">EventType</span></kbd>, which defines the two possible button click events that the game might generate: <kbd><span class="CodeInTextPACKT">ButtonWinGame</span></kbd> and <kbd><span class="CodeInTextPACKT">ButtonLoseGame</span></kbd>.</li>
<li>The <kbd><span class="CodeInTextPACKT">gameManager</span></kbd> variable so that each state object has a link to the game manager.</li>
<li>The constructor method that accepts a reference to <span class="CodeInTextPACKT"><kbd>MyGameManager</kbd>, which</span>&amp;nbsp;automatically makes the <kbd><span class="CodeInTextPACKT">gameManager</span></kbd> variable refer to the passed-in <kbd><span class="CodeInTextPACKT">MyGameManager</span></kbd> object.</li>
<li>The four methods with empty bodies: <span class="CodeInTextPACKT"><kbd>OnMyStateEntered()</kbd></span>, <span class="CodeInTextPACKT"><kbd>OnMyStateExit()</kbd>, <kbd>OnEventRecieved(...)</kbd>,</span> and <kbd><span class="CodeInTextPACKT">StateUpdate()</span></kbd>. Note that these methods are declared virtual so that they can be overridden by subclasses if necessary, but if not overridden then will do nothing.</li>
</ul>
<p>When the <kbd><span class="CodeInTextPACKT">MyGameManager</span></kbd> class's&amp;nbsp;<kbd><span class="CodeInTextPACKT">Awake()</span></kbd> method is executed, three state objects are created, one for each of the playing/win/lose classes. These state objects are stored in their corresponding variables: <kbd><span class="CodeInTextPACKT">stateGamePlaying</span></kbd>, <kbd><span class="CodeInTextPACKT">stateGameWon</span></kbd>, and <kbd><span class="CodeInTextPACKT">stateGameLost</span></kbd>.</p>
<p>The <kbd><span class="CodeInTextPACKT">MyGameManager</span></kbd> class has a variable called <kbd><span class="CodeInTextPACKT">currentState</span></kbd>, which is a reference to the current state object at any time while the game runs (initially, it will be <span class="CodeInTextPACKT">null</span>). Since it is of the <kbd><span class="CodeInTextPACKT">GameState</span></kbd> class (the parent of all state classes), it can refer to any of the different state objects.</p>
<p>After <kbd><span class="CodeInTextPACKT">Awake()</span></kbd>, <kbd><span class="CodeInTextPACKT">GameManager</span></kbd> will receive a <kbd><span class="CodeInTextPACKT">Start()</span></kbd> message. This method initializes&amp;nbsp;<kbd><span class="CodeInTextPACKT">currentState</span></kbd> to be the <kbd><span class="CodeInTextPACKT">stateGamePlaying</span></kbd> object.</p>
<p>For each frame,&amp;nbsp;<kbd><span class="CodeInTextPACKT">GameManager</span></kbd> will receive <kbd><span class="CodeInTextPACKT">Update()</span></kbd> messages. Upon receiving these messages, <kbd><span class="CodeInTextPACKT">GameManager</span></kbd> sends a <kbd><span class="CodeInTextPACKT">StateUpdate()</span></kbd> messages to&amp;nbsp;<kbd><span class="CodeInTextPACKT">currentState</span> &amp;nbsp;</kbd>&amp;nbsp;object. So, for each frame, the object for the current state of the game will execute those methods. For example, when&amp;nbsp;<kbd><span class="CodeInTextPACKT">currentState</span></kbd> is set to game playing, for each frame, the <kbd><span class="CodeInTextPACKT">gamePlayingObject</span></kbd> will calls its (in this case, empty) <kbd><span class="CodeInTextPACKT">StateUpdate()</span></kbd> method.</p>
<p>The <kbd><span class="CodeInTextPACKT">StateGamePlaying</span></kbd> class implements statements in its <kbd><span class="CodeInTextPACKT">OnEventReceived()</span></kbd> method so that when the user clicks on a button, the <kbd><span class="CodeInTextPACKT">gamePlayingObject</span></kbd> will call the <kbd><span class="CodeInTextPACKT">GameManager</span></kbd> instance's <kbd><span class="CodeInTextPACKT">NewState(...)</span></kbd> method, passing it the object corresponding to the new state. So for example, if the user clicks on <span class="ScreenTextPACKT"><span class="packt_screen">Button-win</span></span>, the <kbd><span class="CodeInTextPACKT">NewState(...)</span></kbd> method is passed to <kbd><span class="CodeInTextPACKT">gameManager.stateGameWon</span></kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>There are some details that you don't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the Timer event to lose the game after five seconds</h1>
                </header>
            
            <article>
                
<p>The state pattern solution makes it much simpler, and cleaner to add new features. For example, to add the five-second-timer feature to this recipe, do the following:</p>
<ol>
<li>Create a new C# script class called <kbd><span class="CodeInTextPACKT">SimpleTimer</span></kbd>, and add an instance object as a component to the <span class="ScreenTextPACKT"><span class="packt_screen">Main Camera</span></span> GameObject:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class SimpleTimer : MonoBehaviour<br/>     {<br/>         private float timeGamePlayingStarted;<br/>         private float timeToPressAButton = 5;<br/> <br/>         private MyGameManager myGameManager;<br/> <br/>         private void Start()<br/>         {<br/>             myGameManager = GetComponent&lt;MyGameManager&gt;();<br/>             timeGamePlayingStarted = Time.time;<br/>         }<br/> <br/>         void Update ()<br/>         {<br/>             float timeSinceGamePlayingStarted = Time.time - <br/>             timeGamePlayingStarted;<br/> <br/>             if (timeSinceGamePlayingStarted &gt; timeToPressAButton)<br/>             {<br/>                 myGameManager.PublishEventToCurrentState<br/>                 (GameState.EventType.TimerFinished);<br/>             }<br/>         }<br/>     } </pre>
<ol start="2">
<li>Add a new event type of <kbd><span class="CodeInTextPACKT">TimerFinished</span></kbd> to the <span class="CodeInTextPACKT"><kbd>GameState</kbd> script class</span>:</li>
</ol>
<pre style="padding-left: 30px">    public enum EventType<br/>     {<br/>         ButtonWinGame,<br/>         ButtonLoseGame,<br/>         TimerFinished<br/>     } </pre>
<ol start="3">
<li>Add a new case to the switch statement in <kbd><span class="CodeInTextPACKT">StateGamePlaying</span></kbd>, so that this <kbd><span class="CodeInTextPACKT">TimerFinished</span></kbd> event also causes the game to go into the <kbd><span class="CodeInTextPACKT">GameLost</span></kbd> state:</li>
</ol>
<pre style="padding-left: 30px">    public override void OnEventReceived(EventType eventType)<br/>     {<br/>         switch(eventType){<br/>             case (EventType.ButtonWinGame):<br/>                 gameManager.NewGameState(gameManager.stateGameWon);<br/>                 break;<br/>             case (EventType.ButtonLoseGame):<br/>             case (EventType.TimerFinished):<br/>                 gameManager.NewGameState(gameManager.stateGameLost);<br/>                 break;<br/>         }<br/>     } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>In this recipe, some of the complexity of different types of events causing the <kbd><span class="CodeInTextPACKT">MyGameManager</span></kbd> to change its current state was implemented by other scripted objects (<kbd><span class="CodeInTextPACKT">ButtonActions</span></kbd> and <kbd><span class="CodeInTextPACKT">SimpleTimer</span></kbd> as scripted object components inside <span class="KeyWordPACKT"><span class="packt_screen">Main Camera</span></span>) invoking the&amp;nbsp;<span class="CodeInTextPACKT"><kbd>PublishEventToCurrentState(...)</kbd> public method.</span> A better was to implement events in games is provided later in this chapter in the&amp;nbsp;<em><span class="KeyWordPACKT">Publisher-Subscriber</span> pattern C# delegates and events</em> recipe.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">State-driven behavior with Unity Scriptable Objects</h1>
                </header>
            
            <article>
                
<p>Unity has a feature called <span class="KeyWordPACKT">Scriptable Objects</span>. <span class="KeyWordPACKT">Scriptable Objects</span> are asset files stored in the <kbd>Assets</kbd> folder, like any other asset (such as Materials or Textures). In some ways,&amp;nbsp;<span class="KeyWordPACKT">Scriptable Objects</span> are like <span class="CodeInTextPACKT">Monobehaviours</span>, but they are not attached to GameObjects. Both logic (code) and data can be stored as asset files in the form of&amp;nbsp;<span class="KeyWordPACKT">Scriptable Objects</span>.</p>
<p>In this recipe, we implement a state-based game where the game starts in a game-playing state, and goes to a game-lost state when a timer runs out. If two stars are collected before the timer runs out, the game goes into the game-won state. A <strong><span class="KeyWordPACKT">UI Button</span></strong> is offered to the user, which collects a star each time it is clicked.</p>
<p>As you'll see, <span class="KeyWordPACKT">Scriptable Object</span> asset files are used to represent which decisions cause which state changes to take place.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To manage a game's state-driven behavior with Unity Scriptable Objects, perform the following steps:</p>
<ol>
<li>Create a <strong><span class="KeyWordPACKT">UI Button</span></strong> in the middle of the screen. Name it <kbd><span class="ScreenTextPACKT">Button-collect-star</span></kbd> and edit its text to read <kbd><span class="ScreenTextPACKT">Collect a star</span></kbd>.</li>
<li>Create a <span class="KeyWordPACKT"><strong>UI Text</strong></span> object at the top-right of the screen. Name this <kbd><span class="ScreenTextPACKT">Text-current-state</span></kbd>.</li>
<li>Create a <strong><span class="KeyWordPACKT">UI Text</span></strong> object at the top-left of the screen. Name this <kbd><span class="ScreenTextPACKT">Text-stars-collected</span></kbd>.</li>
<li>Create a second <span class="KeyWordPACKT">UI Text</span> object at the top-left of the screen, positioned below <kbd><span class="ScreenTextPACKT">Text-stars-collected</span></kbd>. Name this <kbd><span class="ScreenTextPACKT">Text-seconds-left</span></kbd>.</li>
<li>Create a new C# script class called <kbd><span class="CodeInTextPACKT">Decision</span></kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public abstract class Decision : ScriptableObject<br/>     {<br/>         public abstract bool Decide(StateController controller);<br/>     }</pre>
<ol start="6">
<li>Create a new C# script class called <kbd><span class="CodeInTextPACKT">Transition</span></kbd>:</li>
</ol>
<pre style="padding-left: 30px">    [System.Serializable]<br/>     public class Transition<br/>     {<br/>         public Decision decision;<br/>         public State trueState;<br/>     } </pre>
<ol start="7">
<li>Create a new C# script class called <kbd><span class="CodeInTextPACKT">State</span></kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     [CreateAssetMenu(menuName = "MyGame/State")]<br/>     public class State : ScriptableObject<br/>     {         public Transition[] transitions;<br/> <br/>         public void UpdateState(StateController controller)<br/>         {<br/>             CheckTransitions(controller);<br/>         }<br/> <br/>         private void CheckTransitions(StateController controller)<br/>         {<br/>             for (int i = 0; i &lt; transitions.Length; i++)<br/>             {<br/>                 bool decisionSucceeded = <br/>                 transitions[i].decision.Decide(controller);<br/> <br/>                 if (decisionSucceeded)<br/>                 {<br/>                     controller.TransitionToState<br/>                     (transitions[i].trueState);<br/>                 }<br/>             }<br/>         }<br/>     } </pre>
<ol start="8">
<li>Create a new C# script class called <kbd><span class="CodeInTextPACKT">StateController</span></kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class StateController : MonoBehaviour<br/>     {<br/>         public State currentState;<br/>         [HideInInspector] public MyGameManager gameManager;<br/> <br/>         void Awake()<br/>         {<br/>             gameManager = GetComponent&lt;MyGameManager&gt;();<br/>         }<br/> <br/>         private void Update()<br/>         {<br/>             currentState.UpdateState(this);<br/>             gameManager.DisplayCurrentState(currentState);<br/>         }<br/> <br/>         public void TransitionToState(State nextState)<br/>         {<br/>             currentState = nextState;<br/>         }<br/>     } </pre>
<ol start="9">
<li>Create a new C# script class called <kbd><span class="CodeInTextPACKT">GameWonDecision</span></kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     [CreateAssetMenu(menuName = "MyGame/Decisions/GameWonDecision")]<br/>     public class GameWonDecision : Decision<br/>     {<br/> <br/>         public override bool Decide(StateController controller)<br/>         {<br/>             return GameWonActionDetected(controller.gameManager);<br/>         }<br/> <br/>         private bool GameWonActionDetected(MyGameManager gameManager)<br/>         {<br/>             return gameManager.HasCollectedAllStars();<br/>         }<br/>     } </pre>
<ol start="10">
<li>Create a new C# script class called <kbd><span class="CodeInTextPACKT">GameLostDecision</span></kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     [CreateAssetMenu(menuName = "MyGame/Decisions/GameLostDecision")]<br/>     public class GameLostDecision : Decision<br/>     {<br/> <br/>         public override bool Decide(StateController controller)<br/>         {<br/>             return GameLostActionDetected(controller.gameManager);<br/>         }<br/> <br/>         private bool GameLostActionDetected(MyGameManager gameManager)<br/>         {<br/>             return gameManager.GetTimeRemaining() &lt;= 0;<br/>         }<br/>     } </pre>
<ol start="11">
<li>Create a new C# script class called <kbd><span class="CodeInTextPACKT">MyGameManager</span></kbd>, and add an instance object as a component of the <span class="ScreenTextPACKT"><span class="packt_screen">Main Camera</span></span>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/>     using UnityEngine.UI;<br/> <br/> <br/>     public class MyGameManager : MonoBehaviour<br/>     {<br/>         public Text textCurrentState;<br/>         public Text textStarsCollected;<br/>         public Text textSecondsLeft;<br/> <br/>         public float secondsLeft = 10;<br/>         public int totalStarsToBeCollected = 2;<br/>         private int starsColleted = 0;<br/> <br/>         void Update()<br/>         {<br/>             secondsLeft -= Time.deltaTime;<br/>             UpdateDisplays();<br/>         }<br/> <br/>         public void DisplayCurrentState(State currentState)<br/>         {<br/>             textCurrentState.text = currentState.name;<br/>         }<br/> <br/>         public bool HasCollectedAllStars()<br/>         {<br/>             return (starsColleted == totalStarsToBeCollected);<br/>         }<br/> <br/>         public float GetTimeRemaining()<br/>         {<br/>             return secondsLeft;<br/>         }<br/> <br/>         public void BUTTON_ACTION_PickupOneStar()<br/>         {<br/>             starsColleted++;<br/>         }<br/> <br/>         private void UpdateDisplays()<br/>         {<br/>             textStarsCollected.text = "stars = " + starsColleted;<br/>             textSecondsLeft.text = "time left = " + secondsLeft;<br/>         }<br/>     } </pre>
<ol start="12">
<li>In the <span class="KeyWordPACKT"><span class="packt_screen">Hierarchy</span></span>, select the <span class="ScreenTextPACKT"><span class="packt_screen">Button-collect-star</span></span> button, and for its <span class="ScreenTextPACKT"><span class="packt_screen">Button (Script)</span></span> component, add an <span class="ScreenTextPACKT"><span class="packt_screen">OnClick</span></span> action to call the <kbd><span class="ScreenTextPACKT">BUTTON_ACTION_PickupOneStar()</span></kbd> method from the <kbd>MyGameManager</kbd> component in the <span class="ScreenTextPACKT"><span class="packt_screen">Main Camera</span></span> GameObject.</li>
<li>In the <span class="KeyWordPACKT"><span class="packt_screen">Project</span></span> panel, create two new folders, named <kbd><span class="ScreenTextPACKT">_Decisions</span></kbd> and <kbd><span class="ScreenTextPACKT">_States</span></kbd>. These folders will contain the <span class="KeyWordPACKT">Scriptable Object</span> asset files for this project.</li>
<li>In the&amp;nbsp;<span class="ScreenTextPACKT"><kbd>_Decisions</kbd> folder</span>, create two new Decision <span class="KeyWordPACKT">Scriptable Objects</span> named <kbd><span class="ScreenTextPACKT">GameWonDecision</span></kbd> and <kbd><span class="ScreenTextPACKT">GameLostDecision</span></kbd>. Do this by choosing menu: <span class="ScreenTextPACKT"><span class="packt_screen">Assets</span> | <span class="packt_screen">Create</span> | <span class="packt_screen">MyGame</span> | <span class="packt_screen">Decisions</span></span>.</li>
<li>In the&amp;nbsp;<span class="ScreenTextPACKT"><kbd>_States</kbd> folder</span>, create three new State <span class="KeyWordPACKT">Scriptable Objects</span> named <kbd><span class="ScreenTextPACKT">StateGamePlaying</span></kbd>, <span class="ScreenTextPACKT"><kbd>StateGameWon</kbd>,</span> and <kbd><span class="ScreenTextPACKT">StateGameLost</span></kbd>. Do this by choosing menu<span class="ScreenTextPACKT">: <span class="packt_screen">Assets</span> | <span class="packt_screen">Create</span> | <span class="packt_screen">MyGame</span> | <span class="packt_screen">State</span></span>.</li>
<li>In the&amp;nbsp;<span class="KeyWordPACKT"><span class="packt_screen">Project</span></span> panel folder <kbd>_States</kbd>, select <span class="KeyWordPACKT">the</span>&amp;nbsp;<span class="ScreenTextPACKT"><kbd>StateGamePlaying</kbd> Scriptable Object</span>, and in the <span class="KeyWordPACKT"><span class="packt_screen">Inspector</span>,</span> set the size of its <span class="ScreenTextPACKT"><span class="packt_screen">Transitions</span></span> property to <kbd><span class="ScreenTextPACKT">2</span></kbd>.
<ul>
<li>For <span class="ScreenTextPACKT"><span class="packt_screen">Element 0</span>,</span> set the <span class="ScreenTextPACKT"><span class="packt_screen">Decision</span></span> to <span class="ScreenTextPACKT"><span class="packt_screen">GameWonDecision</span></span> and the <span class="ScreenTextPACKT"><span class="packt_screen">True</span>&amp;nbsp;state</span> to <span class="ScreenTextPACKT"><span class="packt_screen">StateGameWon</span></span></li>
<li>For <span class="ScreenTextPACKT"><span class="packt_screen">Element 1</span>,</span> set the <span class="ScreenTextPACKT"><span class="packt_screen">Decision</span></span> to <span class="ScreenTextPACKT"><span class="packt_screen">GameLostDecision</span></span> and the <span class="ScreenTextPACKT"><span class="packt_screen">True</span>&amp;nbsp;state</span> to <span class="ScreenTextPACKT"><span class="ScreenTextPACKT"><span class="packt_screen">StateGameLost</span>:</span></span></li>
</ul>
</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/36fe5ff2-2a96-4d8a-babb-f9622131b3bf.png" style="width:24.75em;height:13.00em;"/></div>
<ol start="17">
<li>In the <span class="packt_screen">Hierarchy</span>, select the <span class="ScreenTextPACKT"><span class="packt_screen">Main Camera</span></span> GameObject. Drag it into the <span class="packt_screen">Inspector</span> to ensure that all three <span class="ScreenTextPACKT"><span class="packt_screen">GameManager (Script)</span></span> public variables (<span class="ScreenTextPACKT"><span class="packt_screen">Text Current State</span></span>, <span class="ScreenTextPACKT"><span class="packt_screen">Text Stars Collected</span></span>, and <span class="ScreenTextPACKT"><span class="packt_screen">Text Seconds Left</span>)</span>&amp;nbsp;have the corresponding Canvas <strong><span class="KeyWordPACKT">UI Text</span></strong> GameObjects dragged into them.</li>
<li>Run the game. The game should start in <kbd>StateGamePlaying</kbd>. If the user does nothing, when the timer gets to zero, the game should go into <kbd><span class="ScreenTextPACKT">StateGameLost</span></kbd>. If the user clicks the button twice (simulating collecting two stars) before the timer hits zero, the game should go into <kbd><span class="ScreenTextPACKT">StateGameWon</span></kbd>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><span class="CodeInTextPACKT">GameManager</span> knows nothing about the state-based decisions going on in this game. It has a public method giving the number of seconds left in the timer: <kbd><span class="CodeInTextPACKT">GetTimeRemaining()</span></kbd>. It also has a public method that returns a Boolean (true/false) about whether or not all stars have been collected: <kbd><span class="CodeInTextPACKT">HasCollectedAllStars()</span></kbd>. It also has references to the three&amp;nbsp;<strong><span class="KeyWordPACKT">UI Text</span></strong> GameObjects, so it can keep the display updated with the time left and stars collected. A public&amp;nbsp;<kbd><span class="CodeInTextPACKT">DispayCurrentState(...)</span></kbd>&amp;nbsp;method also updates the name of current game state (that is, whatever was passed to this method).</p>
<p>The core game behavior is driven by the <span class="CodeInTextPACKT"><kbd>StateController</kbd> script class</span>. This maintains the current state, and has a reference to the instance object of the <kbd><span class="CodeInTextPACKT">MyGameManager</span></kbd> class that is its sibling component in the <span class="ScreenTextPACKT"><span class="packt_screen">Main Camera</span></span>. Its <kbd><span class="CodeInTextPACKT">Awake()</span></kbd> method gets the reference to the <kbd><span class="CodeInTextPACKT">MyGameManager</span></kbd> object. Its <kbd><span class="CodeInTextPACKT">Update()</span></kbd>&amp;nbsp;method invokes the current state's <kbd><span class="CodeInTextPACKT">UpdateState(...)</span></kbd> method. It passes a reference to itself to the current state. It also has a third public method, <kbd><span class="CodeInTextPACKT">TransitionToState(...)</span></kbd>, which allows a state to instruct the controller to change the current state.</p>
<p>The <kbd><span class="CodeInTextPACKT">Transition</span></kbd> class has no methods, it simply stores references to two objects: a decision and the state that the system will to change to if the decision is true.</p>
<p>The <kbd><span class="CodeInTextPACKT">Decision</span></kbd> class is <span class="CodeInTextPACKT">abstract</span>, which means there will never be any objects created from this class, but subclasses may be defined. It declares that any subclasses must implement a method named <span class="CodeInTextPACKT"><kbd>Decide(...)</kbd>, which</span>&amp;nbsp;returns a Boolean (<span class="CodeInTextPACKT">true/false</span>) value.</p>
<p>The <kbd><span class="CodeInTextPACKT">State</span></kbd> class has an array of <kbd><span class="CodeInTextPACKT">Transition</span></kbd> objects, and its <kbd><span class="CodeInTextPACKT">UpdateState()</span></kbd> method simple invokes its <kbd><span class="CodeInTextPACKT">CheckTransitions(...)</span></kbd> method.&amp;nbsp;<kbd><span class="CodeInTextPACKT">CheckTransitions(...)</span></kbd> loops through each transition, testing its <kbd><span class="CodeInTextPACKT">Decision</span></kbd>. If the decision is true, it tells&amp;nbsp;<kbd><span class="CodeInTextPACKT">StateController</span></kbd> to make the current state the true state of the transition.</p>
<p>In this project, we have declared two subclasses of the <kbd><span class="CodeInTextPACKT">Decision</span></kbd> class:</p>
<ul>
<li><kbd><span class="CodeInTextPACKT">GameWonDecision</span></kbd>: This class' <kbd><span class="CodeInTextPACKT">Decide(...)</span></kbd> method returns the value of its&amp;nbsp;<span class="CodeInTextPACKT"><kbd>GameWonActionDetected(...)</kbd> method</span>.&amp;nbsp;<kbd><span class="CodeInTextPACKT">GameWonActionDetected(...)</span></kbd> returns the value of the game manager's <kbd><span class="CodeInTextPACKT">HasCollectedAllStars()</span></kbd> method, that is, the game-won decision is true when the game manager says that all stars have been collected.</li>
<li><kbd><span class="CodeInTextPACKT">GameWonDecision</span></kbd>: This class's&amp;nbsp;<kbd><span class="CodeInTextPACKT">Decide(...)</span></kbd> method returns the value of its&amp;nbsp;<span class="CodeInTextPACKT"><kbd>GameLostActionDetected(...)</kbd> method</span>.&amp;nbsp;<kbd><span class="CodeInTextPACKT">GameLostActionDetected(...)</span></kbd> returns true if the game manager's timer is zero or less (time has run out).</li>
</ul>
<p>We have created five s<span class="KeyWordPACKT">criptable object</span> assets:</p>
<ul>
<li><strong>Three states</strong>: <span class="CodeInTextPACKT"><kbd>StateGamePlaying</kbd>, <kbd>StateGameWon</kbd>, <kbd>StateGameLost</kbd></span></li>
<li><strong>Two decisions</strong>: <kbd><span class="CodeInTextPACKT">GameWonDecision</span></kbd> and <kbd><span class="CodeInTextPACKT">GameLostDecision</span></kbd></li>
</ul>
<p>We were able to create these <span class="KeyWordPACKT">Scriptable Object</span> assets via the <span class="packt_screen">Create</span> menu through the statements immediately before the script-class declarations for <kbd><span class="CodeInTextPACKT">Decision</span></kbd> and <kbd><span class="CodeInTextPACKT">State</span></kbd> that declared that there should be a new sub-menu in the <span class="ScreenTextPACKT"><span class="packt_screen">Create Asset</span></span> menu named <span class="CodeInTextPACKT"><span class="packt_screen">MyGame</span></span>:</p>
<pre>[CreateAssetMenu(menuName = "MyGame/Decisions/GameLostDecision")] </pre>
<p>The only one of these <span class="KeyWordPACKT">Scriptable Objects</span> that needed any customizing was <kbd><span class="CodeInTextPACKT">StateGamePlaying</span></kbd>. Two transitions were defined in this object:</p>
<ul>
<li>If <kbd><span class="CodeInTextPACKT">GameWonDecision</span></kbd> becomes true, the <span class="CodeInTextPACKT">State Controller</span> should set the current state to <kbd><span class="CodeInTextPACKT">StateGameWon</span></kbd></li>
<li>If <kbd><span class="CodeInTextPACKT">GameLostDecision</span></kbd> becomes true, the <span class="CodeInTextPACKT">State Controller</span> should set the current state to <kbd>StateGameLost</kbd></li>
</ul>
<p>While it may seem like there was a lot of work for this simple game, what this recipe illustrates is how some generic state-machine classes can be created (<span class="CodeInTextPACKT"><kbd>State</kbd>, <kbd>Decision</kbd>, <kbd>Transition</kbd></span>, <kbd><span class="CodeInTextPACKT">StateController</span></kbd>), and that the actual game behavior is modelled through a set of <span class="KeyWordPACKT">Scriptable</span> <span class="KeyWordPACKT">Object</span> assets, and two classes to implement the decision-making for special game events (<kbd><span class="CodeInTextPACKT">GameWonDecision</span></kbd> and <kbd><span class="CodeInTextPACKT">GameLostDecision</span></kbd>).</p>
<p>Since <span class="KeyWordPACKT">Scriptable</span> <span class="KeyWordPACKT">Object</span> are asset files, there are only one of them. At times, we may want the same <span class="KeyWordPACKT">Scriptable</span> <span class="KeyWordPACKT">Object</span> to be used by different GameObjects when the game is running—for example, the state transitions for the AI of lots of different enemy characters may share the use of the same <span class="KeyWordPACKT">Scriptable</span> <span class="KeyWordPACKT">Object</span>. For this reason, a reference to a <kbd><span class="CodeInTextPACKT">StateController</span></kbd> object instance is passed when methods are invoked on <kbd>State</kbd> and <kbd>Decision</kbd> <span class="KeyWordPACKT">Scriptable</span> <span class="KeyWordPACKT">Objects,&amp;nbsp;</span>so the logic in the methods of the <span class="KeyWordPACKT">Scriptable</span> <span class="KeyWordPACKT">Object</span> can work on whatever r<span class="KeyWordPACKT">un-time</span> controller object is provided with. This is an example of another d<span class="KeyWordPACKT">esign pattern</span> known as the <strong><span class="KeyWordPACKT">Delegate</span></strong> design pattern (not to be confused with a C# <span class="KeyWordPACKT">delegate</span>!).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>There are some details that you don't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extending the game to model Player health</h1>
                </header>
            
            <article>
                
<p>To further understand the power of this data-centric approach to state-based games, let's add the following behavior to the game:</p>
<ul>
<li><span>T</span>he player has a <span class="CodeInTextPACKT">health</span> value, starting at 100% (a float value of 1.0)</li>
<li>In each frame, a random amount of health is added or subtracted</li>
<li>The game is lost if the health of the player goes down to zero</li>
</ul>
<p>To implement this feature, all we need to do is:</p>
<ol>
<li>Add a test to the&amp;nbsp;<kbd><span class="CodeInTextPACKT">GameLostDecision</span></kbd>&amp;nbsp;script class to return true if time or health are zero:</li>
</ol>
<pre style="padding-left: 30px">    private bool GameLostActionDetected(MyGameManager gameManager)<br/>     {<br/>         return (gameManager.GetTimeRemaining() &lt;= 0) || <br/>         (gameManager.GetHealth() &lt;= 0);<br/>     } </pre>
<ol start="2">
<li>Add the <kbd>health</kbd> feature to the&amp;nbsp;<span class="CodeInTextPACKT"><kbd>GameManager</kbd> script class</span>:</li>
</ol>
<pre style="padding-left: 30px">    private float health = 1;<br/>     public float healthPlusMaximum = 0.03f;<br/>     public float healthMinusMaximum = -0.03f;<br/> <br/>     void Update()<br/>     {<br/>         // extra feature<br/>         RandomlyChangeHealth();<br/> <br/>         secondsLeft -= Time.deltaTime;<br/>         UpdateDisplays();<br/>     }<br/> <br/>     // extra freature<br/>     public float GetHealth()<br/>     {<br/>         return health;<br/>     }<br/> <br/>     // health can't go below 0 or above 1<br/>     private void RandomlyChangeHealth()<br/>     {<br/>         float healthChange = Random.Range(healthMinusMaximum,  <br/>         healthPlusMaximum);<br/>         health += healthChange;<br/>         health = Mathf.Clamp(health, 0, 1);<br/>     } </pre>
<p>We could also add another <strong><span class="KeyWordPACKT">UI Text</span></strong> on screen to see the current value of health. If the public <span class="CodeInTextPACKT"><kbd>healthPlusMaximum</kbd> variable</span> is set smaller than the minus maximum (for example,&amp;nbsp;<kbd><span class="CodeInTextPACKT">0.02</span></kbd>), the health will go downwards since the random average will be less than zero.</p>
<p class="mce-root"/>
<p>To add another state, such as&amp;nbsp;<kbd><span class="CodeInTextPACKT">StatePauseGame</span></kbd>, all that is needed are the following steps:</p>
<ol>
<li>Create new&amp;nbsp;<span class="CodeInTextPACKT"><kbd>GamePausedDecision</kbd> script class</span>, with the logic to detect whether the game is paused (for example, the game manager could have an&amp;nbsp;<kbd><span class="CodeInTextPACKT">isPaused</span></kbd>&amp;nbsp;boolean variable that gets set to true when the user presses the <em>P</em> key)</li>
<li>Create a new&amp;nbsp;<span class="CodeInTextPACKT"><kbd>StateGamePaused</kbd> Scriptable Object State</span></li>
<li>Create a new&amp;nbsp;<span class="CodeInTextPACKT"><kbd>GamePausedDecision</kbd> Scriptable Object State</span></li>
<li>Add a third transition to the&amp;nbsp;<kbd><span class="CodeInTextPACKT">StateGamePlaying</span></kbd>&amp;nbsp;Scriptable Object State (element 2), with <kbd><span class="CodeInTextPACKT">GamePausedDecision</span></kbd> and the true state of <kbd><span class="CodeInTextPACKT">StateGamePaused</span></kbd></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>To see this approach to state-driven games using <span class="KeyWordPACKT">Scriptable Objects</span> taken much further, including adding the feature for actions to be performed during each state, follow the online video Unity tutorial about <span class="KeyWordPACKT">Scriptable Objects</span> for enemy state-driven AI:&amp;nbsp;<a href="https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern">https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern</a>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Publisher-Subscriber pattern C# delegates and events</h1>
                </header>
            
            <article>
                
<p>When events can be based on visibility, distance, or collisions, we can use such events as <kbd><span class="CodeInTextPACKT">OnTriggerExit</span></kbd> and <kbd><span class="CodeInTextPACKT">OnBecomeInvisible</span></kbd>. When events can be based on time periods, we can use coroutines. However, some events are unique to each game situation, and C# offers several methods of broadcasting user-defined event messages to scripted objects. One approach is the <kbd><span class="CodeInTextPACKT">SendMessage(...)</span></kbd> method, which, when sent to a GameObject, will check every Monobehaviour scripted component and execute the named method if its parameters match. However, this involves an inefficient technique known as reflection. C# offers another event message approach known as <span class="KeyWordPACKT">delegates</span> and <span class="KeyWordPACKT">events</span>, which we describe and implement in this recipe.</p>
<p><span class="KeyWordPACKT">Delegates</span> and <span class="KeyWordPACKT">events</span> work in a similar way to <kbd><span class="CodeInTextPACKT">SendMessage(...)</span></kbd>, but are much more efficient since Unity maintains a defined list of which objects are listening to the broadcast events. <kbd><span class="CodeInTextPACKT">SendMessage(...)</span></kbd> should be avoided if performance is important, since it means that Unity has to analyze each scripted object (reflect over the object) to see whether there is a public method corresponding to the message that has been sent; this is much slower than using delegates and events.</p>
<p><span class="KeyWordPACKT">Delegates</span> separate the code declaring the <span class="KeyWordPACKT">delegate</span> from any of the codes (classes) that use the <span class="KeyWordPACKT">delegate</span>. The script-class that declares the public <span class="KeyWordPACKT">delegate</span> does not need to know anything about the object or objects that make use of its delegated functionality.</p>
<p><span class="KeyWordPACKT">Delegates</span> and <span class="KeyWordPACKT">events</span> implement the <strong><span class="KeyWordPACKT">Publisher-Subscriber</span> design pattern</strong> (<strong>pubsub</strong>). This is also known as the <strong><span class="KeyWordPACKT">Observer</span></strong> design pattern. Objects can subscribe one of their methods to receive a particular type of event message from a particular publisher. In this recipe, we'll have a manager class that will publish new events when <strong><span class="KeyWordPACKT">UI Buttons</span></strong> are clicked. We'll create some <strong>UI objects</strong>, some of which subscribe to the color-change events. Each time a color-change event is published, subscribed <strong>UI objects</strong> receive the event message and change their color accordingly.</p>
<p>We will also add a c<span class="KeyWordPACKT">onsole</span> event logger, to listen for and log messages about color-change events.</p>
<p>C# publisher objects don't have to worry about how many objects subscribe to them at any point in time (it could be none or 1,000!). This is known as <strong><span class="KeyWordPACKT">loose coupling</span></strong>, since it allows different code components to be written (and maintained) independently and is a desirable feature of object-oriented code:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2154430f-5063-4aa5-a1ab-610c558782c8.png" style="width:33.42em;height:20.25em;"/></div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, a Unity Package has been provided (<kbd><span class="ScreenTextPACKT">colorChangeScene.unitypackage</span></kbd>) in the <kbd>17_04</kbd> folder. This package contains a scene with <strong><span class="KeyWordPACKT">UI Buttons</span></strong> and other objects for the recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To implement the <span class="KeyWordPACKT">Publisher-Subscriber</span> pattern using C# <span class="KeyWordPACKT">delegates</span> and <span class="KeyWordPACKT">events</span>, follow these steps:</p>
<ol>
<li>Create a new Unity project, and delete the default&amp;nbsp;<span class="KeyWordPACKT"><kbd>Scenes</kbd> folder</span>.</li>
<li>Import the provided Unity package (<kbd><span class="ScreenTextPACKT">colorChangeScene.unitypackage</span></kbd>).</li>
<li>Add the following <kbd>ColorManager</kbd> C# script class to the <span class="ScreenTextPACKT"><span class="packt_screen">Main Camera</span></span>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class ColorManager : MonoBehaviour<br/>     {<br/>         private ColorModel colorModel;<br/>         private ColorChangeListenerConsole colorChangeListenerConsole;<br/> <br/>         void Awake()<br/>         {<br/>             colorModel = new ColorModel();<br/>             colorChangeListenerConsole = new <br/>             ColorChangeListenerConsole();<br/>         }<br/> <br/>         public void BUTTON_ACTION_make_green()<br/>         {<br/>             colorModel.SetColor(Color.green);<br/>         }<br/> <br/>         public void BUTTON_ACTION_make_blue()<br/>         {<br/>             colorModel.SetColor(Color.blue);<br/>         }<br/> <br/>         public void BUTTON_ACTION_make_red()<br/>         {<br/>             colorModel.SetColor(Color.red);<br/>         }<br/>     }</pre>
<ol start="4">
<li>Create the&amp;nbsp;<span class="CodeInTextPACKT"><kbd>ColorChangeListenerImage</kbd>&amp;nbsp;</span>C# script class, and add an instance object as a component to the&amp;nbsp;<kbd><span class="ScreenTextPACKT">Image-listening</span></kbd> and <span class="ScreenTextPACKT"><kbd>Slider-listening</kbd> GameObjects</span> (both children of&amp;nbsp;<span class="ScreenTextPACKT"><span class="packt_screen">Canvas</span> | <span class="packt_screen">listening-game-objects</span></span>):</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/>     using UnityEngine.UI;<br/> <br/>     public class ColorChangeListenerImage : MonoBehaviour<br/>     {<br/>         void OnEnable() {<br/>             ColorModel.OnChangeColor += ChangeColorEvent;<br/>         }<br/> <br/>         void OnDisable(){<br/>             ColorModel.OnChangeColor -= ChangeColorEvent;<br/>         }<br/> <br/>         void ChangeColorEvent(Color newColor)<br/>         {<br/>             GetComponent&lt;Image&gt;().color = newColor;<br/>         }<br/>     } </pre>
<ol start="5">
<li>Create the&amp;nbsp;<span class="CodeInTextPACKT"><kbd>ColorChangeListenerText</kbd>&amp;nbsp;</span>C# script class, and add an instance object as a component to the&amp;nbsp;<span class="ScreenTextPACKT"><kbd>Text-listening</kbd> GameObject</span>&amp;nbsp;(a child of&amp;nbsp;<span class="ScreenTextPACKT"><span class="packt_screen">Canvas</span> | <span class="packt_screen">listening-game-objects</span>)</span>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/>     using UnityEngine.UI;<br/> <br/>     public class ColorChangeListenerText : MonoBehaviour<br/>     {<br/>         void OnEnable() {<br/>             ColorModel.OnChangeColor += ChangeColorEvent;<br/>         }<br/> <br/>         void OnDisable(){<br/>             ColorModel.OnChangeColor -= ChangeColorEvent;<br/>         }<br/> <br/>         void ChangeColorEvent(Color newColor)<br/>         {<br/>             GetComponent&lt;Text&gt;().color = newColor;<br/>         }<br/>     }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="6">
<li>Create the <kbd>ColorChangeListenerConsole</kbd> C# script class:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class ColorChangeListenerConsole<br/>     {<br/>         public ColorChangeListenerConsole()<br/>         {<br/>             ColorModel.OnChangeColor += ChangeColorEvent;<br/>         }<br/> <br/>         ~ColorChangeListenerConsole()<br/>         {<br/>             ColorModel.OnChangeColor -= ChangeColorEvent;<br/>         }<br/> <br/>         void ChangeColorEvent(Color newColor){<br/>             Debug.Log("new color = " + newColor);<br/>         }<br/>     } </pre>
<ol start="7">
<li>Create the <kbd>ColorModel</kbd> C# script class:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class ColorModel<br/>     {<br/>         private Color color;<br/> <br/>         public delegate void ColorChangeHandler(Color newColor);<br/>         public static event ColorChangeHandler OnChangeColor;<br/> <br/>         private void PublishColorEvent()<br/>         {<br/>             // if there is at least one listener to this delegate<br/>             if (OnChangeColor != null)<br/>                 // broadcast change colour event<br/>                 OnChangeColor(this.color);<br/>         }<br/> <br/>         public void SetColor(Color newColor)<br/>         {<br/>             this.color = newColor;<br/>             PublishColorEvent();<br/>         }<br/>     } </pre>
<ol start="8">
<li>With <span class="packt_screen">button-<span class="ScreenTextPACKT">GREEN</span></span> selected in the <span class="packt_screen">Hierarchy</span>, add a new <span class="packt_screen">OnClick()</span> event for this button, dragging the <span class="packt_screen">Main Camera</span> as the target GameObject and selecting the&amp;nbsp;<span class="packt_screen">BUTTON_ACTION_make_green()</span> <span class="CodeInTextPACKT">public function</span>. Do the same for the <span class="ScreenTextPACKT"><span class="packt_screen">button-BLUE</span></span> and <span class="ScreenTextPACKT"><span class="packt_screen">button-RED</span></span> buttons with the&amp;nbsp;<span class="CodeInTextPACKT"><span class="packt_screen">BUTTON_ACTION_make_blue()</span></span> and <span class="CodeInTextPACKT"><span class="packt_screen">BUTTON_ACTION_make_red()</span> functions,</span> respectively.</li>
<li>Run the game. When you click a <span class="packt_screen">change-color</span> button, the three <strong>UI objects</strong> on the right of the screen show all changes to the corresponding color, while the two <strong>UI objects</strong> at the bottom-left of the screen remain in the default white color. You should also see <kbd><span class="ScreenTextPACKT">Debug.Log</span></kbd> messages in the <span class="KeyWordPACKT">Console</span> panel, showing the RBG color corresponding to the button that was clicked.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We have added an instance object of <kbd><span class="CodeInTextPACKT">ColorManager</span></kbd> to the <span class="ScreenTextPACKT">Main Camera</span>. This class does three main things:</p>
<ul>
<li>Creates an instance object of the&amp;nbsp;<kbd><span class="CodeInTextPACKT">ColorChangeListenerConsole</span></kbd> script class</li>
<li>Creates an instance object of the&amp;nbsp;<kbd><span class="CodeInTextPACKT">ColorModel</span></kbd> script class</li>
<li>Offers three public methods that can be invoked by clicking the red/green/blue <span class="KeyWordPACKT">UI Buttons</span></li>
</ul>
<p>Each time a button is clicked, the <kbd><span class="CodeInTextPACKT">colorModel</span></kbd> object is told to <kbd><span class="CodeInTextPACKT">SetColor(...)</span></kbd> to the corresponding color.</p>
<p>The <kbd><span class="CodeInTextPACKT">ColorModel</span></kbd>&amp;nbsp;script class has a private variable of the current color. This value can be changed by invoking its <kbd><span class="CodeInTextPACKT">SetColor(...)</span></kbd> method (from the <kbd><span class="CodeInTextPACKT">ColorManager</span></kbd> when a button is clicked). As well as changing the value of color, the&amp;nbsp;<kbd><span class="CodeInTextPACKT">SetColor(...)</span></kbd>&amp;nbsp;method also invokes the&amp;nbsp;<span class="CodeInTextPACKT"><kbd>PublishColorEvent()</kbd> method</span>. The&amp;nbsp;<kbd><span class="CodeInTextPACKT">PublishColorEvent()</span></kbd>&amp;nbsp;method publishes the&amp;nbsp;<span class="CodeInTextPACKT"><kbd>OnChangeColor(this.color)</kbd> event,&amp;nbsp;</span>so that all registered listeners to this event will be invoked with the new c<span class="CodeInTextPACKT">olor</span> value.</p>
<p>On the right-hand side of the screen, we have three GameObjects: <span class="ScreenTextPACKT"><span class="packt_screen">Image-listening</span></span>, <span class="ScreenTextPACKT"><span class="packt_screen">Slider-listening</span>,</span> and <span class="ScreenTextPACKT"><span class="packt_screen">Text-listening</span></span>. Each of these objects has a scripted component of either <kbd><span class="CodeInTextPACKT">ColorChangeListenerImage</span></kbd> or <kbd><span class="CodeInTextPACKT">ColorChangeListenerText</span></kbd>. These components register their respective <kbd><span class="CodeInTextPACKT">OnChangeColor(...)</span></kbd> methods to listen for <kbd><span class="CodeInTextPACKT">OnChangeColor(this.color)</span></kbd> events. The <kbd><span class="CodeInTextPACKT">ColorChangeListenerImage</span></kbd> and <span class="CodeInTextPACKT"><kbd>ColorChangeListenerText</kbd> script classes</span> both register their <kbd><span class="CodeInTextPACKT">ChangeColor(...)</span></kbd> methods to the <kbd>OnChangeColor(...)</kbd> event of the <span class="CodeInTextPACKT"><kbd>ColorModel</kbd> script class</span>.</p>
<p>The&amp;nbsp;<kbd><span class="CodeInTextPACKT">ColorChangeListenerConsole</span></kbd>&amp;nbsp;script class also registers its <kbd><span class="CodeInTextPACKT">ChangeColor(...)</span></kbd> methods to the <kbd><span class="CodeInTextPACKT">OnChangeColor(...)</span></kbd> event of the&amp;nbsp;<span class="CodeInTextPACKT"><kbd>ColorModel</kbd> script class</span>.</p>
<p>Since our scripted objects may be disabled and enabled at different times, each time a scripted <kbd><span class="CodeInTextPACKT">ColorChangeListener</span></kbd> object is enabled (such as when its GameObject parent is instantiated), its <kbd><span class="CodeInTextPACKT">OnChangeColor()</span></kbd> method is added (<span class="CodeInTextPACKT"><kbd>+=</kbd>)</span> to the list of those subscribed to listen for color-change events, likewise, each time <span class="CodeInTextPACKT"><kbd>ColorChangeListenerImage</kbd> or <kbd>Text</kbd></span> objects are disabled, those methods are removed (<span class="CodeInTextPACKT"><kbd>-=</kbd>)</span> from the list of event subscribers.</p>
<div class="packt_infobox">It is very important that methods are removed from the list of subscribers to an event when they are no longer required. Failure to do this can lead to significant problems, such as memory leaks.</div>
<p>When <span class="CodeInTextPACKT"><kbd>ColorChangeListenerImage</kbd> or a <kbd>Text</kbd></span> object receives a color-change message, its subscribed <kbd><span class="CodeInTextPACKT">OnChangeColor()</span></kbd> method is executed and the color of the appropriate component is changed to the received color value (<span class="CodeInTextPACKT">green/red/blue</span>).</p>
<p>The <kbd><span class="CodeInTextPACKT">ColorManager</span></kbd> class declares a <strong><span class="KeyWordPACKT">Delegate</span></strong> named <kbd><span class="CodeInTextPACKT">ColorChangeHandler</span></kbd>. <span class="KeyWordPACKT">Delegates</span> define the return type (in this case, <kbd>void</kbd>) and argument signature of methods that can be delegated (subscribed) to an event. In this case, methods must have the argument signature of a single parameter of the&amp;nbsp;<span class="CodeInTextPACKT"><kbd>Color</kbd> type</span>. Our <kbd><span class="CodeInTextPACKT">OnChangeColor()</span></kbd> method in the&amp;nbsp;<span class="CodeInTextPACKT"><kbd>ColorChangeListenerImage</kbd>, <kbd>Text</kbd>, and <kbd>Console</kbd></span>&amp;nbsp;classes matches this argument signature and so is permitted to subscribe to&amp;nbsp;<kbd><span class="CodeInTextPACKT">changeColorEvent</span></kbd> in the <kbd><span class="CodeInTextPACKT">ColorManager</span></kbd> class.</p>
<div class="packt_infobox">You may notice that&amp;nbsp;<kbd><span class="CodeInTextPACKT">ColorChangeListenerConsole</span></kbd> does not have <span class="CodeInTextPACKT"><kbd>OnEnable</kbd> or <kbd>OnDisable</kbd></span> methods. This is because it is not a <span class="CodeInTextPACKT">MonoBehaviour</span>, and so does not receive Unity runtime events such as <span class="CodeInTextPACKT"><kbd>Awake()</kbd>, <kbd>Update()</kbd>, or <kbd>OnEnable()</kbd></span>. However, being a simple class, it can have a constructor method invoked when a new object instance is created with the <span class="CodeInTextPACKT">new</span> keyword, and a destructor method invoked when the object is no longer referenced. So it is in those methods that these objects register and deregister to listen to <span class="CodeInTextPACKT"><kbd>ColorModel.OnChangeColor</kbd></span> events.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Model-View-Controller (MVC) pattern</h1>
                </header>
            
            <article>
                
<p>The <strong><span class="KeyWordPACKT">Model-View-Controller</span></strong> (<strong>MVC</strong>) pattern is a software architecture that tries to separate the data (Model) from the displays (Views) and actions that change that data (Controller).</p>
<p>In this recipe, we use the MVC pattern to implement a feature of many games—a visual health bar representing the Player's numeric health value (in this case, a float number from <span class="CodeInTextPACKT">0.0 - 1.0</span>). As the user presses the Up/Down arrow keys (simulating healing and damage), the value of the player's heath changes. With the health-change events, the visual display and a <strong><span class="KeyWordPACKT">Console</span></strong> log are updated to present the new health values to the user:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2f1a83c1-3d1a-4ecd-8b51-b8ba25b99953.png" style="width:15.92em;height:4.67em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, two images been provided in the <kbd>17_05</kbd> folder:</p>
<ul>
<li><kbd><span class="ScreenTextPACKT">health_bar_outline.png</span></kbd>: A red heart image and outline for the health filler</li>
<li><kbd><span class="ScreenTextPACKT">health_bar_fill_blue_to_green.png</span></kbd>: A graduated (blue left to green right) filler image, indicating how much health is left</li>
</ul>
<p>Thanks to Pixel Art Maker for the health bar image:</p>
<ul>
<li><a href="http://pixelartmaker.com/art/49e2498a414f221"><span class="URLPACKT">http://pixelartmaker.com/art/49e2498a414f221</span></a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To implement the MVC pattern in Unity, follow these steps:</p>
<ol>
<li>Import the two provided images.</li>
<li>Create a <strong><span class="KeyWordPACKT">UI Image</span></strong> named <kbd><span class="ScreenTextPACKT">Image-health-bar-outline</span></kbd>, and populate it with the <kbd><span class="ScreenTextPACKT">health_bar_outline</span></kbd> image asset.</li>
<li>Create a <strong><span class="KeyWordPACKT">UI Image</span></strong> named <kbd><span class="ScreenTextPACKT">Image-health-bar-filler</span></kbd>, and populate it with the <kbd><span class="ScreenTextPACKT">health_bar_fill_blue_to_green</span></kbd> image asset. In the <span class="packt_screen">Inspector</span> for the <span class="ScreenTextPACKT"><span class="packt_screen">Image (Script)</span></span> component, set the <span class="ScreenTextPACKT"><span class="packt_screen">Image Type</span></span> to <span class="packt_screen">Filled</span>, and the <span class="ScreenTextPACKT"><span class="packt_screen">Fill Type</span></span> to <span class="ScreenTextPACKT"><span class="packt_screen">Horizontal</span></span>.</li>
<li>Arrange your <strong><span class="KeyWordPACKT">Canvas</span></strong> so that <span class="ScreenTextPACKT"><span class="packt_screen">Image-health-bar-filler</span></span> is before <span class="ScreenTextPACKT"><span class="packt_screen">Image-health-bar</span></span> in the <span class="KeyWordPACKT"><span class="packt_screen">Hierarchy</span></span> (the filler appears behind the outline).</li>
<li>Create a new C# script class,&amp;nbsp;<kbd><span class="CodeInTextPACKT">Player</span></kbd>:</li>
</ol>
<pre style="padding-left: 30px">   public class Player<br/>    {<br/>        public delegate void HealthChangeAction(float health);<br/>        public static event HealthChangeAction OnHealthChange;<br/> <br/>        private float health;<br/>        const float MIN_HEALTH = 0;<br/>        const float MAX_HEALTH = 1;<br/> <br/>        public Player(float health = 1)<br/>        {<br/>            this.health = health;<br/> <br/>            // ensure initial value published<br/>            PublishHealthChangeEvent();<br/>        } 

<br/>        public float GetHealth()<br/>        {<br/>            return this.health;<br/>        }<br/> <br/>        public void AddHealth(float amount)<br/>        {<br/>            this.health += amount;<br/>            if (this.health &gt; MAX_HEALTH)<br/>            {<br/>                this.health = MAX_HEALTH;<br/>            }<br/>            PublishHealthChangeEvent();<br/>        }<br/> <br/>        public void ReduceHealth(float amount)<br/>        {<br/>            this.health -= amount;<br/>            if (this.health &lt; MIN_HEALTH)<br/>            {<br/>                this.health = MIN_HEALTH;<br/>            }<br/>            PublishHealthChangeEvent();<br/>        }<br/> <br/>        // event<br/>        private void PublishHealthChangeEvent()<br/>        {<br/>            if (null != OnHealthChange)<br/>                OnHealthChange(this.health);<br/>        }<br/>    } </pre>
<ol start="6">
<li>Create a new C# script class,&amp;nbsp;<kbd><span class="CodeInTextPACKT">PlayerController</span></kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class PlayerController<br/>     {<br/>         private Player player;<br/> <br/>         public PlayerController()<br/>         {<br/>             player = new Player();<br/>         }<br/> <br/>         public void AddToHealth()<br/>         {<br/>             player.AddHealth(0.5f);<br/>         }<br/> <br/>         public void ReduceHealth()<br/>         {<br/>             player.ReduceHealth(0.1f);<br/>         }<br/>     } </pre>
<ol start="7">
<li>Create a new C# script class,&amp;nbsp;<kbd><span class="CodeInTextPACKT">HealthBarDisplay</span></kbd>, and add an instance object as a component to <kbd><span class="ScreenTextPACKT">Image-health-bar-filler</span></kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/>     using UnityEngine.UI;<br/> <br/>     public class HealthBarDisplay : MonoBehaviour<br/>     {<br/>         private Image healthMeterFiller;<br/> <br/>         private void Start()<br/>         {<br/>             healthMeterFiller = GetComponent&lt;Image&gt;();<br/>         }<br/> <br/>         private void OnEnable()<br/>         {<br/>             Player.OnHealthChange += UpdateHealthBar;<br/>         }<br/> <br/>         private void OnDisable()<br/>         {<br/>             Player.OnHealthChange -= UpdateHealthBar;<br/>         }<br/> <br/>         public void UpdateHealthBar(float health)<br/>         {<br/>             healthMeterFiller.fillAmount = health;<br/>         }<br/>     } </pre>
<ol start="8">
<li>Create a new C# script class,&amp;nbsp;<kbd><span class="CodeInTextPACKT">HealthChangeLogger</span></kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class HealthChangeLogger<br/>     {<br/>         public HealthChangeLogger()<br/>         {<br/>             Player.OnHealthChange += LogNewHealth;<br/>         }<br/> <br/>         ~HealthChangeLogger()<br/>         {<br/>             Player.OnHealthChange -= LogNewHealth;<br/>         }<br/> <br/>         public void LogNewHealth(float health)<br/>         {<br/>             // 1 decimal place<br/>             string healthAsString = health.ToString("0.0");<br/>             Debug.Log("health = " + healthAsString);<br/>         }<br/>     } </pre>
<ol start="9">
<li>Add the following <kbd>PlayerManager</kbd> C# script class&amp;nbsp;to the <span class="ScreenTextPACKT"><span class="packt_screen">Main Camera</span></span>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class PlayerManager : MonoBehaviour<br/>     {<br/>         private PlayerController playerController;<br/>         private HealthChangeLogger healthChangeLogger;<br/> <br/>         void Start()<br/>         {<br/>             playerController = new PlayerController();<br/>             healthChangeLogger = new HealthChangeLogger();<br/>         }<br/> <br/>         void Update()<br/>         {<br/>             if (Input.GetKeyDown("up"))<br/>                 playerController.AddToHealth();<br/> <br/>             if (Input.GetKeyDown("down"))<br/>                 playerController.ReduceHealth();<br/>         }<br/>     } </pre>
<ol start="10">
<li>Run the game. Pressing the Up/Down arrow keys should raise/lower the player's health, which should be confimed by the meter fill image, and in the <kbd>Debug.Log()</kbd> messages in the <strong><span class="KeyWordPACKT">Console</span></strong>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You were provided with two&amp;nbsp;<span class="KeyWordPACKT"><strong>UI Images</strong>:</span>&amp;nbsp;one is a health bar outline (red heart and a black outline), the second is the filler image—to show dark blue to light blue to green, for weak to strong health values.</p>
<p class="mce-root"/>
<p>You set the <span class="ScreenTextPACKT"><span class="packt_screen">Image Type</span></span> of <span class="ScreenTextPACKT"><span class="packt_screen">Image-health-bar-filler</span></span> to be <span class="ScreenTextPACKT"><span class="packt_screen">Filled</span></span>, and that it is to be filled <span class="ScreenTextPACKT"><span class="packt_screen">Horizontally</span></span> (left to right). Therefore, the <span class="ScreenTextPACKT"><span class="packt_screen">fillAmount</span></span> property of a <span class="ScreenTextPACKT">UI Image</span> determines how much of this filler image is displayed to the user (from <span class="CodeInTextPACKT"><kbd>0.0</kbd> to <kbd>1.0</kbd></span>).</p>
<p><span class="CodeInTextPACKT">The <kbd>PlayerManager</kbd></span>&amp;nbsp;script class is a manager script that initializes the&amp;nbsp;<kbd><span class="CodeInTextPACKT">PlayerController</span></kbd> and <kbd><span class="CodeInTextPACKT">HealthChangeLogger</span></kbd> objects, and also allows the user to change the health of the Player by pressing the <span class="CodeInTextPACKT">Up</span> and <span class="CodeInTextPACKT">Down</span> arrow keys (simulating healing/damage during a game). Via the <kbd><span class="CodeInTextPACKT">Update()</span></kbd> method, each <span class="CodeInTextPACKT">Up/Down</span> arrow key press invokes the <kbd><span class="CodeInTextPACKT">PlayerController</span></kbd> methods:&amp;nbsp;<span class="CodeInTextPACKT"><kbd>AddToHealth()</kbd> and <kbd>ReducedHealth()</kbd></span>.</p>
<p><span class="CodeInTextPACKT">The <kbd>PlayerController</kbd></span>&amp;nbsp;script class creates a <kbd><span class="CodeInTextPACKT">PlayerModel</span></kbd> object in its constructor. It has two other methods, <span class="CodeInTextPACKT"><kbd>AddToHealth()</kbd> and <kbd>ReducedHealth()</kbd></span>, that add to/reduce the health of the <kbd><span class="CodeInTextPACKT">PlayerModel</span></kbd> object by <kbd><span class="CodeInTextPACKT">+0.5</span></kbd> and <span class="CodeInTextPACKT"><kbd>-0.1</kbd>,</span> respectively.</p>
<p>The <kbd><span class="CodeInTextPACKT">PlayerModel</span></kbd>&amp;nbsp;script class manages values for <kbd><span class="CodeInTextPACKT">Player</span></kbd> health, and uses delegates and events to publish health changes to any listening <strong>View</strong> classes. When a new object is created, the health property is initialized, and a health-change event is published to all listening objects. Likewise, when <span class="CodeInTextPACKT">the <kbd>AddHealth(...)</kbd> and <kbd>ReduceHealth(...)</kbd></span> methods are invoked with a value, the value of the health is changed, and the health-change event is published to all listening objects. The&amp;nbsp;<kbd><span class="CodeInTextPACKT">OnHealthChange</span></kbd>&amp;nbsp;event is visible to other objects as a static public event. The&amp;nbsp;<kbd><span class="CodeInTextPACKT">PublishHealthChangeEvent()</span></kbd>&amp;nbsp;method publishes the new value of health by invoking all listening <kbd><span class="CodeInTextPACKT">OnHealthChange(...)</span></kbd> methods.</p>
<p>There are two View classes that register to listen for <kbd><span class="CodeInTextPACKT">Player</span>.<span class="CodeInTextPACKT">OnHealthChange(...)</span></kbd> events:</p>
<ul>
<li><kbd><span class="CodeInTextPACKT">HealthBarDisplay</span></kbd>: Updates&amp;nbsp;<kbd><span class="CodeInTextPACKT">fillAmount</span></kbd> for a UI Image for each new health value received</li>
<li><kbd><span class="CodeInTextPACKT">HealthChangeLogger</span></kbd>: Prints messages about the new <kbd><span class="CodeInTextPACKT">Player</span> <span class="CodeInTextPACKT">health</span></kbd> value received to the Debug.Log file</li>
</ul>
<p>As can be seen, each of the Model/View/Controller classes is quite small and simple, and each has their own, well-defined responsibilities. It would be easy to add another kind of health-change event listener, perhaps to play a sound, without having to change any code in any of these existing classes. Likewise, it would be straightforward to add a new property to our <kbd><span class="CodeInTextPACKT">PlayerModel</span></kbd> (perhaps a score or inventory value of stars collected, and then add another public static event for score/inventory changes to be published to subscribed listening views).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Only&amp;nbsp;<kbd><span class="CodeInTextPACKT">PlayerManager</span></kbd> is a MonoBehaviour. One of the advantages of this <span class="KeyWordPACKT">MVC</span>&amp;nbsp;architecture is that each of these components becomes much easier to unit-test in isolation. A version of this recipe is used as an example in the&amp;nbsp;<span class="KeyWordPACKT"><em>State Design Pattern</em> <span><em>PlayMode and Unit Testing a health bar with events, logging, and exceptions</em>&amp;nbsp;</span>recipe in</span> <span class="KeyWordPACKT"><a href="">Chapter 19</a>, <em>Automated Testing</em></span>&amp;nbsp;.</li>
</ul>


            </article>

            
        </section>
    </body></html>