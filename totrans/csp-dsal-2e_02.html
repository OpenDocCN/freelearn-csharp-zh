<html><head></head><body>
<div id="_idContainer013">
<h1 class="chapter-number" id="_idParaDest-39"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-40"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.2.1">Introduction to Algorithms</span></h1>
<p><span class="koboSpan" id="kobo.3.1">While reading the first chapter of this book, you learned about various data types. </span><span class="koboSpan" id="kobo.3.2">Now, it is high time to introduce the topic of algorithms. </span><span class="koboSpan" id="kobo.3.3">In this chapter, you will take a look at their </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">definition</span></strong><span class="koboSpan" id="kobo.5.1">, as well as some real-world </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">examples</span></strong><span class="koboSpan" id="kobo.7.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">notations</span></strong><span class="koboSpan" id="kobo.9.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">types</span></strong><span class="koboSpan" id="kobo.11.1">. </span><span class="koboSpan" id="kobo.11.2">As you should take care of the performance of your applications, the subject of computational complexity of the algorithms, including time complexity, will also be presented </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">and explained.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">First, it is worth mentioning that the topic of algorithms is very broad and complex. </span><span class="koboSpan" id="kobo.13.2">You can easily find a lot of scientific publications about them on the internet, published by researchers from all over the world. </span><span class="koboSpan" id="kobo.13.3">The number of algorithms is enormous and it is almost impossible to even remember the names of all the commonly used ones. </span><span class="koboSpan" id="kobo.13.4">Of course, some algorithms are simple to understand and implement, while others are extremely complex and almost impossible to understand without deep knowledge of algorithmics, mathematics, and other dedicated field of science. </span><span class="koboSpan" id="kobo.13.5">There are also various classifications of algorithms by different key features, and there are a lot of types, including recursive, greedy, divide-and-conquer, back-tracking, and heuristic. </span><span class="koboSpan" id="kobo.13.6">However, for various algorithms, you can specify the computational complexity by stating how much time or space they require to operate with the increasing size of a </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">processed input.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">Does this sound overwhelming, complicated, and difficult? </span><span class="koboSpan" id="kobo.15.2">Don’t worry. </span><span class="koboSpan" id="kobo.15.3">In this chapter, I will try to introduce the topic of algorithms in a way that everyone can understand, not only mathematicians or other scientists. </span><span class="koboSpan" id="kobo.15.4">For this reason, in this chapter, you will find some simplifications to make this topic simpler and easier to follow. </span><span class="koboSpan" id="kobo.15.5">However, the aim is to introduce you to this topic and </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">make you interested in algorithms</span></strong><span class="koboSpan" id="kobo.17.1">, not create another research publication or book with a lot of formal definitions and formulas. </span><span class="koboSpan" id="kobo.17.2">Are you ready? </span><span class="koboSpan" id="kobo.17.3">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">get started!</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.21.1">What </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">are algorithms?</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Notations for </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">algorithm representation</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Types </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">of algorithms</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Computational complexity</span></span></li>
</ul>
<h1 id="_idParaDest-41"><a id="_idTextAnchor065"/><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.28.1">What are algorithms?</span></h1>
<p><span class="koboSpan" id="kobo.29.1">Did you know </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.30.1">you typically use algorithms every day and that you are already an author of some algorithms, even without writing any lines of code or drawing a diagram? </span><span class="koboSpan" id="kobo.30.2">If this sounds impossible, give me a few minutes and read this section to get to know how is </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">it possible.</span></span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.32.1">Definition</span></h2>
<p><span class="koboSpan" id="kobo.33.1">First, you need </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.34.1">to know what an </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">algorithm</span></strong><span class="koboSpan" id="kobo.36.1"> is. </span><span class="koboSpan" id="kobo.36.2">It is a </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">well-defined solution for solving a particular problem or performing a computation</span></strong><span class="koboSpan" id="kobo.38.1">. </span><span class="koboSpan" id="kobo.38.2">It is an ordered list of precise </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">instructions</span></strong><span class="koboSpan" id="kobo.40.1"> that are performed in a given order and take a well-defined </span><strong class="bold"><span class="koboSpan" id="kobo.41.1">input</span></strong><span class="koboSpan" id="kobo.42.1"> into account (if any) to produce a well-defined </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">output</span></strong><span class="koboSpan" id="kobo.44.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.46.1"><img alt="Figure 2.1 – Illustration of an algorithm" src="image/B18069_02_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.47.1">Figure 2.1 – Illustration of an algorithm</span></p>
<p><span class="koboSpan" id="kobo.48.1">To be more precise, </span><strong class="bold"><span class="koboSpan" id="kobo.49.1">an algorithm should contain a finite sequence of unambiguous instructions, which provides you with an effective and efficient way of solving the problem</span></strong><span class="koboSpan" id="kobo.50.1">. </span><span class="koboSpan" id="kobo.50.2">Of course, an algorithm can contain </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">conditional expressions</span></strong><span class="koboSpan" id="kobo.52.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.53.1">loops</span></strong><span class="koboSpan" id="kobo.54.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">or </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.56.1">recursion</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.58.1">Where can you find more information?</span><a id="_idTextAnchor068"/></p>
<p class="callout"><span class="koboSpan" id="kobo.59.1">If you are interested in the topic of algorithms, you can find a lot of detailed information about them in many books, including </span><em class="italic"><span class="koboSpan" id="kobo.60.1">Introduction to Algorithms</span></em><span class="koboSpan" id="kobo.61.1">, by Thomas H. </span><span class="koboSpan" id="kobo.61.2">Cormen, Charles E. </span><span class="koboSpan" id="kobo.61.3">Leiserson, Ronald L. </span><span class="koboSpan" id="kobo.61.4">Rivest, and Clifford Stein. </span><span class="koboSpan" id="kobo.61.5">Of course, there are also many resources available online, such as </span><em class="italic"><span class="koboSpan" id="kobo.62.1">GeeksForGeeks</span></em><span class="koboSpan" id="kobo.63.1"> (</span><a href="https://www.geeksforgeeks.org"><span class="koboSpan" id="kobo.64.1">https://www.geeksforgeeks.org</span></a><span class="koboSpan" id="kobo.65.1">), </span><em class="italic"><span class="koboSpan" id="kobo.66.1">The Algorithms</span></em><span class="koboSpan" id="kobo.67.1"> (</span><a href="https://the-algorithms.com"><span class="koboSpan" id="kobo.68.1">https://the-algorithms.com</span></a><span class="koboSpan" id="kobo.69.1">), and </span><em class="italic"><span class="koboSpan" id="kobo.70.1">Algorithms, 4th Edition</span></em><span class="koboSpan" id="kobo.71.1">, by Robert Sedgewick and Kevin Wayne (</span><a href="https://algs4.cs.princeton.edu"><span class="koboSpan" id="kobo.72.1">https://algs4.cs.princeton.edu</span></a><span class="koboSpan" id="kobo.73.1">). </span><span class="koboSpan" id="kobo.73.2">A huge number of resources is also available if you browse the </span><em class="italic"><span class="koboSpan" id="kobo.74.1">Algorithms</span></em><span class="koboSpan" id="kobo.75.1"> topic on GitHub (</span><a href="https://github.com/topics/algorithms"><span class="koboSpan" id="kobo.76.1">https://github.com/topics/algorithms</span></a><span class="koboSpan" id="kobo.77.1">). </span><span class="koboSpan" id="kobo.77.2">I strongly encourage you to search for various resources, either in books or over the internet, and continue learning about algorithms when you’ve finished reading </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">this book.</span></span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.79.1">Real-world examples</span></h2>
<p><span class="koboSpan" id="kobo.80.1">With the definition </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.81.1">of algorithms under your belt, you might be thinking, “</span><em class="italic"><span class="koboSpan" id="kobo.82.1">Come on – inputs, outputs, instructions… where I can find them?</span></em><span class="koboSpan" id="kobo.83.1">” The answer turns out to be much simpler than you might expect because you can find such items almost everywhere, all </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">the time!</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">Let’s start with a </span><strong class="bold"><span class="koboSpan" id="kobo.86.1">simple morning routine</span></strong><span class="koboSpan" id="kobo.87.1">. </span><span class="koboSpan" id="kobo.87.2">First, you wake up and take a look at your phone. </span><span class="koboSpan" id="kobo.87.3">If there are any notifications, you go through them and reply to urgent messages. </span><span class="koboSpan" id="kobo.87.4">For any unurgent items, you postpone them. </span><span class="koboSpan" id="kobo.87.5">Then, you go to the bathroom. </span><span class="koboSpan" id="kobo.87.6">If it is occupied, you wait until it is free, telling the person inside to hurry up. </span><span class="koboSpan" id="kobo.87.7">As soon as you are in the bathroom, you take a shower and brush your teeth. </span><span class="koboSpan" id="kobo.87.8">Finally, you choose suitable clothes according to the current weather and temperature. </span><span class="koboSpan" id="kobo.87.9">Surprise! </span><span class="koboSpan" id="kobo.87.10">Your morning routine is an algorithm. </span><span class="koboSpan" id="kobo.87.11">You can describe it as a set of instructions, which has some inputs, such as notifications and the current temperature, as well as outputs, such as chosen clothes. </span><span class="koboSpan" id="kobo.87.12">What’s more, some of the instructions are conditional, such as only replying to urgent messages. </span><span class="koboSpan" id="kobo.87.13">Others can be executed in a loop, such as waiting until the bathroom </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">is vacant.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">The preceding morning routine also contains other algorithms, such as those for </span><strong class="bold"><span class="koboSpan" id="kobo.90.1">unlocking a smartphone using face recognition</span></strong><span class="koboSpan" id="kobo.91.1">. </span><span class="koboSpan" id="kobo.91.2">It is an algorithm-based mechanism that you can use to ensure that only you can unlock your phone. </span><span class="koboSpan" id="kobo.91.3">What’s more, even </span><strong class="bold"><span class="koboSpan" id="kobo.92.1">organizing notifications on your phone</span></strong><span class="koboSpan" id="kobo.93.1"> is the result of an algorithm that takes into account notifications as input, arranges them into groups, and sorts them suitably before presenting them </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">to you.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">At this point, you are dressed up and ready for a healthy and yummy breakfast. </span><span class="koboSpan" id="kobo.95.2">Imagine that you want to </span><strong class="bold"><span class="koboSpan" id="kobo.96.1">prepare scrambled eggs</span></strong><span class="koboSpan" id="kobo.97.1"> using your grandma’s secret recipe. </span><span class="koboSpan" id="kobo.97.2">You need some ingredients, namely three eggs, salt, and pepper. </span><span class="koboSpan" id="kobo.97.3">As a result, you will have created an amazing dish for your perfect breakfast. </span><span class="koboSpan" id="kobo.97.4">First, you crack the eggs into a bowl and whisk them with a pinch of salt and pepper. </span><span class="koboSpan" id="kobo.97.5">Then, you melt butter in a non-stick skillet over medium-low heat. </span><span class="koboSpan" id="kobo.97.6">Next, you pour the egg mixture into the skillet and keep the eggs moving </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.98.1">until there is no liquid egg. </span><span class="koboSpan" id="kobo.98.2">With that, your breakfast is ready. </span><span class="koboSpan" id="kobo.98.3">However, what is it if not a well-written and organized algorithm with a precise input and </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">yummy output?</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">After breakfast, you need to go to work. </span><span class="koboSpan" id="kobo.100.2">So, you jump into your car and launch a navigation app on your smartphone to see </span><strong class="bold"><span class="koboSpan" id="kobo.101.1">the fastest route to work</span></strong><span class="koboSpan" id="kobo.102.1"> while taking the current traffic </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.103.1">into account. </span><span class="koboSpan" id="kobo.103.2">This task is performed by complicated algorithms that can even involve </span><strong class="bold"><span class="koboSpan" id="kobo.104.1">artificial intelligence</span></strong><span class="koboSpan" id="kobo.105.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.106.1">AI</span></strong><span class="koboSpan" id="kobo.107.1">), together with a computer-understandable representation of routes that use specialized data structures, as well as data obtained from other users. </span><span class="koboSpan" id="kobo.107.2">When combined, this forms traffic data. </span><span class="koboSpan" id="kobo.107.3">As you can see, the algorithm takes the complex input and performs various calculations to present you with an ordered list of route directions – for example, go to route A4, turn right to route S19, and follow this route until you reach </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">your destination.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">While at work, you need to prepare documents for your accountant, so you need to gather documents from colleagues, print some of them from emails, and then </span><strong class="bold"><span class="koboSpan" id="kobo.110.1">sort all invoices by numbers</span></strong><span class="koboSpan" id="kobo.111.1">. </span><span class="koboSpan" id="kobo.111.2">How do you perform sorting? </span><span class="koboSpan" id="kobo.111.3">You take the first document from the stack and put it on the table. </span><span class="koboSpan" id="kobo.111.4">Then, you take the second document from the unsorted stack and put it either above, if the number is smaller than the first invoice, or below the previous one. </span><span class="koboSpan" id="kobo.111.5">Then, you take the third invoice and find a suitable place for it in the ordered stack. </span><span class="koboSpan" id="kobo.111.6">You perform this operation until there are no documents in the unsorted stack. </span><span class="koboSpan" id="kobo.111.7">Wow, another algorithm? </span><span class="koboSpan" id="kobo.111.8">Exactly! </span><span class="koboSpan" id="kobo.111.9">This is one of </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">sorting algorithms</span></strong><span class="koboSpan" id="kobo.113.1">. </span><span class="koboSpan" id="kobo.113.2">You'll learn about them in the </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">next chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">It’s time for a break at work! </span><span class="koboSpan" id="kobo.115.2">You launch your favorite social app and </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">receive suggestions for new friends</span></strong><span class="koboSpan" id="kobo.117.1">. </span><span class="koboSpan" id="kobo.117.2">However, how are they found and proposed to you? </span><span class="koboSpan" id="kobo.117.3">Yes, you’re right – this is another algorithm that takes data from your profile and your activities, as well </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.118.1">as the data of available users, as input, and returns a collection of best-suited suggestions for you. </span><span class="koboSpan" id="kobo.118.2">It can use many complex and advanced techniques, such as </span><strong class="bold"><span class="koboSpan" id="kobo.119.1">machine learning</span></strong><span class="koboSpan" id="kobo.120.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.121.1">ML</span></strong><span class="koboSpan" id="kobo.122.1">) algorithms, which can learn and take your previous reactions into account. </span><span class="koboSpan" id="kobo.122.2">Just think for a second about the data structures that can be used in such cases. </span><span class="koboSpan" id="kobo.122.3">How you can organize your relationships with friends and how can you find out how many other people are between you and your favorite actor from Hollywood? </span><span class="koboSpan" id="kobo.122.4">It would be great to know that your friend knows Mary, who knows Adam, who is a friend of your idol, wouldn’t it? </span><span class="koboSpan" id="kobo.122.5">Such a task can be accomplished using </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.123.1">some graph-based structures, as you will see later in </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">this book.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.125.1">Will you learn about AI algorithms in this book?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.126.1">Unfortunately, no. </span><span class="koboSpan" id="kobo.126.2">Due to the limited number of pages, various algorithms related to AI are not included in this book. </span><span class="koboSpan" id="kobo.126.3">However, note that it is a very interesting topic that involves many </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.127.1">concepts, such as </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">ML</span></strong><span class="koboSpan" id="kobo.129.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.130.1">deep learning</span></strong><span class="koboSpan" id="kobo.131.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.132.1">DL</span></strong><span class="koboSpan" id="kobo.133.1">), which are used in many applications, including recommendation systems, speech-to-text, searching </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.134.1">over extremely high amounts of data (the concept of </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">big data</span></strong><span class="koboSpan" id="kobo.136.1">), generating textual and graphical content, as well as controlling self-driving cars. </span><span class="koboSpan" id="kobo.136.2">To achieve these goals, a lot of interesting algorithms are used. </span><span class="koboSpan" id="kobo.136.3">I strongly encourage you to take a look at this topic on your own or choose one of Packt’s books that focuses on </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">AI-related topics.</span></span></p>
<p><span class="koboSpan" id="kobo.138.1">Are these examples enough? </span><span class="koboSpan" id="kobo.138.2">If not, just think about </span><strong class="bold"><span class="koboSpan" id="kobo.139.1">choosing a movie in a cinema for the evening</span></strong><span class="koboSpan" id="kobo.140.1"> while considering the AI-based suggestions of movies with geolocation-based data of cinemas, or </span><strong class="bold"><span class="koboSpan" id="kobo.141.1">setting a clock alarm</span></strong><span class="koboSpan" id="kobo.142.1"> depending on your plan for the next day. </span><span class="koboSpan" id="kobo.142.2">As you can see, </span><strong class="bold"><span class="koboSpan" id="kobo.143.1">algorithms are everywhere and all of us use them, even if we do not </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.144.1">realize it</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">So, if algorithms are so common and so useful, why don’t we benefit from the huge collection of ones that are available or even write our own algorithms? </span><span class="koboSpan" id="kobo.146.2">There are still some problems that need to be solved using algorithms. </span><span class="koboSpan" id="kobo.146.3">I, as the author of this book, am keeping my fingers crossed for you to </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">solve them!</span></span></p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.148.1">Notations for algorithm representation</span></h1>
<p><span class="koboSpan" id="kobo.149.1">In the </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.150.1">previous section, algorithms were presented in English. </span><span class="koboSpan" id="kobo.150.2">However, this is not the only way of specifying and documenting an algorithm. </span><span class="koboSpan" id="kobo.150.3">In this section, you will learn about four notations for algorithm representation, namely </span><strong class="bold"><span class="koboSpan" id="kobo.151.1">natural language</span></strong><span class="koboSpan" id="kobo.152.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">flowchart, pseudocode</span></strong><span class="koboSpan" id="kobo.154.1">, and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.155.1">programming language</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">To make this </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.158.1">task easier to understand, you will specify the algorithm for calculating an </span><strong class="bold"><span class="koboSpan" id="kobo.159.1">arithmetic mean</span></strong><span class="koboSpan" id="kobo.160.1"> in all of these notations. </span><span class="koboSpan" id="kobo.160.2">As a reminder, the mean can be calculated using the </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">following formula:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<span class="koboSpan" id="kobo.162.1"><img alt="Figure 2.2 – Formula for calculating an arithmetic mean" src="image/B18069_02_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.163.1">Figure 2.2 – Formula for calculating an arithmetic mean</span></p>
<p><span class="koboSpan" id="kobo.164.1">As you </span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.165.1">can see, two inputs are used, namely the provided numbers (</span><em class="italic"><span class="koboSpan" id="kobo.166.1">a</span></em><span class="koboSpan" id="kobo.167.1">) and the total number of elements (</span><em class="italic"><span class="koboSpan" id="kobo.168.1">n</span></em><span class="koboSpan" id="kobo.169.1">). </span><span class="koboSpan" id="kobo.169.2">If no numbers are provided, </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">null</span></strong><span class="koboSpan" id="kobo.171.1"> is returned, indicating that no mean is available. </span><span class="koboSpan" id="kobo.171.2">Otherwise, you sum the numbers and divide them by the total number of elements to get </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">the result.</span></span></p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.173.1">Natural language</span></h2>
<p><span class="koboSpan" id="kobo.174.1">First, let’s specify the algorithm using a natural language. </span><span class="koboSpan" id="kobo.174.2">It is a very easy way of providing </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.175.1">information about algorithms, but it can be ambiguous and unclear. </span><span class="koboSpan" id="kobo.175.2">So, let’s describe our algorithm in </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">this way:</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.177.1">The algorithm reads the input, which represents the total number of elements from which an arithmetic mean will be calculated. </span><span class="koboSpan" id="kobo.177.2">If the entered number is equal to 0, the algorithm should return null. </span><span class="koboSpan" id="kobo.177.3">Otherwise, it should read the numbers in the amount equal to the expected total count. </span><span class="koboSpan" id="kobo.177.4">Finally, it should return the result as the sum of numbers divided by </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.178.1">their count.</span></em></span></p>
<p><span class="koboSpan" id="kobo.179.1">Quite simple and understandable, isn’t it? </span><span class="koboSpan" id="kobo.179.2">You can use this notation for simple algorithms, but it can be useless for complex and advanced algorithms. </span><span class="koboSpan" id="kobo.179.3">Of course, some descriptions in the natural language are often useful, regardless of the complexity of an algorithm. </span><span class="koboSpan" id="kobo.179.4">They can give you a brief understanding of what the aim of the algorithm is, how it works, and what aspects should be taken into account while you’re analyzing or implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">the algorithm.</span></span></p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.181.1">Flowchart</span></h2>
<p><span class="koboSpan" id="kobo.182.1">Another way </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.183.1">of presenting an algorithm is via a </span><strong class="bold"><span class="koboSpan" id="kobo.184.1">flowchart</span></strong><span class="koboSpan" id="kobo.185.1">. </span><span class="koboSpan" id="kobo.185.2">A flowchart </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.186.1">uses a set of graphical elements to prepare a diagram that specifies the algorithm’s operation. </span><span class="koboSpan" id="kobo.186.2">Some of the available symbols are </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.188.1"><img alt="Figure 2.3 – The available symbols while designing a flowchart" src="image/B18069_02_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.189.1">Figure 2.3 – The available symbols while designing a flowchart</span></p>
<p><span class="koboSpan" id="kobo.190.1">The algorithm should contain the </span><strong class="bold"><span class="koboSpan" id="kobo.191.1">entry point</span></strong><span class="koboSpan" id="kobo.192.1"> and one or more </span><strong class="bold"><span class="koboSpan" id="kobo.193.1">exit points</span></strong><span class="koboSpan" id="kobo.194.1">. </span><span class="koboSpan" id="kobo.194.2">It can also contain other blocks, including </span><strong class="bold"><span class="koboSpan" id="kobo.195.1">operation</span></strong><span class="koboSpan" id="kobo.196.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.197.1">input</span></strong><span class="koboSpan" id="kobo.198.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.199.1">output</span></strong><span class="koboSpan" id="kobo.200.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.201.1">condition</span></strong><span class="koboSpan" id="kobo.202.1">. </span><span class="koboSpan" id="kobo.202.2">The following blocks are connected with </span><strong class="bold"><span class="koboSpan" id="kobo.203.1">arrows</span></strong><span class="koboSpan" id="kobo.204.1"> that specify the order of execution. </span><span class="koboSpan" id="kobo.204.2">You can also </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">draw </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.206.1">loops</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">Let’s take a look at a flowchart for calculating the </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">arithmetic mean:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.210.1"><img alt="Figure 2.4 – Flowchart for calculating the arithmetic mean" src="image/B18069_02_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.211.1">Figure 2.4 – Flowchart for calculating the arithmetic mean</span></p>
<p><span class="koboSpan" id="kobo.212.1">The execution starts in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">START</span></strong><span class="koboSpan" id="kobo.214.1"> block. </span><span class="koboSpan" id="kobo.214.2">Then, we assign </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">0</span></strong><span class="koboSpan" id="kobo.216.1"> as a value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">sum</span></strong><span class="koboSpan" id="kobo.218.1"> variable, which stores the sum of all the entered numbers. </span><span class="koboSpan" id="kobo.218.2">Next, we read a value from the input and </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.219.1">store it as a value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">n</span></strong><span class="koboSpan" id="kobo.221.1"> variable. </span><span class="koboSpan" id="kobo.221.2">This is the total number of elements used to calculate the arithmetic mean. </span><span class="koboSpan" id="kobo.221.3">Next, we check </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.222.1">whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">n</span></strong><span class="koboSpan" id="kobo.224.1"> is equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">0</span></strong><span class="koboSpan" id="kobo.226.1">. </span><span class="koboSpan" id="kobo.226.2">If so, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">YES</span></strong><span class="koboSpan" id="kobo.228.1"> branch is chosen, </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">null</span></strong><span class="koboSpan" id="kobo.230.1"> is returned to the output, and the execution stops. </span><span class="koboSpan" id="kobo.230.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">n</span></strong><span class="koboSpan" id="kobo.232.1"> is not equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">0</span></strong><span class="koboSpan" id="kobo.234.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">NO</span></strong><span class="koboSpan" id="kobo.236.1"> branch is chosen and we assign </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">0</span></strong><span class="koboSpan" id="kobo.238.1"> as a value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">i</span></strong><span class="koboSpan" id="kobo.240.1"> variable. </span><span class="koboSpan" id="kobo.240.2">It stores the number of elements already read from the input. </span><span class="koboSpan" id="kobo.240.3">Next, we read the number from the input and save it as a value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">a</span></strong><span class="koboSpan" id="kobo.242.1"> variable. </span><span class="koboSpan" id="kobo.242.2">The following operation block increases </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">sum</span></strong><span class="koboSpan" id="kobo.244.1"> by the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">a</span></strong><span class="koboSpan" id="kobo.246.1">, as well as increments the value </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">i</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">The next block is a conditional one that checks whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">i</span></strong><span class="koboSpan" id="kobo.252.1"> is not equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">n</span></strong><span class="koboSpan" id="kobo.254.1">, which means that the required number of elements is not read from the input yet. </span><span class="koboSpan" id="kobo.254.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">i</span></strong><span class="koboSpan" id="kobo.256.1"> is equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">n</span></strong><span class="koboSpan" id="kobo.258.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">NO</span></strong><span class="koboSpan" id="kobo.260.1"> branch is chosen and a value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">result</span></strong><span class="koboSpan" id="kobo.262.1"> variable is set to a result of a division of </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">sum</span></strong><span class="koboSpan" id="kobo.264.1"> by </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">n</span></strong><span class="koboSpan" id="kobo.266.1">. </span><span class="koboSpan" id="kobo.266.2">Then, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">result</span></strong><span class="koboSpan" id="kobo.268.1"> variable is returned and the execution stops. </span><span class="koboSpan" id="kobo.268.2">An interesting construction is used when the conditional expression evaluates to </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">true</span></strong><span class="koboSpan" id="kobo.270.1">, which means that we need to read another input. </span><span class="koboSpan" id="kobo.270.2">Then, the loop is used and the execution comes back just before the input block for reading </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">a</span></strong><span class="koboSpan" id="kobo.272.1">. </span><span class="koboSpan" id="kobo.272.2">Thus, we can execute some operations multiple times, until the condition </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">is met.</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">As you can see, a flowchart is a diagram that makes it possible to specify a way of algorithm operation in a more precise way than using natural language. </span><span class="koboSpan" id="kobo.274.2">It is an interesting option for simple algorithms, but it can be quite cumbersome in the case of advanced and complex ones, where it is impossible to present the whole operation within a diagram of a reasonably </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">small size.</span></span></p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.276.1">Pseudocode</span></h2>
<p><span class="koboSpan" id="kobo.277.1">The next </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.278.1">notation we’ll look at is </span><strong class="bold"><span class="koboSpan" id="kobo.279.1">pseudocode</span></strong><span class="koboSpan" id="kobo.280.1">. </span><span class="koboSpan" id="kobo.280.2">It allows you to specify algorithms </span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.281.1">in another way, which is a bit similar to the code written in a programming language. </span><span class="koboSpan" id="kobo.281.2">Here, we use the English language to define inputs and outputs, as well as to present a set of instructions clearly and concisely, but without the syntax of any </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">programming language.</span></span></p>
<p><span class="koboSpan" id="kobo.283.1">Here’s some example pseudocode for calculating the </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">arithmetic mean:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.285.1">INPUT:</span></strong><span class="koboSpan" id="kobo.286.1">
n – total number of elements used for mean calculation.
</span><span class="koboSpan" id="kobo.286.2">a – the following numbers entered by a user.
</span><strong class="bold"><span class="koboSpan" id="kobo.287.1">OUTPUT:</span></strong><span class="koboSpan" id="kobo.288.1">
result - arithmetic mean of the entered numbers.
</span><strong class="bold"><span class="koboSpan" id="kobo.289.1">INSTRUCTIONS:</span></strong><span class="koboSpan" id="kobo.290.1">
sum &lt;- 0
read n
if n = 0 then
   return null
endif
i &lt;- 0
do
   read a
   sum &lt;- sum + a
   i &lt;- i + 1
while i &lt;&gt; n
result &lt;- sum / n
return result</span></pre> <p><span class="koboSpan" id="kobo.291.1">As you </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.292.1">can see, the pseudocode provides us </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.293.1">with a syntax that is easy to understand and follow, as well as quite close to a programming language. </span><span class="koboSpan" id="kobo.293.2">For this reason, it is a precise way of algorithm presentation and documentation that can be later used to transform it into a set of instructions in our chosen </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">programming language.</span></span></p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.295.1">Programming language</span></h2>
<p><span class="koboSpan" id="kobo.296.1">Now, let’s look at the last form of algorithm notation: </span><strong class="bold"><span class="koboSpan" id="kobo.297.1">programming language</span></strong><span class="koboSpan" id="kobo.298.1">. </span><span class="koboSpan" id="kobo.298.2">It is very precise, can be compiled and run. </span><span class="koboSpan" id="kobo.298.3">Thus, we can see the result of its operation and check it using a set of test cases. </span><span class="koboSpan" id="kobo.298.4">Of course, we </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.299.1">can implement an algorithm in any programming language. </span><span class="koboSpan" id="kobo.299.2">However, in this book, you will see only examples in the </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">C# language.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">Let’s take a look at the implementation of the mean </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">calculation algorithm:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.303.1">
double sum = 0;
Console.Write("n = ");
int.TryParse(Console.ReadLine(), out int n);
if (n == 0) { Console.WriteLine("No result."); }
int i = 0;
do
{
    Console.Write("a = ");
    double.TryParse(Console.ReadLine(), out double a);
    sum += a;
    i++;
}
while (i != n);
double result = sum / n;
Console.WriteLine($"Result: {result:F2}");</span></pre> <p><span class="koboSpan" id="kobo.304.1">The preceding code contains an </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">if</span></strong><span class="koboSpan" id="kobo.306.1"> conditional statement and a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">do-while</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.308.1"> loop.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">If we run the application, we need to enter the number of elements from which we would like to calculate the arithmetic mean. </span><span class="koboSpan" id="kobo.309.2">Then, we will be asked to enter the number </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">n</span></strong><span class="koboSpan" id="kobo.311.1"> times. </span><span class="koboSpan" id="kobo.311.2">When the number of provided elements is equal to the expected value, the result is calculated and presented in the console, </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.313.1">
n = 3
a = 1
a = 5
a = 10
Result: 5.33</span></pre> <p><span class="koboSpan" id="kobo.314.1">That’s all! </span><span class="koboSpan" id="kobo.314.2">Now, you know what algorithms are, where you can find them in your </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.315.1">daily life, as well as how to represent algorithms </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.316.1">using natural language, flowcharts, pseudocode, and programming languages. </span><span class="koboSpan" id="kobo.316.2">With this knowledge, let’s proceed to learn about different types of algorithms, including recursive and </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">heuristic algorithms.</span></span></p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.318.1">Types of algorithms</span></h1>
<p><span class="koboSpan" id="kobo.319.1">As mentioned previously, algorithms are almost everywhere, and even intuitively, you use them each </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.320.1">day while solving various tasks. </span><span class="koboSpan" id="kobo.320.2">There is an enormous amount of algorithms and a lot of their types, chosen according to different criteria. </span><span class="koboSpan" id="kobo.320.3">To simplify this topic, only a few types will be presented here, chosen from different classifications, to show you a variety and encourage you to learn more about them on your own. </span><span class="koboSpan" id="kobo.320.4">It is also quite common that the same algorithm is classified into a </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">few groups.</span></span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.322.1">Recursive algorithms</span></h2>
<p><span class="koboSpan" id="kobo.323.1">First, let’s </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.324.1">take a look at </span><strong class="bold"><span class="koboSpan" id="kobo.325.1">recursive algorithms</span></strong><span class="koboSpan" id="kobo.326.1">, which </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.327.1">are strictly connected with the idea of </span><strong class="bold"><span class="koboSpan" id="kobo.328.1">recursion</span></strong><span class="koboSpan" id="kobo.329.1"> and are </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.330.1">the opposite of </span><strong class="bold"><span class="koboSpan" id="kobo.331.1">iterative algorithms</span></strong><span class="koboSpan" id="kobo.332.1">. </span><span class="koboSpan" id="kobo.332.2">What does this mean? </span><strong class="bold"><span class="koboSpan" id="kobo.333.1">An algorithm is recursive if it calls itself to solve smaller subproblems of the original problem</span></strong><span class="koboSpan" id="kobo.334.1">. </span><span class="koboSpan" id="kobo.334.2">The algorithm calls itself multiple times until the </span><strong class="bold"><span class="koboSpan" id="kobo.335.1">base condition</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.336.1">is met.</span></span></p>
<p><span class="koboSpan" id="kobo.337.1">This technique provides you with a powerful solution for solving problems, can limit the amount of code, and can be easy to understand and maintain. </span><span class="koboSpan" id="kobo.337.2">However, recursion has some drawbacks </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.338.1">related to performance or the requirement </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.339.1">for more space in the stack’s memory, which could lead to stack overflow problems. </span><span class="koboSpan" id="kobo.339.2">Fortunately, you can prevent some of these issues using </span><strong class="bold"><span class="koboSpan" id="kobo.340.1">dynamic programming</span></strong><span class="koboSpan" id="kobo.341.1">, an optimization technique that </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">supports recursion.</span></span></p>
<p><span class="koboSpan" id="kobo.343.1">Recursion can be used in several algorithms, including </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.345.1">Sorting an array with the </span><strong class="bold"><span class="koboSpan" id="kobo.346.1">merge sort</span></strong><span class="koboSpan" id="kobo.347.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.348.1">quicksort</span></strong><span class="koboSpan" id="kobo.349.1"> algorithms, which are implemented and presented in detail in </span><a href="B18069_03.xhtml#_idTextAnchor088"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.350.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.351.1">, </span><em class="italic"><span class="koboSpan" id="kobo.352.1">Arrays </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.353.1">and Sorting</span></em></span></li>
<li><span class="koboSpan" id="kobo.354.1">Solving the </span><strong class="bold"><span class="koboSpan" id="kobo.355.1">Towers of Hanoi</span></strong><span class="koboSpan" id="kobo.356.1"> game, as depicted in </span><a href="B18069_05.xhtml#_idTextAnchor165"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.357.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.358.1">, </span><em class="italic"><span class="koboSpan" id="kobo.359.1">Stacks </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.360.1">and Queues</span></em></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.361.1">Traversing a tree</span></strong><span class="koboSpan" id="kobo.362.1">, as described in </span><a href="B18069_07.xhtml#_idTextAnchor233"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.363.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.364.1">, </span><em class="italic"><span class="koboSpan" id="kobo.365.1">Variants </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.366.1">of Trees</span></em></span></li>
<li><span class="koboSpan" id="kobo.367.1">Getting a number from the </span><strong class="bold"><span class="koboSpan" id="kobo.368.1">Fibonacci series</span></strong><span class="koboSpan" id="kobo.369.1">, as shown in </span><a href="B18069_09.xhtml#_idTextAnchor367"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.370.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.371.1">, </span><em class="italic"><span class="koboSpan" id="kobo.372.1">See </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.373.1">in Action</span></em></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.374.1">Generating fractals</span></strong><span class="koboSpan" id="kobo.375.1">, as shown in </span><a href="B18069_09.xhtml#_idTextAnchor367"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.376.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.377.1">, </span><em class="italic"><span class="koboSpan" id="kobo.378.1">See </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.379.1">in Action</span></em></span></li>
<li><span class="koboSpan" id="kobo.380.1">Calculating a </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.381.1">factorial</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.382.1"> (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">n!</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.385.1">Getting the </span><strong class="bold"><span class="koboSpan" id="kobo.386.1">greatest common divisor of two numbers</span></strong><span class="koboSpan" id="kobo.387.1"> using the </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">Euclidean algorithm</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.389.1">Traversing the filesystem</span></strong><span class="koboSpan" id="kobo.390.1"> with directories </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">and subdirectories</span></span></li>
</ul>
<h2 id="_idParaDest-51"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.392.1">Divide and conquer algorithms</span></h2>
<p><span class="koboSpan" id="kobo.393.1">Another </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.394.1">group of algorithms is named </span><strong class="bold"><span class="koboSpan" id="kobo.395.1">divide and conquer</span></strong><span class="koboSpan" id="kobo.396.1">. </span><span class="koboSpan" id="kobo.396.2">It is </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.397.1">related to the </span><strong class="bold"><span class="koboSpan" id="kobo.398.1">algorithmic paradigm of solving a problem by breaking it down into smaller subproblems (the “divide” step), calling them recursively until they are simple enough to be solved directly (“conquer”), and combining the results of subproblems to get the final result (“combine”)</span></strong><span class="koboSpan" id="kobo.399.1">. </span><span class="koboSpan" id="kobo.399.2">This approach has many advantages, also taken from the pros of recursion, including ease of implementation, understanding, and maintenance. </span><span class="koboSpan" id="kobo.399.3">By dividing the problem into many subproblems, it supports </span><strong class="bold"><span class="koboSpan" id="kobo.400.1">parallel computing</span></strong><span class="koboSpan" id="kobo.401.1">, which </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.402.1">can lead to performance improvements. </span><span class="koboSpan" id="kobo.402.2">Unfortunately, this paradigm also has some disadvantages, including the necessity for a proper base case definition to terminate the execution of the algorithm. </span><span class="koboSpan" id="kobo.402.3">Performance issues, similar as in the case of recursive algorithms, can exist </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">Divide and </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.405.1">conquer is a popular approach for solving </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.406.1">various algorithmic problems and you can see its implementations in a broad range </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">of applications:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.408.1">Sorting an array with the </span><strong class="bold"><span class="koboSpan" id="kobo.409.1">m</span></strong><strong class="bold"><span class="koboSpan" id="kobo.410.1">erge sort</span></strong><span class="koboSpan" id="kobo.411.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.412.1">quicksort</span></strong><span class="koboSpan" id="kobo.413.1"> algorithms, which are implemented and presented in detail in </span><a href="B18069_03.xhtml#_idTextAnchor088"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.414.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.415.1">, </span><em class="italic"><span class="koboSpan" id="kobo.416.1">Arrays </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.417.1">and Sorting</span></em></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.418.1">Finding the closest pair of points</span></strong><span class="koboSpan" id="kobo.419.1"> located on the two-dimensional surface, which will be presented in </span><a href="B18069_09.xhtml#_idTextAnchor367"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.420.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.421.1">, </span><em class="italic"><span class="koboSpan" id="kobo.422.1">See </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.423.1">in Action</span></em></span></li>
<li><span class="koboSpan" id="kobo.424.1">Calculating the </span><strong class="bold"><span class="koboSpan" id="kobo.425.1">power of </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.426.1">a number</span></strong></span></li>
<li><span class="koboSpan" id="kobo.427.1">Finding the </span><strong class="bold"><span class="koboSpan" id="kobo.428.1">minimum and maximum values</span></strong><span class="koboSpan" id="kobo.429.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">an array</span></span></li>
<li><span class="koboSpan" id="kobo.431.1">Calculating the </span><strong class="bold"><span class="koboSpan" id="kobo.432.1">fast </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.433.1">Fourier transform</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.434.1">Multiplying large numbers</span></strong><span class="koboSpan" id="kobo.435.1"> using </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">Karatsuba’s algorithm</span></span></li>
</ul>
<h2 id="_idParaDest-52"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.437.1">Back-tracking algorithms</span></h2>
<p><span class="koboSpan" id="kobo.438.1">Next, we’ll </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.439.1">cover </span><strong class="bold"><span class="koboSpan" id="kobo.440.1">back-tracking algorithms</span></strong><span class="koboSpan" id="kobo.441.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.442.1">They are used for solving problems that consist of a sequence of decisions, each depending on the decisions that have already been taken, incrementally building the solution. </span><span class="koboSpan" id="kobo.442.2">When you realize that the decisions that have been taken do not provide the correct solution, you </span></strong><strong class="bold"><span class="koboSpan" id="kobo.443.1">backtrack</span></strong><span class="koboSpan" id="kobo.444.1">. </span><span class="koboSpan" id="kobo.444.2">Of course, you can </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.445.1">support this approach with recursion to try various variants and therefore find a suitable solution, if </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">one exists.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">You can use this approach for many tasks, including </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.449.1">Solving the </span><strong class="bold"><span class="koboSpan" id="kobo.450.1">rat in a maze</span></strong><span class="koboSpan" id="kobo.451.1"> problem, as shown in </span><a href="B18069_09.xhtml#_idTextAnchor367"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.452.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.453.1">, </span><em class="italic"><span class="koboSpan" id="kobo.454.1">See </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.455.1">in Action</span></em></span></li>
<li><span class="koboSpan" id="kobo.456.1">Solving </span><strong class="bold"><span class="koboSpan" id="kobo.457.1">Sudoku</span></strong><span class="koboSpan" id="kobo.458.1">, as shown in </span><a href="B18069_09.xhtml#_idTextAnchor367"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.459.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.460.1">, </span><em class="italic"><span class="koboSpan" id="kobo.461.1">See </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.462.1">in Action</span></em></span></li>
<li><span class="koboSpan" id="kobo.463.1">Solving </span><strong class="bold"><span class="koboSpan" id="kobo.464.1">crosswords</span></strong><span class="koboSpan" id="kobo.465.1"> by entering letters into </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">empty spaces</span></span></li>
<li><span class="koboSpan" id="kobo.467.1">Solving the </span><strong class="bold"><span class="koboSpan" id="kobo.468.1">eight queens </span></strong><span class="koboSpan" id="kobo.469.1">problem of placing eight queens on a chessboard and not </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.470.1">allowing them to attack </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">each other</span></span></li>
<li><span class="koboSpan" id="kobo.472.1">Solving the </span><strong class="bold"><span class="koboSpan" id="kobo.473.1">knight’s tour</span></strong><span class="koboSpan" id="kobo.474.1">, where you place a knight on the first block on a chessboard </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.475.1">and move it so that it visits all blocks </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">exactly once</span></span></li>
<li><span class="koboSpan" id="kobo.477.1">Generating </span><strong class="bold"><span class="koboSpan" id="kobo.478.1">gray codes</span></strong><span class="koboSpan" id="kobo.479.1"> to create bit patterns where the following ones differ by one </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">bit only</span></span></li>
<li><span class="koboSpan" id="kobo.481.1">Solving the </span><strong class="bold"><span class="koboSpan" id="kobo.482.1">m-coloring problem</span></strong><span class="koboSpan" id="kobo.483.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">graph-related topics</span></span></li>
</ul>
<h2 id="_idParaDest-53"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.485.1">Greedy algorithms</span></h2>
<p><span class="koboSpan" id="kobo.486.1">Now that </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.487.1">we’ve covered the recursive, divide-and-conquer, and back-tracking </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.488.1">algorithms, it’s high time to present another type, namely greedy algorithms. </span><strong class="bold"><span class="koboSpan" id="kobo.489.1">A </span></strong><strong class="bold"><span class="koboSpan" id="kobo.490.1">greedy algorithm</span></strong><strong class="bold"><span class="koboSpan" id="kobo.491.1"> builds the solution piece by piece by choosing the best option in each step, not concerned about the overall solution, and being short-sighted in its operation</span></strong><span class="koboSpan" id="kobo.492.1">. </span><span class="koboSpan" id="kobo.492.2">For this reason, there is no guarantee that the final result is optimal. </span><span class="koboSpan" id="kobo.492.3">However, in many scenarios, using the local optimal solutions can lead to global optimal solutions or can be </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">good enough.</span></span></p>
<p><span class="koboSpan" id="kobo.494.1">Here are </span><a id="_idIndexMarker206"/><span class="No-Break"><span class="koboSpan" id="kobo.495.1">some examples:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.496.1">Finding the shortest path in a graph using </span><strong class="bold"><span class="koboSpan" id="kobo.497.1">Dijkstra’s algorithm</span></strong><span class="koboSpan" id="kobo.498.1">, as shown and explained in detail in </span><a href="B18069_08.xhtml#_idTextAnchor296"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.499.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.500.1">, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.501.1">Exploring Graphs</span></em></span></li>
<li><span class="koboSpan" id="kobo.502.1">Calculating the minimum spanning tree in a graph with </span><strong class="bold"><span class="koboSpan" id="kobo.503.1">Kruskal’s algorithm</span></strong><span class="koboSpan" id="kobo.504.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.505.1">Prim’s algorithm</span></strong><span class="koboSpan" id="kobo.506.1">, as shown in </span><a href="B18069_08.xhtml#_idTextAnchor296"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.507.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.508.1">, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.509.1">Exploring Graphs</span></em></span></li>
<li><span class="koboSpan" id="kobo.510.1">Solving the </span><strong class="bold"><span class="koboSpan" id="kobo.511.1">minimum coin change</span></strong><span class="koboSpan" id="kobo.512.1"> problem, as explained in </span><a href="B18069_09.xhtml#_idTextAnchor367"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.513.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.514.1">, </span><em class="italic"><span class="koboSpan" id="kobo.515.1">See </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.516.1">in Action</span></em></span></li>
<li><span class="koboSpan" id="kobo.517.1">The greedy approach to </span><strong class="bold"><span class="koboSpan" id="kobo.518.1">Huffman coding</span></strong><span class="koboSpan" id="kobo.519.1"> in </span><strong class="bold"><span class="koboSpan" id="kobo.520.1">data </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.521.1">compression algorithms</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.522.1">Load balancing</span></strong><span class="koboSpan" id="kobo.523.1"> and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.524.1">network routing</span></strong></span></li>
</ul>
<h2 id="_idParaDest-54"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.525.1">Heuristic algorithms</span></h2>
<p><span class="koboSpan" id="kobo.526.1">Now, it’s time </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.527.1">to add more “magic” to your algorithms via heuristics! </span><strong class="bold"><span class="koboSpan" id="kobo.528.1">A </span></strong><strong class="bold"><span class="koboSpan" id="kobo.529.1">heuristic algorithm</span></strong><strong class="bold"><span class="koboSpan" id="kobo.530.1"> calculates a near-optimal solution for an optimization problem and is especially useful for scenarios when the exact methods are not available or are too slow. </span><span class="koboSpan" id="kobo.530.2">Thus, you can see a significant speed boost, but with a decreased accuracy of the result.</span></strong><span class="koboSpan" id="kobo.531.1"> Such an approach is popular and </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.532.1">adequate for solving various real-world problems, often complex and big, and is applied in many different fields of science, even those </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">regarding bioinformatics.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">Heuristic </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.535.1">algorithms have many applications </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">and subtypes:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.537.1">Genetic algorithms</span></strong><span class="koboSpan" id="kobo.538.1">, which are </span><strong class="bold"><span class="koboSpan" id="kobo.539.1">adaptive heuristic search algorithms</span></strong><span class="koboSpan" id="kobo.540.1">, and </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.541.1">can be used to guess the title of this book, as depicted in </span><a href="B18069_09.xhtml#_idTextAnchor367"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.542.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.543.1">, </span><em class="italic"><span class="koboSpan" id="kobo.544.1">See </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.545.1">in Action</span></em></span></li>
<li><span class="koboSpan" id="kobo.546.1">Solving </span><strong class="bold"><span class="koboSpan" id="kobo.547.1">vehicle routing problems</span></strong><span class="koboSpan" id="kobo.548.1"> and the </span><strong class="bold"><span class="koboSpan" id="kobo.549.1">traveling salesman problem</span></strong><span class="koboSpan" id="kobo.550.1"> with the </span><strong class="bold"><span class="koboSpan" id="kobo.551.1">Tabu </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.552.1">Search algorithm</span></strong></span></li>
<li><span class="koboSpan" id="kobo.553.1">Solving the </span><strong class="bold"><span class="koboSpan" id="kobo.554.1">Knapsack problem</span></strong><span class="koboSpan" id="kobo.555.1">, where you need to choose items of the maximum total value to be packed within the </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">mass limit</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.557.1">Filtering and </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.558.1">processing signals</span></strong></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.559.1">Detecting viruses</span></strong></span></li>
</ul>
<h2 id="_idParaDest-55"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.560.1">Dynamic programming</span></h2>
<p><span class="koboSpan" id="kobo.561.1">Since we’re </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.562.1">talking about various types of algorithms, it is </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.563.1">worth mentioning </span><strong class="bold"><span class="koboSpan" id="kobo.564.1">dynamic programming</span></strong><span class="koboSpan" id="kobo.565.1">. </span><span class="koboSpan" id="kobo.565.2">It is a </span><strong class="bold"><span class="koboSpan" id="kobo.566.1">technique that optimizes recursive algorithms by limiting the necessity of computing the same result multiple times</span></strong><span class="koboSpan" id="kobo.567.1">. </span><span class="koboSpan" id="kobo.567.2">This technique can be used in one of </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">two approaches:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.569.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.570.1">top-down approach</span></strong><span class="koboSpan" id="kobo.571.1">, which </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.572.1">uses </span><strong class="bold"><span class="koboSpan" id="kobo.573.1">memoization</span></strong><span class="koboSpan" id="kobo.574.1"> to save </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.575.1">the results of subproblems. </span><span class="koboSpan" id="kobo.575.2">Therefore, the </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.576.1">algorithm can use the value from the cache and does not need to recalculate the same results multiple times or does not need to call the method with the same parameters </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">multiple times.</span></span></li>
<li><span class="koboSpan" id="kobo.578.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.579.1">bottom-up approach</span></strong><span class="koboSpan" id="kobo.580.1">, which uses </span><strong class="bold"><span class="koboSpan" id="kobo.581.1">tabulation</span></strong><span class="koboSpan" id="kobo.582.1"> to </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.583.1">replace recursion </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.584.1">with iteration. </span><span class="koboSpan" id="kobo.584.2">It limits the number </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.585.1">of function calls and problems regarding </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">stack overflow.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.587.1">Both of </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.588.1">these approaches can significantly decrease the time complexity and increase performance, and therefore speed up </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.589.1">your algorithm. </span><span class="koboSpan" id="kobo.589.2">Every time you use recursion, it is a good idea to try to optimize it using dynamic programming. </span><span class="koboSpan" id="kobo.589.3">If you want to learn how to optimize calculating a number from the </span><strong class="bold"><span class="koboSpan" id="kobo.590.1">Fibonacci series</span></strong><span class="koboSpan" id="kobo.591.1">, go to </span><a href="B18069_09.xhtml#_idTextAnchor367"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.592.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.593.1">, </span><em class="italic"><span class="koboSpan" id="kobo.594.1">See </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.595.1">in Action</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.597.1">You can also use dynamic programming to find the </span><strong class="bold"><span class="koboSpan" id="kobo.598.1">shortest path between all pairs of vertices in a graph</span></strong><span class="koboSpan" id="kobo.599.1"> by using the </span><strong class="bold"><span class="koboSpan" id="kobo.600.1">Floyd-Warshall algorithm</span></strong><span class="koboSpan" id="kobo.601.1">, as well as in </span><strong class="bold"><span class="koboSpan" id="kobo.602.1">Dijkstra’s algorithm</span></strong><span class="koboSpan" id="kobo.603.1">. </span><span class="koboSpan" id="kobo.603.2">Another application is for solving the </span><strong class="bold"><span class="koboSpan" id="kobo.604.1">Tower of Hanoi</span></strong><span class="koboSpan" id="kobo.605.1"> mathematical game. </span><span class="koboSpan" id="kobo.605.2">Possibilities are even broader and you can also apply it to </span><strong class="bold"><span class="koboSpan" id="kobo.606.1">artificial </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.607.1">neural networks</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">.</span></span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.609.1">Brute-force algorithms</span></h2>
<p><span class="koboSpan" id="kobo.610.1">While we’re </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.611.1">presenting various types of algorithms, we should also consider brute-force algorithms. </span><strong class="bold"><span class="koboSpan" id="kobo.612.1">A </span></strong><strong class="bold"><span class="koboSpan" id="kobo.613.1">brute-force algorithm</span></strong><strong class="bold"><span class="koboSpan" id="kobo.614.1"> is a general solution for solving a problem by checking all possible options and choosing the best one</span></strong><span class="koboSpan" id="kobo.615.1">. </span><span class="koboSpan" id="kobo.615.2">It is an approach that can have huge time complexity and its operation </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.616.1">can take a lot of time, so it can be useless in real-world scenarios. </span><span class="koboSpan" id="kobo.616.2">However, a brute-force algorithm is often the first choice when you need to solve some algorithmic problem. </span><span class="koboSpan" id="kobo.616.3">There’s nothing bad in doing this as you can learn more about the domain of the problem you wish to solve and see some results for simpler cases. </span><span class="koboSpan" id="kobo.616.4">Nevertheless, while developing an algorithm, it is a good idea to enhance it significantly by using </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">other paradigms.</span></span></p>
<p><span class="koboSpan" id="kobo.618.1">Here are some </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.619.1">examples of where you can use </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">brute-force algorithms:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.621.1">Guessing a password</span></strong><span class="koboSpan" id="kobo.622.1">, where you check each possible password one after the other, as presented in </span><a href="B18069_09.xhtml#_idTextAnchor367"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.623.1">Chapter 9</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.624.1">,</span></em> <em class="italic"><span class="koboSpan" id="kobo.625.1">See </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.626.1">in Action</span></em></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.627.1">Finding the minimum value in an unsorted array</span></strong><span class="koboSpan" id="kobo.628.1">, where you need to iterate through all items as there is no relationship between values in </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">the array</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.630.1">Finding the best possible plan for a day</span></strong><span class="koboSpan" id="kobo.631.1">, placing various tasks between meetings, and </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.632.1">trying to organize it in a way that you can start working late and </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">ending early</span></span></li>
<li><span class="koboSpan" id="kobo.634.1">Solving the </span><strong class="bold"><span class="koboSpan" id="kobo.635.1">traveling </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.636.1">salesman</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.637.1"> problem</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.638.1">After introducing a few types of algorithms, you can see that some of them provide you with a faster solution while others can have huge time complexity. </span><span class="koboSpan" id="kobo.638.2">But what does this mean? </span><span class="koboSpan" id="kobo.638.3">You will learn about computational complexity, especially time complexity, in the </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">next section.</span></span></p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.640.1">Computational complexity</span></h1>
<p><span class="koboSpan" id="kobo.641.1">In this final section, let’s take a look at the </span><strong class="bold"><span class="koboSpan" id="kobo.642.1">computational complexity</span></strong><span class="koboSpan" id="kobo.643.1"> of algorithms, focusing </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.644.1">on both </span><strong class="bold"><span class="koboSpan" id="kobo.645.1">time complexity</span></strong><span class="koboSpan" id="kobo.646.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.647.1">space complexity</span></strong><span class="koboSpan" id="kobo.648.1">. </span><span class="koboSpan" id="kobo.648.2">Why is this so important? </span><span class="koboSpan" id="kobo.648.3">Because it can decide whether your algorithm can be used in real-world scenarios. </span><span class="koboSpan" id="kobo.648.4">As an example, which of the following do </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">you prefer?</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.650.1">(A) Absolutely the best route directions to work, but you receive them after an hour, when you are already </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.651.1">at work.</span></em></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.652.1">(B) Good enough route directions to work, but you receive them within a few seconds, a moment after you enter </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.653.1">your car.</span></em></span></li>
</ul>
<p><span class="koboSpan" id="kobo.654.1">I am sure that you chose </span><em class="italic"><span class="koboSpan" id="kobo.655.1">B</span></em><span class="koboSpan" id="kobo.656.1"> – </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">me too!</span></span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.658.1">Time complexity</span></h2>
<p><span class="koboSpan" id="kobo.659.1">First, let’s </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.660.1">focus on </span><strong class="bold"><span class="koboSpan" id="kobo.661.1">time complexity</span></strong><span class="koboSpan" id="kobo.662.1">, which </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.663.1">indicates </span><strong class="bold"><span class="koboSpan" id="kobo.664.1">the amount of time necessary to run an algorithm as a function of the input length</span></strong><span class="koboSpan" id="kobo.665.1">, namely </span><em class="italic"><span class="koboSpan" id="kobo.666.1">n</span></em><span class="koboSpan" id="kobo.667.1">. </span><span class="koboSpan" id="kobo.667.2">You can specify </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.668.1">it using </span><strong class="bold"><span class="koboSpan" id="kobo.669.1">asymptotic analysis</span></strong><span class="koboSpan" id="kobo.670.1">. </span><span class="koboSpan" id="kobo.670.2">This includes </span><strong class="bold"><span class="koboSpan" id="kobo.671.1">Big-O notation</span></strong><span class="koboSpan" id="kobo.672.1">, which is </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.673.1">used to indicate </span><strong class="bold"><span class="koboSpan" id="kobo.674.1">how much time the algorithm will take with the increasing size of </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.675.1">the input</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.677.1">For example, if you search for the minimum value in an unsorted array of size </span><em class="italic"><span class="koboSpan" id="kobo.678.1">n</span></em><span class="koboSpan" id="kobo.679.1">, you need to visit all elements so that the maximum number of operations is equal to </span><em class="italic"><span class="koboSpan" id="kobo.680.1">n</span></em><span class="koboSpan" id="kobo.681.1">, which is written as </span><em class="italic"><span class="koboSpan" id="kobo.682.1">O(n)</span></em><span class="koboSpan" id="kobo.683.1">. </span><span class="koboSpan" id="kobo.683.2">If the algorithm iterates through each item in a two-dimensional array of size </span><em class="italic"><span class="koboSpan" id="kobo.684.1">n x n</span></em><span class="koboSpan" id="kobo.685.1">, the time complexity is </span><em class="italic"><span class="koboSpan" id="kobo.686.1">O(n*n)</span></em><span class="koboSpan" id="kobo.687.1">, so it </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">is </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.689.1">O(n</span></em></span><span class="No-Break"><span class="superscript"><span class="koboSpan" id="kobo.690.1">2</span></span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.691.1">)</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.693.1">There are </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.694.1">various time complexities, including </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.695.1">the ones </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">presented here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.697.1"><img alt="Figure 2.5 – Illustration of time complexities" src="image/B18069_02_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.698.1">Figure 2.5 – Illustration of time complexities</span></p>
<p><span class="koboSpan" id="kobo.699.1">The first is </span><strong class="bold"><span class="koboSpan" id="kobo.700.1">O(1)</span></strong><span class="koboSpan" id="kobo.701.1"> and is named the </span><strong class="bold"><span class="koboSpan" id="kobo.702.1">constant time</span></strong><span class="koboSpan" id="kobo.703.1">. </span><span class="koboSpan" id="kobo.703.2">It indicates an algorithm whose execution time does </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.704.1">not depend on the input size. </span><span class="koboSpan" id="kobo.704.2">The exemplary operations consistent with the </span><em class="italic"><span class="koboSpan" id="kobo.705.1">O(1)</span></em><span class="koboSpan" id="kobo.706.1"> constraint are getting an </span><em class="italic"><span class="koboSpan" id="kobo.707.1">i</span></em><span class="koboSpan" id="kobo.708.1">-th element from an array, checking whether a hash set contains a given value, or checking whether a number is even </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">or odd.</span></span></p>
<p><span class="koboSpan" id="kobo.710.1">The next time </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.711.1">complexity shown here is </span><strong class="bold"><span class="koboSpan" id="kobo.712.1">O(log n)</span></strong><span class="koboSpan" id="kobo.713.1">, which is named the </span><strong class="bold"><span class="koboSpan" id="kobo.714.1">logarithmic time</span></strong><span class="koboSpan" id="kobo.715.1">. </span><span class="koboSpan" id="kobo.715.2">In this case, the execution time is not constant, but it increases slower than in the linear approach. </span><span class="koboSpan" id="kobo.715.3">A well-known example of the </span><em class="italic"><span class="koboSpan" id="kobo.716.1">O(log n)</span></em><span class="koboSpan" id="kobo.717.1"> constraint is the problem of finding an item in a sorted array with </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">binary search.</span></span></p>
<p><span class="koboSpan" id="kobo.719.1">The third case is </span><strong class="bold"><span class="koboSpan" id="kobo.720.1">O(n)</span></strong><span class="koboSpan" id="kobo.721.1"> and is </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.722.1">named the </span><strong class="bold"><span class="koboSpan" id="kobo.723.1">linear time</span></strong><span class="koboSpan" id="kobo.724.1">. </span><span class="koboSpan" id="kobo.724.2">Here, the execution time increases linearly with the input length. </span><span class="koboSpan" id="kobo.724.3">You can take an algorithm for finding the minimum or maximum value in an unordered list or simply finding a given value in an unordered list as examples of the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.725.1">O(n)</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.726.1"> constraint.</span></span></p>
<p><span class="koboSpan" id="kobo.727.1">The last time complexity </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.728.1">shown here is the </span><strong class="bold"><span class="koboSpan" id="kobo.729.1">polynomial time</span></strong><span class="koboSpan" id="kobo.730.1">, which is </span><strong class="bold"><span class="koboSpan" id="kobo.731.1">O(n</span></strong><span class="superscript"><span class="koboSpan" id="kobo.732.1">m</span></span><strong class="bold"><span class="koboSpan" id="kobo.733.1">)</span></strong><span class="koboSpan" id="kobo.734.1">, so it </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.735.1">can be </span><em class="italic"><span class="koboSpan" id="kobo.736.1">O(n</span></em><span class="superscript"><span class="koboSpan" id="kobo.737.1">2</span></span><em class="italic"><span class="koboSpan" id="kobo.738.1">)</span></em><span class="koboSpan" id="kobo.739.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.740.1">quadratic time</span></strong><span class="koboSpan" id="kobo.741.1">), </span><em class="italic"><span class="koboSpan" id="kobo.742.1">O(n</span></em><span class="superscript"><span class="koboSpan" id="kobo.743.1">3</span></span><em class="italic"><span class="koboSpan" id="kobo.744.1">)</span></em><span class="koboSpan" id="kobo.745.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.746.1">cubic time</span></strong><span class="koboSpan" id="kobo.747.1">), and so </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.748.1">on. </span><span class="koboSpan" id="kobo.748.2">In this case, the execution time increases much faster than in the case of the linear constraint. </span><span class="koboSpan" id="kobo.748.3">It can involve solutions that use nested loops. </span><span class="koboSpan" id="kobo.748.4">Examples include the bubble sort, insertion sort, and selection sort algorithms. </span><span class="koboSpan" id="kobo.748.5">We'll </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.749.1">cover </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.750.1">these in </span><a href="B18069_03.xhtml#_idTextAnchor088"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.751.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.752.1">, </span><em class="italic"><span class="koboSpan" id="kobo.753.1">Arrays </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.754.1">and Sorting</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.756.1">Of </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.757.1">course, there </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.758.1">are even </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.759.1">more time complexities </span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.760.1">available, among </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.761.1">which </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.762.1">you will find </span><strong class="bold"><span class="koboSpan" id="kobo.763.1">double logarithmic time</span></strong><span class="koboSpan" id="kobo.764.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.765.1">polylogarithmic time</span></strong><span class="koboSpan" id="kobo.766.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.767.1">fractional power time</span></strong><span class="koboSpan" id="kobo.768.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.769.1">linearithmic time</span></strong><span class="koboSpan" id="kobo.770.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.771.1">exponential time</span></strong><span class="koboSpan" id="kobo.772.1">, and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.773.1">factorial time</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">.</span></span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.775.1">Space complexity</span></h2>
<p><span class="koboSpan" id="kobo.776.1">Similar to </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.777.1">time complexity, you can specify the </span><strong class="bold"><span class="koboSpan" id="kobo.778.1">space complexity</span></strong><span class="koboSpan" id="kobo.779.1"> using </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.780.1">asymptotic analysis and the Big-O notation. </span><span class="koboSpan" id="kobo.780.2">Space complexity indicates </span><strong class="bold"><span class="koboSpan" id="kobo.781.1">how much memory is necessary to run the algorithm with the increasing </span><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.782.1">length of input</span></strong><span class="koboSpan" id="kobo.783.1">. </span><span class="koboSpan" id="kobo.783.2">You can use similar indicators, such as </span><em class="italic"><span class="koboSpan" id="kobo.784.1">O(1)</span></em><span class="koboSpan" id="kobo.785.1">, </span><em class="italic"><span class="koboSpan" id="kobo.786.1">O(n)</span></em><span class="koboSpan" id="kobo.787.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">or </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.789.1">O(n</span></em></span><span class="No-Break"><span class="superscript"><span class="koboSpan" id="kobo.790.1">2</span></span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.791.1">)</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.793.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.794.1">In this chapter, only a very brief introduction to the subject of algorithms was presented. </span><span class="koboSpan" id="kobo.794.2">I strongly encourage you to try to broaden your knowledge regarding algorithms on your own. </span><span class="koboSpan" id="kobo.794.3">It is an extremely interesting and challenging topic. </span><span class="koboSpan" id="kobo.794.4">For example, you can learn more about various types of algorithms at </span><a href="https://www.techtarget.com/whatis/definition/algorithm"><span class="koboSpan" id="kobo.795.1">https://www.techtarget.com/whatis/definition/algorithm</span></a><span class="koboSpan" id="kobo.796.1"> and at </span><a href="https://www.geeksforgeeks.org/most-important-type-of-algorithms/"><span class="koboSpan" id="kobo.797.1">https://www.geeksforgeeks.org/most-important-type-of-algorithms/</span></a><span class="koboSpan" id="kobo.798.1">, while about the computational complexity at </span><a href="https://en.wikipedia.org/wiki/Computational_complexity"><span class="koboSpan" id="kobo.799.1">https://en.wikipedia.org/wiki/Computational_complexity</span></a><span class="koboSpan" id="kobo.800.1">. </span><span class="koboSpan" id="kobo.800.2">I am keeping my fingers crossed for you success </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">with algorithms!</span></span></p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.802.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.803.1">You’ve just completed the second chapter of this book, which was all about data structures and algorithms in the C# language. </span><span class="koboSpan" id="kobo.803.2">This time, we focused on algorithms and indicated their crucial role in the development of various applications, regardless of </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">their types.</span></span></p>
<p><span class="koboSpan" id="kobo.805.1">First, you learned </span><strong class="bold"><span class="koboSpan" id="kobo.806.1">what an algorithm is</span></strong><span class="koboSpan" id="kobo.807.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.808.1">where you can find algorithms</span></strong><span class="koboSpan" id="kobo.809.1"> in your daily life. </span><span class="koboSpan" id="kobo.809.2">As you saw, algorithms are almost everywhere and you use and design them without even </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">knowing it.</span></span></p>
<p><span class="koboSpan" id="kobo.811.1">Then, you learned about </span><strong class="bold"><span class="koboSpan" id="kobo.812.1">notations for algorithm representation</span></strong><span class="koboSpan" id="kobo.813.1">. </span><span class="koboSpan" id="kobo.813.2">There, you learned how to specify algorithms in a few ways, namely in a natural language, using a flowchart, via pseudocode, or directly in a </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">programming language.</span></span></p>
<p><span class="koboSpan" id="kobo.815.1">Next, you learned </span><strong class="bold"><span class="koboSpan" id="kobo.816.1">about a few different types of algorithms</span></strong><span class="koboSpan" id="kobo.817.1">, starting with the recursive algorithms that call themselves to solve smaller subproblems. </span><span class="koboSpan" id="kobo.817.2">Then, you learned about </span><strong class="bold"><span class="koboSpan" id="kobo.818.1">divide and conquer</span></strong><span class="koboSpan" id="kobo.819.1"> algorithms, which divide the problem into three stages, namely divide, conquer, and combine. </span><span class="koboSpan" id="kobo.819.2">Next, you learned about </span><strong class="bold"><span class="koboSpan" id="kobo.820.1">back-tracking</span></strong><span class="koboSpan" id="kobo.821.1"> algorithms, which allow you to solve problems consisting of a sequence of decisions, each depending on a decision that’s already been taken, together with the backtrack option if the decisions do not provide a correct solution. </span><span class="koboSpan" id="kobo.821.2">Then, you learned about </span><strong class="bold"><span class="koboSpan" id="kobo.822.1">greedy</span></strong><span class="koboSpan" id="kobo.823.1"> algorithms, which choose the best option in each step of their operation while not being concerned about the overall solution. </span><span class="koboSpan" id="kobo.823.2">Another group you learned about was </span><strong class="bold"><span class="koboSpan" id="kobo.824.1">heuristic</span></strong><span class="koboSpan" id="kobo.825.1"> algorithms for finding near-optimal solutions. </span><span class="koboSpan" id="kobo.825.2">Then, you learned that you can optimize recursive algorithms using </span><strong class="bold"><span class="koboSpan" id="kobo.826.1">dynamic programming</span></strong><span class="koboSpan" id="kobo.827.1"> and its top-down and bottom-up approaches. </span><span class="koboSpan" id="kobo.827.2">Finally, you learned about </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.828.1">brute-force</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.829.1"> algorithms.</span></span></p>
<p><span class="koboSpan" id="kobo.830.1">The final part of this chapter looked at </span><strong class="bold"><span class="koboSpan" id="kobo.831.1">computational complexity</span></strong><span class="koboSpan" id="kobo.832.1"> in terms of time and space complexity. </span><span class="koboSpan" id="kobo.832.2">Asymptotic analysis, together with Big-O notation, </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">was presented.</span></span></p>
<p><span class="koboSpan" id="kobo.834.1">In the next chapter, we’ll cover </span><strong class="bold"><span class="koboSpan" id="kobo.835.1">arrays</span></strong><span class="koboSpan" id="kobo.836.1"> and various </span><strong class="bold"><span class="koboSpan" id="kobo.837.1">sorting algorithms</span></strong><span class="koboSpan" id="kobo.838.1">. </span><span class="koboSpan" id="kobo.838.2">Are you ready to continue your adventure with data structures and algorithms in the C# language? </span><span class="koboSpan" id="kobo.838.3">If so, </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">let’s go!</span></span></p>
</div>
</body></html>