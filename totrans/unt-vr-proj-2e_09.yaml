- en: Exploring Interactive Spaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll dig a bit more into level design, modeling, rendering,
    teleporting, and animation; implementing an interactive space you can experience
    in VR. The scene is a photo gallery, where you design a simple floor plan and
    use a Blender to extrude it vertically into the walls. Use your own photos.  You
    can move around the space via teleport or an animated ride through.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Blender and Unity to build a simplistic art gallery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with objects and metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data structures, lists, and scriptable objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using teleportation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an animated walkthrough
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the projects in this chapter are separate and not directly required
    by the other chapters in this book. If you decide to skip any of it or not save
    your work, that's OK.
  prefs: []
  type: TYPE_NORMAL
- en: Level design with Blender
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this project, we're going to design an art gallery layout. We just need
    something simple, a small art gallery exhibit room about 24 by 36 feet. The room
    is so simple, in fact, it could easily be built within Unity using 3D cube primitives,
    but we'll take this opportunity to use Blender a little more since we introduced
    it in [Chapter 2](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml), *Content, Objects,
    and Scale,* keeping it minimal and instructive. If you prefer, you can skip this
    section and build the floor and walls using Unity cubes. Or, use the `Gallery.blend`
    file provided in the files for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the walls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start, draw a simple floor plan on a piece of paper or use a drawing app.
    Mine is just an open space with two entrances and interior walls to display artwork
    (`Gallery-floorplan.jpg`), which looks like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/842f96cf-0055-4ab1-aa1b-3b03570ee2c7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, open Blender. We''ll use a common technique of starting with a simple
    object (plane) and then extruding it to make each of the wall segments. To accomplish
    this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with an empty scene, press the A key to select all, and then press the
    X key to delete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the floor plan image for reference by pressing the N key to open the properties
    panel. In the Background Images pane, select Add Image, click on Open and select
    your image (`Gallery-floorplan.jpg`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Depending on the size and scale of your floor plan reference image, you'll want
    to choose a scale factor so that it's correct in the Blender world coordinate
    space. A scale of `6.25` works for me. Actually, the most important thing is the
    relative scale of the features in the diagram, since we can always adjust the
    scale in Unity in the Import settings, or even in the Scene view itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the Background Images pane, set Size to `6.25`. This pane, with the Size
    field highlighted, is shown in the following screenshot:![](img/c1c87579-278c-49b6-a0d3-912a89ca2761.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to a top-down orthographic view by pressing 7 on the numpad (or navigating
    to View | Top) and the orthographic view by pressing 5 (or navigating to View
    | Persp/Ortho). Note that the background image only gets drawn when it's in the
    top-ortho view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we''ll make a tiny square in one corner of the room that will be extruded
    into a wall. Add a pane by pressing *Shift* + *A* and select Plane. Then, press
    *Tab* to go into the Edit mode. Press *Z* to toggle from the solid to the wireframe
    view. Press *G* to drag it into a corner, click *Enter* to confirm. Press *S*
    to scale it to fit the width of the corner of the wall, as shown in the following
    screenshot (you may recall that you can use the mouse scroll wheel to zoom and
    *Shift* and click on the middle mouse button to pan):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cc3a4220-f622-4200-ae61-977a9a0cc372.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Extrude the corner to make the outer walls. Go into the Edge Select mode (via
    the icon shown in the following screenshot), press *A* to unselect all, and then
    right-click on the edge that you want to extrude. Press *E* to begin extruding,
    press X or Y to constrain it to that axis, and then press *Enter* to complete
    the extrusion where you want it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9b66a724-1280-4a89-bafd-c6a401decb8f.png)'
  prefs: []
  type: TYPE_IMG
- en: Repeat the previous steps for each outer wall. Create a small square at the
    corners so that you can extrude in the perpendicular direction. Leave gaps for
    the doorways. (You may recall that if you need to modify the existing edges, select
    it with a right-click, *Shift* and right-click to select multiple, and move with
    *G*. You can also duplicate the selected items.) Also, you can use *Shift* + *D* to
    duplicate in Object mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cec1e6a0-d972-4b5b-9319-0e7d72626f5d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To extrude out a face from the middle, we need to add an *edge loop*. With
    the mouse over the face, press *Ctrl* + *R* and left-click to create the cut.
    Slide the mouse to position it and left-click again to confirm. Repeat these steps
    for the width of the wall (making a square cut in the outer wall). Select the
    edge segment and press E to extrude it into the room:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e588ee45-e0e7-4579-a900-68e74e209443.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the floor plan is done, we can extrude it along the *z* axis to create
    the walls. Change the view from Ortho to Persp by pressing *5*. Tilt it back using
    the middle mouse click and move. Select all by pressing *A*. Extrude with *E*.
    Begin to extrude with the mouse, press *Z* to constrain, and left-click to confirm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save the model to a file named `gallery.blend`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5018ca90-7f4a-4287-b178-2b01dde03155.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding a ceiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, add a ceiling with two skylights. The ceiling will just be a flat slab
    build from a single cube. Let''s see the steps to add a ceiling:'
  prefs: []
  type: TYPE_NORMAL
- en: Return to Object mode using *Tab*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a cube using *Shift* + *A* and select Cube
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position it at the center using *G* and the mouse (*Alt* + *G* resets all its
    transforms)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale it along *x* and *y* so that it's size is the same as that of the room
    using *S* + *X* and *S* + *Y*)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to Front view using *1*, scale it so that it is flattened using *S* +
    *Z*, and move it to the top of the walls using *G* + *Z*)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The skylights will be holes cut out of the ceiling using another cube as a
    modifier, as show in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a12959d-bd0f-4560-836a-076088c634ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Add a cube, using *Shift* + *A*, scale it to size, and move it to the position
    where you want the skylight.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the cube's *z* axis so that it cuts through the ceiling slab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the cube by pressing *Shift* + *D* and move it to the other skylight's
    position, as shown in the following screenshot:![](img/c86f1c67-6db6-44f4-9bea-a2052b1d7e38.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the ceiling slab with a right-click.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the far right Properties Editor panel, select the wrench-icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, navigate to Add Modifier | Boolean and for the Operation option, select
    Difference. For the Object option, select the first cube (`Cube.001`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/da46e8ba-2867-40c2-8caf-c903c0684602.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Apply to make the operation permanent. Then, delete the cube (select
    it and press X).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the process, adding another Boolean modifier for the second cube.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you get stuck, I''ve included a copy of the finished model with the files
    for this book. This model is simple enough. You can build it using Unity cubes
    alone. So much more can, of course, be done to make this a more realistic architectural
    model, but we''re going to move ahead as is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8f05377-e64a-451f-aded-bf1001b0f2e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Assembling the scene in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can use the gallery room model in Unity and add a floor and a ceiling
    with skylights. We will apply textures to the walls and add lighting.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start a new Unity scene, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene by navigating to File | New Scene. Then, Save Scene As and
    name it `Gallery`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a copy of your `MeMyselfEye` prefab into the Hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the default Main Camera from Hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The gallery room level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll build the art gallery''s room structure by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a floor plane by navigating to GameObject | 3D Object | Plane. Reset
    its Transform option and rename it to `Floor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the material for the floor and color it brown. Create | Material, rename
    it, set its Albedo (`70`, `25`, `5`), and drag the material onto the `Floor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our room is sized 24 by 36 feet, which in meters is roughly 7.3 by 11\. A Unity
    plane is 10 units square. So, Scale it to (`0.73`, `2`, `1.1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the gallery model (for instance, `Gallery.blend`). Drag a copy from Project
    Assets into the Scene. Reset its Transform option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Manually rotate and/or scale it to fit the floor, as needed (mine fits, but
    its Rotate Y value needed to be set to `90`). It may help if you first change
    the Scene view to Top Iso.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a good idea to add a collider to the walls so that a character doesn't
    just walk through them. To accomplish this, navigate to Add Component | Physics
    | Mesh Collider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that when imported, as we defined in Blender, the Gallery has separate
    objects for the walls from the ceiling. A material is created (perhaps named `unnamed`)
    that has a neutral gray Albedo (`204`, `204`, `204`). I like this color for the
    walls, but I made a new material, all White (`255`, `255`, `255`) for the ceiling.
  prefs: []
  type: TYPE_NORMAL
- en: For a good default skybox, we recommend **Wispy Skybox**, a free package on
    the Asset Store ([https://assetstore.unity.com/packages/2d/textures-materials/sky/wispy-skybox-21737](https://assetstore.unity.com/packages/2d/textures-materials/sky/wispy-skybox-21737)).
    Go ahead and download and import it into your project now if you want to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add some sky and sunlight, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If a Lighting tab is not visible in your Unity Editor, navigate to Window |
    Lighting | Settings
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Lighting pane, select the Scene tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For sunlight, in the Lighting Scene pane, at the Sun input, select the (default)
    Directional Light from the Hierarchy and drag it onto the Sun Source slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the sky, if you imported Wispy Skybox (see previously), then in the Lighting
    Scene tab, select the doughnut icon on the Skybox Material slot and select the
    material named `WispySkyboxMat`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we selected the `Directional Light` for the sun source, you can play with
    the angle by selecting the Directional Light and modifying its Rotation, with
    the gizmo in the Scene window or directly in the Inspector, perhaps one that is
    consistent with the Skybox you chose (such as Rotation `60`, `175`, `0`).
  prefs: []
  type: TYPE_NORMAL
- en: You may consider textured materials for the floor and other surfaces. For example,  search
    the Asset Store for "Floor Materials." There are many free packages as well as
    paid ones.
  prefs: []
  type: TYPE_NORMAL
- en: The artwork rig
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can plan the art exhibition. We''ll create a  reusable artwork rig
    prefab with a picture frame, lighting, positioning, artist info, and a teleportation
    viewing position. Then, we''ll hang the art on the walls of the gallery. Later,
    we''ll apply the actual images. The artwork rig will consist of a picture frame
    (cube), a photo plane (quad), and a spotlight, all relative to the artwork''s
    placement on the wall. We will create the first one inside our Scene, save it
    as a `Prefab`, and then place duplicates on the walls throughout the gallery.
    I suggest doing this in the Scene view. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a container object by navigating to GameObject | Create Empty. Name it`ArtworkRig`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the frame. With `ArtworkRig` selected, right-click and navigate to GameObject
    | 3D Object | Cube. Name it `ArtFrame`. In Inspector, set its Scale Z to `0.05`.
    Also, let's assume a `3:4` aspect ratio. So, set its Scale Y value to `0.75`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the rig on a wall (the one facing the entrance at the upper right of
    the original floor plan). It may help to hide the ceiling child of the `Gallery`
    object (uncheck its Enable checkbox option). Then, change the Scene view to Top
    and Iso using Scene View Gizmo on the upper right of the Scene panel. Click on
    the green Y icon for the Top view and the middle square icon for the Iso view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `ArtworkRig`, ensure that the Translate gizmo is active (the second icon
    in the top left icon toolbar), and use the *x* and *z* axis arrows to position
    it. Be sure to select and move the `ArtworkRig`. Leave the frame position at (`0`,`0`,`0`).
    Set the height at eye level (`Y=1.4`). The Transform Position value that works
    for me is (`2`, `1.4`, `-1.82`) and no Rotation at (`0`,`0`,`0`), as shown in
    the screenshot that follows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the frame black. Navigate to Assets | Create | Material, name it `FrameMaterial`,
    and set its Albedo color to black. Then in Hierarchy, select the Frame option
    and drag the `FrameMaterial` material onto `ArtFrame`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the image placeholder. With `ArtFrame` selected in Hierarchy, right-click
    and navigate to 3D Object | Quad. Name it to `Image`. Position it just in front
    of the frame so that it's visible; set Position to (`0`, `0`, `-0.8`) and scale
    it so that it's slightly smaller than the frame by setting Scale to (`0.9`, `0.9`,
    `1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To better appreciate the current scale and eye level, try inserting a copy of
    Ethan into the scene:![](img/df7623ae-a44b-4cac-b4af-6737c555d1f0.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we''ll add a spotlight to the rig, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, put the ceiling back in by checking off the Enable checkbox option for
    the child object of Gallery.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `ArtworkRig` selected in Hierarchy, right-click, navigate to Light | Spotlight,
    and position it one and half meters away from the wall (Z=`-1.5`) and up near
    the ceiling. The exact height doesn't matter much since we don't actually have
    a light fixture. We just have a Vector3 location for the source. I set Position
    to (`0`, `1.5`, `-1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, adjust the `Spotlight` value so that it appropriately illuminates the artwork.
    I set Rotation X to `2`, and adjust the light parameters to your liking, such
    as Range to `5`, Spot Angle to `45`, and Intensity to `3`. The results are shown
    in the following screenshot:![](img/71a054e2-240f-41e7-bd6b-169a3bc06f23.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice the spotlight is passing through the wall, illuminating the floor on
    the other side. We don''t want that. Select the Spotlight and enable shadows via
    Shadow Type: Soft Shadows.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To preserve the rig as a prefab, select `ArtworkRig` in Hierarchy and drag it
    into your Project Assets Prefabs folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting to know your Lighting settings can be important. If you see holes in
    your objects or shadows, for example, try sliding the Directional Light's Normal
    Bias to `0` and Bias to a low value like `0.1`. For more information on shadows
    and the bias property, see [https://docs.unity3d.com/Manual/ShadowOverview.html](https://docs.unity3d.com/Manual/ShadowOverview.html).
  prefs: []
  type: TYPE_NORMAL
- en: The exhibition plan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to duplicate `ArtworkRig` on each wall where we want to display
    the images. Position it and rotate as needed. If you follow the plan shown in
    the following diagram, your exhibition will display ten images, indicated by the
    stars:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edfc5fd9-cb20-4655-bdc2-494ea912734c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are the steps to duplicate `ArtworkRig` on each wall:'
  prefs: []
  type: TYPE_NORMAL
- en: As before, it may be easier to hide the ceiling and change the Scene View panel
    to Top and Iso.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the top left of the Scene View panel, change the Transform Gizmo toggles
    so that the tool handle is placed at the Pivot point rather than Center.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Empty game object, Reset its transform, and name it `Artworks`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the existing `ArtworkRig` so it's a child of `Artworks`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each location, place an artwork in the gallery, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select an existing `ArtworkRig` in the Hierarchy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate `Artworkrig` with right-click on Duplicate, or press *Ctrl* + *D*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rotate the rig so that it faces the correct direction by setting Rotation Y
    to `0`, `90`, `180`, or `-90`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the rig on the wall
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The settings that work for my gallery are provided in the following table (and
    assume your Artworks transform is reset to the origin):'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Position X | Position Z | Rotation Y |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 2 | -1.8 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | -1.25 | -5.28 | -180 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | -3.45 | -3.5 | -90 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | -3.45 | -0.7 | -90 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | -2 | 1.6 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 2 | -1.7 | 180 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 3.5 | 0 | 90 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 3.5 | 3.5 | 90 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 1.25 | 5.15 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | -2 | 1.7 | 180 |'
  prefs: []
  type: TYPE_TB
- en: Note that the objects are listed in the same order that we'll use in the animated
    ride-through of the scene. Place them, as children of `Artworks`, in this order
    in Hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Adding pictures to the gallery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please find 10 of your favorite photos from your photo library to use and add
    them to a new Project Assets folder named `Photos`. We are going to write a script
    that, given the list of images, will add them to each of the ArtworkRigs in the
    scene:'
  prefs: []
  type: TYPE_NORMAL
- en: To create the photos folder, navigate to Assets | Create | Folder and name it
    `Photos`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import 10 photos by dragging and dropping them from your File Explorer into
    the `Photos` folder that you just created (or navigate to Assets | ImportNew Asset...)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we''ll write a script to populate Artworks Images:'
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, select `Artworks`. Then, in Inspector, navigate to Add Component
    | New Script and name it `PopulateArtFrames`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the new script for editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the code for `PopulateArtFrames.cs`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What is going on here? First, we declare a public array of `Textures` named
    `images`. You will see, this will appear in Inspector so we can specify what photos
    to include in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'This script is attached to the Artworks container object, which contains as
    children the ArtworkRigs. When the app starts, in `Start()`, we loop through all
    `theArtworkRigs`, find the Image object. For each image, we get its Renderer component''s
    Material, and assign a new Texture, that being the next image in the list. We
    use an `imageIndex` variable to increment through the list, and stop when we''ve
    run out of images or run out of ArtworkRigs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d312e822-26ad-413d-848f-ca8e4773e8b3.png)'
  prefs: []
  type: TYPE_IMG
- en: The astute reader may wonder since all the ArtworkRigs use the same Material,
    and the Default-Material at that, why wouldn't changing the material on any ArtworkRig
    Image change them all? In fact, Unity takes care of that by cloning the material
    into a new unique one when you modify its texture (or other attributes) at runtime.
    So each ArtworkRig's Image gets its own Material with its own Texture, and thus,
    each picture in our gallery is different.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish this up, let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Save the script and return to the Unity editor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `Artworks` selected in Hierarchy, unfold the Populate Art Frames script
    component in Inspector and unfold the Images parameter
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Images Size value to `10`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the images you imported in the `Photos` folder under Project Assets and
    drag them, one at a time, into the Images slots as Element 0 through Element 9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you click on Play mode, the artwork in the scene will get populated with
    the images in the order that you specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f0c2a10-0ebb-4cd5-be55-5b137716d123.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To view the scene in VR, we can position the MeMyselfEye in front of the first
    ArtworkRig:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `MeMyselfEye` camera rig in Hierarchy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Position to (`2`, `0`, `-2.82`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's pretty nice!
  prefs: []
  type: TYPE_NORMAL
- en: Managing art info data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could end here, but suppose we want to track more data than just the images
    for each artwork, such as artist, title, description, and so on. First, we'll
    consider several software design patterns to manage the data, including separate
    lists, data structures, and scriptable objects. Later, we'll update our ArtworkRig
    to display the info with each framed artwork.
  prefs: []
  type: TYPE_NORMAL
- en: The first two scenarios are for explanation only. We will actually implement
    the `ScriptableObjects` one last.
  prefs: []
  type: TYPE_NORMAL
- en: Using lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One approach could be to add more lists to the `PopulateArtFrames` script for
    each of the data fields. For example, if the script had the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The Inspector would show the following (I limited the list to four items for
    brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b69f475-f8c3-42b8-adf5-4f06ed3e3eb7.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can imagine, this could get very unwieldy. To change Element 3, for example,
    you'd have to go to all the lists, which is easily prone to mistakes; things could
    fatally get very out of sync.
  prefs: []
  type: TYPE_NORMAL
- en: Using data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A better approach could be to write a C# `struct` (or `class`) as a data structure
    that contains each of the fields we want and then make the list in `PopulateArtFrames`
    as this type. For example, the script may read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/98c40591-62a0-470d-a882-63341bd8d4c2.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we have a list of `ArtInfo` elements that we can fill in, and the data for
    each element is grouped together.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of this structure is it could be more easily populated from
    an external data source, such as cloud-based JSON data or a CSV (comma separated
    values) data file.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in loading data from a database there are a number of
    approaches, outside the scope of this chapter. But briefly, if you do find a source
    of CSV data, this handy CSV parser ([https://github.com/frozax/fgCSVReader](https://github.com/frozax/fgCSVReader)) 
    is basic but gets the job done. If you are in need of a JSON parser, from a web-based
    REST API for example, consider the JSON .NET For Unity package ([https://assetstore.unity.com/packages/tools/input-management/json-net-for-unity-11347](https://assetstore.unity.com/packages/tools/input-management/json-net-for-unity-11347))
    or another similar one.
  prefs: []
  type: TYPE_NORMAL
- en: Using scriptable objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous examples, the art info data is maintained on a `GameObject`
    in the Scene Hierarchy. As a software design, this is not really where the data
    belongs. Data objects are not game objects and should be managed separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Scene hierarchy, we define the level design and game behaviors. ArtworkRigs
    have spatial coordinates (Transform) and renderers (and other potentially necessary
    runtime components such as colliders and RigidBodies for physics). But other data,
    still a project asset, can live outside the scene hierarchy. For this, Unity offers
    *ScriptableObjects*. We first introduced ScriptableObjects in [Chapter 5](21722631-9544-4b1e-a888-877d34b0fff7.xhtml),
    *Handy Interactables*, as a way of sharing input data across game objects. We
    will use them again here:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Project window, create a new folder under *Assets* named `ScriptableObjects`
    if not already present
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the new folder, right-click and select Create | C# Script
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the script `ArtInfo`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, open the `ArtInfo.cs` script for editing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `ArtInfo.cs` script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Rather than inheriting from `MonoBehaviour`, we define the class as a `ScriptableObject`.
    We added a `Multiline` attribute for description so the input field in Inspector
    will be a text area.
  prefs: []
  type: TYPE_NORMAL
- en: If you are importing JSON data into your project and want to generate ScriptableObject
    classes that match the JSON object properties, take a look at this tool: [https://app.quicktype.io/#r=json2csharp](https://app.quicktype.io/#r=json2csharp).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top, we provide a `CreateAssetMenu` attribute, which generates a menu
    item in the Unity Editor for our object. Since scriptable objects are not added
    to the scene Hierarchy, we need a way to create them in the project. Using this
    attribute makes it easy, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Save the script and return to Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project window, select your Photos folder where you imported your image
    textures. We'll create the Art Info objects in the same folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Unity editor main menu, navigate to Assets | Create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see a new item My Objects with a submenu with an item Art Info, as
    directed in the CreateAssetsMenu property attribute in our script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Art Info to create an instance. By default, it will be created in the
    same folder as the defining script (this can be changed in the property attribute
    options).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It maybe be helpful to rename the object similar to your images. For example,
    if you have PictureA, name it `PictureA Info`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the image texture onto the scriptable object's Image slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add information for the Title, Artist, and Description too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is a screenshot of an ArtInfo object with data filled in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6433e606-c9dd-49d9-9849-21be5d159a94.png)'
  prefs: []
  type: TYPE_IMG
- en: Repeat these steps for all your pictures.  When you're done, your art data will
    be Project assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the scriptable object assets in the project, we could modify the PopulateArtFrames
    much like we would have for the `struct` version of the code. We''ll do a little
    bit of refactoring, creating a new component on the ArtworkRig to populate itself
    with an ArtInfo object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select one of the ArtworkRigs in the Hierarchy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Component | New Script, name it `ArtworkController`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open it for editing and write it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the script and back in Unity, on the `ArtworkRig` where we just added
    this component:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the image child onto the image slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Apply to save the `ArtworkRig` prefab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, update the `PopulateArtFrames` to iterate the list of `ArtInfo` and send
    the object to the `ArtworkRig`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the Inspector interface is much cleaner and workable. The Artworks'' Populate
    Art Frames component maintains a list of Art Info objects, as shown next. We just
    need to populate the list and use it. The data the list references are maintained
    separately as `ScriptableObjects`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94eb8e15-f62a-4837-9fe8-35e6d34aeb68.png)'
  prefs: []
  type: TYPE_IMG
- en: Press Play. The artwork images should get loaded during Start, just like before
    although we've greatly improved the underlying implementation and can now extend
    our app to include more info about each art picture.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of using ScriptableObject in situations like this is once
    you have a distributable app, you can package these assets into an AssetBundle.
    This would allow, for example, changing out the gallery pictures, along with all
    the art info, in the live version.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the art info
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have more information on each art piece, we can incorporate that
    into our project. We will add a UI canvas to the ArtworkRig. First, we'll include
    an info plaque with each picture. Then we'll make it interactive. If you'd like
    a reminder introduction to Unity's canvas and UI elements, please look at [Chapter
    6](36d3f24b-8acf-42df-92cc-abb5147d4a1f.xhtml), *World Space UI*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the title plaque
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The title plaque will be a small canvas next to each picture, with a title
    text UI element:'
  prefs: []
  type: TYPE_NORMAL
- en: Select one of the ArtworkRig objects in Hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a child canvas, Create UI | Canvas, named InfoPlaque.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Render Mode to World Space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initially reset its position Pos to (`0`, `0`, `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the canvas Width: `640`, Height: `480`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you recall, the canvas scaled in world space will be 640 meters wide! Set
    the Scale to `0.0006.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now you can visually adjust the position using the move gizmo, we found this
    works: Pos (`0.8`, `-0.1`, `-0.01`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a child pane, Create UI | Panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And a sub-child of the panel, create a child text element, Create UI | Text,
    rename it Title.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set some default text, like Title title title title.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Anchor Presets (the fancy icon in the top-left of the Transform panel),
    select Stretch / Stretch, click and also Alt-click it. This will let the text
    fill the panel area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Font Size: `80`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alignment: Middle, Center.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set its Horizontal Overflow: `Wrap`, and Vertical Overflow: `Truncate`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can modify `ArtworkController` script to add a new `public Text title`
    variable and set its `text` property to the `info.title`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'That was easy. Save the script, and then:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the Title element onto the Text slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To save the prefab, make sure the `ArtworkRig` itself is selected in the Hierarchy,
    then press Apply
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now when you press Play, the picture images and title text will get initialized
    on `Start` for each of the artwork rigs. Here''s one of my photos with a title
    plaque:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/801eadda-a63e-4509-a2a3-c248557fe71f.png)'
  prefs: []
  type: TYPE_IMG
- en: Interactive info details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have more information on each picture that fits on the plaque, so we''ll
    allow the player to click an input controller button to open the detail infobox.
    Let''s create that canvas first, with text for artist and description:'
  prefs: []
  type: TYPE_NORMAL
- en: As a shortcut, duplicate the InfoPlaque and name it `DetailsCanvas`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scale and position it, perhaps out front and a slight angle. The following
    values work for me: Pos (`0.7`, `0`, `-0.2`), Width Height (`1200`, `900`), Rotation
    (`0`, `15`, `0`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the Title text element to `Description`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate Description, rename it `Artist`, set to Top Alignment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Apply to save the prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `ArtworkController`  can now populate the details fields too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the `SetArtInfo` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Then, we'll add an `Update` handler to check for user input and display (or
    hide) the details canvas. And ensure the canvas starts out disabled in `Start`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For Daydream on Android, you would call `GvrControllerInput.ClickButtonDown`
    and `ClickButtonUp`.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script.
  prefs: []
  type: TYPE_NORMAL
- en: Drag the Artist and Description elements onto the corresponding slots
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the InfoDetails canvas onto the Details Canvas slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Apply on the ArtworkRig to save the prefab changes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, when you Play and press the Fire1 button on your input controller, the
    details canvas will show, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/039697ed-984c-4227-9332-bfec3c59ad5c.png)'
  prefs: []
  type: TYPE_IMG
- en: If you would like to implement a different button, such as the finger trigger,
    or are using a device without a Fire1 mapping (Daydream), please refer to [Chapter
    5](21722631-9544-4b1e-a888-877d34b0fff7.xhtml), *Handy Interactables,* for implementation
    options and handling input events.
  prefs: []
  type: TYPE_NORMAL
- en: As implemented, all the details canvases will appear when you press the button.
    If you want to control one canvas at a time, you could add a UI button to the
    InfoPlaque, for example, and then use click events on that to trigger the canvas
    visibility, using gaze-based look and click, or laser pointer & click interactions. Reference
    [Chapter 6](36d3f24b-8acf-42df-92cc-abb5147d4a1f.xhtml), *World Space UI*, for
    implementation ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting for image aspect ratio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You probably noticed that some of your pictures appear squished since our framed
    image is shown at a fixed size and aspect ratio. What we really would like is
    for the frame and image to adjust themselves depending on the dimensions of the
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Unity imports a texture, it prepares it (by default) for GPU rendering
    as an object material texture, which includes resizing it to a square power of
    two (for example, 1024 x 1024, 2048 x 2048, and so on). If you adapt your project
    to read images at runtime, for example, from the Resources directory, the device''s
    photo stream, or over the web, then you will have access to the image file''s
    metadata header that includes its pixel width and height. In lieu of that, since
    we''re using imported textures, we can change the Advanced import settings for
    the images we''re using:'
  prefs: []
  type: TYPE_NORMAL
- en: From your Assets Photos folder, select an image texture
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Inspector, under Advanced, change Non Power of 2 to None
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Apply
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this for each image in the project. Note that this also decompresses
    the image, so what might start out as a 400k `.jpg` file becomes a 3 MB, 24-bit
    image in the project, so be cautious of the width and height of the source images
    you choose to use.
  prefs: []
  type: TYPE_NORMAL
- en: Not scaling textures to a power of two is really bad for performance. If you
    have more than a few images, you should avoid this. One approach would be to add
    the image aspect ratio as another field of the ArtInfo, and manually set the value
    in the corresponding scripted objects. Then, change ArtworkController to use this
    value instead of calculating it.
  prefs: []
  type: TYPE_NORMAL
- en: In `ArtworkController.cs`, add the following helper function, which returns
    a normalized scale of a texture. The larger dimension will be 1.0 and the smaller
    one will be a fraction. For example, an image that is 1024w x 768h will get a
    scale of (1.0, 0.75). It also maintains the current relative scale of the picture
    using the Z scale value, since that's not changed by our aspect ratio calculation,
    but will be changed by the Scale tool!
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify `ArtworkController` first by adding a private function `TextureToScale`
    which normalizes the image scale to 1.0 for the larger of width or height, and
    sets the other dimension to the aspect ratio, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The function also preserves the frame depth in the returned scale vector. Now,
    we can use this in `SetArtInfo` function. Add a new public variable for the `frame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, add this line to set the frame''s scale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the updates script. Then, in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the ArtFrame onto the Frame slot in the component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Apply to save the prefab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now when you play, the framed images are scaled with the correct aspect ratio,
    like the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e4c8ce6-432d-473f-9e4b-75afef550bd3.png)'
  prefs: []
  type: TYPE_IMG
- en: Moving around the gallery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've done so much, and yet have not discussed moving about the gallery level.
    In [Chapter 7](f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml), *Locomotion and Comfort*,
    we examined various ways of implementing locomotion and teleportation. Let's now
    consider setting up specific teleportation spawn points that provide an optimal
    viewing pose for each artwork picture in the gallery.
  prefs: []
  type: TYPE_NORMAL
- en: Teleporting between pictures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I suppose a good viewing position is about one meter back from the picture.
    We can add a ViewPose object at that location, within the ArtworkRig. We''ll place
    its origin on the floor. Let''s add that now:'
  prefs: []
  type: TYPE_NORMAL
- en: Select a ArtworkRig in Hierarchy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a child Empty game object, name it `ViewPose`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset the ViewPose transform
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Position to (`0`, `-1.4`, `-1.5`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In [Chapter 7](f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml), *Locomotion and
    Comfort*, we examined various ways of implementing locomotion and teleportation,
    including our own home-grown scripts as well as higher-level toolkits. Here, we'll
    use teleportation toolkits for SteamVR and Daydream. For a more general introduction
    to these toolkits, or alternative solutions, please refer back to that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Teleporting with SteamVR Interaction System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use the SteamVR Interaction System, we start with their Player prefab and
    add the components we want to use:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the Player prefab in `SteamVR/InteractionSystem/Core/Prefabs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag it as a child of `MeMyselfEye` in your scene Hierarchy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete or disable the `[CameraRig]` object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a copy of Teleporting prefab from Project `Assets/SteamVR/InteractionSystem/Teleport/Prefabs` as
    a child of MeMyselfEye (this controller can actually go anywhere in the scene)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Player in Hierarchy, and drag its parent `MeMyselfEye` onto its Tracking
    Origin Transform slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the ViewPose object in the ArtworkRig
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a copy of the TeleportPoint prefab from Project `Assets/SteamVR/InteractionSystem/Teleport/Prefabs` into
    the Hierarchy as a child of ViewPose
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the ArtworkRig and Apply to save the prefab changes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s it! Press Play. The teleport points do not show until you press the
    button on your controller, then they glow, a dashed laser arc lets you choose
    one, and you go there. Here is a screenshot of the Scene view while the teleport
    points are activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6726e430-2dbe-454c-9a7c-5c0911c66d96.png)'
  prefs: []
  type: TYPE_IMG
- en: Teleporting with Daydream Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Daydream Elements toolkit is more granular so it takes a little more to
    get this working. By default, the TeleportController lets you teleport to any
    horizontal surface on the scene (provided it has a collider). To limit it to our
    teleport stations we'll restrict the search to a specific layer, named `Teleport`.
  prefs: []
  type: TYPE_NORMAL
- en: In an ArtworkRig in Hierarchy, select its ViewPose object and create a child
    cylinder (Create | 3D Object | Cylinder) and name it `TeleportPod`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Scale to (`0.5`, `0.5`, `0.01`). You may choose to decorate its material,
    for example, with transparency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put it on Layer `"Teleport"` (If there is no layer named Teleport, from the
    Layers select list choose Add Layer... first).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the parent ArtworkRig and Apply to save the prefab changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we add the Daydream Elements teleport controller:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the TeleportController prefab into your Hierarchy as child of Player (for
    us, `MeMyselfEye / GVRCameraRig / Player`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset its Transform, if necessary
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `MeMyselfEye` object onto the `TeleportController` component's Player transform
    slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag GvrControllerPointer (or whichever controller game object you're using)
    onto the Controller transform slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the TeleportController's Valid Teleport Layers, select Teleport (so both
    Default, Teleport are selected)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On Raycast Mask, we want only Teleport, so select Nothing (to deselect all),
    then select Teleport. The layer settings are shown in the screen capture here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8d3fb548-93bd-43ed-bc0f-a196d0221075.png)'
  prefs: []
  type: TYPE_IMG
- en: Press Play. When the controller pointer's arc touches a teleport pod, it will
    glow highlight. If you click, you will be teleported to that spot.
  prefs: []
  type: TYPE_NORMAL
- en: Room-scale considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The gallery level layout we have designed works best in seated, standing, or
    non-positionally tracked VR. Our use of the zig-zag partitions, for example, is
    not a good idea in room scale VR unless you take care to not allow the player's
    play space (chaperone boundaries) to cross these walls. This can be done, but
    you would need to make the overall space larger, perhaps adaptive to the actual
    play space size, and add conditions to the teleportation feature that we implement
    later in the chapter, complicating our examples. See [Chapter 7](f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml), *Locomotion
    and Comfort* for more about room-scale considerations.
  prefs: []
  type: TYPE_NORMAL
- en: The following image is a depiction of an initial position for MeMyselfEye for
    a room scale OpenVR camera rig, showing the guardian boundaries fit neatly within
    the gallery viewing space for the first ArtworkRig. It may not fit so easily at
    the other viewing situations, so you'd need to make adjustments to discourage
    the player from walking through walls (or through Ethan!). Also, whereas this
    is the default length and width, the player's actual space will vary to their
    configuration requirements. To fully accommodate these possibilities, it may be
    necessary to go to a procedurally generated level layout, where the position and
    scale of the walls are determined at runtime based on the player settings.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5187058a-dc58-40e1-acbc-a2e30e316ff0.png)'
  prefs: []
  type: TYPE_IMG
- en: Animating a ride-through
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you can be certain the player will be seated or at least standing in one
    place, they might enjoy a ride-through guided tour of the gallery.
  prefs: []
  type: TYPE_NORMAL
- en: In conventional games, first-person animation is often used for a cut-scene,
    that is, a canned fly-through animation as a transition from one level to another.
    In VR, it's somewhat different. Walkthroughs can really be the VR experience itself.
    Head tracking is still active. So, it's not simply a prerecorded video. You can
    look around and experience it, and it is more like an amusement park ride. This
    is often called an on-the-rails VR experience.
  prefs: []
  type: TYPE_NORMAL
- en: Be cautious using ride-through animations in your VR apps. It can cause motion
    sickness. If you do, give your players as much control as possible. For example,
    we're animating the `MeMyselfEye` rig, allowing users to continue to look around.
    Placing the user in a cockpit or vehicle with stationary surfaces in the foreground
    can also reduce the tendency for sickness. On the other hand, if you're a thrill
    seeker, techniques similar to those here can be used for making roller-coaster
    rides on a track that moves in three dimensions!
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we are scripting the animations ourselves. In a later chapter,
    we will dive more deeply into other Unity animation and cinematic tools. We create
    a `RidethroughController` that animates the first-person character (`MeMyselfEye`)
    Transform position, and rotation over time. It works by defining the key-frame
    transforms, using the Unity `AnimationCurve` class ([https://docs.unity3d.com/ScriptReference/AnimationCurve.html](https://docs.unity3d.com/ScriptReference/AnimationCurve.html)).
    As the name suggests, for key-frame animation, we define the player's location
    at specific key times in the ride. The in-between frames are calculated automatically.
  prefs: []
  type: TYPE_NORMAL
- en: At the root of Hierarchy, create a new Empty game object and name it `RidethroughController`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new C# script component and name it `RidethroughController`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the script for editing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we''ll define some variables we will need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`playerRoot` is the player transform we will animate (`MeMyselfEye`). `artWorks`
    is the container of the ArtworkRigs. We''ve included an option to specify an initial
    delay and the transition time between pictures. The setup function will generate
    three curves, for position (*x *and *z*) and rotation (about the *y *axis).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we write a `SetupCurves` function that generates the animation curves,
    using each of ArtworkRig''s ViewPose as nodes in the curve. We do this concurrently
    for the *x*, z, and rotation curves as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define the `RidethroughController` to start animating when the game
    object is enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'On each Update, we evaluate the X and Z curves to set the player''s current
    position. And, we evaluate the rotation curve to set the player''s current rotation.
    We use the native `Quaternion` representation of rotations since we''re interpolating
    between two angles we do not want use Euler coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we check whether we've completed the animation by comparing the current
    time with the time of the last node in the curve. If so, we disable the game object.
  prefs: []
  type: TYPE_NORMAL
- en: In this script, I used the `transform.rotation` Quaternion y value directly.
    It's usually not recommended to manipulate Quaternion's value directly, but since
    we're consistently changing only a single axis, it is safe. For more information
    on Quaternion versus Euler angles, see [https://docs.unity3d.com/Manual/QuaternionAndEulerRotationsInUnity.html](https://docs.unity3d.com/Manual/QuaternionAndEulerRotationsInUnity.html).
  prefs: []
  type: TYPE_NORMAL
- en: As written, if/when the RidethroughController game object is enabled, the animation
    will play. You can save your scene with it enabled, and it will play when the
    app begins. We'll leave it up to you to modify it to be trigged by a player's
    option such as a *Start Ride* button within the app!
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the script and then perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From Hierarchy, drag `MeMyselfEye` onto the Player Root slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Artworks` (which contains all `ArtworkRigs`) onto the Artworks slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you Play the scene, you get a nice easy ride through the art gallery, with
    a slight pause to view each photo. That's real nice! Hopefully, you picked images
    that can be shown by you to all your friends and family!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built an art gallery scene from scratch, starting with a
    2D plan drawing and going into Blender to construct a 3D architectural structure.
    We imported the model into Unity and added some environmental lighting. Then,
    we built an artwork rig consisting of an image, a picture frame, and a spotlight,
    and placed instances of the rig on various walls throughout the gallery. Next,
    we imported a bunch of personal photos and wrote a script that populates the art
    frames at runtime. Adding more detailed data about each artwork, we explored several
    ways of managing lists of non-graphical data. Finally, we added the ability to
    move around within the art gallery level, via teleportation and an automated first-person
    walkthrough of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at a different kind of VR experience
    using pre-recorded 360-degree media. You will build and learn about photospheres,
    equirectangular projections, and infographics.
  prefs: []
  type: TYPE_NORMAL
