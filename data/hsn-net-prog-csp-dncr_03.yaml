- en: DNS and Resource Location
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS和资源定位
- en: The last chapter was spent dissecting networks to such a degree that most readers
    will likely never think about them again. In this chapter, we'll take those concepts
    and look at their real-world implementations. We'll start with a look at how the
    problem of resource allocation is solved at the scale of the internet. Distributing
    resources is useless without being able to access them from across your network,
    and this chapter will introduce you to the systems and standards that make doing
    so possible. As we investigate these topics, we'll finally get our hands dirty
    with some code. Throughout this chapter, we'll look at software examples to get
    you familiar with leveraging the tools available with the .NET Core framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章花费了大量时间剖析网络，以至于大多数读者可能永远不会再次考虑它们。在本章中，我们将探讨这些概念，并查看它们的实际应用。我们将从查看互联网规模上解决资源分配问题开始。如果没有能力从您的网络中访问资源，分配资源是没有用的，本章将向您介绍使这成为可能的技术系统和标准。在我们调查这些主题时，我们最终将动手编写一些代码。在本章中，我们将查看软件示例，让您熟悉利用.NET
    Core框架中可用的工具。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How data and services are exposed and made available on everything from your
    home Wi-Fi network to the internet
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在从您的家庭Wi-Fi网络到互联网的任何设备上公开和提供数据和服务
- en: The specific standards used to identify resources at different levels of your
    network, from URLs and domain names, to devices names and local directory access
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于识别您网络不同级别的资源的特定标准，从URL和域名到设备名称和本地目录访问
- en: Using the DNS class in .NET Core to access external resources and resolve requests
    for data within your network
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用.NET Core中的DNS类访问外部资源并解决网络内数据请求
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow this chapter, you'll need to have either Visual Studio Code, or Visual
    Studio Community Edition. Both are free downloads available at the Visual Studio
    website, at [https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，您需要拥有Visual Studio Code或Visual Studio Community Edition。这两个都是可以在Visual
    Studio网站上免费下载的，网址为[https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/)。
- en: 'Check out the following video to see the code in action: [http://bit.ly/2HVSHad](http://bit.ly/2HVSHad)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频，了解代码的实际应用：[http://bit.ly/2HVSHad](http://bit.ly/2HVSHad)
- en: We'll also be using the .NET Core **command-line interface** (**CLI**). This
    will give us access to a series of programs we can call directly from the command
    prompt. To follow along, you'll need to make sure you have the .NET Core SDK installed
    locally, which can be downloaded from [https://www.microsoft.com/net/download](https://www.microsoft.com/net/download).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用.NET Core **命令行界面**（**CLI**）。这将使我们能够直接从命令提示符调用一系列程序。为了跟上进度，您需要确保您已经在本地上安装了.NET
    Core SDK，可以从[https://www.microsoft.com/net/download](https://www.microsoft.com/net/download)下载。
- en: The source code is available at [https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可在[https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core)找到。
- en: Needles in a haystack – data on the internet
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 海量信息中的针——互联网上的数据
- en: The first step to using the resources exposed on a network is finding them.
    While this problem is easily solved on a LAN with only four computers, you can
    imagine how daunting a challenge it becomes when your context grows to the several
    billion devices actively connected to the internet. To ensure reliable delivery
    of requests broadcast on a network, each device on that network must be uniquely
    addressed, and any software that wants to communicate with a device must know
    the address of the target device. With this in mind, let's look at how the problem
    has been solved at scale and consider how we can apply that solution to our more
    locally-relevant use cases with .NET Core.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络上公开的资源的第一步是找到它们。虽然这个问题在只有四台计算机的局域网中很容易解决，但您可以想象当您的环境扩展到数十亿个活跃连接到互联网的设备时，这会变成多么艰巨的挑战。为了确保网络广播请求的可靠交付，网络上的每个设备都必须有唯一的地址，并且任何想要与设备通信的软件都必须知道目标设备的地址。考虑到这一点，让我们看看在规模上是如何解决这个问题，并考虑我们如何可以将这种解决方案应用到我们更相关的本地用例中，使用.NET
    Core。
- en: The first network addresses
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一网络地址
- en: As I mentioned, every device on a network must be uniquely identifiable so that,
    at any given time, requests intended for a specific device can be delivered. Likewise,
    unique addressing means that any responses can be reliably returned to the originating
    device, no matter how many network nodes lie between the two. If someone has written
    a service that solves a problem you have, it's only useful to you if you can actually
    use that service. This means either knowing the address of the device hosting
    that service, or, at the very least, knowing who to ask for the address.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，网络上的每个设备都必须具有唯一的可识别性，这样在任何给定时间，针对特定设备的请求都可以被送达。同样，唯一的地址意味着任何响应都可以可靠地返回到原始设备，无论两个设备之间有多少网络节点。如果有人编写了一个解决你问题的服务，只有当你实际上可以使用该服务时，它对你才有用。这意味着要么知道托管该服务的设备的地址，要么至少知道如何询问地址。
- en: 'Thankfully, this is a problem that was solved long before even the earliest
    incarnations of the modern internet. I am, of course, referring to telecommunication
    networks, and their well-established system for addressing and address look-ups.
    With early telecom networks, engineers needed to solve problems for a large set
    of devices that needed to be uniquely addressed. Whatever system they came up
    with, though, would need to exhibit the following characteristics in order to
    remain viable in the long term:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个问题在互联网的最早形态出现之前就已经得到了解决。我当然是指电信网络，以及它们为地址和地址查找建立的成熟系统。在早期的电信网络中，工程师需要为需要唯一标识的大量设备解决问题。然而，无论他们提出什么系统，都必须展现出以下特性，才能在长期内保持其可行性：
- en: 'Usability: The system would be used by anyone who wanted to communicate over
    the telecom network, and so the system could not have been prohibitively complex.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性：该系统将由任何想要通过电信网络进行通信的人使用，因此该系统不能过于复杂。
- en: 'Scalability: The ultimate goal was to connect every home in the nation with
    a single, unified network. The solution for adding nodes to that network would
    need to grow with the population and the geographic region that it would ultimately
    support.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性：最终目标是连接全国每个家庭，使用一个单一、统一的网络。向该网络添加节点的解决方案需要随着人口和地理区域的扩大而增长。
- en: 'Performance: If a telephone call took as long as the postal service to deliver
    messages back and forth, no one would use it. And, while that was never going
    to be the case, there would certainly be a limit to what customers would tolerate
    in terms of speed and reliability.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能：如果电话通话需要像邮政服务一样长时间来回传递信息，没有人会使用它。虽然这种情况永远不会发生，但客户在速度和可靠性方面所能容忍的极限肯定存在。
- en: Thankfully, what they came up with was a sustainable solution that has scaled
    and functioned for decades.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，他们提出的解决方案是一个可持续的解决方案，它已经扩展并运行了几十年。
- en: The system that telecom engineers devised was that of phone numbers. By assigning
    10-digit addresses to each phone on a telecom network, engineers guaranteed a
    network capable of uniquely addressing up to 9,999,999,999 devices. Add two digit
    country codes to that, and you've got a network that can theoretically support
    up to a trillion devices, or over 100 unique addresses for each human on the planet,
    with approximately another 240 billion to spare.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 电信工程师设计的系统是电话号码系统。通过为电信网络上的每一部电话分配10位地址，工程师确保了一个能够唯一标识高达9,999,999,999个设备的网络。再加上两位数的国家代码，理论上这个网络可以支持高达万亿个设备，或者为地球上每个人提供超过100个独特的地址，还有大约240亿个地址是多余的。
- en: You might have noticed that I specified that the phone numbering system only
    theoretically supports up to a trillion devices. However, there are certain limitations
    of the addressing system of telecoms that make reaching the theoretical maximum
    difficult. As most of you will be well aware, the first three digits of a US telephone
    number are known as the **area code**. Those digits were originally determined
    by the specific geographic location in which the phone was located. This helped
    route numbers quickly, but means that the total number of possible devices supportable
    by telecom networks is limited by the distribution of those devices across geographic
    regions. Within an area code, there is only a theoretical maximum of 9,999,999
    possible devices; barely more than the total population of New York.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我指出电话号码系统在理论上只支持高达万亿个设备。然而，电信寻址系统的一些局限性使得达到理论上的最大值变得困难。正如你们大多数人所意识到的，美国电话号码的前三位数字被称为**区号**。这些数字最初是由电话所在的特定地理位置决定的。这有助于快速路由号码，但也意味着电信网络能够支持的设备总数受到这些设备在地理区域分布的限制。在一个区号内，理论上最多只能有9,999,999个可能的设备；这几乎超过了纽约市总人口。
- en: I'm over-simplifying the solution here, but what this trade-off provided for
    telecom engineers was a simple mechanism for narrowing down the possible field
    of physical phones to which an address would resolve as quickly as was reasonably
    possible. Calls could be routed to a substantially restricted region by examining
    only the first three numbers. This provided an obvious performance benefit by
    applying semantic meaning to a syntactic standard. The telephone numbering system
    simply specifies that a physical phone is addressed by a 10-digit address. That
    is a syntax requirement. However, the geographic information conveyed by the first
    three digits of that address is a semantic standard. There is an underlying meaning
    baked into those first three numbers that conveys how the entire address should
    be handled.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里过于简化了解决方案，但这个权衡为电信工程师提供了一个简单机制，以便尽可能快地将物理电话的可能范围缩小到地址所解析的地址。通过仅检查前三位数字，就可以将电话路由到一个实质上受限的区域。这通过将语义意义应用于句法标准提供了明显的性能优势。电话号码系统简单地指定一个物理电话通过10位地址进行寻址。这是一个句法要求。然而，该地址前三位数字所传达的地理信息是一个语义标准。这些前三位数字中蕴含着一种基本含义，它传达了整个地址应该如何处理。
- en: The scalability of this numeric addressing system helps network devices direct
    traffic accurately. For a human user, though, an arbitrary series of seven to
    ten numbers can be difficult to remember, and are error-prone to use. Those who
    grew up in the time before smartphones and built-in contacts lists may remember
    the need to have a Rolodex, or contact book, to keep frequently needed, but difficult
    to remember, phone numbers organized and on-hand at all times. However, it was
    often the case that you'd need to call someone whose number you didn't have conveniently
    stored. This is where the phone book comes in. It served as a simple way of mapping
    easily-remembered unique identifiers for a person (specifically, a full name and
    street address) to their corresponding network-friendly address (their phone number).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字寻址系统的可扩展性有助于网络设备准确引导流量。然而，对于人类用户来说，一串任意排列的七到十个数字可能难以记忆，且使用时容易出错。那些在智能手机和内置联系人列表出现之前成长起来的人可能还记得，需要有一个罗罗德克斯（Rolodex）或联系簿来组织并随时备好那些经常需要但难以记忆的电话号码。然而，通常情况下，你需要拨打一个你不方便存储的电话号码。这时电话簿就派上用场了。它提供了一种简单的方法，将易于记忆的唯一标识符（特别是全名和街道地址）映射到对应的网络友好地址（他们的电话号码）。
- en: 'All of these features, taken together, provided telecoms with the hallmarks
    of a successful network implementation: usability (through the simplicity of phone
    books), scalability (with the extensive range of valid addresses), and performance
    (with improved routing speeds achieved by embedding semantic meaning into the
    syntactic standards of the address). By now, though, you''ve likely correctly
    guessed that we won''t be programming for telephone networks in C#. So, let''s
    see how the design decisions made by telecom engineers translate to modern computer
    networks.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些特性综合起来，为电信行业提供了成功网络实施的标志：易用性（通过电话簿的简单性）、可扩展性（通过广泛的合法地址范围）和性能（通过将语义意义嵌入地址的语法标准中实现的改进路由速度）。然而，到现在，你可能已经正确地猜到了，我们不会用C#为电话网络编程。那么，让我们看看电信工程师做出的设计决策是如何转化为现代计算机网络的。
- en: DNS – the modern phone book
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS – 现代的电话簿
- en: 'As I have alluded to, engineers designing modern computer networks faced the
    same problem as telecom engineers: defining a standardized syntax with which they
    could create unique addresses for each device on their network. Thankfully, though,
    there were already giants on whose shoulders those computer network engineers
    could stand (to paraphrase Sir Isaac Newton).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我暗示的那样，设计现代计算机网络工程师面临的问题与电信工程师相同：定义一个标准化的语法，以便他们可以为网络上的每一台设备创建唯一的地址。幸运的是，尽管如此，那些计算机网络工程师可以站在巨人的肩膀上（用艾萨克·牛顿爵士的话来说）。
- en: The phone numbering system demonstrated that a simple system of fixed-length
    numeric addresses could be quickly parsed and routed. Moreover, strictly numerical
    addresses can be represented in binary. This meant no additional standards needed
    to be applied for consistently representing non-numeric characters. However, this
    was a trade-off in usability. The software written to use those addresses would
    still need to be written by humans. As is often the case, the easier (and more
    performant) solution for computers to use was the more difficult solution for
    humans. This meant that computer network engineers would need to devise a phone
    book of their own. Thankfully, they rose to the occasion.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 电话号码系统表明，一个简单的固定长度数字地址系统可以快速解析和路由。此外，纯数字地址可以用二进制表示。这意味着不需要额外的标准来一致地表示非数字字符。然而，这在易用性上是一个权衡。用于使用这些地址的软件仍然需要由人类编写。正如经常发生的那样，对计算机来说更容易（且性能更好）的解决方案，对人类来说却更困难。这意味着计算机网络工程师需要设计自己的电话簿。幸运的是，他们做到了。
- en: On all modern computational networks, the fixed-length numerical address by
    which you can reliably locate an external device is the **Internet Protocol (IP)**
    address. Meanwhile, the system from which you can reliably ask for the address
    of a given device is the **Domain Name System (DNS).** This, the DNS, is the computer
    network's phone book. It's essentially an elaborate, distributed mapping of human-readable
    domain names to their underlying IP addresses.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有现代计算网络上，你可以通过可靠的固定长度数字地址来定位外部设备，那就是**互联网协议（IP）地址**。同时，你可以从可靠的系统中获取特定设备的地址，那就是**域名系统（DNS）**。这个DNS，就是计算机网络中的电话簿。它本质上是一个复杂的、分布式的映射，将可读的域名映射到其底层的IP地址。
- en: Every device on the internet (or any local networks) will have their own IP
    address. However, the specifics of how that IP address is determined, and the
    strengths and limitations of the syntax for those addresses, will be discussed
    later in this book. For now, what we're concerned with is specifically how those
    addresses are resolved by their more meaningful, human-readable domain names.
    In this next section, we'll explore fully how that happens every time you look
    up a resource by its URL.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上的每一台设备（或任何本地网络）都将拥有自己的IP地址。然而，关于如何确定该IP地址的具体细节，以及这些地址语法的优势和局限性，将在本书的后续章节中进行讨论。目前，我们关注的是这些地址如何通过更有意义、易于阅读的域名来解析。在接下来的这一节中，我们将全面探讨每次通过URL查找资源时这一过程是如何发生的。
- en: URLs, domain names, and device addresses
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网址、域名和设备地址
- en: With a solid understanding of the primary concerns that must be addressed for
    resource location on networks, let's look at how they've been addressed in more
    detail. First, let's consider how the much less error-prone URL naming convention
    allows easier access to remote resources. Then we'll look at how the DNS provides
    a bridge between the usability of URLs or domain names, and the speed and reliability
    of IP addressing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在对网络中资源定位必须解决的主要问题有了一个坚实的理解之后，让我们更详细地看看这些问题是如何被解决的。首先，让我们考虑一下，为什么相对较少出错的URL命名约定使得访问远程资源更加容易。然后我们将探讨DNS如何成为URL或域名可用性和IP地址速度及可靠性之间的桥梁。
- en: URLs – user-friendly addressing
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URLs – 用户友好的寻址
- en: I've been taking a very basic approach to explaining the nature of locating
    resources so far. I'm certainly aware, though, that most of you probably have
    at least some idea of how that happens in, at the very least, a high-level context.
    Hell, you likely used a web browser to find this book in the first place, and
    had a pretty solid idea that the long string of seemingly random words and letters
    strung together in your browsers address bar was, in fact, a URL. However, I have
    certainly met my fair share of developers who were surprised to learn exactly
    how URLs are constructed and used. So, much as we've done so far, we're going
    to start with a very basic explanation of what exactly URLs are, and how we can
    use them to find what we need.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我到目前为止一直采用一个非常基本的解释方法来解释定位资源的本质。我当然知道，你们中的大多数人可能至少对在至少一个高级环境中它是如何发生的有一些了解。实际上，你们很可能使用了一个网络浏览器来找到这本书，并且对浏览器地址栏中串联在一起的看似随机的单词和字母实际上是URL的事实有一个相当清晰的认识。然而，我确实遇到了一些开发者，他们对URL的构建和使用方式感到惊讶。所以，就像我们到目前为止所做的那样，我们将从对URL究竟是什么以及我们如何使用它们来找到我们所需的东西进行一个非常基本的解释开始。
- en: '**Uniform Resource Locator** (**URL**) is a universally agreed-upon standard
    for (unsurprisingly) locating resources on the web. It does so by specifying the
    mechanism by which to retrieve the resource, as well as the specific route over
    which to retrieve it. It does so by specifying the order of, and delimiters between,
    specific components that collectively define the specific physical location of
    any resource. The specification will initially seem complicated, but will become
    more intuitive as we elaborate on the components and the responsibilities they
    hold.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**统一资源定位符**（**URL**）是一个普遍认可的标准，用于（不出所料）在网络上定位资源。它通过指定检索资源的方式以及检索它的具体路径来实现这一点。它通过指定定义任何资源特定物理位置的特定组件的顺序和分隔符来实现这一点。这个规范一开始可能看起来很复杂，但随着我们对组件及其所承担的责任进行详细阐述，它将变得更加直观。'
- en: URL components
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL组件
- en: Every URL begins with the scheme by which a resource should be located. This
    specifies the transport mechanism, or location type, that should be used to find
    what you're looking for. There is a finite list of universally valid schemes that
    you can specify, including http, ftp, and even file for locally hosted resources.
    The scheme is always followed by a colon (`:`) delimiter. After the scheme specification,
    a URL could contain an optional authority specification, which itself contains
    a small handful of sub-components.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个URL都以一个方案开始，该方案指定了定位资源时应使用的传输机制或位置类型。你可以指定一系列普遍有效的方案，包括http、ftp，甚至对于本地托管资源，还有file。方案后面总是跟着一个冒号（`:`）分隔符。在方案指定之后，一个URL可以包含一个可选的权限指定，它本身包含一小部分子组件。
- en: The authority component
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权限组件
- en: 'The authority has a designated prefix: the special delimiter of two consecutive
    forward slash (`//`) characters, whose presence indicates that characters that
    follow should be parsed according to the specification for a URL authority. This
    prefix is optionally followed by access credentials, or user information, which
    transmits an optional user ID and/or password to the destination host. These values,
    if included, will always be separated from one another with a colon (`:`) as a
    delimiter, and will be separated from the rest of the authority component with
    an at sign (`@`) delimiter.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 权限有一个指定的前缀：两个连续的斜杠（`//`）特殊分隔符，其存在表示随后应按照URL权限的规范进行解析。这个前缀后面可以跟访问凭证或用户信息，它将可选的用户ID和/或密码传输到目标主机。如果包含这些值，它们将始终用冒号（`:`）作为分隔符彼此分开，并用一个at符号（`@`）分隔符与权限组件的其余部分分开。
- en: Whether access credentials are included as part of the authority or not, it
    will always include a host domain. This always follows either the double forward
    slash (`//`) prefix, or, in the event of access credentials, the (`@`) delimiter.
    The host domain specifies the physical address of the hardware hosting the resource
    being located. It can be specified as either a registered domain name, or the
    underlying IP address for the hardware.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 无论访问凭证是否作为权威机构的一部分，它都将始终包含主机域名。这始终跟随双正斜杠（`//`）前缀，或者在存在访问凭证的情况下，跟随（`@`）分隔符。主机域名指定了托管资源的硬件的物理地址。它可以指定为注册的域名，或者硬件的底层IP地址。
- en: Finally, an authority might specify a listening port on the host. This is delimited
    from the host domain name or IP address by the colon (`:`) character, and indicates
    the only ports on the hardware to which requests for the specified resource should
    be sent.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，权威机构可能会指定主机上的监听端口。这由冒号（`:`）字符与主机域名或IP地址分隔，并指示硬件上请求指定资源的唯一端口。
- en: The path component
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路径组件
- en: The path component specifies a series of path segments over which requests must
    travel to arrive at the searched for resource. Each segment of the path is individually
    delimited with a forward slash (`/`) character. It's technically valid to have
    an empty segment as part of your path, resulting in two consecutive forward slash
    characters (`//`).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 路径组件指定了一系列路径段，请求必须通过这些路径段到达要搜索的资源。路径的每个段都由一个正斜杠（`/`）字符单独分隔。在技术上，可以将空段作为路径的一部分，从而产生两个连续的正斜杠字符（`//`）。
- en: The query component
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询组件
- en: After the final segment of the path, the URL may contain an optional query component,
    indicated by the presence of the question mark character (`?`) delimiter. The
    query component allows users to specify additional parameters for more specific
    results from the requested resource. Each different query comes in the form of
    a parameter, the equals sign (`=`) delimiter, and the requested value of the query
    parameter. Finally, each parameter is delimited by either a semi-colon (`;`) or
    ampersand (`&`) delimiter between any two query parameters and their values.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在路径的最后一个部分之后，URL可能包含一个可选的查询组件，由问号字符（`?`）分隔符表示。查询组件允许用户为请求的资源指定额外的参数，以获得更具体的结果。每个不同的查询都采用参数的形式，由等号（`=`）分隔符，以及查询参数的请求值。最后，每个参数由分号（`;`）或和号（`&`）分隔符与任何两个查询参数及其值之间的分隔符。
- en: The fragment component
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段组件
- en: The final piece of a URL, at least ordinarily, is the fragment component. It's
    an optional piece of the URL string, and its presence is indicated by the reserved
    pound, or hash (`#`) prefix. The fragment component is often used to identify
    a sub-component of the eventually-returned resource, and is typically used by
    web browsers to navigate to a specific fragment of the HTML document that was
    searched for.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: URL的最后一部分，至少通常情况下，是片段组件。它是一个可选的URL字符串部分，其存在由保留的井号或哈希（`#`）前缀表示。片段组件通常用于标识最终返回的资源的一个子组件，并且通常由网络浏览器用于导航到搜索的HTML文档的特定片段。
- en: Putting it all together
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有这些放在一起
- en: 'Having clearly enumerated all the relevant components of a URL, we can simplify
    things with a basic syntax specification. Every URL ultimately breaks down to
    the following structure, where optional components are designated with square
    brackets `[]`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 明确列举了URL的所有相关组件后，我们可以通过基本的语法规范来简化问题。每个URL最终都可以分解为以下结构，其中可选组件用方括号`[]`表示：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So here, we see plainly that the only required components of a URL are the scheme
    and subsequent colon delimiter, and a path. Everything else is optional, and you'll
    note that each optional component has its presence in the URL indicated by its
    unique prefix character. And we can, of course, expand on the following components.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，我们可以清楚地看到，URL的唯一必需组件是方案和随后的冒号分隔符，以及路径。其他所有内容都是可选的，并且你会注意到每个可选组件在URL中的存在都由其独特的分隔符字符表示。当然，我们还可以扩展以下组件。
- en: Authority specification
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权威指定
- en: 'The authority, as we already specified, can be broken down as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前指定的，权威机构可以分解如下：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So, if an authority component is present, it will always be prefixed with a
    (`//`) delimiter, and will always contain the host domain. Meanwhile, the access
    credentials component is also broken down as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果存在权威组件，它将始终以双斜杠（`//`）分隔符为前缀，并且始终包含主机域名。同时，访问凭证组件也被分解如下：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, only one component is required. However, if either component is present,
    then the (`@`) character separating access credentials from the host domain becomes
    a requirement. And, if both the `user_id` and the `password` functions are present,
    then the colon (`:`) delimiter between the two components will be required.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，只需要一个组件。然而，如果任一组件存在，那么分隔访问凭证和主机域的`(@)`字符就成为一个必需项。而且，如果`user_id`和`password`功能都存在，那么两个组件之间的冒号(`:`)分隔符也将是必需的。
- en: Query specification
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询规范
- en: 'Finally, the last component that has a well-defined specification for how it
    can be composed is the query component. It can be broken down as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于查询组件，有一个明确的规范说明其如何组成。它可以分解如下：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The sequence of additional delimiters and key-value pairs can extend all the
    way to the maximum allowable length of a valid URL.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 附加分隔符和键值对的序列可以一直延伸到有效URL的最大允许长度。
- en: By following these syntax specifications, you can decompose any URL you are
    presented with into its component parts, and meaningfully leverage it to access
    the resource it identifies.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些语法规范，你可以将你遇到的任何URL分解为其组成部分，并有效地利用它来访问它所标识的资源。
- en: The URL as a sub-type of the URI
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL作为URI的子类型
- en: We've spent the bulk of this section discussing URLs specifically. What you
    may not have realized, however, is that a URL is actually a single, specific kind
    of something known as a **Uniform Resource Identifier** (**URI**), which is a
    string of characters adhering to a well-defined syntax that universally and uniquely
    identifies a resource on a network.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节的大部分内容中专门讨论了URL。然而，你可能没有意识到的是，URL实际上是一种称为**统一资源标识符**（**URI**）的单个、特定类型的对象，它是一系列遵循良好定义语法的字符，可以在网络上唯一地标识资源。
- en: The distinction between a URL and a URI is subtle, and almost entirely conceptual.
    The simplest way to characterize that distinction is to note that, by using a
    URL, we are guaranteed to be able to identify and locate a requested resource.
    The only thing we are guaranteed, given a simple URI, is an ability to identify
    it that is to distinguish the resource from any other arbitrary resource.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: URL和URI之间的区别是微妙的，几乎完全是概念性的。最简单的方式来描述这种区别是，通过使用URL，我们保证能够识别和定位请求的资源。给定一个简单的URI，我们保证的唯一能力是识别它，即区分该资源与任何其他任意资源。
- en: In practice, however, the terms URL and URI are frequently used interchangeably.
    This is because, since URL is a specific kind of URI, it's always valid to characterize
    a URL as a URI. Meanwhile, it is often sufficient to characterize a URI as a URL
    since knowing the specific identity of a resource within the context of a network
    is usually enough to then locate that resource.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，URL和URI这两个术语经常被互换使用。这是因为，由于URL是URI的一种特定类型，因此将其描述为URI总是有效的。同时，通常将URI描述为URL就足够了，因为在网络环境中知道资源的特定标识通常足以定位该资源。
- en: If you're wondering why I brought up a subject of such apparent triviality,
    it's for clarity's sake. Over the course of this book, I'll consistently talk
    about resources as being identified by their URL. However, the class exposed by
    .NET Core for constructing, decomposing, and leveraging these addresses is named
    for the more generic URI specification. In fact, let's take a quick look at that
    class now.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道我为什么要提及这样一个看似微不足道的话题，那是为了清晰起见。在本书的整个过程中，我将会一致地谈论资源是通过其URL来标识的。然而，.NET
    Core暴露的用于构建、分解和利用这些地址的类是以更通用的URI规范命名的。事实上，让我们现在快速看一下这个类。
- en: The System.Net.UriBuilder class
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`System.Net.UriBuilder`类'
- en: If you've made it all the way through this elaborate definition of the URL specification,
    you might be wondering how on earth you can leverage this in your code to access
    a resource, when you already know specifically where to look for it. Enter, dear
    readers, the `UriBuilder` class!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完整地阅读了关于URL规范的定义，你可能想知道如何在实际代码中利用这些知识来访问资源，尤其是当你已经知道具体位置时。亲爱的读者们，请允许我介绍`UriBuilder`类！
- en: Living in the `System.Net` namespace, the `UriBuilder` class is a factory class
    for generating instances of the `Uri` class. It provides users with several overloaded
    constructors to allow the specification of more of the components of a valid URL
    progressively. It also provides accessors to properties representing each of those
    components individually. Finally, it provides a function to produce the well-formed
    instance of the `Uri` class from the component parts.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`System.Net`命名空间中，`UriBuilder`类是一个用于生成`Uri`类实例的工厂类。它为用户提供几个重载的构造函数，允许逐步指定更多有效URL的组件。它还提供了访问器，用于表示每个组件的属性。最后，它提供了一个函数，可以从组件部分生成格式良好的`Uri`类实例。
- en: 'Let''s start with a very simple example. We''ll use `UriBuilder` to compose
    an instance of `Uri` with only the `Scheme` and `Host` components as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的例子开始。我们将使用`UriBuilder`来组合一个只包含`Scheme`和`Host`组件的`Uri`实例，如下所示：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this method, we can see how the `UriBuilder` class composes a well-formed
    and syntactically correct `Uri` out of the component parts we specify, as demonstrated
    in the following code snippet:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以看到`UriBuilder`类如何将我们指定的组件部分组合成一个格式良好且语法正确的`Uri`，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By running this program, you should see the `http://packt.com` output while
    your console is open for ten seconds, before it closes and the application terminates.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行此程序，当您的控制台开启十秒钟后，您应该看到`http://packt.com`输出，然后程序关闭并终止。
- en: Here, we didn't need to specify that the `http` component of the URL should
    be followed by a colon character. We didn't say anything about the host we specified
    being prefixed with the `//` prefix characters. The `UriBuilder` class did that
    for us. This factory class gives us a clean way to incrementally construct a more
    specific desired location, without us, as the developers, having to keep the nitty-gritty
    details of delimiters, prefixes, and suffixes in our heads all the time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不需要指定URL的`http`组件后面应该跟一个冒号字符。我们没有提到我们指定的主机前面应该有`//`前缀字符。`UriBuilder`类为我们做了这件事。这个工厂类为我们提供了一个干净的方式来逐步构建一个更具体的期望位置，而无需我们作为开发者，总是要在脑海中记住分隔符、前缀和后缀的琐碎细节。
- en: In this example, we leveraged the fact that the `UriBuilder` class provides
    public `get` access to all of the properties that it has to encapsulate each component
    of a `Uri`. However, you can also apply many of those properties through a series
    of overloaded constructors, if you know their values at the time of construction.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们利用了`UriBuilder`类提供了对所有属性的公共`get`访问权限的事实，以便封装`Uri`的每个组件。然而，如果您在构造时知道它们的值，您也可以通过一系列重载的构造函数应用许多这些属性。
- en: 'The `UriBuilder` class has seven overloaded constructors. We''ve seen the default
    constructor, taking no parameters, but now let''s look at a program that leverages
    each of the constructors and see what they provide. Given that we know the transport
    scheme and domain name we intend to look up, we can simplify our initial method
    for a simple `Uri` as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`UriBuilder`类有七个重载的构造函数。我们已经看到了默认构造函数，它不接受任何参数，但现在让我们看看一个利用每个构造函数的程序，并看看它们提供了什么。鉴于我们知道我们打算查找的传输方案和域名，我们可以简化我们的初始方法，如下所示：'
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With that change, the output from our `TestUriProgram` will print the exact
    same string we saw before, but the code to produce that output is one-third of
    the size. Whenever possible, I recommend using the constructor overloads to instantiate
    the `UriBuilder` class. Doing so shrinks our code height and makes our intentions
    explicit when instantiating the class. Always be more explicit in your code when
    possible.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，我们的`TestUriProgram`的输出将打印出我们之前看到的相同字符串，但生成该输出的代码大小只有原来的三分之一。在可能的情况下，我建议使用构造函数重载来实例化`UriBuilder`类。这样做可以缩小我们的代码体积，并在实例化类时使我们的意图更加明确。在可能的情况下，始终使您的代码更加明确。
- en: Hosts – domain names and IPs
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机 - 域名和IP
- en: In my description of the host component of a URL, I specified that the host
    domain could be either a domain name, or an IP address. As I mentioned before,
    an IP address is the underlying numeric address used by routing hardware and software
    to navigate to a resource on a network. It's the unique ID, specific to a piece
    of hardware at a specific location. A domain name, however, is the human-readable
    string of words and alpha-numeric characters used to make addressing easier and
    more consistent. It is more consistent, easily remembered, and less prone to error
    than a raw IP address. What's interesting, however, is that domain names and their
    IP addresses are actually functionally interchangeable. In any context in which
    you can use one, you can always safely substitute the other.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我对URL的主机部分的描述中，我指定了主机域名可以是域名或IP地址。正如我之前提到的，IP地址是路由硬件和软件用于在网络中导航到资源的基础数字地址。它是特定位置上特定硬件的唯一ID。然而，域名是由人类可读的单词和字母数字字符组成的字符串，用于使寻址更加容易和一致。它比原始IP地址更一致、更容易记忆且更不容易出错。然而，有趣的是，域名及其IP地址在功能上是可互换的。在任何可以使用一个的地方，你都可以安全地替换另一个。
- en: Given that IP addresses can be resolved directly by the network transport layer,
    and don't need to be resolved before they can be serviced by any node in the routing
    process, we'll ignore them for now. We'll explore the syntax, limitations, and
    advantages gained by using the IP address of a device later on in this book. For
    now, though, we're more concerned with how we can find the IP address in the first
    place. That's why, for this chapter at least, we're only concerning ourselves
    with domain names and how they're resolved by the DNS.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IP地址可以直接由网络传输层解析，并且在使用过程中不需要在节点之前进行解析，所以我们现在暂时忽略它们。我们将在本书的后面部分探讨使用设备IP地址的语法、限制和优势。然而，目前我们更关注的是如何首先找到IP地址。这就是为什么，至少在本章中，我们只关注域名以及它们是如何通过DNS进行解析的。
- en: I'd bet that among everyone reading this book, there isn't a single person who
    knows a single other person who hasn't typed [google.com](http://google.com) or
    [en.wikipedia.org](https://en.wikipedia.org/wiki/Main_Page) into their browser's
    address bar. Our use of domain names is ubiquitous, and yet most of us have no
    idea how, exactly, they are created or used. Even for me, it wasn't until I was
    explicitly tasked with writing software for resolving those domain names on an
    internal network that I finally took the time to understand what made that system
    work. At that time, I learned how the web of DNS servers facilitated network usage
    by human users. While I only mentioned it previously, it's time to consider just
    what the DNS is more deeply, and how we can use it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌，在阅读这本书的所有人中，没有一个人认识一个没有在浏览器地址栏中输入[google.com](http://google.com)或[en.wikipedia.org](https://en.wikipedia.org/wiki/Main_Page)的人。我们使用域名的普遍性是毋庸置疑的，然而，我们中的大多数人并不知道它们是如何创建或使用的。即使对我来说，直到我被明确要求编写用于解析内部网络上域名的软件时，我才终于花时间理解是什么让这个系统工作。那时，我了解到DNS服务器网络如何促进人类用户的网络使用。虽然我之前已经提到过，现在是时候更深入地考虑DNS是什么，以及我们如何使用它了。
- en: The DNS is a distributed, decentralized network of authoritative servers that
    hosts a directory of all sub-domain servers, as well as any domain names that
    can be resolved by that authoritative server. Any domain name that has been registered
    with a certified domain name registrar**,** and which meets the syntax standards
    of a domain name (and which hasn't already been registered), is considered valid.
    Valid domain names are added to the distributed registry hosted by authoritative
    servers. Between your computer and any other network node you hope to interact
    with using a valid, registered domain name, your request will have to interact
    with one or more of these name servers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: DNS是一个分布式的、去中心化的权威服务器网络，它托管着所有子域名服务器以及可以被该权威服务器解析的任何域名。任何已经注册到认证域名注册商的域名，并且符合域名语法标准（且尚未被注册），都被认为是有效的。有效的域名被添加到由权威服务器托管的分布式注册表中。在您的计算机和您希望使用有效注册域名与之交互的任何其他网络节点之间，您的请求将必须与这些名称服务器中的一个或多个进行交互。
- en: Each server will inspect the domain name given, and look up the domain in its
    own directory of names and IP address mappings. Naturally, the server will first
    determine if the given name can be resolved by that server, or at least by one
    of its subordinate servers. If so, the authoritative server simply replaces the
    domain name in the request with the IP address to which it maps, and forwards
    the request along accordingly. If the current server cannot resolve the domain
    name, however, it will forward it along up the hierarchy of name servers to a
    more general, parent domain. This process continues up to the root name server,
    or until the name is resolved.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务器将检查提供的域名，并在其自己的域名和IP地址映射目录中查找该域名。自然地，服务器将首先确定该服务器是否能够解析该域名，或者至少通过其下属服务器之一进行解析。如果是这样，权威服务器只需将请求中的域名替换为它所映射的IP地址，并相应地转发请求。然而，如果当前服务器无法解析域名，它将沿着名称服务器层次结构向上转发，直到根名称服务器，或者直到域名被解析。
- en: The DNS in C#
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#中的DNS
- en: It is occasionally necessary to identify the underlying IP address for a domain
    name from within the context of our software. For that, .NET Core provides the
    static `Dns` class as part of the `System.Net` namespace. With the `Dns` class,
    we can access directory information as returned by the nearest downstream name
    server capable of resolving the given name. We can request an instance of the
    `IPHostEntry` class, containing all of the relevant directory information of a
    DNS entry, or simply an array of IP addresses registered to resolve requests against
    the domain name.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在软件的上下文中识别域名的基础IP地址是必要的。为此，.NET Core提供了`System.Net`命名空间中的静态`Dns`类。使用`Dns`类，我们可以访问由能够解析给定名称的最近下游名称服务器返回的目录信息。我们可以请求`IPHostEntry`类的实例，其中包含DNS条目的所有相关目录信息，或者简单地请求一个IP地址数组，这些IP地址已注册以解析针对域名的请求。
- en: 'To see this in action, simply invoke any of the methods exposed by the static
    `Dns` class in a sample program as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此操作的实际效果，只需在示例程序中调用静态`Dns`类公开的任何方法，如下所示：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With this program, we should see the following output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此程序，我们应该看到以下输出：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Of course, the IP address that is resolved when you look for a host entry that
    resolves the `google.com` domain name will likely be different. Google's servers
    are widely distributed, and the specific server slice (and its associated IP address)
    that is nearest your network location will be what resolves a lookup of that domain
    name.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当您查找解析`google.com`域名的主机条目时，解析出的IP地址可能会有所不同。谷歌的服务器分布广泛，距离您的网络位置最近的特定服务器切片（及其关联的IP地址）将解析该域名的查找。
- en: If you want to validate that the IP address returned is in fact what is registered
    for that domain name, you can actually intercept the host entry lookup locally
    by modifying your computer's hosts file. On a Windows OS, that file will live
    at the `C:\Windows\System32\drivers\etc\hosts` directory, and will have no file
    extension. On macOS and *nix systems, it simply lives at `\etc\hosts`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想验证返回的IP地址确实是该域名的注册地址，您实际上可以通过修改计算机的hosts文件在本地拦截主机条目查找。在Windows操作系统上，该文件位于`C:\Windows\System32\drivers\etc\hosts`目录，并且没有文件扩展名。在macOS和*nix系统上，它简单地位于`\etc\hosts`。
- en: 'This file serves as the first stop on any outbound requests for a network resource
    addressed by a host name. It is, technically, your computer''s internal name server,
    and you can use it to direct traffic any way you''d like. To demonstrate this,
    add an entry to your hosts file as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件是针对由主机名地址的网络资源的任何出站请求的第一个停止点。技术上讲，它是您计算机的内部名称服务器，您可以使用它以任何您想要的方式引导流量。为了演示这一点，按照以下方式向您的hosts文件添加条目：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, opening your command prompt, navigate to an empty folder, and spin up
    a new .NET Core Web API project with the following CLI command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开您的命令提示符，导航到一个空文件夹，并使用以下CLI命令启动一个新的.NET Core Web API项目：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Your console should print information about .NET Core, telemetry, ASP.NET Core,
    and finally, finish execution with the following line:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您的控制台应打印有关.NET Core、遥测、ASP.NET Core的信息，最后，以以下行结束执行：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Assuming that this worked, you can immediately run the application by executing
    the following command from within the same directory that you created the project:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这成功了，您可以直接从创建项目的同一目录中执行以下命令来运行应用程序：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After this, you should see that your application is running and listening,
    as seen in the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您应该看到应用程序正在运行并监听，如下面的截图所示：
- en: '![](img/07246658-3674-4d45-96bf-e0e89da8e0af.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/07246658-3674-4d45-96bf-e0e89da8e0af.png)'
- en: Pay attention to the specific port your application is listening on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意应用程序监听的具体端口。
- en: 'If we look inside the blank Web API application, we can see that .NET Core
    stood up a single controller, named `ValuesController`, and that it exposes a
    number of REST endpoints. The only things that we''re concerned with for now is
    the route specified for the API, and the endpoint listening for HTTP GET requests,
    listed as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看空白Web API应用程序内部，我们可以看到.NET Core启动了一个名为`ValuesController`的单个控制器，并且它公开了多个REST端点。我们现在所关心的只是API指定的路由和监听HTTP
    GET请求的端点，如下所示：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This tells us that we should expect to see the `"value"` result if we navigate
    to the `/api/values/{id}` path on the listening port of our local machine.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，如果我们导航到本地机器监听端口上的`/api/values/{id}`路径，我们应该期望看到`"value"`结果。
- en: 'Sure enough, if you open your browser of choice and type the application''s
    URL into your address bar, appending the path specified in the controller, you
    should see the value string displayed in your browser, as shown in the following
    screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 确实如此，如果你打开你选择的浏览器并在地址栏中输入应用程序的URL，附加控制器中指定的路径，你应该能在浏览器中看到显示的值字符串，如下面的截图所示：
- en: '![](img/a1aebff3-3c6a-4132-b7d4-76aed2098e0d.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a1aebff3-3c6a-4132-b7d4-76aed2098e0d.png)'
- en: What's interesting, though, is that localhost is itself an alias for the `127.0.0.1`
    IP address. By convention, that address always resolves to the current local machine.
    Since we modified our hosts file, however, we should be able to replace `localhost`
    in our URL with the `fun.with.dns.com` as new domain name. Make the change in
    your browser, and you'll see the same response!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有趣的是，localhost本身是`127.0.0.1` IP地址的一个别名。按照惯例，该地址始终解析为当前本地机器。然而，由于我们修改了hosts文件，因此我们应该能够将URL中的`localhost`替换为新的域名`fun.with.dns.com`。在浏览器中进行更改，你将看到相同的响应！
- en: Now that we've seen how to set up our own domain name entries locally, we can
    use our hosts file to explore the `Dns` class in more detail, and validate the
    responses.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何在本地设置自己的域名条目，我们可以使用我们的hosts文件来更详细地探索`Dns`类，并验证响应。
- en: 'First, add an additional entry to the hosts file with a new IP address, but
    the same fake domain name as before. Your new hosts file should read as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在hosts文件中添加一个具有新IP地址的新条目，但与之前相同的假域名。你的新hosts文件应如下所示：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, it doesn''t actually matter what the addresses are, since we won''t be
    looking for resources at those locations. What matters is that there are two.
    With those entries in place, you can see more concretely how the `Dns` class in
    .NET exposes a host entry from the nearest domain name server that can resolve
    it. We can modify our program from before as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，地址本身并不重要，因为我们不会在那些位置查找资源。重要的是有两个地址。有了这些条目，你可以更具体地看到.NET中的`Dns`类如何从最近的域名服务器中公开一个可以解析的主机条目。我们可以修改之前的程序如下：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can now see the following output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到以下输出：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This demonstrates how we can access host information for a given domain name
    or IP address using the `Dns` class. Note that the instance of the `HostEntry`
    class returned by the methods of the `Dns` class always contain all of the IP
    addresses for which there is a record in the naming server. Even when we looked
    up the `HostEntry` class by a specific IP address, the `Dns` class still resolved
    and returned every other IP address registered for the domain name that matched
    the IP address of the original lookup. This provides the flexibility of being
    able to access and leverage alternative hardware resources for a given request
    in the event that one of the registered addresses is unresponsive. The extent
    to which you'll leverage this class in your work may vary, but I hope you see
    now that it can be a useful tool to keep in your belt.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这演示了我们可以如何使用`Dns`类访问给定域名或IP地址的主机信息。请注意，`Dns`类的方法返回的`HostEntry`类实例总是包含在命名服务器中记录的所有IP地址。即使我们通过特定的IP地址查找`HostEntry`类，`Dns`类仍然解析并返回与原始查找IP地址匹配的域名注册的所有其他IP地址。这提供了灵活性，可以在注册的地址之一无响应的情况下，能够访问和使用替代硬件资源。你将在工作中利用这个类到什么程度可能会有所不同，但我希望你现在能看到它可以是一个有用的工具，可以放在你的工具箱里。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we examined the primary characteristics network engineers identified
    as necessary to make networks viable. We considered the trade-off of usability
    for routing hardware versus readability for humans when defining a standard syntax
    for network addressing. With that consideration in mind, we looked at how the
    work of the telecom engineers of previous generations contributed hugely to the
    solutions that were ultimately standardized on all modern networks today.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了网络工程师识别为使网络可行的必要的主要特征。我们在定义网络寻址的标准语法时，考虑了路由硬件的可用性与人类可读性之间的权衡。考虑到这一点，我们研究了前一代电信工程师的工作如何极大地贡献于今天所有现代网络最终标准化的解决方案。
- en: Within that context, we looked at how IP addresses are used by network hardware
    to locate resources, and how the DNS facilitates the more memorable, human-readable
    addressing schemes of URLs and URIs. We learned how those domain names are explicitly
    mapped to their underlying IP addresses by implementing a domain name server of
    our own, using the hosts file of our operating system. Using the sandbox of our
    self-contained DNS server, we explored the C# classes provided by the System.Net
    namespace to facilitate building syntactically correct URLs, and leveraging the
    DNS to lookup the underlying IP addresses of a given URL, or resolve requests
    to do the same.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，我们研究了网络硬件如何使用IP地址定位资源，以及DNS如何促进URL和URI更易记、更易读的寻址方案。我们通过实现自己的域名服务器，使用操作系统的hosts文件，学习了那些域名名是如何明确映射到其底层IP地址的。使用我们自包含的DNS服务器沙盒，我们探索了System.Net命名空间提供的C#类，以促进构建语法正确的URL，并利用DNS查找给定URL的底层IP地址，或解析相同的请求。
- en: With this foundation in place, we'll use the next chapter to explore the communication
    protocols that allow for data transmission from one host to another. We'll look
    at how a standardized model facilitates communication between entities, and take
    a close look at some of the most common protocols used in that communication.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个基础上，我们将使用下一章来探索允许数据从一个主机传输到另一个主机的通信协议。我们将研究标准化模型如何促进实体之间的通信，并仔细研究在那种通信中最常用的协议。 '
- en: Questions
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the three characteristics network engineers seek to achieve for long-term
    viability of a network addressing standard?
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络工程师寻求实现网络寻址标准长期可行性的三个特征是什么？
- en: How did telecom engineers sacrifice the maximum possible scale of telecom networks
    to achieve higher routing performance?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电信工程师是如何牺牲电信网络可能的最大规模以实现更高的路由性能的？
- en: What are the phone number and phone book of the modern internet?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现代互联网的电话号码和电话簿是什么？
- en: How does a URL locate resources on the web?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: URL是如何在网络上定位资源的？
- en: What are the valid components of a URL? Which of them are optional?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: URL的有效组成部分有哪些？其中哪些是可选的？
- en: What is a fully qualified domain name?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是完全合格域名？
- en: How is a device given a domain name?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备是如何获得域名名的？
- en: Further reading
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For more information on URLs, domains, and resource location on networks, consider
    *Managing Mission-Critical Domains and DNS* by *Mark E. Jeftovic*. It provides
    a deeper and more considered analysis of working with the DNS, and strategies
    for leveraging that system to your advantage when constructing networks of your
    own.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 关于URL、域名和网络上的资源定位的更多信息，请考虑阅读*马克·E·杰夫托维奇的《管理关键任务域名和DNS》*。它提供了对与DNS合作的更深入和更周到的分析，以及利用该系统在构建自己的网络时获得优势的策略。
