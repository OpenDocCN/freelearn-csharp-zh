<html><head></head><body>
		<div id="_idContainer208">
			<h1 id="_idParaDest-350" class="chapter-number"><a id="_idTextAnchor349"/>15</h1>
			<h1 id="_idParaDest-351"><a id="_idTextAnchor350"/>Asynchronous Communication with Messages and Events</h1>
			<p>In the previous chapter, we updated our services using binary communication. However, some services don’t need connected services: the client and the server do not need to be connected at the same time, which means communication can be done asynchronously. This communication can be done by sending messages to a queue or <span class="No-Break">publishing events.</span></p>
			<p>In this chapter, we’ll use Azure services for asynchronous communication – that is, Azure Queue Storage and Azure Event Hubs. We’ll also use Apache Kafka as an <span class="No-Break">alternative option.</span></p>
			<p>You’ll learn how to do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Differentiate message queues <span class="No-Break">and events</span></li>
				<li>Send and receive messages using <span class="No-Break">a queue</span></li>
				<li>Publish and subscribe events with Azure <span class="No-Break">Event Hubs</span></li>
				<li>Use Apache Kafka for <span class="No-Break">event processing</span></li>
			</ul>
			<h1 id="_idParaDest-352"><a id="_idTextAnchor351"/>Technical requirements</h1>
			<p>In this chapter, like the previous chapters, you’ll need an Azure subscription and <span class="No-Break">Docker Desktop.</span></p>
			<p>The code for this chapter can be found in this book’s GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/"><span class="No-Break">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/</span></a><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">ch15</strong> folder contains the projects for this chapter, along with their outputs. To add the functionality from this chapter, you can start with the source code from the <span class="No-Break">previous chapter.</span></p>
			<p>We’ll be considering the following projects in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><strong class="source-inline">Codebreaker.AppHost</strong>: The .NET Aspire host project. The app model has been enhanced by adding Azure Storage, Azure Event Hubs, and Apache <span class="No-Break">Kafka services.</span></li>
				<li><strong class="source-inline">Codebreaker.BotQ</strong>: This is a new project that contains nearly the same code as <strong class="source-inline">Codebreaker.Bot</strong>. However, instead of using a REST API to trigger gameplay, a message queue <span class="No-Break">is used.</span></li>
				<li><strong class="source-inline">Codebreaker.GameAPIs</strong>: This project has been updated so that it doesn’t forward completed games to <strong class="source-inline">live-service</strong> directly. Instead, it publishes events to Azure Event Hubs or Apache Kafka depending on the launch <span class="No-Break">profile startup.</span></li>
				<li><strong class="source-inline">Codebreaker.Live</strong>: This project has been changed so that it subscribes to events from Azure Event Hubs using async streams. The SignalR implementation has also been changed so that it uses <span class="No-Break">async streams.</span></li>
				<li><strong class="source-inline">Codebreaker.Ranking</strong>: This is a new project that receives events from Azure Event Hubs or Kafka, writes this information to an Azure Cosmos DB database, and offers a REST service to retrieve the rank of the day. With Event Hub, we have a different way to receive events than we do when <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">live-service</strong></span><span class="No-Break">.</span></li>
			</ul>
			<h1 id="_idParaDest-353"><a id="_idTextAnchor352"/>Comparing messages and events</h1>
			<p>In the previous chapter, we used<a id="_idIndexMarker1118"/> connected network communication<a id="_idIndexMarker1119"/> with all the services. First, we look into the communication between the bot and the game APIs as shown in <span class="No-Break"><em class="italic">Figure 15</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer198" class="IMG---Figure">
					<img src="image/B21217_15_01.jpg" alt="Figure 15.1 - Synchronous communication between the bot and the game APIs"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1 - Synchronous communication between the bot and the game APIs</p>
			<p>The bot service can be accessed<a id="_idIndexMarker1120"/> via REST. The bot service itself invokes the game<a id="_idIndexMarker1121"/> APIs service via gRPC (all other clients use REST with the game APIs service). The bot service then continues communication with the game APIs service, sends moves until the game is complete, and continues with the next game until a specified number of games is played. The bot client invokes the bot service via REST which is (like gRPC) synchronous communication, with request/reply. The bot service here doesn’t have a synchronous implementation, as the bot client doesn’t need to wait until all the games are played – the HTTP protocol would timeout during this time. Instead, the bot service returns an HTTP <strong class="source-inline">ACCEPTED</strong> answer (status code 202) with a unique identifier which can be used by the client to check for a status. The protocol itself is synchronous, as the client waits for <span class="No-Break">answer 202.</span></p>
			<p>When a game ends, the next part of the communication is shown with <span class="No-Break"><em class="italic">Figure 15</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer199" class="IMG---Figure">
					<img src="image/B21217_15_02.jpg" alt="Figure 15.2 - Synchronous communication initiated from the game APIs"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2 - Synchronous communication initiated from the game APIs</p>
			<p>The game APIs service informs<a id="_idIndexMarker1122"/> the ranking service and the live service<a id="_idIndexMarker1123"/> using gRPC. The live service continues communication via SignalR to inform all connected clients about the game end. The ranking service will be implemented in this chapter to write all ended games to a new database. To simplify this image, some services that are used within the communication are not shown. There’s synchronous communication between the game APIs and Azure Cosmos DB, similar to the <span class="No-Break">ranking service.</span></p>
			<p>With synchronous communication, if there’s a delay in one of the services, the delay goes back to the original caller. If there’s an error in one of the services, the client does not receive a <span class="No-Break">successful response.</span></p>
			<p>Microsoft Azure offers several services that can be used to create asynchronous communication: Azure Queue Storage, the Azure Service Bus, Azure Event Gird, and Azure Event Hub. Let’s have a look at a new version of the new sequence with the communication with the bot client and the bot service in <span class="No-Break"><em class="italic">Figure 15</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer200" class="IMG---Figure">
					<img src="image/B21217_15_03.jpg" alt="Figure 15.3 - Asynchronous communication between the bot client and the bot service"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3 - Asynchronous communication between the bot client and the bot service</p>
			<p>With the new implementation<a id="_idIndexMarker1124"/> the Azure Queue Storage comes into play. The bot service<a id="_idIndexMarker1125"/> registers with the queue to receive messages. The bot client, instead of using HTTP to communicate with the bot service, sends a message to the queue. The bot client does not need to wait if anybody started to work on this message. For the client, the job is done. The bot service, because it registered to receive messages, receives the message from the queue and plays the games in the same way as before, this <span class="No-Break">doesn’t change.</span></p>
			<p>Next, we look at the asynchronous communication initiated by the game APIs service in <span class="No-Break"><em class="italic">Figure 15</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer201" class="IMG---Figure">
					<img src="image/B21217_15_04.jpg" alt="Figure 15.4 – Asynchronous communication initiated from the game APIs"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.4 – Asynchronous communication initiated from the game APIs</p>
			<p>Here, the Azure Event Hub comes<a id="_idIndexMarker1126"/> into play. The game APIs service, instead<a id="_idIndexMarker1127"/> of doing synchronous communication both with the ranking and the live services, just communicates with the event hub. A game-ended event is pushed to this service. The game APIs doesn’t need to know who is interested in this event, who is receiving this event. Here, two subscribers, the ranking service and the live service are registered, and receive this event. From here on, communication is the same as before. The ranking service writes the received information to a database (which is not shown), and the live service forwards this information to clients that are subscribed to the live service – if they are subscribed to the same game type that is stored with <span class="No-Break">the event.</span></p>
			<p>The important difference between using message queues and events can be seen in this scenario. When sending a message to a queue, just one receiver deals with the message. Multiple readers can be connected to the same queue (for performance reasons), but only one reader processes the message. If the message is processed successfully, it’s removed from the queue. With<a id="_idIndexMarker1128"/> events, multiple subscribers receive and process<a id="_idIndexMarker1129"/> the <span class="No-Break">same event.</span></p>
			<p>Let’s look at the different options that are available with Microsoft Azure for messages <span class="No-Break">and events.</span></p>
			<h2 id="_idParaDest-354"><a id="_idTextAnchor353"/>Message queues</h2>
			<p>Microsoft Azure offers Azure<a id="_idIndexMarker1130"/> Queue Storage (part of the Azure Storage Account) and Service Bus queues that can be used for queuing messages. Azure Queue Storage is the simpler and cheaper option to use, but Azure Service Bus offers a lot more features, such as ordering guarantees, atomic operations, sending messages in a batch, duplicate detection, and more. See <a href="https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted">https://learn.microsoft.com/en-us/azure/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted</a> <span class="No-Break">for details.</span></p>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor354"/>Events</h2>
			<p>To publish and subscribe<a id="_idIndexMarker1131"/> to events, you can use Azure Event Grid and Azure Event Hubs. <strong class="bold">Azure Event Grid</strong> is easy to use to subscribe to events<a id="_idIndexMarker1132"/> with most Azure resources. In the Azure portal, with most resources, you can see the <strong class="bold">Events</strong> menu in the left bar. For example, when opening an Azure Storage Account, after clicking on <strong class="bold">Events</strong>, click <strong class="bold">Event Subscription</strong>. With a storage account, you’ll see event types such as <strong class="bold">Blob Created</strong>, <strong class="bold">Blob Deleted</strong>, <strong class="bold">Blob Renamed</strong>, <strong class="bold">Directory Created</strong>, <strong class="bold">Directory Deleted</strong>, <strong class="bold">Directory Renamed</strong>, <strong class="bold">Blob Tier Changed</strong>, and others, as shown in <span class="No-Break"><em class="italic">Figure 15</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer202" class="IMG---Figure">
					<img src="image/B21217_15_05.jpg" alt="Figure 15.5 – Create Event Subscription"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.5 – Create Event Subscription</p>
			<p>Event types are predefined by Azure resources. With event subscriptions, you can specify where the event should be fired. You can choose this with the endpoint, which can be an Azure function, a storage queue, a hybrid connection, a Webhook, and <span class="No-Break">so on.</span></p>
			<p>Event Grid also allows you to specify custom topics to be defined, high throughput with up to 10,000,000 events per second, and 100,000 operations a month for free. This service is available as a PaaS<a id="_idIndexMarker1133"/> offering running on Azure with the name <strong class="bold">Event Grid on Kubernetes with Azure Arc</strong> <span class="No-Break">on Kubernetes.</span></p>
			<p>To support even more events, massive scaling with partitions, and a big data<a id="_idIndexMarker1134"/> streaming platform with low latency, <strong class="bold">Azure Event Hubs</strong> can be used. This service offers reliable event delivery where events are stored for up to 7 days in case they have not been delivered. Event Hubs also has great integration with <span class="No-Break">streaming analytics.</span></p>
			<p>Let’s update the Codebreaker<a id="_idIndexMarker1135"/> solution with Azure Queues and Azure <span class="No-Break">Event Hubs.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">At the time of writing, .NET Aspire has planned support with Azure Event Grid. Event Hubs, Queue Storage, and Azure Service Bus are <span class="No-Break">already available.</span></p>
			<p>Let’s start reading from Azure Queue Storage with the Codebreaker <span class="No-Break">bot service.</span></p>
			<h1 id="_idParaDest-356"><a id="_idTextAnchor355"/>Creating a service that reads from Azure Queue Storage</h1>
			<p>The <strong class="source-inline">Codebreaker.Bot</strong> project we used<a id="_idIndexMarker1136"/> previously offers a minimal API service. With the updates, a REST API isn’t needed – a simple console application will do. Just create a new console application (<strong class="source-inline">dotnet new console -o Codebreaker.BotQ</strong>) and copy the source code from <strong class="source-inline">Codebreaker.Bot</strong>. The new bot will also use gRPC for communication with the game APIs service. Because this isn’t an ASP.NET Core application, these NuGet packages are needed <span class="No-Break">for gRPC:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">Google.Protobuf</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Grpc.Net.ClientFactory</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Grpc.Tools</strong></span></li>
			</ul>
			<p>For the DI container, we also need <strong class="source-inline">Microsoft.Extensions.Hosting</strong>, and for the .NET Aspire Storage<a id="_idIndexMarker1137"/> Queues component, we <span class="No-Break">need </span><span class="No-Break"><strong class="source-inline">Aspire.Azure.Storage.Queues</strong></span><span class="No-Break">.</span></p>
			<p>Next, we’ll update the <span class="No-Break">app model.</span></p>
			<h2 id="_idParaDest-357"><a id="_idTextAnchor356"/>Defining app-model for Azure Storage</h2>
			<p>With the AppHost<a id="_idIndexMarker1138"/> project, reference<a id="_idIndexMarker1139"/> the newly created project, <strong class="source-inline">Codebreaker.BotQ</strong>, and add the <strong class="source-inline">Aspire.Hosting.Azure.Storage</strong> NuGet package so that you can use the Azure <span class="No-Break">Storage resource.</span></p>
			<p>Invoke the <strong class="source-inline">AddAzureStorage</strong> method to specify Azure Storage with the <span class="No-Break">app model:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
<strong class="bold">// code removed for brevity</strong>
if (startupMode == "OnPremises")
{
}
else
{
<strong class="bold">  var storage = builder.AddAzureStorage("storage");</strong>
<strong class="bold">  var botQueue = storage.AddQueues("botqueue");</strong>
<strong class="bold">}</strong></pre>
			<p>The Azure Storage resource supports queues, tables, and blobs. This time, we’ll use queues, hence why we’re invoking the <strong class="source-inline">AddQueues</strong> <span class="No-Break">extension method.</span></p>
			<p>The project configuration references <span class="No-Break">the queue:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
<strong class="bold">string botLoop =</strong>
<strong class="bold">  builder.Configuration.GetSection("Bot")["Loop"] ??</strong>
<strong class="bold">    "false";</strong>
<strong class="bold">string botDelay =</strong>
<strong class="bold">  builder.Configuration.GetSection("Bot")["Delay"] ??</strong>
<strong class="bold">    "1000";</strong>
<strong class="bold">// code removed for brevity</strong>
<strong class="bold">builder.AddProject&lt;Projects.Codebreaker_BotQ&gt;("bot")</strong>
<strong class="bold">  .WithReference(insights)</strong>
<strong class="bold">  </strong><strong class="bold">.WithReference(botQueue)</strong>
<strong class="bold">  .WithReference(gameAPIs)</strong>
<strong class="bold">  .WithEnvironment("Bot__Loop", botLoop)</strong>
<strong class="bold">  .WithEnvironment("Bot__Delay", botDelay);</strong></pre>
			<p>Pay attention to using<a id="_idIndexMarker1140"/> the new bot project<a id="_idIndexMarker1141"/> instead of the old one. The new project references the queue to pass the connection string. In addition, we specify the <strong class="source-inline">Loop</strong> and <strong class="source-inline">Delay</strong> parameters, which are read from the configuration and set as environment variables on <span class="No-Break">starting </span><span class="No-Break"><strong class="source-inline">bot-service</strong></span><span class="No-Break">.</span></p>
			<p>These values are specified within the AppHost <span class="No-Break">development configuration:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/appsettings.Development.json</p>
			<pre class="source-code">
{
  // configuration removed for brevity
<strong class="bold">  "Bot": {</strong>
<strong class="bold">    "Loop": true,</strong>
<strong class="bold">    "Delay": 2000</strong>
<strong class="bold">  }</strong>
}</pre>
			<p>The new <strong class="source-inline">bot-service</strong> can read values from the storage queue in a loop – which is configured here. When published <a id="_idIndexMarker1142"/>with Azure, the loop<a id="_idIndexMarker1143"/> isn’t needed. This will be covered later in the <em class="italic">Deploying the solution to Microsoft </em><span class="No-Break"><em class="italic">Azure</em></span><span class="No-Break"> section.</span></p>
			<p>Now that the app model has been specified, let’s continue with the new <span class="No-Break">bot project.</span></p>
			<h2 id="_idParaDest-358"><a id="_idTextAnchor357"/>Using the storage queue component</h2>
			<p>With the previous bot<a id="_idIndexMarker1144"/> project, we received<a id="_idIndexMarker1145"/> values so that we could start playing a sequence of games. The same information is needed with the <span class="No-Break">new bot:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.BotQ/Endpoints/BotQueueClient.cs</p>
			<pre class="source-code">
public record class BotMessage(
  int Count, int Delay, int ThinkTime);</pre>
			<p>The <strong class="source-inline">Count</strong> property is for the number of games to play, the <strong class="source-inline">Delay</strong> property is for the delay between games, and the <strong class="source-inline">ThinkTime</strong> property is for the value of the think time between <span class="No-Break">game moves.</span></p>
			<p>The <strong class="source-inline">BotQueueClientOptions</strong> class is used to receive the configuration values that are passed from <span class="No-Break">the AppHost:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.BotQ/Endpoints/BotQueueClient.cs</p>
			<pre class="source-code">
// code removed for brevity
public class BotQueueClientOptions
{
  public bool Loop { get; set; } = false;
  public int Delay { get; set; } = 1000;
}</pre>
			<p>Within the constructor of the <strong class="source-inline">BotQueueClient</strong> class, <strong class="source-inline">options</strong>, <strong class="source-inline">logger</strong>, the previously used <strong class="source-inline">CodebreakerTimer</strong>, and <strong class="source-inline">QueueServiceClient</strong> <span class="No-Break">are injected:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.BotQ/Endpoints/BotQueueClient.cs</p>
			<pre class="source-code">
public class BotQueueClient(
<strong class="bold">  QueueServiceClient client,</strong>
<strong class="bold">  CodebreakerTimer timer,</strong>
  ILogger&lt;BotQueueClient&gt; logger,
  <strong class="bold">IOptions&lt;BotQueueClientOptions&gt; options</strong>)
{
// code removed for brevity</pre>
			<p>The <strong class="source-inline">QueueService</strong> client class<a id="_idIndexMarker1146"/> is from the <strong class="source-inline">Azure.Storage.Queues</strong> namespace and communicates<a id="_idIndexMarker1147"/> with the Azure Storage queue resources to get information about queues, as well as to create queues. With the implementation of <strong class="source-inline">CodebreakerTimer</strong>, a timer is used to play game after game. It uses the values we receive in the message from <span class="No-Break">the queue.</span></p>
			<p>The <strong class="source-inline">RunAsync</strong> method kicks off <span class="No-Break">the work:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.BotQ/Endpoints/BotQueueClient.cs</p>
			<pre class="source-code">
public async Task RunAsync()
{
<strong class="bold">  var queueClient = client.GetQueueClient(«botqueue»);</strong>
<strong class="bold">  await queueClient.CreateIfNotExistsAsync();</strong>
<strong class="bold">  var deadLetterClient = client.GetQueueClient(</strong>
<strong class="bold">    «dead-letter»);</strong>
<strong class="bold">  await deadLetterClient.CreateIfNotExistsAsync();</strong>
  bool repeat = options.Value.Loop;
  do
  {
<strong class="bold">    await ProcessMessagesAsync(</strong>
<strong class="bold">    queueClient, deadLetterClient);</strong>
    await Task.Delay(options.Value.Delay);
  } while (repeat);
}
// code removed for brevity</pre>
			<p>To read messages<a id="_idIndexMarker1148"/> from the queue, we use the <strong class="source-inline">QueueClient</strong> class. The <strong class="source-inline">QueueServiceClient</strong> method, <strong class="source-inline">GetQueueClient</strong>, returns <strong class="source-inline">QueueClient</strong> to communicate<a id="_idIndexMarker1149"/> with the queue named <strong class="source-inline">botqueue</strong>. With the app model we specified earlier, only the storage account is created, not the queue itself. We create the queue if it doesn’t already exist. Then – in a loop – we invoke <strong class="source-inline">ProcessMessagesAsync</strong>. If the loop isn’t set, messages are retrieved only once. This can be used when publishing Azure Container Apps jobs, as will be discussed in the <em class="italic">Deploying the solution to Microsoft </em><span class="No-Break"><em class="italic">Azure</em></span><span class="No-Break"> section.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">A dead letter queue can be checked to find out if there have been issues with messages. When a message cannot be successfully processed a few times, for example, when the receiver throws, the message is written to the dead <span class="No-Break">letter queue.</span></p>
			<p>Next, <strong class="source-inline">ProcessMessageAsync</strong> reads a message from <span class="No-Break">the queue:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.BotQ/Endpoints/BotQueueClient.cs</p>
			<pre class="source-code">
private async Task ProcessMessagesAsync(
  <strong class="bold">QueueClient queueClient,</strong>
<strong class="bold">  QueueClient deadLetterClient</strong>)
{
<strong class="bold">  QueueProperties properties =</strong>
<strong class="bold">    await queueClient.GetPropertiesAsync();</strong>
  if (<strong class="bold">properties.ApproximateMessagesCount &gt; 0</strong>)
  {
<strong class="bold">    QueueMessage[] messages =</strong>
<strong class="bold">      await queueClient.ReceiveMessagesAsync();</strong>
    foreach (var encodedMessage in messages)
    {
      if (<strong class="bold">encodedMessage.DequeueCount &gt; 3</strong>)
      {
<strong class="bold">        await deadLetterClient.SendMessageAsync(</strong>
<strong class="bold">          encodedMessage.MessageText);</strong>
<strong class="bold">        await queueClient.DeleteMessageAsync(</strong>
<strong class="bold">          encodedMessage.MessageId,</strong>
<strong class="bold">          encodedMessage.PopReceipt);</strong>
        continue;
      }
      byte[] bytes = Convert.FromBase64String(
        encodedMessage.MessageText);
<strong class="bold">      string message = Encoding.UTF8.GetString(bytes);</strong>
<strong class="bold">      var botMessage =</strong>
<strong class="bold">        JsonSerializer.Deserialize&lt;BotMessage&gt;(message);</strong>
<strong class="bold">      timer.Start(</strong>
<strong class="bold">        botMessage.Delay,</strong>
<strong class="bold">        botMessage.Count,</strong>
<strong class="bold">        botMessage.ThinkTime);</strong>
<strong class="bold">      await queueClient.DeleteMessageAsync(</strong>
<strong class="bold">        encMessage.MessageId, encMessage.PopReceipt);</strong>
    }
  }
}
// code removed for brevity</pre>
			<p>First, attributes of the queue are checked to see if there’s a message available using the <strong class="source-inline">ApproximateMessagesCount</strong> property. If this is the case, messages are retrieved using <strong class="source-inline">ReceiveMessagesAsync</strong>. This method reads the messages from the queue, at which point the messages can no longer be seen by others. The time the message is not visible can be set with the <strong class="source-inline">visibilityTimeout</strong> parameter. The default is 30 seconds. When successfully deserializing the message, it is deleted using <strong class="source-inline">DeleteMessageAsync</strong>. The <strong class="source-inline">timer.Start</strong> method starts a task to play the games asynchronously. So, if a game takes longer to play (with many games or with higher think times), this does not influence deleting the message. If the message returns to the queue, it can be processed again. The implementation<a id="_idIndexMarker1150"/> checks for the dequeue count of the message that’s retrieved. If it’s read three times, the message goes to a dead-letter queue and can be manually<a id="_idIndexMarker1151"/> checked <span class="No-Break">for issues.</span></p>
			<p>Next, let’s configure the <span class="No-Break">DI container:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.BotQ/ApplicationServices.cs</p>
			<pre class="source-code">
public static void AddApplicationServices(this IHostApplicationBuilder builder)
{
<strong class="bold">  builder.AddAzureQueueClient("botqueue");</strong>
<strong class="bold">  builder.Services.AddScoped&lt;BotQueueClient&gt;();</strong>
<strong class="bold">  var botConfig = builder.Configuration.GetSection("Bot");</strong>
<strong class="bold">  </strong><strong class="bold">builder.Services.Configure&lt;BotQueueClientOptions&gt;(</strong>
<strong class="bold">    section);</strong>
  builder.Services.AddScoped&lt;CodebreakerTimer&gt;();
  builder.Services.AddScoped&lt;CodebreakerGameRunner&gt;();
  builder.Services.AddSingleton&lt;IGamesClient,
    GrpcGamesClient&gt;()
    .AddGrpcClient&lt;GrpcGame.GrpcGameClient&gt;(
      client =&gt;
      {
        client.Address = new Uri("https://gameapis");
      });
}</pre>
			<p>The <strong class="source-inline">AddAzureQueueClient</strong> method is defined with the <strong class="source-inline">Aspire.Azure.Storage.Queues</strong> NuGet package. This method configures the Aspire component and registers the <strong class="source-inline">QueueService</strong> client with the DI container. With the environment variables passed by the AppHost, these values are retrieved using <strong class="source-inline">builder.Configuration.GetSection</strong> and configured<a id="_idIndexMarker1152"/> with the <strong class="source-inline">BotQueueClientOptions</strong> class, which defines the loop’s behavior. Other than this, the timer, game runner, and gRPC are configured<a id="_idIndexMarker1153"/> in the same way as the previous bot <span class="No-Break">service implementation.</span></p>
			<p>Now, we are ready to run the application and <span class="No-Break">test queues.</span></p>
			<h2 id="_idParaDest-359"><a id="_idTextAnchor358"/>Running the application</h2>
			<p>You can set breakpoints<a id="_idIndexMarker1154"/> within the new bot service project to verify the functionality of the queue. When you start the application, an Azure Storage Account is created. With the initialization of <strong class="source-inline">BotQueueClient</strong>, message queues are created. This can verified in the Azure portal, as shown in <span class="No-Break"><em class="italic">Figure 15</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer203" class="IMG---Figure">
					<img src="image/B21217_15_06.jpg" alt="Figure 15.6 – Storage queues created"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.6 – Storage queues created</p>
			<p>The <strong class="source-inline">botqueue</strong> and <strong class="source-inline">dead-letter</strong> storage queues<a id="_idIndexMarker1155"/> have been created. Now, open <strong class="source-inline">botqueue</strong> to pass a valid JSON message, as shown in <span class="No-Break"><em class="italic">Figure 15</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer204" class="IMG---Figure">
					<img src="image/B21217_15_07.jpg" alt="Figure 15.7 – Add message to queue"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.7 – Add message to queue</p>
			<p><strong class="bold">Encode the message body in Base64</strong> is selected by default – we used this encoding to read<a id="_idIndexMarker1156"/> the message. The message needs to be in a valid JSON format so that it can be deserialized by the <span class="No-Break"><strong class="source-inline">BotMessage</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
{
  "Count": 3,
  "Delay": 5,
  "ThinkTime": 1
}</pre>
			<p>With a valid JSON message, you will see that the message is processed. After sending a message that’s not in JSON<a id="_idIndexMarker1157"/> format, you’ll see the message in the dead-letter queue – after <span class="No-Break">some retries.</span></p>
			<p>As the bot now starts playing games when we send messages, let’s get into the next enhancement – using Azure <span class="No-Break">Event Hubs.</span></p>
			<h1 id="_idParaDest-360"><a id="_idTextAnchor359"/>Publishing messages to Azure Event Hubs</h1>
			<p>To use Azure Event Hubs, we’ll implement<a id="_idIndexMarker1158"/> the game APIs service<a id="_idIndexMarker1159"/> so that we can <span class="No-Break">publish events.</span></p>
			<h2 id="_idParaDest-361"><a id="_idTextAnchor360"/>Defining app-model for Event Hubs</h2>
			<p>To use Azure Event Hubs<a id="_idIndexMarker1160"/> with the AppHost project, the <strong class="source-inline">Aspire.Hosting.Azure.EventHubs</strong> NuGet package<a id="_idIndexMarker1161"/> <span class="No-Break">is required.</span></p>
			<p>Here, Event Hubs needs to be added to the <span class="No-Break">app model:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
var eventHub =
  <strong class="bold">builder.AddAzureEventHubs("codebreakerevents")</strong>
<strong class="bold">    .AddEventHub("games");</strong>
// code removed for brevity</pre>
			<p>The <strong class="source-inline">AddAzureEventHubs</strong> method, adds an Azure Event Hubs namespace, <strong class="source-inline">AddEventHub</strong>, as an event hub. A namespace is a management container with network endpoints and access control. The default Event Hub namespace that’s created is in the Standard tier. For development, you can change this to the Basic tier. Event hubs are created within namespaces. For scalability, event hubs use one or more partitions. By default, the event hub is created with four partitions. A partition contains an ordered stream of events. The number of partitions doesn’t change the price, but the number of throughput units does. With the number of throughput units, you specify a number of events per second. The number of partitions should be equal to or higher than the number of throughput units. Throughput units can be changed as needed; the number of partitions can only be changed in premium and <span class="No-Break">dedicated tiers.</span></p>
			<p>With the event hub specified, we can <span class="No-Break">reference it:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
<strong class="bold">var gameAPIs =</strong>
<strong class="bold">  </strong><strong class="bold">builder.AddProject&lt;Projects.Codebreaker_GameAPIs&gt;(</strong>
<strong class="bold">    "gameapis")</strong>
    .WithExternalHttpEndpoints()
    .WithReference(cosmos)
    .WithReference(redis)
    .WithReference(insights)
<strong class="bold">    .WithReference(eventHub)</strong>
    .WithEnvironment("DataStore", dataStore);</pre>
			<p>With the game APIs service, we replace<a id="_idIndexMarker1162"/> the referenced live service<a id="_idIndexMarker1163"/> with the event hub. The reference to live service is no <span class="No-Break">longer needed.</span></p>
			<p>With this, we can look at the game <span class="No-Break">APIs service.</span></p>
			<h2 id="_idParaDest-362"><a id="_idTextAnchor361"/>Using the .NET Aspire Event Hubs component to produce events</h2>
			<p>To use the .NET Aspire Event Hubs<a id="_idIndexMarker1164"/> component, we must<a id="_idIndexMarker1165"/> add the <strong class="source-inline">Aspire.Azure.Messaging.EventHub</strong> <span class="No-Break">NuGet package.</span></p>
			<p>Using this package, we can configure the <span class="No-Break">DI container:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/ApplicationServices.cs</p>
			<pre class="source-code">
<strong class="bold">  builder.AddAzureEventHubProducerClient(</strong>
<strong class="bold">    "codebreakerevents",settings =&gt;</strong>
<strong class="bold">    {</strong>
<strong class="bold">      </strong><strong class="bold">settings.EventHubName = "games";</strong>
<strong class="bold">    });</strong></pre>
			<p>From the game APIs service, to send<a id="_idIndexMarker1166"/> information about completed<a id="_idIndexMarker1167"/> games, in previous chapters, we created the <strong class="source-inline">LiveReportClient</strong> class to call a REST service and the <strong class="source-inline">GrpcLiveReportClient</strong> class to invoke a gRPC service. Now, we can implement the same interface we used earlier – <strong class="source-inline">IGameReport</strong> with the <span class="No-Break"><strong class="source-inline">EventHubReportProducer</strong></span><span class="No-Break"> class.</span></p>
			<p>Sending events can easily be done, as <span class="No-Break">shown here:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/EventHubReportProducer.cs</p>
			<pre class="source-code">
<strong class="bold">public class EventHubReportProducer(</strong>
<strong class="bold">  EventHubProducerClient producerClient,</strong>
<strong class="bold">  ILogger&lt;EventHubLiveReportClient&gt; logger) :</strong>
<strong class="bold">  IGameReport</strong>
<strong class="bold">{</strong>
<strong class="bold">  public async Task ReportGameEndedAsync(</strong>
<strong class="bold">    GameSummary game,</strong>
<strong class="bold">    CancellationToken cancellationToken = default)</strong>
<strong class="bold">  {</strong>
<strong class="bold">    var data = BinaryData.FromObjectAsJson(game);</strong>
<strong class="bold">    await producerClient.SendAsync(</strong>
<strong class="bold">      [ new EventData(data) ],</strong>
<strong class="bold">      cancellationToken);</strong>
<strong class="bold">    // code removed for brevity</strong>
<strong class="bold">  }</strong>
<strong class="bold">}</strong></pre>
			<p>The <strong class="source-inline">EventHubReportProducer</strong> class injects the <strong class="source-inline">EventHubProducerClient</strong> class to send events to the event hub. <strong class="source-inline">GameSummary</strong> is converted into <strong class="source-inline">BinaryData</strong> with <strong class="source-inline">BinaryData.FromObjectAsJson</strong>. The <strong class="source-inline">EventData </strong>class from the <strong class="source-inline">Azure.Messaging.EventHubs</strong> namespace allows us to pass a string, <strong class="source-inline">BinaryData</strong>, and <strong class="source-inline">ReadOnlyMemory&lt;byte&gt;</strong>. Then, the event<a id="_idIndexMarker1168"/> is published by invoking<a id="_idIndexMarker1169"/> the <span class="No-Break"><strong class="source-inline">SendAsync</strong></span><span class="No-Break"> method.</span></p>
			<p>Now that we’ve published some events, let’s subscribe <span class="No-Break">to them.</span></p>
			<h1 id="_idParaDest-363"><a id="_idTextAnchor362"/>Subscribing to Azure Event Hubs events</h1>
			<p>The <strong class="source-inline">Codebreaker.Live</strong> project previously<a id="_idIndexMarker1170"/> offered a gRPC service that was invoked by the game APIs service to publish completed games via SignalR. Instead of offering a gRPC service, we can subscribe <span class="No-Break">to events.</span></p>
			<p>Create a new <strong class="source-inline">Codebreaker.Ranking</strong> project so that you can offer minimal APIs. This project will receive the same events as <strong class="source-inline">Codebreaker.Live</strong> but write them to a database to offer ranks for games based on days, weeks, <span class="No-Break">and months.</span></p>
			<p>To create the <strong class="source-inline">Codebreaker.Ranking</strong> project, use the <span class="No-Break">following command:</span></p>
			<pre class="console">
dotnet new webapi -minimal -o Codebreaker.Ranking</pre>
			<p>Add the newly created project as a reference to <strong class="source-inline">Codebreaker.AppHost</strong>, and reference <strong class="source-inline">Codebreaker.ServiceDefaults</strong> to configure the service defaults. Now, we can update <span class="No-Break">app model.</span></p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor363"/>Defining app-model for Event Hubs subscribers</h2>
			<p>With the AppHost<a id="_idIndexMarker1171"/> project, the live and ranks<a id="_idIndexMarker1172"/> projects reference the event hub, similar to the events <span class="No-Break">publishing project:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
var storage = builder.AddAzureStorage("storage");
<strong class="bold">var blob = storage.AddBlobs("checkpoints");</strong>
var live =
  builder.AddProject&lt;Projects.Codebreaker_Live&gt;("live")
  .WithExternalHttpEndpoints()
  .WithReference(insights)
<strong class="bold">  .WithReference(eventHub)</strong>
  .WithReference(signalR);
builder.AddProject&lt;Projects.Codebreaker_Ranking&gt;("ranking")
  .WithExternalHttpEndpoints()
  .WithReference(cosmos)
  .WithReference(insights)
<strong class="bold">  .WithReference(eventHub)</strong>
<strong class="bold">  .WithReference(blob);</strong>
// code removed for brevity</pre>
			<p>Subscribing to events can be done<a id="_idIndexMarker1173"/> in two ways, either with the event<a id="_idIndexMarker1174"/> hub consumer client or the event processor client. The event hub consumer client is simpler to use and supports async streams. The event processor client is more powerful and supports receiving from multiple partitions in parallel. The second option needs to save checkpoints in an Azure blob storage account. We use the same account that we already use <span class="No-Break">for queues.</span></p>
			<p>We will implement both versions. The Codebreaker live service uses async streams, and the event hub consumer client with the class <strong class="source-inline">EventHubConsumerClient</strong> fits its need. The Codebreaker ranking<a id="_idIndexMarker1175"/> service makes use of the event<a id="_idIndexMarker1176"/> processor client, <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">EventProcessorClient</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-365"><a id="_idTextAnchor364"/>Using the Event Hubs component with async streaming</h2>
			<p>When using<a id="_idIndexMarker1177"/> the <strong class="source-inline">Codebreaker.Live</strong> project, references<a id="_idIndexMarker1178"/> to the <strong class="source-inline">Aspire.Azure.Messaging.EventHubs</strong> NuGet package <span class="No-Break">are required:</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">Codebreaker.Live</strong> project was created in <a href="B21217_13.xhtml#_idTextAnchor317"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>. Here, we’ll create a new SignalR hub to <span class="No-Break">offer streaming.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/ApplicationServices.cs</p>
			<pre class="source-code">
public static void AddApplicationServices(this IHostApplicationBuilder builder)
{
  builder.Services.AddSignalR()
    .AddMessagePackProtocol()
    .AddNamedAzureSignalR("signalr");
<strong class="bold">   builder.AddAzureEventHubConsumerClient("codebreakerevents",</strong>
<strong class="bold">  settings =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    </strong><strong class="bold">settings.EventHubName = "games";</strong>
<strong class="bold">  });</strong>
}</pre>
			<p>The <strong class="source-inline">AddAzureEventHubConsumerClient</strong> method configures the <strong class="source-inline">EventHubConsumerClient</strong> class as a singleton within the <span class="No-Break">DI container.</span></p>
			<p>Now, we must create a new SignalR hub to <span class="No-Break">inject </span><span class="No-Break"><strong class="source-inline">EventHubConsumerClient</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Endpoints/StreamingLiveHub.cs</p>
			<pre class="source-code">
public class StreamingLiveHub(
<strong class="bold">  EventHubConsumerClient consumerClient,</strong>
  ILogger&lt;StreamingLiveHub&gt; logger) : Hub
{
  // code removed for brevity</pre>
			<p>By using the primary <a id="_idIndexMarker1179"/>constructor, <strong class="source-inline">EventHubConsumerClient</strong> is injected<a id="_idIndexMarker1180"/> to retrieve <span class="No-Break">the events.</span></p>
			<p>Now, create the <span class="No-Break"><strong class="source-inline">SubscribeToGameCompletions</strong></span><span class="No-Break"> method:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Endpoints/StreamingLiveHub.cs</p>
			<pre class="source-code">
<strong class="bold">public async IAsyncEnumerable&lt;GameSummary&gt;</strong>
<strong class="bold">  SubscribeToGameCompletions(</strong>
<strong class="bold">    string gameType,</strong>
<strong class="bold">    [EnumeratorCancellation] CancellationToken</strong>
<strong class="bold">      cancellationToken)</strong>
{
<strong class="bold">  await foreach (PartitionEvent ev in</strong>
<strong class="bold">    consumerClient.ReadEventsAsync(cancellationToken))</strong>
  {
    GameSummary gameSummary;
    try
    {
<strong class="bold">      logger.ProcessingGameCompletionEvent();</strong>
<strong class="bold">      gameSummary = ev.Data.EventBody</strong>
<strong class="bold">        .ToObjectFromJson&lt;GameSummary&gt;();</strong>
    }
    catch (Exception ex)
    {
      logger.ErrorProcessingGameCompletionEvent(
        ex, ex.Message);
      continue;
    }
      if (gameSummary.GameType == gameType)
      {
<strong class="bold">        yield return gameSummary;</strong>
      }
      else
      {
<strong class="bold">        continue;</strong>
      }
    }
  }</pre>
			<p>SignalR supports async streaming<a id="_idIndexMarker1181"/> with methods<a id="_idIndexMarker1182"/> returning <strong class="source-inline">IAsyncEnumerable</strong>. The <strong class="source-inline">SubscribeToGameCompletions</strong> method receives a game type parameter that only returns game completions of this game type. <strong class="source-inline">EventHubConsumerClient</strong> supports async streaming by invoking the <strong class="source-inline">ReadEventsAsync</strong> method. If the received game summary is of the requested game type, it’s returned to the client via the <span class="No-Break">async stream.</span></p>
			<p>At this point, the middleware needs to be configured so that it references the <span class="No-Break">new hub:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/ApplicationServices.cs</p>
			<pre class="source-code">
app.MapHub&lt;LiveHub&gt;("/livesubscribe");
<strong class="bold">app.MapHub&lt;StreamingLiveHub&gt;("/streaminglivesubscribe");</strong></pre>
			<p>We also need to update<a id="_idIndexMarker1183"/> the client by using async streaming<a id="_idIndexMarker1184"/> and the <span class="No-Break">new link:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">LiveTestClient/StreamingLiveClient.cs</p>
			<pre class="source-code">
public async Task SubscribeToGame(string gameType, CancellationToken cancellationToken = default)
{
  if (_hubConnection is null) throw new InvalidOperationException("Start a connection first!");
  try
  {
<strong class="bold">    await foreach (GameSummary summary in</strong>
<strong class="bold">      _hubConnection.StreamAsync&lt;GameSummary&gt;(</strong>
<strong class="bold">        "SubscribeToGameCompletions",</strong>
<strong class="bold">        gameType,</strong>
<strong class="bold">        cancellationToken))</strong>
    {
      string status = summary.IsVictory ? "won" : "lost";
      Console.WriteLine($"Game {summary.Id} {status} " +
        $"by {summary.PlayerName} after " +
        $"{summary.Duration:g} with " +
        $"{summary.NumberMoves} moves");
    }
  }
  catch (HubException ex)
  {
    logger.LogError(ex, ex.Message);
    throw;
  }
  catch (OperationCanceledException ex)
  {
    logger.LogWarning(ex.Message);
  }
}</pre>
			<p>With the same SignalR initialization configuration we created in <a href="B21217_13.xhtml#_idTextAnchor317"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, the client now uses the <strong class="source-inline">StreamAsync</strong> method from the SignalR <strong class="source-inline">HubConnection</strong> class to async stream the results that are returned from <span class="No-Break">the service.</span></p>
			<p>With these changes, you can already<a id="_idIndexMarker1185"/> test and run the solution, starting<a id="_idIndexMarker1186"/> from the message queue up to the SignalR streaming client, to receive completed games. However, let’s add another Event Hubs client to process messages, this time with the Event <span class="No-Break">Hubs processor.</span></p>
			<h2 id="_idParaDest-366"><a id="_idTextAnchor365"/>Using the .NET Aspire Event Hubs component to process messages</h2>
			<p>The <strong class="source-inline">Codebreaker.Ranking</strong> project receives<a id="_idIndexMarker1187"/> events, writes those events<a id="_idIndexMarker1188"/> to an Azure Cosmos database, and offers minimal APIs to get ranking<a id="_idIndexMarker1189"/> information from the players. This project references<a id="_idIndexMarker1190"/> the .NET Aspire <strong class="source-inline">Aspire.Azure.Messaging.EventHubs</strong> and <span class="No-Break"><strong class="source-inline">Aspire.Azure.Storage.Blobs</strong></span><span class="No-Break"> components:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Ranking/ApplicationServices.cs</p>
			<pre class="source-code">
public static void AddApplicationServices(this IHostApplicationBuilder builder)
{
  // code removed for brevity
<strong class="bold">  builder.AddKeyedAzureBlobClient("checkpoints");</strong>
  <strong class="bold">builder.AddAzureEventProcessorClient("codebreakerevents",</strong>
<strong class="bold">    settings =&gt;</strong>
<strong class="bold">    {</strong>
<strong class="bold">      settings.EventHubName = "games";</strong>
<strong class="bold">      settings.BlobClientServiceKey = "checkpoints";</strong>
<strong class="bold">    });</strong>
  <strong class="bold">builder.Services.AddDbContextFactory&lt;RankingsContext&gt;(</strong>
<strong class="bold">    options =&gt;</strong>
    {
      string connectionString =
        builder.Configuration.GetConnectionString(
          "codebreakercosmos") ??
          throw new InvalidOperationException(
            "Could not read the Cosmos connection-string");
      options.UseCosmos(connectionString, "codebreaker");
    });
  builder.EnrichCosmosDbContext&lt;RankingsContext&gt;();
  <strong class="bold">builder.Services</strong>
<strong class="bold">    .AddSingleton&lt;IGameSummaryEventProcessor,</strong>
<strong class="bold">      GameSummaryEventProcessor&gt;();</strong>}</pre>
			<p><strong class="source-inline">AddAzureEventProcessorClient</strong> registers a singleton instance of the <strong class="source-inline">EventProcessorClient</strong> class. We connect to the same namespace and event hub, so this configuration is the same. What’s different is that <strong class="source-inline">AddKeyedAzureBlobClient</strong> is a method from the .NET Aspire Blob Storage component. This method registers a singleton instance with the DI container to read and write blobs. The storage is connected to the event hub by setting <strong class="source-inline">BlobClientServiceKey</strong> to <span class="No-Break">write checkpoints.</span></p>
			<p>You can also simplify the configuration by not registering a keyed configuration. The one default storage component that’s registered is automatically used from the event <span class="No-Break">hub component.</span></p>
			<p>Other than the event hub<a id="_idIndexMarker1191"/> configuration, an EF Core <a id="_idIndexMarker1192"/>context must be configured to write the received game summary information to an Azure Cosmos DB database. Check out <a href="B21217_03.xhtml#_idTextAnchor063"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> for more details. Contrary to <a href="B21217_03.xhtml#_idTextAnchor063"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, we register an EF Core context factory with the DI container, which allows us to inject this into a singleton object and create the context objects with a <span class="No-Break">shorter lifetime.</span></p>
			<p>The registered <strong class="source-inline">GameSummaryEventProcessor</strong> is our implementation for dealing <span class="No-Break">with events:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Ranking/Services/GameSummaryEventProcessor.cs</p>
			<pre class="source-code">
public class GameSummaryEventProcessor(
<strong class="bold">  EventProcessorClient client,</strong>
  IDbContextFactory&lt;RankingsContext&gt; factory,
  ILogger&lt;GameSummaryEventProcessor&gt; logger)
{
  public async Task <strong class="bold">StartProcessingAsync</strong>(
    CancellationToken = default)
  {
    // code removed for brevity
  }
  public Task <strong class="bold">StopProcessingAsync</strong>(
    CancellationToken cancellationToken = default)
  {
  }
}</pre>
			<p>The class injects <strong class="source-inline">EventProcessorClient</strong> and the EF Core context factory. This class implements <a id="_idIndexMarker1193"/>methods to start<a id="_idIndexMarker1194"/> and stop the processing <span class="No-Break">of events.</span></p>
			<p>The <strong class="source-inline">StartProcessingAsync</strong> method is shown in the following <span class="No-Break">code snippet:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Ranking/Services/GameSummaryEventProcessor.cs</p>
			<pre class="source-code">
public async Task StartProcessingAsync(CancellationToken cancellationToken = default)
{
  // code removed for brevity
  <strong class="bold">client.ProcessEventAsync += async (args) =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    GameSummary summary = args.Data.EventBody</strong>
<strong class="bold">      .ToObjectFromJson&lt;GameSummary1&gt;();</strong>
    using var context = await factory.CreateDbContextAsync(
      cancellationToken);
<strong class="bold">    await context.AddGameSummaryAsync(summary,</strong>
<strong class="bold">      cancellationToken);</strong>
<strong class="bold">    await args.UpdateCheckpointAsync(cancellationToken);</strong>
  };
  client.ProcessErrorAsync += (args) =&gt;
  {
    logger.LogError(args.Exception,
      "Error processing event, {error}",
      args.Exception.Message);
    return Task.CompletedTask;
  };
<strong class="bold">  await client.StartProcessingAsync(cancellationToken);</strong>
}</pre>
			<p>Once you start processing events by invoking the <strong class="source-inline">StartProcessingAsync</strong> method, the <strong class="source-inline">EventProcessorClient</strong> class fires .NET events that are invoked when messages are received, and on errors: <strong class="source-inline">ProcessEventAsync</strong> and <strong class="source-inline">ProcessErrorAsync</strong>. A received message is converted from binary into a <strong class="source-inline">GameSummary</strong> object and written<a id="_idIndexMarker1195"/> to the database. In addition to that, the checkpoint in the storage account is written<a id="_idIndexMarker1196"/> so that we know which event message was <span class="No-Break">processed last.</span></p>
			<p>When this is in place, start the application, open the Azure portal to send messages to the bot queue to let the bot play some games, and monitor how events are sent. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.8</em> shows the Azure portal showing Event <span class="No-Break">Hub metrics:</span></p>
			<div>
				<div id="_idContainer205" class="IMG---Figure">
					<img src="image/B21217_15_08.jpg" alt="Figure 15.8 – Event Hub metrics"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.8 – Event Hub metrics</p>
			<p>Apart from checking the Event Hub metrics, verify the data that’s been written to the rankings database. Also, start the SignalR<a id="_idIndexMarker1197"/> client application<a id="_idIndexMarker1198"/> so that you can monitor event data with <span class="No-Break">async streaming.</span></p>
			<p>Open the Event Hub instance in the Azure portal and select <strong class="bold">Configuration</strong> within the <strong class="bold">Settings</strong> category (see <span class="No-Break"><em class="italic">Figure 15</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer206" class="IMG---Figure">
					<img src="image/B21217_15_09.jpg" alt="Figure 15.9 – Event Hub configuration"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.9 – Event Hub configuration</p>
			<p>Here, you can see the configured partition count and can disable the hub. Regarding <strong class="bold">Retention time (hrs)</strong>, you can configure how long the messages should be kept for. The maximum time depends on the configured SKU of the Event Hub namespace. With the standard SKU, the maximum retention is 7 days. If <strong class="source-inline">ranking-service</strong> is not running on one day, there’s still enough time to process the <span class="No-Break">games afterward.</span></p>
			<p>You can also configure how<a id="_idIndexMarker1199"/> data is captured (<strong class="bold">Features</strong> | <strong class="bold">Capture</strong>) with an Azure Storage Account (<strong class="bold">Avro</strong> serialization format) or Azure<a id="_idIndexMarker1200"/> Data Lake (<strong class="bold">Parquet</strong> or <strong class="bold">Delta Lake</strong> serialization format). Make<a id="_idIndexMarker1201"/> sure you check<a id="_idIndexMarker1202"/> out the pricing options before configuring capturing<a id="_idIndexMarker1203"/> or <span class="No-Break">other SKUs.</span></p>
			<p>Mentioning prices, what do you need to be aware of when you’re deploying the solution to <span class="No-Break">Microsoft Azure?</span></p>
			<h1 id="_idParaDest-367"><a id="_idTextAnchor366"/>Deploying the solution to Microsoft Azure</h1>
			<p>When using a low load, the complete<a id="_idIndexMarker1204"/> solution is not expensive<a id="_idIndexMarker1205"/> when it’s running on Microsoft Azure. CPU power typically results in higher cost. How many containers are running with Azure Container Apps? <strong class="source-inline">bot-service</strong>, the <strong class="source-inline">game-apis</strong> service, <strong class="source-inline">live-service</strong>, <strong class="source-inline">ranking-service</strong>, and the Redis container. The <strong class="source-inline">game-apis</strong> service should scale with the minimum value set to 1, which provides a fast response for the first user so that they get a fast first answer. If you scale to 1 when the service is idle, there’s an idle price that reduces the cost of the CPU considerably. <strong class="source-inline">bot-service</strong>, <strong class="source-inline">live-service</strong>, and <strong class="source-inline">ranking-service</strong> can scale down to 0, which means there’s no cost in terms of CPU and memory. However, be aware of custom health checks (covered in <a href="B21217_12.xhtml#_idTextAnchor294"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>), which can play against scaling to 0. With <strong class="source-inline">live-service</strong>, if there’s no listener to query for running games, you can’t subscribe to events. Thus, cost only applies if clients <span class="No-Break">are connected.</span></p>
			<p>The bot contains a loop that keeps running and checks the queue repeatedly. This is not necessary with the Azure Container Apps environment. Here, we can create an <strong class="bold">Azure Container Apps job</strong> resource. This resource<a id="_idIndexMarker1206"/> is only started based on a trigger – for example, a cron time or an event such as a message available in a <span class="No-Break">storage queue.</span></p>
			<p>Creating Azure Container Apps jobs is not yet supported with .NET Aspire out of the box. However, this is possible with some customization. Here’s what you need <span class="No-Break">to do:</span></p>
			<ol>
				<li>Initialize the project with <span class="No-Break"><strong class="source-inline">azd init</strong></span><span class="No-Break">.</span></li>
				<li>Use <strong class="source-inline">azd infra synth</strong> to create Bicep files and <span class="No-Break">manifest files.</span></li>
				<li>Create Azure resources using <span class="No-Break"><strong class="source-inline">azd provision</strong></span><span class="No-Break">.</span></li>
				<li>Change the manifest file of the project that should be deployed as a Container App Job instead of a <span class="No-Break">Container App.</span></li>
				<li>Deploy the projects using <strong class="source-inline">azd deploy</strong> (you can deploy project by project using <strong class="source-inline">azd deploy &lt;service&gt;</strong> or <span class="No-Break">deploy all).</span></li>
			</ol>
			<p>Because of the quick updates<a id="_idIndexMarker1207"/> that are made to .NET Aspire, check out<a id="_idIndexMarker1208"/> the README file in this chapter’s GitHub repository for the <span class="No-Break">latest updates.</span></p>
			<p>Next, let’s look at an alternative option to using <span class="No-Break">Azure services.</span></p>
			<h1 id="_idParaDest-368"><a id="_idTextAnchor367"/>Using Apache Kafka for event processing</h1>
			<p>Apache Kafka can be an alternative<a id="_idIndexMarker1209"/> to using Azure Queue Storage<a id="_idIndexMarker1210"/> and Azure Event Hubs – especially when it comes to on-premises solutions. This technology is used by many companies in their on-premises environments for high performance application-to-application messaging, supports a scalable multiple producers and consumers environment (like Event Hub), and supports a read-only-once scenario like <span class="No-Break">message queues.</span></p>
			<p>Starting the AppHost with the <strong class="source-inline">OnPremises</strong> launch profile will now use the previously created <strong class="source-inline">Codebreaker.Bot</strong>. This uses a REST API instead of message queues, replaces the event publishing mechanism of the <strong class="source-inline">game-apis</strong> service, and makes the event subscription from <strong class="source-inline">ranking-service</strong> use <span class="No-Break">Apache Kafka.</span></p>
			<p>First, we’ll <span class="No-Break">change </span><span class="No-Break"><strong class="source-inline">app-model</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-369"><a id="_idTextAnchor368"/>Configuring Apache Kafka with app-model</h2>
			<p>To use the Apache Kafka<a id="_idIndexMarker1211"/> resource with <strong class="source-inline">app-model</strong>, we must<a id="_idIndexMarker1212"/> add the <strong class="source-inline">Aspire.Hosting.Kafka</strong> <span class="No-Break">NuGet package:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
<strong class="bold">var kafka = builder.AddKafka("kafkamessaging");</strong>
// code removed for brevity
var gameAPIs = builder.AddProject&lt;Projects.Codebreaker_GameAPIs&gt;("gameapis")
  .WithExternalHttpEndpoints()
  .WithReference(sqlServer)
  .WithReference(redis)
<strong class="bold">  .WithReference(kafka)</strong>
  .WithEnvironment("DataStore", dataStore)
<strong class="bold">  .WithEnvironment("StartupMode", startupMode);</strong>
  builder.AddProject&lt;Projects.Codebreaker_Ranking&gt;("ranking")
  .WithExternalHttpEndpoints()
  .WithReference(cosmos)
<strong class="bold">  .WithReference(kafka)</strong>
<strong class="bold">  .WithEnvironment("StartupMode", startupMode);</strong></pre>
			<p>The <strong class="source-inline">AddKafka</strong> method adds a Docker container for local development. This resource is referenced from the <strong class="source-inline">game-apis</strong> service and <strong class="source-inline">ranking-service</strong> to forward the connection. <strong class="source-inline">StartupMode</strong> is configured with the launch profile and forwarded as an environment variable to both of these projects so that they can choose between Azure Event Hubs and <span class="No-Break">Apache Kafka.</span></p>
			<p>Next, we’ll use an Aspire component to <span class="No-Break">publish events.</span></p>
			<h2 id="_idParaDest-370"><a id="_idTextAnchor369"/>Publishing Apache Kafka events</h2>
			<p>When it comes to publishers<a id="_idIndexMarker1213"/> and subscribers, the <strong class="source-inline">Aspire.Confluent.Kafka</strong> NuGet package is used. Within this package, in the <strong class="source-inline">Confluent.Kafka</strong> namespace, the <strong class="source-inline">IProducer</strong> interface is defined. An object of this type is injected with the <strong class="source-inline">KafkaGameReportProducer</strong> class to publish <span class="No-Break">completed games:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/KafkaGameReportProducer.cs</p>
			<pre class="source-code">
public class KafkaGameReportProducer(
<strong class="bold">  IProducer&lt;string, string&gt; producerClient</strong>,
  ILogger&lt;KafkaLiveReportProducer&gt; logger)
<strong class="bold">  : IGameReport</strong>
{
  public async Task ReportGameEndedAsync(
    GameSummary game,
    CancellationToken cancellationToken = default)
  {
<strong class="bold">    Message&lt;string, string&gt; message = new()</strong>
<strong class="bold">    {</strong>
<strong class="bold">      Key = game.Id.ToString(),</strong>
<strong class="bold">      Value = JsonSerializer.Serialize(game)</strong>
<strong class="bold">    </strong><strong class="bold">};</strong>
    string[] topics = ["ranking", "live"];
    foreach (var topic in topics)
    {
<strong class="bold">      _ = producerClient.ProduceAsync(topic, message,</strong>
<strong class="bold">        cancellationToken);</strong>
    }
<strong class="bold">    producerClient.Flush(TimeSpan.FromSeconds(5));</strong>
    logger.GameCompletionSent(game.Id, "Kafka");
    return Task.CompletedTask;
  }
}</pre>
			<p><strong class="source-inline">KafkaGameReportProducer</strong> implements the same interface that was used before – that is, <strong class="source-inline">IGameReport</strong>. The generic parameters of the <strong class="source-inline">IProducer</strong> interface define types for the key and the value. With Kafka, serializers can be specified, which allows for custom serialization. We can use simple strings that easily work across different platforms. With .NET, we can use the <strong class="source-inline">System.Text.Json</strong> serializer to serialize <strong class="source-inline">GameSummary</strong> objects <span class="No-Break">to strings.</span></p>
			<p>The <strong class="source-inline">IProducer</strong> interface defines the <strong class="source-inline">ProduceAsync</strong> method to publish messages. The first parameter names a topic. Upon invoking the <strong class="source-inline">ProduceAsync</strong> method, the message is sent to a Kafka broker service. The message is kept there until it is read by a subscriber for the topic – up to a retention period. The default retention period is 1 week. To send messages to multiple subscribers (<strong class="source-inline">live-service</strong> and <strong class="source-inline">ranking-service</strong>), a list of topics <span class="No-Break">is used.</span></p>
			<p>The <strong class="source-inline">ProduceAsync</strong> method returns <strong class="source-inline">DeliveryResult</strong> when the message is delivered to the broker. We don’t wait for the message to be delivered; instead, we use a loop to send the same message with multiple topics. <strong class="source-inline">Task.WhenAll</strong> could be used to wait for all deliveries or the <strong class="source-inline">Flush</strong> method to wait until a timeout is reached. The <strong class="source-inline">Flush</strong> method returns the number of items in the queue. Before the producer gets disposed of, you need to make sure that all messages are delivered to the broker. Because the producer is configured<a id="_idIndexMarker1214"/> as a singleton with the DI container, we can keep the flush <span class="No-Break">for later.</span></p>
			<p>Now, we must configure the <span class="No-Break">DI container:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/ApplicationServices.cs</p>
			<pre class="source-code">
// code removed for brevity
string? mode = builder.Configuration["StartupMode"];
if (mode == "OnPremises")
{
<strong class="bold">  builder.AddKafkaProducer&lt;string, string&gt;(</strong>
<strong class="bold">    "kafkamessaging", settings =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    settings.Config.AllowAutoCreateTopics = true;</strong>
<strong class="bold">  });</strong>
<strong class="bold">  builder.Services.AddSingleton&lt;IGameReport,</strong>
<strong class="bold">    KafkaGameReportProducer&gt;();</strong>
}</pre>
			<p>The <strong class="source-inline">AddKafkaProducer</strong> method registers the <strong class="source-inline">IProducer</strong> interface as a singleton. <strong class="source-inline">kafkamessaging</strong> is the string that’s used with <strong class="source-inline">app-model</strong> to get the connection string to the Kafka server. With the <strong class="source-inline">KafkaProducerSettings</strong> parameter, telemetry configuration and producer settings can be configured. Here, the <strong class="source-inline">AllowAutoCreateTopics</strong> setting is set to <strong class="source-inline">true</strong> – which is the default with producers. With consumers, this value is <strong class="source-inline">false</strong> by default. The previously created <strong class="source-inline">KafkaGameReportProducer</strong> class is registered as a singleton as well. The <strong class="source-inline">IGameReport</strong> interface is already used by the <strong class="source-inline">GameService</strong> class to report completed games, regardless<a id="_idIndexMarker1215"/> of how this reporting <span class="No-Break">is implemented.</span></p>
			<p>Now, let’s subscribe to these events with the <span class="No-Break">ranking service.</span></p>
			<h2 id="_idParaDest-371"><a id="_idTextAnchor370"/>Subscribing to Apache Kafka events</h2>
			<p>Subscriber applications such<a id="_idIndexMarker1216"/> as <strong class="source-inline">Codebreaker.Ranking</strong> need the same .NET Aspire component package to be referenced. When it comes<a id="_idIndexMarker1217"/> to consumer classes, the <strong class="source-inline">IConsumer</strong> interface must <span class="No-Break">be injected:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Ranking/GameSummaryKafkaConsumer.cs</p>
			<pre class="source-code">
public class GameSummaryKafkaConsumer(
<strong class="bold">  IConsumer&lt;string, string&gt; kafkaClient,</strong>
  IDbContextFactory&lt;RankingsContext&gt; factory,
  ILogger&lt;GameSummaryEventProcessor&gt; logger)
  : IGameSummaryProcessor
{
  public async Task StartProcessingAsync(
    CancellationToken cancellationToken = default)
  {
<strong class="bold">    kafkaClient.Subscribe("ranking");</strong>
    try
    {
      while (!cancellationToken.IsCancellationRequested)
      {
        try
        {
<strong class="bold">          var result = kafkaClient.Consume(</strong>
<strong class="bold">            cancellationToken);</strong>
<strong class="bold">          var value = result.Message.Value;</strong>
<strong class="bold">          var summary =</strong>
<strong class="bold">            JsonSerializer.Deserialize&lt;GameSummary&gt;(value);</strong>
          // code removed for brevity
          using var context = await
            factory.CreateDbContextAsync(
              cancellationToken);
          await context.AddGameSummaryAsync(
            summary, cancellationToken);
        }
<strong class="bold">        catch (ConsumeException ex) when</strong>
<strong class="bold">          (ex.HResult == -2146233088)</strong>
<strong class="bold">        {</strong>
<strong class="bold">          logger.LogWarning("Consume exception {Message}",</strong>
<strong class="bold">            ex.Message);</strong>
<strong class="bold">          await Task.Delay(TimeSpan.FromSeconds(10));</strong>
<strong class="bold">        }</strong>
      }
    }
  }
}</pre>
			<p>The ranking service subscribes to messages with the <strong class="source-inline">ranking</strong> topic using the <strong class="source-inline">Subscribe</strong> method. The topic was used when publishing messages. If the topic doesn’t exist because a message hasn’t been written yet, the <strong class="source-inline">Consume</strong> method throws a <strong class="source-inline">ConsumeException</strong> error. This exception is caught, and the <strong class="source-inline">Consume</strong> method is repeated after a delay. A game might not be completed when the ranking service starts up and the Docker container of the Kafka service hasn’t been configured to <span class="No-Break">keep state.</span></p>
			<p>When a message is received, it is written<a id="_idIndexMarker1218"/> to the database, as we saw earlier with Azure <span class="No-Break">Event Hubs.</span></p>
			<p>Now, we just need to configure the <span class="No-Break">DI container:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Ranking/ApplicationServices.cs</p>
			<pre class="source-code">
string? mode = builder.Configuration["StartupMode"];
if (mode == "OnPremises")
{
<strong class="bold">  builder.AddKafkaConsumer&lt;string, string&gt;(</strong>
<strong class="bold">    "kafkamessaging", settings =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    settings.Config.GroupId = "Ranking";</strong>
<strong class="bold">  };</strong>
<strong class="bold">  builder.Services.AddSingleton&lt;IGameSummaryProcessor,</strong>
<strong class="bold">    GameSummaryKafkaConsumer&gt;();</strong>
}</pre>
			<p>To register the <strong class="source-inline">IConsumer</strong> interface, we use the <strong class="source-inline">AddKafkaConsumer</strong> method. <strong class="source-inline">GroupId</strong> needs to be configured with a Kafka consumer client. Groups are used for scalability. Similar to Azure Event Hubs, Kafka makes use of partitions. Multiple subscribers using the same group ID receive messages from different partitions. This allows for <span class="No-Break">high scalability.</span></p>
			<p>Now, start the solution<a id="_idIndexMarker1219"/> with the <strong class="source-inline">OnPremises</strong> launch profile. Start the Open API page of the bot to let it play some games and debug and monitor the services. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.10</em> shows metrics counts for the <strong class="source-inline">game-apis</strong> service with the <span class="No-Break">bytes transmitted:</span></p>
			<div>
				<div id="_idContainer207" class="IMG---Figure">
					<img src="image/B21217_15_10.jpg" alt="Figure 15.10 – Kafka metrics"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.10 – Kafka metrics</p>
			<p>Check the bytes, the messages<a id="_idIndexMarker1220"/> that have been published and subscribed to, and the queue sizes for the publisher and the subscriber. Now is also a good time to take a break and play a few rounds <span class="No-Break">of Codebreaker.</span></p>
			<h1 id="_idParaDest-372"><a id="_idTextAnchor371"/>Summary</h1>
			<p>In this chapter, you learned how to decouple services by using asynchronous communication technologies, messages, and events. With Microsoft Azure, we used queues from an Azure Storage Account and events from Azure Event Hubs. Instead of using these PaaS services, you can also run Kafka within a Docker container in an Azure Container Apps environment, but you need to configure this with the <span class="No-Break">app model.</span></p>
			<p>You also learned the differences between using message queues and a publish/subscribe event model with <span class="No-Break">multiple subscribers.</span></p>
			<p>Be sure to check out the .NET Aspire component for Azure Service Bus in the <em class="italic">Further reading</em> section. This service offers more features with message queues, and you’ll learn about some concepts you already know about from <span class="No-Break">Apache Kafka.</span></p>
			<p>After all the different services, in the next chapter we’ll look into what more we should think about when deploying the application to the production environment, and we’ll deploy the solution to a <span class="No-Break">Kubernetes cluster.</span></p>
			<h1 id="_idParaDest-373"><a id="_idTextAnchor372"/>Further reading</h1>
			<p>To learn more about the topics that were discussed in this chapter, please refer to the <span class="No-Break">following links:</span></p>
			<ul>
				<li><em class="italic">.NET Aspire Azure Blob Storage </em><span class="No-Break"><em class="italic">component</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-blobs-component"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-blobs-component</span></a></li>
				<li><em class="italic">.NET Aspire Azure Queue Storage </em><span class="No-Break"><em class="italic">component</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-queues-component"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/aspire/storage/azure-storage-queues-component</span></a></li>
				<li><em class="italic">Azure Event Hubs </em><span class="No-Break"><em class="italic">documentation</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/azure/event-hubs/"><span class="No-Break">https://learn.microsoft.com/en-us/azure/event-hubs/</span></a></li>
				<li><span class="hidden">.</span><em class="italic">NET Aspire Azure Event Hubs </em><span class="No-Break"><em class="italic">component</em></span><span class="No-Break">: </span><a href="https://github.com/dotnet/aspire/tree/main/src/Aspire.Hosting.Azure.EventHubs"><span class="No-Break">https://github.com/dotnet/aspire/tree/main/src/Aspire.Hosting.Azure.EventHubs</span></a></li>
				<li><em class="italic">.NET Aspire Azure Service Bus </em><span class="No-Break"><em class="italic">component</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/dotnet/aspire/messaging/azure-service-bus-component"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/aspire/messaging/azure-service-bus-component</span></a></li>
				<li><em class="italic">.NET Aspire RabbitMQ </em><span class="No-Break"><em class="italic">component</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/dotnet/aspire/messaging/rabbitmq-client-component"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/aspire/messaging/rabbitmq-client-component</span></a></li>
				<li><em class="italic">.NET Aspire Apache Kafka </em><span class="No-Break"><em class="italic">component</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/dotnet/aspire/messaging/kafka-component"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/aspire/messaging/kafka-component</span></a></li>
				<li><em class="italic">Apache Kafka .NET </em><span class="No-Break"><em class="italic">Client</em></span><span class="No-Break">: </span><a href="https://docs.confluent.io/kafka-clients/dotnet/current/overview.html"><span class="No-Break">https://docs.confluent.io/kafka-clients/dotnet/current/overview.html</span></a></li>
			</ul>
		</div>
	</body></html>