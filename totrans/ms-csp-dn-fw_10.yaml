- en: Chapter 10. Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。设计模式
- en: In this chapter, we're not focusing on the architecture and tools required to
    manage a solution's life cycle (sometimes called the development ecosystem) but
    on the quality of the code and its structures in terms of efficacy, precision,
    and maintainability.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不是关注管理解决方案生命周期（有时称为开发生态系统）所需的架构和工具，而是关注代码及其结构在效率、精确性和可维护性方面的质量。
- en: We'll start with the SOLID principles, proposed by Robert Martin, which are
    gaining more and more recognition and that we can see implemented in different
    frameworks and technologies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Robert Martin提出的SOLID原则开始，这些原则越来越受到认可，并且我们可以看到它们在不同的框架和技术中得到实施。
- en: A basic application will be used to illustrate the distinct principles, and
    as the requirements evolve, we'll apply different principles and patterns to solve
    the problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用一个基本应用程序来展示不同的原则，随着需求的演变，我们将应用不同的原则和模式来解决问题。
- en: Finally, we'll go through the eight most used patterns of the Gang of Four (according
    to statistics), revising its definitions and purpose to finish with the current
    list of available patterns created and published after the GoF group published
    their book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将根据统计数据回顾Gang of Four（四人帮）最常用的八种模式，修订其定义和目的，以完成GoF小组发布书籍后创建和发布的当前可用模式列表。
- en: 'Therefore, the topics covered in this chapter are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章涵盖的主题如下：
- en: SOLID principles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID原则
- en: Open/Closed principle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放/封闭原则
- en: Liskov Substitution principle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Liskov替换原则
- en: Interface Segregation principle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: Dependency Inversion principle
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: Design patterns
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式
- en: Other software patterns
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他软件模式
- en: Other patterns
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他模式
- en: The origins
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 起源
- en: With time, programming techniques have evolved, at the same pace as languages
    and hardware; so, from the initial confusion in the early 60s, when no foundations
    were established and few models were considered, the 70s marked the start of the
    adoption of other paradigms, such as procedural programming, and later on, **object
    oriented programming** (**OOP**).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，编程技术随着语言和硬件的发展而发展；因此，从20世纪60年代初的初始混乱，当时没有建立基础，考虑的模型很少，70年代标志着其他范式的采用开始，如过程式编程，后来又出现了**面向对象编程**（**OOP**）。
- en: Ole-Johan Dahl and Kristen Nygaard originally proposed OOP with the Simula language,
    when they both worked at the Norwegian Computing Center. They were given the Turing
    Award for these achievements, among other recognitions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Ole-Johan Dahl和Kristen Nygaard最初在挪威计算中心工作时，提出了使用Simula语言的面向对象编程（OOP）。他们因这些成就获得了图灵奖以及其他认可。
- en: A few years later (around 1979), Bjarne Stroustrup created C with Classes, the
    prototype of what C++ today is because he found valuable aspects in Simula, but
    he thought that it was too slow for practical purposes. C++ originally had imperative
    features and object-oriented and generic ones, while also providing the ability
    to program for low-level memory manipulation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 几年后（大约1979年），Bjarne Stroustrup创建了带有类的C语言，这是今天C++的原型，因为他认为Simula中有价值的一面，但他认为它对于实际应用来说太慢了。C++最初具有命令式特征、面向对象和泛型特征，同时提供用于低级内存操作编程的能力。
- en: It was the first OOP language that became universal in adoption (though limited
    in number), due to its many virtues, but for many people, it was not adequate
    for business applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它是第一个被普遍采用（尽管数量有限）的面向对象编程语言，由于其许多优点，但许多人认为它不足以用于商业应用。
- en: Later on, the appearance of Java and the .NET platforms proposed a much easier
    and affordable solution for many programmers while still moving within the ordered
    space that object oriented programming languages promote.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，Java和.NET平台的出现为许多程序员提供了一个更容易、更经济的解决方案，同时仍然在面向对象编程语言所倡导的有序空间内发展。
- en: So, OOP was adopted, and up until this date, no other important programming
    paradigm has substituted these ideas. Surely, there are other approaches, such
    as functional programming, but even the most significant representative of this
    tendency, JavaScript, is becoming more object-oriented in the latest versions
    (ECMAScript 2015).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，面向对象编程（OOP）被采纳，并且直到今天，没有其他重要的编程范式能够替代这些思想。当然，还有其他方法，比如函数式编程，但即使是这一趋势的最显著代表JavaScript，在最新版本（ECMAScript
    2015）中也变得更加面向对象。
- en: With the accelerated expansion of software solutions, many lessons were learned
    about how to correctly afford common software problems, and that will be our starting
    point.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件解决方案的加速扩展，我们学到了许多关于如何正确处理常见软件问题的经验教训，这将是我们的起点。
- en: The SOLID principles
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID原则
- en: Some programming guidelines have a wide, general-purpose intention, while some
    are designed to fix certain specific problems. Thus, before talking about the
    specific problems, we should review those features that can be applied in many
    different scenarios and solutions. I mean those principles that should be taken
    into consideration beyond the type of solution or specific platform to program
    for.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程指南具有广泛、通用的目的，而另一些则是为了解决某些特定问题而设计的。因此，在讨论具体问题之前，我们应该回顾那些可以在许多不同场景和解决方案中应用的特征。我的意思是那些应该超越解决方案类型或特定平台编程的考虑原则。
- en: Moreover, this is where the SOLID principles (and other related problems) come
    into play. In 2001, Robert Martin published a foundational article on the subject
    ([http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod)),
    in which he picked up a set of principles and guidelines that, in his own words,
    *focus very tightly on dependency management*, its inconveniences, and how to
    solve them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这就是SOLID原则（以及其他相关问题）发挥作用的地方。在2001年，罗伯特·马丁（Robert Martin）发表了一篇关于该主题的基础性文章([http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod))，在其中他挑选了一套原则和指南，用他自己的话说，*非常紧密地关注依赖管理*，其不便之处以及如何解决这些问题。
- en: 'To explain this further in his words, *poor dependency management leads to
    code that is hard to change, fragile, and non-reusable*. Reusability is one the
    main principles of OOP, along with maintainability (the capacity to change as
    the project grows: one of the purposes of inheritance).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 用他的话进一步解释，*糟糕的依赖管理会导致代码难以更改、脆弱且不可重用*。可重用性是面向对象编程的主要原则之一，与可维护性（随着项目增长而改变的能力：继承的一个目的）并列。
- en: 'Overall, there are 11 principles to consider, but they can be divided into
    three areas:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，有11个原则需要考虑，但它们可以分为三个领域：
- en: The SOLID principles, which deal with class design
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID原则，涉及类设计
- en: 'The rest of the principles, which are about packages: three of them are about
    package cohesion and the other three study couplings between packages and how
    to evaluate the package structure'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余的原则，关于包的：其中三个关于包的内聚性，另外三个研究包之间的耦合以及如何评估包结构
- en: We're going to start with the SOLID principles, which by extension not only
    affect the class design, but other architectures as well.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从SOLID原则开始，这些原则不仅影响类设计，还影响其他架构。
- en: For instance, the application of some of these ideas paved the way for some
    of the most important modifications in the building of HTML5.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，应用这些想法中的某些内容为HTML5构建中的某些最重要的修改铺平了道路。
- en: The application of the **SRP** (**Single Responsibility principle**), from which
    the more general design principle of Separation of Concerns is derived, only highlighted
    the need to totally separate presentation (CSS) from content (HTML) and the subsequent
    deprecation of some tags (`<cite>`, `<small>`, `<font>`, and so on).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 应用**SRP**（**单一职责原则**），从中衍生出更一般的设计原则——关注点分离，仅强调了完全分离表示（CSS）和内容（HTML）的需要，以及随后一些标签（`<cite>`、`<small>`、`<font>`等）的弃用。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some of the aforementioned tags are deprecated and not recommended as presentation
    features, but they are kept in the standard because of their semantic value instead,
    such as `<b>`, `<i>`, <`small>`, and so on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些上述标签已被弃用，不推荐作为表示功能，但它们保留在标准中，是因为它们的语义价值，例如`<b>`、`<i>`、`<small>`等。
- en: This applies to some popular frameworks, such as AngularJS, which was designed
    not only with the Single Responsibility principle in mind, but also based on the
    Dependency Inversion principle (the **D** in SOLID).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于一些流行的框架，例如AngularJS，它不仅考虑了单一职责原则，还基于依赖倒置原则（SOLID中的**D**）。
- en: 'The next graphic resumes the five principles'' initials and its correspondences:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图表总结了五个原则的首字母及其对应关系：
- en: '![The SOLID principles](img/image00629.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![SOLID原则](img/image00629.jpeg)'
- en: 'The explanation of every letter in the acronym as expressed in Wikipedia is
    as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科中关于该缩写每个字母的解释如下：
- en: '**S - Single Responsibility Principle**: A class should have only a single
    responsibility (that is, only one potential change in the software''s specification
    should be able to affect the specification of the class). Martin states that this
    principle is based on the principle of cohesion, previously defined by Tom de
    Marco in a book named *Structured Analysis and Systems Specification* and by Meilir
    Page-Jones in his work *The Practical Guide to Structured Systems Design*.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S - 单一职责原则**：一个类应该只有一个职责（也就是说，只有软件规范的一个潜在变化能够影响类的规范）。马丁表示，这个原则基于之前由汤姆·德·马尔科在《结构化分析和系统规范》一书中以及梅利尔·佩奇-琼斯在他的著作《结构化系统设计实用指南》中定义的凝聚性原则。'
- en: '**O - Open/Closed Principle**: Software entities should be open for extension,
    but closed for modification. Bertrand Meyer was the first to propose this principle.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O - 开放/封闭原则**：软件实体应该对扩展开放，但对修改封闭。伯特兰·迈耶是第一个提出这一原则的人。'
- en: '**L - Liskov Substitution principle**: *Objects in a program should be replaceable
    with instances of their subtypes without altering the correctness of that program*.
    Barbara Liskov first stated this.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L - Liskov 替换原则**：*程序中的对象应该可以用其子类型实例替换，而不会改变该程序的正确性*。芭芭拉·利斯科夫首先提出了这个原则。'
- en: '**I - Interface Segregation principle**: *Many client-specific interfaces are
    better than one general-purpose interface*. Robert C. Martin was the first to
    use and formulate this principle.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I - 接口隔离原则**：*许多针对特定客户端的接口比一个通用接口更好*。罗伯特·C·马丁是第一个使用并制定这一原则的人。'
- en: '**D - Dependency inversion principle**: *We should ''Depend on Abstractions''.
    Do not depend upon concretions*. This too is an idea developed by Robert C. Martin.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D - 依赖倒置原则**：*我们应该“依赖于抽象”。不要依赖于具体实现*。这个想法也是由罗伯特·C·马丁提出的。'
- en: Single Responsibility principle
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: For **Single Responsibility principle** (**SRP**), the basic statement, in this
    case, is *there should never be more than one reason for a class to change*. In
    this context, responsibility is defined as *a reason for change*. If, under any
    circumstance, more than one reason comes up to change the class, the class' responsibilities
    are multiple and should be redefined.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**单一职责原则**（SRP），基本陈述在这种情况下是*一个类不应该有超过一个改变的理由*。在这种情况下，职责被定义为*改变的理由*。如果在任何情况下，出现多个理由来改变类，那么类的职责是多个的，应该重新定义。
- en: This is, indeed, one of the most difficult principles to apply properly because
    as Martin says, *conjoining responsibilities is something that we do naturally*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是最难正确应用的原则之一，因为正如马丁所说，*合并职责是我们自然而然做的事情*。
- en: 'In his book *Agile Principles, Patterns, and Practices in C#* , Martin proposes
    a canonical example to show the differences, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的书《敏捷原则、模式和C#实践》中，马丁提出一个典型的例子来展示差异，如下所示：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Given the previous interface, any class implementing this interface has two
    responsibilities: the connection management and the communication itself. Such
    responsibilities can be used from the different parts of an application, which,
    in turn, might change as well.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 给定前面的接口，任何实现这个接口的类都有两个职责：连接管理和通信本身。这样的职责可以从应用程序的不同部分使用，而这些部分也可能随之改变。
- en: 'Instead of this code structure, Martin proposes a different diagram:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与此代码结构不同，马丁提出了不同的图示：
- en: '![Single Responsibility principle](img/image00630.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![单一职责原则](img/image00630.jpeg)'
- en: However, one wonders, should these two responsibilities be separated? It only
    depends on application changes. To be precise, the key here is to know whether
    changes in the application affect the signature of connection functions. If they
    do, we should separate both; otherwise, there's no need for separation because
    we would then create needless complexity.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，人们可能会想，这两个职责是否应该分开？这完全取决于应用的变化。更准确地说，关键在于知道应用的变化是否会影响连接函数的签名。如果会，我们就应该将两者分开；否则，没有必要分开，因为那样会创造不必要的复杂性。
- en: So, overall, reason to change is the key, but keep in mind that a reason to
    change is applicable only if changes occur.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总的来说，变化的原因是关键，但请记住，变化的原因只有在发生变化时才适用。
- en: In other situations, there might be reasons to keep distinct responsibilities
    together as long as they are closely related to the business definitions or have
    to do with hardware requirements of the operating system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，只要它们与业务定义紧密相关或与操作系统的硬件要求有关，就有理由将不同的职责保持在一起。
- en: An example
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个例子
- en: Let's imagine we need to create a simple Windows Forms application (we pick
    this model for simplicity in order to avoid unnecessary XAML), which has the ability
    to offer the user a few cars (actually, just three different brands), and the
    application should show maximum speed and a photo for the selected car.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们需要创建一个简单的Windows Forms应用程序（我们选择这个模型是为了简单，以避免不必要的XAML），该应用程序能够向用户提供几款汽车（实际上，只有三个不同的品牌），并且应用程序应该显示所选汽车的最高速度和照片。
- en: Later on, we can derive from the class hierarchy to create different versions
    that are able to cover distinct characteristics, specific of business models,
    or legal conditions, among others.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们可以从类层次结构中派生出不同的版本，这些版本能够覆盖不同的特征，具体包括业务模型或法律条件等。
- en: 'So, the first step is to represent the user interface that will cover the requirements,
    mentioned previously, according to the indications. I came up with a very simple
    Windows form, as shown in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一步是根据指示表示将覆盖之前提到的要求的用户界面。我设计了一个非常简单的Windows窗体，如下面的截图所示：
- en: '![An example](img/image00631.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![一个示例](img/image00631.jpeg)'
- en: We're dealing with three (or more) brands, and optionally, we have a place to
    display the maximum speed value. We also included a button for acceleration so
    that we can verify that the car never goes faster than its maximum speed limit.
    Finally, the photo will remind us about the car we're dealing with.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理的是三个（或更多）品牌，并且可选地有一个地方来显示最大速度值。我们还包括了一个加速按钮，以便我们可以验证汽车永远不会超过其最大速度限制。最后，照片将提醒我们我们正在处理的是哪款汽车。
- en: So, we plan to define a class named `SportCar`, in which we will abstract the
    required elements to be managed from the UI, and to make things clearer, we start
    by creating an interface, `ISportCar`, which states the requisites.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们计划定义一个名为`SportCar`的类，在这个类中，我们将抽象出从UI管理所需元素，并且为了使事情更清晰，我们首先创建一个接口，`ISportCar`，它声明了必需的条件。
- en: 'We can use the Class Diagram tool to create an interface that defines four
    properties and one method: `Brand`, `MaxSpeed`, `Photo`, `Speed`, and `Accelerate`
    (which will change the Speed property from the user interface). So, the final
    code is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类图工具创建一个定义了四个属性和一个方法（`Accelerate`，它将改变用户界面中的`Speed`属性）的接口：`Brand`、`MaxSpeed`、`Photo`、`Speed`和`Accelerate`。因此，最终的代码如下：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using the Class Diagram tool, we can create a `SportCar` class and link it to
    the interface so it declares the dependency. Later on, with the basic class declaration
    created by the IDE, we can move on to the source code and indicate the `Implement
    Interface` option to have the class with the interface implemented for us.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类图工具，我们可以创建一个`SportCar`类并将其链接到接口，以便声明依赖关系。稍后，使用IDE创建的基本类声明，我们可以继续进行源代码，并选择`实现接口`选项，以便为我们实现具有接口的类。
- en: 'A few touches for the sake of simplicity can have us end up with the following
    initial code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，一些触摸可能会让我们得到以下初始代码：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Observe that all properties are read-only, since all except one should be established
    at creation time, and the only method that changes (`Speed`) must only vary using
    the `Accelerate` method (declared as virtual in order to allow further inheritance).
    This method returns a Boolean value to indicate the limit conditions: `MaxSpeed`
    exceeded. This is why it''s declared a private set.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有属性都是只读的，因为除了一个之外，所有属性都应该在创建时设置，而唯一会改变的方法（`Speed`）必须只能通过使用`Accelerate`方法（声明为虚拟以便允许进一步继承）来改变。此方法返回一个布尔值以指示极限条件：`MaxSpeed`超过。这就是为什么它被声明为私有设置。
- en: 'On the graphic side, our (now modified) diagram should reveal dependencies
    and members of both code fragments:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形方面，我们（现在已修改）的图表应该揭示代码片段的依赖关系和成员：
- en: '![An example](img/image00632.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![一个示例](img/image00632.jpeg)'
- en: 'So, at first, the class has the sole responsibility of managing the state of
    a `SportCar` instance of the class. This implies business logic: a Ferrari looks
    like a Ferrari, not like a BMW, and each one has its own properties (`MaxSpeed`
    and `Speed` in this case). Nothing related to the user interface or storing state,
    among other things, should be considered here.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最初，这个类只负责管理`SportCar`类实例的状态。这意味着业务逻辑：法拉利看起来像法拉利，不像宝马，每个都有自己的属性（在这个例子中是`MaxSpeed`和`Speed`）。除了用户界面或存储状态之外，其他任何与这里无关的内容都不应该被考虑。
- en: Next, we need a constructor that enforces some of the principles mentioned earlier.
    It should resolve all the immutable properties; so, when the class is created,
    they are assigned the proper value.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个构造函数来强制执行之前提到的一些原则。它应该解析所有不可变属性；因此，当创建类时，它们被分配了适当的值。
- en: 'Here, we face another problem: how does our class know about the possible brands
    available? There are several approaches here, but a simple one would be to declare
    an internal array defining the allowed brands and have the constructor check whether
    the brand suggested in the construction is one of the brands our class can manage.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们面临另一个问题：我们的类如何知道可能的品牌？这里有几种方法，但一个简单的方法是声明一个内部数组，定义允许的品牌，并让构造函数检查在构造中建议的品牌是否是我们类可以管理的品牌之一。
- en: Note that I have included three simple pictures corresponding to the three brands
    inside the application's resource file. This is a dependency. If a fourth brand
    needs to be considered, we should change the constructor to supply this additional
    functionality, but for the sake of simplicity, let's assume that no changes in
    the business logic of the number of cars will happen for the moment.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经在应用程序的资源文件中包含了三个与三个品牌对应的简单图片。这是一个依赖项。如果需要考虑第四个品牌，我们应该将构造函数更改为提供这项附加功能，但为了简单起见，让我们假设目前不会发生关于汽车数量业务逻辑的变化。
- en: 'With all this in mind, we will add the following code to our class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，我们将以下代码添加到我们的类中：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this, we have an operational (although incomplete) version of our class.
    Now, in the user interface, we should declare a variable of the `SportCar` class
    and instantiate it every time the user changes the brand using the `cboPickUpCar`
    ComboBox.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们得到了我们类的操作（尽管是不完整的）版本。现在，在用户界面中，我们应该声明一个`SportCar`类的变量，并在用户使用`cboPickUpCar`组合框更改品牌时实例化它。
- en: Actually, we also need to update the UI once the car is instantiated so that
    it reflects the properties of the car (its state). And it should be consistent
    with the properties of every brand available.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，一旦创建了汽车，我们还需要更新UI，以便它反映汽车（其状态）的属性。并且它应该与每个可用的品牌的属性保持一致。
- en: 'This simple code does the trick:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简单的代码就完成了这项任务：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we have a first version that works properly, but our class needs to have
    the ability to change the `Speed` property. So we add some code to the `Accelerate`
    method:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个工作正常的第一版本，但我们的类需要具有更改`Speed`属性的能力。因此，我们在`Accelerate`方法中添加了一些代码：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And that''s it. We should now reflect these changes in the UI, which is pretty
    straightforward:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们现在应该在UI中反映这些更改，这相当直接：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The final result should work as expected (refer to the screenshot). You can
    pick from the different brands available, and every new selection provokes a new
    instantiation of the `SportCar` class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应该按预期工作（参考截图）。你可以从不同的品牌中选择，每次新的选择都会引发`SportCar`类的新实例化。
- en: We can see all the properties at runtime, and the only mutable property (`Speed`)
    is changed exclusively from the `Accelerate` method, which now has a unique responsibility.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在运行时看到所有属性，唯一的可变属性（`Speed`）仅从`Accelerate`方法中更改，现在它有一个独特的责任。
- en: 'However, since this responsibility implies business logic, it also checks whether
    an attempt to exceed the allowed speed has taken place and avoids a case inspecting
    the possible value of an increase in the speed (we have assumed a constant value
    for that speed in the initial declarations of the class). You should see an output
    like the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于这项责任涉及到业务逻辑，它还检查是否发生了超出允许速度的尝试，并避免检查速度增加的可能值的案例（我们在类的初始声明中为该速度假设了一个常数值）。你应该看到以下类似的输出：
- en: '![An example](img/image00633.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![一个示例](img/image00633.jpeg)'
- en: Now, let's consider some possible situations that arise when changes are proposed.
    This is when the next principle comes into action, and it deals with how to manage
    requisites when new conditions arise.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一些在提出更改时可能出现的可能情况。这是下一个原则开始发挥作用的时候，它处理的是在出现新条件时如何管理需求。
- en: Open/Closed principle
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放/封闭原则
- en: We can detect the need to use this principle when a change in the module outcomes
    in a waterfall of changes that affect dependent modules. The design is said to
    be too inflexible.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当模块的结果变化导致影响依赖模块的连锁反应时，我们可以检测到需要使用这个原则。这种设计被认为过于不灵活。
- en: The **Open/Closed principle** (**OCP**) advises us that we should refactor the
    application in a manner that future changes don't provoke further modifications.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放/封闭原则**（**OCP**）建议我们应该以未来更改不会引发进一步修改的方式重构应用程序。'
- en: The form to apply this principle correctly would be by extending the functionality
    with new code (for instance, using polymorphism) and never changing the old code,
    which is working already. We can find several strategies to achieve this goal.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正确应用这个原则的形式是通过添加新代码（例如，使用多态）来扩展功能，而永远不改变已经工作的旧代码。我们可以找到几种实现这个目标的方法。
- en: Observe that *closed for modification* is especially meaningful when you have
    distinct, separate modules (DLLs, EXEs, and so on) that depend on the module to
    be changed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你有明确、独立的模块（DLLs、EXEs 等）依赖于要更改的模块时，*封闭于修改*特别有意义。
- en: On the other hand, using extension methods or polymorphic techniques allows
    us to perform changes in code without affecting the rest. Think, for example,
    about the extension methods available in the C# language since version 3.0\. You
    can consider extension methods a special type of static method, with the difference
    that they are called as if they were instance methods of the extended type. You
    find a typical example in the LINQ standard query operators because they add a
    query functionality to the existing types, such as `System.Collections.IEnumerable`
    or `System.Collections.Generic.IEnumerable<T>`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用扩展方法或多态技术允许我们在不影响其余部分的情况下对代码进行更改。例如，考虑 C# 语言自 3.0 版本以来可用的扩展方法。你可以将扩展方法视为一种特殊的静态方法，区别在于它们被调用时就像它们是扩展类型的实例方法一样。你可以在
    LINQ 标准查询运算符中找到一个典型例子，因为它们向现有类型添加了查询功能，例如 `System.Collections.IEnumerable` 或 `System.Collections.Generic.IEnumerable<T>`。
- en: The classical and simplest example of this pattern is the client/server cohesion
    that is largely seen in development for many years. It is preferable that clients
    depend on servers' abstractions, not on their concretions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的经典和最简单的例子是客户端/服务器耦合，这在多年的开发中很常见。客户端最好依赖于服务器的抽象，而不是具体实现。
- en: 'This can be achieved with interfaces. Servers can implement a client interface
    that clients will use to connect to them. In this manner, servers can change without
    affecting the way clients use them (refer to the next diagram):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过接口来实现。服务器可以实现一个客户端接口，客户端将使用它来连接到服务器。这样，服务器可以改变，而不会影响客户端使用它们的方式（参考下一张图）：
- en: '![Open/Closed principle](img/image00634.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![开放/封闭原则](img/image00634.jpeg)'
- en: Any subtype of client interface will be free to implement the interface in the
    way it deems more appropriate and as long as it doesn't break other clients' access.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 任何客户端接口的子类型都可以自由地以它认为更合适的方式实现接口，只要它不破坏其他客户端的访问。
- en: Back to our sample
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到我们的示例
- en: Now, let's imagine that the Mercedes corporation announces a change in their
    models, which allows you to receive a notification when the user is in danger
    due to the car approaching its speed limit.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想象一下，奔驰公司宣布对其车型进行更改，这使得你可以在用户因为汽车接近速度限制而处于危险时收到通知。
- en: On first view, some would think about modifying the `Accelerate` method to include
    an event that can communicate this circumstance to whatever user interface is
    using it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，有些人可能会考虑修改 `Accelerate` 方法，以包含一个可以将其情况传达给使用它的任何用户界面的事件。
- en: However, that would violate the OCP, since the current version is already working
    properly. This is one case where polymorphism is useful.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这会违反 OCP，因为当前版本已经运行良好。这是多态有用的一例。
- en: We can create another overload of the `Accelerate` method to allow this. It
    could receive an argument (the brand) that identifies whether the call is being
    made from a Mercedes and launch an event call, so any client could act accordingly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建 `Accelerate` 方法的另一个重载来允许这样做。它可以接收一个参数（品牌），以标识调用是否来自奔驰，并启动一个事件调用，这样任何客户端都可以相应地行动。
- en: 'I''ll duplicate the project in a new one with another name so that you always
    have distinct versions depending on the case (`Demo2-OCP`):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在一个新的项目中复制这个项目，并给它另一个名称，这样你就可以根据情况始终拥有不同的版本（例如 `Demo2-OCP`）：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we declare a new event member (`SpeedLimit`) and invoke the
    event if the Boolean value is `true`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们声明了一个新的事件成员（`SpeedLimit`），如果布尔值为 `true`，则调用该事件。
- en: Since events are notifications and not direct function calls to the user interface,
    the UI is free to subscribe to the events required.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件是通知而不是直接调用用户界面的函数，UI 可以自由订阅所需的事件。
- en: 'In the user interface, we should subscribe to the `SpeedLimit` event and modify
    our `btnAccelerate_Click` event handler in this manner to handle this situation:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户界面中，我们应该订阅 `SpeedLimit` 事件，并按以下方式修改我们的 `btnAccelerate_Click` 事件处理器来处理这种情况：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the instantiation process, the subscription is quite simple, and we can
    also have the IDE to create the `SpeedLimit` event handler for us:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化过程中，订阅相当简单，我们也可以让 IDE 为我们创建 `SpeedLimit` 事件处理器：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Observe that I'm simplifying the code as much as possible because the interest
    here is showing coding practices that align with the SOLID principles.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我在尽可能简化代码，因为这里的重点是展示与 SOLID 原则一致的编码实践。
- en: 'When we execute this code, we can observe that—just for the Mercedes—if we
    try to pass the speed limit, a MessageBox popup indicating the circumstance appears
    (refer to the screenshot). The other brands are not affected:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行此代码时，我们可以观察到——仅针对奔驰——如果我们尝试传递速度限制，会出现一个弹出消息框，表明情况（参考截图）。其他品牌不受影响：
- en: '![Back to our sample](img/image00635.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![回到我们的示例](img/image00635.jpeg)'
- en: However, as we mentioned, the .NET framework also uses these patterns and others
    in different namespaces, and that also includes the important LSP principle, as
    we'll see next.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们提到的，.NET 框架也在不同的命名空间中使用了这些模式和其它模式，这还包括我们接下来将要看到的 LSP 原则。
- en: Liskov Substitution principle
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Liskov 替换原则
- en: 'Let''s remember this definition: subtypes must be substitutable for their base
    types. This means that this should happen without breaking the execution or losing
    any other kind of functionality.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记住这个定义：子类型必须可替换为其基类型。这意味着这应该在不破坏执行或丢失任何其他类型的功能的情况下发生。
- en: You'll notice that this idea lies behind the basic principles of inheritance
    in the OOP programming paradigm.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这个想法是面向对象编程范式继承基本原理背后的。
- en: If you have a method that requires an argument of the `Person` type (let's put
    it that way), you can pass an instance of another class (`Employee`, `Provider`,
    and so on) as long as these instances inherit from `Person`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个需要 `Person` 类型参数的方法（让我们这样表述），你可以传递一个继承自 `Person` 的另一个类的实例（例如 `Employee`、`Provider`
    等）。
- en: This is one of the main advantages of well-designed OOP languages, and the most
    popular and accepted languages support this characteristic.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设计良好的面向对象语言的主要优势之一，最受欢迎和接受的语言支持这一特性。
- en: Back to the code again
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 再次回到代码
- en: Let's take a look at the support inside our sample, where a new requisite arises.
    Actually, our demo simply calls the subscribers of Mercedes cars and notifies
    them that a `SpeedLimit` event took place.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们示例中的支持情况，其中出现了一个新的需求。实际上，我们的演示只是调用了奔驰车的订阅者，并通知他们发生了 `SpeedLimit` 事件。
- en: However, what if we need to know the moment in time in which that circumstance
    happened and the resulting speed that we tried to obtain? That is, what if we
    need more information about the event?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们需要知道那个情况发生的时间点和我们试图获得的速度呢？也就是说，如果我们需要更多关于事件的详细信息呢？
- en: In the current state, the `SpeedLimit` event does not pass any information to
    the caller beyond the sender (which refers to the origin of such call). But we
    can use the implementation of the Liskov Substitution principle inherent to the
    C# language in order to pass a derived class of `EventArgs` containing the required
    information, and the context should manage it just as well.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前状态下，`SpeedLimit` 事件除了发送者（指代调用源）之外，不会向调用者传递任何信息。但我们可以利用 C# 语言内固有的 Liskov 替换原则的实现，传递一个包含所需信息的
    `EventArgs` 派生类，上下文应该能够很好地管理它。
- en: 'So, the first step is to inherit from `EventArgs` and create a new class capable
    of holding the solicited information:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一步是从 `EventArgs` 继承并创建一个新的类，以便能够包含所需的信息：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And we need to change the event invocation so that it recovers the necessary
    information before calling the event. In this way, the new version of `Accelerate`—which
    is still totally compatible with the previous one—will be as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改事件调用，以便在调用事件之前恢复必要的信息。这样，新的 `Accelerate` 版本——仍然完全兼容之前的版本——将如下所示：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, when we invoke `SpeedLimit`, we are sending business logic information to
    any subscriber, either from the UI or any other. So, we can pass a derived instance
    of the `EventArgs` class to the event without provoking any complain in the UI's
    editor (or the compiler).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们调用`SpeedLimit`时，我们正在向任何订阅者发送业务逻辑信息，无论是从UI还是其他地方。因此，我们可以将`EventArgs`类的派生实例传递给事件，而不会在UI的编辑器（或编译器）中引起任何抱怨。
- en: 'The final step is to change the user interface to recover the data passed to
    it and present it in a modified version of the previous `MessageBox` call:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将用户界面更改以恢复传递给它的数据，并以修改后的先前`MessageBox`调用的形式呈现：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This time, when we select a Mercedes car and try to surpass the limit, we get
    a much more informative report in `MessageBox`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当我们选择一辆梅赛德斯汽车并尝试超过限制时，我们在`MessageBox`中得到了一个更详细的信息报告：
- en: '![Back to the code again](img/image00636.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![再次回到代码中](img/image00636.jpeg)'
- en: Thanks to the Liskov Substitution principle support, we were able to add behavior
    and information with minimum effort, knowing that the UI receiving the information
    would perform a simple casting to convert the basic `EventArgs` declaration into
    the extended `SpeedLimitData` event that we really passed to the event handler.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Liskov替换原则的支持，我们能够以最小的努力添加行为和信息，知道接收信息的UI会执行简单的转换，将基本的`EventArgs`声明转换为实际传递给事件处理器的扩展`SpeedLimitData`事件。
- en: Other implementations of LSP in .NET (Generics)
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET中LSP的其他实现（泛型）
- en: This is not the only implementation of the LSP principle that we find inside
    .NET, since different areas of the framework have grown using this conception.
    For instance, generics are one of the benefits of LSP.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们在.NET中找到的唯一LSP原则的实现，因为框架的不同领域都是使用这种概念增长的。例如，泛型是LSP的好处之一。
- en: In our sample, we can create a generic version of the event in order to manage
    extra information very easily. Imagine that besides the private measures taken
    in the case of Mercedes, all the brands now want to support messaging when the
    legal speed limit is reached.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的样本中，我们可以创建一个通用版本的事件，以便非常容易地管理额外信息。想象一下，除了在梅赛德斯案例中采取的私人措施之外，现在所有品牌都希望在达到法定速度限制时支持消息传递。
- en: This affects any instance of `SpeedCar`. It's not mandatory (it doesn't force
    you to stop increasing the speed, but it shows you another warning about this
    condition).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这会影响`SpeedCar`的任何实例。这不是强制性的（它不会强迫你停止增加速度，但它会显示关于这种条件的另一个警告）。
- en: 'Since it has an impact on all brands, we can add a new event to the `SpeedCar`
    class, only this time, we define it as generic in order to support the extra information:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它对所有品牌都有影响，我们可以在`SpeedCar`类中添加一个新事件，但这次我们将其定义为泛型，以支持额外信息：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s assume that the value for Speed Legal Limit is the maximum allowed in
    some states of the US (80 mi/h). We''ll define a new constant, `MaxLegal`, with
    this value:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设速度法定限制值是美国某些州允许的最大值（80英里/小时）。我们将定义一个新的常量`MaxLegal`，具有这个值：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, to reflect this new condition, we should modify our `Accelerate` methods
    to include a previous call in case the car exceeds the legal value, indicating
    the amount exceeded:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了反映这个新条件，我们应该修改我们的`Accelerate`方法，以包括在汽车超过法定值时的前一个调用，指示超出的量：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That's all the work you need to do with the `SpeedCar` class. The rest will
    be an update to the user interface; so, for any car, when the condition launches,
    another `MessageBox` call warns the user about the condition.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要与`SpeedCar`类一起做的所有工作。其余的将是用户界面的更新；因此，对于任何汽车，当条件启动时，另一个`MessageBox`调用会警告用户关于该条件。
- en: 'In this way, we now register every car for the `LegalLimitCondition` event
    and let the IDE generate the associated event handler for us:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们现在为每个汽车注册`LegalLimitCondition`事件，并让IDE为我们生成相关的事件处理器：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This time, we pass the argument to a revised version of the `UpdateUI` method,
    which now admits an optional argument, indicating the speed excess:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将参数传递给`UpdateUI`方法的修订版，它现在接受一个可选参数，表示速度超限：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And that's it. Now, different event mechanisms inform the user interface about
    the business logic conditions via notifications with a custom event system.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在，不同的事件机制通过自定义事件系统的通知，将业务逻辑条件告知用户界面。
- en: Note that the sequence in calling events is important and the final assignment
    of the `Speed` value is performed at the end of the `Accelerate` method when all
    previous conditions have been processed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意调用事件的顺序很重要，并且`Speed`值的最终赋值是在`Accelerate`方法末尾进行的，此时所有先前条件都已处理。
- en: Events are flexible enough as to be defined in a way that allows us to pass
    our own information via classic definitions, or—with the participation of generics—we
    can simply define a generic event handler that holds information of any kind.
    All these techniques foster the implementation of good practices, not just the
    SOLID principles.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 事件足够灵活，可以定义为允许我们通过经典定义传递自己的信息，或者——在泛型的参与下——我们可以简单地定义一个通用的事件处理器，它可以持有任何类型的信息。所有这些技术都促进了良好实践的实施，而不仅仅是SOLID原则。
- en: Changes in the UI should not affect the `SportClass` definition; although its
    usage of the business logic differs, we keep the changes in the class to a minimum.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: UI中的更改不应影响`SportClass`的定义；尽管其业务逻辑的使用不同，但我们尽量将类中的更改保持在最小。
- en: 'At runtime, we will now be warned about any excess in velocity over the `MaxLegal`
    constant previously established (refer to the screenshot):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，我们现在将警告任何超过之前设定的`MaxLegal`常数的速度超额（参考截图）：
- en: '![Other implementations of LSP in .NET (Generics)](img/image00637.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![.NET中LSP的其他实现（泛型）](img/image00637.jpeg)'
- en: 'Let''s review the other two principles remaining in the SOLID package now:
    **Interface Segregation principle** (**ISP**) and **Dependency Inversion principle**
    (**DIP**).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾SOLID包中剩余的两个原则：**接口分离原则**（**ISP**）和**依赖倒置原则**（**DIP**）。
- en: Interface Segregation principle
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口分离原则
- en: As Martin states, this principle *deals with the inconveniences of "fat" interfaces*.
    And the problem arises when the interfaces of the class can be logically fragmented
    into distinct groups or methods.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如马丁所说，这个原则*处理了“胖”接口的不便问题*。问题出现在当类的接口可以逻辑上分解成不同的组或方法时。
- en: In this case, if there is more than a client of our application, chances are
    that some clients are connected to a functionality they never use.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我们的应用程序有多个客户端，那么很可能有些客户端连接到了他们从未使用过的功能。
- en: 'Back to our demo again: the mere review of the definition reveals that our
    system has some defects from the point of view of this principle.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的演示：仅仅审查定义就揭示出，从这一原则的角度来看，我们的系统存在一些缺陷。
- en: 'First, we''re implementing a method that is only used by a type of a `SportCar`
    client: the Mercedes. The other brands don''t use it. In case a new condition
    arises for a different brand, new options should be created.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实现了一个仅由`SportCar`客户端类型使用的方法：奔驰。其他品牌不使用它。如果不同品牌出现新的条件，应该创建新的选项。
- en: 'So, this marks a difference in the way in which we can categorize our cars:
    those who notify the user interface about `SpeedLimit` and those who don''t. We
    should start by redefining our `ISportCar` interface to cover only those aspects
    that are commonly used by any client. This includes the `LegalLimitCondition`
    event but not the `SpeedLimit` event.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这标志着我们分类汽车的方式上的一个差异：那些通知用户界面关于`SpeedLimit`的汽车和那些不通知的汽车。我们应该首先重新定义我们的`ISportCar`接口，使其仅涵盖任何客户端都常用的方面。这包括`LegalLimitCondition`事件，但不包括`SpeedLimit`事件。
- en: 'So, we will have this implementation:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将有这个实现：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The new version of `SportCar` would implement only an `Accelerate` overload
    of the method, launching the `LegalLimitCondition` event but not the `SpeedLimit`
    event, which is only suitable for the Mercedes:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`SportCar`的新版本将仅实现方法的`Accelerate`重载，触发`LegalLimitCondition`事件但不触发`SpeedLimit`事件，这对于奔驰是合适的：'
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that we still control `MaxSpeed`, only that we don't take any action but
    avoid the speed beyond the maximum value.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们仍然控制`MaxSpeed`，只是我们不采取任何行动，避免超过最大值。
- en: This separation suggested by this principle also applies to the first principle,
    since now, the responsibilities of this class are focused on the group of clients
    that use this implementation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则建议的这种分离也适用于第一原则，因为现在，这个类的责任集中在使用这个实现的一组客户端上。
- en: 'On the other hand, we will create a new class `SportsCarWithN` (a sports car
    with notifications) that inherits from `SportsCar` but adds the functionality
    required by the Mercedes (or any other brand that would decide to do this in the
    future):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们将创建一个新的类`SportsCarWithN`（带通知的跑车），它继承自`SportsCar`，但增加了奔驰（或任何其他决定在未来这样做品牌）所需的功能：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this manner, each part of the hierarchy takes care of its own duties. Any
    car that inherits from `SportCarWithN` will have the extra functionality, while
    the rest of the cars will behave in the standard manner.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，层次结构中的每个部分都负责自己的职责。任何从`SportCarWithN`继承的汽车都将具有额外的功能，而其他汽车将以标准方式运行。
- en: 'In the user interface, things also get simplified. Now, we declare `theCar`
    to be of type `ISportCar` and decide which constructor to call at execution time:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户界面中，事情也变得简单。现在，我们声明`theCar`的类型为`ISportCar`，并在执行时决定调用哪个构造函数：
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `btnAccelerate_Click` event handler is also simplified, since every instance
    of `ISportCar` will know how to call the appropriate method in the underlying
    model:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`btnAccelerate_Click`事件处理程序也被简化了，因为每个`ISportCar`实例都知道如何调用底层模型中的适当方法：'
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, at runtime, only the Mercedes brand receives both notifications, while
    the rest of the brands get only the `LegalLimitCondition` event.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在运行时，只有Mercedes品牌接收两个通知，而其他品牌只收到`LegalLimitCondition`事件。
- en: You can check the results in Demo-ISP and check out both types of conditions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Demo-ISP中检查结果，并查看两种类型的条件。
- en: Dependency Inversion principle
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: 'The last of the SOLID principles is based on two statements, that Wikipedia
    states in this form:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则的最后一项基于两个陈述，维基百科以这种形式陈述：
- en: '*High-level modules should not depend on low-level modules. Both should depend
    on abstractions.*'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高级模块不应依赖于低级模块。两者都应依赖于抽象*。'
- en: '*Abstractions should not depend upon details. Details should depend upon abstractions.*'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*抽象不应依赖于细节。细节应依赖于抽象*。'
- en: As for the first statement, we should clarify what we understand by high-level
    and low-level modules. The terminology is related to the importance of the actions
    performed by the module.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 至于第一个陈述，我们应该澄清我们对高级和低级模块的理解。这个术语与模块执行的动作的重要性有关。
- en: 'Let''s put it simply: if a module holds the business logic of a `Customers`
    class, and another includes the format that a list of the `Customers` class uses
    in a report, the first one would be high-class and the second would be low-class.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简单地说：如果一个模块包含`Customers`类的业务逻辑，而另一个包含`Customers`类在报告中使用的列表格式，那么第一个模块将是高级的，而第二个将是低级的。
- en: The second statement speaks by itself. If an abstraction depends on details,
    the usage as a definition contract is compromised.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个陈述不言自明。如果一个抽象依赖于细节，那么作为定义合同的用法就会受到损害。
- en: 'In the case of our sample, we still have some code that will not grow appropriately:
    the `SportsCar` creation method depends much on what the user writes in the ComboBox.
    There are several situations that could show this inconvenience: writing the wrong
    name in the brand selection procedure, adding future new brands, and so on. There
    is some boilerplate code in the UI that we can improve.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的样本中，我们仍然有一些代码不会适当地增长：`SportsCar`创建方法在很大程度上依赖于用户在ComboBox中输入的内容。有几种情况可能会显示出这种不便：在品牌选择过程中输入错误的名字、添加未来的新品牌等。UI中有些样板代码我们可以改进。
- en: A final version of the sample
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样本的最终版本
- en: Without pretending that the sample is perfect (at all), the creation procedure
    can be extracted from the UI and delegated to another class (`CarFactory`) that
    would be responsible for calling the appropriate constructor depending on the
    brand. (We'll see that this technique is actually implemented using one of the
    design patterns we'll study later on.)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 不假装这个样本（在任何方面）是完美的，创建过程可以从UI中提取并委托给另一个类（`CarFactory`），该类将负责根据品牌调用适当的构造函数。（我们将看到这种技术实际上是通过我们稍后将要学习的设计模式之一来实现的。）
- en: In this way, the responsibility of calling the proper constructor would be on
    `CarFactory`, and additional brands can be added more easily.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，调用适当构造函数的责任就在`CarFactory`，并且可以更容易地添加额外的品牌。
- en: In addition, our `SportsCar` class will now exclusively take care of its state
    and business logic related to the state and not the details of `Photo` associations
    or `MaxSpeed` values, which seem adequate for a factory.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的`SportsCar`类现在将专门负责其状态和与状态相关的业务逻辑，而不是`Photo`关联或`MaxSpeed`值的细节，这些似乎适合工厂。
- en: 'So, we will now have a new class (located in the same file as the `SportsCar`
    file), containing these details:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在将有一个新的类（位于与`SportsCar`文件相同的文件中），包含这些细节：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With this new version, the `SportsCar` class is reduced to a minimum: it declares
    constants, its event, its state (properties), and the only action required (`Accelerate`).
    The rest is in the hands of the `CarFactory` class.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新版本中，`SportsCar`类被简化到最小：它声明了常量、事件、状态（属性）以及唯一需要的操作（`Accelerate`）。其余的由`CarFactory`类负责。
- en: 'The user interface is also simplified in the creation method, since it doesn''t
    need to know which brand the user selected in order to call either constructor;
    it simply calls the constructor inside `CarFactory` and checks the result of the
    process in order to assign the event handlers required to show the car''s notifications:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建方法中，用户界面也得到了简化，因为它不需要知道用户选择了哪个品牌才能调用任一构造函数；它只是调用`CarFactory`内部的构造函数，并检查过程的结果，以便分配显示汽车通知所需的事件处理程序：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The runtime behavior is just the same as earlier. The difference is that with
    this decoupling of components, maintenance and growing are much easier.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时行为与之前相同。不同的是，通过这种组件解耦，维护和扩展变得更加容易。
- en: 'Let''s imagine that a change happens and the application now has to deal with
    a new type of brand: Ford, which also incorporates `SpeedLimit` notifications.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设发生了一个变化，应用程序现在必须处理一种新的品牌：福特，它也包含`SpeedLimit`通知。
- en: 'The only work to do is to add a picture of a Ford (a Ford GT, not to detract
    from the other cases…) and retouch `CarFactory` to add the new case structure
    and its values:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要做的工作是添加一张福特（福特GT，不要影响其他案例…）的图片，并调整`CarFactory`以添加新的案例结构和其值：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the UI, only one thing is required: adding the new `Ford` string to the
    selection ComboBox, and it''s ready. Now, we''ll be offered the new brand, and
    when we select it, the behavior will be as expected:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI中，只需要做一件事：将新的`Ford`字符串添加到选择ComboBox中，它就准备好了。现在，我们将提供新的品牌，当我们选择它时，行为将如预期：
- en: '![A final version of the sample](img/image00638.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![样本的最终版本](img/image00638.jpeg)'
- en: Generally speaking, there are many ways in which the DIP principle can lead
    to a solution. One of them is through a dependency container, which is a component,
    which serves or provides you with some code, injecting it when required.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，DIP原则可以通过许多方式导致解决方案。其中之一是通过依赖注入容器，这是一个组件，它提供给你一些代码，在需要时注入它。
- en: Some popular dependency containers for C# are Unity and Ninject, to name just
    a couple. In the code, you instruct this component to register certain classes
    of your application; so, later on, when you need an instance of one of them, it
    is served to your code automatically.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流行的C#依赖注入容器包括Unity和Ninject，仅举两个例子。在代码中，你指导这个组件注册你的应用程序的某些类；因此，当后来你需要其中一个类的实例时，它会被自动提供给你的代码。
- en: Other frameworks implement this principle as well, even if they're not purely
    object oriented. This is the case with AngularJS, in which, when you create a
    controller that requires access to a service, you ask for the service in the controller's
    function declaration, and the internal DI system of Angular serves a singleton
    instance of the service without the intervention of the client's code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 其他框架也实现了这个原则，即使它们不是纯粹面向对象的。AngularJS就是这种情况，当你创建一个需要访问服务的控制器时，你会在控制器函数声明中请求该服务，Angular的内部依赖注入系统会提供一个服务的单例实例，而不需要客户端代码的干预。
- en: Design patterns
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: As we said, SOLID principles are beyond any specific consideration on how to
    resolve a certain coding problem and even beyond languages or paradigms. However,
    before Robert Martin defined these principles, other patterns were already in
    use related to very distinct aspects of coding and structuring applications.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，SOLID原则超越了任何特定于如何解决某个编码问题的考虑，甚至超越了语言或范式。然而，在罗伯特·马丁定义这些原则之前，已经存在一些与编码和应用程序结构化的非常不同方面的模式。
- en: In real life, a class can use one or more patterns, making it diffuse the boundary
    between the two. Additionally, you can begin to use a simple pattern and evolve
    into other more complex patterns depending on the needs of our application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，一个类可以使用一个或多个模式，使其边界变得模糊。此外，你可以开始使用一个简单的模式，并根据应用程序的需求逐步发展到更复杂的模式。
- en: 'In 1995, Eric Gamma, Richard Helm, Ralph Johnson, and John Vlissides (since
    then, the **Gang of Four** or **GoF** for short) published a book that has remained
    a reference point: *Design Patterns: Elements of Reusable Object-Oriented Software*.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 1995年，埃里克·伽玛、理查德·赫尔姆、拉尔夫·约翰逊和约翰·弗利斯（从那时起，简称为**四人帮**或**GoF**）出版了一本书，这本书一直是一个参考点：*设计模式：可重用面向对象软件元素*。
- en: The authors analyze a total of 23 design patterns applicable in different coding
    scenarios in order to solve different coding problems.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 作者分析了总共23种适用于不同编码场景的设计模式，以解决不同的编码问题。
- en: 'They divide the 23 patterns into three categories:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 他们将23种模式分为三类：
- en: '**Creational**: It includes these patterns:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建型模式**：它包括以下模式：'
- en: Abstract Factory
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: Builder
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建器模式
- en: Factory
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂模式
- en: Prototype
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型模式
- en: Singleton
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式
- en: '**Structural**: It is composed of these patterns:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构型模式**：它由以下模式组成：'
- en: Adapter
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器模式
- en: Bridge
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桥接模式
- en: Composite
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合模式
- en: Decorator
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰者模式
- en: Façade
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 门面模式
- en: Flyweight
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 享元模式
- en: Proxy
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理模式
- en: '**Behavioral**: It is made up of the following patterns:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为模式**：它由以下模式组成：'
- en: Chain of Responsibility
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链模式
- en: Command
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式
- en: Interpreter
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器模式
- en: Iterator
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器模式
- en: Mediator
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中介者模式
- en: Memento
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型模式
- en: Observer
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式
- en: State
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态模式
- en: Strategy
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式
- en: Template method
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法
- en: Visitor
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者模式
- en: 'Obviously, all these patterns are a lot to be covered in this chapter, even
    in a superficial way, but we''re going to focus on the most frequently used ones
    and explain their advantages and programming in C#:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，所有这些模式都在本章中有很多内容要介绍，即使是以浅显的方式，但我们将重点关注最常用的模式，并解释它们的优点和C#编程：
- en: '![Design patterns](img/image00639.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![设计模式](img/image00639.jpeg)'
- en: 'The .NET framework itself contains, among others, these patterns: Singleton,
    Strategy, Factory, Builder, Decorator, and several other patterns in different
    namespaces.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: .NET框架本身包含，包括其他模式：单例、策略、工厂、构建器、装饰者以及在不同命名空间中的其他几个模式。
- en: There are numerous statistic reports on the Internet about the GoF pattern's
    usage. Obviously, it's not a question of using this or that pattern because of
    general acceptance. On the contrary, the reasons to use them are based on the
    benefits these patterns offer in order to improve the quality of an application.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有许多关于GoF模式使用的统计报告。显然，这并不是因为普遍接受而使用这个或那个模式的问题。相反，使用它们的理由是基于这些模式提供的利益，以改善应用程序的质量。
- en: 'That said, I''ll just review some of them to give you an idea about their possibilities
    of solving specific problems. However, an agreement seems to exist when placing
    the following eight patterns among the most used:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我将简要回顾其中的一些，以便给你一个关于它们解决特定问题可能性的概念。然而，似乎存在一种共识，即以下八种模式是最常用的：
- en: '**Construction**: Singleton and Factory'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建模式**：单例和工厂模式'
- en: '**Structural**: Adapter, Decorator, and Façade'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构型模式**：适配器、装饰者和门面模式'
- en: '**Behavioral**: Command, Observer, and Strategy'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为模式**：命令、观察者和策略'
- en: Note that some patterns, such as Iterator, are not included here just because
    they're already present in the vast majority of the collection's libraries (such
    as in the `System.Collections` and `System.Collections.Generic` namespaces in
    .NET). Another typical case is Abstract Factory, which is widely used in ADO.NET.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些模式，如迭代器，没有包括在这里，只是因为它们已经在大多数集合库中存在（例如在.NET中的`System.Collections`和`System.Collections.Generic`命名空间中）。另一个典型的情况是抽象工厂，它在ADO.NET中广泛使用。
- en: 'Let''s start with the most common (and reviled) of them all: Singleton.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最常见（也是最被诟病的）模式开始：单例。
- en: Singleton
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例
- en: The Singleton pattern prevents the creation of more than one instance of a class.
    It's the most popular pattern because its implementation is required in a great
    variety of situations and many different languages (also in non-compiled languages,
    such as JavaScript).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式防止创建一个类的多个实例。它是最受欢迎的模式，因为它的实现需要在各种情况下，以及许多不同的语言中（包括非编译语言，如JavaScript）。
- en: At the same time, it's one of the most reviled because of general abuse of the
    pattern in many situations in which other patterns would be preferred or even
    no pattern is required at all (not to mention the difficulties that sometimes
    arise when including it in unit tests).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，它也是因为模式在许多情况下被滥用而受到普遍诟病，在这些情况下，其他模式可能更受欢迎，甚至根本不需要模式（更不用说在单元测试中包含它时有时出现的困难）。
- en: 'The way it should be coded requires the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 应该如何编码需要以下要求：
- en: The class should be responsible for creating the unique instance
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类应该负责创建唯一实例
- en: The unique instance has to be accessible through a method in the class
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一实例必须通过类中的方法访问
- en: The constructor should be private in order to avoid direct instantiation
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数应该是私有的，以避免直接实例化
- en: 'To apply this pattern in our sample, we can imagine a new requisite: for instance,
    imagine that the user interface requires that either from the current main window
    or from other future windows, some user information showing the name of the user
    and the date/time at which the car is selected is available.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的示例中应用此模式，我们可以想象一个新的需求：例如，想象用户界面要求从当前主窗口或其他未来的窗口中，提供一些用户信息，显示用户姓名和选择汽车时的日期/时间。
- en: 'The shape of the new class should reflect the pattern and the values required:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 新类的外形应该反映模式和所需值：
- en: '[PRE26]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Observe that this class is only for reading purposes, with no meaningful functionality.
    However, having it instantiated in this manner, no possible duplication is possible.
    There will always be a unique set of user information.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个类仅用于阅读目的，没有有意义的功能。然而，以这种方式实例化，不可能出现任何重复。将始终存在一组唯一的用户信息。
- en: The class' instance is stored in the private static `instance` variable, and
    the constructor is private in order to avoid external instantiation. Actually,
    all members except the `Instance` property are private.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 类的实例存储在私有的静态`instance`变量中，构造函数是私有的，以避免外部实例化。实际上，除了`Instance`属性之外的所有成员都是私有的。
- en: The other aspect of the class that you might wonder about is the `Lazy<UserInfoSingleton>`
    type of the `instance` member, which guarantees that the instance is thread-safe
    since it won't really be instantiated until it is used by a client of the class.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会对课程中的另一个方面感到好奇，那就是`instance`成员的`Lazy<UserInfoSingleton>`类型，这保证了实例是线程安全的，因为它实际上只有在被类的客户端使用时才会被实例化。
- en: The Factory pattern
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂模式
- en: Wikipedia's definition of the Factory pattern states that, *a Factory is actually
    a creator of objects which have a common interface, without exposing the instantiation
    logic*.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科对工厂模式的定义是，*工厂实际上是一个创建具有公共接口的对象的创建者，而不暴露实例化逻辑*。
- en: Actually, this is what we did in the last modification in our sample, when we
    detached the instantiation into a `CarFactory` class.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这就是我们在上次修改示例中所做的，当时我们将实例化分离到了`CarFactory`类中。
- en: 'With these changes, we divided the structure of the resulting objects into
    two parts:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，我们将结果对象的结构分为两部分：
- en: The `CarFactory` class decides the state structure of the resulting object depending
    on the brand field (remember that the state of a class is defined by the set of
    values that its properties hold in a given instant of its execution).
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CarFactory`类根据品牌字段决定结果对象的状态结构（记住，一个类在执行过程中的状态是由其属性在给定时刻所持有的值的集合定义的）。'
- en: '`SportsCar` and `SportsCarWithN` are implementations of a behavior. Each one
    implements distinct behaviors with respect to the instant `Speed` value, and both
    share the same state structure (same field names and types).'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SportsCar`和`SportsCarWithN`是行为的实现。每个都针对`Speed`值的实例实现了不同的行为，并且它们共享相同的状态结构（相同的字段名称和类型）。'
- en: In our sample, there is a dependency between the fields, since `MaxSpeed` and
    `Photo` directly depend on `Brand`, so they should be resolved at construction
    time. Generally speaking, when there aren't any dependencies of this type, the
    structure can be more flexible.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，字段之间存在依赖关系，因为`MaxSpeed`和`Photo`直接依赖于`Brand`，因此它们应该在构造时解决。一般来说，当没有这种类型的依赖时，结构可以更加灵活。
- en: The Adapter pattern
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器模式
- en: The Adapter pattern is one of the most versatile, and it's intended to allow
    two components that were not originally designed to work together in order to
    integrate them in the cleanest way possible.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式是最灵活的之一，它的目的是允许将两个最初未设计为一起工作的组件以最干净的方式集成。
- en: It is, therefore, especially suitable when we have to deal with legacy code,
    in which it is quite difficult, if not impossible, to modify fragments of the
    code, but we have the requirement to include new functionality.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它特别适合我们在必须处理遗留代码时，在这种情况下，修改代码片段相当困难，如果不是不可能的，但我们有包含新功能的要求。
- en: 'The following schema shows the most common way to visually prototype the indirect
    path that the Adapter pattern implements in order to achieve this goal:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了实现此目标时，适配器模式所实现的间接路径的常见视觉原型化方式：
- en: '![The Adapter pattern](img/image00640.jpeg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![适配器模式](img/image00640.jpeg)'
- en: As you can see in the schema, there is a client that uses a certain interface.
    When the original class needs to change or extend some behavior with minimal or
    no changes, Adapter is one of the most accepted solutions.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图示中看到的，有一个客户端使用某个接口。当原始类需要以最小或没有更改的方式更改或扩展某些行为时，适配器是最受欢迎的解决方案之一。
- en: 'Imagine that we have a class that lists all car brands and that we cannot modify,
    with the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们有一个列出所有汽车品牌的类，我们无法修改，以下是其代码：
- en: '[PRE27]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'On the other hand, a new class has to be used in order to get the list of the
    cars still calling to the same `adapter.GetCars()` function. This class, named
    `ListOfCarsProvider`, holds a method called `GetListOfCars`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，为了获取仍然调用相同 `adapter.GetCars()` 函数的汽车列表，必须使用一个新的类。这个类名为 `ListOfCarsProvider`，它包含一个名为
    `GetListOfCars` 的方法：
- en: '[PRE28]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can define a simple interface (`ITarget`), which defines the same method
    signature that the final class requires:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个简单的接口 (`ITarget`)，它定义了最终类所需的方法签名：
- en: '[PRE29]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The next step is to make `VendorAdapter` implement `ITarget`. The trick is
    that we make the implementation of `GetCars()` call the new list of cars in `ListOfCarsProvider`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是让 `VendorAdapter` 实现 `ITarget`。技巧在于我们让 `GetCars()` 的实现调用 `ListOfCarsProvider`
    中的新汽车列表：
- en: '[PRE30]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, we preserve the functionality of the base class but allow a
    new way to obtain the list of available cars. We provide a level of indirection
    with minimal changes.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们保留了基类的功能，但允许以新的方式获取可用汽车的列表。我们通过最小的更改提供了一种间接级别。
- en: 'Of course, the list is obtained at runtime, as expected:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，列表是在运行时获得的，正如预期的那样：
- en: '![The Adapter pattern](img/image00641.jpeg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![适配器模式](img/image00641.jpeg)'
- en: The Façade pattern
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外观模式
- en: Another useful (and quite used) pattern in many circumstances is the Façade
    pattern. It's quite simple, and its main purpose is to unify processes dispersed
    in distinct functions of a library, giving access to them through a more simple,
    concrete set of methods.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，外观模式也是一个有用（并且相当常用）的模式。它相当简单，其主要目的是统一分散在库中不同函数中的过程，通过更简单、更具体的方法集来访问它们。
- en: 'Wikipedia collects some typical usages of this pattern, for example, when you
    want to do the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科收集了一些这个模式的典型用法，例如，当你想要做以下事情时：
- en: Make an external library easier to use
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使外部库更容易使用
- en: Give access to a library in a more readable way or with a more organized structure
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以更易读或更有组织的方式访问库
- en: Reduce the dependencies found in the management of an outside library
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少在外部库管理中发现的依赖关系
- en: 'The graphic schema that represents this structure is usually represented in
    this manner:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 表示这种结构的图形方案通常以这种方式表示：
- en: '![The Façade pattern](img/image00642.jpeg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![外观模式](img/image00642.jpeg)'
- en: This means that the façade its just another layer between a set of classes that
    can either be saved inside a larger library or disaggregated along distinct files.
    In any case, the pattern allows the unification of that functionality included
    in the assemblies.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着外观模式只是位于一组类之间的一层，这些类可以保存在一个更大的库中，或者沿着不同的文件分解。在任何情况下，该模式都允许统一包含在程序集中的功能。
- en: No interface implementation is required since it's only a matter of calling
    the required methods, thus providing the business logic. You'll find the source
    code corresponding to the preceding schema in the demo called `PatternFacade`.
    The runtime doesn't have much interest in this since you can easily deduct how
    it works.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只需调用所需的方法，因此不需要接口实现，从而提供业务逻辑。你将在名为 `PatternFacade` 的演示中找到对应于前面方案的源代码。运行时对此不感兴趣，因为你很容易推断出它是如何工作的。
- en: The Decorator pattern
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰者模式
- en: The Decorator pattern is frequently used when you need to add a functionality
    to a procedure (often obtaining extra data to accompany the standard implementation)
    but you have to keep the current behavior as it is and only add the new functionality
    for certain scenarios.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者模式在需要向过程添加功能（通常是获取伴随标准实现的额外数据）时经常被使用，但你必须保持当前的行为不变，并且只为某些场景添加新功能。
- en: If you think about it, this pattern enforces the application of the Open/Closed
    principle. The main code remains intact, but the pattern allows the functionality
    to grow in a controlled manner.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这么想，这个模式强制执行了开放/封闭原则。主要代码保持不变，但该模式允许功能以受控的方式增长。
- en: 'The situation is similar to the first implementation of our `SportsClassWithN`
    type of cars in our sample. The current functionality of the main class (`SportsCar`)
    is not to be changed. But some extra requirements would be needed in case the
    brand were a Mercedes (and later on, for the Ford brand as well). In this case,
    the new class inherited from the base class and added some behavior:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况与我们在示例中对 `SportsClassWithN` 类型的汽车的第一种实现相似。当前主类 (`SportsCar`) 的功能不应改变。但如果品牌是奔驰（稍后，对于福特品牌也是如此），则需要一些额外的要求。在这种情况下，从基类继承的新类添加了一些行为：
- en: '![The Decorator pattern](img/image00643.jpeg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![装饰者模式](img/image00643.jpeg)'
- en: Finally, the user interface decides which class is to be implemented at runtime,
    and in the case of the exception, it instructs the event handler to manage that
    exception.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，用户界面决定在运行时实现哪个类，并在异常的情况下，指导事件处理器来处理该异常。
- en: The pattern admits (like most of them) slight variations in the way you implement
    it.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式允许（像大多数模式一样）在实现方式上略有变化。
- en: The Command pattern
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令模式
- en: 'The Command pattern is one of the most used patterns in the behavioral category.
    GoF authors define the pattern in this way: *encapsulate a request as an object,
    thereby letting you parameterize clients with different requests, queue or log
    requests, and support undoable operations*.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式是行为类别中最常用的模式之一。GoF 作者这样定义该模式：*将请求封装为一个对象，从而允许你用不同的请求参数化客户端，排队或记录请求，并支持可撤销操作*。
- en: As always, a level of indirection is provided. Instead of immediately executing
    a call, we are allowed to queue it, which has many advantages in a bunch of scenarios,
    especially now, when more and more implementations require asynchronous processing.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，提供了一定程度的间接性。我们不是立即执行调用，而是允许将其排队，这在许多场景中都有很多优点，尤其是在现在，越来越多的实现需要异步处理。
- en: The key part of this pattern is that it decouples the object that invokes an
    operation from the one that has the knowledge to perform it.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式的关键部分是它将调用操作的对象与知道如何执行它的对象解耦。
- en: 'A typical example that GoF authors state as canonical is about the menu''s
    implementation in a classic user interface: in this case, you can implement several
    user interface artifacts to perform the same action (such as `MenuItem` and a
    toolbar''s button) by having both of them perform the same action, that is, making
    both implement the same concrete `Command` subclass.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: GoF 作者提出的典型示例是关于经典用户界面中菜单实现的规范：在这种情况下，你可以通过让它们执行相同的行为（例如 `MenuItem` 和工具栏的按钮）来实现多个用户界面元素以执行相同操作，也就是说，让它们都实现相同的具体
    `Command` 子类。
- en: An example already implemented in .NET
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET 中已实现的示例
- en: 'Again, we can find the Command pattern implemented in a variety of places within
    .NET Framework. Perhaps one of the most evident patterns is something as simple
    as the procedure to close a window: you can do it in four different ways:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们可以在 .NET Framework 的多个地方找到命令模式的实现。也许最明显的模式之一就是关闭窗口的简单过程：你可以用四种不同的方式来完成它：
- en: By clicking on the icon window to close it
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过点击图标窗口来关闭它
- en: Using the window menu (not the user menu) and selecting **Close**
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用窗口菜单（而非用户菜单）并选择**关闭**
- en: By pressing *Ctrl* + *F4*
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过按 *Ctrl* + *F4*
- en: By calling `this.close()` in some of the window's code
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在窗口的一些代码中调用 `this.close()`
- en: All of the preceding ways provoke a command invocation, sending a `WM_CLOSE`
    message to the window.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述方法都会引发命令调用，向窗口发送一个 `WM_CLOSE` 消息。
- en: Note
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can check the whole list of window messages that a window can handle at
    the dedicated site, Platform Invoke ([http://www.pinvoke.net/](http://www.pinvoke.net/)).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在专门的网站 Platform Invoke ([http://www.pinvoke.net/](http://www.pinvoke.net/))
    上查看窗口可以处理的整个消息列表。
- en: Invoking `this.close()` in a window is a command invocation itself. The .NET
    Framework also sends one of these messages to be managed by the message's dispatcher
    window function.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口中调用 `this.close()` 本身就是一个命令调用。.NET Framework 还会发送这些消息之一，由消息的分派窗口函数来管理。
- en: You can intervene in this call thanks to the implementation of the `Window.FormClosing`
    event, which carries information about the command to be executed and allows it
    to cancel it by assigning the value of the `e.Cancel` property (`EventArgs`)to
    `true`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过实现 `Window.FormClosing` 事件来干预这个调用，该事件携带有关要执行命令的信息，并允许通过将 `e.Cancel` 属性（`EventArgs`）的值设置为
    `true` 来取消它。
- en: Besides, you can find out the reason for this event to be launched, examining
    the `e.CloseReason` property that the `e` argument holds.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以通过检查 `e` 参数持有的 `e.CloseReason` 属性来找出引发此事件的原因。
- en: These two possibilities are available thanks to the implementation of the command
    pattern in the internal mechanism used to send `WM_CLOSE` messages to a window
    inside .NET Framework.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种可能性得益于在 .NET Framework 中用于向窗口内部发送 `WM_CLOSE` 消息的内部机制中实现的命令模式。
- en: Note
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We'll talk about the advanced aspects of .NET framework in the last chapter
    of this book, along with other techniques related to platform invocation.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的最后一章中讨论.NET框架的高级特性，以及与平台调用相关的其他技术。
- en: 'The following capture resumes this window-closing scenario in the user interface
    of our initial demos:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图总结了我们在初始演示的用户界面中关闭窗口的场景：
- en: '![An example already implemented in .NET](img/image00644.jpeg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![在.NET中已实现的示例](img/image00644.jpeg)'
- en: The Observer pattern
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者模式
- en: Again, we find another popular pattern that's widely implemented inside the
    .NET framework for distinct scenarios.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们发现另一个在.NET框架中广泛实现的流行模式，用于不同的场景。
- en: The MSDN documentation states that this pattern *enables a subscriber to register
    with and receive notifications from a provider. It is suitable for any scenario
    that requires push-based notification*.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: MSDN文档指出，这个模式*允许订阅者注册并从提供者接收通知。它适用于任何需要基于推送的通知的场景*。
- en: 'A typical case of this pattern is implemented in order to link data in a model
    with the user interface, which shows it in distinct controls: DataGridViews, TextBoxes,
    and so on. When the user performs an action that implies a modification in the
    data shown in the UI—such as an update, a deletion, or a modification—the desired
    behavior is that these controls are automatically informed of the changes and
    they can update them in the UI.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将模型中的数据与用户界面链接起来，并使用不同的控件（如DataGridViews、TextBoxes等）显示它，实现了这个模式的典型用例。当用户执行一个意味着在UI中修改显示数据的操作时——比如更新、删除或修改——期望的行为是这些控件自动被告知变化，并可以在UI中更新它们。
- en: 'This source suggests the steps to implement this pattern in .NET:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这个来源建议在.NET中实现这个模式的步骤：
- en: A provider needs to be in charge of sending notifications to the observer. It
    should be a class or a structure that implements the `IObservable<T>` interface,
    although its only requisite is implementing the `IObservable<T>.Subscribe` method.
    This is the one called by client observers that wish to receive notifications.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者需要负责向观察者发送通知。它应该是一个实现`IObservable<T>`接口的类或结构，尽管它的唯一要求是实现`IObservable<T>.Subscribe`方法。这是客户端观察者调用以接收通知的方法。
- en: 'An observer that is the object that receives notifications from the provider.
    In this case, the class should implement the `IObserver<T>` interface, but it''s
    required that it implement three methods that will be called by the provider:'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者是接收提供者通知的对象。在这种情况下，该类应该实现`IObserver<T>`接口，但它需要实现三个将由提供者调用的方法：
- en: '`IObserver<T>.OnNext`, which provides new or current information'
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IObserver<T>.OnNext`，它提供新的或当前的信息'
- en: '`IObserver<T>.OnError`, which is in charge of informing the observer about
    any error that has occurred'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IObserver<T>.OnError`，它负责通知观察者任何已发生的错误'
- en: '`IObserver<T>.OnCompleted`, which always marks the ending of notifications'
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IObserver<T>.OnCompleted`，它总是标记通知的结束'
- en: If you think about the scenario, we have the typical communication scheme between
    a sender and a receiver. So, we also need a channel to transmit the information.
    In this case, we need a mechanism that allows providers to keep track of observers.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您考虑这个场景，我们就有了一个发送者和接收者之间的典型通信方案。因此，我们还需要一个通道来传输信息。在这种情况下，我们需要一个机制，允许提供者跟踪观察者。
- en: Such mechanism in .NET is usually assigned to an instance of `System.Collections.Generics.List<T>`,
    which is in charge of holding references to the implementations of `IObserver<T>`.
    This is a convenient way to handle references to an unlimited number of observers.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在.NET中，这种机制通常分配给`System.Collections.Generics.List<T>`的一个实例，它负责持有`IObserver<T>`实现的引用。这是处理无限多个观察者引用的便捷方式。
- en: Usually, there is another object that stores data that the provider sends to
    its subscribed observers.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，还有一个对象存储提供者发送给其已订阅观察者的数据。
- en: 'In a real-case scenario, it might depend on the solution you''re building:
    Windows Presentation Foundation interfaces implement observable collections precisely
    with this purpose. Even other mechanisms that implement the MVC paradigm are capable
    of showing this behavior.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际场景中，这可能会取决于您构建的解决方案：Windows Presentation Foundation接口正是为了这个目的而实现了可观察集合。甚至其他实现MVC范式的机制也能够展示这种行为。
- en: A well-known case outside the OOP world is the AngularJS Framework, which makes
    every data in the model observable and linkable to the user interface, implementing
    a double binding architecture that makes any change in the model automatically
    reflect in the user interface, using a special markup (the *moustache* syntax).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程世界之外的一个著名案例是AngularJS框架，它使模型中的每个数据都变得可观察并可链接到用户界面，实现了一个双向绑定架构，使得模型中的任何变化都会自动反映在用户界面上，使用特殊的标记（*moustache*语法）。
- en: The Strategy pattern
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略模式
- en: The Strategy pattern is officially defined as *a practice of defining a family
    of algorithms, encapsulate each one, and make them interchangeable. Strategy lets
    the algorithm vary independently from clients that use it*.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式正式定义为*定义一组算法的实践，封装每个算法，并使它们可互换。策略允许算法独立于使用它的客户端变化*。
- en: 'Mainly, there are three participants:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有三个参与者：
- en: The `Strategy` (or compositor) component responsible for defining a common interface
    for all algorithms to be managed
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责为所有要管理的算法定义一个公共接口的`Strategy`（或组合器）组件
- en: '`ConcreteStrategy`, which implements the algorithm using the strategy interface'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteStrategy`，它使用策略接口实现算法'
- en: '`AContext`, which has three roles: it gets configured with the `ConcreteStrategy`
    object, maintains a reference to the `Strategy` object, and—optionally—it can
    define an interface to allow Strategy to access its data.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AContext`具有三个角色：它通过`ConcreteStrategy`对象进行配置，维护对`Strategy`对象的引用，并且可选地可以定义一个接口，允许策略访问其数据。'
- en: In code, a typical example might be when you have to use different sorting strategies
    (in any collection), but depending on other circumstances, you might like to choose
    which sorting algorithm you'd like to use, for instance, QuickSort, Shell, or
    Bubble.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，一个典型的例子可能是在任何集合中必须使用不同的排序策略时，但根据其他情况，你可能希望选择你想要使用的排序算法，例如快速排序、希尔排序或冒泡排序。
- en: You can define an object (`SortingClass`) with a method responsible for sorting,
    but depending on a value, the instance is created from another instance of the
    actual sorting method.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义一个具有负责排序的方法的对象（`SortingClass`），但根据一个值，实例是从另一个实际的排序方法实例创建的。
- en: 'The following code gives you an idea about how to use this pattern. The key
    is that `SortingClass` is called with distinct instances of the desired algorithm:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用这个模式。关键在于使用所需算法的不同实例调用`SortingClass`：
- en: '[PRE31]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With this approach, the user interface will always call the same method for
    sorting, whatever its name, but the actual sorting mechanism will be decided at
    runtime.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，用户界面将始终调用同一个排序方法，无论其名称如何，但实际的排序机制将在运行时决定。
- en: Other software patterns
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他软件模式
- en: 'As we mentioned, there is a total of 23 patterns linked to the original publication
    of the GoF group, but later on, other patterns belonging to the three main categories
    have appeared. Even a new category was defined: Concurrency patterns.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，总共有23个模式与GoF小组的原始出版物相关联，但后来，属于三个主要类别的其他模式出现了。甚至定义了一个新的类别：并发模式。
- en: 'Among the three base categories, the additions are as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在三个基本类别中，增加的内容如下：
- en: '**Creational**: The following are the sub types of this category:'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建型**：以下是这个类别的子类型：'
- en: '**Multiton**: Focalizes the creation of classes through a single, global point
    and ensures that instances are only named instances.'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多例模式**：通过一个单一的全局点集中创建类，并确保实例仅是命名实例。'
- en: '**Object Pool**: Provides a cached system to avoid the expensive acquisition
    (or release) of resources. It does this by recycling any object that is not being
    used. Many specialists consider it a generalization of the connection pool and
    thread pool patterns.'
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象池**：提供一个缓存系统以避免昂贵的资源获取（或释放）。它是通过回收任何未使用的对象来做到这一点的。许多专家认为它是连接池和线程池模式的泛化。'
- en: '**Resource Acquisition is Initialization**: Wikipedia states that this *ensures
    that resources are properly released by tying them to the lifespan of suitable
    objects*.'
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源获取即初始化**：维基百科指出，这*确保了资源通过绑定到合适的对象的生命周期而被正确释放*。'
- en: '**Structural**: The following are the sub types of this category:'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构型**：以下是这个类别的子类型：'
- en: '**Extension object**: Allows the addition of a functionality to a given hierarchy
    without changing it.'
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展对象**：允许在不更改给定层次结构的情况下向其添加功能。'
- en: '**Front controller**: This one has to do with web application design. It''s
    a way to unify entry points to handle requests in a single node.'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端控制器**：这与Web应用程序设计有关。这是一种将入口点统一到单个节点以处理请求的方法。'
- en: '**Marker**: This is an empty interface to provide a way to link metadata to
    a class.'
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标记**：这是一个空接口，用于提供将元数据链接到类的方式。'
- en: '**Module**: Wikipedia says that it''s *intended to group several related elements,
    such as classes, singletons, methods, globally used, into a single conceptual
    entity*.'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块**：维基百科表示，它**旨在将多个相关元素，如类、单例、方法、全局使用等，组合成一个单一的概念实体**。'
- en: '**Twin**: A dangerous one; according to some specialists, this provides the
    modeling of multiple inheritance for languages that don''t support this feature.'
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双胞胎**：一个危险的例子；据一些专家称，这为不支持此特性的语言提供了多重继承的建模。'
- en: '**Behavioral**: The following are the sub types of this category:'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为**：以下是该类别的子类型：'
- en: '**Blackboard**: This is a pattern for artificial intelligence systems that
    allow the merging of different data sources (refer to [https://en.wikipedia.org/wiki/Blackboard_system](https://en.wikipedia.org/wiki/Blackboard_system)).'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黑板**：这是一个用于人工智能系统的模式，允许合并不同的数据源（参考[https://en.wikipedia.org/wiki/Blackboard_system](https://en.wikipedia.org/wiki/Blackboard_system)）。'
- en: '**Null object**: This is intended to avoid null references by providing a default
    object. In C#, we''ve seen how it is implemented using different operators (such
    as Null Coalescence and Null-Conditional Operators, which we saw in the initial
    chapters).'
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空对象**：这是通过提供一个默认对象来避免空引用的。在C#中，我们已经看到了它是如何使用不同的运算符（如空合并运算符和空条件运算符，我们在第一章中看到）实现的。'
- en: '**Servant**: This defines common operations for a set of classes.'
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：这定义了一组类的常见操作。'
- en: '**Specification**: Recombines business logic in a Boolean fashion. There is
    abundant documentation of the implementation of this pattern in C# and how it
    has improved along with new versions of the language ([https://en.wikipedia.org/wiki/Specification_pattern](https://en.wikipedia.org/wiki/Specification_pattern)).'
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规范**：以布尔方式重新组合业务逻辑。有大量关于在C#中实现此模式及其随着语言新版本的改进的文档（[https://en.wikipedia.org/wiki/Specification_pattern](https://en.wikipedia.org/wiki/Specification_pattern)）。'
- en: '**Concurrency patterns**: These are specifically designed to deal with multithreading
    scenarios. The following table is inspired by the actual documentation of this
    subject available on Wikipedia:'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发模式**：这些模式是专门设计来处理多线程场景的。以下表格灵感来源于维基百科上关于此主题的实际文档：'
- en: '| Name | Description |'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Active object | Decouples method execution from the method invocation that
    resides in its own thread of control. The goal is to introduce concurrency using
    asynchronous method invocation and a scheduler to handle requests. |'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 活动对象 | 将方法执行与位于其自己的控制线程中的方法调用解耦。目标是使用异步方法调用和调度器来处理请求以引入并发。|'
- en: '| Balking | Only executes an action on an object when the object is in a particular
    state. |'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 拒绝 | 只有在对象处于特定状态时才在对象上执行操作。|'
- en: '| Binding properties | Combines multiple observers to force properties in different
    objects to be synchronized or coordinated in some way. |'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 绑定属性 | 结合多个观察者，以强制不同对象中的属性以某种方式同步或协调。|'
- en: '| Block chain | A decentralized way to store data and agree on the ways to
    process it in a Merkle tree, optionally using a digital signature for any individual
    contributions. |'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 区块链 | 一种去中心化的存储数据并同意在默克尔树中处理数据的方式，可选地使用数字签名对任何个人贡献进行签名。|'
- en: '| Double-checked locking | Reduces the overhead of acquiring a lock by first
    testing the locking criterion (the lock hint) in an unsafe manner; only if that
    succeeds does the actual locking logic proceed.Can be unsafe when implemented
    in some language/hardware combinations. It can, therefore, be considered an anti-pattern
    sometimes. |'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 双重检查锁定 | 通过首先以不安全的方式测试锁定标准（锁定提示）来减少获取锁的开销；只有在该测试成功后，实际的锁定逻辑才会进行。在某些语言/硬件组合中实现时可能不安全。因此，有时可以将其视为一种反模式。|'
- en: '| Event-based asynchronous | Addresses problems with the asynchronous pattern
    that occurs in multithreaded programs. |'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 基于事件的异步 | 解决多线程程序中出现的异步模式问题。|'
- en: '| Guarded suspension | Manages operations that require both a lock to be acquired
    and a precondition to be satisfied before the operation can be executed. |'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 保护挂起 | 管理在操作可以执行之前需要获取锁并满足预条件的操作。|'
- en: '| Join | Provides a way to write concurrent, parallel, and distributed programs
    by passing messages. Compared to the use of threads and locks, this is a high-level
    programming model. |'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| Join | 通过传递消息提供编写并发、并行和分布式程序的方法。与使用线程和锁相比，这是一个高级编程模型。 |'
- en: '| Lock | A thread puts a "lock" on a resource, preventing other threads from
    accessing or modifying it. |'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 锁 | 一个线程对资源施加“锁”，防止其他线程访问或修改它。 |'
- en: '| Messaging Design Pattern (MDP) | Allows the interchange of information (that
    is, messages) between components and applications. |'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 消息设计模式（MDP） | 允许组件和应用程序之间交换信息（即消息）。 |'
- en: '| Monitor object | An object whose methods are subject to mutual exclusion,
    thus preventing multiple objects from erroneously trying to use it at the same
    time. |'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 监视对象 | 指一个其方法受到互斥性约束的对象，从而防止多个对象同时错误地尝试使用它。 |'
- en: '| Reactor | Provides an asynchronous interface to resources that must be handled
    synchronously. |'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 反应器 | 为必须同步处理资源提供异步接口。 |'
- en: '| Read-write lock | Allows concurrent read access to an object, but requires
    exclusive access for write operations. |'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 读写锁 | 允许对对象进行并发读取访问，但写入操作需要独占访问。 |'
- en: '| Scheduler | Explicitly controls when threads may execute single-threaded
    code. |'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 调度器 | 明确控制线程何时可以执行单线程代码。 |'
- en: '| Thread pool | A number of threads are created to perform a number of tasks,
    which are usually organized in a queue. Typically, there are many more tasks than
    threads. Can be considered a special case of the object pool pattern. |'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 线程池 | 创建多个线程以执行多个任务，这些任务通常组织在一个队列中。通常，任务的数量要多于线程的数量。可以将其视为对象池模式的特殊情况。 |'
- en: '| Thread-specific storage | Static or "global" memory that is local to a thread.
    |'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 线程特定存储 | 静态或“全局”内存，它是线程本地的。 |'
- en: Also, remember that often, there's no need to explicitly implement a pattern
    when the framework you use already supports it (such as how it happens in the
    .NET Framework), and chances are that at the time of implementing a real solution,
    not one but several of these patterns might be required in order to code things
    properly.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，通常，当您使用的框架已经支持该模式时（例如在.NET框架中发生的情况），通常不需要显式实现一个模式，并且实施实际解决方案时，可能需要不止一个而是多个这些模式才能正确编码。
- en: Other patterns
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他模式
- en: At the beginning of this chapter, we said that there are many different patterns,
    guides, and sets of good practices published by different specialists, either
    from academic environments or from corporations.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们提到有许多不同的模式、指南和最佳实践集是由不同的专家发布的，无论是来自学术环境还是来自企业。
- en: 'They can be also applied to distinct programming contexts, and for different
    programming paradigms: the integration of applications, data management, user
    interfaces, application testing (unit or behavioral), and so on. They are usually
    called Domain Specific patterns.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以应用于不同的编程上下文，以及不同的编程范式：应用程序集成、数据管理、用户界面、应用程序测试（单元或行为测试），等等。它们通常被称为领域特定模式。
- en: In any case, as technology evolves, so do the patterns. New patterns appear,
    and some others become less used, just because the technology or architecture
    they apply to also falls into disuse.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，随着技术的演变，模式也在演变。新的模式出现，而一些其他模式的使用频率降低，这仅仅是因为它们所应用的技术或架构也变得不再使用。
- en: Some others, in turn, get revitalized as the technology grows, such as in the
    case of *Design and Implementation Guidelines for Web Clients*, which you can
    find at [https://msdn.microsoft.com/en-us/library/ff650462.aspx](https://msdn.microsoft.com/en-us/library/ff650462.aspx).
    However, if we consider other patterns very useful at the moment, such as Data
    patterns ([https://msdn.microsoft.com/en-us/library/ff648420.aspx](https://msdn.microsoft.com/en-us/library/ff648420.aspx)),
    chances are that you'll find them a little outdated just because it was published
    in 2003, and things have changed a lot since then, not to mention the appearance
    of other models and technologies, such as the Big Data revolution.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他模式，随着技术的发展而得到复兴，例如在“Web客户端的设计和实现指南”案例中，您可以在[https://msdn.microsoft.com/en-us/library/ff650462.aspx](https://msdn.microsoft.com/en-us/library/ff650462.aspx)找到。然而，如果我们认为其他模式在目前非常有用，例如数据模式([https://msdn.microsoft.com/en-us/library/ff648420.aspx](https://msdn.microsoft.com/en-us/library/ff648420.aspx))，那么您可能会发现它们有些过时，因为它们是在2003年发布的，而且从那时起变化了很多，更不用说大数据革命的出现和其他模型和技术了。
- en: So, keep in mind the big principles first, and when you have to apply any of
    them for the sake of your application, take a look at the available patterns (classic
    or new) because they might offer you a trusted, proved solution.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先记住大的原则，当你必须为了你的应用程序应用其中任何一个时，查看可用的模式（经典或新的），因为它们可能为你提供一个可信的、经过验证的解决方案。
- en: Summary
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through software guides and patterns. We started with
    the SOLID principles proposed by Robert Martin a few years ago, which are now
    gaining momentum among the programmers community, and we can see them implemented
    in the vast majority of frameworks in use today.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了软件指南和模式。我们从几年前罗伯特·马丁提出的SOLID原则开始，这些原则现在在程序员社区中越来越受欢迎，并且我们可以看到它们在当今使用的绝大多数框架中得到了实现。
- en: We used a simple application, and as the requirements evolved, we applied different
    principles or patterns to solve the problems.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个简单的应用程序，随着需求的演变，我们应用了不同的原则或模式来解决这些问题。
- en: Finally, we studied the eight most used GoF patterns (according to the statistics),
    revising their definitions and purposes in order to finish with the current list
    of available patterns created and published after the GoF group published their
    book.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了最常用的八个GoF模式（根据统计数据），修订了它们的定义和目的，以便以当前可用的模式列表结束，这些模式是在GoF小组发布他们的书籍之后创建和发布的。
- en: In the next chapter, we'll deal with security issues, including the new proposals
    widely adopted in the industry, such as the **OAuth** (**Open Authorization**)
    protocol.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理安全问题，包括在业界广泛采用的新的提议，例如**OAuth**（**开放授权**）协议。
