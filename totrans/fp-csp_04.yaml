- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Honest Functions, Null, and Option
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 诚实函数、`null` 和 `Option`
- en: 'In this chapter, we discuss the art and science of honest functions, the intricacies
    of null, and the C# tools tailored to address them. But before we dive deep, let’s
    lay out the roadmap:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论诚实函数的艺术和科学、`null` 的复杂性以及针对它们定制的 C# 工具。但在我们深入探讨之前，让我们制定路线图：
- en: Understanding honest functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解诚实函数
- en: The problems with hidden nulls
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏的 `null` 的问题
- en: Embracing honesty with nullable reference types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥抱可空引用类型的诚实
- en: 'Beyond null: Option'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了 `null`：`Option`
- en: Real-world scenarios
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现实场景
- en: As you navigate through this chapter, be on the lookout for practical advice
    and evidence-backed guidelines. Come with a curious mind, and by the end, you’ll
    possess the know-how to write more transparent and resilient C# code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在你浏览这一章的过程中，要寻找实用的建议和有证据支持的指南。带着好奇心来，到结束时，你将掌握编写更透明和健壮的 C# 代码的知识。
- en: Just as we did in our previous chapters, let’s assess where you stand. Here,
    there are three tasks for you. If you’re unsure about tackling them, dive into
    this chapter right away. But, if you feel confident in your skills, perhaps you
    might skim through and jump to the sections that challenge you the most. Ready?
    Let’s go!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在前面的章节中所做的那样，让我们评估你的位置。这里有三个任务供你完成。如果你不确定如何应对它们，立即进入这一章。但是，如果你对自己的技能有信心，也许你可以快速浏览并跳到最具挑战性的部分。准备好了吗？让我们开始吧！
- en: Task 1 – Refactor for honest return types
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 1 – 重新设计诚实返回类型
- en: 'Here’s a function in Steve’s tower defense game that retrieves a tower based
    on its ID. Refactor it to return an honest type indicating potential nullability:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个史蒂夫的塔防游戏中的函数，根据其 ID 获取一个塔。将其重构为返回一个表示潜在空值的诚实类型：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Task 2 – Guard against null inputs
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 2 – 防止空输入
- en: 'Refactor the following function to guard against null inputs using preconditions
    and throw appropriate exceptions if the precondition isn’t met:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下函数重构为使用预条件来防止空输入，并在预条件未满足时抛出适当的异常：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Task 3 – Pattern matching with nullable types
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 3 – 使用可空类型进行模式匹配
- en: 'Given the following classes, write a method that receives an enemy and returns
    a string with its description using pattern matching:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下类，编写一个方法，接收一个敌人并使用模式匹配返回其描述字符串：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Again, if you are sure you know the right answers to all three tasks, you can
    skip this chapter. Of course, you can always come back if you have any questions.
    Now let’s discuss honest functions and their benefits.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果你确信你知道所有三个任务的正确答案，你可以跳过这一章。当然，如果你有任何问题，随时可以回来。现在让我们来讨论诚实函数及其好处。
- en: Honest functions – definition and understanding
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 诚实函数 – 定义和理解
- en: A few days after his conversation with Julia about pure functions and side effects,
    Steve was eager to learn more. He called Julia to ask what he should study next.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在与朱莉娅关于纯函数和副作用交谈几天后，史蒂夫渴望了解更多。他打电话给朱莉娅询问他接下来应该学习什么。
- en: 'Julia: *Let’s talk about honest functions,* `null`*, and* `Option` *types,’
    she suggested. ‘These concepts are crucial for writing clear,* *predictable code.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*让我们来谈谈诚实函数、`null` 和 `Option` 类型，*她建议。“这些概念对于编写清晰、可预测的代码至关重要。”
- en: 'Steve: *Sounds great! But what exactly are* *honest functions?*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：*听起来很棒！但* *诚实函数* *究竟是什么？*
- en: 'Julia: *An honest function provides a clear, unambiguous contract between the
    function and its callers, resulting in code that’s more robust, less prone to
    bugs, and easier to* *reason about.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*一个诚实函数在函数与其调用者之间提供了一个清晰、明确的契约，从而使得代码更加健壮，更不容易出错，并且更容易* *推理* *。”
- en: So what exactly is an honest function?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么一个诚实函数究竟是什么呢？
- en: In the simplest terms, an honest function is one where its type signature fully
    and accurately describes its behavior. If a function claims that it will take
    an integer and return another integer, then that’s precisely what it will do.
    There are no hidden gotchas, no exceptions thrown out of the blue, and no subtle
    changes to global or static state that aren’t reflected in the function’s signature.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，一个诚实函数是指其类型签名完全且准确地描述了其行为。如果一个函数声称它将接受一个整数并返回另一个整数，那么它就会做到这一点。没有任何隐藏的陷阱，没有突然抛出的异常，也没有未在函数签名中反映的全局或静态状态的变化。
- en: 'Consider the following C# function:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 C# 函数：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At first glance, this function seems to fulfill its promise. It takes two integers
    and returns their quotient. However, what happens when we pass zero as the denominator?
    `DivideByZeroException` is thrown. The function was not entirely honest with us;
    its signature did not warn us about this potential pitfall. An honest version
    of this function would explicitly signal the potential for failure in its signature.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，这个函数似乎履行了其承诺。它接受两个整数并返回它们的商。然而，当我们传递零作为分母时会发生什么？会抛出`DivideByZeroException`。这个函数并没有完全对我们诚实；其签名没有警告我们这个潜在的风险。这个函数的诚实版本会在其签名中明确指出失败的可能性。
- en: So, how does this concept of honesty tie into the broader context of functional
    programming and the software development industry? In functional programming,
    functions are the building blocks of your code. The more clearly and honestly
    these functions describe their behavior, the easier it is to build larger, more
    complex programs. Each function serves as a reliable component that behaves just
    as its signature describes, allowing developers to confidently compose and reuse
    these functions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这种诚实概念如何与函数式编程和软件开发行业的更广泛背景相结合呢？在函数式编程中，函数是代码的构建块。这些函数描述其行为越清晰、越诚实，构建更大、更复杂的程序就越容易。每个函数都作为一个可靠的组件存在，其行为正如其签名所描述的那样，允许开发者自信地组合和重用这些函数。
- en: As Julia explained honest functions, Steve’s eyes lit up with understanding.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当朱莉娅解释诚实函数时，史蒂夫的眼睛因理解而亮了起来。
- en: 'Steve: *So it’s like when I tell my teammates I’ll deliver a feature by Friday,
    I should actually* *do it?*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：*所以，就像我告诉我的队友我会在周五交付一个功能一样，我应该* *真正地做到这一点吗*？
- en: 'Julia: *Exactly! In programming, our functions should be just* *as reliable.*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*没错！在编程中，我们的函数应该* *同样可靠*。
- en: 'Now, let’s dive deeper into the benefits of using honest functions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨使用诚实函数的好处：
- en: '**Improved readability**: Honest functions make the code more straightforward
    to read and understand. There’s no need to dive into the implementation to grasp
    what the function is doing. The function’s signature is a contract that accurately
    describes its behavior.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高可读性**：诚实函数使代码更易于阅读和理解。无需深入研究实现细节即可了解函数的功能。函数的签名是一个合同，准确描述了其行为。'
- en: '**Enhanced predictability**: With honest functions, surprises are drastically
    minimized. The function’s behavior is precisely what is described in the signature,
    leading to fewer unexpected bugs and exceptions at runtime.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强可预测性**：使用诚实函数，意外情况大大减少。函数的行为正是签名中描述的那样，导致运行时出现更少的意外错误和异常。'
- en: '**Increased reliability**: By minimizing surprises and explicitly handling
    potential error scenarios, honest functions result in a more robust code base
    that can withstand the rigors of real-world usage.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高可靠性**：通过最小化意外情况并明确处理潜在的错误场景，诚实函数导致代码库更加健壮，能够承受现实世界使用的严酷考验。'
- en: Consider a code base where every function is honest. Any developer, familiar
    or not with the code, could look at a function signature and know immediately
    what it does, what it needs, and what it might return, including any potential
    error conditions. It’s like having a well-documented code base without the need
    for verbose documentation. That’s the power and promise of honest functions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个每个函数都是诚实的代码库。任何开发者，无论是否熟悉代码，都可以查看函数签名并立即了解其功能、所需条件和可能返回的内容，包括任何潜在的错误条件。这就像拥有一个文档齐全的代码库，而不需要冗长的文档。这就是诚实函数的力量和承诺。
- en: In the following sections, we’ll explore how to implement honest functions in
    C# and how to deal with potential dishonesty, such as nulls or exceptions. Fasten
    your seatbelts, because our journey into the world of honest and dishonest functions
    is just beginning!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨如何在C#中实现诚实函数以及如何处理潜在的欺骗行为，例如空值或异常。系好安全带，因为我们对诚实与不诚实函数世界的探索才刚刚开始！
- en: The problems with hidden nulls
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏空值的弊端
- en: Steve recalled a recent bug in his tower defense game.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫回忆起他最近在塔防游戏中的一个错误。
- en: 'Steve: *I think I’ve run into this problem. My game crashed when trying to
    upgrade a tower that* *didn’t exist.*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：*我想我遇到过这个问题。当我尝试升级一个* *不存在的塔* *时，我的游戏崩溃了*。
- en: 'Julia: *That’s a classic example, let’s look at how we can prevent that using
    what we’re* *learning today.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*这是一个典型的例子，让我们看看我们今天所学的内容如何防止这种情况发生*。
- en: Have you ever felt confused trying to figure out why your program stopped working?
    Most times, the problem comes from a well-known `NullReferenceException`. This
    section looks at the tricky connection between C# and null, pointing out the problems
    many developers face.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经感到困惑，试图弄清楚为什么你的程序停止工作？大多数时候，问题来自众所周知的 `NullReferenceException`。本节探讨了 C#
    和空值之间复杂的关系，指出了许多开发者面临的问题。
- en: A quick look back – C# and null
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速回顾一下——C# 和空值
- en: To understand our current problem, let’s look back a bit. Tony Hoare, an important
    computer expert, called the null reference a “huge mistake.” The idea was to provide
    developers with a tool to show when a value was missing. At first, it seemed like
    a good plan, but it ended up causing many problems and mistakes in languages –
    C# included.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解我们当前的问题，让我们回顾一下。Tony Hoare，一位重要的计算机专家，称空引用为“一个巨大的错误”。这个想法是为开发者提供一个工具来显示值缺失的情况。起初，这似乎是一个好计划，但最终它导致了许多问题和错误，包括
    C# 语言。
- en: When C# was introduced, it used this idea from older programming methods, letting
    developers use null to show something was missing. But over time, this simple
    choice caused a lot of errors and mix-ups.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当 C# 被引入时，它采用了来自较老编程方法的一个想法，允许开发者使用空值来表示某物缺失。但随着时间的推移，这个简单的选择导致了大量的错误和混淆。
- en: Common mistakes and the troubling NullReferenceException
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见错误和令人烦恼的 NullReferenceException
- en: All C# developers, whether new or experienced, have come across `NullReferenceException`.
    This error happens when you try to use something that isn’t there.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 C# 开发者，无论是新手还是经验丰富的，都遇到过 `NullReferenceException`。当你尝试使用不存在的东西时，这个错误会发生。
- en: 'Think about a program that gets user information. You might expect to always
    find a user:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个获取用户信息的程序。你可能会期望总能找到用户：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Oops! If `FindUserById` can’t find a user, the second line will give `NullReferenceException`,
    which, if not caught, will terminate the whole execution of the thread. This mistake
    happens because we thought a user would always be there. This shows how hidden
    nulls can cause unexpected problems in our code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！如果 `FindUserById` 无法找到用户，第二行将抛出 `NullReferenceException`，如果不捕获它，将会终止整个线程的执行。这个错误发生是因为我们以为用户总是会存在的。这显示了隐藏的空值如何在我们的代码中引起意外的问题。
- en: Many programs are much bigger than this example, which makes these kinds of
    mistakes hard to find and fix. These hidden problems can stay hidden for a long
    time, causing errors when you least expect them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序比这个例子大得多，这使得这些错误难以找到和修复。这些隐藏的问题可能长时间隐藏，在你最不期望的时候引发错误。
- en: Hidden nulls can be thought of as unseen traps. They can catch out both new
    and experienced programmers. Plus, they go against the main idea of functional
    programming, which values clear and expected outcomes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏的空值可以被视为看不见的陷阱。它们可以捕捉到新手和经验丰富的程序员。此外，它们与函数式编程的主要理念相悖，函数式编程重视清晰和预期的结果。
- en: Not all bad – the value of null
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并非全是坏事——空值的价值
- en: It’s easy to blame null for these problems. But the real issue is how it’s used.
    Null can be helpful if used in a clear way to show something is missing. The problem
    comes when its use is unclear, leading to many potential errors.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 容易把问题归咎于空值。但真正的问题是它的使用方式。如果使用清晰的方式来表示某物缺失，空值是有帮助的。问题在于其使用不明确，导致许多潜在的错误。
- en: The journey of C# with null has had its ups and downs. But, as we’ll learn in
    the next sections, C# now has multiple ways to handle null, making our code clearer
    and more straightforward. And one of these ways is to use nullable reference types.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: C# 与空值的旅程有起有落。但，正如我们将在下一节中学习的，C# 现在有多种处理空值的方法，使我们的代码更清晰、更直接。其中一种方法就是使用可空引用类型。
- en: Embracing honesty with nullable reference types
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用可空引用类型拥抱诚实
- en: Handling null in C# has always been quite a challenge. Many software developers
    (me included) advocate doing a check for `NullReferenceException`s as a mandatory
    task in a code review checklist. In most cases, it is really easy to check for
    possible null values just by looking at the pull request, even without an IDE.
    Recently, we received help when Microsoft introduced nullable reference types.
    So, now, the compiler will join us in the search of possible disasters caused
    by null.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中处理空值一直是一个很大的挑战。许多软件开发者（包括我）都主张在代码审查清单中检查 `NullReferenceException` 作为一项强制性任务。在大多数情况下，仅通过查看拉取请求就可以轻松检查可能的空值，即使没有
    IDE。最近，当微软引入了可空引用类型时，我们得到了帮助。因此，现在，编译器将加入我们寻找由空值引起的可能灾难的行列。
- en: What are nullable reference types?
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是可空引用类型？
- en: In the simplest terms, **Nullable Reference Types** (or **NRTs** for short)
    are a feature in C# that allows developers to clearly indicate whether a reference
    type can be null or not. With this, C# gives us a tool to make our intentions
    clear right from the start. Think of it as a signpost, guiding other developers
    (and even our future selves) about what to expect from our code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，**可空引用类型**（或简称**NRTs**）是C#中的一个特性，允许开发者明确地指出一个引用类型是否可以为空。有了这个特性，C#为我们提供了一个工具，从代码一开始就清楚地表达我们的意图。把它想象成一个路标，引导其他开发者（甚至是我们未来的自己）了解我们的代码应该期待什么。
- en: Without NRTs, every reference type in C# could potentially be `null`. This would
    create a guessing game. Is this variable going to have a value or is it going
    to be `null`? Now, with NRTs, we don’t have to guess anymore. The code itself
    tells the story.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 没有NRTs，C#中的每个引用类型都可能被赋值为 `null`。这会变成一个猜谜游戏。这个变量会具有值还是会被赋值为 `null`？现在，有了NRTs，我们不再需要猜测。代码本身就在讲述这个故事。
- en: 'Let’s look at a basic example to grasp the concept:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个基本示例来理解这个概念：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding snippet, the `notNullable` variable is a regular string that
    can’t be assigned `null` (if you try, the compiler will warn you). On the other
    hand, since C# 8.0, nullable is explicitly marked with `?`, indicating that it
    can be `null`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`notNullable` 变量是一个普通的字符串，不能被赋值为 `null`（如果你尝试这样做，编译器会发出警告）。另一方面，自从
    C# 8.0 开始，可空类型会明确地用 `?` 标记，表示它可以被赋值为 `null`。
- en: 'In some cases, you might want to assign `null` to a variable that is not marked
    as nullable. In this case, to suppress warnings, you can use the `!` sign to let
    the compiler know that you are aware of what you are doing and everything is going
    according to plan:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能想将 `null` 赋值给未标记为可空的变量。在这种情况下，为了抑制警告，你可以使用 `!` 符号来让编译器知道你已经意识到自己在做什么，并且一切都在计划中进行：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: One of the biggest advantages of NRTs is that the C# compiler will warn you
    if you’re potentially doing something risky with null values. It’s like having
    a friendly guide always looking over your shoulder, ensuring you don’t fall into
    the common traps of null misuse.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: NRTs（可空引用类型）最大的优点之一是，C# 编译器会警告你如果在使用可空值时可能正在执行有风险的操作。这就像有一个友好的向导始终在关注你的肩膀，确保你不会陷入常见的空值误用的陷阱。
- en: For instance, if you try to access properties or methods on a nullable reference
    without checking for `null`, the compiler will give you a heads-up.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你尝试在未检查 `null` 的情况下访问可空引用类型的属性或方法，编译器会提前警告你。
- en: Transitioning to NRTs
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转向NRTs
- en: 'For those with existing C# projects, you might be wondering: *Will my project
    be littered with warnings if I enable NRTs?* The answer is no. By default, NRTs
    are turned off. You can opt into this feature, file by file, allowing for a smooth
    transition.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些有现有C#项目的开发者来说，你可能想知道：*如果我启用NRTs，我的项目会被警告信息充斥吗？* 答案是否定的。默认情况下，NRTs是关闭的。你可以选择按文件启用此功能，以便平稳过渡。
- en: NRTs are a good answer to the long-standing challenge posed by null references.
    By making the potential presence of null explicit in our code, we take a giant
    leap toward clarity, safety, and functional honesty. In the end, embracing NRTs
    not only makes our code more resilient but also ensures that our intentions, as
    developers, are transparent.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: NRTs是解决长期存在的空引用挑战的好方法。通过在我们的代码中明确表示空值的存在，我们迈出了向清晰、安全和功能诚实的大步。最终，拥抱NRTs不仅使我们的代码更加健壮，而且确保了我们的意图，作为开发者，是透明的。
- en: Enabling nullable reference types
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用可空引用类型
- en: 'To enable NRTs, we need to tell the C# compiler that we’re ready for its guidance.
    This is done using a simple directive: `#``nullable enable`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用NRTs，我们需要告诉C#编译器我们已经准备好接受它的指导。这是通过一个简单的指令完成的：`#nullable enable`。
- en: 'Place this at the start of your `.``cs` file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `.cs` 文件开头放置以下内容：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: From this point onward in the file, the compiler creates a specific nullable
    context and assumes that all reference types are non-nullable by default. If you
    want a type to be nullable, you’ll have to mark it explicitly with `?`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件的这个点开始，编译器创建了一个特定的可空上下文，并假设所有引用类型默认为不可空。如果你想使一个类型为可空，你必须明确地用 `?` 标记它。
- en: With NRTs enabled, the C# compiler becomes your safety net, pointing out potential
    issues with nulls in your code. Whenever you try to assign null to a reference
    type without the `?` marker or when you attempt to access a potentially null variable
    without checking it, the compiler will warn you.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 启用NRTs后，C#编译器成为你的安全网，指出代码中潜在的空值问题。无论何时你尝试将 `null` 赋值给没有 `?` 标记的引用类型，或者尝试访问未检查的可空变量，编译器都会发出警告。
- en: 'Here’s an example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Disabling nullable reference types
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用可空引用类型
- en: 'While transitioning a project to use NRTs, there may be sections of your code
    where you’d prefer to delay the transition. You can turn off NRTs for those specific
    sections using the `#nullable` `disable` directive:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在将项目过渡到使用NRTs的过程中，你的代码中可能会有一些部分你希望延迟过渡。你可以使用`#nullable disable`指令关闭这些特定部分的NRTs：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This tells the compiler to revert to the old behavior, treating all reference
    types as potentially nullable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉编译器恢复到旧的行为，将所有引用类型视为可能为null。
- en: You might wonder why C# chose to use directives for this feature. The reason
    is flexibility. By using directives, developers can gradually introduce NRTs into
    their projects, one file or even one section of code at a time. This phased approach
    makes it easier to adapt existing projects.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么C#选择使用指令来实现这个特性。原因是灵活性。通过使用指令，开发者可以逐步将NRTs（非空引用类型）引入到他们的项目中，一次一个文件，甚至一次一个代码段。这种分阶段的方法使得适应现有项目变得更加容易。
- en: Warnings and annotations options
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 警告和注释选项
- en: 'Speaking of a phased approach, there are two more options to set our nullable
    contexts: `warnings` and `annotations`. You can use them by writing the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 说到分阶段的方法，还有两个选项可以设置我们的可空上下文：`warnings`和`annotations`。你可以通过编写以下内容来使用它们：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Or, you can write this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以这样写：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The main purpose of these options is to ease the migration of your existing
    code from a fully disabled null context to a fully enabled one. In short, we want
    to start with the `warnings` option in order to get dereference warnings. When
    all warnings are fixed, we can switch to `annotations`. This option will not give
    us any warnings, but it will start to treat our variables as non-nullable unless
    declared with the `?` mark.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项的主要目的是为了简化将现有代码从完全禁用的null上下文迁移到完全启用上下文的过程。简而言之，我们希望通过开启`warnings`选项来获取解引用警告。当所有警告都修复后，我们可以切换到`annotations`。这个选项不会给我们带来任何警告，但它将开始将我们的变量视为不可为null，除非用`?`标记声明。
- en: To get more information about these options and nullable context in generated
    files, and to find out more about three nullabilities – oblivious, nullable, and
    non-nullable, I recommend you read the article *Nullable reference types* ([https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references](https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references)).
    You might also want to read the article “Update a codebase with nullable reference
    types to improve null diagnostic warnings” ([https://learn.microsoft.com/en-us/dotnet/csharp/nullable-migration-strategies](https://learn.microsoft.com/en-us/dotnet/csharp/nullable-migration-strategies)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关这些选项和生成文件中null上下文的信息，以及了解更多关于三种nullability（不可知、可空和非空）的内容，我建议你阅读文章《可空引用类型》([https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references](https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references))。你可能还想阅读文章“使用可空引用类型更新代码库以改进null诊断警告”([https://learn.microsoft.com/en-us/dotnet/csharp/nullable-migration-strategies](https://learn.microsoft.com/en-us/dotnet/csharp/nullable-migration-strategies))。
- en: The bigger picture – project-wide settings
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更大的图景——项目级设置
- en: 'While directives are great for granular control, you can also enable NRTs for
    an entire project. In the project settings, or directly in the `.csproj` file,
    set the `<Nullable>` element to enable:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然指令对于细粒度控制很好，但你也可以为整个项目启用NRTs。在项目设置中，或直接在`.csproj`文件中，将`<Nullable>`元素设置为启用：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This setting treats every file in the project as if it started with the `#nullable
    enable` directive. When you turn on a nullable context for the whole project,
    you might want to keep some parts of the code from generating warnings, but use
    the project-wide nullable context after it. In that case, you can use the `restore`
    option:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置将项目中的每个文件都视为从`#nullable enable`指令开始。当你为整个项目开启可空上下文时，你可能希望保留一些代码部分不生成警告，但在之后使用项目级别的可空上下文。在这种情况下，你可以使用`restore`选项：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Enabling nullable reference types is like turning on a light in a previously
    dim room. It reveals potential pitfalls and ensures that we write safer, clearer
    code. With the tools C# provides, we have both granular and broad control over
    this feature, making the transition to a more transparent coding style both manageable
    and rewarding.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 启用可空引用类型就像在之前昏暗的房间里打开一盏灯。它揭示了潜在的陷阱，并确保我们编写更安全、更清晰的代码。有了C#提供的工具，我们对此功能既有细粒度的控制，也有广泛的控制，使得过渡到更透明的编码风格既可行又有益。
- en: Returning with intention
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有意返回
- en: In the realm of functional programming, a function’s primary aim is to be transparent.
    By transparent, we mean that the function should not just do what its name implies,
    but also, its return type should offer a clear contract of what to expect. Let’s
    dive deep into crafting honest return types in C#.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程领域，函数的主要目标是透明。透明意味着函数不仅应该做其名称暗示的事情，而且其返回类型应该提供对预期内容的清晰契约。让我们深入探讨在C#中构建诚实的返回类型。
- en: 'A seasoned developer knows that a function’s name or signature alone might
    not depict the entire story. Consider the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的开发者知道，一个函数的名称或签名本身可能无法描述整个故事。考虑以下：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: On the surface, this function seems to promise that it’ll fetch a user profile
    given a user ID. However, questions linger. What if the user doesn’t exist? What
    if there’s an error retrieving the profile?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，这个函数似乎承诺根据用户ID获取用户资料。然而，疑问仍然存在。如果用户不存在怎么办？如果检索资料时出现错误怎么办？
- en: 'Now consider an alternative:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个替代方案：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'By simply introducing `?` to the return type, the function becomes more transparent
    about its intention. It suggests: *I’ll try to fetch a user profile for this ID.
    But there’s a possibility you might get* *a null*.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地在返回类型中引入`?`，函数变得更加透明地表达了其意图。它暗示着：“我将尝试为这个ID获取用户资料。但有可能你会得到*一个null*。”
- en: The distinction between UserProfile and UserProfile?
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UserProfile和UserProfile?之间的区别
- en: 'While the distinction might seem minute, the implications are vast:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种区别可能看起来微不足道，但其影响是深远的：
- en: '`UserProfile?`, you immediately know there’s a possibility of not getting a
    user profile.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserProfile?`，你立刻知道有可能得不到用户资料。'
- en: '**Defensive coding**: Knowing the return can be null, you’ll naturally write
    safer code to handle such cases.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防御性编程**：知道返回值可能为null，你会自然地编写更安全的代码来处理这些情况。'
- en: '**Error handling**: Instead of exceptions or error codes to signify missing
    data, a nullable return type provides a clear, type-safe way to express the possibility
    of absence.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：而不是使用异常或错误代码来表示数据缺失，可空返回类型提供了一种清晰、类型安全的方式来表达缺失的可能性。'
- en: 'Let’s see this in practice:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际应用：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, with the help of NRTs, we can understand code more clearly and
    process its results correctly. And all we did to achieve it was just tweaking
    the method’s signature a little bit.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，借助NRTs（非空引用类型），我们可以更清晰地理解代码并正确处理其结果。而我们为了实现这一点所做的，仅仅是稍微调整了方法签名。
- en: Honoring a function’s contract
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尊重函数的契约
- en: An honest function goes beyond just indicating potential null returns. It creates
    a mindset of “return with intention.” When returning with intention, you’re not
    merely returning data; you’re communicating a state.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个诚实的函数不仅仅表明可能返回null，它还创造了一种“有意返回”的心态。当有意返回时，你不仅仅是返回数据；你是在传达一种状态。
- en: Consider the following examples.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。
- en: '`null` checks and avoids potential `NullReferenceException`s:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`检查并避免潜在的`NullReferenceException`：'
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Fetching data**: When retrieving data that might not exist, instead of exceptions,
    a nullable type paints a clearer picture:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取数据**：在检索可能不存在的数据时，而不是抛出异常，可空类型可以更清晰地描绘情况：'
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Transparent return types result in fewer surprises and more robust code. By
    clearly communicating what a function can return, you do the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 透明的返回类型导致更少的意外和更健壮的代码。通过清楚地传达函数可以返回的内容，你做了以下事情：
- en: '**Reduce errors**: Because developers will handle scenarios they might have
    overlooked otherwise'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少错误**：因为开发者将处理他们可能忽视的其他场景'
- en: '**Promote clarity**: Developers spend less time digging into function implementations,
    relying on return types to guide behavior'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高清晰度**：开发者花费更少的时间挖掘函数实现，依靠返回类型来指导行为'
- en: '**Foster trust**: A clear contract ensures that the function lives up to its
    promise, creating a sense of reliability in the code base'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建立信任**：清晰的契约确保函数履行其承诺，在代码库中创造一种可靠性感'
- en: 'As we continue to explore honest functions, always remember: your functions
    are both performers and communicators. Let them not just do their task, but also
    communicate their intent and potential outcomes transparently. In doing so, you
    build resilient systems, create clear contracts, and encourage a safer, more predictable
    coding environment.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续探索诚实的函数，请始终记住：你的函数既是执行者也是沟通者。让它们不仅完成其任务，而且透明地传达它们的意图和潜在结果。这样做，你构建了弹性系统，创建了清晰的契约，并鼓励一个更安全、更可预测的编码环境。
- en: Demanding honesty from function inputs
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对函数输入提出诚实的要求
- en: A truly robust system is not just about what you return; it’s also about what
    you accept. Guarding your functions against potentially misleading or harmful
    inputs is paramount in creating predictable, error-resistant applications.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真正健壮的系统不仅关乎你返回什么，还关乎你接受什么。保护你的函数免受可能误导或有害的输入是创建可预测、容错应用程序的关键。
- en: 'Consider this common scenario: You have a function that expects a certain type
    of input. However, when a `null` value sneaks its way in, your function breaks
    down, leading to the infamous `NullReferenceException`. To mitigate this, C# provides
    a way to demand honesty from function inputs using nullable reference types.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个常见的场景：你有一个期望特定类型输入的函数。然而，当 `null` 值悄悄进入时，你的函数会崩溃，导致臭名昭著的 `NullReferenceException`。为了减轻这种情况，C#
    提供了一种使用可空引用类型要求函数输入诚实的方法。
- en: 'Let’s say you define a function as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你定义了一个函数如下：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The intention is clear: the function expects `UserProfile`. However, what’s
    stopping a developer from passing in `null`?'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 目的明确：函数期望 `UserProfile`。然而，什么阻止了开发者传递 `null`？
- en: Nullable reference types to the rescue
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可空引用类型拯救了
- en: 'As we discussed earlier, with C# 8.0, nullable reference types add another
    layer of protection. By turning on nullable reference types using `#nullable enable`,
    the compiler becomes your guardian:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，在 C# 8.0 中，可空引用类型增加了另一层保护。通过使用 `#nullable enable` 启用可空引用类型，编译器变成了你的守护者：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, if any developer tries to pass a nullable `UserProfile` to the function,
    the compiler will raise a warning. This nudges developers in the right direction
    and prevents potential runtime errors.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果任何开发者尝试将可空的 `UserProfile` 传递给函数，编译器将发出警告。这促使开发者走向正确的方向，并防止潜在的运行时错误。
- en: 'However, warnings do not guarantee that `null` will not be used, so let’s look
    at another approach. Here, we defend the method with the simplest guard in a straightforward
    null check:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，警告并不能保证不会使用 `null`，所以让我们看看另一种方法。在这里，我们用最简单的保护方法——直接的空检查来捍卫这个方法：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This check ensures that if the function is ever provided `null`, it’ll immediately
    halt execution and provide a clear reason.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个检查确保如果函数被提供了 `null`，它将立即停止执行并提供一个明确的原因。
- en: Using preconditions and contracts
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用先决条件和契约
- en: Contracts and preconditions take the idea of guarding to a new level. By defining
    a set of rules that must hold true before a function can proceed, you’re making
    the function’s expectations explicit.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 契约和先决条件将保护的概念提升到了一个新的水平。通过定义一组在函数可以继续之前必须成立的规则，你使得函数的期望变得明确。
- en: 'Consider the CodeContracts ([https://github.com/Microsoft/CodeContracts](https://github.com/Microsoft/CodeContracts))
    library provided by Microsoft. With this, you can ensure your function’s preconditions
    with a more expressive syntax:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑微软提供的 CodeContracts ([https://github.com/Microsoft/CodeContracts](https://github.com/Microsoft/CodeContracts))
    库。有了这个库，你可以使用更丰富的语法来确保函数的先决条件：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This code is much more concise, however, it guards our method from `null` values
    in the same way.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码更加简洁，但它以同样的方式保护我们的方法免受 `null` 值的影响。
- en: Using built-in checks
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内置检查
- en: 'In C# 6.0, we received a new way to guard against null values – `ArgumentNullException.ThrowIfNull`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 6.0 中，我们得到了一种新的方法来防止空值 - `ArgumentNullException.ThrowIfNull`：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, this code looks even cleaner and easier to read. Also, a more enhanced
    method for strings appeared in C# 7.0: `ArgumentException.ThrowIfNullOrEmpty`.
    It not only checks for null but also ensures that the string is not empty:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这段代码看起来更加整洁，也更容易阅读。此外，C# 7.0 中出现了一种更完善的方法来处理字符串：`ArgumentException.ThrowIfNullOrEmpty`。它不仅检查是否为空，还确保字符串不为空：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The power of explicit non-null inputs
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式非空输入的力量
- en: 'By demanding non-null arguments, you do the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过要求非空参数，你做了以下几件事：
- en: '**Improve predictability**: Functions behave as expected since rogue nulls
    don’t derail them'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高可预测性**：函数的行为符合预期，因为恶意的 `null` 值不会使它们出轨'
- en: '**Boost developer confidence**: With clear contracts, developers can invoke
    functions without second-guessing'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提升开发者信心**：有了清晰的契约，开发者可以调用函数而无需犹豫'
- en: '**Reduce debugging time**: Catching potential issues at compile time is always
    faster than runtime debugging'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少调试时间**：在编译时捕捉潜在问题总是比运行时调试快'
- en: In order to write good functional code, ensuring clarity in what you accept
    is just as crucial as being transparent in what you return. By demanding honesty
    from function inputs, you’re laying a solid foundation for code that’s both reliable
    and resilient.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写好的函数式代码，确保你接受的内容清晰，就像确保你返回的内容透明一样重要。通过要求函数输入诚实，您为编写既可靠又具有弹性的代码奠定了坚实的基础。
- en: Pattern matching and nullable types
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配和可空类型
- en: Pattern matching is a powerful tool in the C# arsenal, serving as a mechanism
    to make the code not only more expressive but also clearer and safer. When combined
    with nullable types, pattern matching helps us guard our code against potential
    pitfalls.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是C#工具箱中的强大工具，它不仅使代码更具表现力，而且更清晰、更安全。当与可空类型结合使用时，模式匹配帮助我们保护代码免受潜在陷阱的影响。
- en: Pattern matching, introduced in C# 7.0 and enhanced in subsequent versions,
    is a feature that allows you to test a value against a pattern, providing a way
    to extract information from the value when it conforms to the pattern.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配，自C# 7.0引入并在后续版本中增强，是一种允许您将值与模式进行比较的功能，当值符合模式时，提供从值中提取信息的方法。
- en: 'Consider the classic `switch` statement, evolved with pattern matching:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑经典的`switch`语句，结合模式匹配进化而来：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, `ArcherTower` and `CannonTower` are types. If `tower` is of type `ArcherTower`,
    it not only enters the respective case block but also casts it to the `ArcherTower`
    type, allowing you to access its properties directly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ArcherTower`和`CannonTower`是类型。如果`tower`是`ArcherTower`类型，它不仅进入相应的case块，还将它转换为`ArcherTower`类型，允许您直接访问其属性。
- en: Pattern matching with nullable types
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有可空类型的模式匹配
- en: 'Pattern matching truly shines when dealing with nullable types. Let’s consider
    a situation where we fetch a user profile:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配在处理可空类型时真正大放异彩。让我们考虑一个获取用户配置文件的情况：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How do we handle this potential null in a type-safe, clear manner? Enter pattern
    matching.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何以类型安全和清晰的方式处理这种潜在的null？请进入模式匹配。
- en: Using the “is” pattern
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用“is”模式
- en: 'Ideally, our code should be easy to read, and what could be easier than using
    plain English? The “is” pattern is designed to assist with that:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们的代码应该易于阅读，还有什么比使用普通英语更容易呢？“is”模式就是为了帮助实现这一点：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This immediately makes the code more readable, drawing a clear distinction between
    the scenarios.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这立即使代码更易于阅读，清楚地区分了不同的情况。
- en: Switch expressions with property patterns
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有属性模式的switch表达式
- en: 'Introduced in C# 8.0, the `switch` expression paired with property patterns
    provides an even more concise way to handle complex conditions:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 自C# 8.0引入的`switch`表达式与属性模式结合，提供了一种更简洁的方式来处理复杂条件：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, not only do we check for null, but we also examine specific properties
    of the `Book` object, making decisions based on their values.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不仅检查null，还检查`Book`对象的特定属性，根据它们的值做出决策。
- en: Ensuring clarity with nullable types
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可空类型确保清晰性
- en: 'The amalgamation of pattern matching and nullable types ensures the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配与可空类型的结合确保以下内容：
- en: '**Safety**: By handling potential nulls explicitly, you reduce the risk of
    runtime errors'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：通过显式处理潜在的null，您降低了运行时错误的风险'
- en: '**Expressiveness**: Patterns allow you to condense complex conditional logic
    into concise, readable constructs'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表现力**：模式允许您将复杂的条件逻辑压缩成简洁、易读的结构'
- en: '**Readability**: Clear distinctions between different conditions and outcomes
    enable developers to understand the flow effortlessly'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性**：不同条件和结果之间的清晰区分使开发者能够轻松理解流程。'
- en: Pattern matching, when combined with nullable types, is a formidable tool for
    any C# developer. It not only streamlines code but also strengthens it, allowing
    you to write applications that are more resilient to unexpected scenarios. Use
    it and your code will be both a joy to write and a model of reliability.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当与可空类型结合使用时，模式匹配是任何C#开发者的强大工具。它不仅简化了代码，而且增强了代码，使您能够编写对意外情况更具弹性的应用程序。使用它，您的代码将既易于编写，又可靠。
- en: The null object pattern
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空对象模式
- en: The null object pattern is a design pattern that provides an object as a surrogate
    for the lack of an object of a given interface. Essentially, it provides default
    behavior in the absence of meaningful data or behavior. This pattern is particularly
    useful in scenarios where you’d expect an object but don’t have one, and don’t
    want to constantly check for `null`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 空对象模式是一种设计模式，它提供了一个对象作为给定接口中缺少的对象的代理。本质上，它在没有有意义的数据或行为的情况下提供默认行为。这种模式在预期有对象但实际没有，且不希望不断检查`null`的场景中特别有用。
- en: The problem with null checks
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`null`检查的问题'
- en: 'Imagine you’re developing a system where you have a series of operations to
    perform on a `User` object. Now, not every user might be initialized in the system,
    which often leads to this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在开发一个系统，在这个系统中，你需要在`User`对象上执行一系列操作。现在，并不是每个用户都可能在系统中初始化，这通常会导致以下情况：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This might seem innocent for a single check. But when your code base is littered
    with such null checks, the code becomes verbose and less readable. The proliferation
    of null checks can also obscure the primary business logic, making the code base
    harder to maintain and understand.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于单个检查可能看起来很无害。但当你代码库中充满了这样的`null`检查时，代码变得冗长且难以阅读。`null`检查的泛滥也可能掩盖主要业务逻辑，使得代码库更难以维护和理解。
- en: The null object solution
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空对象解决方案
- en: The null object pattern provides an elegant solution to this problem. Instead
    of using a null reference to convey the absence of an object, you create an object
    that implements the expected interface but does nothing – a “null object.”
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 空对象模式为这个问题提供了一个优雅的解决方案。而不是使用空引用来传达对象的缺失，你创建了一个实现预期接口但不做任何事情的对象——一个“空对象”。
- en: 'Here’s an example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In situations where a user isn’t available, instead of returning `null`, you’d
    return an instance of `NullUser`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户不可用的情况下，你将返回`NullUser`的实例，而不是返回`null`。
- en: 'Now, when you want to perform an operation, you can confidently do so without
    checking for `null`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你想要执行操作时，你可以自信地这样做，而无需检查`null`：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Regardless of whether `user` is `RealUser` or `NullUser`, the code won’t throw
    `Null``ReferenceException`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 无论`user`是`RealUser`还是`NullUser`，代码都不会抛出`NullReferenceException`。
- en: Advantages
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优势
- en: 'Implementing the null object pattern offers several key advantages:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 实现空对象模式提供了几个关键优势：
- en: '**Reduction of conditional statements**: You can decrease the number of explicit
    null checks, leading to cleaner and more readable code.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少条件语句**: 你可以减少显式`null`检查的数量，从而得到更干净、更易读的代码。'
- en: '**Safety**: The risk of null reference exceptions gets drastically reduced.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**: `null`引用异常的风险大大降低。'
- en: '**Polymorphism**: By treating the null object the same as other objects, you
    can leverage the power of polymorphism, which can simplify and clarify the code.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态性**: 通过将空对象与其他对象同等对待，你可以利用多态的力量，这可以简化并澄清代码。'
- en: '**Clarity in intent**: Null objects can have meaningful names, making it clear
    when a “do-nothing” or default behavior is intentional'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**意图的清晰性**: 空对象可以有有意义的名称，这使得在“什么都不做”或默认行为是故意的时非常清楚。'
- en: Limitations and considerations
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局限性和考虑因素
- en: 'While the null object pattern has its benefits, it’s not always the best solution:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然空对象模式有其优点，但它并不总是最佳解决方案：
- en: '**Overhead**: For very large systems or deeply nested structures, introducing
    null objects everywhere can add overhead'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开销**: 对于非常大的系统或深度嵌套的结构，在各个地方引入空对象可能会增加开销'
- en: '**Complexity**: If the interface or base class changes frequently, maintaining
    a corresponding null object can become tedious'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**: 如果接口或基类频繁更改，维护相应的空对象可能会变得繁琐'
- en: '**Obscured errors**: If you’re not careful, using null objects can potentially
    mask problems in the system, since they provide default behavior that might hide
    issues that would have otherwise been exposed by a null reference'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐藏的错误**: 如果你不够小心，使用空对象可能会潜在地掩盖系统中的问题，因为它们提供了默认行为，可能会隐藏其他情况下由空引用暴露的问题。'
- en: The null object pattern is a powerful tool in the arsenal of a C# developer.
    It’s not a one-size-fits-all solution, but when applied judiciously, it can greatly
    improve code clarity and robustness. Like all design patterns, understanding when
    and where to apply it is crucial. So don’t hurry to use it everywhere, and let’s
    look at a more functional approach – the `Option` type.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 空对象模式是C#开发者工具箱中的强大工具。它不是万能的解决方案，但当你明智地应用它时，它可以极大地提高代码的清晰度和健壮性。像所有设计模式一样，理解何时何地应用它是至关重要的。所以不要急于在所有地方使用它，让我们看看一种更函数式的方法——`Option`类型。
- en: Beyond null – using Option
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越`null` – 使用`Option`
- en: '`Nullable<T>`, which is embedded in C#, is a great tool to work with `null`
    values, but there is a better and more straightforward construct for the handling
    of null values. `Option` is a type that provides more expressive tools for conveying
    the presence or absence of a value, serving as a richer alternative to nullable
    types.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nullable<T>`，它是C#中内置的，是一个处理`null`值的好工具，但有一个更简单直接的结构来处理`null`值。`Option`是一种类型，它提供了更多表达性的工具来传达值的缺失或存在，作为可空类型的更丰富替代品。'
- en: A brief introduction to Option
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Option`的简要介绍'
- en: At its core, the `Option` type can be thought of as a container that may or
    may not contain a value. Typically, it’s represented as either `Some` (which wraps
    a value) or `None` (indicating the absence of a value).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，`Option`类型可以被视为一个可能包含或不包含值的容器。通常，它表示为`Some`（包装一个值）或`None`（表示值的缺失）。
- en: 'Usually, the implementation of `Option` looks like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`Option`的实现看起来像这样：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: While C# doesn’t have a built-in `Option` type, you can use the one above or
    use a library such as LanguageExt ([https://github.com/louthy/language-ext](https://github.com/louthy/language-ext)),
    which provides this functionality.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 C# 没有内置的`Option`类型，但你可以使用上面的类型或使用像LanguageExt ([https://github.com/louthy/language-ext](https://github.com/louthy/language-ext))这样的库，它提供了这个功能。
- en: 'Now, let’s look at how we can leverage the `Option` type:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何利用`Option`类型：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Another way to use `Option` is to write the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Option`的另一种方法是编写以下内容：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This code is more straightforward, however, the code before it is more concise.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码更直接，但之前的代码更简洁。
- en: 'Now, when calling this function, we can handle the result in a more expressive
    manner:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当调用此函数时，我们可以以更表达的方式处理结果：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This approach makes the handling of potential missing values explicit and clear.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使处理潜在缺失的值变得明确和清晰。
- en: As Steve delved into `Option` types, he thought “This reminds me of how we handle
    power-ups in our games, sometimes they’re there, sometimes they’re not.”
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当史蒂夫深入研究`Option`类型时，他想“这让我想起了我们在游戏中处理升级的方式，有时它们在那里，有时它们不在。”
- en: Advantages of the Option type over nullable types
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Option`类型相对于可空类型的优势'
- en: 'When it comes to handling values that might be absent, opting for the `Option`
    type presents distinct advantages in your code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到处理可能缺失的值时，选择`Option`类型在你的代码中具有明显的优势：
- en: '`Some` and `None` constructs makes the code’s intention unmistakable. There’s
    a clear distinction between having a value and lacking one.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Some`和`None`构造使得代码的意图一目了然。有值和无值之间有一个清晰的区分。'
- en: '`Option` type forces you to handle both `Some` and `None` scenarios, reducing
    potential oversights in your code.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Option`类型强制你处理`Some`和`None`两种情况，减少了代码中的潜在疏忽。'
- en: '`Option` types often work together with other functional methods, enabling
    powerful and concise transformations.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Option`类型通常与其他函数式方法一起工作，实现强大且简洁的转换。'
- en: The interplay of Option and nullable types
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Option`和可空类型之间的相互作用'
- en: 'It’s worth noting that while the `Option` type provides a robust mechanism
    for managing optional values, it doesn’t entirely replace nullable types. Instead,
    consider them as tools in your toolbox, each with its strengths:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，虽然`Option`类型提供了一个强大的机制来管理可选值，但它并不完全取代可空类型。相反，将它们视为你的工具箱中的工具，每个都有其优势：
- en: Use nullable reference types when working with native C# constructs or when
    interfacing with libraries/frameworks expecting them
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用原生C#构造或与期望它们的库/框架交互时，请使用可空引用类型
- en: Adopt the `Option` type in scenarios requiring richer functional operations
    or when building libraries with a functional flavor
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要更丰富函数操作或构建具有函数式风格的库的场景中采用`Option`类型
- en: The `Option` type brings a taste of pure functional programming to the C# world,
    offering a sophisticated toolset for handling optional values. By integrating
    these constructs into your applications, you elevate the clarity, robustness,
    and expressiveness of your code. While the learning curve might be steeper than
    with nullable types, the rewards in terms of code quality and resilience are well
    worth the effort.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option` 类型为C#世界带来了纯函数式编程的滋味，提供了一套复杂的工具集来处理可选值。通过将这些结构集成到您的应用程序中，您可以提高代码的清晰度、稳健性和表现力。虽然学习曲线可能比可空类型更陡峭，但就代码质量和弹性而言，这些回报是值得努力的。'
- en: Practical scenarios – handling nulls effectively
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际场景 – 有效处理空值
- en: As you must have already seen, dealing with nulls isn’t just a theoretical concern;
    it’s a daily challenge. By examining real-world scenarios, we can better appreciate
    the need for clear strategies in managing nulls and ensuring robust, reliable
    applications.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经看到的，处理空值不仅仅是一个理论上的问题；它是一个日常挑战。通过分析现实世界的情况，我们可以更好地理解在管理空值和确保稳健、可靠的应用程序中明确策略的必要性。
- en: Case study – managing YouTube videos
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究 – 管理YouTube视频
- en: '**Scenario**: A system retrieves video details from a database. Not every video
    ID queried will have a corresponding video entry.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**: 一个系统从数据库检索视频详细信息。并非每个查询的视频ID都会有一个相应的视频条目。'
- en: '**Traditional approach**:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**传统方法**:'
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Option approach**:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项方法**:'
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: By returning `Video?`, we’re signaling the potential absence of a video explicitly.
    Calling functions can then use pattern matching or direct null checks to handle
    the absence gracefully.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通过返回`Video?`，我们明确地表示视频可能不存在。调用函数可以使用模式匹配或直接空值检查来优雅地处理缺失情况。
- en: Case study – managing different video types
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究 – 管理不同视频类型
- en: '**Scenario**: As YouTube started supporting various video formats and sources
    (e.g., live streams, 360-degree videos, standard uploads), the backend systems
    had to correctly identify and process each video type. With the platform’s increasing
    complexity and new video formats being introduced, using traditional if-else statements
    to handle these became cumbersome and less maintainable. Pattern matching emerged
    as an efficient solution to this challenge.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**: 随着YouTube开始支持各种视频格式和来源（例如，直播、360度视频、标准上传），后端系统必须正确识别和处理每种视频类型。随着平台的日益复杂和新的视频格式被引入，使用传统的if-else语句来处理这些情况变得越来越繁琐且难以维护。模式匹配成为解决这一挑战的有效解决方案。'
- en: '**Traditional approach**:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**传统方法**:'
- en: '[PRE38]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Pattern** **matching approach**:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式匹配方法**:'
- en: '[PRE39]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Pattern matching provided a more elegant, concise, and readable approach to
    handling different video types. As YouTube introduces new video formats or features,
    they can be seamlessly integrated into the `GetVideoDetails` function. This modern
    approach reduces potential errors, simplifies the code, and enhances maintainability.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配提供了一种更优雅、简洁和可读的方法来处理不同的视频类型。随着YouTube引入新的视频格式或功能，它们可以无缝集成到`GetVideoDetails`函数中。这种现代方法减少了潜在的错误，简化了代码，并提高了可维护性。
- en: Case study – working with non-existing objects
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究 – 处理不存在的对象
- en: '**Scenario**: As YouTube expanded globally, it was increasingly common to encounter
    incomplete or missing data due to various reasons, such as network hiccups, data
    migration issues, or regional content restrictions. Using traditional null checks
    became increasingly cumbersome, leading to scattered logic throughout the code
    base. The null object pattern offered a systematic approach to provide a default
    object instead of a null reference.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**: 随着YouTube在全球范围内的扩张，由于各种原因（如网络故障、数据迁移问题或区域内容限制），遇到不完整或缺失数据的情况越来越普遍。使用传统的空值检查变得越来越繁琐，导致代码库中逻辑分散。空对象模式提供了一种系统性的方法，通过提供一个默认对象而不是空引用来解决问题。'
- en: '**Traditional approach**:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**传统方法**:'
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And when displaying the video:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当显示视频时：
- en: '[PRE41]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Null object** **pattern approach**:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**空对象模式方法**:'
- en: 'First, create a default object for videos:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为视频创建一个默认对象：
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then modify the fetching method:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后修改获取方法：
- en: '[PRE43]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then display the video:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后显示视频：
- en: '[PRE44]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: By adopting the null object pattern, YouTube’s Video Management System managed
    to encapsulate the behavior associated with null or missing data within the default
    “null object,” leading to more unified and predictable system behavior. It removed
    numerous null checks scattered throughout the code base, reducing the chances
    of null reference exceptions, and enhancing the system’s robustness and maintainability.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用空对象模式，YouTube 的视频管理系统成功地将与空或缺失数据相关的行为封装在默认的“空对象”中，从而实现了更统一和可预测的系统行为。它消除了代码库中散布的许多空值检查，减少了空引用异常的可能性，并增强了系统的健壮性和可维护性。
- en: The impact of handling nulls in real-world scenarios
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在现实世界场景中处理空值的影响
- en: 'In real-life situations, how we deal with null values in our code can have
    a big impact. Let’s explore how handling nulls can make a difference:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中的情况下，我们如何处理代码中的空值可能会有很大的影响。让我们探讨一下处理空值如何产生差异：
- en: '`NullReferenceException`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NullReferenceException`'
- en: '**Clearer intention**: Using tools such as nullable reference types and pattern
    matching, our code more transparently communicates potential outcomes'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更清晰的意图**：使用诸如可空引用类型和模式匹配等工具，我们的代码更透明地传达潜在的结果'
- en: '**Developer confidence**: When the system’s behavior is predictable, developers
    can integrate and extend it with greater confidence'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者信心**：当系统的行为可预测时，开发者可以更有信心地进行集成和扩展'
- en: In real-world scenarios, the unknowns and uncertainties are plentiful. By incorporating
    clear and transparent handling of potential nulls, we ensure that our applications
    are both resilient and maintainable. Whether you’re managing video data, processing
    forms, or integrating with third-party services, a deliberate approach to null
    management can make all the difference.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的场景中，未知和不确定性很多。通过引入对潜在空值的清晰和透明处理，我们确保我们的应用程序既具有弹性又易于维护。无论您是在管理视频数据、处理表单还是与第三方服务集成，对空值管理的深思熟虑的方法都可以产生重大差异。
- en: The reality of honesty in C# – why there will never be truly honest functions
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 中诚实的现实——为什么永远不会真正有诚实的函数
- en: C# is a multi-paradigm language, offering a lot of features, each designed with
    various considerations in mind. As we venture into the topic of “honest functions,”
    we must also acknowledge that C#’s design, while powerful, has some trade-offs.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: C# 是一种多范式语言，提供了许多功能，每个功能都是考虑到各种因素而设计的。当我们探讨“诚实函数”这一主题时，我们也必须承认，尽管 C# 的设计非常强大，但也存在一些权衡。
- en: The compromises of the C# language design
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 语言设计的妥协
- en: 'C#’s design involves certain trade-offs. Let’s examine them and understand
    their impact:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: C# 的设计涉及某些权衡。让我们来检查它们并了解它们的影响：
- en: '**Historical baggage**: C# has evolved over the years, adding new features
    while ensuring backward compatibility. This means that older, less “honest” ways
    of doing things will always remain a part of the language.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**历史包袱**：C# 在这些年中不断发展，添加了新功能同时确保向后兼容。这意味着较老、不那么“诚实”的做法将始终是语言的一部分。'
- en: '**Performance versus safety**: Offering both low-level performance-oriented
    features and high-level safety features is not easy. Sometimes, the requirements
    of performance might lead developers away from purely “honest” constructs.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能与安全性的权衡**：提供低级性能导向功能和高级安全功能并不容易。有时，性能的要求可能会让开发者偏离纯粹的“诚实”结构。'
- en: '**Broad audience**: C# is designed for a vast range of developers, from those
    writing system-level code to high-level enterprise applications. As a result,
    the language can’t be too opinionated in favor of any single paradigm, including
    functional programming.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广泛的受众**：C# 是为广泛的开发者设计的，从编写系统级代码的人到高级企业应用程序的开发者。因此，语言不能过于偏袒任何单一范式，包括函数式编程。'
- en: '`OutOfMemoryException`, for example. Although, we might think that if we are
    the creators of our code it will do as we wish, don’t forget that the **Common
    Language Runtime** (**CLR**) is the true master here and it can interfere with
    our intentions.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OutOfMemoryException`，例如。虽然，我们可能会认为如果我们是代码的创造者，它就会按照我们的意愿行事，但别忘了**公共语言运行时**（**CLR**）才是真正的掌控者，它可以干预我们的意图。'
- en: C# offers a rich variety of features, enabling developers to craft solutions
    across different paradigms. In our pursuit of honesty and clarity, we should recognize
    and respect the trade-offs intrinsic to the language’s design. Additionally, we
    need to remember that our code does not run in an ideal world and that the environment
    also impacts the way our programs work.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: C#提供了丰富的功能，使开发者能够在不同的范式下构建解决方案。在我们追求诚实和清晰的过程中，我们应该认识到并尊重语言设计内在的权衡。此外，我们需要记住，我们的代码并不在一个理想的世界中运行，环境也会影响我们的程序的工作方式。
- en: Practical tips and best practices
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实用技巧和最佳实践
- en: As we navigate the nuances of functional programming in C# and its approach
    to handling nulls, some practical strategies emerge. These strategies ensure that
    our applications remain robust while benefiting from the enhanced clarity and
    predictability that functional paradigms provide.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索C#中函数式编程的细微差别及其处理null的方法时，一些实用的策略浮现出来。这些策略确保我们的应用程序保持稳健，同时受益于函数范式提供的增强清晰度和可预测性。
- en: Strategies for migrating existing code bases to adopt nullable reference types
    and Option
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将现有代码库迁移以采用可空引用类型和Option的策略
- en: 'Let’s consider strategies for migrating your existing code bases to adopt nullable
    reference types and `Option`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑将现有代码库迁移以采用可空引用类型和`Option`的策略：
- en: '`#nullable` `enable` directive:'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#nullable` `enable` 指令：'
- en: '[PRE45]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**Use of analysis tools**: Tools such as Roslyn analyzers ([https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview](https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview))
    can help identify potential nullability issues in code.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用分析工具**：如Roslyn分析器（[https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview](https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview)）等工具可以帮助识别代码中的潜在nullability问题。'
- en: '`Option` type, ensure you understand the implications of the calling code.
    Functions may return different types, requiring adjustments to the calling logic.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Option`类型，确保你理解调用代码的影响。函数可能返回不同的类型，需要调整调用逻辑。'
- en: Common pitfalls and how to navigate them
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见陷阱及其规避方法
- en: 'Let’s take a closer look at common pitfalls and discover how to effectively
    navigate them:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地看看常见的陷阱，并了解如何有效地规避它们：
- en: '**Assuming non-null values prematurely**: Even with nullable reference types
    enabled, always validate inputs, especially if they come from external sources:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过早假设非null值**：即使启用了可空引用类型，也始终要验证输入，尤其是如果它们来自外部来源：'
- en: '[PRE46]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`Option` type is powerful, it might not be suitable for every scenario. For
    simple cases where nullability is self-explanatory, nullable reference types might
    be more appropriate.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Option`类型功能强大，可能并不适合每个场景。对于nullability显而易见的简单情况，可空引用类型可能更为合适。'
- en: '**Forgetting legacy code**: Older parts of the code base may not adhere to
    new paradigms. When integrating new and old code, be cautious of potential mismatches
    in expectations.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**忘记遗留代码**：代码库中的旧部分可能不符合新的范式。在整合新旧代码时，要小心潜在的期望不匹配。'
- en: Testing strategies for null and Option handling
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试策略：处理null和Option
- en: 'Let’s talk about how to test your code when it deals with null and `Option`
    in a functional programming way. It’s important to test that your code works correctly,
    and now we’ll explore how to do that:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论如何以函数式编程的方式测试处理null和`Option`的代码。确保代码正确工作非常重要，现在我们将探讨如何做到这一点：
- en: '**Unit testing with null values**: Ensure unit tests cover scenarios where
    null values are passed to functions. This helps catch potential null-related issues
    before they reach production:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用null值的单元测试**：确保单元测试覆盖将null值传递给函数的场景。这有助于在这些问题到达生产环境之前捕捉潜在的null相关问题：'
- en: '[PRE47]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`Option` types, tests should cover both `Some` and `None` scenarios to ensure
    all code paths are verified:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Option`类型，测试应涵盖`Some`和`None`场景，以确保所有代码路径都得到验证：'
- en: '[PRE48]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**Integration testing**: Beyond unit tests, integration tests should be employed
    to validate interactions between different components, especially when dealing
    with databases, APIs, or other external systems that might return unexpected null
    values.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：除了单元测试之外，还应该使用集成测试来验证不同组件之间的交互，尤其是在处理可能返回意外null值的数据库、API或其他外部系统时。'
- en: Learning about functional programming in C# might not be an easy thing, but
    you have already started this venture and continued it right up to the current
    lines. You are doing great, so keep it up, and let’s reinforce the knowledge you’ve
    acquired with our traditional three exercises.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中学习函数式编程可能不是一件容易的事情，但你已经开始了这个旅程，并一直持续到现在的代码行。你做得很好，所以继续保持，让我们通过我们传统的三个练习来巩固你获得的知识。
- en: Exercises
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Now that Steve has learned about honest functions, null, and Option types, Julia
    has prepared some challenges to help him apply these concepts to his tower defense
    game. Let’s see if you can help Steve solve them!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，史蒂夫已经了解了诚实函数、空值和 Option 类型，朱莉娅已经准备了一些挑战，帮助他将这些概念应用到他的塔防游戏中。让我们看看你是否能帮助史蒂夫解决这些问题！
- en: Exercise 1
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1
- en: 'Steve’s game needs to fetch tower information reliably. Refactor this function
    to use an honest return type that clearly indicates when a tower might not be
    found:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫的游戏需要可靠地获取塔信息。重构这个函数以使用诚实的返回类型，明确指示塔可能找不到的情况：
- en: '[PRE49]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Exercise 2
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2
- en: 'In the game players can apply power-ups to towers. Refactor this function to
    ensure it handles null inputs gracefully:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，玩家可以将增强道具应用到塔上。重构这个函数以确保它能够优雅地处理空输入：
- en: '[PRE50]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Exercise 3
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3
- en: 'Steve wants to provide players with detailed information about the enemies
    they’re facing. Using the enemy classes from his game, implement a function that
    generates descriptive strings for each enemy type:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫希望向玩家提供他们面对的敌人的详细信息。使用他游戏中的敌人类，实现一个函数，为每种敌人类型生成描述性字符串：
- en: '[PRE51]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Solutions
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Exercise 1
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1
- en: 'Incorporate the `Option` return type to signify that a user may or may not
    be found:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Option` 返回类型纳入，以表示用户可能找到或不找到：
- en: '[PRE52]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Exercise 2
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2
- en: 'Utilize a built-in check for null inputs that will throw an exception if the
    user profile is `null`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 利用内置的空输入检查，如果用户配置文件为 `null`，则抛出异常：
- en: '[PRE53]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Exercise 3
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3
- en: 'Employ pattern matching to address potential null values elegantly:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式匹配优雅地处理潜在的空值：
- en: '[PRE54]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: These exercises and their solutions provide an applied understanding of the
    concepts covered, guiding you toward a functional and robust approach to handling
    nulls and honest functions in C#. Keep experimenting, keep iterating, and always
    lean into the principles of functional programming to craft clearer, more resilient
    C# code.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习及其解决方案提供了对所涵盖概念的应用理解，指导你走向处理空值和诚实函数的实用且健壮的方法。继续实验，不断迭代，并始终遵循函数式编程的原则，以编写更清晰、更具弹性的
    C# 代码。
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As our journey through honest functions and the intricacies of null handling
    in C# draws to a close, let’s reflect on our discoveries and look to the future.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们通过诚实函数和 C# 中空值处理的复杂性的旅程即将结束，让我们反思我们的发现并展望未来。
- en: We have traversed the history and implications of `null` in C#. We’ve understood
    its nuances, its dangers, and its power. By now, the infamous `NullReferenceException`
    should be less of a nemesis and more of an old acquaintance you nod at from across
    the room, acknowledging its presence but never letting it disrupt your day.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了 C# 中 `null` 的历史和影响。我们已经理解了它的细微差别、它的危险和它的力量。到现在，臭名昭著的 `NullReferenceException`
    应该不再是你的敌人，而是一个你在房间另一边点头致意的老熟人，承认它的存在，但永远不会让它打扰你的日常生活。
- en: Honest functions – or functions that explicitly state their intentions, inputs,
    and outputs – represent a paradigm shift toward predictability, clarity, and resilience.
    Embracing honesty in functions is not merely about avoiding pitfalls but about
    embracing a philosophy of transparency. In doing so, we create code that other
    developers can trust, understand, and build upon.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 诚实函数——或者明确声明其意图、输入和输出的函数——代表了向可预测性、清晰性和弹性的范式转变。在函数中拥抱诚实不仅仅是为了避免陷阱，更是为了拥抱一种透明度的哲学。通过这样做，我们创建的代码可以让其他开发者信任、理解和在此基础上构建。
- en: We’ve dived deep into the realms of nullable reference types and pattern matching
    and even touched upon the null object pattern and the `Option` type, all of which
    present us with powerful tools to express our intentions with precision and grace.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经深入研究了可空引用类型和模式匹配的领域，甚至触及了空对象模式和 `Option` 类型，所有这些都为我们提供了强大的工具，以精确和优雅地表达我们的意图。
- en: Yet, as with all tools, it’s essential to remember that their strength lies
    in their appropriate application. The world of C# is vast, and while functional
    programming principles offer much value, they are but one aspect of a rich tapestry.
    It’s up to you, the developer, to discern when to employ these concepts and when
    to lean into other paradigms. As we add a functional paradigm to our habitual
    way of coding, it may cause different errors and we’d better be ready to work
    with them. That’s why I invite you to read the next chapter, about error handling.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就像所有工具一样，我们必须记住，它们的强大之处在于它们的适当应用。C#的世界广阔无垠，虽然函数式编程原则提供了很多价值，但它们只是丰富多彩的画卷中的一个方面。选择何时应用这些概念，何时转向其他范式，取决于你，作为开发者。当我们把函数式范式添加到我们的习惯性编码方式中时，可能会引发不同的错误，我们最好准备好与他们一起工作。这就是为什么我邀请你阅读下一章，关于错误处理。
- en: Part 2:Advanced Functional Techniques
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：高级函数式技术
- en: Building on the foundations established in Part I, we now delve into more advanced
    functional programming techniques. We’ll start by exploring functional approaches
    to error handling, moving beyond traditional try-catch blocks to more elegant
    solutions. Next, we’ll cover higher-order functions and delegates, unlocking the
    power of functions as first-class citizens. The section concludes with an in-depth
    look at functors and monads, advanced concepts that provide powerful tools for
    managing complexity in your code.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分建立的基础之上，我们现在深入探讨更高级的函数式编程技术。我们将从探索错误处理的函数式方法开始，超越传统的try-catch块，到更优雅的解决方案。接下来，我们将介绍高阶函数和委托，解锁函数作为一等公民的力量。本节以对functors和monads的深入探讨结束，这些高级概念为管理代码中的复杂性提供了强大的工具。
- en: 'This part has the following chapters:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B21069_05.xhtml#_idTextAnchor221)*, Error Handling*'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第五章*](B21069_05.xhtml#_idTextAnchor221)*，错误处理*'
- en: '[*Chapter 6*](B21069_06.xhtml#_idTextAnchor270)*, Higher-Order Functions and
    Delegates*'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第六章*](B21069_06.xhtml#_idTextAnchor270)*，高阶函数和委托*'
- en: '[*Chapter 7*](B21069_07.xhtml#_idTextAnchor332)*, Functors and Monads*'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第七章*](B21069_07.xhtml#_idTextAnchor332)*，Functors和Monads*'
