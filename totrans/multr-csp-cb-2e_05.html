<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Using C# 6.0</h1></div></div></div><p>In this chapter, we will look through native asynchronous programming support in the C# 6.0 programming language. You will learn the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using the <code class="literal">await</code> operator to get asynchronous task results</li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">await</code> operator in a lambda expression</li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">await</code> operator with consequent asynchronous tasks</li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">await</code> operator for the execution of parallel asynchronous tasks</li><li class="listitem" style="list-style-type: disc">Handling exceptions in asynchronous operations</li><li class="listitem" style="list-style-type: disc">Avoiding the use of the captured synchronization context</li><li class="listitem" style="list-style-type: disc">Working around the <code class="literal">async void</code> method</li><li class="listitem" style="list-style-type: disc">Designing a custom awaitable type</li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">dynamic</code> type with <code class="literal">await</code></li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Introduction</h1></div></div></div><p>Until now, you learned <a id="id199" class="indexterm"/>about the Task Parallel Library, the latest asynchronous programming infrastructure from Microsoft. It allows us to design our program in a modular manner, combining different asynchronous operations together.</p><p>Unfortunately, it is still difficult to understand the actual program flow when reading such a program. In a large program, there will be numerous tasks and continuations that depend on each other, continuations that run other continuations, and continuations for exception handling. They are all gathered together in the program code in very different places. Therefore, understanding the sequence of which operation goes first and what happens next becomes a very challenging problem.</p><p>Another issue to watch out for is whether the proper synchronization context is propagated to each asynchronous task that could touch user interface controls. It is only permitted to use these controls from the UI thread; otherwise, we would get a multithreaded access exception.</p><p>Speaking about exceptions, we also have to use separate continuation tasks to handle errors that occur inside antecedent asynchronous operation or operations. This in turn results in complicated error-handling code that is spread through different parts of the code, not logically related to each other.</p><p>To address these issues, the<a id="id200" class="indexterm"/> authors of C# introduced new language enhancements called <strong>asynchronous functions </strong>along with C# version 5.0. They really make asynchronous programming simple, but at the same time, it is a higher level abstraction over TPL. As we mentioned in <a class="link" href="ch04.html" title="Chapter 4. Using the Task Parallel Library">Chapter 4</a>, <em>Using the Task Parallel Library</em>, abstraction hides important implementation details and makes asynchronous programming easier at the cost of taking away many important things from a programmer. It is very important to understand the concept behind asynchronous functions to create robust and scalable applications.</p><p>To create <a id="id201" class="indexterm"/>an asynchronous function, you first mark a method with the <code class="literal">async</code> keyword. It is not possible to have the <code class="literal">async</code> property or event accessor methods and constructors without doing this first. The code will look as follows:</p><div><pre class="programlisting">async Task&lt;string&gt; GetStringAsync()
{
  await Task.Delay(TimeSpan.FromSeconds(2));
  return "Hello, World!";
}</pre></div><p>Another important fact is that asynchronous functions must return the <code class="literal">Task</code> or <code class="literal">Task&lt;T&gt;</code> type. It is possible to have <code class="literal">async void</code> methods, but it is preferable to use the <code class="literal">async Task</code> method instead. The only reasonable option to use <code class="literal">async void</code> functions is when using top-level UI control event handlers in your application.</p><p>Inside a method marked with the <code class="literal">async</code> keyword, you can use the <code class="literal">await</code> operator. This operator works with tasks from TPL and gets the result of the asynchronous operation inside the task. The details will be covered later in the chapter. You cannot use the <code class="literal">await</code> operator outside the <code class="literal">async</code> method; there will be a compilation error. In addition, asynchronous functions should have at least one <code class="literal">await</code> operator inside their code. However, not having an <code class="literal">await</code> operator will lead to just a compilation warning, not an error.</p><p>It is important to note that this method returns immediately after the line with the <code class="literal">await</code> call. In case of a synchronous execution, the executing thread will be blocked for 2 seconds and then return a result. Here, we wait asynchronously while returning a worker thread to a thread pool immediately after executing the <code class="literal">await</code> operator. After 2 seconds, we get the worker thread from a thread pool once again and run the rest of the asynchronous method on it. This allows us to reuse this worker thread to do some other work while these 2 seconds pass, which is extremely important for application scalability. With the help of asynchronous functions, we have a linear program control flow, but it is still asynchronous. This is both very comfortable and very confusing. The recipes in this chapter will help you learn every important aspect of asynchronous functions.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>In my experience, there is a common misunderstanding about how programs work if there are two consecutive <code class="literal">await</code> operators in it. Many people think that if we use the await function on one asynchronous operation after another, they run in parallel. However, they actually run sequentially; the second one starts only when the first operation completes. It is very important to remember this, and later in the chapter, we will cover this topic in detail.</p></div></div><p>There are a number of limitations connected with using <code class="literal">async</code> and <code class="literal">await</code> operators. In C# 5.0, for example, it<a id="id202" class="indexterm"/> is not possible to mark the console application's <code class="literal">Main</code> method as <code class="literal">async</code>; you cannot have the <code class="literal">await</code> operator inside a <code class="literal">catch</code>, <code class="literal">finally</code>, <code class="literal">lock</code>, or <code class="literal">unsafe</code> block. It is not allowed to have <code class="literal">ref</code> and <code class="literal">out</code> parameters on an asynchronous function. There <a id="id203" class="indexterm"/>are more subtleties, but these are the major points. In C# 6.0, some of these limitations have been removed; you can use <code class="literal">await</code> inside <code class="literal">catch</code> and <code class="literal">finally</code> blocks due to compiler internal enhancements.</p><p>Asynchronous functions <a id="id204" class="indexterm"/>are turned into complex program constructs by the C# compiler behind the scenes. I intentionally will not <a id="id205" class="indexterm"/>describe this in detail; the resulting code is quite similar to another C# construct, called <strong>iterators</strong>, and is implemented as a sort of state machine. Since many developers have started using the <code class="literal">async</code> modifier almost on every method, I would like to emphasize that there is no sense in marking a method <code class="literal">async</code> if it is not intended to be used in an asynchronous or parallel manner. Calling the <code class="literal">async</code> method includes a significant performance hit, and the usual method call is going to be about 40 to 50 times faster as compared to the same method marked with the <code class="literal">async</code> keyword. Please be aware of that.</p><p>In this chapter, you will learn to use the C# <code class="literal">async</code> and <code class="literal">await</code> keywords to work with asynchronous operations. We will cover how to await asynchronous operations sequentially and parallelly. We will discuss how to use <code class="literal">await</code> in lambda expressions, how to handle exceptions, and how to avoid pitfalls when using the <code class="literal">async void</code> methods. To conclude the chapter, we will dive deep into synchronization context propagation and you will learn how to create your own awaitable objects instead of using tasks.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Using the await operator to get asynchronous task results</h1></div></div></div><p>This recipe walks <a id="id206" class="indexterm"/>you through the basic scenario of using asynchronous functions. We will compare how<a id="id207" class="indexterm"/> to get an asynchronous operation result with TPL and with the <code class="literal">await</code> operator.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec119"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter5\Recipe1</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec120"/>How to do it...</h2></div></div></div><p>To use the <code class="literal">await</code> operator in order to get asynchronous task results, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div><pre class="programlisting">static Task AsynchronyWithTPL()
{
  Task&lt;string&gt; t = GetInfoAsync("Task 1");
  Task t2 = t.ContinueWith(task =&gt; WriteLine(t.Result),
    TaskContinuationOptions.NotOnFaulted);
  Task t3 = t.ContinueWith(task =&gt; WriteLine(t.Exception.InnerException),
    TaskContinuationOptions.OnlyOnFaulted);

  return Task.WhenAny(t2, t3);
}

static async Task AsynchronyWithAwait()
{
  try
  {
    string result = await GetInfoAsync("Task 2");
    WriteLine(result);
  }
  catch (Exception ex)
  {
    WriteLine(ex);
  }
}

static async Task&lt;string&gt; GetInfoAsync(string name)
{
  await Task.Delay(TimeSpan.FromSeconds(2));
  //throw new Exception("Boom!");
  return
     $"Task {name} is running on a thread id {CurrentThread.ManagedThreadId}." + 
$" Is thread pool thread: {CurrentThread.IsThreadPoolThread}";
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div><pre class="programlisting">Task t = AsynchronyWithTPL();
t.Wait();

t = AsynchronyWithAwait();
t.Wait();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec121"/>How it works...</h2></div></div></div><p>When the program<a id="id208" class="indexterm"/> runs, we run two asynchronous operations. One of them is standard TPL-powered code and the second one uses the new <code class="literal">async</code> and <code class="literal">await</code> C# features. The <code class="literal">AsynchronyWithTPL</code> method starts a task that runs for 2 seconds and then returns a string with information about the worker thread. Then, we define a continuation to print out the asynchronous operation result after the operation is complete and another one to print the exception details in case errors occur. Finally, we return a task representing one of the continuation<a id="id209" class="indexterm"/> tasks and wait for its completion in the <code class="literal">Main</code> method.</p><p>In the <code class="literal">AsynchronyWithAwait</code> method, we achieve the same result by using <code class="literal">await</code> with the task. It is as if we write just the usual synchronous code—we get the result from the task, print out the result, and catch an exception if the task is completed with errors. The key difference is that we actually have an asynchronous program. Immediately after using <code class="literal">await</code>, C# creates a task that has a continuation task with all the remaining code after the <code class="literal">await</code> operator and deals with exception propagation as well. Then, we return this task to the <code class="literal">Main</code> method and wait until it gets completed.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>Note that depending on the nature of the underlying asynchronous operation and the current synchronization context, the exact means of executing asynchronous code may differ. We will explain this later in the chapter.</p></div></div><p>Therefore, we can <a id="id210" class="indexterm"/>see that the first and the second parts of the program are conceptually equivalent, but in the second part the C# compiler does the work of handling asynchronous code implicitly. It is, in fact, even more complicated than the first part, and we will cover the details in the next few recipes of this chapter.</p><p>Remember that it is not recommended to use the <code class="literal">Task.Wait</code> and <code class="literal">Task.Result</code> methods in environments <a id="id211" class="indexterm"/>such as the Windows GUI or ASP.NET. This could lead to deadlocks if the programmer is not 100% aware of what is really going on in the code. This was illustrated in the <em>Tweaking the execution of tasks with TaskScheduler</em> recipe in <a class="link" href="ch04.html" title="Chapter 4. Using the Task Parallel Library">Chapter 4</a>, <em>Using the Task Parallel Library</em>, when we used <code class="literal">Task.Result</code> in the WPF application.</p><p>To test how exception handling works, just uncomment the <code class="literal">throw new Exception</code> line inside the <code class="literal">GetInfoAsync</code> method.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Using the await operator in a lambda expression</h1></div></div></div><p>This recipe will <a id="id212" class="indexterm"/>show you how to use <code class="literal">await</code> inside a lambda <a id="id213" class="indexterm"/>expression. We will write an anonymous method that uses <code class="literal">await</code> and get a result of the method execution asynchronously.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec122"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter5\Recipe2</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec123"/>How to do it...</h2></div></div></div><p>To write an anonymous method that uses <code class="literal">await</code> and get a result of the method execution asynchronously using the <code class="literal">await</code> operator in a lambda expression, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div><pre class="programlisting">static async Task AsynchronousProcessing()
{
  Func&lt;string, Task&lt;string&gt;&gt; asyncLambda = async name =&gt; {
    await Task.Delay(TimeSpan.FromSeconds(2));
    return
  $"Task {name} is running on a thread id {CurrentThread.ManagedThreadId}." +
  $" Is thread pool thread: {CurrentThread.IsThreadPoolThread}";
  };

  string result = await asyncLambda("async lambda");

  WriteLine(result);
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div><pre class="programlisting">Task t = AsynchronousProcessing();
t.Wait();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec124"/>How it works...</h2></div></div></div><p>First, we move out<a id="id214" class="indexterm"/> the asynchronous function into the <code class="literal">AsynchronousProcessing</code> method, since we cannot use <code class="literal">async</code> with <code class="literal">Main</code>. Then, we<a id="id215" class="indexterm"/> describe a lambda expression using the <code class="literal">async</code> keyword. As the type of any lambda expression cannot be inferred from lambda itself, we have to specify its type to the C# compiler explicitly. In our case, the type means that our lambda  expression accepts one string parameter and returns a <code class="literal">Task&lt;string&gt;</code> object.</p><p>Then, we define the lambda expression body. One aberration is that the method is defined to return a <code class="literal">Task&lt;string&gt;</code> object, but we actually return a string and get no compilation errors! The C# compiler<a id="id216" class="indexterm"/> automatically generates a task and returns it for us.</p><p>The last step is to await the<a id="id217" class="indexterm"/> asynchronous lambda expression execution and print out the result.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec51"/>Using the await operator with consequent asynchronous tasks</h1></div></div></div><p>This recipe will show<a id="id218" class="indexterm"/> you how exactly the <a id="id219" class="indexterm"/>program flows when we have several consecutive <code class="literal">await</code> methods in the code. You will learn how to read the code with the <code class="literal">await</code> method and understand why the <code class="literal">await</code> call is an asynchronous operation.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec125"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter5\Recipe3</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec126"/>How to do it...</h2></div></div></div><p>To understand a program flow in the presence of consecutive <code class="literal">await</code> methods, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div><pre class="programlisting">static Task AsynchronyWithTPL()
{
  var containerTask = new Task(() =&gt; { 
    Task&lt;string&gt; t = GetInfoAsync("TPL 1");
    t.ContinueWith(task =&gt; {
      WriteLine(t.Result);
      Task&lt;string&gt; t2 = GetInfoAsync("TPL 2");
      t2.ContinueWith(innerTask =&gt; WriteLine(innerTask.Result),
        TaskContinuationOptions.NotOnFaulted | TaskContinuationOptions.AttachedToParent);
      t2.ContinueWith(innerTask =&gt; WriteLine(innerTask.Exception.InnerException),
        TaskContinuationOptions.OnlyOnFaulted | TaskContinuationOptions.AttachedToParent);
      },
      TaskContinuationOptions.NotOnFaulted | TaskContinuationOptions.AttachedToParent);

    t.ContinueWith(task =&gt; WriteLine(t.Exception.InnerException),
      TaskContinuationOptions.OnlyOnFaulted | TaskContinuationOptions.AttachedToParent);
  });

  containerTask.Start();
  return containerTask;
}

static async Task AsynchronyWithAwait()
{
  try
  {
    string result = await GetInfoAsync("Async 1");
    WriteLine(result);
    result = await GetInfoAsync("Async 2");
    WriteLine(result);
  }
  catch (Exception ex)
  {
    WriteLine(ex);
  }
}

static async Task&lt;string&gt; GetInfoAsync(string name)
{
  WriteLine($"Task {name} started!");
  await Task.Delay(TimeSpan.FromSeconds(2));
  if(name == "TPL 2")
    throw new Exception("Boom!");
  return
  $"Task {name} is running on a thread id {CurrentThread.ManagedThreadId}." +
  $" Is thread pool thread: {CurrentThread.IsThreadPoolThread}";
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div><pre class="programlisting">Task t = AsynchronyWithTPL();
t.Wait();

t = AsynchronyWithAwait();
t.Wait();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec127"/>How it works...</h2></div></div></div><p>When the program<a id="id220" class="indexterm"/> runs, we run two asynchronous operations just as we did in the first recipe. However, this time, we shall start from the <code class="literal">AsynchronyWithAwait</code> method. It still looks like the usual synchronous code; the only difference is the two <code class="literal">await</code> statements. The most important point is that the code is still sequential, and the <code class="literal">Async 2</code> task will start only after the previous one is completed. When we read the code, the program flow is very clear: we see what runs first and what goes after. Then, how is this program asynchronous? Well, first, it is not always asynchronous. If a task is already complete when we use <code class="literal">await</code>, we will get its result synchronously. Otherwise, the common approach when we see an <code class="literal">await</code> statement inside<a id="id221" class="indexterm"/> the code is to note that at this point, the method will return immediately and the rest of the code will be run in a continuation task. Since we do not block the execution, waiting for the result of an operation, it is an asynchronous call. Instead of calling <code class="literal">t.Wait</code> in the <code class="literal">Main</code> method, we can perform any other task while the code in the <code class="literal">AsynchronyWithAwait</code> method is being executed. However, the main thread must wait until all the asynchronous operations complete, or they will be stopped as they run on background threads.</p><p>The <code class="literal">AsynchronyWithTPL</code> method imitates the same program flow as the <code class="literal">AsynchronyWithAwait</code> method does. We need a container task to handle all the dependent tasks together. Then, we start the main task and add a set of continuations to it. When the task is complete, we print out the result; we then start one more task, which in turn has more continuations to continue work after the second task is complete. To test the exception handling, we throw an exception on purpose when running the second task and get its information printed out. This set of continuations creates the same program flow as in the first method, and when we compare it to the code with the <code class="literal">await</code> methods, we can see that it is much easier to read and understand. The only trick is to remember that asynchrony does not always mean parallel execution.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Using the await operator for the execution of parallel asynchronous tasks</h1></div></div></div><p>In this recipe, you will<a id="id222" class="indexterm"/> learn how to use <code class="literal">await</code> to run asynchronous operations in parallel instead of the usual sequential execution.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec128"/>Getting ready</h2></div></div></div><p>To step through this recipe, you<a id="id223" class="indexterm"/> will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter5\Recipe4</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec129"/>How to do it...</h2></div></div></div><p>To understand the use of the <code class="literal">await</code> operator for parallel asynchronous task execution, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code below the <code class="literal">Main</code> method:<div><pre class="programlisting">static async Task AsynchronousProcessing()
{
  Task&lt;string&gt; t1 = GetInfoAsync("Task 1", 3);
  Task&lt;string&gt; t2 = GetInfoAsync("Task 2", 5);

  string[] results = await Task.WhenAll(t1, t2);
  foreach (string result in results)
  {
    WriteLine(result);
  }
}

static async Task&lt;string&gt; GetInfoAsync(string name, int seconds)
{
  await Task.Delay(TimeSpan.FromSeconds(seconds));
  //await Task.Run(() =&gt; 
  //   Thread.Sleep(TimeSpan.FromSeconds(seconds)));
  return
  $"Task {name} is running on a thread id " +
  $"{CurrentThread.ManagedThreadId}. " +
  $"Is thread pool thread: {CurrentThread.IsThreadPoolThread}";
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div><pre class="programlisting">Task t = AsynchronousProcessing();
t.Wait();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec130"/>How it works...</h2></div></div></div><p>Here, we define two<a id="id224" class="indexterm"/> asynchronous tasks running for 3 and 5 seconds, respectively. Then, we use a <code class="literal">Task.WhenAll</code> helper method to create another task that will be complete only when all of the underlying tasks get completed. Then, we await the result of this combined task. After 5 seconds, we get all the results, which means that the tasks were running simultaneously.</p><p>However, there is one interesting observation. When you run the program, you might note that both tasks are likely to be served by the same worker thread from a thread pool. How is this possible <a id="id225" class="indexterm"/>when we have run the tasks in parallel? To make things even more interesting, let's comment out the <code class="literal">await Task.Delay</code> line inside the <code class="literal">GetIntroAsync</code> method and uncomment the <code class="literal">await Task.Run</code> line, and then run the program.</p><p>We will see that in this case, both the tasks will be served by different worker threads. The difference is that <code class="literal">Task.Delay</code> uses a timer under the hood, and the processing goes as follows: we get the worker thread from a thread pool, which awaits the <code class="literal">Task.Delay</code> method to return a result. Then, the <code class="literal">Task.Delay</code> method starts the timer and specifies a piece of code that will be called when the timer counts the number of seconds specified to the <code class="literal">Task.Delay</code> method. Then, we immediately return the worker thread to a thread pool. When the timer event runs, we get any available worker thread from a thread pool once again (which could be the same thread that we used first) and run the code provided to the timer on it.</p><p>When we use the <code class="literal">Task.Run</code> method, we get a worker thread from a thread pool and make it block for a number of seconds, provided to the <code class="literal">Thread.Sleep</code> method. Then, we get a second worker thread and block it as well. In this scenario, we consume two worker threads and they do absolutely nothing, as they are not able to perform any other task while waiting.</p><p>We will talk in detail about the first scenario in <a class="link" href="ch09.html" title="Chapter 9. Using Asynchronous I/O">Chapter 9</a>, <em>Using Asynchronous I/O</em>, where we will discuss a large set of asynchronous operations working with data inputs and outputs. Using the first approach whenever possible is the key to creating scalable server applications.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Handling exceptions in asynchronous operations</h1></div></div></div><p>This recipe will describe<a id="id226" class="indexterm"/> how to deal with<a id="id227" class="indexterm"/> exception handling using asynchronous functions in C#. You will learn how to work with aggregate exceptions in case you use <code class="literal">await</code> with multiple parallel asynchronous operations.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec131"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter5\Recipe5</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec132"/>How to do it...</h2></div></div></div><p>To understand handling exceptions in asynchronous operations, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div><pre class="programlisting">static async Task AsynchronousProcessing()
{
  WriteLine("1. Single exception");

  try
  {
    string result = await GetInfoAsync("Task 1", 2);
    WriteLine(result);
  }
  catch (Exception ex)
  {
    WriteLine($"Exception details: {ex}");
  }

  WriteLine();
  WriteLine("2. Multiple exceptions");

  Task&lt;string&gt; t1 = GetInfoAsync("Task 1", 3);
  Task&lt;string&gt; t2 = GetInfoAsync("Task 2", 2);
  try
  {
    string[] results = await Task.WhenAll(t1, t2);
    WriteLine(results.Length);
  }
  catch (Exception ex)
  {
    WriteLine($"Exception details: {ex}");
  }

  WriteLine();
  WriteLine("3. Multiple exceptions with AggregateException");

  t1 = GetInfoAsync("Task 1", 3);
  t2 = GetInfoAsync("Task 2", 2);
  Task&lt;string[]&gt; t3 = Task.WhenAll(t1, t2);
  try
  {
    string[] results = await t3;
    WriteLine(results.Length);
  }
  catch
  {
    var ae = t3.Exception.Flatten();
    var exceptions = ae.InnerExceptions;
    WriteLine($"Exceptions caught: {exceptions.Count}");
    foreach (var e in exceptions)
    {
      WriteLine($"Exception details: {e}");
      WriteLine();
    }
  }

  WriteLine();
      WriteLine("4. await in catch and finally blocks");

  try
  {
    string result = await GetInfoAsync("Task 1", 2);
    WriteLine(result);
  }
  catch (Exception ex)
  {
    await Task.Delay(TimeSpan.FromSeconds(1));
    WriteLine($"Catch block with await: Exception details: {ex}");
  }
  finally
  {
     await Task.Delay(TimeSpan.FromSeconds(1));
    WriteLine("Finally block");
  }
}

static async Task&lt;string&gt; GetInfoAsync(string name, int seconds)
{
  await Task.Delay(TimeSpan.FromSeconds(seconds));
  throw new Exception($"Boom from {name}!");
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div><pre class="programlisting">Task t = AsynchronousProcessing();
t.Wait();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec133"/>How it works...</h2></div></div></div><p>We run four scenarios<a id="id228" class="indexterm"/> to illustrate the most common cases of error handling using <code class="literal">async</code> and <code class="literal">await</code> in C#. The first case is very simple and almost identical to the usual synchronous code. We just use the <code class="literal">try</code>/<code class="literal">catch</code> statement and get the exception's details.</p><p>A very common<a id="id229" class="indexterm"/> mistake is using the same approach when more than one asynchronous operations are being awaited. If we use the <code class="literal">catch</code> block in the same way as we did before, we will get only the first exception from the underlying <code class="literal">AggregateException</code> object.</p><p>To collect all the information, we have to use the awaited tasks' <code class="literal">Exception</code> property. In the third scenario, we flatten the <code class="literal">AggregateException</code> hierarchy and then unwrap all the underlying exceptions from it using the <code class="literal">Flatten</code> method of <code class="literal">AggregateException</code>.</p><p>To illustrate C# 6.0 changes, we use <code class="literal">await</code> inside <code class="literal">catch</code> and <code class="literal">finally</code> blocks of the exception handling code. To verify that it was not possible to use <code class="literal">await</code> inside <code class="literal">catch</code> and <code class="literal">finally</code> blocks in the previous version of C#, you can compile it against C# 5.0 by specifying it in the project properties under the build section advanced settings.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec54"/>Avoiding the use of the captured synchronization context</h1></div></div></div><p>This recipe<a id="id230" class="indexterm"/> discusses the details of the synchronization context behavior when <code class="literal">await</code> is used to get asynchronous operation results. You will learn how and when to turn off the synchronization context flow.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec134"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter5\Recipe6</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec135"/>How to do it...</h2></div></div></div><p>To understand the details of the synchronization context behavior when <code class="literal">await</code> is used and to learn how and when to turn off the synchronization context flow, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">Add references to the Windows Presentation Foundation Library by following these steps:<div><ol class="orderedlist arabic"><li class="listitem">Right-click on the <strong>References</strong> folder in the project, and select the <strong>Add reference…</strong> menu option.</li><li class="listitem">Add references to these libraries: <strong>PresentationCore</strong>, <strong>PresentationFramework</strong>, <strong>System.Xaml</strong>, and <strong>WindowsBase</strong>. You can use the search function in the reference manager dialog as follows:</li></ol></div><div><img src="img/B05292_05_01.jpg" alt="How to do it..."/></div></li><li class="listitem">In the <code class="literal">Program.cs</code> file, add<a id="id231" class="indexterm"/> the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Diagnostics;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using static System.Console;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div><pre class="programlisting">private static Label _label;

static async void Click(object sender, EventArgs e)
{
  _label.Content = new TextBlock {Text = "Calculating..."};
  TimeSpan resultWithContext = await Test();
  TimeSpan resultNoContext = await TestNoContext();
  //TimeSpan resultNoContext =
  //   await TestNoContext().ConfigureAwait(false);
  var sb = new StringBuilder();
  sb.AppendLine($"With the context: {resultWithContext}");
  sb.AppendLine($"Without the context: {resultNoContext}");
  sb.AppendLine("Ratio: " +
    $"{resultWithContext.TotalMilliseconds/resultNoContext.TotalMilliseconds:0.00}");
  _label.Content = new TextBlock {Text = sb.ToString()};
}

static async Task&lt;TimeSpan&gt; Test()
{
  const int iterationsNumber = 100000;
  var sw = new Stopwatch();
  sw.Start();
  for (int i = 0; i &lt; iterationsNumber; i++)
  {
    var t = Task.Run(() =&gt; { });
    await t;
  }
  sw.Stop();
  return sw.Elapsed;
}

static async Task&lt;TimeSpan&gt; TestNoContext()
{
  const int iterationsNumber = 100000;
  var sw = new Stopwatch();
  sw.Start();
  for (int i = 0; i &lt; iterationsNumber; i++)
  {
    var t = Task.Run(() =&gt; { });
    await t.ConfigureAwait(
      continueOnCapturedContext: false);
  }
  sw.Stop();
  return sw.Elapsed;
}</pre></div></li><li class="listitem">Replace the <code class="literal">Main</code> method <a id="id232" class="indexterm"/>with the following code snippet:<div><pre class="programlisting">[STAThread]
static void Main(string[] args)
{
  var app = new Application();
  var win = new Window();
  var panel = new StackPanel();
  var button = new Button();
  _label = new Label();
  _label.FontSize = 32;
  _label.Height = 200;
  button.Height = 100;
  button.FontSize = 32;
  button.Content = new TextBlock {Text = "Start asynchronous operations"};
  button.Click += Click;
  panel.Children.Add(_label);
  panel.Children.Add(button);
  win.Content = panel;
  app.Run(win);

  ReadLine();
}</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec136"/>How it works...</h2></div></div></div><p>In this example, we studied one of the most important aspects of an asynchronous function's default <a id="id233" class="indexterm"/>behavior. You already know about task schedulers and synchronization contexts from <a class="link" href="ch04.html" title="Chapter 4. Using the Task Parallel Library">Chapter 4</a>, <em>Using the Task Parallel Library</em>. By default, the <code class="literal">await</code> operator tries to capture synchronization contexts and executes the preceding code on it. As we already know, this helps us write asynchronous code by working with user interface controls. In addition, deadlock situations, such as those that were described in the previous chapter, will not happen when using <code class="literal">await</code>, since we do not block the UI thread while waiting for the result.</p><p>This is reasonable, but let's see what can potentially happen. In this example, we create a Windows Presentation Foundation application programmatically and subscribe to its button-click event. When clicking on the button, we run two asynchronous operations. One of them uses a regular <code class="literal">await</code> operator, while the other uses the <code class="literal">ConfigureAwait</code> method with <code class="literal">false</code> as a parameter value. It explicitly instructs that we should not use captured synchronization contexts to run continuation code on it. Inside each operation, we measure the time they take to complete, and then, we display the respective time and ratios on the main screen.</p><p>As a result, we see that the regular <code class="literal">await</code> operator takes much more time to complete. This is because we post 100,000 continuation tasks on the UI thread, which uses its message loop to asynchronously work with those tasks. In this case, we do not need this code to run on the UI thread, since we do not access the UI components from the asynchronous operation; using <code class="literal">ConfigureAwait</code> with <code class="literal">false</code> will be a much more efficient solution.</p><p>There is one more thing worth noting. Try to run the program by just clicking on the button and waiting for the results. Now, do the same thing again, but this time, click on the button and try to drag the application window from side to side in a random manner. You will note that the code on the captured synchronization context becomes slower! This funny side effect perfectly illustrates how dangerous asynchronous programming is. It is very easy to experience a situation like this, and it would be almost impossible to debug it if you have never experienced such a behavior before.</p><p>To be fair, let's see the <a id="id234" class="indexterm"/>opposite scenario. In the preceding code snippet, inside the <code class="literal">Click</code> method, uncomment the commented line and comment out the line immediately preceding it. When running the application, we will get a multithreaded control access exception because the code that sets the <code class="literal">Label</code> control text will not be posted on the captured context, but it will be executed on a thread pool worker thread instead.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec55"/>Working around the async void method</h1></div></div></div><p>This recipe describes why <code class="literal">async void</code> methods are quite dangerous to use. You will learn in what <a id="id235" class="indexterm"/>situations it is acceptable to use this method and what to use instead, when possible.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec137"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter5\Recipe7</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec138"/>How to do it...</h2></div></div></div><p>To learn how to work with the <code class="literal">async void</code> method, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div><pre class="programlisting">static async Task AsyncTaskWithErrors()
{
  string result = await GetInfoAsync("AsyncTaskException", 2);
  WriteLine(result);
}

static async void AsyncVoidWithErrors()
{
  string result = await GetInfoAsync("AsyncVoidException", 2);
  WriteLine(result);
}

static async Task AsyncTask()
{
  string result = await GetInfoAsync("AsyncTask", 2);
  WriteLine(result);
}

static async void AsyncVoid()
{
  string result = await GetInfoAsync("AsyncVoid", 2);
  WriteLine(result);
}

static async Task&lt;string&gt; GetInfoAsync(string name, int seconds)
{
  await Task.Delay(TimeSpan.FromSeconds(seconds));
  if(name.Contains("Exception"))
    throw new Exception($"Boom from {name}!");
  return
  $"Task {name} is running on a thread id {CurrentThread.ManagedThreadId}." +
  $" Is thread pool thread: {CurrentThread.IsThreadPoolThread}";
}</pre></div></li><li class="listitem">Add the<a id="id236" class="indexterm"/> following code snippet inside the <code class="literal">Main</code> method:<div><pre class="programlisting">Task t = AsyncTask();
t.Wait();

AsyncVoid();
Sleep(TimeSpan.FromSeconds(3));

t = AsyncTaskWithErrors();
while(!t.IsFaulted)
{
  Sleep(TimeSpan.FromSeconds(1));
}
WriteLine(t.Exception);

//try
//{
//  AsyncVoidWithErrors();
//  Thread.Sleep(TimeSpan.FromSeconds(3));
//}
//catch (Exception ex)
//{
//  Console.WriteLine(ex);
//}

int[] numbers = {1, 2, 3, 4, 5};
Array.ForEach(numbers, async number =&gt; {
  await Task.Delay(TimeSpan.FromSeconds(1));
  if (number == 3) throw new Exception("Boom!");
  WriteLine(number);
});

ReadLine();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec139"/>How it works...</h2></div></div></div><p>When the program <a id="id237" class="indexterm"/>starts, we start two asynchronous operations by calling the two methods, <code class="literal">AsyncTask</code> and <code class="literal">AsyncVoid</code>. The first method returns a <code class="literal">Task</code> object, while the other returns nothing since it is declared <code class="literal">async void</code>. They both return immediately since they are asynchronous, but then, the first one can be easily monitored with the returned task status or just by calling the <code class="literal">Wait</code> method on it. The only way to wait for the second method to complete is to literally wait for some time because we have not declared any object that we can use to monitor the state of the asynchronous operation. Of course, it is possible to use some kind of shared state variable and set it from the <code class="literal">async void</code> method while checking it from the <code class="literal">calling</code> method, but it is better to just return a <code class="literal">Task</code> object instead.</p><p>The most dangerous part is exception handling. In case of the <code class="literal">async void</code> method, an exception will be posted to a current synchronization context; in our case, a thread pool. An unhandled exception on a thread pool will terminate the whole process. It is possible to intercept unhandled exceptions using the <code class="literal">AppDomain.UnhandledException</code> event, but there is no way to recover the process from there. To experience this, we should uncomment the <code class="literal">try</code>/<code class="literal">catch</code> block inside the <code class="literal">Main</code> method and then run the program.</p><p>Another fact about using <code class="literal">async void</code> lambda expressions is that they are compatible with the <code class="literal">Action</code> type, which is widely used in the standard .NET Framework class library. It is very easy to forget about exception handling inside this lambda expression, which will crash the program again. To see an example of this, uncomment the second commented-out block inside the <code class="literal">Main</code> method.</p><p>I strongly recommend<a id="id238" class="indexterm"/> using <code class="literal">async void</code> only in UI event handlers. In all other situations, use the methods that return <code class="literal">Task</code> instead.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec56"/>Designing a custom awaitable type</h1></div></div></div><p>This recipe <a id="id239" class="indexterm"/>shows you how to design a very basic awaitable type that is compatible with the <code class="literal">await</code> operator.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec140"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter5\Recipe8</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec141"/>How to do it...</h2></div></div></div><p>To design a custom awaitable type, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div><pre class="programlisting">static async Task AsynchronousProcessing()
{
  var sync = new CustomAwaitable(true);
  string result = await sync;
  WriteLine(result);

  var async = new CustomAwaitable(false);
  result = await async;

  WriteLine(result);
}

class CustomAwaitable
{
  public CustomAwaitable(bool completeSynchronously)
  {
    _completeSynchronously = completeSynchronously;
  }

  public CustomAwaiter GetAwaiter()
  {
    return new CustomAwaiter(_completeSynchronously);
  }

  private readonly bool _completeSynchronously;
}

class CustomAwaiter : INotifyCompletion
{
  private string _result = "Completed synchronously";
  private readonly bool _completeSynchronously;

  public bool IsCompleted =&gt; _completeSynchronously;

  public CustomAwaiter(bool completeSynchronously)
  {
    _completeSynchronously = completeSynchronously;
  }

  public string GetResult()
  {
    return _result;
  }

  public void OnCompleted(Action continuation)
  {
    ThreadPool.QueueUserWorkItem( state =&gt; {
      Sleep(TimeSpan.FromSeconds(1));
      _result = GetInfo();
      continuation?.Invoke();
    });
  }

  private string GetInfo()
  {
    return
    $"Task is running on a thread id {CurrentThread.ManagedThreadId}." +
    $" Is thread pool thread: {CurrentThread.IsThreadPoolThread}";
  }
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div><pre class="programlisting">Task t = AsynchronousProcessing();
t.Wait();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec142"/>How it works...</h2></div></div></div><p>To be compatible <a id="id240" class="indexterm"/>with the <code class="literal">await</code> operator, a type should comply with a number of requirements that are stated in the C# language specification. If you have Visual Studio 2015 installed, you may find the specifications document inside the <code class="literal">C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC#\Specifications\1033</code> folder (assuming you have a 64-bit OS and used the default installation path).</p><p>In paragraph 7.7.7.1, we find a definition of awaitable expressions:</p><p><em>The task of an </em><code class="literal">await</code><em> expression is required to be awaitable. An expression </em><code class="literal">t</code><em> is awaitable if one of the following holds:</em></p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">t</code><em> is of compile time type dynamic</em></li><li class="listitem" style="list-style-type: disc"><code class="literal">t</code><em> has an accessible instance or extension method called </em><code class="literal">GetAwaiter</code><em> with no parameters and no type parameters, and a return type </em><code class="literal">A</code><em> for which all of the following hold:</em><div><ol class="orderedlist arabic"><li class="listitem"><code class="literal">A</code><em> implements the interface </em><code class="literal">System.Runtime.CompilerServices.INotifyCompletion</code><em> (hereafter known as </em><code class="literal">INotifyCompletion</code><em> for brevity).</em></li><li class="listitem"><code class="literal">A</code><em> has an accessible, readable instance property </em><code class="literal">IsCompleted</code><em> of type </em><code class="literal">bool</code>.</li><li class="listitem"><code class="literal">A</code><em> has an accessible instance method </em><code class="literal">GetResult</code><em> with no parameters and no type parameters</em>.</li></ol></div></li></ul></div><p>This information is enough to get started. First, we define an awaitable type <code class="literal">CustomAwaitable</code> and implement the <code class="literal">GetAwaiter</code> method. This in turn returns an instance of the <code class="literal">CustomAwaiter</code> type. <code class="literal">CustomAwaiter</code> implements the <code class="literal">INotifyCompletion</code> interface, has the <code class="literal">IsCompleted</code> property of the type <code class="literal">bool</code>, and has the <code class="literal">GetResult</code> method, which returns a <code class="literal">string</code> type. Finally, we write a piece of code that creates two <code class="literal">CustomAwaitable</code> objects and awaits both of them.</p><p>Now, we should understand the way <code class="literal">await</code> expressions are evaluated. This time, the specifications have not been quoted to avoid unnecessary details. Basically, if the <code class="literal">IsCompleted</code> property returns <code class="literal">true</code>, we just call the <code class="literal">GetResult</code> method synchronously. This prevents us from allocating resources for asynchronous task execution if the operation has<a id="id241" class="indexterm"/> already been completed. We cover this scenario by providing the <code class="literal">completeSynchronously</code> parameter to the constructor method of the <code class="literal">CustomAwaitable</code> object.</p><p>Otherwise, we register a callback action to the <code class="literal">OnCompleted</code> method of <code class="literal">CustomAwaiter</code> and start the asynchronous operation. When it gets completed, it calls the provided callback, which will get the result by calling the <code class="literal">GetResult</code> method on the <code class="literal">CustomAwaiter</code> object.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>This implementation has been used for educational purposes only. Whenever you write asynchronous functions, the most natural approach is to use the standard <code class="literal">Task</code> type. You should define your own awaitable type only if you have a solid reason why you cannot use <code class="literal">Task</code> and you know exactly what you are doing.</p></div></div><p>There are many other topics related to designing custom awaitable types, such as the <code class="literal">ICriticalNotifyCompletion</code> interface implementation and synchronization context propagation. After understanding the basics of how an awaitable type is designed, you will be able to use the C# language specification and other information sources to find out the details you need with ease. But I would like to emphasize that you should just use the <code class="literal">Task</code> type, unless you have a really good reason not to.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec57"/>Using the dynamic type with await</h1></div></div></div><p>This recipe <a id="id242" class="indexterm"/>shows you how to design a very basic type that is <a id="id243" class="indexterm"/>compatible with the <code class="literal">await</code> operator and the dynamic C# type.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec143"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. You will need Internet access to download the NuGet package. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter5\Recipe9</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec144"/>How to do it...</h2></div></div></div><p>To learn how to<a id="id244" class="indexterm"/> use the <code class="literal">dynamic</code> type with <code class="literal">await</code>, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">Add references<a id="id245" class="indexterm"/> to the <strong>ImpromptuInterface</strong> NuGet package by following these steps:<div><ol class="orderedlist arabic"><li class="listitem">Right-click on the <strong>References</strong> folder in the project, and select the <strong>Manage NuGet Packages…</strong> menu option.</li><li class="listitem">Now, add your preferred references to the <strong>ImpromptuInterface NuGet</strong> package. You can use the search function in the <strong>Manage NuGet Packages</strong> dialog as follows:</li></ol></div><div><img src="img/B05292_05_02.jpg" alt="How to do it..."/></div></li><li class="listitem">In the<a id="id246" class="indexterm"/> <code class="literal">Program.cs</code> file, use the following <code class="literal">using</code> directives:<div><pre class="programlisting">using System;
using System.Dynamic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using ImpromptuInterface;
using static System.Console;
using static System.Threading.Thread;</pre></div></li><li class="listitem">Add the<a id="id247" class="indexterm"/> following code snippet below the <code class="literal">Main</code> method:<div><pre class="programlisting">static async Task AsynchronousProcessing()
{
  string result = await GetDynamicAwaitableObject(true);
  WriteLine(result);

  result = await GetDynamicAwaitableObject(false);
  WriteLine(result);
}

static dynamic GetDynamicAwaitableObject(bool completeSynchronously)
{
  dynamic result = new ExpandoObject();
  dynamic awaiter = new ExpandoObject();

  awaiter.Message = "Completed synchronously";
  awaiter.IsCompleted = completeSynchronously;
  awaiter.GetResult = (Func&lt;string&gt;)(() =&gt; awaiter.Message);

  awaiter.OnCompleted = (Action&lt;Action&gt;) ( callback =&gt; 
    ThreadPool.QueueUserWorkItem(state =&gt; {
      Sleep(TimeSpan.FromSeconds(1));
      awaiter.Message = GetInfo();
      callback?.Invoke();
    })
  );

  IAwaiter&lt;string&gt; proxy = Impromptu.ActLike(awaiter);

  result.GetAwaiter = (Func&lt;dynamic&gt;) ( () =&gt; proxy );

  return result;
}

static string GetInfo()
{
  return
    $"Task is running on a thread id {CurrentThread.ManagedThreadId}." +
    $" Is thread pool thread: {CurrentThread.IsThreadPoolThread}";
}</pre></div></li><li class="listitem">Add the<a id="id248" class="indexterm"/> following code below the <code class="literal">Program</code> class<a id="id249" class="indexterm"/> definition:<div><pre class="programlisting">public interface IAwaiter&lt;T&gt; : INotifyCompletion
{
    bool IsCompleted { get; }

    T GetResult();
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div><pre class="programlisting">Task t = AsynchronousProcessing();
t.Wait();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec145"/>How it works...</h2></div></div></div><p>Here, we repeat the<a id="id250" class="indexterm"/> trick from the previous recipe but this time, with the help of dynamic expressions. We can achieve this goal with the help of NuGet—a package manager that contains many useful libraries. This time, we use a library that dynamically creates wrappers, implementing the interfaces we need.</p><p>To start with, we create two instances of the <code class="literal">ExpandoObject</code> type and assign them to dynamic local variables. These variables will be our <code class="literal">awaitable</code> and <code class="literal">awaiter</code> objects. Since an <code class="literal">awaitable</code> object just requires having the <code class="literal">GetAwaiter</code> method, there are no problems with providing it. <code class="literal">ExpandoObject</code> (combined with the <code class="literal">dynamic</code> keyword) allows us to customize<a id="id251" class="indexterm"/> itself and add properties and methods by assigning corresponding values. It is in fact a dictionary-type collection with keys of the type <code class="literal">string</code> and values of the type <code class="literal">object</code>. If you are familiar with the JavaScript programming language, you might note that this is very similar to JavaScript objects.</p><p>Since <code class="literal">dynamic</code> allows us to skip compile-time checks in C#, <code class="literal">ExpandoObject</code> is written in such a way that if you assign something to a property, it creates a dictionary entry, where the key is the property name and a value is any value that is supplied. When you try to get the property value, it goes into the dictionary and provides the value that is stored in the corresponding dictionary entry. If the value is of the type <code class="literal">Action</code> or <code class="literal">Func</code>, we actually store a delegate, which in turn can be used like a method. Therefore, a combination of the <code class="literal">dynamic</code> type with <code class="literal">ExpandoObject</code> allows us to create an object and dynamically provide it with properties and methods.</p><p>Now, we need to construct our <code class="literal">awaiter</code> and <code class="literal">awaitable</code> objects. Let's start with <code class="literal">awaiter</code>. First, we provide a property called <code class="literal">Message</code> and an initial value to this property. Then, we define the <code class="literal">GetResult</code> method using a <code class="literal">Func&lt;string&gt;</code> type. We assign a lambda expression, which returns the <code class="literal">Message</code> property value. We then implement the <code class="literal">IsCompleted</code> property. If it is set to <code class="literal">true</code>, we can skip the rest of the work and proceed to our <code class="literal">awaitable</code> object that is stored in the <code class="literal">result</code> local variable. We just need to add a method returning the <code class="literal">dynamic</code> object and return our <code class="literal">awaiter</code> object from it. Then, we can use <code class="literal">result</code> as the <code class="literal">await</code> expression; however, it will run synchronously.</p><p>The main challenge is implementing asynchronous processing on our dynamic object. The C# language specifications state that an <code class="literal">awaiter</code> object must implement the <code class="literal">INotifyCompletion</code> or <code class="literal">ICriticalNotifyCompletion</code> interface, which <code class="literal">ExpandoObject</code> does not. And even when we implement the <code class="literal">OnCompleted</code> method dynamically, adding it to the <code class="literal">awaiter</code> object, we will not succeed because our object does not implement<a id="id252" class="indexterm"/> either of the aforementioned interfaces.</p><p>To work around this<a id="id253" class="indexterm"/> problem, we use the <code class="literal">ImpromptuInterface</code> library that we obtained from NuGet. It allows us to use the <code class="literal">Impromptu.ActLike</code> method to dynamically create proxy objects that will implement the required interface. If we try to create a proxy implementing the <code class="literal">INotifyCompletion</code> interface, we will still fail because the <code class="literal">proxy</code> object is not dynamic anymore, and this interface has the <code class="literal">OnCompleted</code> method only, but it does not have the <code class="literal">IsCompleted</code> property or the <code class="literal">GetResult</code> method. As the last workaround, we define a generic interface, <code class="literal">IAwaiter&lt;T&gt;</code>, which implements <code class="literal">INotifyCompletion</code> and adds all the required properties and methods. Now, we use it for proxy generation and change the <code class="literal">result</code> object to return a <code class="literal">proxy</code> instead of <code class="literal">awaiter</code> from the <code class="literal">GetAwaiter</code> method. The program now works; we just constructed an <code class="literal">awaitable</code> object that is completely dynamic at runtime.</p></div></div></body></html>