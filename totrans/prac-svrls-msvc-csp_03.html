<html><head></head><body>
<div><h1 class="chapterNumber"><a id="_idTextAnchor067"/>3</h1>
<h1 class="chapterTitle" id="_idParaDest-52"><a id="_idTextAnchor068"/>Setup and Theory: Docker and Onion Architecture</h1>
<p class="normal">This chapter discusses two important building blocks of modern microservices architectures, which will be used in most of the book’s examples, as follows:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Docker Containers</strong>: Docker containers<a id="_idIndexMarker151"/> are a virtualization tool that enables your microservices to run on a wide range of hardware platforms, preventing compatibility issues.</li>
<li class="bulletList"><strong class="keyWord">The Onion Architecture</strong>: The Onion Architecture<a id="_idIndexMarker152"/> confines dependencies from both the <strong class="keyWord">user interface</strong> (<strong class="keyWord">UI</strong>) and from the deployment platform in drivers so that the <a id="_idIndexMarker153"/>software modules that encode the whole business knowledge are completely independent of the chosen UI, tools, and runtime environment. Moreover, in order to optimize the interaction between domain experts and developers, all domain entities are implemented as classes in the following way:<ol class="numberedList level-2" style="list-style-type: decimal;">
<li class="numberedList level-2" value="1">Each entity interacts with the remainder of the code only through methods that represent the behavior of all actual domain entities.</li>
<li class="numberedList level-2">Names of entities and entity members are taken from the vocabulary of the application domain. The purpose is to build up a common language between developers and users called <a id="_idIndexMarker154"/>the <strong class="keyWord">ubiquitous language</strong>.</li>
</ol>
</li>
</ul>
<p class="normal">While Docker containers are roughly tied to microservice performance optimization, the Onion Architecture is not specific for microservices. However, the Onion Architecture described here was designed specifically for use with microservices, as it makes wide use of some of the microservice-specific patterns we described in <a href="Chapter_2.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a><em class="italic">, Demystifying Microservices Applications</em>, such as publisher-subscriber events, to maximize the independence of software modules and to ensure separation between update and query software modules.</p>
<p class="normal">In this chapter, we will introduce a Visual Studio solution template based on the Onion Architecture along with code snippets that we will use throughout the remainder of the book for implementing any kind of microservice. We will discuss both the theory behind it and its pros.</p>
<p class="normal">More specifically, this chapter covers the followi<a id="_idTextAnchor069"/>ng:</p>
<ul>
<li class="bulletList">The Onion Architecture</li>
<li class="bulletList">A solution template based on the Onion Architect<a id="_idTextAnchor070"/>ure</li>
<li class="bulletList">Containers and Docker</li>
</ul>
<p class="normal">By the end of the chapter, you should be able to create an application based on the Onion Architecture and work with Docker containers, which are the building blocks of complex microservices applications.</p>
<h1 class="heading-1" id="_idParaDest-53"><a id="_idTextAnchor071"/>Technical requirements</h1>
<p class="normal">This chapter requires the following:</p>
<ol>
<li class="numberedList" value="1">At a minimum, the Visual Studio 2022 free <em class="italic">Community edition</em>.</li>
<li class="numberedList"><strong class="keyWord">Docker Desktop</strong> for Windows (<a href="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a>)</li>
<li class="numberedList"><strong class="keyWord">Docker Desktop</strong>, in turn, requires <strong class="keyWord">Windows Subsystem for Linux (WSL)</strong>, which can be installed by following these steps:<ol class="numberedList level-2" style="list-style-type: decimal;">
<li class="numberedList level-2" value="1">Type <code class="codeHighlighted" style="font-weight: bold;">powershell</code> in the Windows 10/11 search bar.</li>
<li class="numberedList level-2">When Windows PowerShell is proposed as a search result, click on <strong class="screenText">Run as an administrator</strong>.</li>
<li class="numberedList level-2">In the Windows PowerShell administrative console that appears, run the <code class="codeHighlighted" style="font-weight: bold;">wsl --install</code> command.</li>
</ol>
</li>
</ol>
<p class="normal">You can find the sample code for this chapter at <a href="https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp">https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp</a>.</p>
<h1 class="heading-1" id="_idParaDest-54"><a id="_idTextAnchor072"/>The Onion Architecture</h1>
<p class="normal">The Onion Architecture makes a clear <a id="_idIndexMarker155"/>distinction between domain-specific code and the technical code that handles the UI, storage interaction, and hardware resources. This keeps the domain-specific code completely independent of technical tools, such as the operating system, web technology, database, and database interaction tools.</p>
<p class="normal">The whole <a id="_idIndexMarker156"/>application is organized into layers, with the outermost layer having the sole purpose of providing all the necessary infrastructure (i.e., drivers), UI, and test suites, as shown in the following figur<a id="_idTextAnchor073"/>e:</p>
<figure class="mediaobject"><img alt="Figure 3.1: Basic Onion Architecture" src="img/B31916_03_1.png"/></figure>
<p class="packt_figref">Figure 3.1: Basic Onion Architecture</p>
<p class="normal">In turn, the application-specific code is organized into several more nested layers. All layers must satisfy the following constraint:</p>
<div><p class="normal"> Each layer may reference only inner layers. The way this constraint is implemented depends on the underlying language and stack. For instance, layers can be implemented as packages, namespaces, or libraries. We will implement layers with .NET library projects that can be easily turned into NuGet packages, too.</p>
</div>
<p class="normal">So, for instance, in the preceding figure, the outermost layer may reference all application-specific libraries, plus all libraries that implement all the required drivers.</p>
<p class="normal">The application-specific code references the functionalities implemented in the outermost layer’s drivers through interfaces, while the outermost layer has the main function of providing a dependency injection engine that couples each of these interfaces with a driver that implements it:</p>
<pre class="programlisting code"><code class="hljs-code">...
builder.Services.AddScoped&lt;IMyFunctionalityInterface1, MyFunctionalityImplementation1&gt;();
builder.Services.AddScoped&lt;IMyFunctionalityInterface2, MyFunctionalityImplementation2&gt;();
...
</code></pre>
<p class="normal">The application-specific <a id="_idIndexMarker157"/>layer, in turn, is composed of at least two main layers: a layer that contains all domain entity definitions, called<a id="_idIndexMarker158"/> the <strong class="keyWord">Domain layer</strong>, and a layer that contains the definition of all application operations, called the <strong class="keyWord">Application Services</strong> layer, as<a id="_idIndexMarker159"/> shown in the following figure:</p>
<figure class="mediaobject"><img alt="Figure 3.2: Complete Onion Architecture" src="img/B31916_03_2.png"/></figure>
<p class="packt_figref">Figure 3.2: Complete Onion Architecture</p>
<p class="normal">If needed, the Application Services layer can be split into more sublayers, and more layers can be placed between the Application Services and Domain layers, but this is rarely done.</p>
<p class="normal">The Domain layer is often split into two<a id="_idIndexMarker160"/> sublayers: <strong class="keyWord">the Model layer,</strong> which contains the actual domain entity definitions, and the <strong class="keyWord">Domain Services</strong> layer, which contains <a id="_idIndexMarker161"/>further business rules.</p>
<p class="normal">Throughout this book, we will use just the Application Services and Domain layers. We will discuss each of them in a separate subsection.</p>
<h2 class="heading-2" id="_idParaDest-55"><a id="_idTextAnchor074"/>The Domain layer</h2>
<p class="normal">The Domain layer contains the<a id="_idIndexMarker162"/> class representation of each domain entity with its behavior encoded in the public method of such classes.</p>
<p class="normal">Moreover, domain entities can be modified just with methods that represent actual domain operations. Thus, for instance, we can’t directly access and modify all fields of a purchase order; we are limited to manipulating it just through methods that represent actual domain operations, such as adding or deleting an item, applying a discount, or modifying the delivery date.</p>
<p class="normal">The names of all public methods and properties must be<a id="_idIndexMarker163"/> built with the actual language used by the domain experts, the previously mentioned <strong class="keyWord">ubiquitous language</strong>.</p>
<p class="normal">All the preceding constraints have the purpose of optimizing communication between developers and experts. In this way, domain experts and developers can discuss the public interface of the entity since it uses the same vocabulary and actual domain operations.</p>
<p class="normal">The following is a part of a hy<a id="_idTextAnchor075"/>pothetical <code class="inlineCode">PurchaseOrde</code>r entity:</p>
<pre class="programlisting code"><code class="hljs-code">  public class PurchaseOrder
    {
      …
      #region private members
      private IList&lt;PurchaseOrderItem&gt; items;
      private DateTime _deliveryTime;
      #endregion
      public PurchaseOrder(DateTime creationTime, DateTime deliveryTime)
        {
          CreationTime = creationTime;
          _deliveryTime = deliveryTime;
          items=new List&lt;PurchaseOrderItem&gt;();
        }
      public DateTime CreationTime {get; init;}
      public DateTime DeliveryTime =&gt; _deliveryTime;
      public IEnumerable&lt;PurchaseOrderItem&gt; Items =&gt; items;
      public bool DelayDelyveryTime(DateTime newDeliveryTime)
        {
          if(_deliveryTime&lt; newDeliveryTime)
            {
              _deliveryTime = newDeliveryTime;
              return true;
            }
          else return false;
        }
      public void AddItem (PurchaseOrderItem x)
        { items.Add(x); }
      public void RemoveItem(PurchaseOrderItem x)
        { items.Remove(x); }
       …
  }
</code></pre>
<p class="normal">Once taken <a id="_idIndexMarker164"/>from the constructor, <code class="inlineCode">CreationTime</code> cannot be modified anymore, so it is implemented as a {<code class="inlineCode">get; init;}</code> property. The list of all items can be modified through the <code class="inlineCode">AddItem</code> and <code class="inlineCode">RemoveItem</code> methods, which are understandable by all domain experts. Finally, we can delay the delivery date but we can’t anticipate it. This automatically encodes a domain business rule by enforcing the use of the <code class="inlineCode">DelayDeliveryTime</code> method.</p>
<p class="normal">We can improve the <code class="inlineCode">PurchaseOrde</code>r entity by adding a <code class="inlineCode">PurchaseTotal</code> <strong class="keyWord">get property</strong> that returns the total amount of the purchase, and by adding an <code class="inlineCode">ApplyDiscount</code> method.</p>
<p class="normal">Summing up, we can state the following rule:</p>
<div><p class="normal"> Domain entity states can only be changed through methods that encode actual domain operations and that automatically enforce all business rules.</p>
</div>
<p class="normal">These entities differ a lot from the<a id="_idIndexMarker165"/> usual <strong class="keyWord">Entity Framework Core</strong> entities we are used to for the following reasons:</p>
<ul>
<li class="bulletList">Entity Framework Core entities are record-like classes with no methods. That is, they are just a set of property-value pairs.</li>
<li class="bulletList">Each Entity Framework Core entity corresponds to a single object related somehow to other entities, while domain entities are often trees of nested objects. That is why domain entities are usually <a id="_idIndexMarker166"/>called <strong class="keyWord">aggregates</strong>.</li>
</ul>
<p class="normal">Thus, for instance, the <code class="inlineCode">PurchaseOrder</code> aggregate contains a main<a id="_idTextAnchor076"/> entity and a <code class="inlineCode">PurchaseOrderItem</code> collection. It is worth pointing out that <code class="inlineCode">PurchaseOrderItem</code> cannot be considered a separate domain entity since there are no domain operations that involve a single <code class="inlineCode">PurchaseOrderItem</code>, but <code class="inlineCode">PurchaseOrderItem</code> can be manipulated just as a part of <code class="inlineCode">PurchaseOrder</code>.</p>
<p class="normal">A similar phenomenon doesn’t occur with flat Entity Framework entities, as they lack the concept of domain operations. We may conclude the following:</p>
<div><p class="normal"> Domain operations on domain entities can force them to merge with dependent entities, thus becoming a complex tree of objects <a id="_idIndexMarker167"/>called <strong class="keyWord">aggregates</strong>.</p>
</div>
<p class="normal">For the <a id="_idIndexMarker168"/>remainder of this book, we will refer to domain entities as aggregates.</p>
<p class="normal">So far, we have given entities a strong application domain semantic together with the concept of aggregation. These aggregates differ a lot from database tuples and also from their object representation provided by ORMS such as Entity Framework Core, so we have a mismatch between aggregates and the structures used to persist them. This mismatch could be solved in several ways, but all solutions must conform to <a id="_idIndexMarker169"/>the <strong class="keyWord">persistence ignorance</strong> principle:</p>
<div><p class="normal"> Aggregates must not be impacted by how they might be persisted. They must be completely decoupled from the persistence code, and the persistence technique must not impose any constraint on the aggregate design.</p>
</div>
<p class="normal">We now observe another phenomenon: entities without an identity!</p>
<p class="normal">Two purchase orders with exactly the same dates and items remain two different entities; in fact, they must have a different delivery for each of them.</p>
<p class="normal">However, what happens with two addresses containing exactly the same fields? If we consider the semantics of an address, can we say they are two different entities?</p>
<p class="normal">Each address denotes a place, and if two addresses have the same fields, they denote exactly the same place. Thus, addresses are just like numbers: even though we may replicate them several times, each copy always denotes the same abstract entity.</p>
<p class="normal">Therefore, we may conclude that addresses with the same fields are indistinguishable. Relational databases use principal keys to verify when two tuples reference the same abstract entity, so we may conclude that the principal key of an address should be the set of all its fields.</p>
<p class="normal">In the theory of domain entities, objects similar to addresses are called value objects, and their in-memory representation must not contain explicit principal keys. An equality operator applied to two instances of them must return <code class="codeHighlighted" style="font-weight: bold;">true</code> if and only if all their fields are equal. Moreover, they must be immutable – that is, once created, t<a id="_idTextAnchor077"/>heir properties cannot be changed, so the only way to modify a value object is to create a new object with some property value changed.</p>
<p class="normal">In C#, value objects are easily represented <a id="_idIndexMarker170"/>with <strong class="keyWord">records</strong>:</p>
<pre class="programlisting code"><code class="hljs-code">public record Address
{
  public string Country {get; init;}
  public string Town {get; init;}
  public string Street {get; init;}
}
</code></pre>
<p class="normal">The <code class="inlineCode">init</code> keyword is<a id="_idIndexMarker171"/> what makes record-type properties immutable since it means they can only be</p>
<p class="normal">initialized. A modified copy of a record can be created as follows:</p>
<pre class="programlisting code"><code class="hljs-code">var modifiedAddress = myAddress with {Street = "new street"};
</code></pre>
<p class="normal">If we pass all the properties in the constructor instead of using initializers, the preceding definition can be simplified as follows:</p>
<pre class="programlisting code"><code class="hljs-code">public record Address(string Country, string Town, string Street) ;
</code></pre>
<p class="normal">Typical value objects include costs (represented as a number and a currency symbol), locations (represented as longitude and latitude), addresses, and contact information.</p>
<p class="normal">In practice, value objects can be represented in databases with the usual tuple with a principal key (for instance, an autoincremented integer). Then, a new copy of each tuple can be created differently for each occurrence of the same address. It is also possible to enforce a unique database copy by defining complex composite keys.</p>
<div><p class="normal"> Since aggregates and value objects differ a lot from the entities used by all main ORMs such as Entity Framework, when we use ORMS to interact with databases, we must translate ORM entities into aggregates and value objects, and vice versa, each time we exchange data with an ORM.</p>
</div>
<p class="normal">According to general Onion <a id="_idIndexMarker172"/>Architecture rules, the Domain layer interacts with the actual implementation provided by an ORM through an interface. This is usually done with the so-called <strong class="keyWord">repository pattern</strong>.</p>
<div><p class="normal"> According to the repository pattern, a storage service must be provided through one separate interface for each aggregate.</p>
</div>
<p class="normal">This means the Domain layer must contain a different interface for each aggregate, which takes care of retrieving, saving, and deleting the whole aggregate. The repository pattern helps keep the code modular and easy to search and update since we know we must have one and only one repository interface for each aggregate, so we can organize the whole aggregate-related code in a single folder.</p>
<p class="normal">The actual implementation of each repository is contained in the Infrastructure layer of the Onion Architecture in a kind of database (or persistence) driver, together with various other drivers that virtualize the interaction with the infrastructure.</p>
<p class="normal">Each aggregate repository interface contains methods that return aggregates, delete aggregates, and make any other kind of persistency-related operations on aggregates.</p>
<p class="normal">In complex applications, it is best practice to split the Domain layer into a Model layer, which contains just aggregates, and an outer Domain Services layer, which contains the repository interfaces and the definition of domain operations that can’t be implemented as aggregate methods.</p>
<p class="normal">In particular, <strong class="keyWord">Domain Services</strong> interfaces <a id="_idIndexMarker173"/>handle the tuples used to encode the results <a id="_idIndexMarker174"/>returned by query microservices. These tuples are not aggregates but a mix of data taken from different data tables, so they conform to a completely different design pattern. They are returned as record-like objects with no methods and just properties that correspond to the database tuples fields. Further <strong class="keyWord">Domain Services</strong> interfaces are implemented in the persistence driver of the infrastructure layer, too.</p>
<p class="normal">Handling queries and <a id="_idIndexMarker175"/>modifications separately and with different design patterns is known as the <strong class="keyWord">Command Query Responsibility Segregation (CQRS</strong>) pattern.</p>
<div><p class="normal"> Since, the microservices described in this book are quite simple, in our code examples, we will not split the domain layer into the model and domain services layers. Therefore, the repository and other domain services interfaces will be mixed with aggregates in the same Visual Studio project. However, when implementing more complex applications, you should use the division of the domain layer into the model and domain services layers.</p>
</div>
<p class="normal">Let’s look at some examples of a repository interface. The <code class="inlineCode">PurchaseOrder</code> aggregate might have an associated repository interface that looks as follows:</p>
<pre class="programlisting code"><code class="hljs-code">    public interface IPurchaseOrderRepository
    {
      PurchaseOrder New(DateTime creationTime, DateTime deliveryTime);
      Task&lt;PurchaseOrder&gt; GetAsync(long id);
      Task DeleteAsync(long id);
      Task DeleteAsync(PurchaseOrder order);
      Task&lt;IEnumerable&lt;OrderBasicInfoDTO&gt;&gt; GetMany(DateTime? startPeriod,
            DateTime? endPeriod, int? customerId
            );
         ...
    }
</code></pre>
<p class="normal">There is no update method since updates are implemented by directly calling the aggregate methods. The last method in the code shown returns a collection of record-like DTOs called <code class="inlineCode">OrderBasicInfoDTO</code>.</p>
<div><p class="normal"> It is worth pointing out that there are no repository interfaces associated with value objects since value objects are handled just as primitive types, such as integers, decimals, or strings.</p>
</div>
<p class="normal">Several changes to different aggregates can be dealt with in a transactional way thanks to the <strong class="keyWord">Unit Of Work</strong> pattern, which will be<a id="_idIndexMarker176"/> described later on in the <em class="italic">Command</em> subsection.</p>
<p class="normal">More details on how Entity Framework Core supports the implementation of repository interfaces and on how domain objects are tied and translated back and forth to Entity Framework Core en<a id="_idTextAnchor078"/>tities will be given in the<em class="italic"> A solution template based on the Onion Architecture </em>section.</p>
<p class="normal">Having understood the in-memory representation of domain objects, we can move on to the way a microservices-oriented Onion Architecture represents all business transactions/operations.</p>
<h2 class="heading-2" id="_idParaDest-56"><a id="_idTextAnchor079"/>Application services</h2>
<p class="normal">In the <em class="italic">Microservices organization </em>subsection of<em class="italic"> </em><a href="Chapter_2.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a><em class="italic">, Demystifying Microservices Applications</em>, we saw that microservices architectures <a id="_idIndexMarker177"/>often <a id="_idIndexMarker178"/>use the <strong class="keyWord">CQRS</strong> pattern, which is where some microservices specialize in queries and others specialize in updates. That is the strong version of the CQRS pattern, but there is also a weaker version that simply requires that queries and updates be organized into different modules, possibly belonging to the same microservice.</p>
<p class="normal">While it is not always convenient to apply CQRS in its stronger form, its weaker form is a must when implementing microservices, as updates involve aggregates while queries involve just record-like DTOs, so they require completely different types of processing.</p>
<p class="normal">Accordingly, the operations defined in the application services layer of a microservice are split into two different types: <strong class="keyWord">queries </strong>and <strong class="keyWord">commands</strong>. As we will see, the execution of commands can trigger events, so together with commands and queries, application services must also handle so-called <strong class="keyWord">domain events</strong>. We will discuss all these different operations in the dedicated subsections that follow.</p>
<h3 class="heading-3" id="_idParaDest-57"><a id="_idTextAnchor080"/>Queries</h3>
<p class="normal">A query object represents one <a id="_idIndexMarker179"/>or several similar queries, so it usually has one or several methods that take some inputs and return the query results. Most query methods just call a single repository method that implements the needed query, but in some cases, they may execute several repository methods and then they may somehow merge their results.</p>
<p class="normal">During system testing, actual query implementations must be replaced by fake implementations, so, usually, each query has an associated interface that is coupled with the actual implementation in the dependency injection engine. This way, the UI may just require the interface in some constructor, thus enabling testing with a fake implementation of the query.</p>
<p class="normal">The following is a possible definition<a id="_idIndexMarker180"/> of a query that returns all purchase orders emitted after a given date, together with its associated interface:</p>
<pre class="programlisting code"><code class="hljs-code">public interface IPurchaseOrderByStartDateQuery: IQuery
{
  Task&lt;IEnumerable&lt;OrderBasicInfoDTO&gt;&gt; Execute(DateTime startDate);
}
public class PurchaseOrderByStartDateQuery(IPurchaseOrderRepository repo):
  IPurchaseOrderByStartDateQuery
{
  public async Task&lt;IEnumerable&lt;OrderBasicInfoDTO&gt;&gt; Execute(DateTime startDate)
  {
    return await repo.GetMany(startDate, null, null);
  }
}
</code></pre>
<p class="normal">The interface inherits from an empty interface whose unique purpose is to mark both the interface and its implementation as queries. This way, all queries and their associated implementation can be automatically found with the help of reflection and added to the dependency injection engine. We will provide the code that discovers all queries in the <em class="italic">A solution template based on the Onion Architecture </em>section together with a complete solution template.</p>
<p class="normal">As mentioned, the implementation just calls a repository method and passes it adequate parameters. An implementation of the repository is passed in the principal constructor of the class by the same dependency injection engine that will inject the query itself in the constructor of a presentation layer object (a controller, in the case of an ASP.NET Core website).</p>
<h3 class="heading-3" id="_idParaDest-58"><a id="_idTextAnchor081"/>Commands</h3>
<p class="normal">Commands work in a slightly <a id="_idIndexMarker181"/>different way because, for better code readability, each command represents a single application operation. For this reason, each command instance represents both the abstract operation and its input. The actual operation implementation is contained in a command handler object. The following is the code of a hypothetical command that applies a discount to a purchase order:</p>
<pre class="programlisting code"><code class="hljs-code">public record ApplyDiscountCommand(decimal discount, long orderId): ICommand;
</code></pre>
<p class="normal">Commands <a id="_idIndexMarker182"/>must be immutable; that’s why we implanted them as records. In fact, the only operation allowed on them is their execution. Similar to queries, commands also implement an empty interface that marks them as commands (in this case, <code class="inlineCode">ICommand</code>).</p>
<p class="normal">Command handlers are implementations of the following interface:</p>
<pre class="programlisting code"><code class="hljs-code">    public interface ICommandHandler {}
    public interface ICommandHandler&lt;T&gt;: ICommandHandler
        where T: ICommand
    {
      Task HandleAsync(T command);
    }
</code></pre>
<p class="normal">As you can, see all command handlers implement the same <code class="inlineCode">HandleAsync</code> method that accepts the command as its single input. Thus, for instance, the handler associated with <code class="inlineCode">ApplyDiscountCommand</code> is something like the following class:</p>
<pre class="programlisting code"><code class="hljs-code">public class ApplyDiscountCommandHandler(
IPackageRepository repo):ICommandHandler&lt;ApplyDiscountCommand&gt;
  {
    public async Task HandleAsync(ApplyDiscountCommand command)
      {
        var purchaseOrder = await repo.GetAsync(command.OrderId);
 //call adequate aggregate methods to apply the required update
//possibly modify other aggregates by getting them with other
        //injected repositories
        ...
      }
    }
</code></pre>
<p class="normal">All handlers must be added to the dependency injection engine, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddScoped&lt;ICommandHandler&lt;ApplyDiscountCommand&gt;,
 ApplyDiscountCommandHandler&gt;();
</code></pre>
<p class="normal">This can be done automatically by scanning the application services assembly with reflection. We will provide the code that discovers all command handlers in the <em class="italic">A solution template based on the Onion Architecture </em>section.</p>
<p class="normal">Each command handler gets or creates aggregates, modifies them by calling their methods, and then executes a save instruction to persist all modifications in the underlying storage.</p>
<p class="normal">The save operation must be implemented in the storage driver (for instance, Entity Framework Core), so, as usual for all Onion Architecture drivers’ operations, it is mediated by an interface. The inter<a id="_idTextAnchor082"/>face that performs the save operations and other transaction-related operations is usually called <strong class="keyWord">IUnitOfWork</strong>. A possible definition of this interface is as follows:</p>
<pre class="programlisting code"><code class="hljs-code">public interface IUnitOfWork
  {
    Task&lt;bool&gt; SaveEntitiesAsync();
    Task StartAsync();
    Task CommitAsync();
    Task RollbackAsync(<a id="_idTextAnchor083"/>);
  }
</code></pre>
<p class="normal">Let’s break this down:</p>
<ul>
<li class="bulletList"><code class="inlineCode">SaveEntitiesAsync</code> saves all updaters performed so far in a single transaction. It returns <code class="inlineCode">true</code> if the storage engine actually changed after the save operation, and <code class="inlineCode">false</code> otherwise.</li>
<li class="bulletList"><code class="inlineCode">StartAsync</code> starts a transaction.</li>
<li class="bulletList"><code class="inlineCode">CommitAsync</code> and <code class="inlineCode">RollbackAsync</code> respectively commit and rol<a id="_idTextAnchor084"/>l back an opened transaction.</li>
</ul>
<p class="normal">All methods that<a id="_idIndexMarker183"/> explicitly control the start and end of a transaction are useful for enclosing both a get operation and the final <code class="inlineCode">SaveEntitiesAsync</code> save in the same transaction, as in the following simplified flight reservation snippet:</p>
<pre class="programlisting code"><code class="hljs-code">await unitOfWork.StartAsync();
var flight = await repo.GetFlightAsync(flightId);
flight.Seats--;
if(flight.Seats &lt; 0)
{
  await unitOfWork.RollBackAsync();
  return;
}
...
await unitOfWork.SaveEntitiesAsync();
await unitOfWork.CommitAsync();
</code></pre>
<p class="normal">If there are no more available seats, the transaction is aborted, but if there are available seats, we are sure that no other passenger can take the available seat because both the query and the update are performed in the same transaction, thus preventing interference from other reservation operations.</p>
<p class="normal">Of course, the preceding code works if the transaction has an adequate isolation level and if the database supports that isolation level. We can use a high enough isolation level for all operations in our<a id="_idIndexMarker184"/> microservice; otherwise, we are forced to pass the isolation level as a <code class="inlineCode">StartAsync</code> argument.</p>
<p class="normal">Now, we are ready to explain why domain events are needed, and how they are handled.</p>
<h3 class="heading-3" id="_idParaDest-59"><a id="_idTextAnchor085"/>Domain events</h3>
<p class="normal">We may define <strong class="keyWord">domain events</strong> as<a id="_idIndexMarker185"/> follows:</p>
<div><p class="normal"> <strong class="keyWord">Domain events</strong> are events <a id="_idIndexMarker186"/>originating from something happening in the microservice domain and are handled within the boundaries of the microservice itself. This means they involve communications based on the publisher-subscriber pattern between two chunks of code of the same microservice.</p>
</div>
<p class="normal">Therefore, they must not be confused with the events involved in the communications between different microservices, which are <a id="_idIndexMarker187"/>called <strong class="keyWord">integration events</strong> to distinguish them from domain events.</p>
<p class="normal">Why use events inside the boundaries of a microservice? The reason is always the same: to ensure a better decoupling between parts. Here, the parts involved are aggregates. The code of each aggregate must be completely independent of other aggregates to ensure modularity and modifiability, so relations between aggregates are either mediated by command handlers or by some publisher-subscriber pattern.</p>
<p class="normal">Accordingly, if the interaction between two aggregates is somehow decided by the code of a command handler, the same command handler might take care of processing the data of both of them and then somehow update them. However, if the interaction is tied to the processing within an aggregate method, we are forced to use events because we can’t make an aggregate aware of all the other aggregates that need to be informed about some of its data changes. Summing up, we may state the following principle:</p>
<div><p class="normal"> Domain events are triggered just inside aggregate methods because other kinds of interactions are better handled by command handlers’ code.</p>
</div>
<p class="normal">Another important principle is the following:</p>
<div><p class="normal"> Events triggered inside an aggregate method must not interfere with the ongoing method processing because these might undermine the contract between the aggregate and the command handlers that manipulate it.</p>
</div>
<p class="normal">Accordingly, each aggregate stores all events inside of it in an events list, and then the command handler decides when to execute these handlers. Typically, all events of all aggregates processed by a command handler are executed just before the handler saves all changes by calling <code class="inlineCode">unitOfWork.SaveEntitiesAsync()</code>. However, this is not a general rule.</p>
<p class="normal">Events are handled in a similar way to commands, the only difference being that each command has just one associated handler, while each event may have several subscriptions attached to it. Luckily, this difficulty can be easily handled with some advanced features of the .NET dependency injection engine.</p>
<p class="normal">More specifically, events are classes marked with the empty <code class="inlineCode">IEventNotification</code> interface, while event handlers are an implementation of the following interface:</p>
<pre class="programlisting code"><code class="hljs-code">public interface IEventHandler
{
}
public interface IEventHandler&lt;T&gt;: IEventHandler
    where T: IEventNotification
  {
    Task HandleAsync(T ev);
  }
</code></pre>
<p class="normal">All data structures <a id="_idIndexMarker188"/>involved are completely analogous to the ones needed to handle commands. However, now we must add some enhancements to associate each event with all its handlers. The following generic class does the trick:</p>
<pre class="programlisting code"><code class="hljs-code">public class EventTrigger&lt;T&gt;
        where T: IEventNotification
  {
    private readonly IEnumerable&lt;IEventHandler&lt;T&gt;&gt; _handlers;
    public EventTrigger(IEnumerable&lt;IEventHandler&lt;T&gt;&gt; handlers)
      {
        _handlers = handlers;
      }
      public async Task Trigger(T ev)
      {
        foreach (var handler in _handlers)
          await handler.HandleAsync(ev);
      }
  }
</code></pre>
<p class="normal">Here, <code class="inlineCode">IEventNotification</code> is an empty interface used just to mark a class as representing an event.</p>
<p class="normal">If we add the preceding generic class to the dependency injection engine with <code class="inlineCode">service.AddScoped(typeof(EventTrigge&lt;&gt;))</code>, then whenever we require a specific instance of this class (say, for the <code class="inlineCode">MyEvent</code> event generic argument), the dependency injection engine will automatically retrieve all <code class="inlineCode">IEventHandler&lt;MyEvent&gt;</code> implementations and will pass it in the constructor of the <code class="inlineCode">EventTrigger&lt;MyEvent&gt;</code> instance being returned. After that, we may launch all subscribed handlers with something like the following:</p>
<pre class="programlisting code"><code class="hljs-code">public class MyCommandHandler(EventTrigger&lt;MyEvent&gt; myEventHandlers): …
{
  public async Task HandleAsync(MytCommand command)
  {
    …
    await myEventHandlers.Trigger(myEvent)
    …
   }
}
</code></pre>
<p class="normal">It is worth pointing <a id="_idIndexMarker189"/>out that the <code class="inlineCode">IEventNotification</code> interface must be defined in the domain layer since it must use aggregates, while all other interfaces and classes connected to events are defined in the application services DLL.</p>
<p class="normal">As an example of an event, let’s consider a purchase order aggregate of an e-commerce application. When the purchase order is finalized by calling its <code class="inlineCode">Finalize</code> method, if the purchase is greater than a given threshold, then an event must be created for adding some scores to the user profiles that the user can spend to get discounts on further purchases.</p>
<p class="normal">The following<a id="_idTextAnchor086"/> figure exemplifies what happens:</p>
<figure class="mediaobject"><img alt="Figure 3.3: Domain event example" src="img/B31916_03_3.png"/></figure>
<p class="packt_figref">Figure 3.3: Domain event example</p>
<p class="normal">As in the case of <a id="_idIndexMarker190"/>command handlers, all event handlers defined in the application services DLL can be automatically discovered and added to the dependency injection engine through reflection. We will show how to do it in the next section, which will propose a general .NET solution template for the Onion Architecture.</p>
<h1 class="heading-1" id="_idParaDest-60"><a id="_idTextAnchor087"/>A solution template based on the Onion Architecture</h1>
<p class="normal">In this section, we describe a solution template<a id="_idIndexMarker191"/> based on the Onion Architecture that we will use throughout the remainder of the book, which you can find in the <code class="inlineCode">ch03</code> folder of the book’s GitHub repository (<a href="https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp">https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp</a>). This template shows how to put into practice what you have learned about the Onion Architecture.</p>
<p class="normal">The solution contains two .NET library projects, called <code class="inlineCode">ApplicationServices</code> and <code class="inlineCode">DomainLayer</code>, which implement, respectively, the application services and domai<a id="_idTextAnchor088"/>n layers of an Onion Architecture:</p>
<figure class="mediaobject"><img alt="Figure 3.4: Solution template based on the Onion Architecture" src="img/B31916_03_4.png"/></figure>
<p class="packt_figref">Figure 3.4: Solution template based on the Onion Architecture</p>
<p class="normal">As prescribed by the Onion Architecture, the <code class="inlineCode">ApplicationServices</code> project has a reference to the <code class="inlineCode">DomainLayer</code> architecture project.</p>
<p class="normal">In <code class="inlineCode">ApplicationServices</code>, we added the following folders:</p>
<ul>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;">Queries</code> to place all queries and query interfaces</li>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;">Commands</code> to place all command classes</li>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;">CommandHandlers</code> to place all command handlers</li>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;">EventHandlers</code> to place all event handlers</li>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;">Tools</code>, which contains all Onion Architecture-related interfaces used by the application services we described in the previous section</li>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;">Extensions</code>, which contains the <code class="inlineCode">HandlersDIExtensions.AddApplicationServices()</code> extension method that adds all queries, event handlers, and command handlers defined in the project to the dependency injection engine</li>
</ul>
<p class="normal">All the preceding folders can be organized into subfolders to increase the code readability.</p>
<p class="normal">In the <code class="inlineCode">DomainLayer</code> project, we added the following folders:</p>
<ul>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;">Models</code> to place all aggregates and value objects</li>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;">Events</code> to place all events that may be raised by the aggregates</li>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;">Tools</code>, which contains all Onion Architecture-related interfaces used by the domain we described in the previous section, and some further utility classes</li>
</ul>
<p class="normal">The <code class="inlineCode">Extensions</code> folder of the <code class="inlineCode">ApplicationServices</code> project contains just one file:</p>
<figure class="mediaobject"><img alt="Figure 3.5: ApplicationServices extensions" src="img/B31916_03_5.png"/></figure>
<p class="packt_figref">Figure 3.5: ApplicationServices extensions</p>
<p class="normal">The <code class="inlineCode">HandlersDIExtensions</code> static class contains two overloads of an extension method, which adds all queries, command<a id="_idIndexMarker192"/> handlers, event handlers, and the <code class="inlineCode">EventMediator</code> class to the dependency injection engine:</p>
<pre class="programlisting code"><code class="hljs-code">public static IServiceCollection AddApplicationServices
  (this IServiceCollection services, Assembly assembly)
{
  AddAllQueries(services, assembly);
  AddAllCommandHandlers(services, assembly);
  AddAllEventHandlers(services, assembly);
  services.AddScoped&lt;EventMediator&gt;();
  return services;
}
public static IServiceCollection AddApplicationServices
  (this IServiceCollection services)
{
  return AddApplicationServices(services,
    typeof(HandlersDIExtensions).Assembly);
}
</code></pre>
<p class="normal">It uses three different private methods that scan the assembly with reflection, looking respectively for queries, command handlers, and event handlers. The full code is available in the <code class="inlineCode">ch03</code> folder of the GitHub repository associated with the book. Here, we analyze just <code class="inlineCode">AddAllCommandHandlers</code> to show the basic ideas exploited by all three methods:</p>
<pre class="programlisting code"><code class="hljs-code">private static IServiceCollection AddAllCommandHandlers
  (this IServiceCollection services, Assembly assembly)
{
  var handlers = assembly.GetTypes()
    .Where(x =&gt; !x.IsAbstract &amp;&amp; x.IsClass
      &amp;&amp; typeof(ICommandHandler).IsAssignableFrom(x));
  …
</code></pre>
<p class="normal">First of all, we collect all <a id="_idIndexMarker193"/>nonabstract classes that implement the <code class="inlineCode">ICommandHandler</code> empty interface. This interface was specifically added to all command handlers to retrieve all of them with reflection. Then, for each of them, we retrieve the <code class="inlineCode">ICommandHandler&lt;T&gt;</code> that it implements:</p>
<pre class="programlisting code"><code class="hljs-code">foreach (var handler in handlers)
{
  var handlerInterface = handler.GetInterfaces()
    .Where(i =&gt; i.IsGenericType &amp;&amp;typeof(
      ICommandHandler).IsAssignableFrom(i))
    .SingleOrDefault();
</code></pre>
<p class="normal">Finally, if we find such an interface, we add the pair to the dependency injection engine:</p>
<pre class="programlisting code"><code class="hljs-code">foreach (var handler in handlers)
{
  …
  if (handlerInterface != null)
  {
    services.AddScoped(handlerInterface, handler);
  }
}
</code></pre>
<p class="normal">The <code class="inlineCode">Tools</code> folder of the <code class="inlineCode">ApplicationServices</code> project contains the files shown here:</p>
<figure class="mediaobject"><img alt="Figure 3.6: ApplicationServices tools" src="img/B31916_03_6.png"/></figure>
<p class="packt_figref">Figure 3.6: ApplicationServices tools</p>
<p class="normal">We already analyzed all interfaces and classes contained in the preceding <code class="codeHighlighted" style="font-weight: bold;">Tools</code> folder, except <code class="inlineCode">EventMediator</code> in the previous section. Let’s recall them:</p>
<ul>
<li class="bulletList"><code class="inlineCode">IQuery</code> and <code class="inlineCode">ICommand</code> are empty interfaces that mark, respectively, queries and commands</li>
<li class="bulletList"><code class="inlineCode">ICommandHandler&lt;T&gt; </code>and<code class="inlineCode"> IEventHandler&lt;T&gt; </code>are the interfaces that must be implemented, respectively, by<a id="_idTextAnchor089"/> command handlers and event handlers</li>
<li class="bulletList"><code class="inlineCode">EventTrigger&lt;T&gt; </code>is the class that does the magic of collecting all event handlers associated with the same event, <code class="inlineCode">T</code></li>
</ul>
<p class="normal"><code class="inlineCode">EventMediator</code> is a utility <a id="_idIndexMarker194"/>class that solves a practical problem. A command handler that needs to trigger all event handlers associated with an event, <code class="inlineCode">T</code>, must inject <code class="inlineCode">EventTrigger&lt;T&gt;</code> in its constructor. However, the point is that a command discovers that it needs to trigger the <code class="inlineCode">T</code> event just when it finds the <code class="inlineCode">T</code> event in the event lists of an aggregate, so it should inject all possible <code class="inlineCode">EventTrigger&lt;T&gt;</code> in its constructor.</p>
<p class="normal">To overcome this problem, the <code class="inlineCode">EventMediator</code> class uses <code class="inlineCode">IServiceProvide</code>r to require the event handlers associated with a list of events it is passed in its <code class="inlineCode">TriggerEvents(IEnumerable&lt;IEventNotification&gt; events)</code> method.</p>
<p class="normal">Accordingly, it is enough to inject <code class="inlineCode">EventMediator</code> in the constructor of each command handler so that whenever it finds a nonempty event list, <code class="inlineCode">L</code>, in an aggregate, it can simply call the following:</p>
<pre class="programlisting code"><code class="hljs-code">await<a id="_idTextAnchor090"/> eventMediator.TriggerEvents(L);
</code></pre>
<p class="normal">Once <code class="inlineCode">EventMediator</code> receives the preceding call, it scans the event list to discover all the events contained in it, then for each of them, it requires the corresponding <code class="inlineCode">EventTrigger&lt;T&gt;</code> to get all associated event handlers, and finally, it executes all retrieved handlers, passing them the corresponding events.</p>
<p class="normal">To perform its job, the <code class="inlineCode">EventMediator</code> class requires <code class="inlineCode">IServiceProvider</code> in its constructor:</p>
<pre class="programlisting code"><code class="hljs-code">public class EventMediator
{
  readonly IServiceProvider services;
  public EventMediator(IServiceProvider services)
  {
    this.services = services;
  }
  ...
</code></pre>
<p class="normal">Then, it uses this service provider to require each needed <code class="inlineCode">EventTrigger&lt;T&gt;</code>:</p>
<pre class="programlisting code"><code class="hljs-code">public async Task TriggerEvents(IEnumerable&lt;IEventNotification&gt; events)
  {
    if (events == null) return;
    foreach(var ev in events)
    {
      var triggerType = typeof(EventTrigger&lt;&gt;).MakeGenericType(
        ev.GetType());
      var trigger = services.GetService(triggerType);
</code></pre>
<p class="normal">Finally, it invokes the <code class="inlineCode">EventTrigger&lt;T&gt;.Trigger</code> methods with reflection:</p>
<pre class="programlisting code"><code class="hljs-code">var task = (Task)triggerType.GetMethod(nameof(
  EventTrigger&lt;IEventNotification&gt;.Trigger))
  .Invoke(trigger, new object[] { ev });
await task.ConfigureAwait(false);
</code></pre>
<p class="normal">The<a id="_idIndexMarker195"/> following is the full code of the <code class="inlineCode">EventMediator</code> class:</p>
<pre class="programlisting code"><code class="hljs-code">public class EventMediator
{
  readonly IServiceProvider services;
  public EventMediator(IServiceProvider services)
  {
    this.services = services;
  }
  public async Task TriggerEvents(IEnumerable&lt;IEventNotification&gt; events)
  {
    if (events == null) return;
    foreach(var ev in events)
    {
      var triggerType = typeof(EventTrigger&lt;&gt;).MakeGenericType(
        ev.GetType());
      var trigger = services.GetService(triggerType);
      var task = (Task)triggerType.GetMethod(nameof(
        EventTrigger&lt;IEventNotification&gt;.Trigger))
        .Invoke(trigger, new object[] { ev });
      await task;
    }
  }
}
</code></pre>
<p class="normal">The <code class="inlineCode">Tools</code> folder of the <code class="inlineCode">DomainLayer</code> project contains the following files:</p>
<figure class="mediaobject"><img alt="Figure 3.7: DomainLayer tools" src="img/B31916_03_7.png"/></figure>
<p class="packt_figref">Figure 3.7: DomainLayer tools</p>
<p class="normal"><code class="inlineCode">IEventNotification</code> and <code class="inlineCode">IRepository</code> are empty interfaces that mark, respectively, events and repository interfaces. We<a id="_idIndexMarker196"/> already discussed them in the previous section. We also already discussed <code class="inlineCode">IUnitOfWork</code>, which is the interface needed by command handlers to persist changes and handle transactions.</p>
<p class="normal"><code class="inlineCode">Entity&lt;T&gt;</code> is a class that all aggregates must inherit from:</p>
<pre class="programlisting code"><code class="hljs-code">public abstract class Entity&lt;K&gt;
    where K: IEquatable&lt;K&gt;
{
  public virtual K Id {get; protected set; } = default!;
  public bool IsTransient()
  {
    return Object.Equals(Id, default(K));
  }
  &gt;Domain events handling region
  &gt;Override Equal region
}
</code></pre>
<p class="normal">The preceding class contains two minimized code regions. The <code class="inlineCode">K</code> generic parameter is the type of the aggregate’s <code class="inlineCode">Id</code> principal key.</p>
<p class="normal">The <code class="inlineCode">IsTransient()</code> method returns <code class="inlineCode">true</code> if the aggregate has not been assigned a principal key yet.</p>
<p class="normal"><code class="inlineCode">Override Equal region</code> contains the code that overrides the <code class="inlineCode">Equal</code> method and defines equality and inequality operators. The redefined <code class="inlineCode">Equal</code> method considers equal two instances if and only if they have the same principal key.</p>
<p class="normal"><code class="codeHighlighted" style="font-weight: bold;">Domain events handling region</code> handles the list of events triggered during all calls to the aggregate methods. The exploded code is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">#region domain events handling
public List&lt;IEventNotification&gt; DomainEvents { get; private set; } = null!;
public void AddDomainEvent(IEventNotification evt)
{
  DomainEvents ??= new List&lt;IEventNotification&gt;();
  DomainEvents.Add(evt);
}
public void RemoveDomainEvent(IEventNotification evt)
{
  DomainEvents?.Remove(evt);
}
#endregion
</code></pre>
<p class="normal">We don’t need an <a id="_idIndexMarker197"/>abstract class for value objects because, as discussed in the previous section, the .NET <code class="inlineCode">record</code> type perfectly represents all value type features.</p>
<p class="normal">Before discussing in more detail how to connect the two library projects of the template with the actual storage drivers and with an actual UI, we need to understand how to handle the mismatch between aggregates and record-like ORM classes. We will do this in the dedicated subsection that follows.</p>
<h2 class="heading-2" id="_idParaDest-61"><a id="_idTextAnchor091"/>Matching aggregates and ORM entities</h2>
<p class="normal">There are several techniques to match<a id="_idIndexMarker198"/> ORM entities and aggregates. The simplest one consists of implementing the aggregates with the ORM entities themselves. The main difficulty with this approach is that aggregates do not expose the properties that must match the database fields as public properties. However, since they usually expose them as private fields, we may try to use these private fields for the database field mapping if the chosen ORM supports mapping with private properties.</p>
<p class="normal">Entity Framework Core supports the mapping with private fields, but if we are looking for complete independence from the database driver, we can’t rely on this peculiarity of Entity Framework Core. Moreover, this approach forces us to define the ORM entities in the domain layer since they are also aggregates. This means that we can’t decorate the class member with ORM-specific attributes and that we need to worry about how the class will be used by the ORM while defining each aggregate, thus undermining independence from a specific storage driver.</p>
<p class="normal">A better approach is the <strong class="keyWord">state object</strong> approach:</p>
<ol>
<li class="numberedList" value="1">We associate each aggregate with an interface that stores the state of the aggregate in its properties. This way, instead of using private backing fields, the aggregate uses the properties of this interface.</li>
<li class="numberedList">The state interface is passed in the constructor of the aggregate and then stored in a private <code class="inlineCode">readonly</code> property.</li>
<li class="numberedList">The ORM entity associated with the aggregate implements this interface. This way, the database driver adapts to the aggregates and not vice versa, thus achieving the required independence of the Domain layer from the database driver.</li>
<li class="numberedList">When the domain layer requires either a new fresh aggregate or an aggregate already stored in the database through a repository interface method, the database implementation of the repository method creates or retrieves the corresponding ORM entity and then creates a new aggregate, passing this ORM entity in its constructor as a state object.</li>
<li class="numberedList">When the aggregates are modified, all their modifications are reflected on their state objects, which, being ORM entities, are tracked by the ORM. Therefore, when we instruct the ORM to save all changes, all aggregates’ changes are automatically passed to the underlying database because these changes are stored in tracked objects.</li>
</ol>
<p class="normal">The following figure<a id="_idIndexMarker199"/> shows the preceding flow:</p>
<figure class="mediaobject"><img alt="Figure 3.8: Aggregates lifecycle" src="img/B31916_03_8.png"/></figure>
<p class="packt_figref">Figure 3.8: Aggregates lifecycle</p>
<p class="normal">Let’s try to modify our previous <code class="inlineCode">PurchaseOrder</code> aggregate by using the following state interface:</p>
<pre class="programlisting code"><code class="hljs-code">public interface IPurchaseOrderState
{
  public DateTime CreationTime { get; set; }
  public DateTime DeliveryTime { get; set; }
  public ICollection&lt;PurchaseOrderItem&gt; Items { get; set; }
  …
}
</code></pre>
<p class="normal">Modifications <a id="_idIndexMarker200"/>are straightforward and do not increase the complexity of the code:</p>
<pre class="programlisting code"><code class="hljs-code">public class PurchaseOrder
{
  private readonly IPurchaseOrderState _state;
  public PurchaseOrder(IPurchaseOrderState state)
  {
    _state = state;
  }
  public DateTime CreationTime =&gt; _state.CreationTime;
  public DateTime DeliveryTime =&gt; _state.DeliveryTime;
  public IEnumerable&lt;PurchaseOrderItem&gt; Items =&gt; _state.Items;
  public bool DelayDelyveryTime(DateTime newDeliveryTime)
  {
    if(_state.DeliveryTime &lt; newDeliveryTime)
    {
      _state.DeliveryTime = newDeliveryTime;
      return true;
    }
    else return false;
    }
    public void AddItem (PurchaseOrderItem x)
    { _state.Items.Add(x); }
    public void RemoveItem(PurchaseOrderItem x)
    { _state.Items.Remove(x); }
}
</code></pre>
<p class="normal">Now, we are ready to understand how to connect the two projects of our template with an actual database driver and an actual UI.</p>
<h2 class="heading-2" id="_idParaDest-62"><a id="_idTextAnchor092"/>A complete solution based on the Onion Architecture</h2>
<p class="normal">The <em class="italic">ch03</em> folder of the book’s GitHub repository (<a href="https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp">https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp</a>) contains <a id="_idIndexMarker201"/>a complete solution, which, together with the application services and domain layer libraries, also features a database driver based on Entity Framework Core and a presentation layer based on an ASP.NET Core Web API project.</p>
<p class="normal">The purpose of this project is to show how to use the general Onion Architecture template described in this section in an actual solution.</p>
<p class="normal">The following figure shows the complete solution:</p>
<figure class="mediaobject"><img alt="Figure 3.9: A complete solution based on the Onion Architecture" src="img/B31916_03_9.png"/></figure>
<p class="packt_figref">Figure 3.9: A complete solution based on the Onion Architecture</p>
<p class="normal">The <code class="inlineCode">DBDrive</code>r project is a .NET library project where we added a dependency on the following Nuget packages:</p>
<ul>
<li class="bulletList"><code class="inlineCode">Microsoft.EntityFrameworkCore.SqlServer</code>: This package loads both Entity Framework Core and its SQL Server provider</li>
<li class="bulletList"><code class="inlineCode">Microsoft.EntityFrameworkCore.Tools</code>: This package provides all tools for scaffolding and handling database migrations</li>
</ul>
<div><p class="normal"> Since the <code class="inlineCode">DBDriver</code> project must provide a storage driver, it also has a dependency on the domain library project.</p>
</div>
<p class="normal">The <code class="inlineCode">WebApi</code> project is <a id="_idIndexMarker202"/>an ASP.NET Core Web API project. It works as the outermost layer of the Onion Architecture.</p>
<div><p class="normal">The outermost layer of the Onion Architecture (in our example, <code class="inlineCode">WebApi</code>) must have a dependency on the application services directory and all drivers’ projects (in our example, just <code class="inlineCode">DBDrive</code>r).</p>
</div>
<p class="normal">We added some folders and classes to the <code class="inlineCode">DBDriver</code> project that should be used in all drivers based on Entity Framework Core. The following figure shows the project structure:</p>
<figure class="mediaobject"><img alt="Figure 3.10: DBDriver project structure" src="img/B31916_03_10.png"/></figure>
<p class="packt_figref">Figure 3.10: DBDriver project structure</p>
<p class="normal">Here is the description of all the folders:</p>
<ul>
<li class="bulletList"><code class="inlineCode">Entities</code>: Put all your Entity Framework Core entities here, possibly organized in subfolders.</li>
<li class="bulletList"><code class="inlineCode">Repositories</code>: Put all repository implementations here, possibly organized in subfolders.</li>
<li class="bulletList"><code class="inlineCode">MainDbContext</code>: This is the skeleton of the project Entity Framework DB context, which also contains the implementation of the <code class="inlineCode">IUnitOfWork</code> interface.</li>
<li class="bulletList"><code class="inlineCode">Extensions</code>: This folder contains two extension classes. <code class="inlineCode">RepositoryExtensions</code> just provides the <code class="inlineCode">AddAllRepositories</code> extension method, which discovers all repository implementations and adds them to the dependency injection engine. Its code is similar to one of the <code class="inlineCode">AddAllCommandHandlers</code> extension methods that we described in the previous subsection, so we will not describe it here. <code class="inlineCode">DBExtension</code> contains just the <code class="inlineCode">AddDbDriver</code> extension method, which adds all implementations provided by <code class="inlineCode">DBDriver</code> to the dependency injection engine.</li>
</ul>
<p class="normal">The implementation<a id="_idIndexMarker203"/> of the <code class="inlineCode">AddDbDriver</code> extension method is straightforward:</p>
<pre class="programlisting code"><code class="hljs-code">public static IServiceCollection AddDbDriver(
  this IServiceCollection services,
  string connectionString)
{
  services.AddDbContext&lt;IUnitOfWork, MainDbContext&gt;(options =&gt;
    options.UseSqlServer(connectionString,
      b =&gt; b.MigrationsAssembly("DBDriver")));
  services.AddAllRepositories(typeof(DBExtensions).Assembly);
  return services;
}
</code></pre>
<p class="normal">It accepts the database connection string as its only input and adds the <code class="inlineCode">MainDbContext</code> Entity Framework context as implementation for the <code class="inlineCode">IUnitOfWork</code> interface with the usual <code class="inlineCode">AddDbContext </code>Entity Framework Core extension method. Then, it calls the <code class="inlineCode">AddAllRepositories</code> method to add all repository implementations provided by <code class="inlineCode">DBDriver</code>.</p>
<p class="normal">Here is the <code class="inlineCode">MainDbContext</code> class:</p>
<pre class="programlisting code"><code class="hljs-code">internal class MainDbContext : DbContext, IUnitOfWork
{
  public MainDbContext(DbContextOptions options)
    : base(options)
    {
    }
  protected override void OnModelCreating(ModelBuilder builder)
   {
  }
  region IUnitOfWork Implementation
}
</code></pre>
<p class="normal">The class is defined as internal since it must not be visible outside of the database driver. All entity configurations must be placed inside the <code class="inlineCode">OnModelCreating</code> method as usual.</p>
<p class="normal">The implementation of <code class="inlineCode">IUnitOfWork</code> is minimized. The exploded code is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">#region IUnitOfWork Implementation
public async Task&lt;bool&gt; SaveEntitiesAsync()
{
  return await SaveChangesAsync() &gt; 0; ;
}
public async Task StartAsync()
{
  await Database.BeginTransactionAsync();
}
public Task CommitAsync()
{
  return Database.CommitTransactionAsync();
}
public Task RollbackAsync()
{
  return Database.RollbackTransactionAsync();
}
#endregion
</code></pre>
<p class="normal">The <code class="inlineCode">IUnitOfWork</code> implementation is straightforward since it consists of a one-to-one coupling with <code class="inlineCode">DBContext</code> methods.</p>
<div><p class="normal"> Since we expose just <code class="inlineCode">IUnitOfWork</code> in the dependency injection engine, all repositories that need <code class="inlineCode">MainDbContext</code> for their job must require <code class="inlineCode">IUnitOfWork</code> in their constructors, and then they must cast it to <code class="inlineCode">MainDbContext</code>.</p>
</div>
<p class="normal">Having<a id="_idIndexMarker204"/> discussed what we need to know about <code class="inlineCode">DBDriver</code>, let’s move to the Web API project.</p>
<div><p class="normal"> Connecting the outermost project of an Onion Architecture is easy. We just need to call the extension method exposed by the application services, which injects all application services implementations in the dependency injection engine, and we need to call the extension methods of all drivers.</p>
</div>
<p class="normal">In our case, we need to add just two calls to <code class="codeHighlighted" style="font-weight: bold;">Program.cs</code>:</p>
<pre class="programlisting code"><code class="hljs-code">..
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddApplicationServices();
builder.Services.AddDbDriver(
  builder.Configuration?.GetConnectionString(
    "DefaultConnection") ?? string.Empty);
..
</code></pre>
<p class="normal">At this point, in <a id="_idIndexMarker205"/>the case of the ASP.NET Core project, all that remains is to acquire the command handlers for the commands that we need in the constructors of our controllers. After that, each action method must just use the input that it received to build adequate commands, and then it must invoke the handler associated with each command.</p>
<p class="normal">The short description of how to handle the outermost layer of an Onion Architecture completes our short introduction to this architecture, but we will find examples throughout the remainder of the book since we will use them for most of our code examples.</p>
<p class="normal">Let’s move on to another important building block of microservices architecture: containers!</p>
<h1 class="heading-1" id="_idParaDest-63"><a id="_idTextAnchor093"/>Containers and Docker</h1>
<p class="normal">We’ve already discussed the advantages of having microservices<a id="_idIndexMarker206"/> that don’t depend on the environment where they run; microservices can be moved from busy nodes to idle nodes without constraints, thus achieving a better load balance and, consequently, better usage of the available hardware.</p>
<p class="normal">However, if we need to mix legacy software with newer modules or if we would like to use the best stack for each module, with the ability to mix several development stack implementations, we are faced with the problem that each different stack has different hardware/software prerequisites. In these cases, the independence of each microservice from the hosting environment can be restored by deploying each microservice, together with all its dependencies, on a private virtual machine.</p>
<p class="normal">However, starting a virtual machine with its private copy of the operating system takes a lot of time, and microservices must be started and stopped quickly to reduce load-balancing and fault recovery costs. Luckily, microservices can rely on a lighter form of virtualization technology: containers. Containers provide<a id="_idIndexMarker207"/> a lightweight and efficient form of virtualization. Unlike traditional virtual machines that virtualize an entire machine, including the operating system, containers virtualize at the operating system’s filesystem level, sitting on top of the host operating system kernel. They use the operating system of the host machine (kernel, DLLs, and drivers) and use the operating system’s native features to isolate processes and resources, creating an isolated environment for the images they run.</p>
<p class="normal">The following figure shows how<a id="_idIndexMarker208"/> containers work:</p>
<figure class="mediaobject"> <img alt="Figure 3.11: Container basic principles" src="img/B31916_03_11.png"/></figure>
<p class="packt_figref">Figure 3.11: Container basic principles</p>
<p class="normal">Containers are run by the containers’ runtime <a id="_idIndexMarker209"/>from <strong class="keyWord">images</strong> that encode their content. The same image can create several identical containers. Images are stored in <strong class="keyWord">image registries</strong> that identify <a id="_idIndexMarker210"/>them through both an image name and an image version. In turn, images are created by commands in a text file that specify both the container’s content and properties.</p>
<p class="normal">More specifically, names are URLs whose domain part is the registry domain, and the path part is composed of a namespace that includes related images and a repository name. The version is attached to this URL with a colon and is called <code class="codeHighlighted" style="font-weight: bold;">tag</code> since it can be any string. Summing up, the name and version are encoded as shown here:</p>
<pre class="programlisting con"><code class="hljs-con">&lt;registry domain&gt;/&lt;namespace&gt;/&lt;repository name&gt;:&lt;tag&gt;
</code></pre>
<p class="normal">Thus, for instance, the ASP.NET CORE 9.0 runtime Docker image’s full URL is as follows:</p>
<pre class="programlisting con"><code class="hljs-con">mcr.microsoft.com/dotnet/aspnet:9.0
</code></pre>
<p class="normal">Here, <code class="inlineCode">mcr.microsoft.com</code> is the registry domain, <code class="inlineCode">dotnet</code> is the namespace, <code class="inlineCode">asp.net</code> is the repository name, and <code class="inlineCode">9.0</code> is the tag.</p>
<p class="normal">Any runtime that needs to create containers downloads its image from a registry, possibly providing credentials, and then uses the downloaded images to create the containers. The following figure shows the whole process of container creation:</p>
<figure class="mediaobject"><img alt="Figure 3.12: Containers/images lifecycle" src="img/B31916_03_12.png"/></figure>
<p class="packt_figref">Figure 3.12: Containers/images lifecycle</p>
<p class="normal">In the remainder of the <a id="_idIndexMarker211"/>book, we will use Docker containers as a de facto standard. Each Docker image is generated by specifying changes to apply to another preexisting image with <a id="_idIndexMarker212"/>the <strong class="keyWord">Docker containers description language</strong>. The <a id="_idIndexMarker213"/>instructions for creating a Docker image are contained in a file that must be named <strong class="keyWord">Dockerfile</strong> (without any file extension).</p>
<p class="normal">Each <strong class="keyWord">Dockerfile</strong> usually starts with a <code class="inlineCode">FROM</code> instruction that specifies the preexisting image to modify, as shown here:</p>
<pre class="programlisting con"><code class="hljs-con">FROM mcr.microsoft.com/dotnet/aspnet:9.0
...
</code></pre>
<p class="normal">The tag with the ASP.NET CORE version to use is specified after the image URL, preceded by a colon, as shown in the preceding code. Images taken from private repositories must be specified with their complete URL, which starts with the domain of the registry. Images without their complete URL are allowed only when they are hosted on the Docker free public registry, <code class="inlineCode">hub.docker.com/r/</code>.</p>
<p class="normal">The following figure shows the hierarchical organization<a id="_idIndexMarker214"/> of Docker images:</p>
<figure class="mediaobject"><img alt="Figure 3.13: Hierarchy of images and containers" src="img/B31916_03_13.png"/></figure>
<p class="packt_figref">Figure 3.13: Hierarchy of images and containers</p>
<p class="normal">The <code class="inlineCode">FROM</code> statement specifies<a id="_idIndexMarker215"/> the environment you are in, called the <strong class="keyWord">build stage</strong>. After <a id="_idIndexMarker216"/>that, you can deal with the image as if it were a filesystem by copying files from your <a id="_idTextAnchor094"/>computer into it and by executing shell commands:</p>
<figure class="mediaobject"><img alt="Figure 3.14: Building the image" src="img/B31916_03_14.png"/></figure>
<p class="packt_figref">Figure 3.14: Building the image</p>
<div><p class="normal"> In all copy operations, you can use relative paths on your computer. They are assumed to be relative to the directory that contains the <code class="inlineCode">Dockerfile</code> file.</p>
</div>
<p class="normal">Here are the main <code class="inlineCode">Dockerfile</code> commands:</p>
<ul>
<li class="snippet-con">WORKDIR &lt;path in the image file system&gt;<p class="normal-one">This <a id="_idIndexMarker217"/>instruction defines the current directory in the image filesystem. If the directory doesn’t exist, it is created. After that, you can use relative paths also in the image filesystem.</p>
</li>
<li class="snippet-con">COPY &lt;path in your computer&gt; &lt;path in the image&gt;<p class="normal-one">Copy one or more files into the image filesystem. If the source path denotes a folder, the whole folder is recursively copied; otherwise, a single file is copied. In any case, the directory or file copied takes the name specified in the image path.</p>
</li>
<li class="snippet-con">Copy &lt;path1&gt; &lt;path2&gt; … ./ (or [&lt;path1&gt;, &lt;path2&gt;, …, ./]<p class="normal-one">The content specified by all source paths is copied into the image’s current directory. Source file names are not changed.</p>
</li>
<li class="snippet-con">Copy –-from=&lt;image name or url&gt;:&lt;version&gt; …<p class="normal-one">This works like the previous copy commands but files are taken from the image specified by the name/URL after <code class="inlineCode">from=</code>. A name can be specified instead of a URL only if the image is contained in your computer or the Docker public repository. If no version is specified, <code class="inlineCode">latest</code> is assumed as the default version name.</p>
</li>
<li class="snippet-con">RUN &lt;command&gt; &lt;arg1&gt; &lt;arg2&gt; ...<p class="normal-one">This executes the specified shell command with the specified arguments in the current directory of the image.</p>
</li>
<li class="snippet-con">CMD [&lt;command&gt;, &lt;arg1&gt;, &lt;arg2&gt;, ...]
        <pre class="programlisting con-one"><code class="hljs-con">ENTRYPOINT [&lt;command&gt;, &lt;arg1&gt;, &lt;arg2&gt;, ...]
</code></pre>
<p class="normal-one">This specifies what happens when the container is executed. More specifically, it declares both the command and arguments to run when the container is executed.</p>
</li>
<li class="snippet-con">EXPOSE &lt;port1&gt; &lt;port2&gt;<p class="normal-one">This declares all ports supported by the container. Network traffic should be redirected into the container only through the ports declared here, but traffic directed to other ports is not <a id="_idIndexMarker218"/>blocked.</p>
</li>
</ul>
<p class="normal">A Dockerfile can also build intermediary images as a step to define the final image. For instance, an image containing the whole .NET SDK can be created with the only purpose of compiling a .NET solution. Then, the final binaries will be copied with the <code class="inlineCode">Copy –-from=…</code> instruction in the final image, which contains just the .NET runtime. We will analyze this possibility in more detail when discussing Visual Studio support for Docker.</p>
<p class="normal">Let’s move on to a very simple example to familiarize ourselves with both Dockerfile instructions and the shell commands that manipulate Docker images and containers.</p>
<h2 class="heading-2" id="_idParaDest-64"><a id="_idTextAnchor095"/>Docker Desktop: a simple example</h2>
<p class="normal">In order to operate with Docker on a<a id="_idIndexMarker219"/> client computer, you need to install <strong class="keyWord">Doker Desktop</strong>. Please refer to the instructions in the <em class="italic">Technical requirements</em> section for its installation. As described in the <em class="italic">Technical requirements</em> section, all examples suppose a Windows machine with WSL installed and Docker Desktop configured for Linux containers.</p>
<p class="normal">Once you have installed Docker Desktop, you will have the following:</p>
<ul>
<li class="bulletList">The Docker runtime, so <a id="_idIndexMarker220"/>you can instantiate containers from images, and run them on your computer.</li>
<li class="bulletList">A Docker client, so you can <a id="_idIndexMarker221"/>compile Dockerfiles into images, and execute other Docker-related shell commands.</li>
<li class="bulletList">A Docker local registry. All images <a id="_idIndexMarker222"/>compiled on your computer will be placed here. From here, you can move them to other registries. Moreover, before creating containers on your machine, you need to download their images here.</li>
</ul>
<p class="normal">In order to show the power of Docker, we will start with a simple Java example. You will see that you don’t need either the Java runtime or Java SDK to compile and run a simple Java program because everything needed is downloaded into the image being built.</p>
<p class="normal">Let’s start by creating a folder in which to place all the files needed to build the image. Let’s call it <code class="inlineCode">SimpleExample</code>.</p>
<p class="normal">In this folder, place a <code class="inlineCode">Hello.java</code> file containing the following simple code:</p>
<pre class="programlisting code"><code class="hljs-code">class Hello{
  public static void main(String[] args){
    System.out.println("This program runs in a  Docker container");
  }
}
</code></pre>
<p class="normal">Now, in the same folder, we need just a<a id="_idIndexMarker223"/> Dockerfile <a id="_idTextAnchor096"/>with the following content:</p>
<pre class="programlisting con"><code class="hljs-con">FROM eclipse-temurin:11
COPY . /var/www/java
WORKDIR /var/www/java
RUN javac Hello.java
CMD ["java", "Hello"]
</code></pre>
<p class="normal"><code class="inlineCode">eclipse-temurin</code> is a Java SDK. This will enable us both to compile and execute Java code in our image and our containers. Then, the code copies everything in our folder into the newly created <code class="inlineCode">/var/www/java</code> path in the image being built. Please remember that relative paths on the source are evaluated with respect to the position of the Dockerfile.</p>
<p class="normal">Finally, we move to the <code class="inlineCode">var/www/java</code> folder and run the Java compiler, which will create a <code class="inlineCode">.jar</code> file in the same folder. The <code class="inlineCode">CMD</code> instruction specifies invoking the Java command on the previously created <code class="inlineCode">.jar</code> file when a container based on this image will be executed.</p>
<p class="normal">Now, we need a Linux shell opened in our <code class="inlineCode">SimpleExample</code> folder to execute Docker commands. Right-click on the image of the <code class="inlineCode">SimpleExample</code> folder by simultaneously pressing the <em class="italic">shift</em> key, and choose the option to open a Linux shell from the menu that appears.</p>
<p class="normal">As a first step, we need to <em class="italic">build</em> our <code class="inlineCode">Dockerfile</code> instructions to create an image. This is done with the <code class="codeHighlighted" style="font-weight: bold;">build</code> command, as follows:</p>
<pre class="programlisting con"><code class="hljs-con">docker build ./ -t simpleexample
</code></pre>
<p class="normal">The first argument specifies the location of the Dockerfile, while the <code class="inlineCode">-t</code> option specifies a tag (an image URL) to attach to the image, in our case, <code class="inlineCode">simpleexample</code>. Since the image will be placed in our local Docker Desktop registry, it is enough to specify the repository part of the URL, but if you have several local<a id="_idIndexMarker224"/> images, you can also add a namespace to better classify your images. Usually, at this stage, no version tag is added, and Docker assumes the <code class="inlineCode">latest</code> default tag.</p>
<div><p class="normal"> Remember: all image names must be lowercase!</p>
</div>
<p class="normal">The compilation might take a few seconds. If you look at the console while it is compiling, you can see that other images are recursively downloaded, because each image is built upon other images, and so on.</p>
<p class="normal">Now, issue the <code class="inlineCode">docker images</code> command to se<a id="_idTextAnchor097"/>e all images defined on your local registry. You should see <code class="inlineCode">simpleexample</code> among them. Images are also listed in the UI that appears when you double-click on the Docker Desktop icon on your desktop.</p>
<p class="normal">Now, let’s create a container based on the newly created images. The <code class="inlineCode">run</code> command creates a container based on a given image and immediately executes it:</p>
<pre class="programlisting con"><code class="hljs-con">docker run --name myfirstcontainer simpleexample
</code></pre>
<p class="normal">The <code class="inlineCode">--name</code> option specifies a name for the container while the other argument is the name of the image we want to use to create the container. The container prints the string we put in our Java class and then exits quickly.</p>
<p class="normal">Let’s list all executing containers with <code class="inlineCode">docker ps</code>. No container has been listed since our container finished its execution. However, we can see also all non-running containers with the <code class="inlineCode">--all</code> option:</p>
<pre class="programlisting con"><code class="hljs-con">docker ps --all
</code></pre>
<p class="normal">Let’s re-execute our container. If we re-execute the <code class="inlineCode">run</code> command, we will create another container, so the right way to re-execute a sleeping container is as follows:</p>
<pre class="programlisting con"><code class="hljs-con">docker restart myfirstcontainer
</code></pre>
<p class="normal">However, in this case, no <a id="_idIndexMarker225"/>string is printed on the console because <code class="inlineCode">restart</code> runs the container into another process. You might find this strange but it is not, because containers usually run a never-ending loop that might block your shell.</p>
<p class="normal">Neverending containers can be stopped with something like this:</p>
<pre class="programlisting con"><code class="hljs-con">docker stop myfirstcontainer
</code></pre>
<p class="normal">When you have finished with your container, you can remove it with the following:</p>
<pre class="programlisting con"><code class="hljs-con">docker rm myfirstcontainer
</code></pre>
<p class="normal">Now, you can remove also the image used to create the container with the following:</p>
<pre class="programlisting con"><code class="hljs-con">docker rmi simpleexample
</code></pre>
<p class="normal">You have learned a lot of useful Docker shell commands. The next section is dedicated to the description of some more advanced useful commands.</p>
<h2 class="heading-2" id="_idParaDest-65"><a id="_idTextAnchor098"/>A few more Docker commands and options</h2>
<p class="normal">During <a id="_idIndexMarker226"/>microservice operations, Docker containers are moved from one hardware node to another to balance the load. Unfortunately, when a container is removed to create it elsewhere, all files saved in its filesystem are lost. For this reason, some portions of the container’s filesystem are mapped to external storage, typically provided by network disk units.</p>
<p class="normal">This is possible because the <code class="inlineCode">run</code> command has the option to map a directory in the host machine (say, <code class="inlineCode">S</code>) to a directory in the container’s internal storage space (say, <code class="inlineCode">D</code>) so that files written to <code class="inlineCode">D</code> are actually saved in <code class="inlineCode">S</code>, and remain safe also after the container has been removed. This operation is <a id="_idIndexMarker227"/>called <strong class="keyWord">bind mount</strong>, and the option to add it to the <code class="inlineCode">run</code> command is as follows:</p>
<pre class="programlisting con"><code class="hljs-con">docker run -v &lt;host machine path&gt;:&lt;container path&gt; ...
</code></pre>
<p class="normal">Another option allows the mapping of each port exposed by the container to an actual port on the host computer:</p>
<pre class="programlisting con"><code class="hljs-con">docker run -p &lt;host machine port&gt;:&lt;container port&gt; ...
</code></pre>
<p class="normal">This option can be repeated several times to map more than one port. Without this option, it would be impossible to redirect network traffic inside the container.</p>
<p class="normal">The <code class="inlineCode">-e</code> option passes operating system environment variables to the container. The code running in the container can easily ask the values of these variables to the operating system, so they are the preferred way to configure an application:</p>
<pre class="programlisting con"><code class="hljs-con">docker run -e mayvariable1=mayvalue1  -e mayvariable2=mayvalue2. ..
</code></pre>
<p class="normal">Another useful option of the <code class="inlineCode">run</code> command is the <code class="inlineCode">-d</code> option (<em class="italic">d</em> stands for <em class="italic">detached</em>):</p>
<pre class="programlisting con"><code class="hljs-con">docker run -d ...
</code></pre>
<p class="normal">When this option is provided, the container is launched detached from the current shell prompt, that is, in a different process. This way, a container that hosts a never-ending program, such as a web server, doesn’t block the shell prompt.</p>
<p class="normal">Each image can be attached to an indefinite number of tags that can be used as alternative names:</p>
<pre class="programlisting con"><code class="hljs-con">docker tag &lt;image name&gt; &lt;tag&gt;
</code></pre>
<p class="normal">Tagging is the <a id="_idIndexMarker228"/>first step for pushing a local image into a public registry. Suppose we have an image called <code class="inlineCode">myimage</code> that we would like to push to a private registry we have on Azure, say, <code class="inlineCode">myregistry.azurecr.io/</code>. Suppose we would like to place thi<a id="_idTextAnchor099"/>s image in the <code class="inlineCode">mypath/mymage</code> path of this registry, that is, to <code class="inlineCode">myregistry.azurecr.io/mypath/mymage</code>.</p>
<p class="normal">As a first step, we tag our image with its final URL:</p>
<pre class="programlisting con"><code class="hljs-con">docker tag myimage myregistry.azurecr.io/mypath/mymage
</code></pre>
<p class="normal">Then, it is enough to execute a <code class="codeHighlighted" style="font-weight: bold;">push</code> operation that uses the new tag attached to the image:</p>
<pre class="programlisting con"><code class="hljs-con">docker push myregistry.azurecr.io/mypath/mymage:&lt;version&gt;
</code></pre>
<p class="normal">Pulling public registry images to our local registry instead is straightforward:</p>
<pre class="programlisting con"><code class="hljs-con">docker pull myregistry.azurecr.io/mypath/myotherimage:&lt;version&gt;
</code></pre>
<div><p class="normal"> Before interacting with a registry that requires a login, we must perform a login operation. Each registry has its own login procedure.</p>
</div>
<p class="normal">The simplest way to log in to an Azure registry is by using the Azure CLI. You can download its installer here: <a href="https://aka.ms/installazurecliwindows">https://aka.ms/installazurecliwindows</a>.</p>
<p class="normal">As a first step, log in to your Azure account with the following:</p>
<pre class="programlisting con"><code class="hljs-con">az login
</code></pre>
<p class="normal">This command<a id="_idIndexMarker229"/> should start your default browser and should drive you through the manual login procedure in your Azure account. Once logged in to your Azure account, you can log in to your private registry by typing the following command:</p>
<pre class="programlisting con"><code class="hljs-con">az acr login --name &lt;registryname&gt;
</code></pre>
<p class="normal">Here, <code class="inlineCode">&lt;registryname&gt;</code> is the unique name of your Azure registry, not its complete URL. After logging in, you can freely work with your Azure registry.</p>
<p class="normal">Visual Studio has native support for Docker. Let’s analyze all the possibilities offered by this support.</p>
<h2 class="heading-2" id="_idParaDest-66"><a id="_idTextAnchor100"/>Visual Studio support for Docker</h2>
<p class="normal">Visual Studio support<a id="_idIndexMarker230"/> for Docker can be enabled by simply selecting the <strong class="screenText">Enable container support</strong> checkbox in the appropriate Visual Studio project options. Let’s <a id="_idIndexMarker231"/>experiment with an ASP.NET Core MVC project. After the project selection and after having chosen the project name, say, <code class="codeHighlighted" style="font-weight: bold;">DockerTest</code>, you should arrive at the following option page:</p>
<figure class="mediaobject"><img alt="Figure 3.15: Enabling Docker support" src="img/B31916_03_15.png"/></figure>
<p class="packt_figref">Figure 3.15: Enabling Docker support</p>
<p class="normal">Please check the <strong class="screenText">Enable container support</strong> checkbox.</p>
<p class="normal">If you forgot to enable Docker support here, you can always right-click on the project icon in Visual Studio Solution Explorer and then select <strong class="screenText">Add </strong>-&gt;<strong class="screenText"> Docker support</strong>.</p>
<p class="normal">The project contains a Dockerfile:</p>
<figure class="mediaobject"><img alt="Figure 3.16: Visual Studio Dockerfile" src="img/B31916_03_16.png"/></figure>
<p class="packt_figref">Figure 3.16: Visual Studio Dockerfile</p>
<p class="normal">Click on the Dockerfile; it should contain the definition of four images. In fact, the final image is built in four stages.</p>
<p class="normal">The first stage defines the .NET runtime and the ports used by the application in the final image:</p>
<pre class="programlisting con"><code class="hljs-con">FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
WORKDIR /app
EXPOSE 8080
EXPOSE 8081
</code></pre>
<p class="normal">The name <code class="inlineCode">base</code> after <code class="inlineCode">AS</code> will <a id="_idIndexMarker232"/>be called by other <code class="inlineCode">FROM</code> instructions in the same file. The<a id="_idIndexMarker233"/> second stage performs the project build by using the <code class="codeHighlighted" style="font-weight: bold;">dotnet</code> SDK:</p>
<pre class="programlisting con"><code class="hljs-con">FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["DockerTest/DockerTest.csproj", "DockerTest/"]
RUN dotnet restore "./DockerTest/DockerTest.csproj"
COPY . .
WORKDIR "/src/DockerTest"
RUN dotnet build "./DockerTest.csproj" -c $BUILD_CONFIGURATION -o /app/build
</code></pre>
<p class="normal">The <code class="inlineCode">ARG</code> instruction defines a variable that can be recalled as <code class="inlineCode">$BUILD_CONFIGURATION</code> in other instructions. Here, it is used to define the chosen configuration for the build. You can replace its value with <code class="inlineCode">Debug</code> to compile in Debug mode.</p>
<p class="normal">The first <code class="inlineCode">Copy</code> instruction just copies the project file in the <code class="inlineCode">/src/DockerTest</code> directory of the image. Then, Nuget packages are restored and all source files are copied from the directory containing the Dockerfile to the current image directory, <code class="inlineCode">/src</code>. Finally, we move into <code class="inlineCode">/src/DockerTest</code> and perform a build. The build output files are placed in the <code class="inlineCode">/app/build</code> directory in the image.</p>
<p class="normal">The third stage is built on top of the <code class="inlineCode">build</code> image and simply publishes the project files in the <code class="inlineCode">/app/publish</code> folder:</p>
<pre class="programlisting con"><code class="hljs-con">FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "./DockerTest.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false
</code></pre>
<p class="normal">We could have<a id="_idIndexMarker234"/> merged stages 2 and 3 into a single stage but it is convenient <a id="_idIndexMarker235"/>to split stages into smaller stages because intermediary images are cached, so in subsequent builds, when the image input does not change, cached images are used instead of recomputing them.</p>
<p class="normal">Finally, the fourth and last stage is built on top of the first stage since it just needs the .NET runtime, and simply copies the published files from the image created in the third stage:</p>
<pre class="programlisting con"><code class="hljs-con">FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "DockerTest.dll"]
</code></pre>
<p class="normal">Now, place a breakpoint in the <code class="codeHighlighted" style="font-weight: bold;">Index</code> method of the <code class="inlineCode">HomeController.cs</code> file and run the solution. Visual Studio automatically builds the Dockerfile and runs the image.</p>
<p class="normal">The breakpoint will be hit since Visual Studio is able to perform debugging inside the container images!</p>
<p class="normal">While the application is running, for each container, Visual Studio shows logs, environment variables, bind mounts, and other information:</p>
<figure class="mediaobject"><img alt="Figure 3.17: Visual Studio Containers console" src="img/B31916_03_17.png"/></figure>
<p class="packt_figref">Figure 3.17: Visual Studio Containers console</p>
<div><p class="normal"> You can get also an interactive shell inside each container where you can explore the container’s filesystem, execute shell commands, and perform diagnostics and performance measurement operations, by simply opening a Linux shell and issuing the following command:</p>
<pre class="programlisting con"><code class="hljs-con">docker exec -it &lt;container-name-or-id&gt; /bin/bash
</code></pre>
</div>
<p class="normal">In our case, let’s list all running containers with <code class="inlineCode">docker ps</code> to get our container ID:</p>
<pre class="programlisting con"><code class="hljs-con">CONTAINER ID   IMAGE        COMMAND                  CREATED          STATUS          PORTS                                              NAMES
f6ca4537e060   dockertest   "dotnet --roll-forwa…"   17 minutes ago   Up 17 minutes   0.0.0.0:49154-&gt;8080/tcp, 0.0.0.0:49153-&gt;8081/tcp   DockerTest
</code></pre>
<p class="normal">Then, run<a id="_idIndexMarker236"/> the<a id="_idIndexMarker237"/> following:</p>
<pre class="programlisting con"><code class="hljs-con">docker exec -it DockerTest /bin/bash
</code></pre>
<p class="normal">Now, you are in the container filesystem! Let’s try some shell commands, such as <code class="inlineCode">Is</code>, for instance. When you have finished with the container, it is enough to run <code class="inlineCode">exit</code> to return to your host computer console.</p>
<h1 class="heading-1" id="_idParaDest-67"><a id="_idTextAnchor101"/>Summary</h1>
<p class="normal">This chapter described two important building blocks of microservices architectures: the Onion Architecture and Docker containers. The chapter described the basic principles of the Onion Architecture and how both the Application Services and Domain layers are organized. More specifically, we described commands, queries, events, and their handlers together with aggregates and value objects.</p>
<p class="normal">Moreover, you learned how to use the preceding concepts in a Visual Studio solution thanks to the Visual Studio solution templates provided.</p>
<p class="normal">The chapter explained the importance of containers, how to build a Dockerfile, and how to use Docker shell commands in practice. Finally, the chapter described Visual Studio support for Docker.</p>
<p class="normal">The next chapter focuses on Azure functions and their main triggers.</p>
<h1 class="heading-1" id="_idParaDest-68"><a id="_idTextAnchor102"/>Questions</h1>
<ol>
<li class="numberedList" value="1">Is it true that the Domain layer project must have a reference to the database driver project?</li>
</ol>
<p class="normal-one">No, it is false. References to drivers must be added to the infrastructure layer.</p>
<ol>
<li class="numberedList" value="2">Which solution projects are among the application services references?</li>
</ol>
<p class="normal-one">Only those projects that are part of the Domain Layer.</p>
<ol>
<li class="numberedList" value="3">Which solution projects are among the references of the outermost layer project of an Onion Architecture?</li>
</ol>
<p class="normal-one">Application Services, Db Drivers, and all infrastructure drivers.</p>
<ol>
<li class="numberedList" value="4">Is it true that an aggregate always corresponds to a unique database table?</li>
</ol>
<p class="normal-one">No, it is false.</p>
<ol>
<li class="numberedList" value="5">Why are domain events needed?</li>
</ol>
<p class="normal-one">They are needed to decouple the code of different aggregates.</p>
<ol>
<li class="numberedList" value="6">What is the purpose of the <code class="codeHighlighted" style="font-weight: bold;">WORKDIR</code> Dockerfile instruction?</li>
</ol>
<p class="normal-one">To set the image current directory.</p>
<ol>
<li class="numberedList" value="7">How is it possible to pass environment variables to a container?</li>
</ol>
<p class="normal-one">Through the -e options of the docker run command.</p>
<ol>
<li class="numberedList" value="8">What is the right way to persist the storage of Docker containers?</li>
</ol>
<p class="normal-one">Volume binds is the way to persist the storage of Docker containers.</p>
<h1 class="heading-1" id="_idParaDest-69"><a id="_idTextAnchor103"/>Further reading</h1>
<ul>
<li class="bulletList">More on queries, commands, and the domain layer can be found here: <a href="https://udidahan.com/2009/12/09/clarified-cqrs/">https://udidahan.com/2009/12/09/clarified-cqrs/</a></li>
<li class="bulletList">More information on Docker can be found on Docker’s official website: <a href="https://docs.docker.com/">https://docs.docker.com/</a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-70"><a id="_idTextAnchor104"/>Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/PSMCSharp">https://packt.link/PSMCSharp</a></p>
<p class="normal"><img alt="A qr code with black squares  AI-generated content may be incorrect." src="img/B31916_Discord-QR-Code.png"/></p>
</div>
</body></html>