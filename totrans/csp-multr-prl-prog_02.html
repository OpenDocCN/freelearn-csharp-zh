<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Looking at Multithreaded Classes – BackgroundWorker</h1></div></div></div><p>C# offers a variety of ways to create and control threads in our applications. There are the <code class="literal">Thread</code> and <code class="literal">ThreadPool</code> classes, the<a id="id77" class="indexterm"/> <strong>Task Parallel Library</strong> (<strong>TPL</strong>), the <code class="literal">Async</code> methods, and the <code class="literal">BackgroundWorker</code> component. The <code class="literal">BackgroundWorker</code> is the original way of doing multiple things at once in C# and, to many, it has become passé and <code class="literal">Tasks</code> and <code class="literal">Threads</code> are now the preferred method. But for simple multithreaded needs, <code class="literal">BackgroundWorker</code> is an extremely handy and easy-to-use way to accomplish multiple things at once.</p><p>In this chapter, we will study this component in detail, and we will begin developing multithreaded applications that take full advantage of multiprocessing. After reading this and following the exercises, we shall:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Develop applications that are able to execute tasks in the background while keeping alive the graphical user interface, offering the user a more real-life experience</li><li class="listitem" style="list-style-type: disc">Learn to create independent threads using a simple component</li><li class="listitem" style="list-style-type: disc">Understand the differences between synchronous and asynchronous execution</li><li class="listitem" style="list-style-type: disc">Develop applications that are able to show the progress of their many concurrent running tasks in the graphical user interface</li><li class="listitem" style="list-style-type: disc">Learn to start and cancel background tasks</li><li class="listitem" style="list-style-type: disc">Develop applications capable of launching multiple background tasks when necessary</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Getting started with the BackgroundWorker component</h1></div></div></div><p>Since the<a id="id78" class="indexterm"/> introduction of .NET 2.0 (C# 2005), a new component has become a part of Visual C# that simplifies the execution of tasks in independent threads, separated from the main thread. It is the <code class="literal">BackgroundWorker</code> component (<code class="literal">System.ComponentModel.BackgroundWorker</code>), and it allows us to begin working with many threads and taking advantage of parallelism with very little effort.</p><p>One of the main advantages of components in C# and the .NET working environment is the possibility to define their properties, values, and events in design time without the need to write lots of code.</p><p>Unfortunately, the <code class="literal">BackgroundWorker</code> component is not a <strong>Windows Presentation Foundation</strong> (<strong>WPF</strong>)<a id="id79" class="indexterm"/> component. As you can see in the following screenshot, in a Windows Form application, it is available in <strong>Toolbox</strong> under <strong>Components</strong>:</p><div><img src="img/8321EN_02_01.jpg" alt="Getting started with the BackgroundWorker component"/></div><p>In a WPF <a id="id80" class="indexterm"/>application, it is not available, as shown:</p><div><img src="img/8321EN_02_02.jpg" alt="Getting started with the BackgroundWorker component"/></div><p>This does not<a id="id81" class="indexterm"/> mean that it is not available in WPF. It just means that you will need to implement it completely in code instead of being able to manipulate it in the <strong>Designer</strong> view. To declare a <code class="literal">BackgroundWorker</code> instance in WPF, we simply add the following <code class="literal">using</code> statement:</p><div><pre class="programlisting">using System.ComponentModel;
Then we declare it in the code.
BackgroundWorker Worker = new BackgroundWorker();</pre></div><p>Historically, multithreaded programming terrified developers because of the extreme complexity of the code needed to initialize, coordinate, stop, and free those threads.</p><p>The easiest way to begin experimenting with multithreading in .NET and learn the basic principles is to use the <code class="literal">BackgroundWorker</code> component. It allows us to define certain properties in design time (in Windows Forms) and introduce the code for the <code class="literal">DoWork</code> event handler. It represents an easy and rapid way to generate a new thread, independent of the main thread (the one that runs the main application's flow), and without having to use more flexible or more complicated methods.</p><p>The work to be done and run in a new thread is programmed in the <code class="literal">DoWork</code> event handler of <code class="literal">BackgroundWorker</code>. To understand how it works, let's look at an example to see it in action and <a id="id82" class="indexterm"/>experience the difference between the code running in the same thread (the application's main thread) and in another thread.</p><p>Imagine that we must create a CodeBreaker application. There is a code of four Unicode characters, and we want to break it by a brute-force attack. Therefore, we must loop through each Unicode character until we have a match, then move on to the next character, and so on.</p><p>However, as the application will take some time to break the code, we do not want to get caught by a guard during the hacking process. Therefore, we will add some pictures that will simulate a Fishes game, present in the <em>How to do it</em> section under the <em>Simple example without a BackgroundWorker object</em> section. We must be able to hide our hacking application and show the Fishes game by clicking on a button.</p><p>First, we are going to build a new C# application, and we will program a classic linear programming loop with some processing in order to run the code in the same thread (the application's main thread):</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>We need a computer with at least two cores or two microprocessors installed in order to achieve significant results for the forthcoming experiments, and for the examples in the rest of this book.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Simple example without a BackgroundWorker object</h1></div></div></div><p>We will start this <a id="id83" class="indexterm"/>WPF chapter by first creating a single thread version of our CodeBreaking application. This will give us a starting point and show us the limitations of running everything on a single thread. We will then refactor our application to use two threads, and then many threads, to show the improved performance and capabilities.</p><p>As mentioned before, we will be doing all of this in a WPF application instead of Windows Forms. This will require us to work with the <code class="literal">BackgroundWorker</code> component entirely in code instead of being able to use it at design time.</p><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>How to do it</h2></div></div></div><p>The following are the steps that we need to perform:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new WPF application C# project in Visual Studio (<strong>File</strong> | <strong>New</strong> | <strong>Project</strong> | <strong>Visual C#</strong> | <strong>WPF Application</strong>).</li><li class="listitem"> The IDE will create a very simple application with <code class="literal">MainWindow.xaml</code> and <code class="literal">MainWindow.xaml.cs</code> files. We will name our project <code class="literal">CodeBreaker</code>:<div><img src="img/8321EN_02_03.jpg" alt="How to do it"/></div></li><li class="listitem">Open <code class="literal">MainWindow.xaml</code> in the designer, and add the following controls:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Two images showing a skull and an agent (<code class="literal">imgSkull</code> and <code class="literal">imgAgent</code>).</li><li class="listitem" style="list-style-type: disc">Three <a id="id84" class="indexterm"/>images showing three fish (<code class="literal">imgFish1</code>, <code class="literal">imgFish2</code>, and <code class="literal">imgFish3</code>).</li><li class="listitem" style="list-style-type: disc">Four textblock elements with their <code class="literal">Text</code> property set to <code class="literal">"#1"</code>,<code class="literal">"#2"</code>,<code class="literal">"#3"</code>, and <code class="literal">"#4"</code> (<code class="literal">txtNumber1</code>, <code class="literal">txtNumber2</code>, <code class="literal">txtNumber3</code>, and <code class="literal">txtNumber4</code> respectively).</li><li class="listitem" style="list-style-type: disc">Four labels with their <code class="literal">Text</code> property set to <code class="literal">"*"</code> (<code class="literal">txtOutput1</code>, <code class="literal">txtOutput2</code>, <code class="literal">txtOutput3</code>, and <code class="literal">txtOutput4</code>).</li><li class="listitem" style="list-style-type: disc">One textblock element with its <code class="literal">Text</code> property set to <code class="literal">"CodeBreaker (Single-threaded)"</code>.</li><li class="listitem" style="list-style-type: disc">One textblock with its <code class="literal">Text</code> property set to <code class="literal">"Fishes Game!!!"</code>.</li><li class="listitem" style="list-style-type: disc">One button with its <code class="literal">Text</code> property set to <code class="literal">"Start"</code> (<code class="literal">btnStart</code>). This is the button that will run the main loop, which will find the code.</li><li class="listitem" style="list-style-type: disc">One button showing with its <code class="literal">Text</code> property set to <code class="literal">"Hide"</code> (<code class="literal">btnHide</code>). This button must hide all the controls related to the CodeBreaker and show the Fishes game. You will click on this button when the guard is coming!</li><li class="listitem" style="list-style-type: disc">One button with its <code class="literal">Text</code> property set to <code class="literal">"Game over"</code> (<code class="literal">btnGameOver</code>). This button must hide all the controls related to the Fishes<a id="id85" class="indexterm"/> game and show the CodeBreaker again. You will click on this button when the guard has gone and you will feel safe to continue breaking the code!</li></ul></div><p>The controls mentioned here are shown in the following screenshot:</p><div><img src="img/8321EN_02_04.jpg" alt="How to do it"/></div></li><li class="listitem">In <a id="id86" class="indexterm"/>the <code class="literal">MainWindow.xaml.cs</code> code file, add the following line in the <code class="literal">public partial class MainWindow : Window</code> definition to declare two private variables:<div><pre class="programlisting">// The simulated code to be broken
   private string Code;
   // The list of Labels of the characters to be broken.
   private List&lt;TextBlock&gt; OutputCharLabels;</pre></div></li><li class="listitem">Add the following method, <code class="literal">SimulateCodeGeneration</code>, to our <code class="literal">MainWindow</code> class. This will simulate the code that must be broken:<div><pre class="programlisting">    private void SimulateCodeGeneration()
    {
        // A Random number generator.
        Random loRandom = new Random();
        // The char position being generated
        int i;

        Code = "";
        for (i = 0; i &lt;= 4; i++)
        {
            // Generate a Random Unicode char for each of 
            //the 4 positions
            Code += (char)(loRandom.Next(65535));
        }
    }</pre></div></li><li class="listitem">Add the <a id="id87" class="indexterm"/>following procedure, <code class="literal">setFishesVisibility</code>. This will change the visibility of the controls related to the Fishes game:<div><pre class="programlisting">        private void setFishesVisibility(System.Windows.Visibility pbValue)
        {
            // Change the visibility of the controls 
            //related to the fishes game.
            imgFish1.Visibility = pbValue;
            imgFish2.Visibility = pbValue;
            imgFish3.Visibility = pbValue;
            txtFishGame.Visibility = pbValue;
            btnGameOver.Visibility = pbValue;
        }</pre></div></li><li class="listitem">Add the following procedure, <code class="literal">setCodeBreakerVisibility</code>. This will change the visibility of the controls related to the CodeBreaking procedure:<div><pre class="programlisting">        private void setCodeBreakerVisibility(System.Windows.Visibility pbValue)
        {
            // Change the visibility of the controls related to the CodeBreaking procedure.
            imgSkull.Visibility = pbValue;
            imgAgent.Visibility = pbValue;
            txtCodeBreaker.Visibility = pbValue;
            txtNumber1.Visibility = pbValue;
            txtNumber2.Visibility = pbValue;
            txtNumber3.Visibility = pbValue;
            txtNumber4.Visibility = pbValue;
            txtOutput1.Visibility = pbValue;
            txtOutput2.Visibility = pbValue;
            txtOutput3.Visibility = pbValue;
            txtOutput4.Visibility = pbValue;
            btnStart.Visibility = pbValue;
            btnHide.Visibility = pbValue;
        }</pre></div></li><li class="listitem">Add the<a id="id88" class="indexterm"/> following procedure, <code class="literal">showFishes</code>. This will show the Fishes game and will hide everything related to the CodeBreaking procedure:<div><pre class="programlisting">private void showFishes()
{
// Hide all the controls related to the code 
// breaking procedure.
setCodeBreakerVisibility(System.Windows.Visibility.Hidden);
// Change the window title
this.Title = "Fishing game for Windows 1.0";
// Make the fishes visible
setFishesVisibility(System.Windows.Visibility.Visible);

}</pre></div></li><li class="listitem">Add the following procedure, <code class="literal">showCodeBreaker</code>. This will hide the Fishes game (implying you do not want to play), and will show everything related to the CodeBreaking procedure. You need this in order to break the code:<div><pre class="programlisting">        private void showCodeBreaker()
        {
            // Hide all the controls related to the fishes 
            // game
            setFishesVisibility(System.Windows.Visibility.Hidden);
            // Change the window title
            this.Title = "CodeBreaker Application";
            // Make the code breaker controls visible
            setCodeBreakerVisibility(System.Windows.Visibility.Visible);

        }</pre></div></li><li class="listitem">Add the following function, <code class="literal">checkCodeChar</code>. This will return <code class="literal">true</code> if the received character and position matches the one in the code. This will help us in our simulation, and we can then replace it with a real decoder:<div><pre class="programlisting">        private bool checkCodeChar(char pcChar, int piCharNumber)
        {
            // Returns a bool value indicating whether the piCharNumber position of the code is the pcChar received.
            return (Code[piCharNumber] == pcChar);
        }</pre></div></li><li class="listitem">Add the following code in the MainWindow constructor (after <code class="literal">InitializeComponent()</code>):<div><pre class="programlisting">            // Generate a random code to be broken
            SimulateCodeGeneration();
            // Create a new list of Label controls that show the characters of the code being broken.
            OutputCharLabels = new List&lt;TextBlock&gt;(4);
            // Add the Label controls to the List
            OutputCharLabels.Add(txtOutput1);
            OutputCharLabels.Add(txtOutput2);
            OutputCharLabels.Add(txtOutput3);
         OutputCharLabels.Add(txtOutput4);
        // Hide the fishes game and show the CodeBreaker
        showCodeBreaker();</pre></div></li><li class="listitem">Open the <code class="literal">Click</code> event in the button <code class="literal">butGameOver</code> and enter the following code:<div><pre class="programlisting">    // Hide the fishes game and show the CodeBreaker
    showCodeBreaker();</pre></div></li><li class="listitem">Open the <code class="literal">Click</code> event in the button <code class="literal">butHide</code>, and enter the following code:<div><pre class="programlisting">    // Hide the CodeBreaker and show the fishes game
    showFishes();</pre></div></li><li class="listitem">Open the <code class="literal">Click</code> event in the <a id="id89" class="indexterm"/>button <code class="literal">butStart</code>, and enter the following code:<div><pre class="programlisting">                // This code will break the simulated code.
            // This variable will hold a number to iterate from 1 to 65,535 - Unicode character set.
            int i;
            // This variable will hold a number to iterate from 0 to 3 (the characters positions in the code to be broken).
            int liCharNumber;
            // This variable will hold a char generated from the number in i
            char lcChar;
            // This variable will hold the current Label control that shows the char position being decoded.
            TextBlock loOutputCharCurrentLabel;

            for (liCharNumber = 0; liCharNumber &lt; 4; liCharNumber++)
            {
                loOutputCharCurrentLabel =
                OutputCharLabels[liCharNumber];
                // This loop will run 65,536 times
                for (i = 0; i &lt;= 65535; i++)
                {
                    // myChar holds a Unicode char
                    lcChar = (char)(i);
                    loOutputCharCurrentLabel.Text = lcChar.ToString();
                    //Application.DoEvents();
                    if (checkCodeChar(lcChar, liCharNumber))
                    {
                        // The code position was found
                        break;
                    }
                }
            }
            MessageBox.Show("The code has been decoded successfully.", this.Title);</pre></div></li><li class="listitem">Build and<a id="id90" class="indexterm"/> run the application:<div><img src="img/8321EN_02_05.jpg" alt="How to do it"/></div></li><li class="listitem">Click on the <strong>Start</strong> button. While the loop is running and the code is being broken by brute force, try clicking on the <strong>Hide</strong> button. You won't be able to.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>How does it work?</h2></div></div></div><p>If a guard comes <a id="id91" class="indexterm"/>past when you are trying to break the code, you will be caught because there is no way to stop the CodeBreaking once it starts until it completes.</p><p>Why? Because we do not have a multithreaded application, we lose control over the graphical user interface.</p><p>The code programmed in the <code class="literal">btnStart</code> click event handler runs in the main thread. Therefore, when the user clicks on this button, he or she loses control over the UI and cannot click on the other button to hide the CodeBreaker-related controls because the thread is processing the <code class="literal">btnStart</code> click method. Until this method finishes, nothing else can be processed.</p><p>The code is<a id="id92" class="indexterm"/> quite simple. It generates the 65,536 Unicode characters four times, and calls the <code class="literal">checkCodeChar</code> function in order to determine whether it is part of the code or not. It tries to display the progress showing each tested character in the window, but as it is a single-threaded application, it fails in this objective. Again, as the loop is run in the main thread of the process created when the application is executed, we lose control over the UI. We cannot move the window, change its size, or push a button. The main thread is processing the intensive loop and consuming all the processing time of a single core. Hence, it cannot show information in the main window.</p><p>For this reason, when the guard comes, you are dead. Hence, let's create a multithreaded application and save human lives!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>WPF example with an asynchronous BackgroundWorker</h1></div></div></div><p>A loop like the one used in the <a id="id93" class="indexterm"/>previous example is an ideal task to run in an independent thread. That way, we could keep control over the UI and have the possibility of canceling the job, displaying its progress, hiding the CodeBreaker controls, and displaying our Fishes game. Hence, we can avoid being shot by the guard (death or jail).</p><p>In this section, we will see how to use the <code class="literal">BackgroundWorker</code> component in a simple way to create a second concurrent thread in our application, which will allow the user to perform other actions while the CodeBreaking process is being performed.</p><p>We will first do this in an asynchronous way and then in a synchronous way in the next chapter. The differences will be shown; in the asynchronous method, we will be able to take advantage of concurrent processing with two threads, but we will lose visibility as to the status of the second thread. We will not know where it is in the CodeBreaking process and when it is completed.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>How to do it</h2></div></div></div><p>Now, let's make some changes to the application. We will process the CodeBreaking loop using a <code class="literal">BackgroundWorker</code> component in order to run the code in an independent thread:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <a id="id94" class="indexterm"/>project, <code class="literal">CodeBreaker</code>.</li><li class="listitem">Add a <code class="literal">BackgroundWorker</code> object to the <code class="literal">MainWindow</code> (<code class="literal">bakCodebreaker</code>) class.<div><pre class="programlisting">private readonly BackgroundWorker bakCodebreaker = new BackgroundWorker();</pre></div></li><li class="listitem">Next, register the <code class="literal">DoWork</code> event handler in the constructor of the <code class="literal">MainWindow</code> class.<div><pre class="programlisting">bakCodebreaker.DoWork += bakCodebreaker_DoWork;</pre></div></li><li class="listitem">Then, add the <code class="literal">DoWork</code> event handler method and paste the same code entered previously in the <code class="literal">Click</code> event in the button, <code class="literal">btnStart</code> (this is the code that is going to be run when the <code class="literal">BackgroundWorker</code> object is started):<div><pre class="programlisting">        private void bakCodebreaker_DoWork(object sender, DoWorkEventArgs e)
        {
            // This code will break the simulated code.
            // This variable will hold a number to iterate from 1 to 65,535 - Unicode character set.
            int i;
            // This variable will hold a number to iterate from 0 to 3 (the characters positions in the code to be broken).
            int liCharNumber;
            // This variable will hold a char generated from the number in i
            char lcChar;
            // This variable will hold the current Label control that shows the char position being decoded.
            TextBlock loOutputCharCurrentLabel;

            for (liCharNumber = 0; liCharNumber &lt; 4; liCharNumber++)
            {
                loOutputCharCurrentLabel =
                OutputCharLabels[liCharNumber];
                // This loop will run 65,536 times
                for (i = 0; i &lt;= 65535; i++)
                {

                    // myChar holds a Unicode char
                    lcChar = (char)(i);
                    //loOutputCharCurrentLabel.Text = lcChar.ToString();

                    if (checkCodeChar(lcChar, liCharNumber))
                    {
                        // The code position was found
                        break;

                    }
                }

               // MessageBox.Show("The code has been decoded successfully.",
               //                  this.Title);
            }
      }</pre></div></li><li class="listitem">Then, comment <a id="id95" class="indexterm"/>out the following lines of code:<div><pre class="programlisting">    // loOutputCharCurrentLabel.Text = lcChar.ToString();
    // MessageBox.Show("The code has been decoded successfully.", this.Title);</pre></div><div><div><h3 class="title"><a id="note07"/>Note</h3><p>You must comment out these lines of code because, as the <code class="literal">BackgroundWorker</code> object creates a new thread in which the loop is going to run, it cannot make changes to the user interface. There are mechanisms to do that, and we will learn them later.</p></div></div></li><li class="listitem">Open the <code class="literal">Click</code> event in the button <code class="literal">btnStart</code>, and enter the following code:<div><pre class="programlisting">    // Start running the code programmed in 
    // BackgroundWorker DoWork event handler
    // in a new independent thread and return control to 
    // the application's main thread
    bakCodebreaker.RunWorkerAsync();</pre></div></li><li class="listitem">Build and run the application.</li><li class="listitem">Click on the <strong>Start</strong> button. While the loop is running and the code is being broken by brute force in a new thread created by the <code class="literal">BackgroundWorker</code> component, try to click on the <strong>Hide</strong> button. It works, and while the CodeBreaker code is still working in the background, you will see the Fishes game being <a id="id96" class="indexterm"/>displayed in the window, as shown in the following screenshot:<div><img src="img/8321EN_02_06.jpg" alt="How to do it"/></div></li><li class="listitem">Move the window, change its size, maximize it, and do anything else you want to. While you do these operations, the code programmed in the <code class="literal">DoWork</code> event will keep on executing in another thread.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>How does it work?</h2></div></div></div><p>We can click on the <strong>Hide</strong> button, and the window shows the three fish with the <strong>Game Over</strong> button, but the program continues processing the CodeBreaker in the other thread (the <code class="literal">DoWork</code> method of <code class="literal">BackgroundWorker</code>).</p><p>The code programmed in the <code class="literal">DoWork</code> event handler runs in an independent thread. Therefore, when the user clicks on the <strong>Start</strong> button, a new thread is created, and he or she does not lose control over the UI. While the CodeBreaker is running, the user can move the mouse cursor over other buttons, change the window size, and use other user interface components similar to the buttons.</p><p>However, we cannot see the progress of the code being broken. We will fix this issue shortly.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>How does it work without blocking the UI?</h2></div></div></div><p>After calling the <code class="literal">RunWorkerAsync()</code> method of <code class="literal">BackgroundWorker</code>, the advantage of threading begins by running the code programmed in the <code class="literal">DoWork</code> event handler in a new independent thread. This mechanism is known as<a id="id97" class="indexterm"/> <strong>asynchronous execution</strong>.</p><p>When an asynchronous method is called, it runs in an independent way and the program flow goes on with the instruction after the method call, even though the code has not finished its execution. The code in the asynchronous method runs concurrently with the main program flow.</p><p>We are going to run<a id="id98" class="indexterm"/> our last example step-by-step in order to understand the asynchronous execution and how the main thread's code goes on running.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>How to do it</h2></div></div></div><p>The following are the steps that need to be followed:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the project <code class="literal">CodeBreaker</code>.</li><li class="listitem">Define a breakpoint in the line <code class="literal">bakCodebreaker.RunWorkerAsync();</code> in the <code class="literal">Click</code> event code of <code class="literal">btnStart</code>.</li><li class="listitem">Define a breakpoint in the line <code class="literal">showFishes();</code> in the <code class="literal">Click</code> event code of <code class="literal">btnHide</code>.</li><li class="listitem">Press <em>F5</em> or navigate to <strong>Debug</strong> | <strong>Start Debugging</strong> in the main menu.</li><li class="listitem">Click on the <strong>Start</strong> button. The line with the breakpoint defined is shown highlighted as the next statement that will be executed.</li><li class="listitem">Press <em>F10</em> or navigate to <strong>Debug</strong> | <strong>Step Over</strong> in the main menu a few times. As you can see, the next statement that will be executed in the main thread is not in the <strong>DoWork</strong> event handler of <code class="literal">BackgroundWorker</code>. It remains in the <code class="literal">Click</code> event code of <code class="literal">btnStart</code>.</li><li class="listitem">Now, click on the <strong>Hide</strong> button.</li><li class="listitem">Press <em>F10</em> or navigate to <strong>Debug</strong> | <strong>Step Over</strong> in the main menu a few times. As you can see, the thread created by <code class="literal">BackgroundWorker</code> keeps running while the next statement that will be executed in the main thread is not in the <code class="literal">DoWork</code> event handler of <code class="literal">BackgroundWorker</code>. It remains in the <code class="literal">Click</code> event code of <code class="literal">btnHide</code>.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>How does it work?</h2></div></div></div><p>Running the <a id="id99" class="indexterm"/>application step by step, we could not enter the code in the <code class="literal">DoWork</code> event handler of <code class="literal">BackgroundWorker</code>. However, the code was running because the CodeBreaker thread did its job. It happened because the <code class="literal">BackgroundWorker</code> object starts an asynchronous execution of the code in another thread. Therefore, the main thread continues with its next statements as if the <code class="literal">RunWorkerAsync()</code>method had completed successfully. Hence, that method does not execute code in a linear, synchronous way.</p><p>The execution flow in the main thread is synchronous. The main thread and the one created by <code class="literal">BackgroundWorker</code> run concurrently.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>Nevertheless, not everything that shines is gold. Asynchronous code execution brings many new headaches to programmers because it ends with many implicit warranties related to synchronous and linear code execution. We will be talking about them and will provide simple solutions for the most common problems.</p></div></div><p>When we worked with a single thread, we used to be the only owners of all the available elements in the programming context, the instances, the variables, the collections, the arrays, the controls that compose the graphical user interface, the components, and so on. However, when we work with multiple threads and asynchronous execution, we are sharing this world, in many ways, with strangers. Hence, there may be some code that runs concurrently, affecting the values for some variables, or accomplishing changes in the instances of the objects that we were going to work on.</p><p>For this reason, a paradigm shift in the way we approach our code is needed. We must stop thinking that we are alone with our code. The same thing happened when home computers were not connected to a network, some decades ago. They did not use a hard drive, and the user was the complete and unique owner of everything that was executed. Things such as memory swapping did not take place then. On the other side, nowadays, it would be difficult to find a modern computer without some kind of Internet connection. The antivirus, antispyware, anti-malware, and many other anti-threats that could interrupt the digital ecosystem harmony appeared. Therefore, every action in an application on a website is accompanied by those "anti-" whatever threat.</p><p>The same happens with multithreading and asynchronous execution. New threats appear and they can make the most perfectly designed code for a single thread produce completely unexpected and incomprehensible results when executed in a multithreading environment.</p><p>Many <a id="id100" class="indexterm"/>techniques must be applied in order to avoid the different problems related to concurrent programming. We are going to analyze them with concrete examples through this book, case by case.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>WPF example with a synchronous BackgroundWorker</h1></div></div></div><p>We are <a id="id101" class="indexterm"/>used to synchronous execution when we work with a single thread. This mechanism executes the next instruction once the current instruction processing is completed.</p><p>When a synchronous method is called, it runs on the same thread and the program flow goes into the method's code. Once it returns from the method with or without a result, it goes on with the instruction next to the method call. There is no code in the method left for later execution, because it finishes when it returns the control to the caller. The main program has to wait for the method to complete its execution in order to go on with the next set of instructions.</p><p>This is what happens when you debug a single-threaded application, step-by-step.</p><p>In a single-threaded application, the synchronous execution takes place as we observed in classic linear programming. When a line of code executes, nothing else runs.</p><p>However, in a multithreaded application, such as the ones using one or more <code class="literal">BackgroundWorker</code> controls, asynchronous execution comes into the picture.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>We must master this important change in the way methods are called and new independent threads are created on the fly, in order to get used to parallel and concurrent programming in C#.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Showing progress</h1></div></div></div><p>Users may get <a id="id102" class="indexterm"/>impatient when processes are delayed for more than a few seconds. In such cases, they need to know how long it will take them to finish. A good evidence of this is the replacement of messages such as <em>Hold on…</em> by animated dialog boxes with progress bars, entertaining the users while they wait for the process and showing them an approximate time required to finish the task.</p><p>Reporting progress is one of the main problems when we work with only one thread and make intensive use of the processing power. Now, we will make changes to the application to show the code as it is being decoded and report the decoding progress for each character. This way, you will be able to decide whether to hide the CodeBreaker when the guard is coming or wait for the process to finish.</p><p>As we work in the same thread that updates the user interface, if we send orders to make changes in a control to show any kind of progress, it will probably show the update whenever the main thread retrieves control (usually, when the process has already finished). Hence, as it is not useful to watch when the process has finished, it is necessary to update the progress report regularly.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>As a rule, we cannot make calls to a control since the thread used is different from the one that created it. If that happened, an <code class="literal">InvalidOperationException</code> would be raised. In order to make these calls safely, we must use delegates and asynchronous calls, known as<a id="id103" class="indexterm"/> <strong>callbacks</strong>.</p></div></div><p>The <code class="literal">BackgroundWorker</code> component<a id="id104" class="indexterm"/> offers a straightforward way to report progress and simplifies updating any control in the user interface that shows this progress, without any need to use delegates or asynchronous calls (callbacks). The last two are indeed much more complex ways to achieve the same results.</p><p>In order to show the progress of an operation using the <code class="literal">BackgroundWorker</code> component, we must assign the <code class="literal">true</code> value to its <code class="literal">WorkerReportsProgress</code> property. Its type is <code class="literal">bool</code>, and it tells whether the code executed in the new thread will report some kind of progress or not. If the value is <code class="literal">true</code>, the <code class="literal">BackgroundWorker</code> component will trigger the <code class="literal">ProgressChanged</code> event handler.</p><p>This event facilitates updating the user interface. Therefore, it allows changes to control values, without having to consider the problems generated when we want to do it from a thread different from the one that created the control (the application's main thread).</p><p>We are going to make some changes to our second example to take advantage of the features offered by the <code class="literal">BackgroundWorker</code> component to report progress in the user interface without delegates or callbacks. This way, we will be safe from the guards.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>How to do it</h2></div></div></div><p>The following are the<a id="id105" class="indexterm"/> steps that need to be followed:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the project <code class="literal">CodeBreaker</code>.</li><li class="listitem">Add four <code class="literal">ProgressBar</code> controls to <code class="literal">frmMain</code> (<code class="literal">pgbProgressChar1</code>, <code class="literal">pgbProgressChar2</code>, <code class="literal">pgbProgressChar3</code>, and <code class="literal">pgbProgressChar4</code>).</li><li class="listitem">Register the <code class="literal">ProgressChanged</code> event handler in the <code class="literal">MainWindow</code> constructor:<div><pre class="programlisting">bakCodebreaker.ProgressChanged += bakCodebreaker_ProgressChanged;</pre></div></li><li class="listitem">Set the <code class="literal">WorkerReportsProgress</code> property of <code class="literal">bakCodebreaker</code> to true.</li><li class="listitem">Add the following lines of code to the <code class="literal">setCodeBreakerVisibility</code> procedure. This will change the visibility of the new controls related to the progress of the CodeBreaking procedure:<div><pre class="programlisting">    // Change the visibility of the controls related to the 
    // progress of the CodeBreaking procedure
    pgbProgressChar1.Visibility = pbValue;
    pgbProgressChar2.Visibility = pbValue;
    pgbProgressChar3.Visibility = pbValue;
    pgbProgressChar4.Visibility = pbValue;</pre></div></li><li class="listitem">Add the following lines of code in the form class declaration to declare a new private variable:<div><pre class="programlisting">   // The list of ProgressBar controls that show the 
   // progress of the character being decoded
 private List&lt;ProgressBar&gt; prloProgressChar;</pre></div></li><li class="listitem">Add the following code in the form constructor (after <code class="literal">InitializeComponent()</code>):<div><pre class="programlisting">  // Create a new list of ProgressBar controls that show 
  // the progress of each character of the code being 
  // broken
    prloProgressChar = new List&lt;ProgressBar&gt;(4);
    // Add the ProgressBar controls to the list
    prloProgressChar.Add(pgbProgressChar1);
    prloProgressChar.Add(pgbProgressChar2);
    prloProgressChar.Add(pgbProgressChar3);
    prloProgressChar.Add(pgbProgressChar4);</pre></div></li><li class="listitem">Add a new class file to the project and call it <code class="literal">CodeBreakerProgress</code>. The new <code class="literal">CodeBreakerProgress</code> class will have properties that will help provide many values related to the progress to update the user interface. Add the following<a id="id106" class="indexterm"/> code to the class.<div><pre class="programlisting">    public class CodeBreakerProgress
    {
        // The char position in the 4 chars code
        private int priCharNumber;
        // The Unicode char code
        private int priCharCode;
        // The decoding process percentage completed
        private int priPercentageCompleted;

        public int CharNumber
        {
            get
            {
                return priCharNumber;
            }
            set
            {
                priCharNumber = value;
            }
        }

        public int CharCode
        {
            get
            {
                return priCharCode;
            }
            set
            {
                priCharCode = value;
            }
        }

        public int PercentageCompleted
        {
            get
            {
                return priPercentageCompleted;
            }
            set
            {
                priPercentageCompleted = value;
            }
        }
    }</pre></div></li><li class="listitem">Open the <code class="literal">DoWork</code> event in <code class="literal">bakCodebreaker</code> of <code class="literal">BackgroundWorker</code>, and enter the following code at the beginning, before the <code class="literal">for</code> loop:<div><pre class="programlisting">    // This variable will hold a CodeBreakerProgress 
    // instance
    CodeBreakerProgress loCodeBreakerProgress = new CodeBreakerProgress();
    // This variable will hold the last percentage of the iteration completed
    int liOldPercentageCompleted;

    liOldPercentageCompleted = 0;</pre></div></li><li class="listitem">Now, in the same<a id="id107" class="indexterm"/> event, add the following code before the <code class="literal">if (checkCodeChar(lcChar, liCharNumber))</code> line:<div><pre class="programlisting">    // The percentage completed is calculated and stored in 
    // the PercentageCompleted property
    loCodeBreakerProgress.PercentageCompleted = (int)((i * 100) / 65535);
    loCodeBreakerProgress.CharNumber = liCharNumber;
    loCodeBreakerProgress.CharCode = i;

    if (loCodeBreakerProgress.PercentageCompleted &gt; liOldPercentageCompleted)
    {
        // The progress is reported only when it changes with regard to the last one (liOldPercentageCompleted)
        bakCodebreaker.ReportProgress(loCodeBreakerProgress.PercentageCompleted, loCodeBreakerProgress);
        // The old percentage completed is now the 
        // percentage reported
        liOldPercentageCompleted = loCodeBreakerProgress.PercentageCompleted;
    }</pre></div></li><li class="listitem">Now, in the same event, add the following code before the <code class="literal">break;</code> line:<div><pre class="programlisting">    // The code position was found
    loCodeBreakerProgress.PercentageCompleted = 100;
    bakCodebreaker.ReportProgress(loCodeBreakerProgress.PercentageCompleted, loCodeBreakerProgress);</pre></div></li><li class="listitem">Open <a id="id108" class="indexterm"/>the <code class="literal">ProgressChanged</code> event in the <code class="literal">bakCodebreaker</code> of <code class="literal">BackgroundWorker</code> and enter the following code (this is the code that will be run when the <code class="literal">ReportProgress</code> method is called):<div><pre class="programlisting">    // This variable will hold a CodeBreakerProgress instance
    CodeBreakerProgress loCodeBreakerProgress = (CodeBreakerProgress)e.UserState; 

    // Update the corresponding ProgressBar with the percentage received in the as a parameter
    prloProgressChar[loCodeBreakerProgress.CharNumber].Value = loCodeBreakerProgress.PercentageCompleted;
    // Update the corresponding Label with the character being processed
    OutputCharLabels[loCodeBreakerProgress.CharNumber].Text = ((char)loCodeBreakerProgress.CharCode).ToString();</pre></div></li><li class="listitem">Build and run the application.</li><li class="listitem">Click on the <strong>Start</strong> button and you will see the progress bars filling up, showing how the process advances from 0 to 65,535 Unicode characters and the characters being tested. This is shown in the following screenshot. Now you have more information to decide whether to hide the application or not.<div><img src="img/8321EN_02_07.jpg" alt="How to do it"/></div></li></ol></div><p>While the code is being broken, the UI can be used because the CodeBreaking is being done in a separate thread.</p><p>If the CodeBreaking runs too fast on your system, to see what is going on, add the following line before the <code class="literal">if (checkCodeChar(lcChar, liCharNumber))</code> statement.</p><div><pre class="programlisting">System.Threading.Thread.Sleep(1);</pre></div><p>This will add a 1-millisecond wait between each character being checked.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>How does it work?</h2></div></div></div><p>The code <a id="id109" class="indexterm"/>programmed in the loop reports the progress only if the percentage completed increased by a unit or more. Otherwise, we would be triggering 65,536 events in order to report only 100 different percentages. That would not make sense and add extra burdensome processing. That would be very inefficient and would make the loop take longer to complete its execution.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Canceling a BackgroundWorker thread</h1></div></div></div><p>Executing a<a id="id110" class="indexterm"/> time-consuming process in an independent thread allows us to work concurrently while showing its progress. One of the advantages of doing this is the possibility of allowing the user to go on using the controls in the graphical user interface without the restrictions of single-threaded applications. For example, perhaps he or she wants to cancel the CodeBreaking process instead of letting it finish.</p><p>The <code class="literal">BackgroundWorker</code> component simplifies the task of canceling the execution of the code running in the thread it creates without a lot of programming effort.</p><p>To do this, we must assign the <code class="literal">true</code> value to the <code class="literal">WorkerSupportsCancellation</code> property of <code class="literal">BackgroundWorker</code>. It is a <code class="literal">bool</code> value and tells whether the code executed in the new thread will support cancellation through a call to the <code class="literal">CancelAsync()</code> method of <code class="literal">BackgroundWorker</code>. This method simply assigns the <code class="literal">true</code> value to the <code class="literal">BackgroundWorker</code> property <code class="literal">CancellationPending</code>. Hence, the code being executed in the <code class="literal">DoWork</code> event handler must regularly check this property's value to determine whether it has to go on working or not.</p><p>Hiding the CodeBreaking does not stop the CodeBreaking process. So, we can still get caught if someone hacks into our computer and sees the process. Therefore, it is very important to provide the application with a fast cancellation procedure.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>How to do it</h2></div></div></div><p>We are going to make some changes to our example to allow the user to cancel the loop at any time without delegates or callbacks, using the features provided by the <code class="literal">BackgroundWorker</code> component:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the project <code class="literal">CodeBreaker</code>.</li><li class="listitem">Set the <code class="literal">WorkerSupportsCancellation</code> property of <code class="literal">bakCodebreaker</code> to <code class="literal">true</code>.</li><li class="listitem">Add a button control <code class="literal">btnStop</code>. Set its <code class="literal">Text</code> property to <code class="literal">"Stop"</code>.</li><li class="listitem">Add the following line of code to the procedure, <code class="literal">setCodeBreakerVisibility</code>. It will change the visibility of the new button:<div><pre class="programlisting">    // Change the visibility of the new stop button
      btnStop.Visibility = pbValue;</pre></div></li><li class="listitem">Open the <code class="literal">DoWork</code> event in <code class="literal">bakCodebreaker</code> and enter the following code before the line <code class="literal">lcChar = (char)(i)</code> in the beginning of the <code class="literal">for</code> loop (the code now adds support for a premature cancellation):<div><pre class="programlisting">    if (bakCodebreaker.CancellationPending)
    {
        // The user requested to cancel the process
        e.Cancel = true;
        return;
   }</pre></div></li><li class="listitem">Open the <code class="literal">Click</code> event in the button <code class="literal">btnStart</code> and add the following lines of code at the beginning (the code now disables the <strong>Start</strong> button and enables the <strong>Stop</strong> button):<div><pre class="programlisting">                // Disable the Start button
            btnStart.IsEnabled = false;
            // Enable the Stop button
            btnStop.IsEnabled = true;</pre></div></li><li class="listitem">Set <a id="id111" class="indexterm"/>the <code class="literal">IsEnabled</code> property of the <code class="literal">btnStop</code> button to <code class="literal">false</code> in the constructor. Hence, the button will be disabled when the application starts.</li><li class="listitem">Open the <code class="literal">Click</code> event in the <code class="literal">btnStop</code> button and enter the following code:<div><pre class="programlisting">                // Disable the Stop button
            btnStop.IsEnabled = false;
            // Enable the Start button
            btnStart.IsEnabled = true;
            
            //Call the CancelAsync method to cancel the 
            // process.
            bakCodebreaker.CancelAsync();</pre></div></li><li class="listitem">Build and run the application.</li><li class="listitem">Click on the <strong>Start</strong> button. Now click on the <strong>Stop</strong> button. The CodeBreaker will cancel its execution. The thread created by the <code class="literal">BackgroundWorker</code> component will stop running. The result is shown in the following screenshot:<div><img src="img/8321EN_02_08.jpg" alt="How to do it"/></div></li><li class="listitem">Now, click on the <strong>Start</strong> button and let the CodeBreaking complete.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>How does it work?</h2></div></div></div><p>Earlier, you<a id="id112" class="indexterm"/> could avoid the guards, and now you are able to stop the CodeBreaking in case spies hack your system!</p><p>We can now develop an application that is able to execute a time-consuming task in the background, while keeping the graphical user interface alive. This offers the user a more real-life experience and we can offer the user the possibility of starting and stopping the process whenever they want to. We have done all of this using the <code class="literal">BackgroundWorker</code> component features.</p><p>However, the application has a defect. When we click on the <strong>Start</strong> button and let the process finish, the <strong>Stop</strong> button will not be shown disabled. Additionally, we cannot see the final code on the screen. We must create a remedy for this.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Working with multiple BackgroundWorker components</h1></div></div></div><p>We can work with<a id="id113" class="indexterm"/> many <code class="literal">BackgroundWorker</code> components in order to run many concurrent threads. Usually, we will use the <code class="literal">Thread</code> class to run many threads at once, but the <code class="literal">BackgroundWorker</code> class provides us an easy way to do this as well. As we learned in the previous chapter, the performance results will depend upon the number of cores or processors available in the computer in which we run the application and how busy each core is with other threads of execution.</p><p>Using the real algorithms, the process of breaking the four Unicode characters code is very intensive and requires more time than expected. Breaking the code must take the minimum time possible. So far, we have been using multithreading to have a more responsive application, but now, we must make execution of the CodeBreaking process much faster.</p><p>We are going to take the code presented in our previous examples and divide it into four <code class="literal">BackgroundWorker</code> components. With this example, we will learn how multiple <code class="literal">BackgroundWorker</code> components coexist and create new independent threads, and hence achieve an incredible performance enhancement.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>How does it work?</h2></div></div></div><p>The steps that need to be followed are as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the project <code class="literal">CodeBreaker</code>.</li><li class="listitem">Add three new <code class="literal">BackgroundWorker</code> components (<code class="literal">bakCodeBreaker2</code>, <code class="literal">bakCodeBreaker3</code>, and <code class="literal">bakCodeBreaker4</code>) to create four independent threads. This is done in the declaration section of the <code class="literal">MainWindow</code> class. Next, set the <code class="literal">True</code> value for their properties <code class="literal">WorkerReportsProgress</code> and <code class="literal">WorkerSupportsCancellation</code> in the class constructor.</li><li class="listitem">Add a new class to the project and call it <code class="literal">CodeBreakerParameters</code>. The <code class="literal">CodeBreakerParameters</code> class will have properties that will help provide many values that will be available as parameters for the four <code class="literal">BackgroundWorker</code> components:<div><pre class="programlisting">    public class CodeBreakerParameters
    {
        // The first char position in the 4 chars code to 
        // process
           private int priFirstCharNumber;
        // The last char position in the 4 chars code to 
        // process
           private int priLastCharNumber;
        // The maximum number of the Unicode character
        private int priMaxUnicodeCharCode;

        public int FirstCharNumber
        {
            get
            {
                return priFirstCharNumber;
            }
            set
            {
                priFirstCharNumber = value;
            }
        }

        public int LastCharNumber
        {
            get
            {
                return priLastCharNumber;
            }
            set
            {
                priLastCharNumber = value;
            }
        }

        public int MaxUnicodeCharCode
        {
            get
            {
                return priMaxUnicodeCharCode;
            }
            set
            {
                priMaxUnicodeCharCode = value;
            }
        }
    }</pre></div></li><li class="listitem">Again, add another new class file. This one will be called <code class="literal">CodeBreakerResult</code>. The<a id="id114" class="indexterm"/> new <code class="literal">CodeBreakerResult</code> class will have properties that help in providing many values as parameters for the four <code class="literal">BackgroundWorker</code> components' <code class="literal">RunWorkerCompleted</code> events:<div><pre class="programlisting">    public class CodeBreakerResult
    {
        // The first char position in the 4 chars code to 
        // process
        private int priFirstCharNumber;
        // The last char position in the 4 chars code to 
        // process
        private int priLastCharNumber;
        // The part of the broken code 
        private string prsBrokenCode;

        public int FirstCharNumber
        {
            get
            {
                return priFirstCharNumber;
            }
            set
            {
                priFirstCharNumber = value;
            }
        }

        public int LastCharNumber
        {
            get
            {
                return priLastCharNumber;
            }
            set
            {
                priLastCharNumber = value;
            }
        }

        public string BrokenCode
        {
            get
            {
                return prsBrokenCode;
            }
            set
            {
                prsBrokenCode = value;
            }
        }
    }</pre></div></li><li class="listitem">Open the <code class="literal">Click</code> event in the <code class="literal">btnStart</code> button and add the following lines of code before <a id="id115" class="indexterm"/>the line <code class="literal">bakCodebreaker.RunWorkerAsync();</code> (now the code will set the parameters for the four <code class="literal">BackgroundWorker</code> components and will run them asynchronously):<div><pre class="programlisting">    // Start running the code programmed in each 
    // BackgroundWorker DoWork event handler in a new 
    // independent thread and return control to the 
    // application's main thread
    // First, create the CodeBreakerParameters for each 
    // BackgroundWorker and set its parameters
    CodeBreakerParameters loParameters1 = new CodeBreakerParameters();
    CodeBreakerParameters loParameters2 = new CodeBreakerParameters();
    CodeBreakerParameters loParameters3 = new CodeBreakerParameters();
    CodeBreakerParameters loParameters4 = new CodeBreakerParameters();
    loParameters1.MaxUnicodeCharCode = 32000;
    loParameters1.FirstCharNumber = 0;
    loParameters1.LastCharNumber = 0;
    loParameters2.MaxUnicodeCharCode = 32000;
    loParameters2.FirstCharNumber = 1;
    loParameters2.LastCharNumber = 1;
    loParameters3.MaxUnicodeCharCode = 32000;
    loParameters3.FirstCharNumber = 2;
    loParameters3.LastCharNumber = 2;
    loParameters4.MaxUnicodeCharCode = 32000;
    loParameters4.FirstCharNumber = 3;
    loParameters4.LastCharNumber = 3;
    bakCodebreaker.RunWorkerAsync(loParameters1);
    bakCodebreaker2.RunWorkerAsync(loParameters2);
    bakCodebreaker3.RunWorkerAsync(loParameters3);
    bakCodebreaker4.RunWorkerAsync(loParameters4);</pre></div></li><li class="listitem">Now, in the same aforementioned event, remove the line <code class="literal">bakCodebreaker.RunWorkerAsync();</code>.</li><li class="listitem">Open the <code class="literal">Click</code> event in the <code class="literal">btnStop</code> button and add the following lines of code (now the code will cancel the four <code class="literal">BackgroundWorker</code> components, <code class="literal">bakCodebreaker</code> and the three <code class="literal">BackgroundWorker</code> components added in the following lines):<div><pre class="programlisting">    bakCodebreaker2.CancelAsync();
    bakCodebreaker3.CancelAsync();
    bakCodebreaker4.CancelAsync();</pre></div></li><li class="listitem">Now, we will create generic procedures to handle the following programmed events of<code class="literal"> BackgroundWorker</code> components, receiving the same parameters as the corresponding event handler:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">DoWorkProcedure</code> for the <code class="literal">DoWork</code> event</li><li class="listitem" style="list-style-type: disc"><code class="literal">RunWorkerCompletedProcedure</code> for the <code class="literal">RunWorkerCompleted</code> event</li><li class="listitem" style="list-style-type: disc"><code class="literal">ProgressChangedProcedure</code> for the <code class="literal">ProgressChanged</code> event</li></ul></div></li><li class="listitem">Paste<a id="id116" class="indexterm"/> the <code class="literal">DoWork</code> event handler code of <code class="literal">bakCodebreaker</code> in a new private procedure and then make the following changes as shown:<div><pre class="programlisting">    private void DoWorkProcedure(object sender, DoWorkEventArgs e)</pre></div></li><li class="listitem">Add the following variable definitions at the beginning:<div><pre class="programlisting">    // This variable will hold the broken code
    string lsBrokenCode = "";
    CodeBreakerParameters loCodeBreakerParameters = (CodeBreakerParameters)e.Argument;</pre></div></li><li class="listitem">Replace the line <code class="literal">int liTotal = (int)e.Argument</code>; with the following (now the event handler procedure needs more parameters, and so we create a class to manage them):<div><pre class="programlisting">    int liTotal = loCodeBreakerParameters.MaxUnicodeCharCode;</pre></div></li><li class="listitem">Replace the line that defines the first loop with the following (now the loop takes into account the parameters received through a <code class="literal">CodeBreakerParameters</code> instance):<div><pre class="programlisting">    for (liCharNumber = loCodeBreakerParameters.FirstCharNumber; liCharNumber &lt;= loCodeBreakerParameters.LastCharNumber; liCharNumber++)</pre></div></li><li class="listitem">Replace the pending cancellation check with the following line (we use the <code class="literal">sender</code> parameter typecast because the same procedure is employed by the four <code class="literal">BackgroundWorker</code> components):<div><pre class="programlisting">   if (((BackgroundWorker)sender).CancellationPending)</pre></div></li><li class="listitem">Replace the call to the <code class="literal">ReportProgress</code> method by the following line (again, we use the <code class="literal">sender</code> parameter typecasted for generalization):<div><pre class="programlisting">((BackgroundWorker)sender).ReportProgress(loCodeBreakerProgress.PercentageCompleted, loCodeBreakerProgress);</pre></div></li><li class="listitem">Replace the call to the <code class="literal">ReportProgress</code> method when the <code class="literal">checkCodeChar</code> function returns <code class="literal">true</code> with the following line:<div><pre class="programlisting">    ((BackgroundWorker)sender).ReportProgress(loCodeBreakerProgress.PercentageCompleted, loCodeBreakerProgress);</pre></div></li><li class="listitem">Replace<a id="id117" class="indexterm"/> the line <code class="literal">e.Result = lsBrokenCode;</code> with the following lines (now we must return more than one result; therefore, we use an instance of the <code class="literal">CodeBreakerResult</code> class created earlier):<div><pre class="programlisting">    // Create a new instance of the CodeBreakerResult class 
    // and set its properties' values
    CodeBreakerResult loResult = new CodeBreakerResult();
    loResult.FirstCharNumber = loCodeBreakerParameters.FirstCharNumber;
    loResult.LastCharNumber = loCodeBreakerParameters.LastCharNumber;
    loResult.BrokenCode = lsBrokenCode;
    // Return a CodeBreakerResult instance in the Result 
    // property
    e.Result = loResult;</pre></div></li><li class="listitem">Enter the following code to create the new <code class="literal">RunWorkerCompleted</code> procedure:<div><pre class="programlisting">    private void RunWorkerCompletedProcedure(object sender, RunWorkerCompletedEventArgs e)
    {
        if (!e.Cancelled)
        {
            // Obtain the CodeBreakerResult instance 
            // contained in the Result property of e 
            // parameter
            CodeBreakerResult loResult = (CodeBreakerResult)e.Result;
            int i;

            // Iterate through the parts of the result 
            // resolved by this BackgroundWorker
            for (i = loResult.FirstCharNumber; i &lt;= loResult.LastCharNumber; i++)
            {
                // The process has finishes, therefore the 
                // ProgressBar control must show a 100%
                prloProgressChar[i].Value = 100;
                // Show the part of the broken code in the 
                // label
                OutputCharLabels[i].Text = loResult.BrokenCode[i - loResult.FirstCharNumber].ToString();
            }
    }</pre></div></li><li class="listitem">Enter the<a id="id118" class="indexterm"/> following code to create the new <code class="literal">ProgressChangedProcedure</code> procedure:<div><pre class="programlisting">    private void ProgressChangedProcedure(object sender, ProgressChangedEventArgs e)
    {
        // This variable will hold a CodeBreakerProgress 
        // instance
        CodeBreakerProgress loCodeBreakerProgress = (CodeBreakerProgress)e.UserState;
        // Update the corresponding ProgressBar with the percentage received as a parameter
        prloProgressChar[loCodeBreakerProgress.CharNumber].Value = loCodeBreakerProgress.PercentageCompleted;
        // Update the corresponding Label with the character being processed
        OutputCharLabels[loCodeBreakerProgress.CharNumber].Text = ((char)loCodeBreakerProgress.CharCode).ToString();
    }</pre></div></li></ol></div><p>Now, you have to program the code for the three additional event handlers of the four <code class="literal">BackgroundWorker</code> components. As we have used procedures, we will use the same code for the four <code class="literal">BackgroundWorker</code> components:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the<a id="id119" class="indexterm"/> following code in the four <code class="literal">BackgroundWorker</code> components' <code class="literal">DoWork</code> event handlers:<div><pre class="programlisting">    DoWorkProcedure(sender, e);</pre></div></li><li class="listitem">Add the following code in the four <code class="literal">BackgroundWorker</code> components' <code class="literal">ProgressChanged</code> event handlers:<div><pre class="programlisting">    ProgressChangedProcedure(sender, e);</pre></div></li><li class="listitem">Add the following code in the four <code class="literal">BackgroundWorker</code> components' <code class="literal">RunWorkerCompleted</code> event handlers:<div><pre class="programlisting">    RunWorkerCompletedProcedure(sender, e);</pre></div></li><li class="listitem">Build and run the application.</li><li class="listitem">Click on the <strong>Start</strong> button and let the process finish. You will see that all four characters are being decoded at the same time concurrently. If you have a machine with four cores in it, you will see all four cores being utilized simultaneously and much improved performance:<div><img src="img/8321EN_02_09.jpg" alt="How does it work?"/></div><p>And here is<a id="id120" class="indexterm"/> how it looks once it is completed:</p><div><img src="img/8321EN_02_10.jpg" alt="How does it work?"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>How does it work?</h2></div></div></div><p>Now, your<a id="id121" class="indexterm"/> CodeBreaking procedure is very fast! Each character of the code is being decoded in parallel.</p><p>As we have seen, it is easy to split a process into many threads using the features provided by the <code class="literal">BackgroundWorker</code> component. The results of the execution of the previous example will depend on the number of cores or processors available in the computer. The ideal situation is to start as many <code class="literal">BackgroundWorker</code> components as the number of cores available. This way, we can achieve the best performance for each thread and take the CPU usage to around 95 percent. Of course this will vary and we will not always know the number of cores on a target machine. As we will see in future chapters, there are ways to use the <strong>Task Parallel Library</strong> (<strong>TPL</strong>)<a id="id122" class="indexterm"/> to achieve maximum concurrency on machines when we do not know the number of cores on a machine ahead of time.</p><p>Now, we do not need to run many instances of an application to take advantage of parallel processing capabilities. Using the <code class="literal">BackgroundWorker</code> component and everything we have learned so far, we can quite easily split a process into many threads.</p><p>However, we had to make some important changes to the code because we needed to generalize the behavior of four <code class="literal">BackgroundWorker</code> components without writing the same piece of code four times. This is called <strong>refactoring</strong><a id="id123" class="indexterm"/> and should also be done when developing software to minimize redundant code.</p><p>We created <a id="id124" class="indexterm"/>new classes to pass parameters and obtain results because we needed many parameters and many results. As you can see, with typecasting, C# offers us excellent alternatives to generalize the code.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>The key was the <code class="literal">sender</code> parameter. Remember that this parameter, available in the event handlers, offers a reference to the component (the <code class="literal">BackgroundWorker</code>) that triggers the event. Typecasting the <code class="literal">sender</code> parameter to a <code class="literal">BackgroundWorker</code> component, we could generalize the code in the different event handlers and create procedures for each one.</p></div></div><p>There were many changes. But once the code patterns are practiced and learned, it will be easier to work with concurrent programming structures. This will be especially important when working with the TPL.</p><p>As of now, the application uses four <code class="literal">BackgroundWorker</code> components, and hence four independent threads not including the main thread. It does not give the user a message about the end of the CodeBreaking global process.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Exploring other examples</h1></div></div></div><p>Try adding <a id="id125" class="indexterm"/>another <code class="literal">BackgroundWorker</code> to show a message box telling the user the process has finished, or disabling the <strong>Stop</strong> button and enabling the <strong>Start</strong> button, when the four <code class="literal">BackgroundWorker</code> components complete their work. You can<a id="id126" class="indexterm"/> use the <code class="literal">IsBusy()</code> function.</p><p>You can use the <strong>Process Explorer</strong> to view the running threads for the example and monitor its activities. You can download and install <strong>Process Explorer</strong><a id="id127" class="indexterm"/> from <a class="ulink" href="http://download.cnet.com/Process-Explorer/3000-2094_4-10223605.html">http://download.cnet.com/Process-Explorer/3000-2094_4-10223605.html</a>, if you do not already have it loaded. This is a very handy utility and will allow you to really dissect what is happening with the different threads in your application. The following is a sample of Process Explorer running alongside our <code class="literal">CodeBreaker</code> application.</p><p>Apply all the things we have learned in the previous chapter. Also, use the Windows Task Manager. You will have a better understanding of the differences between multiple processes and multithreaded applications when monitoring the application running concurrently with the four <code class="literal">BackgroundWorker</code> threads, in a computer with a quad-core microprocessor and using the Process Explorer.</p><p>Before the <strong>Start</strong> button is <a id="id128" class="indexterm"/>pressed, these are the threads and information you should see for this application:</p><div><img src="img/8321EN_02_11.jpg" alt="Exploring other examples"/></div><p>After the <strong>Start</strong> button is pressed, these are the threads and information you should see for this application:</p><div><img src="img/8321EN_02_12.jpg" alt="Exploring other examples"/></div><p>Monitor the <a id="id129" class="indexterm"/>application using one, two, three, and four threads running concurrently.</p><p>Enhance the application using the patterns we have learned in the previous example using only one <code class="literal">BackgroundWorker</code> component. Change the code to add the possibility to start and stop the threads running in each <code class="literal">BackgroundWorker</code> component.</p><p>Monitor the application starting and stopping one, two, three, and four threads running concurrently, and pay attention to what happens with the threads' activities and CPU usage in the Process Explorer.</p><p>Run the application in different computers with different microprocessors and use the Process Explorer to monitor their behavior and measure their performance.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Summary</h1></div></div></div><p>We learned a lot in this chapter about working with threads using the <code class="literal">BackgroundWorker</code> component. Specifically, we covered the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Developing applications that are able to create background threads using the <code class="literal">BackgroundWorker</code> component and showing the progress of execution by taking advantage of the methods provided by this component</li><li class="listitem" style="list-style-type: disc">Programming the threads' code to be executed by <code class="literal">BackgroundWorker</code></li><li class="listitem" style="list-style-type: disc">Understanding the differences between synchronous and asynchronous execution and how they are related to threads</li><li class="listitem" style="list-style-type: disc">Reporting the progress of multiple threads in the user interface</li><li class="listitem" style="list-style-type: disc">Starting and canceling threads created using <code class="literal">BackgroundWorker</code> instances</li><li class="listitem" style="list-style-type: disc">Launching multiple threads using many <code class="literal">BackgroundWorker</code> components</li><li class="listitem" style="list-style-type: disc">Creating the various event handlers of the <code class="literal">BackgroundWorker</code> component in code</li></ul></div><p>Now that we've learned a simple way to create many threads in a C# application using the <code class="literal">BackgroundWorker</code> component, we're ready to do these things using a much more flexible but more complex technique—the <code class="literal">Thread</code> class—which is the topic of the next chapter.</p></div></body></html>