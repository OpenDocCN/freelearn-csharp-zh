<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Reflection and Dynamic Programming</h1></div></div></div><p>The principles of Reflection in computer science are defined by Wikipedia as:</p><div><blockquote class="blockquote"><p>The ability of a computer program to examine, introspect, and modify its own structure and behavior.</p></blockquote></div><p>The internal structure of the .NET assemblies we saw in the first chapter allows us to load and invoke types embedded inside our own or foreign assemblies at runtime with a technique called dynamic invocation.</p><p>Moreover, classes related to CodeDOM and <code class="literal">Reflection.Emit</code> namespaces permit code generation at runtime, either in C# or other languages, including <strong>Intermediate Language</strong> (<strong>IL</strong>).</p><p>However, beyond the .NET-to-NET dialogs, we can use Interoperability to manipulate applications built in other non-NET programming languages. Actually, many professional applications find it suitable—and very useful—to count on external functionalities that we might detect as present in the host operating system. This means that we can interoperate with <strong>Microsoft Office Suite</strong> (<strong>Word</strong> and <strong>Excel</strong> being the most typical cases of these resources).</p><p>These applications can provide us with new and exciting possibilities, such as graph (charts) generation, text spelling, document template creation, and even add-in enhancements.</p><p>That's why our goal in this chapter is to review some of the most useful concepts and use cases that a programmer might find of interest in relation with these topics.</p><p>We will start with Reflection, analyzing the possibilities offered by .NET Framework to introspect the very structure of assemblies and invoke internal functionalities in a totally programmable way.</p><p>I will also cover the ability of emitting source code at runtime and generate new types and launch them at runtime.</p><p>In the second part, we will review the most noticeable and statistically used options offered by Interop programming, the name used to indicate when a program communicates with another application to establish a controlled, programmatic dialog in order to interchange data and emit instructions to other applications.</p><p>So, in brief, we will go through the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Concepts and the implementation of Reflection in the .NET framework</li><li class="listitem">Typical uses of Reflection in everyday programming</li><li class="listitem">Using System.Emit to generate source code at runtime</li><li class="listitem">Interop programming from the C# language</li><li class="listitem">Using Interop with Microsoft Office apps</li><li class="listitem">Creating Office add-ins or apps</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec25"/>Reflection in the .NET Framework</h1></div></div></div><p>As always, it is good to <a id="id420" class="indexterm"/>start with the main definition (MSDN source), which states that:</p><div><blockquote class="blockquote"><p>The classes in the System.Reflection namespace, together with System.Type, enable you to obtain information about loaded assemblies and the types defined within them, such as classes, interfaces, and value types. You can also use Reflection to create type instances at run time, and to invoke and access them.</p></blockquote></div><p>Remember, as we mentioned in the first chapter, that the organization of assemblies is such that they contain modules, which in turn contain types that contain members. Reflection techniques<a id="id421" class="indexterm"/> allow you to find out (introspect) which modules, types, and members are present inside a given assembly.</p><p>Therefore, when we access any member via Interop, there's a hierarchy of info properties linked to it: the generic member's info, its System.Type (the type it belongs to) namespace, the method base, and also information related to its properties, fields and events, as the next graphic shows:</p><div><img src="img/image00503.jpeg" alt="Reflection in the .NET Framework"/></div><p style="clear:both; height: 1em;"> </p><p>As per the .NET architecture analyzed in previous chapters, the two core elements that enable this behavior are the assembly's metadata and the .NET's dynamic common type system.</p><p>A simple look at the<a id="id422" class="indexterm"/> basic members of the highest element in .NET hierarchy (<code class="literal">System.Object</code>) shows that Reflection is at the very core of its inception, since we have a <code class="literal">GetType()</code> method that is going to be present all along the chain of objects.</p><p>Actually, <code class="literal">GetType()</code> returns<a id="id423" class="indexterm"/> an instance of the <code class="literal">System.Type</code> class, served in a way that encapsulates all the metadata of the object being examined. It is with this <code class="literal">System.Type</code> instance that you will be able to traverse all details of the type or class (except the IL code) and also gain the ability to discover the surrounding context: the module that implements that type and its containing assembly.</p><p>In the <a class="link" title="Chapter 3. Advanced Concepts of C# and .NET" href="part0023.xhtml#aid-LTSU2">Chapter 3</a>, <em>Advanced Concepts of C# and .NET</em>, we included the following sample to test the very basics of Reflection:</p><div><pre class="programlisting">dynamic dyn = "This is a dynamic declared string";
Type t = dyn.GetType();
PropertyInfo prop = t.GetProperty("Length");
int stringLength = prop.GetValue(dyn, new object[] { });
Console.WriteLine(dyn);
Console.WriteLine(stringLength);</pre></div><p>In this code, we're using <code class="literal">GetType()</code> and casting the result to a <code class="literal">Type</code> object, which we can later use to inspect the members of the <code class="literal">dyn</code> variable. A look at the Object Browser in the search for the <code class="literal">System.Type</code> instance makes things quite clear:</p><div><img src="img/image00504.jpeg" alt="Reflection in the .NET Framework"/></div><p style="clear:both; height: 1em;"> </p><p>The screenshot shows how <code class="literal">System.Type</code> implements the <code class="literal">IReflect</code> interface, which provides a gang of methods for introspection (most of them starting with <code class="literal">Get</code>, followed by the target introspection to find out fields, members, and so on).</p><p>Also, note the presence<a id="id424" class="indexterm"/> of the <code class="literal">InvokeMember</code> method, which permits dynamic invocation of the type's members at runtime and can be used for a variety of purposes. The return values of these methods are arrays that represent the information structure of every individual member: <code class="literal">MemberInfo[]</code>, <code class="literal">PropertyInfo[]</code>, <code class="literal">MethodInfo[]</code>, and <code class="literal">FieldInfo[]</code>.</p><p>Now, let's start coding <a id="id425" class="indexterm"/>some of these ideas in a simple console application that declares a <code class="literal">Person</code> class with three properties and a method and learn how we get all this information at runtime.</p><p>Please, notice that the <code class="literal">Person</code> class owns a property which uses a method declared in a distinct namespace (<code class="literal">System.Windows.Forms</code>). There's no problem to access that method via Reflection and invoking it, only that we have to reference the namespace, together with <code class="literal">System.Reflection</code>, that we'll use a bit later:</p><div><pre class="programlisting">using System;
using System.Reflection;
using System.Windows.Forms;
using static System.Console;

namespace Reflection1
{
  class Program
  {
    static void Main(string[] args)
    {
      Person p = new Person()
      {
        eMail = "person@email",
        Name = "Person Name",
        BirthDate = DateTime.Today
      };
      WriteLine($"Type of p: { p.GetType() }");
      Read();
    }
  }
  class Person
  {
    public string Name { get; set; }
    public string eMail { get; set; }
    public DateTime BirthDate { get; set; }
    public void ShowPersonData(string caption, MessageBoxIcon icon)
    {
      MessageBox.Show(this.Name + " - " + this.BirthDate,
      caption, MessageBoxButtons.OK, icon);
    }
  }
}
// Output: "Type of p:  Reflection1.Person"</pre></div><p>We're including the output in the <a id="id426" class="indexterm"/>code since it is pretty predictable, and we're just asking for the type. However, let's continue adding some more lines before<a id="id427" class="indexterm"/> the call to <code class="literal">Read()</code>, to find out more about the <code class="literal">Person</code> class:</p><div><pre class="programlisting">WriteLine($"Type of p: { p.GetType() }");
Type tPerson = p.GetType();
WriteLine($"Assembly Name: {tPerson.Assembly.ToString()}");
WriteLine($"Module Name (Path removed): {tPerson.Module.Name}");
WriteLine($"Name of the undelying type: {tPerson.UnderlyingSystemType.Name}");
WriteLine($"Number of Properties (public): {tPerson.GetProperties().Length}");
// Now ler's retrieve all public members
var members = tPerson.GetMembers();
foreach (var member in members)
{
  WriteLine($"Member: {member.Name}, {member.MemberType.ToString()}");
}
Read();</pre></div><p>Now, we find out something else about the internal structure, as shown in the output:</p><div><img src="img/image00505.jpeg" alt="Reflection in the .NET Framework"/></div><p style="clear:both; height: 1em;"> </p><p>Some of the <em>hidden</em> members show up now, such as the default constructor created by the compiler (<code class="literal">.ctor</code>), the conversion of the <code class="literal">{get; set;}</code> declarations into pairs of field/access methods, and the<a id="id428" class="indexterm"/> inherited members from the object. Using these methods, we obtain all the information that's relative to a member.</p><p>Not only can we find<a id="id429" class="indexterm"/> out the structure of another type, but we can also invoke its members, as mentioned earlier. For example, the <code class="literal">ShowPersonData</code> method receives two parameters to configure a <code class="literal">MessageBox</code> object, where it presents some information to the user.</p><p>This means that we need to be able to call the method and also configure and send the parameters it requires. We can do this with the following code:</p><div><pre class="programlisting">// Invoke a method
var method = tPerson.GetMethod("ShowPersonData");
object[] parameters = new object[method.GetParameters().Length];
parameters[0] = "Caption for the MessageBox";
parameters[1] = MessageBoxIcon.Exclamation;
method.Invoke(p, parameters);</pre></div><p>Since parameters can be of any type, we create an object array that will be used at runtime to correspond every item in the array with its argument in the method. In this case, we want to pass the caption of the dialog box and the icon to be used.</p><p>As expected, we get the <a id="id430" class="indexterm"/>corresponding <code class="literal">MessageBox</code> object at runtime with the correct configuration:</p><div><img src="img/image00506.jpeg" alt="Reflection in the .NET Framework"/></div><p style="clear:both; height: 1em;"> </p><p>Of course, we can also perform<a id="id431" class="indexterm"/> the manipulation of properties in a similar manner:</p><div><pre class="programlisting">// Change a Property
WriteLine(" Write/Read operations\n");
var property = tPerson.GetProperty("Name");
object[] argums = { "John Doe" };
WriteLine($" Property {property.Name} - Is writable: {property.CanWrite}");
tPerson.InvokeMember("Name", BindingFlags.SetProperty, null, p, argums);
WriteLine($" Property {property.Name}: written ok.");
// Read the Name property
object value = tPerson.InvokeMember(property.Name, BindingFlags.GetProperty, null, p, null);
WriteLine($" New {property.Name} is: {value}");</pre></div><p>The output confirms that the property was of a read/write kind and also confirms the results of the change (note that we don't pass any argument to read the data):</p><div><img src="img/image00507.jpeg" alt="Reflection in the .NET Framework"/></div><p style="clear:both; height: 1em;"> </p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec59"/>Calling external assemblies</h2></div></div></div><p>If we need<a id="id432" class="indexterm"/> information and/or functionality concerning a different assembly, that's also possible using the <code class="literal">Assembly</code> object or by referencing the assembly and obtaining its data from the static <code class="literal">GetType()</code> method of the <code class="literal">Type</code> object.</p><p>This includes those that are part of .NET Framework itself. To access all these functionalities, the <code class="literal">System.Reflection</code> namespace provides a cluster of related possibilities. A syntax such as this can serve the purpose:</p><div><pre class="programlisting">using System;
using System.Windows.Forms;
using System.Reflection;
using static System.Console;

namespace Reflection1
{
  class Program2
  {
    static void Main(string[] args)
    {
      // Direct reflection of a referenced type
      // (System.Math belongs to mscorlib)
      WriteLine("\n MemberInfo from System.Math");
      // Type and MemberInfo data.
      Type typeMath = Type.GetType("System.Math");
      MemberInfo[] mathMemberInfo = typeMath.GetMembers();
      // Shows the DeclaringType method.
      WriteLine($"\n The type {typeMath.FullName} contains {mathMemberInfo.Length} members.");
      Read();
    }
  }
}

// output:
// MemberInfo from System.Math
// The type System.Math contains 76 members.</pre></div><p>So, we're reflecting on a reference type (<code class="literal">System.Math</code>) included in the basic library, <code class="literal">mscorlib</code>, to find out how many members are included, such as in the previous case.</p><p>Alternatively, we can load <a id="id433" class="indexterm"/>an assembly at runtime using the <code class="literal">Assembly</code> object and even create an instance of that object using the <code class="literal">CreateInstance()</code> static method with code like this:</p><div><pre class="programlisting">// Loading an assembly at runtime.
Assembly asm = Assembly.Load("mscorlib");
Type ty = asm.GetType("System.Int32");
WriteLine(ty.FullName);
Object o = asm.CreateInstance("System.Int32");
WriteLine(o.GetType().FullName);   // =&gt; System.Int32</pre></div><p>It is also possible to get all the referenced assemblies of the current (running) assembly. The <code class="literal">GetExecutingAssembly()</code> method returns an <code class="literal">Assembly</code> object pointing to itself, and by calling <code class="literal">GetReferencedAssemblies()</code>, we get all this information. The following code will suffice to obtain this list:</p><div><pre class="programlisting">// Get information on assemblies referenced in the current assembly.
AssemblyName[] refAssemblies;
refAssemblies =   Assembly.GetExecutingAssembly().GetReferencedAssemblies();
WriteLine(" Assemblies referenced by the running assembly:");
foreach (var item in refAssemblies)
{
  Console.WriteLine(" " + item.FullName);
}
Read();</pre></div><p>The entire output (including the three previous routines) looks like what is shown in the following screenshot:</p><div><img src="img/image00508.jpeg" alt="Calling external assemblies"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec60"/>Generic Reflection</h2></div></div></div><p>Reflection of generic types is also available and can be checked using Boolean properties, such as <code class="literal">IsGenericType</code>, <code class="literal">IsGenericTypeDefinition</code>, or <code class="literal">GetGenericArguments()</code>. The same mechanisms <a id="id434" class="indexterm"/>apply in this case, only checking the corresponding types for the difference. The following is a short demo, which declares a generic <code class="literal">Dictionary</code> object and recovers information on its types:</p><div><pre class="programlisting">using System;
using static System.Console;
using System.Collections.Generic;

namespace Reflection1
{
  class Program3
  {
    static void Main(string[] args)
    {
      var HttpVerbs = new Dictionary&lt;string, string&gt;();
      HttpVerbs.Add("Delete", "Requests that a specified URI be deleted.");
      HttpVerbs.Add("Get", "Retrieves info that is identified by the URI of the request");
      HttpVerbs.Add("Head", "Retrieves the message headers ");
      HttpVerbs.Add("Post", "Posts a new entity as an addition to a URI.");
      HttpVerbs.Add("Put", "Replaces an entity that is identified by a URI.");

      // Reflection on a generic type
      Type t = HttpVerbs.GetType();
      WriteLine($"\r\n {t}");
      WriteLine($" Is a generic type? {t.IsGenericType}");
      WriteLine($" Is a generic type definition? {t.IsGenericTypeDefinition}");

      // Info on type parameters or type arguments.
      Type[] typeParameters = t.GetGenericArguments();

      WriteLine($" Found {typeParameters.Length} type arguments:");
      foreach (Type tParam in typeParameters)
      {
        if (tParam.IsGenericParameter)
        {
          // Display Generic Parameters (if any);
          Console.WriteLine($" Type parameter: {tParam.Name} in position: " + $" {tParam.GenericParameterPosition}");
        }
        else
        {
          Console.WriteLine($" Type argument: {tParam}" );
        }
      }
      Read();
    }
  }
}</pre></div><p>The—quite predictable—output shows characteristics about the type (generic) and its members (non generic) and iterates over a loop, checking for the genericity of every type (using the <code class="literal">IsGenericParameter</code> Boolean property) before printing its details:</p><div><img src="img/image00509.jpeg" alt="Generic Reflection"/></div><p style="clear:both; height: 1em;"> </p><p>So, changing the methods' calls and/or adding some checking, we can also use generic types with Reflection, just as we did with the <em>classical</em> ones.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec61"/>Emitting code at runtime</h2></div></div></div><p>Another interesting possibility<a id="id435" class="indexterm"/> is the capacity of some classes in the .NET Framework to emit code at runtime and—eventually—compile and run it. Observe that Visual Studio itself creates code in many scenarios: when<a id="id436" class="indexterm"/> creating the structure of documents in different languages from a template, using code snippets, scaffolding an ORM in ASP.NET, and so on.</p><p>This is a task that can be achieved mainly in two ways: using CodeDOM or by means of classes inside the <code class="literal">System.Reflection.Emit</code> namespace.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec39"/>The System.CodeDOM namespace</h3></div></div></div><p>The first option refers to the <code class="literal">System.CodeDOM</code> and <code class="literal">System.CodeDOM.Compiler</code> namespaces, and it's been present in .NET since the very first version of the framework. Note the DOM part of the<a id="id437" class="indexterm"/> name: it means Document Object Model, just like in HTML, XML, or other document structures.</p><p>With classes inside CodeDOM, we can generate source code using templates that define coding structures in different languages, so we can even generate source code in all languages supported by .NET Framework.</p><p>To generate code for any .NET structure, CodeDOM classes represent any aspect of the generated code, and we should use two different mechanisms: one that expresses the elements to be built and another that—when lunched—produces the actual code.</p><p>Let's imagine how can we generate the previous <code class="literal">Person</code> class; only, reduce it to a minimum of elements for sake of clarity.</p><p>We will need the following:</p><div><ul class="itemizedlist"><li class="listitem">An instance of <code class="literal">CodeCompileUnit</code>, which is in charge of generating the DOM structure of our component (its code graph). This structure is responsible for scaffolding the different members our class contains: properties, fields, methods, and so on.</li><li class="listitem">The rest of the elements have to be created one by one using classes available in CodeDOM, which represent every possible reserved word or structure (classes, methods, parameters, and so on).</li><li class="listitem">Finally, all elements created individually are included in the <code class="literal">CodeCompileUnit</code> object prior to its generation.</li></ul></div><p>Let's take a look at the code, which produces a file that contains the same definition of a <code class="literal">Person</code> class that we used at the beginning of this chapter (for the sake of brevity, I'm just including here the<a id="id438" class="indexterm"/> initial lines and final lines. You'll find the whole code in demo <code class="literal">Reflection1</code> inside this chapter's source code):</p><div><pre class="programlisting">using System.CodeDom;
using System.Reflection;
using System.CodeDom.Compiler;
using System.IO;

namespace Reflection1
{
  class Program5
  {
    static void Main(string[] args)
    {
      CodeCompileUnit oCU = new CodeCompileUnit();
      CodeTypeDeclaration oTD;

      // Working with CodeDOM
      CodeNamespace oNamespace = new CodeNamespace("Reflection1");
      // CodeNameSpace can import declarations of other namespaces
      // which is equivalent to the "using" statement
      oNamespace.Imports.Add(new CodeNamespaceImport("System.Windows.Forms"));
      // Class creation is undertaken by CodeTypeDeclaration class.
      // You can configure it with attributes, properties, etc.
      oTD = new CodeTypeDeclaration();
      oTD.Name = "Person";
      oTD.IsClass = true;


      // Generate code
      CodeDomProvider provider = CodeDomProvider.CreateProvider("CSharp");
      CodeGeneratorOptions options = new CodeGeneratorOptions();
      options.BracingStyle = "C";
      using (StreamWriter sr = new StreamWriter(@"Person.cs"))
      {
        provider.GenerateCodeFromCompileUnit(oCU, sr, options);
      }
    }
  }
}</pre></div><p>Once we establish our entry point in <code class="literal">Program5</code>, its execution generates a file with the same code that we had in the <code class="literal">Program.cs</code> file.</p><div><h3 class="title"><a id="tip07"/>Tip</h3><p>Note that you will have to check the <code class="literal">bin/debug</code> directory, since we didn't establish a different output path.</p></div><p>You should see something like the following screenshot in your <strong>Solution Explorer</strong>:</p><div><img src="img/image00510.jpeg" alt="The System.CodeDOM namespace"/></div><p style="clear:both; height: 1em;"> </p><p>As you can see, the generated code is pretty verbose. However, that's what it takes to generate code feature by feature. Let's go briefly through it and underline the most important classes implied in the generation, starting with the end of the <code class="literal">Main</code> method.</p><p>The object that puts <a id="id439" class="indexterm"/>everything to work is the <code class="literal">CodeDomProvider</code> class. It has to be instantiated, indicating the language to be used (<code class="literal">CSharp</code>, in our case). At the end, we will invoke its <code class="literal">GenerateCodeFromCompileUnit</code> method, which will use all previous definitions to produce the actual code inside the file defined for this purpose.</p><p>So, at the top of <code class="literal">Program5</code>, we declare a <code class="literal">CompilerUnit</code> object. The other crucial component is the <code class="literal">CodeTypeDeclaration</code> object, which is in charge of storing all declarations used while code generation takes place.</p><p>The rest of the classes implied in the construction are merely helper classes to build each brick of the resulting class. This is the role of the <code class="literal">CodeNamespace</code>, <code class="literal">CodeNamespaceImport</code>, <code class="literal">CodeSnippetTypeMember</code>, <code class="literal">CodeCommentStatement</code>, <code class="literal">CodeMemberMethod</code>, and <code class="literal">CodeParameterDeclarationExpression</code> classes.</p><p>Although you may think that this is too much effort to just create the resulting class, keep in mind that the automatization of tasks inside Visual Studio follows similar paths and that you could create you own mechanisms of code generation suited to your needs or the company's requirements.</p><p>With such programmable context, it's easy to imagine a number of situations in which code generation can be tuned by the generating program at runtime, allowing you to produce code with different variations depending on options we established previously.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec40"/>The Reflection.Emit namespace</h3></div></div></div><p>The <code class="literal">System.Reflection.Emit</code> namespace is intended for code generation, allowing developers to create code<a id="id440" class="indexterm"/> or metadata from within their applications, independent of the specifics of the operating system's loaders.</p><p>Basically, this namespace offers the following programmatic options:</p><div><ul class="itemizedlist"><li class="listitem">It allows the building of modules and assemblies at runtime</li><li class="listitem">It creates classes and types and emits IL</li><li class="listitem">It launches a .NET compiler to build apps</li></ul></div><p>The way the code is generated here is different from CodeDOM in several aspects. One of them is the ability to generate IL code at runtime, which means that the execution of some C# code will produce outputs not coded in C# but using these instruments.</p><p>One of the objects implied in this type of code generation is the <code class="literal">DynamicMethod</code> object included in the <code class="literal">System.Reflection.Emit</code> namespace. This object allows the obtention of another object of type <code class="literal">ILGenerator</code>.</p><p>Once you get <code class="literal">ILGenerator</code>, you can produce IL code dynamically in a very straightforward manner:</p><div><pre class="programlisting">// 1st sample of emission (using ILGenerator):
// A way to obtain one is creating a dynamic method. When the
// method is invoked, its generated contents are executed.
DynamicMethod dn = new DynamicMethod("dynamicMethod", null, null);
var ilgen = dn.GetILGenerator();
ilgen.EmitWriteLine("Testing Reflection Emit.");
ilgen.EmitWriteLine("We use IlGenerator here...");
ilgen.Emit(OpCodes.Ret);
dn.Invoke(null, null);</pre></div><p>Observe how we finally call the <code class="literal">DynamicObject.Invoke</code> method as if it were a delegate. If you test the previous code, the output generated will correspond to what is the equivalent of the <a id="id441" class="indexterm"/>counterpart lines of the code programmed in C#, which produces the same information in the output:</p><div><img src="img/image00511.jpeg" alt="The Reflection.Emit namespace"/></div><p style="clear:both; height: 1em;"> </p><p>Also, note the presence of the <code class="literal">OpCodes.Ret</code> value in the last call to <code class="literal">ilgen.Emit</code>. This generates a return statement, which pushes the return value, if present, from the evaluation stack to the caller's evaluation stack.</p><p>If you take a look at fields related to OpCodes, you'll discover that it provides an extensive list of field representations of MSIL instructions, as shown in the next screenshot:</p><div><img src="img/image00512.jpeg" alt="The Reflection.Emit namespace"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="tip08"/>Tip</h3><p>Note that if you want to take a <a id="id442" class="indexterm"/>deep dive into these possibilities, there's a page on MSDN, which contains an exhaustive relation of all the OpCodes at <a class="ulink" href="https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes_fields(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes_fields(v=vs.110).aspx</a>.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec26"/>Interoperability</h1></div></div></div><p>The other big topic we want to cover in this chapter is the possibility of a .NET application "talking" to<a id="id443" class="indexterm"/> other installed applications in our system. This talking means instantiating these applications and interchanging data between them or asking the other applications to perform tasks we should program ourselves.</p><p>Initially (in versions previous to C# 4.0), this technology was exclusively COM-based. The trick was done via Interop using some DLLs called <strong>Type Libraries</strong> (<strong>TLB</strong>) or <strong>Object Libraries</strong> (<strong>OLB</strong>). The programmer should then use (reference) these libraries and instantiate their internal objects, which represent the internal components of the application to communicate with.</p><p>This was possible using a <strong>Runtime Callable Wrapper</strong> (<strong>RCW</strong>) whose operational schema is explained in the following figure:</p><div><img src="img/image00513.jpeg" alt="Interoperability"/></div><p style="clear:both; height: 1em;"> </p><p>Let's see how communication was made between the COM and .NET worlds. You have to keep in mind that COM is not a managed environment, and it executes instructions native to the Windows operating system. The RCW component was responsible for this and acted as a proxy between both execution contexts.</p><p>No optional parameters were available for a C# programmer in this model. So, you had to pass as many parameters as the method defined, using the <code class="literal">System.Reflection.Missing.Value</code> type, besides other difficulties present in the way Reflection was used to find out which members were present and usable, plus other related paraphernalia.</p><p>This is code that illustrates such a situation in early versions. It assumes that a reference has been made to the corresponding TLB of Microsoft Word, which exposed an object called <code class="literal">ApplicationClass</code> to allow Word instantiation:</p><div><pre class="programlisting">public void OpenWordDoc()
{
  ApplicationClass WordApp = new ApplicationClass();
  WordApp.Visible = true;
  object missing = System.Reflection.Missing.Value;
  object readOnly = false;
  object isVisible = true;
  object fileName = Path.Combine(
    AppDomain.CurrentDomain.BaseDirectory, @"..\..\..\Document.doc");
  Microsoft.Office.Interop.Word.Document theDoc = WordApp.Documents.Open(
      ref fileName, ref missing, ref readOnly, ref missing,
      ref missing, ref missing, ref missing, ref missing,
      ref missing, ref missing, ref missing, ref isVisible,
      ref missing, ref missing, ref missing, ref missing);
  theDoc.Activate();
}</pre></div><p>Note how all the <a id="id444" class="indexterm"/>arguments that the <code class="literal">Open</code> method defines, had to be passed as <code class="literal">missing</code> for this case. As you see, this is a pretty clumsy way to open a document and access its members (actually, when using this Interop feature, operating from Visual Basic .NET was much easier and simple some time ago.).</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec62"/>Primary Interop Assemblies</h2></div></div></div><p>As technologies evolved, type<a id="id445" class="indexterm"/> libraries were replaced with something called <strong>PIAs</strong> (<strong>Primary Interop Assemblies</strong>), which play the same role as the RCWs but allow programmability in an easier manner.</p><p>So, the way to <a id="id446" class="indexterm"/>communicate with external (interoperable) applications becomes possible through those libraries that take care of the required marshalling of data types between two worlds which are—at first—not so easy to connect, especially for those programmers not skilled enough to use the COM platform.</p><p>The following schema shows this communication architecture:</p><div><img src="img/image00514.jpeg" alt="Primary Interop Assemblies"/></div><p style="clear:both; height: 1em;"> </p><p>Let's start from the <a id="id447" class="indexterm"/>beginning, only using the latest versions to see how we operate today.</p><p>To obtain (and see in action) an instance of an interoperable application, the first step is to reference the corresponding PIA that will serve as the proxy. This is available in the <strong>References</strong> option of any .NET application, only not in the default DLL's tab but in the <strong>Extensions</strong> tab.</p><p>Note that you will see a <a id="id448" class="indexterm"/>bunch of DLLs available, and—in many cases—you'll observe duplications. You have to pay attention to the version number, which will vary depending on the Office version installed on your machine.</p><p>Besides, you might find duplications of even the same versions in different locations in your box. This is due to the fact that the installation of Office allows the user to manually include these PIAs during the process or it might be due to the previous installation of older Office versions:</p><div><img src="img/image00515.jpeg" alt="Primary Interop Assemblies"/></div><p style="clear:both; height: 1em;"> </p><p>If you check the <strong>COM</strong> option of <strong>Reference Manager</strong>, you will also discover the presence of some entries with the word <code class="literal">Excel</code> inside. They might vary in your machine, but usually, they point to the corresponding executable being referenced (<code class="literal">Excel.exe</code>, in the next screenshot).</p><p>However, if you mark this <a id="id449" class="indexterm"/>option as well and accept the selection, you won't see a reference to <code class="literal">Excel.exe</code> in the list of your Project's references. Instead, you'll see a library whose name is the same as what it was in the previous case (when I referenced the PIA) but one that really points to a DLL in the GAC called <code class="literal">Microsoft.Office.Interop.Excel</code>, followed by a GUID number: the reference is "redirected" to point to the most suitable library:</p><div><img src="img/image00516.jpeg" alt="Primary Interop Assemblies"/></div><p style="clear:both; height: 1em;"> </p><p>The object model that Excel offers to the programmer recalls exactly that of its user interface. There's an <code class="literal">Application</code> object, which represents the entire application, and each <code class="literal">Workbook</code> object is represented by its corresponding object in the model. Each one contains a collection of the <code class="literal">Worksheet</code> objects. Once the starting point is ready, the <code class="literal">Range</code> object enables<a id="id450" class="indexterm"/> you to operate with individual (or groups of) cells.</p><p>To start with, let's call an<a id="id451" class="indexterm"/> Excel instance in the modern, easier way, and show it with a new Excel book. In this sample, in order to interchange information between our application and Excel or Word later on, I'm using a basic Windows Forms application, which will launch Excel using the following code.</p><p>Somewhere in our Windows Form, we define this:</p><div><pre class="programlisting">using Excel = Microsoft.Office.Interop.Excel;
using Word = Microsoft.Office.Interop.Word;
...
private void Form1_Load(object sender, EventArgs e)
{
  OpenExcel();
}
public void OpenExcel()
{
  var excel = new Excel.Application();
  excel.Visible = true;
  excel.Workbooks.Add();
  excel.get_Range("A1").Value2 = "Initial Data";
  excel.get_Range("B1").Value2 = "Demo data 1";
  excel.get_Range("C1").Value2 = "Demo data 2";
  excel.get_Range("D1").Value2 = "Demo data 3";
}</pre></div><p>This, indeed, launches Excel and passes this information to the four cells referenced in the code, as we can see in the output. Note the initial declarations to reference Excel and Word in our code. With this alias, it becomes easier to reference any object in the proxy and the code becomes less verbose. Since we call <code class="literal">OpenExcel</code> when the document is loaded, both applications will be opened, the second one being Excel presenting our data:</p><div><img src="img/image00517.jpeg" alt="Primary Interop Assemblies"/></div><p style="clear:both; height: 1em;"> </p><p>This is nothing amazing <a id="id452" class="indexterm"/>or unexpected, but we see that it's fairly easy to call other applications with Interop and pass data to them. Anyway, some peculiarities of Office Interop (also common to other applications) are evident here.</p><p>To start with, you have to declare the <code class="literal">excel</code> object as <code class="literal">Visible</code>. That's because by default, Office Interop applications don't show up. This is very useful when you just want a functionality to happen and recover the results in your application without the target app bothering the final user.</p><p>Obviously, we're using <a id="id453" class="indexterm"/>some objects you might not be familiar with, since they belong to the target application: <code class="literal">Range</code> represents a range of cells within the current Worksheet, the <code class="literal">get_Range</code> method recovers a <code class="literal">Set</code>/<code class="literal">Get</code> reference to the required cells we pass as an argument. Note, we can indicate the range required in the string we passed to this method or use an enumeration, such as in <code class="literal">get_Range(c1, c2)</code>.</p><p>Alternatively, we can also create a <code class="literal">Range</code> object using a syntax like this:</p><div><pre class="programlisting">// an alternative way to get a range object
var oSheet = excel.Sheets[1]; // Index starts by 1
var oRange = (Excel.Range)oSheet.Range[oSheet.Cells[1, 2],
  oSheet.Cells[4, 3]];
oRange.Value2 = "Same value";</pre></div><p>Observe that in this case, we declare a <code class="literal">Sheet</code> object recovered from the available collection of sheets that Excel creates in the initial workbook. With this object and using an array-like syntax, we select the initial and ending cells to include in our range (by default, all of them are accessible).</p><p>Also, note that when <a id="id454" class="indexterm"/>we define a rectangle with our cells, several columns are collected, so the resulting modification ends up with the following output:</p><div><img src="img/image00518.jpeg" alt="Primary Interop Assemblies"/></div><p style="clear:both; height: 1em;"> </p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec41"/>Formatting cells</h3></div></div></div><p>Most likely, we will have to<a id="id455" class="indexterm"/> format the contents we pass to an Excel sheet. This implies another way to operate (which is very coherent; let's underline that).</p><p>Most of these objects are defined separately and then applied to the corresponding object to be targeted. In the case of formatting, keep in mind that the format should be applied to cells that hold some value (it might well be that you opened an existing workbook object).</p><p>So, we're going to create another method in our Form to call Excel and create a style that we can apply to our cells. Something like this would be enough for now:</p><div><pre class="programlisting">public Excel.Style FormatCells()
{
  Excel.Style style = excel.ActiveWorkbook.Styles.Add("myStyle");
  //Creation of an style to format the cells
  style.Font.Name = "Segoe UI";
  style.Font.Size = 14;
  style.Font.Color = ColorTranslator.ToOle(Color.White);
  style.Interior.Color = ColorTranslator.ToOle(Color.Silver);
  style.HorizontalAlignment = Excel.XlHAlign.xlHAlignRight;
  return style;
}</pre></div><p>Note that some objects always make a reference to the current (active in that moment) element, such as <code class="literal">ActiveWorkBook</code> or an alternative <code class="literal">ActiveSheet</code>. We also can count on an <code class="literal">ActiveCell</code> object that operates on a given range previously selected.</p><p>Finally, we call <code class="literal">oRange.Columns.AutoFit()</code> in order to make every column as wide as the maximum length inside it. With this definition, we can call <code class="literal">FormatCells</code> whenever we need the style to be <a id="id456" class="indexterm"/>applied on any range. In this case, operating over the second range defined, the output shows the correct formatting applied:</p><div><img src="img/image00519.jpeg" alt="Formatting cells"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec42"/>Inserting multimedia in a sheet</h3></div></div></div><p>Another interesting <a id="id457" class="indexterm"/>option is the ability to insert external images inside the area of our selection. This can even be performed using any content available on the clipboard. In this case, the code is quite straightforward:</p><div><pre class="programlisting">// Load an image to Clipboard and paste it
Clipboard.SetImage(new Bitmap("Packt.jpg"));
excel.get_Range("A6").Select();
oSheet.Paste();</pre></div><p>The output shows the Packt logo located in the selected cell:</p><div><img src="img/image00520.jpeg" alt="Inserting multimedia in a sheet"/></div><p style="clear:both; height: 1em;"> </p><p>We're assuming that a picture with the Packt Publishing logo is available at the current (execution) path. Of course, we could save it in a resource file and recover it in some other fashion. For<a id="id458" class="indexterm"/> example, we can recover the front page image of this book from its corresponding link on the Packt Publishing site at <a class="ulink" href="https://www.packtpub.com/sites/default/files/B05245_MockupCover_Normal_.jpg">https://www.packtpub.com/sites/default/files/B05245_MockupCover_Normal_.jpg</a> using this code:</p><div><pre class="programlisting">public Bitmap LoadImageFromSite()
{
  // Change your URL to point to any other image...
  var urlImg = @"https://www.packtpub.com/sites/default/files/B05245_MockupCover_Nor	mal_.jpg";
  WebRequest request = WebRequest.Create(urlImg);
  WebResponse response = request.GetResponse();
  Stream responseStream = response.GetResponseStream();
  return new Bitmap(responseStream);
}</pre></div><p>Here, we need the help of the <code class="literal">WebRequest/WebResponse</code> objects that belong to the <code class="literal">System.Net</code> namespace as well as the <code class="literal">Stream</code> class, which you find as part of the <code class="literal">System.IO</code> namespace. As you can imagine, in the Windows Forms code, we change the previous code for:</p><div><pre class="programlisting">Clipboard.SetImage(LoadImageFromSite());</pre></div><p>The resulting output shows this book's front page located at cell A6 (remember that it's important to select the destination target before you do this):</p><div><img src="img/image00521.jpeg" alt="Inserting multimedia in a sheet"/></div><p style="clear:both; height: 1em;"> </p><p>In this manner, we have a <a id="id459" class="indexterm"/>bunch of possible additions to build Excel sheets, including external content, which, of course, doesn't have to be graphical and admits other types of content (even video).</p><p>When we deal with graphics in Excel, usually what we really want is to instruct Excel to build a business chart from some data. Once that is done, we can save it as an image file or recover it and present it in our application (often not showing Excel's user interface in any manner).</p><p>To get an Excel chart object up and running, we have to add a chart to the WorkBook's chart collection in a manner similar to what we did with the WorkBook itself. To generate a given type of chart, a useful object is the <code class="literal">ChartWizard</code> object, which receives configuration parameters that allow us to indicate one from the many types of charts available and the text of <code class="literal">Title</code> required for our chart. So, we might end up with something like this:</p><div><pre class="programlisting">chart.ChartWizard(Source: range.CurrentRegion,
  Title: "Memory Usage of Office Applications");
chart.ChartType = Excel.XlChartType.xl3DArea;
chart.ChartStyle = 14;
chart.ChartArea.Copy();</pre></div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>The explanation of the<a id="id460" class="indexterm"/> different types of charts and styles can be found in the MSDN documentation and exceeds the coverage of this book (it is available at <a class="ulink" href="https://msdn.microsoft.com/en-us/library/microsoft.office.tools.excel.aspx">https://msdn.microsoft.com/en-us/library/microsoft.office.tools.excel.aspx</a>).</p></div><p>Note that we finally copy the generated graphic to the clipboard in order to use the same technique as earlier, although you can use some other approaches to get the image as well.</p><p>To get some straightforward<a id="id461" class="indexterm"/> data to build the image, I've started from an old Microsoft demo, which recovers processes from the memory but changes the target to only processes related to Microsoft Office applications and reduces the code to a minimum:</p><div><pre class="programlisting">public void DrawChart()
{
  var processes = Process.GetProcesses()
    .OrderBy(p =&gt; p.WorkingSet64);
  int i = 2;
  foreach (var p in processes)
  {
    if (p.ProcessName == "WINWORD" ||
      p.ProcessName == "OUTLOOK" ||
      p.ProcessName == "EXCEL")
    {
      excel.get_Range("A" + i).Value2 = p.ProcessName;
      excel.get_Range("B" + i).Value2 = p.WorkingSet64;
      i++;
    }
  }

  Excel.Range range = excel.get_Range("A1");
  Excel.Chart chart = (Excel.Chart)excel.ActiveWorkbook.Charts.Add(
    After: excel.ActiveSheet);

  chart.ChartWizard(Source: range.CurrentRegion,
    Title: "Memory Usage of Office Applications");
  chart.ChartType = Excel.XlChartType.xl3DArea;
  chart.ChartStyle = 14;
  //chart.CopyPicture(Excel.XlPictureAppearance.xlScreen,
  //    Excel.XlCopyPictureFormat.xlBitmap,
  //    Excel.XlPictureAppearance.xlScreen);
  chart.ChartArea.Copy();
}</pre></div><p>In another event handler linked to a button (the entire demo is available, as always, with the companion code for this chapter), we launch the process in this way:</p><div><pre class="programlisting">private void btnGenerateGraph_Click(object sender, EventArgs e)
{
  DrawChart();
  if (Clipboard.ContainsImage())
  {
    pbChart.SizeMode = PictureBoxSizeMode.StretchImage;
    pbChart.Image = Clipboard.GetImage();
  }
  else
  {
    MessageBox.Show("Clipboard is empty");
  }
}</pre></div><p>We're assuming that a <code class="literal">PictureBox</code> control is present in the form with the name <code class="literal">pbChart</code>. However, before <a id="id462" class="indexterm"/>showing the results, note that if the user interacts with Excel, we need to manually close and destroy the resources created by the application; so, in the <code class="literal">form_closing</code> event, we're including this sample code:</p><div><pre class="programlisting">private void frmInteropExcel_FormClosing(object sender, FormClosingEventArgs e)
{
  excel.ActiveWorkbook.Saved = true;
  excel.UserControl = false;
  excel.Quit();
}</pre></div><p>Besides, we have created an Excel object at the beginning (declared in the form's scope and instantiated in the <code class="literal">Initialize</code> event), so the <code class="literal">excel</code> variable is available alongside all methods in the form. When executing, we get both applications running (I keep Excel visible for demoing purposes):</p><div><img src="img/image00522.jpeg" alt="Inserting multimedia in a sheet"/></div><p style="clear:both; height: 1em;"> </p><p>When pressing the <strong>Generate GraphChart</strong> button, we have a duplicate output showing the generated graphic<a id="id463" class="indexterm"/> in <code class="literal">ActiveWorkBook</code> along with the picture shown within the <code class="literal">PictureBox</code> control in the Form:</p><div><img src="img/image00523.jpeg" alt="Inserting multimedia in a sheet"/></div><p style="clear:both; height: 1em;"> </p><p>Other common usages<a id="id464" class="indexterm"/> of Excel Interop include the automation of graphic reports, the generation of bulk e-mails, and automatic generation of business documents (invoices, receipts, and so on).</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec63"/>Interop with Microsoft Word</h2></div></div></div><p>The other big star in Office Automation solutions is Microsoft Word. Just like Excel, it exposes a very complete <strong>Object Model</strong> (<strong>OM</strong>), updated to expose the new features accompanying every release, and it's fully programmable in the same fashion as what we've been doing with Excel.</p><p>Naturally, Word's OM, or just WOM, is <a id="id465" class="indexterm"/>radically different from Excel and includes all the characteristics a programmer would need to automate practically any task. Actually, the user interface objects (as it happens with Excel) are faithfully represented, and that includes the ability to invoke dialog boxes that launch certain processes (such as spellcheck) or any other typical configuration feature of the editor.</p><p>As with Excel, automation takes place using a PIA (<code class="literal">Microsoft.Office.Interop.Word.dll</code>), and the initialization process is quite similar:</p><div><pre class="programlisting">Word.Application word = new Word.Application();
private void btnOpenWord_Click(object sender, EventArgs e)
{
  word.Visible = true;
  word.Documents.Add();

  var theDate = DateTime.Today.ToString(CultureInfo.CreateSpecificCulture("en-US"));
  word.Selection.InsertAfter(theDate + Environment.NewLine);
  word.Selection.InsertAfter("This text is passed to Word directly." + Environment.NewLine);
  word.Selection.InsertAfter("Number or paragraphs: " +
    word.ActiveDocument.Paragraphs.Count.ToString());
}</pre></div><p>Provided that we have a <a id="id466" class="indexterm"/>button (<code class="literal">btnOpenWord</code>), we instantiate a Word object at initialization time; so, when the user clicks, we just have to make Word visible and use the <code class="literal">Selection</code> object (which, in case there's nothing selected yet, refers to the caret).</p><p>From this point, <code class="literal">Selection</code> offers several methods to insert text (<code class="literal">InsertDatetime</code>, <code class="literal">InsertAfter</code>, <code class="literal">InsertBefore</code>, <code class="literal">InsertParagraph</code>, <code class="literal">Text</code>, and so on). Note how the resulting process writes to Word and the whole text inserted remains selected:</p><p> </p><div><img src="img/image00524.jpeg" alt="Interop with Microsoft Word"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>As always, it's important to release objects used during runtime. So, we code the following in the <code class="literal">form_closing</code> event:</p><div><pre class="programlisting">private void fmInteropWord_FormClosing(object sender, FormClosingEventArgs e)
{
  try
  {
    word.ActiveDocument.Saved = true;
    word.Quit();
  }
  catch (Exception)
  {
    MessageBox.Show("Word already closed or not present");
  }
}</pre></div><p>The manipulation <a id="id467" class="indexterm"/>of images is even easier, since we can reference any external image with a few lines of code. To load the same image as in the Excel demos, we would use the following:</p><div><pre class="programlisting">private void btnInsertImage_Click(object sender, EventArgs e)
{
  var filePath = Environment.CurrentDirectory;
  word.Selection.InsertAfter(Environment.NewLine + "Logo PACKT: ");
  var numChars = word.Selection.Characters.Count;
  word.Selection.InlineShapes.AddPicture(filePath + "\\Packt.jpg",
    Range: word.ActiveDocument.Range(numChars));
}</pre></div><p>It's important to specify here the position of the image because otherwise, the whole selection would be replaced by the <code class="literal">AddPicture</code> method. This is why we add a fourth parameter (<code class="literal">Range</code>), which allows us to indicate where the image should go.</p><p>Also, observe how we can always know every aspect of the document's elements (the number of characters and collections of <code class="literal">Rows</code>, <code class="literal">Columns</code>, <code class="literal">Shapes</code>, <code class="literal">Tables</code>, <code class="literal">Paragraphs</code>, and so on). In addition, since we can now use named parameters, we just have to pass the required ones:</p><div><img src="img/image00525.jpeg" alt="Interop with Microsoft Word"/></div><p style="clear:both; height: 1em;"> </p><p>Formatting can also be achieved very easily by selecting a <code class="literal">Range</code> object and configuring it to the required values (we created a special button for this named <code class="literal">btnFormat</code>; so, in the <code class="literal">Click</code> event, we code the following:</p><div><pre class="programlisting">private void btnFormat_Click(object sender, EventArgs e)
{
  Word.Range firstPara = word.ActiveDocument.Paragraphs[1].Range;
  firstPara.Font.Size = 21;
  firstPara.Font.Name = "Century Gothic";
  firstPara.ParagraphFormat.Alignment =
    Word.WdParagraphAlignment.wdAlignParagraphCenter;
}</pre></div><p>With the previous<a id="id468" class="indexterm"/> text in our document, once the click event is invoked, we'll get the output shown in this capture:</p><div><img src="img/image00526.jpeg" alt="Interop with Microsoft Word"/></div><p style="clear:both; height: 1em;"> </p><p>Another very common use of Word relates to its ability to operate with text and return such text to the caller function. This is especially useful in checking spelling and other internal engines, such as grammar revision.</p><p>The technique consists of passing the required text to Word, selecting it, and launching the <strong>Spell &amp; Grammar</strong> dialog box to operate on it. Once the text is revised, we can return the corrected text to the calling application. Let's see how this works in a sample. We have a button labeled <code class="literal">Spell Check</code> (named <code class="literal">btnSpellCheck</code>), which launches the process of spelling correction using this code:</p><div><pre class="programlisting">private void btnSpellCheck_Click(object sender, EventArgs e)
{
  if (word.Documents.Count &gt;= 1)
    rtbSpellingText.Text +=
      Environment.NewLine + Environment.NewLine +
    SpellCheck(rtbSpellingText.Text);
  else
    MessageBox.Show("Please, use the Open Word option first");
}

private string SpellCheck(string text)
{
  var corrected = string.Empty;
  var doc = word.ActiveDocument;
  if (!string.IsNullOrEmpty(text))
  {
    doc.Words.Last.InsertAfter(Environment.NewLine + text);
    var corRange = doc.Paragraphs.Last.Range;
    corRange.CheckSpelling();
    corrected = corRange.Text;
  }
  return corrected;
}</pre></div><p>The output consists<a id="id469" class="indexterm"/> of three elements: our .NET application, Word, and the <strong>Spell &amp; Grammar</strong> dialog box, which is launched when we call the <code class="literal">CheckSpelling</code> method, as shown in the following screenshot:</p><div><img src="img/image00527.jpeg" alt="Interop with Microsoft Word"/></div><p style="clear:both; height: 1em;"> </p><p>When the process is over, the corrected results are returned to the caller function, where we update the <code class="literal">RichTextBox</code> control used to hold the text. Note that you can keep Word invisible and the only functionality available in the user interface would be your application and the <strong>Spell &amp; Grammar</strong> dialog box.</p><p>Also, note that we check the presence of an opened document, which should otherwise generate a runtime exception. After the process, our <code class="literal">RichTextBox</code> control will contain the corrected text, as expected:</p><div><img src="img/image00528.jpeg" alt="Interop with Microsoft Word"/></div><p style="clear:both; height: 1em;"> </p><p>Besides this utility, practically any other Office-related functionality is available via automation in a<a id="id470" class="indexterm"/> similar manner. However, this is not the only way we can use and extend the Office functionality by means of .NET applications. Actually, one of the most successful options relies on Add-In constructions or Office apps.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec64"/>Office apps</h2></div></div></div><p>On the official page of <a id="id471" class="indexterm"/>Office 2013 (the version we're using here, although<a id="id472" class="indexterm"/> this sample works perfectly well in the 2016 version), Office Apps are defined in this way:</p><div><blockquote class="blockquote"><p>Apps for Office enable users to run the same solutions across applications, platforms, and devices, and provide an improved experience within Office applications by integrating rich content and services from the web.</p></blockquote></div><p>The key architecture is explained a bit further, pointing out that these apps run within supported Office 2013 applications by using the power of the web and standard web technologies such as HTML5, XML, CSS3, JavaScript, and REST APIs. This is very important for a number of reasons.</p><p>First, the use of standard technologies allows us to incorporate any previous or already created, functional content we might have. If it works on the Web, it'll work on one of these apps (although automation via JavaScript APIs does not cover all possibilities that PIAs offer). However, on the other hand, APIs exposed by JavaScript 5/6 make a number of new programming options available to developers (Web Workers, Web Sockets, and so on).</p><p>If this is not enough, consider the huge amount of JavaScript and CSS frameworks available today: jQuery, BootStrap, Angular, among others. We can use all of them in these applications. Overall, we're talking<a id="id473" class="indexterm"/> about a webpage that is hosted inside an Office client application (Excel, Word, PowerPoint, and Project are available options).</p><p>Note that these apps<a id="id474" class="indexterm"/> can run in desktop clients, Office Online, mobile browsers, and on premises and in the cloud as well. Options of deployment include the Office Store or on-site catalogs.</p><p>Let's see how this works, by using the default template that Visual Studio 2015 offers and analyzing and customizing these contents for an initial, working demo.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec43"/>The Office app default project</h3></div></div></div><p>So, let's create a new project and select the <strong>Visual C#-Office/SharePoint-Apps</strong> tree element: we're offered three<a id="id475" class="indexterm"/> choices. If you select the <strong>Apps for Office</strong> option, a selection box will be shown (I'll use <strong>Task pane</strong> here, but you also have <strong>Content</strong> and <strong>Mail</strong>):</p><div><img src="img/image00529.jpeg" alt="The Office app default project"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="tip10"/>Tip</h3><p>Other templates for<a id="id476" class="indexterm"/> many different types of apps are at your disposal on the site available at <a class="ulink" href="http://dev.office.com/code-samples#?filters=office%20add-ins">http://dev.office.com/code-samples#?filters=office%20add-ins</a>.</p></div><p>In this demo, I opt<a id="id477" class="indexterm"/> for Word as a destination Office application, although by default, all checkboxes are marked:</p><div><img src="img/image00530.jpeg" alt="The Office app default project"/></div><p style="clear:both; height: 1em;"> </p><p>If you review the resulting files, you'll notice that these apps are basically composed of two parts: a manifest file, which configures the app's behavior, and a web page, which references all required resources: jQuery, style sheets, JavaScript initialization files, a <code class="literal">web.config</code> file, and so on.</p><p>If you open the manifest file, you'll see that Visual Studio offers a configuration file editor, where you can indicate every functional aspect. A note within the <strong>Activation</strong> tab of that window reminds us of the possible targets where this app will possibly work:</p><div><img src="img/image00531.jpeg" alt="The Office app default project"/></div><p style="clear:both; height: 1em;"> </p><p>Actually, this template already works once compiled, and it operates over a block of selected text, passing it back to the <strong>Task</strong> pane, which will appear to the right of a new Word document, showing the <code class="literal">Home.html</code> page. This page, in turn, loads the <code class="literal">Home.js</code> and <code class="literal">app.js</code> files, which take care <a id="id478" class="indexterm"/>of initialization. Other <code class="literal">.css</code> files are added for formatting purposes as well.</p><p>Besides this, there's a very important piece of JavaScript that is referenced via CDN, <code class="literal">office.js</code>. This is the library in charge of the traffic between the two worlds present here: the Office programming model and the HTML5/CSS3/JS world.</p><p>There's a graphic schema <a id="id479" class="indexterm"/>on the page at <a class="ulink" href="https://technet.microsoft.com/en-us/library/jj219429.aspx">https://technet.microsoft.com/en-us/library/jj219429.aspx</a>, which offers a visual look at the scenario at runtime:</p><div><img src="img/image00532.jpeg" alt="The Office app default project"/></div><p style="clear:both; height: 1em;"> </p><p>To run the test, launch the application from Visual Studio, and when Word appears, type some text and select it. Optionally, you can try the <em>lorem trick</em> (you might know it already): simply type <code class="literal">=lorem(n)</code> in the document, where <em>n</em> is the number of lorem paragraphs you want to generate, and lorem text will automatically get appended to the current text of the document.</p><p>Once we do that and<a id="id480" class="indexterm"/> select a fragment, the button labeled <strong>Get data from selection</strong> will recover the selected text and present it at the bottom of the <strong>Task</strong> pane. You should see something similar to what is shown in the following screenshot:</p><div><img src="img/image00533.jpeg" alt="The Office app default project"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec44"/>Architectural differences</h3></div></div></div><p>Note that this time, there's<a id="id481" class="indexterm"/> no reference to Interop libraries. This is a big architectural change, and it's undertaken by the Office JavaScript Object Model—not as exhaustive as the ones in PIAs libraries but wide enough to provide us with a lot of useful options.</p><p>Let's add a very simple method to show how we can operate in the opposite direction: inserting text into the document from the <strong>Task</strong> pane.</p><p>First, we need to add a new element to the <strong>Task</strong> pane user interface. A simple button will suffice for our purposes, so we'll add a new button next to the already existing <code class="literal">get-data-from-selection</code> button: one that I'll call <code class="literal">insert-data-from-Task-Pane</code> in the <code class="literal">Home.html</code> file:</p><div><pre class="programlisting">&lt;button id="insert-data-from-Task-Pane"&gt;Insert data from TaskPane&lt;/button&gt;</pre></div><p>The next step is programming<a id="id482" class="indexterm"/> the button's click event handler in a manner similar to what the template demo does, only simplifying the code to the maximum here. Thus, inside the <code class="literal">Home.js</code> file and next to the initialization of the other button, we will add a similar function:</p><div><pre class="programlisting">$('#insert-data-from-Task-Pane').click(insertDataFromTaskPane);</pre></div><p>And, the body of <code class="literal">insertDataFromTaskPane</code>, contains the following code:</p><div><pre class="programlisting">function insertDataFromTaskPane() {
  Office.context.document.setSelectedDataAsync(
    'Text inserted from the Task Pane' +
    '\nCallaback function notifies status',
    function (result) {
      app.showNotification('Feedback:', result.status);
    }
  );
}</pre></div><p>Note that no dialog boxes are allowed on a <strong>Task</strong> pane; so we notify the user about the success or error of the process, calling <code class="literal">showNotification</code> on the app object, which sends data to the <strong>Task</strong> pane notification area, previously configured in the initialization process.</p><p>Consequently, we're moving in both directions here: from the <strong>Task</strong> pane to the Word document, inserting a couple of lines and notifying how things worked out in the opposite direction. Observe that the <code class="literal">setSelectedDataAsync</code> method provides us with a mechanism to insert data into the document in a manner similar to what we did previously with <code class="literal">insertAfter</code> methods of the PIAs object model.</p><p>Finally, remember that in the JavaScript world it's usual to assign a callback function as the last argument of many function calls in order to allow feedback on the resulting method or add an extra functionality once execution is finished. The argument recovered in the function declaration (the <code class="literal">result</code> object) contains properties that include relevant information, such as the status of the operation.</p><p>There's plenty of information about programming this type of application in the MSDN documentation, in which you'll be able to see new types of applications of this sort, especially applications that allow the construction of Add-ins for Office 365.</p><p>Just for the sake of<a id="id483" class="indexterm"/> completeness, let's show the results of the previous code in this screenshot:</p><div><img src="img/image00534.jpeg" alt="Architectural differences"/></div><p style="clear:both; height: 1em;"> </p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec27"/>Summary</h1></div></div></div><p>We saw several aspects of programming that have to do with the ability of .NET Framework to introspect its own assemblies and invoke its functionality in a standard fashion and even use CodeDOM's possibilities to generate code at runtime, enabling a generation of templates and other code fragments at will.</p><p>We also saw a brief intro to <code class="literal">Reflection.Emit</code> just to check how it's possible to generate IL code at runtime and insert it into other executable code.</p><p>In the second part of this chapter, we covered the most common scenarios used in Office Automation, a technique that allows us to call functionalities included in Office, such as Excel and Word, and interact with them via proxy libraries (the Primary Interop Assemblies) in a way in which we gain almost absolute control over the other applications, being able to pass and recover information between our application and the Office partner via instructions emitted to these proxies.</p><p>We finally included a short introduction to the new way of building components, which appeared in version 2013 of Office (Office apps) and saw the basic architecture of these types of components, reviewing the basic template Visual Studio offers and modifying it to include a simple, double direction functionality via <strong>Office JavaScript Object Model</strong>.</p><p>In the next chapter, we will focus on database programming, covering the foundations of interactions with relational models available in Visual Studio.</p></div></body></html>