<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. No Longer Alone – Sweet-Toothed Pandas Strike</h1></div></div></div><div><blockquote class="blockquote"><p><em>"They are angry and they are hungry. Beware, the sweet-tooth pandas are getting closer for your delicious cake!</em></p></blockquote></div><p>Animations and artificial intelligence are at the core of giving life to an <strong>Non-Playing Characters</strong> (<strong>NPCs</strong>) or complex objects in games. The former makes NPCs appear dynamic and not static; the latter gives them an intelligence, with which they can move and act into the world.</p><p>This chapter explains how to use the animation system of Unity, with a particular focus on 2D animations. We will cover artificial intelligence and what it can do in video games later in the book.</p><p>The first part of the chapter will focus on the rich and sophisticated animation system of Unity (sometimes referred to as Mecanim). In explaining each part, we will bring, bit by bit, our evil pandas to life.</p><p>However, in the second part of the chapter, we will give the evil pandas the possibility to move around the map, to trigger actions such as dying or eating so much cake that they will explode... <em>literally</em>!</p><p>In particular, we will see:</p><div><ul class="itemizedlist"><li class="listitem">Animation clips and how to create and handle them from Sprite Sheets</li><li class="listitem">The Animator and how to build a finite state machine for animations</li><li class="listitem">Scripting objects with an Animator component to trigger animations and make the animation machine working</li><li class="listitem">Implementing a waypoint system to move the sweet-tooth pandas around</li></ul></div><p>Like all the other chapters of this book, you will find the <em>Homework</em> section at the end. It has a range of different exercises for you to do to improve your skills and implement a range of different functionalities in your game. So, let's get ready to learn how to bring our evil pandas to life.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec47"/>Getting ready</h1></div></div></div><p>The graphic package that we are using for this book contains an animation Sprite Sheet for our terrible sweet-tooth pandas. Therefore, be sure to have the Sprite Sheet imported as <strong>Sprite</strong> and to set <strong>Sprite Mode</strong> to <strong>Multiple</strong>. In fact, you should have all single frames in a different sprite. Remember to rename them so that you will be less confused later on. The same applies if you are using your own graphics.</p><div><img src="img/image00445.jpeg" alt="Getting ready"/><div><p>An evil panda is looking forward to eat your cake</p></div></div><p style="clear:both; height: 1em;"> </p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec48"/>Animations</h1></div></div></div><p>Life and all of its creatures are dynamic. We move, and our movements, even the subtlest of ones, express emotions. If we were to remove such things, even the tiniest smile, life would become dull and static. Animation effects can range from the simplest of things such as a flag waving to a dragon flying. Just look around you, inside and outside; something will be moving or will move from time to time. Even stones move, albeit with wind, something knocking them, or someone skipping them across water.</p><p>Unity has a complex animation system, also known as <strong>Mecanim</strong>, which requires time to get used to. It includes different components. Some of these are specifically for 3D animations; others can be used for both 2D and 3D. Usually, animating in 3D is harder than in 2D since it requires tweaking of many parameters, and therefore much more practice is needed to master it. If you are interested in learning more about 3D animation in Unity, I suggest that you to read a specific book about it.</p><p>In this book, we will focus on animating only in 2D. As such, our workflow becomes simple enough that it can be explained within this chapter. In particular, we will go through the following workflow:</p><div><ul class="itemizedlist"><li class="listitem">Creating some files called animation clips, to store our animations. We will do this starting from animation Sprite Sheets.</li><li class="listitem">Building a finite-state machine to control the flow of the animations.</li><li class="listitem">Writing a script to control the finite-state machine triggers.</li></ul></div><p>Specifically, in this section, we will see how to animate our terrible sweet-tooth pandas. In our graphic package, we can find the animation Sprite Sheets of the panda under the <code class="literal">Graphic/Enemies</code> folder. Of course, all the Sprite Sheets should already be sliced, as we have seen back in <a class="link" title="Chapter 1. A Flat World in Unity" href="part0016.xhtml#aid-F8901">Chapter 1</a>, <em>A Flat World in Unity</em> and if you are using your own graphics, it is better if all the single sprites have the same dimensions. But before we go any further in exploring Mecanim, let's go through some background information about animation in the next two sections.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec35"/>A historical overview</h2></div></div></div><p>The term <em>animation</em> derives from the Latin word <em>animates</em>, which is the past participle of the verb <em>animare</em>; that means <em>give breath to</em>. The verb derives from the word <em>anima</em>, which means <em>life, breath</em>, originating from the Greek word <em>anemos</em>, literally <em>wind</em>, which in turn descend from the Sanskrit word <em>aniti</em>, meaning <em>breathes</em>. It was only during the 1742 that the verb <em>to animate</em> was used for the first time with the sense of <em>give life to</em>.</p><p>Modern animations are based on the concept of motion. Therefore, it's worthwhile to mention that the first studies of motion were conducted by the Greek Philosopher <em>Ζήνων ὁ Ἐλεάτης</em> (known in English as <em>Zeno of Elea</em>) during the 4th century B.C. We can read about many of his ideas in works by another Greek philosopher: <em>Ἀριστοτέλης</em> (known in English as <em>Aristotle</em>). Zeno is famous for conceiving many paradoxes about motion, exploring the problem to prove the inexistence of motion. One of these paradoxes is the arrow paradox (also known as <strong>Fletcher's paradox</strong>). We can read a little bit about this from Aristotle's book Physics IV, as follows:</p><div><blockquote class="blockquote"><p><em>"If everything when it occupies an equal space is at rest, and if that which is in locomotion is always occupying such a space at any moment, the flying arrow is therefore motionless."</em></p></blockquote></div><div><img src="img/image00446.jpeg" alt="A historical overview"/><div><p>The Zeno's Fletcher's paradox described by Aristotle. You don't see the arrow moving towards the target, but just moments in which the arrow is static, albeit in different positions. Therefore, motion is an illusion.</p></div></div><p style="clear:both; height: 1em;"> </p><p>As we can see from the preceding picture, the paradox claims the motionlessness of the arrow, since in each instant the arrow is in a very particular position in space and it is static in that instant. Besides the many philosophical implications and solutions to the paradox, it's interesting to note that the same concept applies nowadays for animation. Animations in movies and video games (to name a few) are just a series of static frames, which, in a rapid succession, give the illusion of motion.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec36"/>Animations in video games</h2></div></div></div><p>Animations help to bring our creations to life. They make the living more vibrant and the dead even creepier! The development of animation has come a long way since the pixel art graphics to what can only be described as an uncanny valley of movement. In some cases, the animations are so life like that for a moment we forget that we're in an alternate reality.</p><p>Now, let's go back to the start of game animation. Space Invaders, Donkey Kong, and Tempest. If you have ever experienced one of these games, then you will know what I mean when a lot can be conveyed by very simple animation, whether it is translating side to side with Space Invaders, jumping to dodge barrels in Donkey Kong, or rotating in Tempest. However, as time progressed, so too did the animation techniques that we have become all too familiar with. With the introduction of 3D games and consequently characters, we have seen animations enter another dimension... literally. But despite their polygonal bodies and ridged movements, such as the following image of Lara Croft (though not so much nowadays), animations allow us to simply interact with a game.</p><div><img src="img/image00447.jpeg" alt="Animations in video games"/><div><p>Taken from the gameplay of Lara Croft in Tomb Raider I</p></div></div><p style="clear:both; height: 1em;"> </p><p>One good philosophy behind including animation is to think of animations as a way of communicating with your audience. Sometimes, emotions such as love, excitement, and hate are great ways to communicate feelings, just like body movements such as running, jumping, and attacking are good ways to indicate a state that the player is currently experiencing. However, animation doesn't just include the player; objects such as trees, and animals, and those who are not playing, or NPC, also interact and move about the game space, sometimes just as any controlled player would. Some of the most prolific examples of the use of animation with NPCs are in <strong>Role Playing Games</strong> (<strong>RPGs</strong>).</p><p>Many characters that you interact with develop a feeling about you. For example, if you constantly answer them with an abrupt response, they are likely to display facial expressions of despise, or shock like the next image. Where, on the other hand, if you're warm, friendly, and offer a helping hand, then their facial expressions are likely to be more welcoming.</p><div><img src="img/image00448.jpeg" alt="Animations in video games"/><div><p>Shepard, clearly not laughing at a joke (Mass Effect series)</p></div></div><p style="clear:both; height: 1em;"> </p><p>Timing is everything, so when it comes to animations, make sure that they happen when they are supposed to. Pressing <em>
<strong>X</strong>
</em> to jump and the jump happening only 3 seconds later is not going to end well, for your game or the player. It is not enough to just animate a character or an object, but you've to add them up to create an immersive environment. The importance of being immersed within a game is vital if you want your player to come back for more. If you have clunky animation that causes frustration, chances are that the player won't be persistent, unless perhaps the story is extremely intriguing. Even the trees in most games animate, even with subtle swaying or leaves flickering with the wind. In this way, it's better than having giant poles of static wood sticking out from the ground.</p><p>Another thing to consider when it comes to animation is the frame rate and, in turn, the hardware. You may have a wonderful animation sequence, such as the epic cut scene like the fight in Crisis Core: Final Fantasy VII between Sephiroth, Genesis, and Angeal (as shown in the following image); another example is the gameplay while you're killing enemies in Battlefield 4. But if there were a delay, well, it would have been pretty much nothing! When creating games for Unity, it is very important to consider this, especially when you are targeting mobile devices. While many mobile devices have the ability to play some resource-heavy media, not all do. Therefore, if your ultimate device won't be able to keep up, your intense efforts are likely to go in vain, unless of course you find another device to target. This is mostly the case with 3D games on mobile devices, and you can find out more here in the official Unity documentation: <a class="ulink" href="https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html">https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html</a>.</p><div><h3 class="title"><a id="tip34"/>Tip</h3><p>I recommend that you visit the preceding link once you've finished the chapter so as to have a better understanding of the animation system in Unity.</p></div><div><img src="img/image00449.jpeg" alt="Animations in video games"/><div><p>Gameplay screenshot of Genesis and Sephiroth fighting in Crisis Core: Final Fantasy VII</p></div></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="tip35"/>Tip</h3><p>Check out this site for some great tips for using animation in mobile games: <a class="ulink" href="http://www.teksmobile.com.au/blog/15-animation-tips-to-make-your-mobile-games-more-engaging">www.teksmobile.com.au/blog/15-animation-tips-to-make-your-mobile-games-more-engaging</a>.</p></div><p>Now that we have an overview of animations in video games, let's head back to Unity to discover what it handles with animations, starting with the general workflow.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Workflow for animations</h2></div></div></div><p>Now that we have understood why animations are so important for video games, let's give them a closer look. Unity's animation system is based on the concept of animation clips; we will explore this in more detail in the next section. As the name suggests, they are just clips containing data for a single animation (with a few exceptions).</p><p>Animation clips are organized into a structure that is similar to a flowchart system, where different nodes are connected to others (like the next screenshot). This system is called an Animator Controller and it acts as a state machine. It keeps track of which clip should currently be played and determines when the animations should change or blend together.</p><div><img src="img/image00450.jpeg" alt="Workflow for animations"/></div><p style="clear:both; height: 1em;"> </p><p>A very simple Animator Controller might only contain a small amount of clips. For example, one clip may be an object breaking, the other a fan rotating. On the other hand, a more advanced Animator Controller is likely to contain a lot more animations, for instance, all actions related to the main character, such as running, walking, idling, dying, and so on. In addition, animations may blend between multiple clips in order to look more fluid-like and less robotic, unless of course that is your intention!</p><p>Unity's animation system also has many special features, especially when using humanoid characters. These features allow you to retarget human-like or humanoid animations from any source, such as motion capture, the Unity asset store, or software such as Maya or Blender, and then apply them to your own character model. In addition to applying these animations, you are also able to adjust muscle definitions on characters. These special features are enabled by Unity's Avatar system, where humanoid characters are mapped to a common internal format (we won't see this in detail, but you can learn more in the optional section at the end of the chapter).</p><p>Ultimately, the animation clips, the Animator Controller, and the Avatar, are brought together on a gameObject via the Animator Component. This component references an Animator Controller and (if required) the Avatar for the model in question. The Animator Controller in turn contains the references to the animation clips it uses.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Animations clips and the Animator component</h2></div></div></div><p>At the heart of Unity's animation system, there are Animation Clips. These components contain information that relate to an object's animation, such as whether or not they need to change their translation (position), their rotation, and so on, as the animation takes place. Animation clips can be 2D or 3D and are often made in programs such as 3D Studio Max, Flash, Maya, Blender, and even Photoshop. In addition to using software, animations can be created manually, such as rigging a 3D character (giving it a skeleton to move) or creating movement-by-movement sprites where each movement is drawn out. Remember the old Disney cartoons? Well they used similar processes to bring us some of our most beloved memories. However, if your game requires something that isn't too complex such as opening and closing doors, you are able to do this in Unity. Unity offers a tool known as the the Animation window (more about this later in the chapter).</p><p>In the case of 2D, these animation clips can contain an arbitrary sequence of sprites, like single frames in a movie, and change them over time so to give the illusion of motion. Usually, in 2D game development, sprite sheets are used for these purposes (like we anticipated in <a class="link" title="Chapter 1. A Flat World in Unity" href="part0016.xhtml#aid-F8901">Chapter 1</a>, <em>A Flat World in Unity</em>). As such, our graphic package contains these animation sprite sheets as well.</p><div><img src="img/image00451.jpeg" alt="Animations clips and the Animator component"/></div><p style="clear:both; height: 1em;"> </p><p>Another useful way to think about Animation clips is to pretend that they are actions, such as pick up an object, walk, or jump.</p><div><h3 class="title"><a id="note36"/>Note</h3><p>In most advanced cases, Animation clips can contain part of an action that can be blended or merged with other animation clips.</p></div><p>For our pandas, we have the following animations:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Walk</strong>: When our panda will move along the path</li><li class="listitem"><strong>Die</strong>: When the player's cupcake towers will take the panda down</li><li class="listitem"><strong>Hit</strong>: When the player's cupcake towers will hit the panda</li><li class="listitem"><strong>Eat</strong>: When the panda reaches the end of the level and eats a slice of the player's cake</li></ul></div><p>As such, we need to create four different animation clips, one for each of these.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec34"/>Creating Animation clips with a controller</h3></div></div></div><p>The method explained in this section is a rapid way to start to create the first Animation clip, starting from a sprite sheet, and as a side effect, a controller will be created. However, we will deal with it later in the chapter.</p><p>First of all, create an empty game object in the scene, and rename it to <code class="literal">Panda</code> (or if you prefer, <code class="literal">Sweet-Tooth_Panda</code>). Eventually, you'll want to store it, once finished working on it, inside a prefab.</p><p>Now in the project panel, if we select <code class="literal">animation_panda_sprite_sheet</code> and expand it, we will have something like this:</p><div><img src="img/image00452.jpeg" alt="Creating Animation clips with a controller"/></div><p style="clear:both; height: 1em;"> </p><p>All the single Sprites/frames of the animation should be the same size. By ensuring this in the beginning, it allows you to avoid many headaches later on. Therefore, if the Sprite Sheet is well done, it should be sliced without difficultly with the <strong>Grid By Cell Count</strong> mode in the Sprite Editor, as we did in <a class="link" title="Chapter 1. A Flat World in Unity" href="part0016.xhtml#aid-F8901">Chapter 1</a>, <em>A Flat World in Unity</em>. In our package, our Sprite Sheet is already good to go with each Sprite distributed evenly, but if you're using your own graphic and the Sprite Sheet doesn't have all the frames of the same size, you might want to modify it within a graphics program (such as Photoshop or Gimp) so that the sprites are distributed accordingly.</p><p>This is the final result in the Sprite Editor:</p><div><img src="img/image00453.jpeg" alt="Creating Animation clips with a controller"/></div><p style="clear:both; height: 1em;"> </p><p>However, if you move the slider at the bottom part of the project panel (as we learned in <a class="link" title="Chapter 1. A Flat World in Unity" href="part0016.xhtml#aid-F8901">Chapter 1</a>, <em>A Flat World in Unity</em>), you are able to see all the single sprites, as the following image shows:</p><div><img src="img/image00454.jpeg" alt="Creating Animation clips with a controller"/></div><p style="clear:both; height: 1em;"> </p><p>Select all the Sprites that belong to the animations of the walking Panda, and drag them onto the <strong>Panda</strong> game object we have created before:</p><div><img src="img/image00455.jpeg" alt="Creating Animation clips with a controller"/><div><p>In our case, we have 11 sprites for the Walking animation, then 5 sprites for the Hit animation, 10 for the Die animation, and finally 16 for the Eat animation</p></div></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="tip37"/>Tip</h3><p>It may happen that the last Sprite is equal to the first one. Depending on the case, you might not want it because it is likely to cause a disruption in the animation, such as a delay in a walking sequence. In that case, you can just select all the sprites but the last one.</p></div><p>Unity will ask you where to save the animation clip and under which name. We can name it <code class="literal">Panda_Walk_Animation</code> and save it in our <code class="literal">Animation</code> folder. If you don't have it, you can create it under the <code class="literal">Asset</code> folder. In this way, as we discussed in <a class="link" title="Chapter 1. A Flat World in Unity" href="part0016.xhtml#aid-F8901">Chapter 1</a>, <em>A Flat World in Unity</em>, we keep our project clean and tidy.</p><p>When we select the <code class="literal">Panda</code> object, we can notice that in the Inspector two components have been added. One is a <strong>Sprite Renderer</strong>, which we have already discussed in previous chapters. The other is an <strong>Animator</strong> component. Let's see it in detail in the next section.</p><div><img src="img/image00456.jpeg" alt="Creating Animation clips with a controller"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note38"/>Note</h3><p>If you navigate in the <strong>Animation</strong> folder, other than the animation file we have just created, you will also find an Animator controller called <code class="literal">Panda</code> (or <code class="literal">Sweet-Tooth_Panda</code>, since the name is taken from the Game Object). For our purposes, it's better to rename it as something that describes it better, such as <code class="literal">PandaAnimatorController</code>. We will learn more about this later in the chapter.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec35"/>The Animator component</h3></div></div></div><p>The main function of the Animator component is to hold a reference to an Animator Controller, which defines how our animation clips should be played. Furthermore, it controls when and how to blend and/or transition between them. We will explore the controller in the next sections.</p><p>The Animator component has some parameters that can adjusted. Let's see the main ones:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Controller</strong>: This is the reference to the Animator Controller, and it's the most important variable. If not set, the Animator component can't work. In the previous picture, the controller is set to <code class="literal">Panda</code> (or <code class="literal">PandaAnimatorController</code> if you have renamed it), which is a controller we just created.</li><li class="listitem"><strong>Avatar</strong>: A parameter only for 3D Humanoid characters, so you can ignore it (however, if you are interested in learning more, check out the <em>More about Animations</em> section later in the chapter).</li><li class="listitem"><strong>Apply Root Motion</strong>: You can ignore this too (however, if you are interested in the learning more, check out the <em>More about Animations</em> section).</li><li class="listitem"><strong>Update Mode</strong>: Specifies when the Animator is updated and which timescale it should use. The <strong>Normal</strong> mode updates the controller in sync with the update calls, and the Animator's speed matches the current timescale. If the timescale is slowed, animations will slow down to match. The <strong>Animate Physics</strong> mode instead updates the Animator in sync with the <strong>FixedUpdate</strong> calls, which are used by the Physic engine. This is useful when the object you are animating has a physical interaction, for instance, if a character needs to push or pull a rigid body (more about Physics in the next chapter). Finally, the <strong>Unscaled Time</strong> mode updates the Animator in sync with the Update calls, like the <strong>Normal</strong> mode, but the current timescale is ignored and it always plays at 100% of its speed. For instance, this mode is useful when you pause the game but you still want to animate part of the UI or the pause menu itself.</li><li class="listitem"><strong>Culling Mode</strong>: Specifies the culling mode for animations (more on this in the <em>More about Animations</em> section later in the chapter).</li></ul></div><p>Furthermore, at the bottom of the Animator component, there is an information box with some useful information about the Animator controller we are using. For now, the only information that is relevant is <strong>Clip Count</strong>, which tells you how many animation clips are used by the controller. You can find out more about this information box in the <em>More about Animations</em> section.</p><div><img src="img/image00457.jpeg" alt="The Animator component"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec36"/>Creating the other animation clips</h3></div></div></div><p>Now, we need to create the remaining animation clips respectively for when the pandas die, eat or get hit. This time, we want to do it without generating the controller. We have two choices. In the first, we still keep dragging and dropping the other groups of Sprites onto the <strong>Panda</strong> game object as we did previously. As a result, Unity will still ask to give a name and a location for the animation clip, but it won't generate another controller. This is the fastest way. However, there is another one. It involves the <strong>Animation</strong> window, but for the sake of learning we will use this second method to create the remaining Animation clips.</p><p>To do so, open the <strong>Animation</strong> windows (click on the top bar menu on <strong>Window</strong> | <strong>Animation</strong> or use the shortcut <em>Ctrl</em> + <strong>6</strong>). Then, select your <strong>Panda</strong> from the <strong>Hierarchy</strong> panel. You should see something like this:</p><div><img src="img/image00458.jpeg" alt="Creating the other animation clips"/></div><p style="clear:both; height: 1em;"> </p><p>The <strong>Animation</strong> window allows you to create animations within Unity. It uses interpolation techniques between key frames to compute the position and rotation (along with other parameters) between each frame. It also supports a recording functionality as well as a curve editor. In 2D game development, this is not much used if animation Sprite Sheets are available, like our case (unless you need to fine-tune the animation). Yet, this is an important tool that avoids the need for third-party programs to create your animations. Also, it is useful for prototyping animations. Unfortunately, we don't have enough room in this chapter to talk in detail about the <strong>Animation</strong> window, but you can read more about it in the official documentation here: <a class="ulink" href="https://docs.unity3d.com/Manual/animeditor-UsingAnimationEditor.html">https://docs.unity3d.com/Manual/animeditor-UsingAnimationEditor.html</a>.</p><p>In our case, however, we will use it just to create and save animation clips starting from our Sprites. As we can notice from the preceding picture, there is already the Walk animation created in the last section. To create a new animation clip, click on <strong>Panda_Walk_Animation</strong> and a drop-down menu like the following should appear:</p><div><img src="img/image00459.jpeg" alt="Creating the other animation clips"/></div><p style="clear:both; height: 1em;"> </p><p>Click on <strong>Create New Clip...</strong> and Unity will ask you where to save this new file and its name. We can name it <code class="literal">Panda_Die_Animation</code> and save it within the <code class="literal">Animations</code> folder. As a result, the <strong>Animation</strong> window should now be cleared, as shown here:</p><div><img src="img/image00460.jpeg" alt="Creating the other animation clips"/></div><p style="clear:both; height: 1em;"> </p><p>Now, we can select the Sprites of the die animation, and drag and drop them within the window. Thus, the Sprite animation is loaded within the animation file, as we can see from the Animation window:</p><div><img src="img/image00461.jpeg" alt="Creating the other animation clips"/></div><p style="clear:both; height: 1em;"> </p><p>We need to repeat the process to create the Hit and Eat animations. At the end, you should have the following files in the <code class="literal">Animations</code> folder:</p><div><img src="img/image00462.jpeg" alt="Creating the other animation clips"/></div><p style="clear:both; height: 1em;"> </p><p>One more thing. If you click on one of them, in the <strong>Inspector</strong>, you can see some options about whether the animation can be played in loop and how, along with an information box with some the amount of certain kind of data for the animation, such as how many muscles (but this is for 3D animation, and we won't use this information).</p><div><img src="img/image00463.jpeg" alt="Creating the other animation clips"/></div><p style="clear:both; height: 1em;"> </p><p>Not all our animations are supposed to be played in loop. In fact, all but the walk animations are not supposed to loop. Therefore, for them, just uncheck the <strong>Loop Time</strong> variable in the <strong>Inspector</strong>, like this:</p><div><img src="img/image00464.jpeg" alt="Creating the other animation clips"/></div><p style="clear:both; height: 1em;"> </p><p>So far so good. Before you proceed, I advise you to create a new prefab in the <code class="literal">Prefab</code> folder, called <code class="literal">PandaPrefab</code>, and drag your <strong>Panda</strong> there.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec39"/>The Animator</h2></div></div></div><p>Imagine all of the different types of actions that you perform throughout the day-from the moment you wake up, to making coffee, having a shower, and getting ready for work. Each of these would have a different animation. The same goes for characters. In most games, characters or other animated objects (animals, trees, and so on) have a range of animations. Just like our example before, each animation will correspond to a different moment during gameplay. For example, when a character is just standing and being idle, they aren't doing much, but it is likely that they are still breathing. In some games, if characters remain idle for an extended period of time, other animation sequences are then triggered, such as impatient foot tapping or something completely unexpected. In first-person shooters, objects within the game environment may have the ability to be affected by things such as bullets or force (such as running hard into a wall), and as a result, they might break, crack, open, or even close. Mecanim uses a visual layout system similar to a flowchart to represent a state machine and enable you to control and sequence the animation clips that you want to use on your character or object. We will discuss this in more detail later.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec37"/>The Animator window</h3></div></div></div><p>The Animator window allows you to create, view, and modify Animator Controller assets within Unity.</p><p>Now that we have all our animation files, we need to embed them within the Animator Controller in a meaningful way. If you double-click on <code class="literal">PandaAnimatorController</code>, the <strong>Animator</strong> window opens, and you should have a screen similar to the following one:</p><div><img src="img/image00465.jpeg" alt="The Animator window"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note39"/>Note</h3><p>In case you don't see your panda animations within rectangles, like the preceding image, it is probably because you have created the animation clips without having the animation window linked to a controller. That is not a problem; you just need to select the animation clips you want in the controller and drag them into the <strong>Animator</strong> window, and they will be added.</p></div><p>The <strong>Animator</strong> window is divided into two sections. The main section with the dark gray grid is the layout area. You can use this area to create, arrange, and connect states in your Animator Controller.</p><p>You can right-click on the grid to create a new state node. Using the middle mouse button or <em>
<strong>Alt</strong>
</em>/Option, drag to pan the view around. Click to select state nodes, so as to edit them in the <strong>Inspector</strong>, and click and drag state nodes to rearrange the layout of your state machine, like this:</p><div><img src="img/image00466.jpeg" alt="The Animator window"/></div><p style="clear:both; height: 1em;"> </p><p>In this way, our state machine will be clearer and tidy for what we are going to do. The second section of the <strong>Animator</strong> window is the left-hand pane, which can be switched between the <strong>Parameters</strong> tab and <strong>Layers</strong> tab (if you want to learn more about layers, you can read the optional section of this chapter, <strong>Layers</strong> in the <strong>Animator</strong>, inside the <em>More about Animations</em> section). The <strong>Parameters</strong> tab allows you to create, view, and edit the Animator Controller parameters. These are variables that you define, which will then act as inputs into the state machine. We will see them in detail soon.</p><p>Also, toggling the eye icon on or off (highlighted in the next image to easily locate it) will show or hide the <strong>Parameters</strong> and <strong>Layers</strong> side pane, allowing you more room to see and edit your state machine.</p><div><img src="img/image00467.jpeg" alt="The Animator window"/></div><p style="clear:both; height: 1em;"> </p><p>Furthermore, if we enable the lock icon (as in the next image) in the top-right corner, we are able to keep the <strong>Animator</strong> window focused on the current state machine. If the lock icon is disabled, clicking on a new Animator asset or a Game Object with an Animator component will switch the <strong>Animator</strong> window. As a result, we are then able to show that item's state machine. The benefit of locking the window is that it allows us to keep the <strong>Animator</strong> window from showing the same state machine, regardless of what assets or Game Objects are selected.</p><div><img src="img/image00468.jpeg" alt="The Animator window"/></div><p style="clear:both; height: 1em;"> </p><p>The last useful toggle (located just below the lock icon) is <strong>Auto Live Link</strong>, which allows us to see the machine in action at runtime. For your convenience, it is highlighted in the following image, but we will talk more about it when we need to test the machine we are building up:</p><div><img src="img/image00469.jpeg" alt="The Animator window"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec38"/>The Animator state machine</h3></div></div></div><p>As we already have mentioned, the Animator controller is a flowchart system; specifically it is a kind of finite-state machine. But what is a finite-state machine? From Wikipedia, we can read:</p><div><blockquote class="blockquote"><p><em>"A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), or simply a state machine, is a mathematical model of computation used to design both computer programs and sequential logic circuits. It is conceived as an abstract machine that can be in one of a finite number of states. The machine is in only one state at a time; the state it is in at any given time is called the current state. It can change from one state to another when initiated by a triggering event or condition; this is called a transition. A particular FSM is defined by a list of its states, its initial state, and the triggering condition for each transition."</em></p></blockquote></div><p>In our specific cases, the states will be the animations. So, saying that our Animator is a specific state means that the Game Object with that Animator controller is playing that specific animation. If it is not completely clear right now, it will be a while before we explain the different parts.</p><div><h3 class="title"><a id="note40"/>Note</h3><p>We will explore finite-state machines a bit more in detail later in the book, when we deal with Artificial Intelligence.</p></div><p>Unity generated an Animator controller for us when we created the first Animation clip. But if you need to manually create it, here's how to do it. From the <strong>Project</strong> panel (possibly within a meaningful folder, such as <code class="literal">Animations</code>), right-click and select <strong>Create</strong> | <strong>Animator Controller</strong>. Once renamed, double-click on it to open it in the <strong>Animator</strong> window. Contrary to the automatically generated controller, which already contains all the states of our Panda animation, here there are no such states. In fact, we need to manually import them. In the case of our Pandas, we just need to select the animations file that we have created before from the <strong>Project</strong> panel and drag them into the grid of the <strong>Animator</strong> window. If you remember, we stored them inside the <code class="literal">Animations</code> folder. Always remember that you can move any state just by dragging it. This is useful, because you can reorganize states so as to have a visual order and improve the readability of your work.</p><p>Now, it's time to dig deeper and see how to actually build an animation machine for our pandas. If you created a new Animator controller, discard it, and let's take the one we had before.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec39"/>The Animator states</h3></div></div></div><p>Animations bring characters to life, and therefore Animation states provide the foundations for the Animation State Machine within Unity. Each state contains an individual animation sequence (or blend tree), such as running, walking, climbing, jumping, and so on. All these animation sequences will then be triggered and subsequently played when the character is in that respective state. When an event in the game triggers a state transition, such as the player jumps over a ledge while running, the character will be left in a new state whose animation sequence will then take over.</p><p>When you select a state in the Animator Controller, you will see the properties for that state in the inspector, as shown here:</p><div><img src="img/image00470.jpeg" alt="The Animator states"/></div><p style="clear:both; height: 1em;"> </p><p>These properties and their functions are listed here:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Name</strong>: Is just how the state will be referred in the Animator, and it is also the name showed on top of the state. If it is automatically generated from an animation, as a default, it will have the same name of the animation clip. In fact, our four panda states have the same names as their respectively animation clips.</li><li class="listitem"><strong>Tag</strong>: Just another way to identify a state or a set of them. It is useful when you need to control animation machines from a script. For our purposes, we can leave it in blank.</li><li class="listitem"><strong>Motion</strong>: This is the animation clip assigned to this state, for example, one of the animation clips that we have created before, such as <code class="literal">Panda_Walk_Animation</code> or <code class="literal">Panda_Die_Animation</code> (actually, it can also be a blending tree; see the optional section <em>More about animations</em> later in the chapter).</li><li class="listitem"><strong>Speed</strong>: The default speed of the animation. For example, the default speed of an animation may be too slow, such as a running animation, and therefore, the speed needs to be increased. By changing the value of <strong>Speed</strong>, the animation is able to player faster.</li><li class="listitem"><strong>Multiplier</strong>: A number that is multiplied by <strong>Speed</strong> to increase it or decrease it. Next to it, there is the parameter checkbox. This allows us to transform this number into an animator parameter (please also note that the multiplier cannot have an independent value, but just be linked to a float parameter). In this way, we can control the speed of some animations, without touching the <strong>Speed</strong> settings (given that all of them are linked to the same parameter).</li><li class="listitem"><strong>Mirror</strong>: Should the state be mirrored, which means if the animation clip should be played like in a mirror, exchanging left with right and vice versa. This is only applicable to 3D humanoid animations, and therefore we won't deal with it. Note that can be transformed into a parameter Boolean.</li><li class="listitem"><strong>Cycle Offset</strong>: Determines if the animation loop should start to a different point, and the value indicates the offset from the beginning of the animation. Also this acts as a <strong>Multiplier</strong> and can be set to be a parameter.</li><li class="listitem"><strong>Foot IK</strong>: Should <strong>Foot IK</strong> be respected for this state? This is applicable to 3D humanoid animations, so we won't deal with it.</li><li class="listitem"><strong>Write Defaults</strong>: This decides whether or not AnimatorStates writes back the default values for properties that are not animated by its motion. By default, it is set to true, but unchecking it means that the non-animated properties of a state will keep the value they had previously.</li><li class="listitem"><strong>Transitions</strong>: The list of transitions originating from this state. It is equivalent to identify under which conditions this state changes into another one. We will see transitions in detail in a couple of sections.</li><li class="listitem"><strong>Add Behaviour</strong>: For the description of this button see the optional section <em>More about Animations</em> later in the chapter.</li></ul></div><p>The default state, displayed in brown, is the state that the machine will be in when it is first activated. If you want, you are able to change the default state of the state machine by right-clicking on another state and selecting <strong>Set As Layer Default State</strong> from the context menu.</p><div><img src="img/image00471.jpeg" alt="The Animator states"/></div><p style="clear:both; height: 1em;"> </p><p>In our case, the default state is the <strong>Panda_Walk_Animation</strong> state, so be sure that it is selected as the default state. In addition, to add a new state, right-click on an empty space in the <strong>Animator Controller</strong> window and navigate to <strong>Create State</strong> | <strong>Empty</strong> from the context menu. Another way to create a state, as we have already pointed out, is to drag an animation into the <strong>Animator Controller</strong> window, and as a result, you will create a state containing that animation.</p><p>As far as our panda's animation states are concerned, we don't have particular needs or settings to tweak. After all, what we are building is a relatively simple finite state machine compared to big, complex 3D animation machines. But, if at any moment you feel that one of the four animations that we have is too fast or too slow, just select it and change its speed. In that case, you can do it at the end, when we finish the state machine, so as to have better and complete vision of the panda animation as a whole, and tweak these values to improve it. For instance, I slowed down the walking, hit, and eat animation to 25%, which means a speed of 0.25, whereas for the die animation, I used 0.2. Usually you find these values by trial and error.</p><div><h3 class="title"><a id="note41"/>Note</h3><p>Note that you can only drag Mecanim animations into the controller; non-Mecanim animations will be rejected. Moreover, states do not necessarily contain single animation clips. In fact, they could also contain Blend Trees. You can read more about them in the optional section, <em>More about Animations</em>, later in the chapter.</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec3"/>Special states</h4></div></div></div><p>An animator machine also has some special states, which are presented in this image:</p><div><img src="img/image00472.jpeg" alt="Special states"/></div><p style="clear:both; height: 1em;"> </p><p><strong>Any State</strong> is a special state that is always present. <strong>Any State</strong> implies that it cannot be the end point of a transition. For example, jumping to <em>any state</em> cannot be used as a way to pick a random state to enter the next. <strong>Any State</strong> exists for the situation where you want to go to a specific state regardless of which state you are currently in. This is a simpler way of adding the same outward transition to all states in your machine. <strong>Entry</strong> and <strong>Exit</strong> are states that determine the beginning and the end of the Animation State Machine.</p><div><h3 class="title"><a id="note42"/>Note</h3><p>There are other special states to handle sub-machines. For more information, check out the <em>More about Animation</em> section later on in the chapter.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec40"/>The animator parameters</h3></div></div></div><p>As we already introduced before, on the left-hand side of the <strong>Animator</strong> window, there are two tabs: <strong>Layers</strong>, which we won't deal with here (but I remind you that you can read the optional <em>Layers in the Animator</em> section), and <strong>Parameters</strong>, which we will learn in this section.</p><div><img src="img/image00473.jpeg" alt="The animator parameters"/></div><p style="clear:both; height: 1em;"> </p><p>Animation <strong>Parameters</strong> are variables that are defined within an <strong>Animator Controller</strong>. These parameters can be accessed and their values assigned from scripts. As a result, scripts can control or affect the flow of the state machine. For example, a script can set a parameter that indicates how fast an animation should be played, such as running or walking; these can be the same animation, just played at different speed. In a more sophisticated behavior, the same parameter can be a condition to switch between a proper walking animation and a running one, based on the player's input.</p><p>To add a parameter, click on the small + button, as highlighted in this picture:</p><div><img src="img/image00474.jpeg" alt="The animator parameters"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note43"/>Note</h3><p>However, if you want to delete a parameter, select the parameter in the lists and press the <em>Delete</em> key.</p></div><p>A drop-down menu appears, asking which kind of parameter we want to add:</p><div><img src="img/image00475.jpeg" alt="The animator parameters"/></div><p style="clear:both; height: 1em;"> </p><p>They can be of four basic types:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">Int</code>: An integer (whole number)</li><li class="listitem"><code class="literal">Float</code>: A number with a decimal part</li><li class="listitem"><code class="literal">Bool</code>: A true or false value (represented by a checkbox)</li><li class="listitem"><code class="literal">Trigger</code>: A Boolean parameter that is reset by the controller when consumed by a transition (represented by a circle button)</li></ul></div><p>Parameters can be assigned values from a script using functions in the <code class="literal">Animator</code> class, specifically with the following self-explanatory functions: <code class="literal">SetFloat()</code>, <code class="literal">SetInt()</code>, <code class="literal">SetBool()</code>, <code class="literal">SetTrigger()</code>, and <code class="literal">ResetTrigger()</code>.</p><p>As we have already seen, parameters can be linked to transition conditions or even to state variables (such as the speed multiplier), and then be controlled by scripts. To give an example, imagine the heroine of your game is riding a horse. A script can change a float parameter, which is linked to the speed multiplier of the galloping horse animation, based on how much the player spurs the horse. As a result, the animation of the horse will change in real time, based on the player input (if the player is controlling your heroine), and the horse will move faster.</p><p>However, for our Tower Defense game, we just need triggers, in particular, three: one for when the panda is hit, another one when it reaches the end and eats the cake, and the last one when it dies under sprinkles hit. We can respectively name them <code class="literal">HitTrigger</code>, <code class="literal">EatTrigger</code>, and <code class="literal">DieTrigger</code>. At the end, you should see the following:</p><div><img src="img/image00476.jpeg" alt="The animator parameters"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note44"/>Note</h3><p>Of course, this is not the only way to implement this system. Refer to the <em>State machine behaviours</em> section later to learn how to use behaviours within a state so that in the <em>Homework</em> section you can test yourself with this new technique in order to implement this kind of behaviours in a different way.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec41"/>The animator transitions</h3></div></div></div><p>Transitions allow us to change from one state of the Finite State Machine into another one. They can be triggered when certain conditions are met. As the name suggests, they handle how the current state transits into the destination state and how these two should be merged to have a smooth transition.</p><p>They are represented as mono-directional arrows between two states. To create a new transition between two state, right-click from the state where the transition should start (in our case, <code class="literal">Panda_Walk_Animation</code>) and select <strong>Make Transition</strong>, as shown in this screenshot:</p><div><img src="img/image00477.jpeg" alt="The animator transitions"/></div><p style="clear:both; height: 1em;"> </p><p>Then click on another state to make the transition between them. In this example, we are doing a transition from <code class="literal">Panda_Walk_Animation</code> to <code class="literal">Panda_Hit_Animation</code>, as shown here:</p><div><img src="img/image00478.jpeg" alt="The animator transitions"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec42"/>Transition settings</h3></div></div></div><p>If you click on the arrow, you can see the transition settings/properties in the <strong>Inspector</strong>, like the following screenshot:</p><div><img src="img/image00479.jpeg" alt="Transition settings"/></div><p style="clear:both; height: 1em;"> </p><p>If you wish, you can assign a name to the transition, by typing it in the field shown next (you need to press <em>Enter</em> to confirm your choice):</p><div><img src="img/image00480.jpeg" alt="Transition settings"/></div><p style="clear:both; height: 1em;"> </p><p>As a result, its name will be shown in the state that contains that transition (for instance, in our example, within the <code class="literal">Panda_Walk_Animation</code> state):</p><div><img src="img/image00481.jpeg" alt="Transition settings"/></div><p style="clear:both; height: 1em;"> </p><p>Renaming transition is your choice. Someone prefers to give proper names, someone else references to it as initial and final state, which is the default name. However, if you decide to rename them, remember to give meaningful names; it doesn't matter if they are long.</p><p>Let's cover in detail each of these settings so as to have a better understanding of what they mean. Keep in mind that some of them refer to certain conditions, which we will explore soon.</p><div><ul class="itemizedlist"><li class="listitem"><strong>Has Exit Time</strong>: If this is set to true, the transition can only happen at the time specified in the <strong>Exit Time</strong> variable.</li><li class="listitem"><strong>Exit Time</strong>: If <strong>Has Exit Time</strong> is enabled, this value represents the exact time for the transition to take effect. This is represented in normalized time (percentage value); so, for example, an exit time of 0.65 means that on the first frame where 65% of the animation has played, the <strong>Exit Time</strong> condition will be true. On the next frame, the condition will be false. For looped animations, transitions with exit times smaller than 1 will be evaluated on every loop, so you can use this to time your transition with the proper timing in the animation, for every loop. Transitions with exit times greater than 1 will be evaluated only once, so they can be used to exit at a specific time-after a fixed number of loops. For example, a transition with an exit time of 4.5 will be evaluated once, after four and a half loops.</li><li class="listitem"><strong>Fixed Duration</strong>: If enabled, the transition time is interpreted in seconds; otherwise, it is interpreted in a percentage between 0 and 1 (normalized time), such as 0.5, which would represent 50%.</li><li class="listitem"><strong>Transition Duration</strong>: This is the duration of the transition. This will also determine the length between the two blue markers in the Transition Graph (see the next section).</li><li class="listitem"><strong>Transition Offset</strong>: This is the offset of the time where the animation (in the destination state that is transitioned to) begins to play. For example, a value of 0.4 would mean the target state will begin playing at 40% of the way through its own timeline.</li><li class="listitem"><strong>Interrupt Source</strong>: This allows you to control the circumstances that allow a transition to interrupt the current one. In particular, you can select five different modes:<div><ul class="itemizedlist"><li class="listitem"><strong>None</strong> won't allow anything to interrupt the transition.</li><li class="listitem"><strong>Current State</strong> allows only transitions, within the current state, to interrupt the transition.</li><li class="listitem"><strong>Next State</strong> allows the transition to be interrupted by other transitions, but only if those are within the destination state. Therefore, if the destination state has a transition that is ready to fire, it will interrupt this one and will be triggered.</li><li class="listitem"><strong>Current State then Next State</strong> allows the transition to be interrupted by transitions from either the current or the destination state. However, if the conditions of a transition becomes true on both the current state and the destination one, then the former will take the priority. For example, if two transitions are ready to fire but one is on the current state and another one on the destination one, the first transition will be triggered and will interrupt the current playing transition.</li><li class="listitem"><strong>Next State then Current State</strong> still allows the transition to be interrupted by either transitions of the current or destination state. But in contrast to <strong>Current State then Next State</strong>, if the condition of a transition becomes true on both the current state and the destination one, then the latter will take priority.</li></ul></div></li><li class="listitem"><strong>Ordered Interruption</strong>: This determines whether the current transition can be interrupted by other transitions independently of their order.</li></ul></div><div><h3 class="title"><a id="tip45"/>Tip</h3><p>Now that you can make transitions, remember to rearrange often your finite state machine so as to improve readability. You should always place the states in such a way that all the transitions are nicely visible, and ideally they shouldn't cross each other much.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec43"/>Transition graph</h3></div></div></div><p>Unity also provides a useful way to tweak these properties (listed just now) in a visual way, through the transition graph, which is located just below the settings of the previous section.</p><p>The transition settings can be adjusted either manually by entering numbers into the fields that we saw before, or by using the transition diagram, which will modify the values when the visual elements are manipulated.</p><div><img src="img/image00482.jpeg" alt="Transition graph"/><div><p>The Transition Graph with a clear timeline; we can tweak how the transition will happen in a visual way</p></div></div><p style="clear:both; height: 1em;"> </p><p>In the preceding diagram, you can do one of the following things:</p><div><ul class="itemizedlist"><li class="listitem">Change the duration of the transition by dragging the <em>out</em> marker.</li><li class="listitem">Change the duration of the transition and the exit time by dragging the <em>in</em> marker.</li><li class="listitem">Adjust the transition offset by dragging the animation clips shown in the bottom part of the graph.</li><li class="listitem">Preview the transition by dragging the playback marker and navigate frame by frame to adjust how the animation clips blend together. The preview window is located at the bottom of the inspector.</li></ul></div><div><img src="img/image00483.jpeg" alt="Transition graph"/><div><p>This is the preview window, where you can rotate, scale and play animations, as well as display their pivot point (or center of mass in the case of 3D models) and change the time scale to which you want to play the preview</p></div></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note46"/>Note</h3><p>If the transition involves a blending tree as one of the two states (or both), the blend tree parameters will also appear in the transition graph. You can find a bit more about blending trees in the <em>More about Animations</em> section later in the chapter.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec44"/>Transition conditions</h3></div></div></div><p>So far we have seen many settings for our transitions, but when are they actually triggered? That's why, at the bottom of the settings, there are the transition conditions. You can see them here:</p><div><img src="img/image00484.jpeg" alt="Transition conditions"/></div><p style="clear:both; height: 1em;"> </p><p>To add a condition, press the <strong>+</strong> button. To remove, select one of them and click on the <strong>-</strong> button. Besides, you can reorder them by dragging their left handle. However, the order doesn't affect the logic behind the transition (just the implementation of it, and maybe the readability of your project).</p><p>These conditions can be checked against the parameters. For <code class="literal">int</code> and <code class="literal">float</code> parameters, we can check them against a fixed number. So if the value in the parameter is <strong>Greater</strong> or <strong>Less</strong> than the fixed number. For <code class="literal">int</code> parameters, we can also check whether they are <strong>Equals</strong> or <strong>NotEqual</strong> compared to the fixed number. Bools, instead, can be checked to find out whether they are true or false. Finally, triggers cannot be checked against something, but the condition checks whether they fire.</p><p>Here is an example of conditions using all of the four kinds of parameters:</p><div><img src="img/image00485.jpeg" alt="Transition conditions"/></div><p style="clear:both; height: 1em;"> </p><p>Please note that the transition is executed/performed only if all the conditions are verified in that moment. A transition without conditions is triggered at the time specified in <strong>Exit Time</strong>.</p><div><h3 class="title"><a id="note47"/>Note</h3><p>If <strong>Has Exit Time</strong> is not checked and the transition has no condition as well, then the transition is ignored by Unity. So it is as if the transition didn't exist.</p></div><p>Now that we have learned how to set a transition, we will explore some useful functionalities to test them in the next section.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec45"/>Testing transitions</h3></div></div></div><p>There are two useful functionalities to know about if you need to test the transitions. The first one is <strong>Solo</strong> and second is <strong>Mute</strong>. If you select a transition, you can see them at the top of the <strong>Inspector</strong>:</p><div><img src="img/image00486.jpeg" alt="Testing transitions"/></div><p style="clear:both; height: 1em;"> </p><p>However, I suggest you to set <strong>Solo</strong> and <strong>Mute</strong> in another way. In fact, if we select a state, we can find in the <strong>Inspector</strong> all the transitions from that state with the <strong>Solo</strong> and <strong>Mute</strong> functionalities. As a result, we will have a handy view, since we can look at and set all the transitions from that state in one go, shown as follows (all the transitions in this picture will be made in the next section):</p><div><img src="img/image00487.jpeg" alt="Testing transitions"/></div><p style="clear:both; height: 1em;"> </p><p>When the <strong>Mute</strong> checkbox is selected, that specific transition will be ignored completely. Whereas, when the <strong>Solo</strong> checkbox is selected, all the other transitions will be considered muted. Furthermore, in the <strong>Animator</strong> window, it is possible to see <strong>Mute</strong> transitions in red, whereas <strong>Solo</strong> transitions are in green:</p><div><img src="img/image00488.jpeg" alt="Testing transitions"/><div><p>An example of Solo and Mute transitions</p></div></div><p style="clear:both; height: 1em;"> </p><p>If you have the hard copy of this book (so without colors), the transition that goes from <code class="literal">Panda_Walk_Animation</code> to <code class="literal">Panda_Hit_Animation</code> is a <strong>Mute</strong> transition, so the arrow is red. Both the transitions from <code class="literal">Panda_Walk_Animation</code> to <code class="literal">Panda_Die_Animation</code> and <code class="literal">Panda_Eat_Animation</code> are <strong>Solo</strong> transitions, and the arrow is green. The remaining one is neither a <strong>Mute</strong> nor <strong>Solo</strong> transition, and therefore it is white. However, this is just an example; feel free to test in the best way that suits you.</p><p>Moreover, from the official documentation we can read a rule of thumb about <strong>Solo</strong> and <strong>Mute</strong> functionalities:</p><div><blockquote class="blockquote"><p><em>"The basic rule of thumb is that if one Solo is ticked, the rest of the transitions from that state will be muted. If both Solo and Mute are ticked, then Mute takes precedence."</em></p></blockquote></div><p>Finally, it's worthy to keep in mind that at the time I'm writing this sentence, there is a known issue (always from the official documentation):</p><div><blockquote class="blockquote"><p><em>"The controller graph currently doesn't always reflect the internal mute states of the engine."</em></p></blockquote></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec40"/>The panda's Animation State Machine</h2></div></div></div><p>Now that we learnt a bit more about how to use Mecanim system, we will do what we started-have a complete controller for the animations of our pandas. This is how the controller should look once finished:</p><div><img src="img/image00489.jpeg" alt="The panda's Animation State Machine"/></div><p style="clear:both; height: 1em;"> </p><p>As you can see, there are four transitions, and we've got only one. But we still need to properly set all of them. Therefore, create and complete the transitions in the following way:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">Panda_Walk_Animation</code> to <code class="literal">Panda_Hit_Animation</code>: When the panda is walking and a sprinkle hits it, the panda will play the Hit animation. Therefore, let's add <code class="literal">HitTrigger</code> as a condition and uncheck <strong>Has Set Time</strong> to trigger the transition at any moment during the walk loop. Furthermore, to make the transition instantaneous, let's set <strong>Transition Duration</strong> to zero to make it start playing the Hit animation from the first frame set <strong>Transition Offset</strong> to zero.</li><li class="listitem"><code class="literal">Panda_Hit_Animation</code> to <code class="literal">Panda_Walk_Animation</code>: After the panda has been hit, he will then keep walking again towards the player's cake. As a result, we need to recover the panda from the <code class="literal">Panda_Hit_Animation</code> state as soon as the animation finishes. So, let's set <strong>Has Exit Time</strong> to true and <strong>Transition Duration</strong> and <strong>Transition Offset</strong> to zero, since we want the transition to be instantaneous.</li><li class="listitem"><code class="literal">Panda_Walk_Animation</code> to <code class="literal">Panda_Eat_Animation</code>: When the panda finally arrives to the player's cake, the panda will eat so much of it that he will explode! Therefore, the transition needs to be triggered with <code class="literal">EatTrigger</code>, so add it to the conditions and uncheck <strong>Has Exit Time</strong>. Moreover, as all the transitions of the panda should be immediate, set both <strong>Transition Duration</strong> and <strong>Transition Offset</strong> to zero.</li><li class="listitem"><code class="literal">Panda_Walk_Animation</code> to <code class="literal">Panda_Die_Animation</code>: Being under fire by sprinkles is tough for our panda. If it cannot hold anymore, it will die, leaving the player's cake untouched. This is a transition triggered by <code class="literal">DieTrigger</code>, which we need to add to the conditions. Again, for the same reasons as before, uncheck <strong>Has Exit Time</strong> and set both <strong>Transition Duration</strong> and <strong>Transition Offset</strong> to zero.</li><li class="listitem"><code class="literal">Panda_Die_Animation</code> to <code class="literal">Exit</code>: Once the panda is dead, we want to get rid of it. Going in the <code class="literal">Exit</code> state, actually (since we don't have any sub-machines), will make the controller start again from the enter state/node. However, we will see how to destroy the panda before this happens. It doesn't matter if this animation goes in any other state, but choosing exit makes more sense, and so it helps in the readability of your controller. Once more, we want the transition to be instantaneous, so we set both <strong>Transition Duration</strong> and <strong>Transition Offset</strong> to zero; but we want to trigger this transition as soon as the animation finishes, which means having <strong>Has Exit Time</strong> set to true.</li><li class="listitem"><code class="literal">Panda_Eat_Animation</code> to <code class="literal">Exit</code>: The same reasons we said for the previous transition hold for this too. The panda will eat so much cake that it will explode, and again the panda will be removed from the scene. Check <strong>Has Exit Time</strong> and set <strong>Transition Duration</strong> and <strong>Transition Offset</strong> to zero.</li></ul></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec46"/>Testing the panda's Animation State Machine</h3></div></div></div><p>Before we move on to the next section, we should check whether what we have done so far works. However, the whole system will be completed only when we finish the game. Therefore, we need to find a smart and fast way to test the controller.</p><p>The easiest way is to create a new scene and drag and drop the panda Prefab into it. Then, build an UI interface with three buttons. Change their text so that you will have <code class="literal">Trigger Die Animation</code>, <code class="literal">Trigger Hit Animation</code>, and <code class="literal">Trigger Eat Animation</code>, as shown in this screenshot:</p><div><img src="img/image00490.jpeg" alt="Testing the panda's Animation State Machine"/></div><p style="clear:both; height: 1em;"> </p><p>As we learnt in the previous chapter, the buttons have the <strong>On Click ()</strong> event, which allows us to call some functions when the button is pressed. However, we didn't have chance to use this functionality. In fact, we will work more on UI events in the next chapter.</p><p>For now, you can select all the three buttons, and click on the small <strong>+</strong> button in the bottom-right corner of the <strong>On Click ()</strong> event. We can see this in the following image:</p><div><img src="img/image00491.jpeg" alt="Testing the panda's Animation State Machine"/></div><p style="clear:both; height: 1em;"> </p><p>A new event appears, as shown here:</p><div><img src="img/image00492.jpeg" alt="Testing the panda's Animation State Machine"/></div><p style="clear:both; height: 1em;"> </p><p>Drag the panda from the <strong>Hierarchy</strong> panel, into the object variable, so that you will have the following:</p><div><img src="img/image00493.jpeg" alt="Testing the panda's Animation State Machine"/></div><p style="clear:both; height: 1em;"> </p><p>From the drop-down menu, navigate to <strong>Animator</strong> | <strong>Set Trigger (string)</strong>. In this way, we can set the triggers of our Animator. So at the end, you should have this:</p><div><img src="img/image00494.jpeg" alt="Testing the panda's Animation State Machine"/></div><p style="clear:both; height: 1em;"> </p><p>Now, select each button separately, and assign to each one of them the respective trigger. For instance, in the <strong>Trigger Die Animation</strong> button, you should write <code class="literal">DieTrigger</code>, as shown in this picture:</p><div><img src="img/image00495.jpeg" alt="Testing the panda's Animation State Machine"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note48"/>Note</h3><p>Using the <code class="literal">Set Trigger (string)</code> function is not the best option, since it involves the use of strings. But for testing purposes, it's more than fine. In the next section, when we build a script that controls the Animator, we will see how to use hashes to refer to Animator parameters as numbers, and improve efficiency.</p></div><p>As a result, each one of those buttons now acts as a trigger for our panda. Therefore, we can press <strong>Play</strong>, and finally see our panda walking. Then, by clicking on the buttons, we can trigger the transitions in the Animator and see the panda changing state/animation. As a result, we can test if the transitions work well or not. Feel free to tweak any parameters you want, such as the speed of an animation or the transition graph of one of the transitions to suit your needs.</p><p>Do you remember the <strong>Auto live link</strong> toggle when we talked about the <strong>Animator</strong> window? Once you are in <strong>Play</strong> mode, that is the right moment to activate it. As a result, you will be able to have a visual representation on your <strong>Animator</strong> window of the state of your machine.</p><p>For instance, in the following screenshot, the walk loop is performed and it also shows a bar with the progress of the animation. This can help you a lot to tweak the Animator controller.</p><div><img src="img/image00496.jpeg" alt="Testing the panda's Animation State Machine"/></div><p style="clear:both; height: 1em;"> </p><p>Now, once you are happy with your changes and you have applied them, save the scene if you want, but come back to our main scene. Then, we are ready to create a script, or two, for our pandas.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Scripting Animations</h2></div></div></div><p>Finally, we've got all the animations for our pandas and a controller that changes them based on some triggers. However, so far nothing will ever set a trigger of the Animator (except our UI test buttons in the other scene). Therefore, we need to create the script for the panda, which will not only include the behaviour of the panda, but it will also trigger the right animations. In the next section, we will learn how to tweak the parameters of an Animator within a script. But before we get there, let me to introduce you a very powerful tool: State Machine Behaviours!</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec42"/>State machine behaviours</h2></div></div></div><p>Each state of the animation machines can contain one or more behaviours. These are scripts that extend the <code class="literal">StateMachineBehaviour</code> class, which include the following functions/events, with self-explanatory names regarding when they are called/triggered: <code class="literal">OnStateEnter()</code>, <code class="literal">OnStateExit()</code>, <code class="literal">OnStateIK()</code>, <code class="literal">OnStateMove()</code>, and <code class="literal">OnStateUpdate()</code>.</p><p>In particular, you need to override these functions from the mother class, and they take as input three parameters. The first is the Animator itself, the second is an <code class="literal">AnimatorStateInfo</code> that stores information about the current state, and finally we have an integer that represents the layer. In our case, since we won't use any other layer than the base one, it will be always zero. They have the following signature (take <code class="literal">OnStateEnter()</code> for example):</p><pre class="programlisting">override public void OnStateEnter(Animator Animator, AnimatorStateInfo stateInfo, int layerIndex) &#13;
</pre><p>As a result, we can control everything within a state. In fact, State Machine Behaviours are a very powerful tool. Once you have created a script that extends the <code class="literal">StateMachineBehaviour</code> class, select the state where you want to add it. Then, click on the <strong>Add Behaviour</strong> button at the bottom of the <strong>Inspector</strong>, like this:</p><div><img src="img/image00497.jpeg" alt="State machine behaviours"/></div><p style="clear:both; height: 1em;"> </p><p>If your class contains variables, they are shown in the <strong>Inspector</strong> as for any other script, and they can be configured for that specific state. Here is a State Machine Behaviour that contains some variables and how they are displayed:</p><div><img src="img/image00498.jpeg" alt="State machine behaviours"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note49"/>Note</h3><p>Be careful when using static variables, because they are shared among all the instances of the State Machine Behaviour among all the controllers! In fact, it's good practice to not use static variables in this context.</p></div><p>Now, imagine that the hero of your game that has the ability to carry and hold different weapons. In this case, with a machine behaviour, you can check which weapon the character is holding, and if it matches with the legendary fire sword, add a fire particle effect when our hero slashes an enemy. Another example could be where some characters share the same animation machine, since they are really similar, but some of them can glide after a jump. As such, you'd want to check this and, in some way, modify some parameters of your animation machines.</p><p>To put simply, the only limit is your imagination (and computational power), and you can enhance your animation machine. Of course, all that you can achieve with State Machine Behaviour can be done in other ways, but they offer a simple and quite intuitive way to do it. It doesn't take much to get used and learn how to deal with this tool.</p><p>Now that we know what a State Machine Behaviours is, let's make one for our panda!</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec47"/>The destroy behaviour</h3></div></div></div><p>When our panda is killed either by a terrible rain of sprinkles or by eating too much cake, in some way we need to make the panda disappear from the scene. However, we need to do it, after that the death animation is played, and eventually also after we have updated the gameplay (which we will see later in the book).</p><p>That's why we have created two extra transitions from the <strong>Die</strong> and <strong>Eat</strong> animations into the <strong>Exit</strong> state. These transitions will be executed once the respective animation has finished playing. Moreover, these animations are triggered by us in a separate script (see the next section), so before the panda dies, we have a chance to update the gameplay, such as the amount of sugar or health of the player.</p><p>A State Machine Behaviour allows us to have this level of control, that is to destroy the panda when it finishes to play that particular animation. Therefore, we can create a new script and call it something meaningful, such as <code class="literal">StateMachineBehaviour_DestroyOnExit</code>. Now, double-click on the script to open it.</p><p>First of all, we need to extend <code class="literal">StateMachineBehaviour</code> and not <code class="literal">MonoBehaviour</code>. We can just replace the latter with the former. Since the script doesn't extend <code class="literal">MonoBehaviour</code> anymore, we can also remove the <code class="literal">Start()</code> and <code class="literal">Update()</code> functions. At the end, we should come up with the following:</p><pre class="programlisting">using System.Collections; &#13;
using System.Collections.Generic; &#13;
using UnityEngine; &#13;
 &#13;
public class StateMachineBehaviour_DestroyOnExit : StateMachineBehaviour { &#13;
 &#13;
} &#13;
</pre><p>Next, we need to override one of the aforementioned functions of a State Machine Behaviour. In particular we want to override the <code class="literal">OnExit()</code> function. So every time the state changes to another (which in the case of the <strong>Die</strong> and <strong>Eat</strong> states means immediately after their animations are played), the panda will be destroyed. We can do this easily, since one of the parameters of the function is the Animator itself, and from it, we can retrieve the gameObject to which the Animator is attached and destroy it. Therefore, we can just add this function:</p><pre class="programlisting">    override public void OnStateExit(Animator Animator, AnimatorStateInfo stateInfo, int layerIndex) { &#13;
       <em> //Destroy the gameobject where the Animator is attached to</em> &#13;
        Destroy(Animator.gameObject); &#13;
    } &#13;
</pre><p>Save the script, and select the <strong>Die</strong> and <strong>Eat</strong> states. From there, click on <strong>Add Behaviour</strong> and select <code class="literal">StateMachineBehaviour_DestroyOnExit</code>.</p><p>Once you have done all of this, we are done! Now, every time the <strong>Die</strong> or <strong>Eat</strong> animations are played, on their completion, the panda will be destroyed. The next step is to see how to actually trigger the states within the controller.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec48"/>The panda script</h3></div></div></div><p>We need to create a new script, and this time let it be derived from <code class="literal">MonoBehaviour</code>. We can call it <code class="literal">PandaScript</code>. Then, we can start to create some variables inside it. Let's start with a public variable to keep track of the panda's life and another one for its speed:</p><pre class="programlisting">
<em>    //Public variables that express the characteristic of the Panda</em> &#13;
    public float speed;     //The movement speed &#13;
    public float health;    //The amount of health &#13;
</pre><p>Then, we need a variable to store the reference to the Animator. So, we can use this variable when we need to trigger an animation in the Animator:</p><pre class="programlisting">
<em>    //Private variable to store the Animator for handling animations</em> &#13;
    private Animator Animator; &#13;
</pre><p>As we learned in the <em>Animator Parameter</em> section, there are different methods to set parameters within the Animator. However, there are two versions of them: one refers to the parameter with an ID or Hash, the other one as a string. The latter is for sure the most intuitive, but since it relies on string processing, it's a bit slower than the first one. As such, whenever this is possible, it's better to use a hash (see the information box) to refer to a specific parameter within the Animator. Therefore, we can store these hashes inside some variable, so to fast use them.</p><div><h3 class="title"><a id="note50"/>Note</h3><p>In computer science when we need to map data of an arbitrary size onto data of a fixed size, we use a <code class="literal">Hash</code> function. The result of this function is called <em>hash values</em>, <em>hash codes</em>, <em>digests</em>, or simply <em>hashes</em>. The main uses of these <code class="literal">Hash</code> functions are in cryptography and digital security. Whenever you digitally sign a document, behind the scenes there is a <code class="literal">Hash</code> function somewhere too. However, they are also used in other contexts, such as to optimize, as in the case of Unity.</p></div><p>In our very specific case, we have a set of parameters, which need an integer ID so that they can be referred to quickly in the Animator. A <code class="literal">Hash</code> function is applied from the name of the parameter, which is a string, and so potentially with infinite combinations, since a string can be long arbitrary, onto a finite set of the Integers which may be expressed with a single <code class="literal">int</code> variable (so only up to two billion, one hundred and forty-seven million, four hundred and eighty-three thousand, six hundred and forty-seven). So every time in your video game use an <code class="literal">int</code> variable for storing money or lives, like we did in the last chapter, <code class="literal">2,147,483,647</code> is the maximum amount. Usually for video games, this limit is more than fine for any integer parameters you may want, although it is possible to overcome it if needed with special data structures. As a result, from the name of the parameter of the Animator, we can have a number with which we can refer to the parameter.</p><p>These hashes are Animator independent, since they are based only on the name of the parameter itself. So they can be calculated or retrieved from the static function <code class="literal">Animator.StringToHash()</code>, which takes as input the name of the parameter and returns as output it's numerical representation to use in an Animator.</p><p>In our specific case, we have the three triggers, and we can store their hashes in the following variables:</p><pre class="programlisting">
<em>//Hash representations of the Triggers of the Animator controller of the Panda</em> &#13;
private int AnimDieTriggerHash = Animator.StringToHash("DieTrigger"); &#13;
private int AnimHitTriggerHash = Animator.StringToHash("HitTrigger"); &#13;
private int AnimEatTriggerHash = Animator.StringToHash("EatTrigger"); &#13;
</pre><p>The next step is to get the reference to the Animator controller in the <code class="literal">Start()</code> function, so to be used in the other functions. We can achieve this by using the <code class="literal">GetComponent()</code> function, which returns the component specified as <code class="literal">Type</code> attached to the same gameObject of this script. Therefore, we can simply add this line in the <code class="literal">Start()</code> function:</p><pre class="programlisting">    void Start () { &#13;
       <em> //Get the reference to the Animator</em> &#13;
        Animator = GetComponent&lt;Animator&gt;(); &#13;
  } &#13;
</pre><p>Now, as for a modular workflow, we can create some private functions to implement the logic behind controlling the state machine. However, we will deal with them when we need to call them later on.</p><p>So now, we need a function that allows our panda to move towards a point in the map. This function takes a <code class="literal">Vector3</code> as input parameter, which is the destination point on the map. Based on the speed variable, it creates a step for our panda. Then, using the <code class="literal">MoveTowards()</code> function, it moves the panda of one step towards the destination point:</p><pre class="programlisting">
<em>    //Function that based on the speed of the Panda makes it moving towards the destination point, specified as Vector3</em> &#13;
    private void MoveTowards(Vector3 destination) { &#13;
       <em> //Create a step and then move in towards destination of one step</em> &#13;
        float step = speed * Time.deltaTime; &#13;
        transform.position = Vector3.MoveTowards(transform.position, destination, step); &#13;
    } &#13;
</pre><p>Another function will be called when the panda is hit by a sprinkle from one of the player's cupcake towers. It has as input a float, which is the amount of damage the panda has taken from the hit. So, the function subtracts this value to the health of the panda, and then checks if the health is less than zero. If so, the function triggers the Die Animation by set the <code class="literal">DieTrigger</code> parameter. We don't need to then destroy the panda because once death is triggered, the state machine behaviour will take care of it. On the other hand, if the panda is not dead yet, the function, instead, plays the Hit Animation:</p><pre class="programlisting">
<em>    //Function that takes as input the damage that Panda received when hit by a sprinkle.</em>
<em>//After have detracted the damage to the amount of health of the Panda checks if the Panda</em>
<em> //is still alive, and so play the Hit animation, or if the health goes below zero the Die animation</em> &#13;
    private void Hit(float damage) { &#13;
           <em>//Subtract the damage to the health of the Panda</em> &#13;
        health -= damage; &#13;
           <em>//Then it triggers the Die or the Hit animations based if the Panda is still alive </em>        &#13;
 if(health &lt;= 0) { &#13;
            Animator.SetTrigger(AnimDieTriggerHash); &#13;
        } &#13;
        else { &#13;
            Animator.SetTrigger(AnimHitTriggerHash); &#13;
        } &#13;
    } &#13;
</pre><p>One last function we need to add is for when the panda reaches the end of its path and it's standing in front of the player's cake. Here the function just triggers the <code class="literal">Eat animation</code>. How to damage the player is something that we will deal in the next chapter:</p><pre class="programlisting">
<em>       //function that triggers the Eat animation</em> &#13;
    private void Eat() { &#13;
        Animator.SetTrigger(AnimEatTriggerHash); &#13;
    } &#13;
</pre><p>We can save the script for now. It should appear like this in the Inspector:</p><div><img src="img/image00499.jpeg" alt="The panda script"/></div><p style="clear:both; height: 1em;"> </p><p>No need to worry now about how to set the speed and the health! We will see this when we will talk about gameplay programming.</p><p>Unless you want to read the next optional section, which will guide you through more advanced topics, we can say that we have finished with animation. If you don't want to read the next section, or want to come back to it later, maybe once you've finished the whole book, you can skip directly to the homework and summary sections. Otherwise, take a break and continue with the next section.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec49"/>More about Animations</h1></div></div></div><p>We have seen a lot about the Animation workflow in Unity, yet a lot has been left out. This section presents some relatively advanced topics of the Animation workflow in Unity, and they are not needed to develop our Tower Defense Game. In fact, some of these applies only on 3D, but I feel that it's worthwhile to mention them to have a rough, but complete picture of the whole workflow for Animations in Unity. Therefore, feel free to skip this section, or read without focus to understand completely what's written. You can always come back here later, maybe when you've finished the book, for a deeper look to its content.</p><div><h3 class="title"><a id="note51"/>Note</h3><p>All the following sections are not intended to explain in detail how to use these tools in Unity, but rather to be aware of their existence and functionalities so as to learn them later on when you are a bit more practical with Unity.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Avatars</h2></div></div></div><p>In the case of 3D characters, and especially for humanoids, you need to <em>rig</em> your character, which means to match all bones of the 3D model into a Unity Avatar. If the model is well done and optimized for Unity, this process can be automatized; otherwise it needs to be done by hand, as shown in this picture:</p><div><img src="img/image00500.jpeg" alt="Avatars"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note52"/>Note</h3><p>In the scene view, there is your 3D model, from which you can drag and drop the parts of his/her/its body in the avatar.</p></div><p>In this way, Unity stores additional information about the 3D model. It stores not only the matching bones, but also muscles. The main reason is that by doing it in this way it is possible to perform retargeting, which means using the same animations for different character. Suppose you have a beautiful walking animation, and you want to apply it to all your characters. But some of them are tall. Others are fat or full of muscles. The Avatar stores this additional information to overcome the problem and adapt the walking animation to each character.</p><p>Furthermore, Unity also allows masking, which means to discard part of the Animation clip data and uses specific parts only. For instance, imagine you have a beautiful walking animation and an animation of someone drinking a glass of water. Suppose you want to make your character to drink a glass of water while he or she keeps walking. By masking the drinking animation, we are able to crop it just onto the upper body part. As a result, we can leave the walking animation playing on the legs, while the drinking one is playing on the upper body of the character.</p><p>If you imagine a complex game, where the characters can do many things while walking (such as shoot, reload or talk) this functionality is really helpful. Keep in mind that masking can be done to different levels. For instance, you can merge more than two animations together with respect to different body parts, as well as sub-masking. The possibilities are endless!</p><p>That's why Unity offers also a more detailed mapping when required, for instance, for the head or the hands, as the next picture shows, where we can see the mapping for the left hand:</p><div><img src="img/image00501.jpeg" alt="Avatars"/></div><p style="clear:both; height: 1em;"> </p><p>All of this is really powerful when used in combination with sub-state machines, state-behaviors and Layers in the Animator.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec49"/>Sub-state machines</h3></div></div></div><p>Previously, we have seen that the Animator is a finite state machine with different states, each one of them as an animation clip. But in actual fact, not all of the states are animation clips. Some of them can be something else, such as sub-state machines. This means, that a state can contain another whole finite state machine!</p><div><img src="img/image00502.jpeg" alt="Sub-state machines"/><div><p>A sub-state machine appears into the upper level like a state, though with a slightly different shape. In fact, transitions can both start or end on a sub-state machine like any other state.</p></div></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note53"/>Note</h3><p>You can recognize a sub-state machine since the shape around the name is slightly different.</p></div><p>In this scenario, the exit state/node becomes important, because it allows us to finish/exit from the sub-state machine and continue in the next state. Of course, also a sub-machine can be interrupted if set to do so when some conditions are met. Needless to say, being able to nest animation machines is indeed a very powerful tool to build very complex Animators.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec50"/>The hierarchical location menu</h3></div></div></div><p>As we have seen, states can contain sub-states and trees and these structures can be nested repeatedly. When drilling down into sub-states, the hierarchy of parent states and the current state can be viewed on the top bar (highlighted in the following picture):</p><div><img src="img/image00503.jpeg" alt="The hierarchical location menu"/></div><p style="clear:both; height: 1em;"> </p><p>Clicking on the parent states allows you to jump back up to parent states or go straight back to the base layer of the state machine.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Layers in the Animator</h2></div></div></div><p>Now, if we want to create, view, or edit layers within our Animator Controller, we need to make sure that the left-hand pane is set to Layers view, like this image:</p><div><img src="img/image00504.jpeg" alt="Layers in the Animator"/></div><p style="clear:both; height: 1em;"> </p><p>This allows you to have multiple layers of animation within a single animation controller. All these layers are then able to run at the same time, where each layer is controlled by a separate state machine. This process is commonly used when, for instance, you have a separate layer playing upper-body animations over a base layer that controls the general movement animations for a character (to use in combination with Avatar Masks).</p><p>To begin, click on the plus icon to add a layer. On the other hand, to delete a layer, select the layer and press the <em>Delete</em> key.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Blending trees</h2></div></div></div><p>Besides Animation clips and sub-state machines, a state in the Animator can be also a blending tree. A common process to apply between different frames of an animation is to blend two or more similar motions, so that it feels like one fluid animation. For example, walking and running animations may require that key frames are blended between one another according to the character's speed. Ideally, you want the player to be slower if they are walking and faster if they are running. In some cases, the speed of how fast a player runs can also be increased again with game elements such as items (speed boosts). Another typical example is to lean the character left or right while they are turning to achieve a more realist behaviors. This can be obtained with blend trees, which are able to <em>blend</em> animation clips.</p><div><img src="img/image00505.jpeg" alt="Blending trees"/><div><p>An example of a very common blending tree; Here the walking animation is split in three animation clips, so the character can lean to the left or right as he/she turns during the walk</p></div></div><p style="clear:both; height: 1em;"> </p><p>In fact, they use linear interpolation, which can be controlled by some weights and parameters. Unity supports both 1D and 2D interpolation for blending trees.</p><div><img src="img/image00506.jpeg" alt="Blending trees"/><div><p>2D interpolation of Blending trees. Numbers and animation clips are placed at random, the aim of the figure it's showing the 2D interpolation in the upper part, where the diamond shapes are the different animation clips and the circle shape is the 2D value that controls the blending among the clips.</p></div></div><p style="clear:both; height: 1em;"> </p><p>We won't go further into blending trees, but keep in mind that they can be used to blend more animations together in real time to achieve incredibly real behaviors and smoother animations.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec46"/>Animator Override Controller</h2></div></div></div><p>Imagine that you have just created a beautiful Animation State Machine, full of layers and transitions, since it is super detailed. Your character has states that allows her to cast a spell, to grab a coffee or to swing a sword. However, now, you need to consider that also a Goblin can do that. And even the Ogre of your second level as well as the elf that your protagonist has to fight later on in your game. Should you create again a very similar Animation Machine for each one of them, but just changing the Animation clips? And what if later on you decide to slightly change the controller, do you have to slightly change all of them? Thank God, Unity offers an easier way, called the <strong>Animator Override Controller</strong>.</p><p>You can create an <strong>Animator Override Controller</strong> by right-clicking on the project panel and navigate to <strong>Create</strong> | <strong>Animator Override Controller</strong>. It will be an asset as the others Animator controllers. However, you cannot open it in the <strong>Animator</strong> window. If you select it in the <strong>Inspector</strong>, you will see that you can link a normal Animator controller to it, as shown in this screenshot:</p><div><img src="img/image00507.jpeg" alt="Animator Override Controller"/></div><p style="clear:both; height: 1em;"> </p><p>Just for the sake of learning, we drag and drop the only controller that we have in our project, the panda controller. As a result, all the Animator states we used will appear in a list, and we can assign a different animation clip from the original controller.</p><div><img src="img/image00508.jpeg" alt="Animator Override Controller"/></div><p style="clear:both; height: 1em;"> </p><p>In this way, you don't need to replicate the Animator controller but just assign new animation clips. Once the Animator controller changes, all the <strong>Animator Override Controllers</strong> will change accordingly, updating all the characters in your game that use that controller. Not bad, isn't it?</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec51"/>Culling Mode in the Animator component</h3></div></div></div><p>For a moment now, picture a beautiful animation of a shiny coin. It is so beautiful that you decide to include many coins in your game. As a result, it might be computationally heavy to make rotate thousands of coins if then the player can see just three on his or her screen.</p><p>Consider, instead, this other case. The player just turned a switch that triggers a really heavy and slow door. So, while the door is opening, the player explores a bit the environment. When he or she comes back, the player would expect that the animation of the door is complete and so the door is open. This means that the animation of the door should run also when it is not visible, whereas the coin is not needed to be animated in any moment, for instance when it is off screen.</p><p>To optimize this issue, Unity offers an option in the Animator component, the <strong>Culling Mode</strong>. This allows us to specify when the object should animate. The possible values are the following:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Always Animate</strong>: The most expensive, although realistic, solution. As the name suggests, the object is always animated, so in the case of the door also, when it is off screen, it will keep opening.</li><li class="listitem"><strong>Cull Update Transforms</strong>: This is a mid-solution; it disables only some parts, such as Retargeting and IK, to improve performance, but still has a certain degree of realism when needed, without paying too much in computational cost.</li><li class="listitem"><strong>Cull Completely</strong>: This is the cheapest from a computational point of view, since the object stops being animated completely when it is off screen.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec52"/>Root motion</h3></div></div></div><p>Some animations, in theory, should displace the character, such as walking but not drinking a glass of water. So in order to fix this issue in Unity, you can either move the character with a script, as we did in our case, or use root motion. As the name suggests, this allows the animation itself to move the root of the character (or object or creature) achieving a more realistic motion in space.</p><p>However, it is not straightforward and has some drawbacks. For instance, it is more expensive from a computational point of view, and as such, many characters with root motions on low-end devices could be prohibitive. Furthermore, it requires different tweaks, especially if the animation is not really well done.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec53"/>Inverse Kinematic</h3></div></div></div><p>Inverse Kinematic is something relatively new in video games. It allows you to have a target into the animation, and sometimes compute in real time an animation that suits the target. For instance, imagine a character who just wants to rest his or her hands on the wall. The Inverse Kinematic should allow you to control the animation to place the hand on the wall, regardless of whether the wall is 1 centimeter further or closer.</p><p>Usually animations use what is called Direct Kinematic (or Forward Kinematic). Based on the position and rotation of the joints, it is possible to determine the position of each part of the skeleton. So imagine having an arm, and based on the positions and rotations of your shoulder, elbow, and wrist, you can determine the position and rotation of your hand. In fact, these techniques come from robotic research.</p><p>The inverse problem, known as Inverse Kinematic, is to determine the positions and rotations of your shoulder, elbow, and wrist starting from the position and rotation of your hand. However, this problem is not uniquely determined, since it might have infinite solutions. Therefore, solving this problem wasn't straightforward. In any case, different techniques (which in the case of robotics may involve inverting the Jacobian matrix) were developed to solve this problem.</p><p>The problem with having different solutions is that some of them may lead to very unusual poses. Following again the example of the arm, a solution that, in order to rest the hand to the wall, brings the elbow up to the eye is not really believable (see the next image, on the left). Whereas this might be a relative problem if applied to robotics, in animation this is indeed a big problem, because we want our characters to be believable.</p><p>So, other techniques have been developed to solve the problem, and the study of social behaviors (for humanoid characters) have been conducted to understand why some poses are more realistic than others. For instance, the pose in the preceding picture is tiring; nobody will ever rest his hand on the wall in such way. In fact, this also deals with physics, since our brain tries to control our body in such a way to spend as less energy as possible. This results in an unconscious behavior that we recognize in other people, and our videogame characters need it as well.</p><p>Unity implements some of these techniques, and Mecanim supports some kind of Inverse Kinematic for humanoid characters, given that they have a correct configured avatar. However, we don't want to dig any deeper in this. I just leave the most curious reader with the link to the Official Documentation here: <a class="ulink" href="https://docs.unity3d.com/Manual/InverseKinematics.html">https://docs.unity3d.com/Manual/InverseKinematics.html</a>.</p><div><h3 class="title"><a id="note54"/>Note</h3><p>Another example where Inverse Kinematic is studied and used is for virtual presence in virtual reality. The recent Oculus Touch allows you to have your hands within the Rift Headset, but not your elbow and/or shoulder. While implementing inverse kinematic-even taking into account the believability and the less energy pose-the software is yet not able to precisely map your arm positions in space, because you will feel awkward. However, in multiplayer games, you can see other people in the virtual world but not in reality (or feel their bodies like they do), and therefore Inverse Kinematic can be applied. Although it won't give the exact position of the elbows of the other players in the game, it is close enough to be believable. A game that uses this mechanism is for instance Dead and Buried. As you can see from the next picture, you can see only your hands, but of the other players, you can see their whole bodies.</p></div><div><img src="img/image00509.jpeg" alt="Inverse Kinematic"/></div><p style="clear:both; height: 1em;"> </p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Animator component information box</h2></div></div></div><p>As we already mentioned before, the Animator component has an information box at the bottom, which may contain some useful data. Here is a picture of the information box again, for your reference:</p><div><img src="img/image00510.jpeg" alt="Animator component information box"/></div><p style="clear:both; height: 1em;"> </p><p>Besides the <strong>Clip Count</strong> that we already have seen, here is a briefly list of the other information:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Pos</strong>, <strong>Rot</strong>, and <strong>Scale</strong>: These indicate the total number of curves used respectively for the position, rotation and scale. The animation window, the one we didn't see in detail, allows you to create such curves.</li><li class="listitem"><strong>Muscles</strong>: The number of muscles used in the Animator in case of Humanoid characters.</li><li class="listitem"><strong>Generic</strong>: The number of numeric curves used by the Animator to animate other properties.</li><li class="listitem"><strong>PPtr</strong>: The total count of sprite animation curves; it is useful when we work in 2D.</li><li class="listitem"><strong>Curves Count</strong>: The total combined number of animation curves.</li><li class="listitem"><strong>Constant</strong>: The number of animation curves that are optimized as constant values. Unity selects this automatically if your animation files contain curves with unchanging values.</li><li class="listitem"><strong>Dense</strong>: The number of animation curves that are optimized using the <em>dense</em> method of storing data (discrete values, which are interpolated between linearly). This method uses less significantly less memory than the <em>stream</em> method.</li><li class="listitem"><strong>Stream</strong>: The number of animation curves using the <em>stream</em> method of storing data (values with time and tangent data for curved interpolation). This data occupies significantly more memory than the <em>dense</em> method.</li></ul></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec54"/>Legacy animation</h3></div></div></div><p>A simpler animation system was used by Unity prior to the introduction of Mecanim (in year 2012, with Unity 4.0). Given that some time has passed since then, backward compatibility is still available. As a result, it is still possible to continue working on older projects without having to update Mecanim or worrying about other issues arising from the software.</p><p>Some people find the Legacy animation system useful for fast prototyping and/or testing animation clips, especially when the object has only one animation clip. This is because it was based on the Animation component (picture given next), and it should not be confused with the Animator component that we have seen before in the chapter.</p><div><img src="img/image00511.jpeg" alt="Legacy animation"/></div><p style="clear:both; height: 1em;"> </p><p>You can find out more about the Legacy animation system here in the official documentation: <a class="ulink" href="https://docs.unity3d.com/Manual/Animations.html">https://docs.unity3d.com/Manual/Animations.html</a>.</p><p>So, unless you have a specific need for it, you can completely ignore the Legacy Animation system, but it was worthwhile to mention it so that you don't get confused in case you found the Animation component and didn't know what it was.</p><p>In saying that, and while the legacy animation is still available, it is not recommended that you use it for new projects with Unity.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec50"/>Get animated!!</h1></div></div></div><p>One practical example to do that takes you outside of Unity is to think about the movement involved in animation. For example, when you are walking, typing, drinking, eating, any kind of movement, do it in slow motion. What you begin to notice is how subtle movements can make animations distinct and give it character. For each animation, such as drinking a glass of water for instance, do it in a different way. Pick up the cup, perhaps with a different grip such as using your whole hand or a few fingers around the handle. As you begin to become more conscious about movement, you should be able to gain some insight into how you might need to adjust an animation in Unity when something doesn't quite feel right. To get a better idea again, search for videos, even books to explore the uses of animation and some of their underpinnings. While this book is in no way a how to on animation, understanding the fundamentals not only help you to improve your own understanding about animations, but also help you to better understand the role of an animator and what it entails. This kind of information will be valuable to you later if you ever work or need to work with an animator.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec51"/>Homework</h1></div></div></div><p>In this chapter, we faced many aspects of Animation clips and Animator controllers. However, before we go to the next chapter, I invite you to give a look to these exercises to improve your skills:</p><div><ol class="orderedlist arabic"><li class="listitem"><strong>Becoming an animation designer</strong>: Think of five games that you play, and select a part of each game such as the tutorial level, fighting a boss, walking through a forest, or even the main menu. Now, write down a list of animations that each of them have. Next, remove some animations, or even add some and think how it would alter the experience. Does it improve it, or does it change the atmosphere entirely? Could you make a relatively happy atmosphere really dark by changing some of the animations, and vice versa? By doing this, you will begin to understand the importance that animations play on not only providing life to your game, but also emotion and setting the atmosphere.</li><li class="listitem"><strong>Drawing an animation (Part I)</strong>: Imagine that you need to create an animation; you can do this simply in a graphics program. Begin by blocking out the arm; you can use a square for the hand, a rectangle for the forearm, and a longer rectangle for the upper arm. Now, move each one so that it performs a swing animation. It would be ideal to set it up like the Sprite Sheets that we have used so far. Then, import them inside Unity and test it out.</li><li class="listitem"><strong>Drawing an animation (Part II)</strong>: Now, add details to your animation, or other body parts such as legs. Moreover, feel free to add some special effects, like the Hit animation of the panda. Once you have you animation ready, try to create a second and a third one. Then, import them all, set them up, and build an Animator controller to see how they are animated. Furthermore, you can polish your animations in order to improve the transitions between them.</li><li class="listitem"><strong>A less dauntless Panda (Part I)</strong>: As we have scripted, when the panda is hit, it keeps moving forward. However, the panda should be a little stunned. Only when the animation finishes, the panda should continue its advance towards the player's cake. Fix this problem with any technique you come up, so you can modify the <strong>Panda Script</strong> or create Machine State Behaviours.</li><li class="listitem"><strong>A less dauntless Panda (Part II)</strong>: If you have done the previous exercise and found a solution to the fix, it's time to make your code a bit more robust. Add a Boolean value in the <strong>Panda Script</strong> and stop the panda from moving when it is hit, but only if the Boolean is set to true. In this way, we can expose this variable in the <strong>Inspector</strong> and give more possibilities of which kind of panda the player has to face (continued in the next chapter).</li><li class="listitem"><strong>State Machine Behaviour as a listener</strong>: We have implemented the <strong>Panda Script</strong> in such a way that triggers are set in the Animator controller to change animations. Now, remove both the Hit and Die triggers from the <strong>Panda Script</strong> and implement other Machine State Behaviours that retrieve the value of panda's health and respectively trigger the Hit animation when health is decreased from the last time or the Die animation if it is below zero.</li><li class="listitem"><strong>Explore the Animation window</strong>: Even if we didn't deal with the animation window, you can try to explore it, maybe by following the link to the official documentation provided. Then, try to make some animations for our sprinkles so that they can rotate while they are flying towards an evil Panda. Maybe you can also create a collision animation. Wrap these animations within an Animator controller and modify the Projectile script if needed.</li></ol><div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec52"/>Summary</h1></div></div></div><p>Thus, we created four different animation clips for our panda, one for each of its possible actions: Walk, Die, Hit, and Eat. Then, we wrapped them within a controller and built a finite state machine to define how these animation clips are linked, through transitions. Finally, we wrote a script to trigger the different states of the machine.</p><p>Now that we have seen how to animate our Pandas, it's time to move on to the next chapter, maybe after a coffee break.</p></div></body></html>