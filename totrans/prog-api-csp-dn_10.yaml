- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying to Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore **Continuous Integration and Continuous Deployment**
    ( **CI/CD** ) on Azure. These are critical skills for enterprise development and
    ensure that bugs are caught early in the process, especially when working with
    a team. The earlier integration issues are surfaced, the less expensive they are
    to fix.
  prefs: []
  type: TYPE_NORMAL
- en: Among the skills that we will review are creating an Azure project, creating
    a pipeline, and configuring the pipeline for CI/CD.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will build on the skills you developed in [*Chapter 6*](B21998_06.xhtml#_idTextAnchor077)
    and walk you through setting up CI/CD step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using tests to ensure code quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying from DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Azure.Data.Tables** NuGet package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the end of [*Chapter 6*](B21998_06.xhtml#_idTextAnchor077) , you saw how
    easy it is to deploy to Azure directly from Visual Studio. This is fine for testing
    scenarios and one-off experiments or proofs of concept, but in a production scenario,
    this one project may be part of a much larger system.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a series of “gates” (checks) before publishing to production can
    be advantageous for many reasons. Note that there are many types of release gates.
    The most common (and important) are **Pull Requests** ( **PRs** ), unit tests,
    integration tests, and end-to-end tests.
  prefs: []
  type: TYPE_NORMAL
- en: Using tests to ensure code quality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many kinds of tests that you might run against your code. Among the
    most important are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests cover one section of your code that does one thing. For example,
    many unit tests have a 1:1 correspondence with methods, but not always. Think
    functionality rather than code. However, they must run extremely fast so that
    you run them after every code change. This allows you to code with confidence,
    knowing that if anything breaks, you know that something went wrong and where
    the problem is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'Integration tests are run less often, typically after completing a discreet
    set of functionality to make sure that what you’ve created fits together with
    what is already in place. Finally, end-to-end tests ensure that the entire set
    of scenarios works as expected. This is, typically, where professional QA people
    run their tests. As programmers, it is almost impossible to run thorough end-to-end
    tests on our own code: we see what we expect to see, and we run what we expect
    the user to run. QA professionals can create a suite of tests to ensure that the
    program works well with good data but also with bad or corrupted data and when
    the user does something we didn’t expect.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, you can automate all of these tests, checking various levels of
    the code to ensure nothing has regressed. While we won’t be looking at all of
    the advanced scenarios that Azure DevOps provides for us, we will be setting up
    a standard build and release pipeline that you can use to automate your deployments.
    In short, we will set up CI that will automate what we just did when we manually
    published to Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Manual versus automated implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Going a little deeper, let’s compare DevOps (continuous delivery) and publishing
    through Visual Studio manually. You can have automated builds whenever a new commit
    has been pushed to master. Along with automated builds on a branch, you can have
    builds checked with PRs. PRs have the benefit of another skilled programmer checking
    and testing your code before it is merged in. The fact is that automated tests
    can only go so far. PRs are also a good place to determine and test which environments
    your code requires (e.g., Windows, Linux, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: Using the same binaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is highly advantageous to deploy exactly the same binaries to your lower
    environments, such as your local computer, and then promote these same binaries
    to production. Though C# and .NET do have deterministic builds, the other parts
    of your deployed package or container may not. If something does go wrong after
    deployment, DevOps provides the ability to immediately roll back your deployed
    artifact. A history of these deployments is kept for each environment as well.
  prefs: []
  type: TYPE_NORMAL
- en: While DevOps is superior in a lot of scenarios, it can be somewhat more difficult
    when debugging build failures. Each step of the build pipeline is logged for you
    to look at and diagnose later; however, that is sometimes easier said than done.
    Additionally, the more concurrent pipeline builds there are, the more difficult
    it may be to figure out what went wrong in the case of a failure. Compounding
    this, the larger the team gets, the more queueing of builds may happen.
  prefs: []
  type: TYPE_NORMAL
- en: With that in place, we are ready to deploy to DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The number of concurrent executing pipelines and the execution minutes per month
    is limited in the free version of DevOps. You can, of course, subscribe to increase
    these restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying from DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ll now be walking through deploying from DevOps instead of our local Visual
    Studio. The first step is to create your DevOps project, as shown in *Figure 10*
    *.1* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – DevOps opening page](img/B21988_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – DevOps opening page
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the project, we’ll use the wizard. (The first time, the wizard will
    probably come up immediately, otherwise click to bring up the wizard.) Here are
    the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [dev.Azure.com](http://dev.Azure.com) .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Start free** (even if you already have an account).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it redirects you, enter **dev.azure.com** in the address box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **New Project** in the upper right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a name and description and choose **private** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Advanced** and make sure the version control is set to **Git** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s now import a bit of code.
  prefs: []
  type: TYPE_NORMAL
- en: Importing sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can deploy to Azure, we need to have a repository with the code we
    want to deploy. Clone the code for [*Chapter 6*](B21998_06.xhtml#_idTextAnchor077)
    from [https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter06](https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter06)
    and copy or move it into another folder so that it is no longer associated with
    the cloned repo. Open the solution in Visual Studio. Now we want to use Visual
    Studio to create a repository in our new DevOps project. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **GitChanges** view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create** **Git Repository** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Azure DevOps** , as shown in *Figure 10* *.2* , and click on **Create**
    **and Push** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Create a Git repository](img/B21988_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Create a Git repository
  prefs: []
  type: TYPE_NORMAL
- en: With that in place, we are ready to create the actual build pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the build pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have your code in an Azure repository, you can create the build
    pipeline. To do so, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Create Pipeline** , as shown in *Figure 10* *.3* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Create Pipeline](img/B21988_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Create Pipeline
  prefs: []
  type: TYPE_NORMAL
- en: You should see a wizard that will walk you through creating your pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The first step asks where your code is. DevOps supports a few different code
    repositories, including Azure Repos, Bitbucket, GitHub, GitHub Enterprise, other
    generic Git repositories, and Subversion.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are two different ways to build your pipelines. The first is through YAML
    files, which can be in your repository alongside your code, which has the added
    benefit of being versioned. The second supported way to build your pipelines is
    the way we’ll be taking.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Use the classic editor** , which will give us a much more in-depth
    UI to create a pipeline without YAML
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose your repository in the next dropdown and then select the default branch,
    as shown in *Figure 10* *.4* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Select a source](img/B21988_10_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Select a source
  prefs: []
  type: TYPE_NORMAL
- en: Click **Continue** and you will see a screen that asks you to select a template
    for your project. A number of standard ones are displayed by default but there
    are many others available. Since we are building and deploying an Azure function,
    scroll down to where it lists **Azure Functions for .NET** , as shown in *Figure
    10* *.5* , and click **Apply** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Azure Functions for .NET](img/B21988_10_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Azure Functions for .NET
  prefs: []
  type: TYPE_NORMAL
- en: This takes you to an editor for your pipeline. You should see various tabs,
    including **Tasks** , **Variable** , **Triggers** , **Options** , and **History**
    .
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline item under the **Tasks** tab should be selected by default. If
    not, select it. In either case, click it and then rename your pipeline to whatever
    you would like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The agent pool allows you to select from Microsoft-hosted build machines or,
    if you have custom private agents set up, you can also select those. We will not
    be covering private agents in this book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **Azure Pipelines** for the agent pool, and select **ubuntu latest**
    for **Agent Specification** , as shown in *Figure 10* *.6* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Although leaving the agent specification as Windows may work, we find it prevents
    a number of issues when you match your agent specification to the resource type
    that you created in Azure. In our case, we made a Linux Azure function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Pipeline setup](img/B21988_10_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Pipeline setup
  prefs: []
  type: TYPE_NORMAL
- en: Select **Get Sources** under the **Tasks** tab. This should already be filled
    out for you with a number of defaults, including your default branch to build
    from. The defaults for **Agent job 1** under the **Get sources** item should be
    fine and can be retained as is. Click on **Build Project** under **Agent job 1**
    to select the actual task that is used to build the published output, as shown
    in *Figure 10* *.7* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Get sources](img/B21988_10_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Get sources
  prefs: []
  type: TYPE_NORMAL
- en: The default task should be **Build Project .NET Core** . You can build a number
    of different types of assemblies, including console, libraries, ASP.NET Core,
    and, in our case, Azure Functions. As of the time of writing, task version 2 is
    currently supported and is the default.
  prefs: []
  type: TYPE_NORMAL
- en: Change the display name to something more descriptive, such as **Publish Project**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **publish** from the **Command** dropdown. Uncheck **Publish web projects**
    . Though our Azure function is an API and could be considered a web project in
    a different context, we do not need this particular functionality for what we
    are doing. Leave the arguments as is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that **Zip published projects** and **Add project’s folder name to publish
    path** are both checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Arguments** text box, change **publish_output** to **$(build.artifactstagingdirectory)**
    , as shown in *Figure 10* *.8* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Publish Project](img/B21988_10_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Publish Project
  prefs: []
  type: TYPE_NORMAL
- en: You can explore the other **Advanced** , **Control Options** , and **Output
    Variables** expanders but the defaults should be fine.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on **Archive Files** and choose **Remove Task** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are now ready to publish that artifact to DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing an artifact
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To publish the artifact, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Publish Artifact: Drop** on the left side.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is what uploads your newly zipped output folder to DevOps’s artifact storage
    for further release later. The defaults in this section should be fine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Triggers** tab. Check the **Enable continuous integration** box,
    and ensure that **Include** is selected for the master branch. This is what triggers
    builds on every push to master.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Save & queue** under the **Save & queue** dropdown (to the right of
    the tabs).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the **Run pipeline** dialog box appears, fill in a comment just like you
    would when committing code, and click **Save** and **Run** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Pipelines** tab on the far left, which will bring you back to
    the list of pipelines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The pipeline that you named should show, and the icon should be blue on your
    screen indicating that it is executing the build pipeline. If it is finished,
    or after a minute or so, it will turn green.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the larger list item to go to the list of the builds for that pipeline,
    or the text of the commit message to go directly to those build details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Summary** tab, you should see a variety of information, including the
    build number, branch, commit, number of artifacts published, and list of jobs.
    Next to the **Summary** tab may be other tabs. These can be added by other plugins.
    Clicking on the job indicated by the green check displays the individual steps
    that the agent used to build your artifact. All standard out (console output)
    is captured and saved for use in the debugging build errors. Usually, build errors
    will be prominent and direct you to the location of the error.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying your artifact to Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that your artifact is built and zipped, we’ll deploy it to Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Releases** subsection under **Pipelines** on the left. Click
    on **New Release Pipeline** . Once again, a familiar **Select a Template** screen
    should be shown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can scroll down or search for **Functions** in the list, select the one
    that says **Deploy a Function App to Azure Functions** , and click **Apply** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now see a stage pop out named **Stage one** . This entire section
    can be customized with different business workflows according to your needs. For
    this exercise, we will have a single environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Change the stage name to **Production** . Click on **Add an Artifact** . Select
    the source of the artifact, which in our case is a build artifact – which may
    already be selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your project and then your source build pipeline. Leave the latest as
    the default version and your source alias should already be pre-populated. Click
    **Add** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the most powerful opportunities when deploying to Azure is CD. Every
    time your code is checked in and approved, a version is created and deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your artifact name should now be in the **Artifact** section. Take the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the lightning bolt icon on the artifact to show the CD triggers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the CD. This is how we automate the creation of a release after the build
    is completed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the lightning bolt icon on the production stage. This is also part
    of the automatic deployment configuration. **After Release** should be selected
    by default; however, if you do not want the release pipeline to automatically
    start, then select **Manual Only** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on the **1 Job, 1 Task** label with the red icon, or you can select
    the **Tasks** tab. This should look similar to the build pipeline that we created
    earlier. There should be a few items highlighted in red indicating that they need
    attention.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your Azure subscription from that drop-down list. If there is an **Authorize**
    button, click it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Function App on Linux** for your app type, and then under the **App
    service name** dropdown, you should see all of the available Linux Azure functions.
    Please note that if the resource was created recently, it may not show up immediately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on **Run On Agent** and use the same agent settings that we did in the
    build pipeline: **Azure Pipelines** for the agent pool and **ubuntu latest** for
    the agent specification. The rest of the defaults will be fine.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click on **Deploy Azure Function App** . You can change the display
    name to something more descriptive if you’d like. Notice that the Azure subscription
    app type and Azure Functions app name are grayed out. These should match the ones
    we selected when we selected the production stage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the triple dots under the package or folder label and then navigate
    down to the artifact ZIP that was built, as shown in *Figure 10* *.9* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Select a file or folder](img/B21988_10_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Select a file or folder
  prefs: []
  type: TYPE_NORMAL
- en: For the runtime stack, select **.NET isolated 8.0** and leave **Start with**
    **Command** blank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the application and configuration settings and click on the triple dots
    next to the app settings. This may look familiar to you because this is where
    we are going to set up the application settings as we did in [*Chapter 6*](B21998_06.xhtml#_idTextAnchor077)
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on **Add** and use the same name that we used in Azure before: **MyReturnProperty**
    . For the value, and keeping with the consistency of what we have seen before,
    you can use something such as *my value from DevOps* . (If you have spaces in
    this value, be sure to put it all in double quotes.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Ok** . The name-value pairs should be joined together into a single
    string in the app settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on **Save** , and fill out the comment if you want. You can leave
    the folder as a slash, or if you know you will have a lot of release pipelines
    in the future you can organize them into folders here. Then, click **Ok** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’re not quite done. We must test the release pipeline to ensure that everything
    works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the release pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s test our release pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Create release** in the upper right-hand corner. You should see the
    **Create New Release** flyout. You can do temporary one-off adjustments on the
    manual or automated settings for each of the stages. You may want to create the
    release, but not necessarily actually push it out to production. You should see
    the artifact that was created in the build pipeline along with a proper version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create** . Since we left the stage set to automated, it should automatically
    begin releasing. Click on the newly created release and you should see a blue
    in-progress icon, or green if it has already succeeded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can click on a stage to show logging information under **Summary** along
    with what commits were made in this new release. Back in the production stage,
    you can click on logs, which will bring you to the log view of the release pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For demonstration purposes, disable authorization by going to the authentication
    section in your function application resource and clicking on the **Edit Text**
    link (by the **Authentication settings** header). Select **Disable** . Click **Save**
    . (Be sure to re-enable this when you are finished testing.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the release has finished, navigate to the **Function1** URL we were using
    in [*Chapter 6*](B21998_06.xhtml#_idTextAnchor077) , or refresh if it is still
    open in the browser. It should now display the settings that we configured in
    the release pipeline: *my value* *from DevOps* .'
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s test to make sure it is all working:'
  prefs: []
  type: TYPE_NORMAL
- en: Go back to Visual Studio and make a small edit (e.g., a comment).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit, and then push that to the master branch. Back in DevOps, go to the **Pipelines**
    section and you should see that that pipeline is already building. Wait for it
    to complete, then navigate to the release pipeline. You should see that a brand-new
    release was created immediately after the build succeeded and should now either
    be running or perhaps even completed already.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! You have set up a pipeline that automatically deploys an Azure
    function HTTP trigger on every commit to the master branch!
  prefs: []
  type: TYPE_NORMAL
- en: '*Piece* *of cake!*'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on deploying our Azure function using CI/CD.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to set up the pipeline and connect it to our function. We also saw
    how to enable deployment to fire every time code is pushed to the master branch.
  prefs: []
  type: TYPE_NORMAL
- en: You try it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a simple Azure function. Next, create a new pipeline that automatically
    deploys that Azure function on every commit to the master branch. Take your time;
    there are a lot of steps.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have worked your way through creating APIs and seen how to migrate your
    work to Azure. You have conquered many advanced topics and are ready to implement
    enterprise APIs. Thank you for hanging in there with us, and be sure to let us
    know what you liked (and didn’t!) about this book. Finally, if you have the time,
    please leave a review on Amazon. You know what they say: if you liked it, tell
    Amazon; if not, tell us!'
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, we briefly point you to additional resources.
    We hope they are helpful as you go forward.
  prefs: []
  type: TYPE_NORMAL
