- en: Integrating External Components and Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成外部组件和处理
- en: So far, we have been developing our FlixOneStore. In the previous chapter, we
    added a shopping cart and shipping facility. However, some organizations may not
    need such facilities, as some organizations have everything in the house. For
    instance, our FlixOneStore requires an external component to help us track the
    assignment and payment-management system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在开发我们的 FlixOneStore。在上一章中，我们添加了购物车和发货功能。然而，某些组织可能不需要这样的设施，因为某些组织已经拥有一切。例如，我们的
    FlixOneStore 需要一个外部组件来帮助我们跟踪分配和支付管理系统。
- en: 'In this chapter, we will discuss the external components with the help of code
    examples. We will mainly cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过代码示例来讨论外部组件。我们将主要涵盖以下主题：
- en: Understanding the middleware
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解中间件
- en: Adding logging to our API in the middleware
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在中间件中添加日志记录到我们的 API
- en: Intercepting HTTP requests and responses by building our own middleware
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过构建自己的中间件来拦截 HTTP 请求和响应
- en: JSON-RPC for RPC communication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON-RPC 用于 RPC 通信
- en: Understanding the middleware
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解中间件
- en: As the name suggests, middleware is a piece of software that connects two different
    or similar places. In the world of software engineering, middleware is a software
    component and is assembled in an application pipeline to handle requests and responses.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，中间件是一种连接两个不同或相似位置的软件。在软件工程的世界里，中间件是一个软件组件，它被组装到应用程序管道中，以处理请求和响应。
- en: These components can also check whether a request should pass to the next components,
    or whether the request should be handled by a component before or after the next
    component is triggered/invoked. This request pipeline is built with the use of
    a request delegate. This request delegate interacts with each HTTP request.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件还可以检查请求是否应该传递到下一个组件，或者请求是否应该在下一个组件触发/调用之前或之后由组件处理。这个请求管道是通过使用请求代表构建的。这个请求代表与每个
    HTTP 请求交互。
- en: 'Look at the following quote from the documentation of ASP.NET Core ([https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/)):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下来自 ASP.NET Core 文档的引用（[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/))：
- en: '"Middleware is software that''s assembled into an application pipeline to handle
    requests and responses."'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: “中间件是组装到应用程序管道中以处理请求和响应的软件。”
- en: 'Look at the following diagram, showing an example of a simple middleware component:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下图表，展示了一个简单的中间件组件的示例：
- en: '![](img/9bce228e-7b7b-4e9c-8088-5adfcb279a1f.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9bce228e-7b7b-4e9c-8088-5adfcb279a1f.png)'
- en: Requesting delegates
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求代表
- en: Requests are handled by the `Use`, `Run`, `Map`, and `MapWhen` extension methods.
    These methods configure the request delegates.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请求由 `Use`、`Run`、`Map` 和 `MapWhen` 扩展方法处理。这些方法配置请求代表。
- en: 'To understand this in detail, let''s create a dummy project using `ASP.NET
    Core`. Go through the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更详细地了解这一点，让我们使用 `ASP.NET Core` 创建一个模拟项目。按照以下步骤操作：
- en: Open Visual Studio.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio。
- en: 'Go to File | New | Project, or click *Ctrl* + *Shift* + *N*. Refer to the following
    screenshot:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“文件”|“新建”|“项目”，或按 *Ctrl* + *Shift* + *N*。参考以下截图：
- en: '![](img/c0b2f086-c173-4d34-bd96-36a9f72eb2aa.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c0b2f086-c173-4d34-bd96-36a9f72eb2aa.png)'
- en: Creating a new project using Visual Studio 2017
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 2017 创建新项目
- en: From the New Project screen, select ASP.NET Core Web Application.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“新建项目”屏幕中选择 ASP.NET Core Web 应用程序。
- en: 'Name your new project (say `Chap05_01`), select a location, and click OK, as
    shown in the following screenshot:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名您的新项目（例如 `Chap05_01`），选择位置，然后单击“确定”，如下截图所示：
- en: '![](img/230053ba-e018-446e-bc6d-e6fd627bb5b1.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/230053ba-e018-446e-bc6d-e6fd627bb5b1.png)'
- en: Selecting new project template
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 选择新项目模板
- en: From the new ASP.NET Core Web Application template screen, choose the API template.
    Make sure you select .NET Core and ASP.NET Core 2.0.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的 ASP.NET Core Web 应用程序模板屏幕中选择 API 模板。确保您选择了 .NET Core 和 ASP.NET Core 2.0。
- en: 'Click OK, as shown in the following screenshot:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“确定”，如下截图所示：
- en: '![](img/f27c348c-5b5b-49e9-9f5b-149c6bae1232.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f27c348c-5b5b-49e9-9f5b-149c6bae1232.png)'
- en: 'Open Solution Explorer. You will see the file/folder structure, as shown in
    the following screenshot:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开解决方案资源管理器。您将看到文件/文件夹结构，如下截图所示：
- en: '![](img/59fe708a-495b-4023-b55d-7743d92329ce.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59fe708a-495b-4023-b55d-7743d92329ce.png)'
- en: Showing file/folder structure of Chap05_01 project
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 显示 Chap05_01 项目的文件/文件夹结构
- en: 'From the dummy project that we have just created, open the `Startup.cs` file
    and look at the `Configure` method, which contains the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们刚刚创建的模拟项目中打开 `Startup.cs` 文件，查看包含以下代码的 `Configure` 方法：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code is self-explanatory: it tells the system to add `Mvc` to
    the request pipelines by initiating the `app.UseMvc()` extension method of `Microsoft.AspNetCore.Builder.IApplicationBuilder`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是自我解释的：它告诉系统通过启动 `Microsoft.AspNetCore.Builder.IApplicationBuilder` 的 `app.UseMvc()`
    扩展方法将 `Mvc` 添加到请求管道中。
- en: You can get more information on `IApplicationBuilder` at [https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder?view=aspnetcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder?view=aspnetcore-2.0).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder?view=aspnetcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder?view=aspnetcore-2.0)
    获取有关 `IApplicationBuilder` 的更多信息。
- en: It also instructs the system to use a particular exception page if the environment
    is in development. The preceding method configures the application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它还指示系统在开发环境中使用特定的异常页面。前面的方法配置了应用程序。
- en: In the next section, we will discuss four important `IApplicationBuilder` methods in
    detail.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将详细讨论四个重要的 `IApplicationBuilder` 方法。
- en: Use
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用
- en: 'The `Use` method adds a delegate to the application request pipelines. Look
    at the following screenshot for the signature of this method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Use` 方法向应用程序请求管道中添加一个委托。请查看以下截图以了解此方法的签名：'
- en: '![](img/291321c1-da74-4bc7-85da-9ab284eee7ff.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/291321c1-da74-4bc7-85da-9ab284eee7ff.png)'
- en: Signature of Use method
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Use` 方法的签名'
- en: As we discussed in the previous section, the middleware methods can short circuit
    the request pipeline or pass the request to the next delegate.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中讨论的，中间件方法可以短路请求管道或将请求传递给下一个委托。
- en: Short-circuiting a request is nothing but ending a request.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 短路请求不过是结束请求。
- en: 'Look at the following code for the `Use` method:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下 `Use` 方法的代码：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, I have tried to explain the dummy implementation of the
    `Use` method with the help of a local function. Here, you can see that `Middleware`
    is invoking or passing the request to the next delegate, before or after `await
    next.Invoke();`. You can write/implement other code phrases, but these phrases
    should not send responses to the client, such as those that write output, produce
    the 404 status, and so on.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我试图通过使用局部函数来解释 `Use` 方法的模拟实现。在这里，你可以看到 `Middleware` 在 `await next.Invoke();`
    之前或之后调用或传递请求给下一个委托。你可以编写/实现其他代码片段，但这些代码片段不应该向客户端发送响应，例如那些写入输出、产生 404 状态等的代码片段。
- en: '**Local functions** are the methods that are declared within a method and can
    be called within the scope of the method itself. These methods can only be used
    by another method.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**局部函数**是在方法内部声明的函数，可以在方法的范围内调用。这些方法只能由另一个方法使用。'
- en: Run
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行
- en: 'The `Run` method adds a delegate to the request pipeline in the same way as
    the `Use` method, but this method terminates the request pipeline. Look at the
    following screenshot for the signature of this method:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run` 方法与 `Use` 方法以相同的方式向请求管道中添加一个委托，但此方法会终止请求管道。请查看以下截图以了解此方法的签名：'
- en: '![](img/6a5a0166-c10b-490c-8ccc-a4454aabc2a0.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6a5a0166-c10b-490c-8ccc-a4454aabc2a0.png)'
- en: 'Look at the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下代码：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, I tried to show that `Run` terminates the request pipeline.
    Here, I used a local function, `RequestDelegate`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我试图通过使用局部函数 `RequestDelegate` 来展示 `Run` 终止请求管道。在这里，我使用了局部函数。
- en: 'You can see that I added a console logger before this and that there is scope
    to add more code phrases, but not those phrases that send responses back to the
    client. Here, `Run` terminates by returning a string. Run Visual Studio or press
    *F5*—you will get an output similar to the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我在此之前添加了一个控制台记录器，并且有空间添加更多的代码片段，但不是那些将响应发送回客户端的代码片段。在这里，`Run` 通过返回一个字符串来终止。运行
    Visual Studio 或按 *F5* 键，你将得到类似于以下截图的输出：
- en: '![](img/47ec67d8-9b78-4440-8bb0-223ef2a17710.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/47ec67d8-9b78-4440-8bb0-223ef2a17710.png)'
- en: Map
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: 'The `Map` method helps when you want to connect multiple instances of middleware.
    To do this, `Map` calls another request delegate. Look at the following screenshot
    for the signature of this method:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map` 方法有助于当你想要连接多个中间件实例时。为此，`Map` 调用另一个请求委托。请查看以下截图以了解此方法的签名：'
- en: '![](img/9e767d6f-3229-463b-9373-8c8ec0ac298a.png)^(Signature of Map method)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e767d6f-3229-463b-9373-8c8ec0ac298a.png)^(Map方法的签名)'
- en: 'Look at the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this code, I added a `Map` that just maps `<url>/testroute`. Following this
    is the same `Run` method that we discussed previously. `TestRoutehandler` is a
    private method. Look at the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我添加了一个`Map`，它只是映射`<url>/testroute`。接下来是之前讨论过的相同的`Run`方法。`TestRoutehandler`是一个私有方法。看看下面的代码：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before `app.Run(Handler);` is a normal delegate. Now, run the code and look
    at the results. They should be similar to the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.Run(Handler);`之前是一个正常的委托。现在，运行代码并查看结果。它们应该类似于以下截图：
- en: '![](img/93907e52-1b91-46c5-9e62-7b3ab8e77ac8.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93907e52-1b91-46c5-9e62-7b3ab8e77ac8.png)'
- en: 'You can see that the root of the web application is showing the string that
    is mentioned in the `Run` delegate method. You will get the output shown in the
    following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，Web应用程序的根目录显示了在`Run`委托方法中提到的字符串。你将得到以下截图所示的输出：
- en: '![](img/a5cb5a2a-d3dd-417c-8f89-d9d3ddb0df73.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5cb5a2a-d3dd-417c-8f89-d9d3ddb0df73.png)'
- en: Adding logging to our API in middleware
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在中间件中为我们的API添加日志记录
- en: In simple words, logging is nothing but the process or act of getting log files
    in one place to get the events or other actions that occur in APIs during communication.
    In this section, we will implement logging for our product APIs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，日志记录就是将日志文件集中在一起的过程或行为，以获取API在通信期间发生的事件或其他操作。在本节中，我们将为我们的产品API实现日志记录。
- en: Before we start looking at how to log our APIs' events, let's first take a quick
    look at our existing product APIs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查看如何记录API的事件之前，让我们先快速看一下我们现有的产品API。
- en: Refer to the *Request delegates *section to refresh your memory as to how you
    can create a new ASP.NET Core project.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下 *请求委托* 部分，以刷新你对如何创建一个新的ASP.NET Core项目的记忆。
- en: 'The following screenshot shows the project structure of our product APIs:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的产品API的项目结构：
- en: '![](img/84ad0efb-4932-4e26-82e1-460cbc488d84.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84ad0efb-4932-4e26-82e1-460cbc488d84.png)'
- en: 'Here is our `Product` model:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的`Product`模型：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Product` model is a class that represents a product, containing properties.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product`模型是一个表示产品的类，包含属性。'
- en: 'Here is our repository interface:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的存储库接口：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `IProductRepository` interface has methods that are required for our APIs
    to start with operations for a product.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`IProductRepository`接口有我们API开始时对产品进行操作所需的方法。'
- en: 'Let''s take a look at our `ProductRepository` class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的`ProductRepository`类：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `ProductRepository` class implements the `IProductRepository` interface.
    The preceding code is self-explanatory.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductRepository`类实现了`IProductRepository`接口。前面的代码是自我解释的。'
- en: 'Open the `Startup.cs` file and add the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Startup.cs` 文件并添加以下代码：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For Swagger support for our Product APIs, you need to add the `Swashbuckle.ASPNETCore` NuGet
    package.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持我们的产品API的Swagger，你需要添加`Swashbuckle.ASPNETCore` NuGet包。
- en: 'Now, open the `appsettings.json` file and add the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`appsettings.json`文件并添加以下代码：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s see what our `ProductController` contains:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的`ProductController`包含什么：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code is the `GET` resource of our product APIs. It calls the `GetAll()`
    method of our `ProductRepository`, transposes the response, and returns it. In
    the previous code, we have already instructed the system to resolve the `IProductRepository` interface with
    the `ProductRepository` class. Refer to the `Startup` class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是我们产品API的`GET`资源。它调用我们的`ProductRepository`的`GetAll()`方法，转换响应，并返回它。在之前的代码中，我们已经指示系统使用`ProductRepository`类解析`IProductRepository`接口。参考`Startup`类。
- en: 'Here is the method that transposes the response:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是转换响应的方法：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code accepts a parameter of the `Product` type and then returns
    an object of the `ProductViewModel` type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码接受一个`Product`类型的参数，然后返回一个`ProductViewModel`类型的对象。
- en: 'The following code shows how our controller constructor is injected:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了我们的控制器构造函数是如何注入的：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, we injected our `ProductRepository`, and it will be automatically
    initialized whenever anyone calls any resources of the product APIs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们注入了我们的`ProductRepository`，并且每当有人调用产品API的任何资源时，它将自动初始化。
- en: Now, you are ready to play with the application. Run the application from the
    menu or click *F5*. In a web browser, you can use the suffix `/swagger` to the
    URL of the address.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好玩这个应用程序了。从菜单中运行应用程序或点击*F5*。在网页浏览器中，你可以在地址的URL后使用后缀`/swagger`。
- en: For the complete source code, refer to the GitHub repository link at [https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码，请参考GitHub仓库链接：[https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core)。
- en: 'It will show the Swagger API documentation, as shown in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 它将显示Swagger API文档，如下所示：
- en: '![](img/81c11e65-4875-466e-a068-7a62e931b066.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/81c11e65-4875-466e-a068-7a62e931b066.png)'
- en: 'Click on the `GET /api/Product/productlist` resource. It will return a list
    of products, as shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`GET /api/Product/productlist`资源。它将返回产品列表，如下所示：
- en: '![](img/2d825f3e-e331-434a-8d31-ad740b96efc1.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2d825f3e-e331-434a-8d31-ad740b96efc1.png)'
- en: Let's implement logging for our API. Please note that to make our demo short
    and simple, I am not adding complex scenarios to track everything. I am adding
    simple logs to showcase the logging capabilities.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的API实现日志记录功能。请注意，为了使我们的演示简短简单，我没有添加复杂场景来跟踪一切。我只是添加了简单的日志来展示日志记录功能。
- en: 'To start implementing logging for our product APIs, add a new class called
    `LogAction` in a new folder called `Logging`. Here is the code from the `LogAction`
    class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始为我们的产品API实现日志记录，在名为`Logging`的新文件夹中添加一个名为`LogAction`的新类。以下是`LogAction`类的代码：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code contains constants that are nothing but our application's
    actions, also called **events**.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码包含的常量只是我们应用程序的操作，也称为**事件**。
- en: 'Update our `ProductController`; it should now look like the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 更新我们的`ProductController`；现在它应该看起来像以下代码：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we added an `ILogger` interface, which comes from a dependency
    injection container (see [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.0 ](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.0)for
    more details).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们添加了一个`ILogger`接口，它来自依赖注入容器（更多详情请见[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.0 ](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.0)）。
- en: 'Let''s add the logging capability to the `GET` resource of the product API:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在产品API的`GET`资源中添加日志记录功能：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code returns the product list and logs the information.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码返回产品列表并记录信息。
- en: To test this scenario, we need a client or an API tool so we can see the output.
    To do this, we will use the `Postman` extension (see[ https://www.getpostman.com/ ](https://www.getpostman.com/)for
    more details).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试此场景，我们需要一个客户端或API工具，以便我们可以看到输出。为此，我们将使用`Postman`扩展（更多详情请见[ https://www.getpostman.com/ ](https://www.getpostman.com/)）。
- en: 'First, we need to run the application. To do so, open the Visual Studio command
    prompt, move to your project folder, and then pass the command `dotnet run`. You
    will see a similar message to the one shown in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要运行应用程序。为此，打开Visual Studio命令提示符，移动到您的项目文件夹，然后输入命令`dotnet run`。您将看到如下所示的类似消息：
- en: '![](img/adeff017-ecbf-4077-bd70-3c2e468bb408.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/adeff017-ecbf-4077-bd70-3c2e468bb408.png)'
- en: 'Now, launch Postman and invoke the `GET /api/product/productlist` resource:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动Postman并调用`GET /api/product/productlist`资源：
- en: '![](img/9f77c310-49f6-4d9c-b833-0d264193c9bd.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f77c310-49f6-4d9c-b833-0d264193c9bd.png)'
- en: 'By clicking the Send button, you would expect a list of products to be returned,
    but this is not the case, as shown in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 点击发送按钮，你期望返回产品列表，但情况并非如此，如下所示：
- en: '![](img/99026730-2294-43ba-85c6-535d9e4cac95.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/99026730-2294-43ba-85c6-535d9e4cac95.png)'
- en: The preceding exception occurs because we are using a non-generic type in our
    `ProductController` that is not injectable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上述异常发生是因为我们在`ProductController`中使用了一个非泛型类型，该类型不可注入。
- en: 'So, we need to make slight changes in our `ProductController`. Look at the
    following code snippet:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要对我们的`ProductController`进行一些小的修改。看看以下代码片段：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, I added a generic `ILogger<ProductController>` type.
    As it is injectable, it will get resolved automatically.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我添加了一个泛型`ILogger<ProductController>`类型。由于它是可注入的，它将自动解析。
- en: Logging is slightly different in .NET Core 2.0 compared to its earlier versions.
    The implementation of the nongeneric `ILogger` is not available by default, but
    it is available for `ILogger<T>`. If you want to use nongeneric implementation,
    use `ILoggerFactory` instead of `ILogger`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与其早期版本相比，.NET Core 2.0 中的日志记录略有不同。默认情况下，非泛型 `ILogger` 的实现不可用，但 `ILogger<T>`
    可用。如果您想使用非泛型实现，请使用 `ILoggerFactory` 而不是 `ILogger`。
- en: 'In this case, the constructor of our `ProductController` would look like the
    following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的 `ProductController` 构造函数将如下所示：
- en: '`private readonly IProductRepository _productRepository;`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`private readonly IProductRepository _productRepository;`'
- en: '`private readonly ILogger _logger;`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`private readonly ILogger _logger;`'
- en: '`public ProductController(IProductRepository productRepository, ILoggerFactory
    logger)`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`public ProductController(IProductRepository productRepository, ILoggerFactory
    logger)`'
- en: '`{`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`{`'
- en: '`_productRepository = productRepository;`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`_productRepository = productRepository;`'
- en: '`_logger = logger.CreateLogger("Product logger");`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`_logger = logger.CreateLogger("Product logger");`'
- en: '`}`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: 'Open the `Program` class and update it. It should look like the following code
    snippet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Program` 类并更新它。它应该看起来像以下代码片段：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You also need to update the `appsettings.json` file and write more code for
    the logger so that your file looks like the following snippet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要更新 `appsettings.json` 文件并为记录器编写更多代码，以便您的文件看起来像以下片段：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, once again, open the Visual Studio command prompt and write the `dotnet
    build` command. It will build the project, and you will get a message similar
    to the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次打开 Visual Studio 命令提示符并写入 `dotnet build` 命令。它将构建项目，您将收到类似于以下截图的消息：
- en: '![](img/712f7568-3d05-4989-87ea-78badf111be9.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/712f7568-3d05-4989-87ea-78badf111be9.png)'
- en: 'From this point, if you run Postman, it will give you the results, as shown
    in the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，如果您运行 Postman，它将给出以下截图所示的结果：
- en: '![](img/955ca74a-b21f-4f99-8816-ddfe33cb32e5.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/955ca74a-b21f-4f99-8816-ddfe33cb32e5.png)'
- en: 'The preceding code adds the ability to log the actions. You will receive similar log
    actions to those shown in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码添加了记录操作的能力。您将收到类似于以下截图所示的类似日志操作：
- en: '![](img/4f57ea89-3a05-4cc4-841f-72f8095a8bf3.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f57ea89-3a05-4cc4-841f-72f8095a8bf3.png)'
- en: Here, we have written some code that uses the default `ILogger`. We have used
    default methods to invoke the logger; however, there are scenarios where we need
    a customized logger. In the next section, we will discuss how to write middleware
    for a custom logger.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们编写了一些使用默认 `ILogger` 的代码。我们使用了默认方法来调用记录器；然而，在某些场景中，我们需要一个定制的记录器。在下一节中，我们将讨论如何编写用于自定义记录器的中间件。
- en: Intercepting HTTP requests and responses by building our own middleware
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过构建自己的中间件来拦截 HTTP 请求和响应
- en: 'In this section, we will create our own middleware for our existing application.
    In this middleware, we will log all requests and responses. Let''s go through
    the following steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为现有应用程序创建自己的中间件。在这个中间件中，我们将记录所有请求和响应。让我们按以下步骤进行：
- en: Open Visual Studio.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio。
- en: 'Open an existing project of the Product APIs by clicking File | Open | Project/Solution (or
    pressing *Ctrl* + *Shift* + *O*), as shown in the following screenshot:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击文件 | 打开 | 项目/解决方案（或按 *Ctrl* + *Shift* + *O*）打开 Product APIs 的现有项目，如图以下截图所示：
- en: '![](img/c7d1d3df-b9e8-4033-b1ef-d18001ade638.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7d1d3df-b9e8-4033-b1ef-d18001ade638.png)'
- en: 'Locate your solution folder and click Open, as shown in the following screenshot:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到您的解决方案文件夹并单击打开，如图以下截图所示：
- en: '![](img/61661159-326b-4c8a-81da-d7b943efb169.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61661159-326b-4c8a-81da-d7b943efb169.png)'
- en: 'Open the solution explorer, add a new folder, and name it `Middleware` by right-clicking
    on the project name, as shown in the following screenshot:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开解决方案资源管理器，通过右键单击项目名称添加一个新文件夹，并将其命名为 `Middleware`，如图以下截图所示：
- en: '![](img/01dd79d4-1500-4331-a7e8-5935fb70d39d.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01dd79d4-1500-4331-a7e8-5935fb70d39d.png)'
- en: Right-click on the `Middleware` folder and select Add | New Item.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `Middleware` 文件夹并选择添加 | 新项。
- en: 'From the web templates, select the Middleware Class and name the new file `FlixOneStoreLoggerMiddleware`.
    Then, click Add, as shown in the following screenshot:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从网络模板中，选择中间件类并将新文件命名为 `FlixOneStoreLoggerMiddleware`。然后单击添加，如图以下截图所示：
- en: '![](img/bbc65dd4-b76a-4fd4-9cee-0f5b13150f20.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbc65dd4-b76a-4fd4-9cee-0f5b13150f20.png)'
- en: 'Your folder hierarchy should be like the one shown in the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您的文件夹层次结构应类似于以下截图所示：
- en: '![](img/da2e2fcb-191b-4c64-91ae-cf6b04d6f02d.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da2e2fcb-191b-4c64-91ae-cf6b04d6f02d.png)'
- en: Thanks to Justin Williams who provided a solution for POST resources; his solution
    is available at [https://github.com/JustinJohnWilliams/RequestLogging](https://github.com/JustinJohnWilliams/RequestLogging).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢Justin Williams提供的POST资源的解决方案；他的解决方案可在[https://github.com/JustinJohnWilliams/RequestLogging](https://github.com/JustinJohnWilliams/RequestLogging)找到。
- en: 'Look at the following code snippet of our `FlixOneStoreLoggerMiddleware` class:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下我们的`FlixOneStoreLoggerMiddleware`类的代码片段：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we are simply taking advantage of the inbuilt DI using
    the `RequestDelegate` to create our custom middleware.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只是利用内置的DI通过`RequestDelegate`来创建我们的自定义中间件。
- en: 'The following code shows us how we should be wiring up all requests and responses
    for the log:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我们如何为日志配置所有请求和响应：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Refer to the *Request delegate* section in this chapter, where we looked at
    middleware. In the preceding code, we are simply logging the request and response
    with the help of the `ILogger` generic type. The `await _next(httpContext);` line
    continues with the request pipeline.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的“*请求委托*”部分，其中我们探讨了中间件。在前面的代码中，我们只是通过`ILogger`泛型类型帮助记录请求和响应。`await _next(httpContext);`行继续请求管道。
- en: 'Open the `Setup.cs` file and add the following code in the `Configure` method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Setup.cs`文件，并在`Configure`方法中添加以下代码：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, we take advantage of  `ILoggerFactory` and add `Console`
    and `Debug` to log the requests and responses. The `UseFlixOneLoggerMiddleware` method
    is actually an extension method. For this, add the following code to the `FlixOneStoreLoggerExtension`
    class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们利用`ILoggerFactory`并添加`Console`和`Debug`来记录请求和响应。`UseFlixOneLoggerMiddleware`方法实际上是一个扩展方法。为此，将以下代码添加到`FlixOneStoreLoggerExtension`类中：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, whenever any request comes to our product APIs, the log should appear,
    as shown in the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当任何请求到达我们的产品API时，日志应该会显示，如下面的截图所示：
- en: '![](img/a7b36f72-6571-4284-860f-f2c2f0ed525b.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7b36f72-6571-4284-860f-f2c2f0ed525b.png)'
- en: In this section, we created a custom middleware and then logged all requests
    and responses.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个自定义中间件，并记录了所有请求和响应。
- en: JSON-RPC for RPC communication
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON-RPC用于RPC通信
- en: JSON-RPC is a stateless, lightweight remote procedure call (RPC) protocol. The
    specification (namely, JSON-RPC 2.0 specifications (see[ http://www.jsonrpc.org/specification ](http://www.jsonrpc.org/specification)for
    more details)) defines various data structures and their processing rules.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-RPC是一个无状态的、轻量级的远程过程调用（RPC）协议。规范（即，JSON-RPC 2.0规范（见[http://www.jsonrpc.org/specification](http://www.jsonrpc.org/specification)获取更多详细信息））定义了各种数据结构和它们的处理规则。
- en: The main objects as per the specifications are shown in the following sections.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 主要对象按规范在以下部分中展示。
- en: Request object
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求对象
- en: 'The `Request` object represents any call/request that is sent to the server.
    The `Request` object has the following members:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Request`对象代表发送到服务器的任何调用/请求。`Request`对象具有以下成员：'
- en: '**jsonrpc**: A string that indicates the version of the JSON-RPC protocol.
    It *must* be accurate (in this case, version 2.0).'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jsonrpc**：一个表示JSON-RPC协议版本的字符串。它**必须**准确（在这种情况下，版本2.0）。'
- en: '**method**: A string that has the name of the method to be adjured. Method
    names that begin with the word `rpc` and are succeeded by a period character (U+002E
    or ASCII 46) are restrained for rpc-internal methods and extensions, and *must
    not* be worn for anything else.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**method**：一个字符串，包含要调用的方法名称。以单词`rpc`开头并后跟一个点字符（U+002E或ASCII 46）的方法名称被限制为rpc-内部方法和扩展，**不得**用于其他任何目的。'
- en: '**params**: A structured value that dominates the parameter values. It is to
    be worn throughout the conjuration of the method. This member *may* be deleted.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**params**：一个结构化值，主导参数值。在整个方法调用过程中都要使用此成员。此成员**可能**被删除。'
- en: '**id**: An identifier fixed by the client that *must* have a string, number,
    or *null* value if constituted.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**id**：客户端固定的一个标识符，如果构成，必须有字符串、数字或**null**值。'
- en: Response object
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应对象
- en: 'As per the specifications, whenever a call is made to the server, there must
    be a response from the server. The `Response` is expressed as a single JSON object
    with the following members:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 根据规范，每当对服务器进行调用时，服务器必须有一个响应。`Response`以一个包含以下成员的单个JSON对象表示：
- en: '**jsonrpc**: A string that is the version of the JSON-RPC protocol'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jsonrpc**：一个表示JSON-RPC协议版本的字符串'
- en: '**result**: A required member, if the request succeeds'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**result**：一个必需的成员，如果请求成功'
- en: '**error**: A required member, if there was an error'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**error**：如果发生错误，一个必需的成员'
- en: '**id**: A required member'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**id**：一个必需的成员'
- en: In this section, we looked at an overview of JSON-RPC specification 2.0.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们概述了JSON-RPC规范2.0。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the integration of external APIs/components regarding
    payment gateways, order tracking, notification services, and so on. We also implemented
    their functionality by using actual code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了与支付网关、订单跟踪、通知服务等相关的外部API/组件的集成。我们还通过实际代码实现了它们的功能。
- en: Testing is the one process that helps us to make our code error free. It is
    also a practice for all developers who want to make their code clean and maintainable.
    In the next chapter, we will cover the testing paradigm in day-to-day development activities.
    We will discuss some important terms associated with the test paradigm. We will
    also cover the theory around these terms, and then we will cover code examples,
    looking at stubs and mocks, and learning about integration, security, and performance
    testing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是我们帮助代码无错误的唯一过程。它也是所有希望使代码整洁和可维护的开发者的实践。在下一章中，我们将涵盖日常开发活动中的测试范式。我们将讨论与测试范式相关的一些重要术语。我们还将涵盖这些术语的理论，然后我们将涵盖代码示例，查看存根和模拟，并了解集成、安全和性能测试。
