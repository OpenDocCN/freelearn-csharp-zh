<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Why Domain-Driven Design?</h1>
                </header>
            
            <article>
                
<p>The software industry appeared back in the early 1960s and has been growing ever since. There have been predictions that one day all software will be written and software developers will no longer be needed, but this prophecy has never become reality, and the growing army of software engineers is working hard to satisfy the continually increasing demand.</p>
<p>However, from the very early days of the industry, the number of projects that were delivered very late and massively over budget, plus the number of failed projects, was overwhelming. The 2015 CHAOS report by the Standish Group (<a href="https://www.projectsmart.co.uk/white-papers/chaos-report.pdf">https://www.projectsmart.co.uk/white-papers/chaos-report.pdf</a>) suggests that from 2011 to 2015, the percentage of successful IT projects remained unchanged at a level of just 22%. Over 19% of projects failed, and the rest experienced challenges. Although the report might set somewhat controversial expectations for project success, it still paints a picture that is familiar to many. These numbers are astonishing. Over four decades, a lot of methods have been developed and advertised as silver bullets for software project management, but there has been <span>little </span>or <span>no </span>change in the number of successful projects.</p>
<p>One of the critical factors that define the success of any IT project is understanding the problem that the system is supposed to solve. We are all very familiar with systems that do not solve the problems they claim to answer or do it very inefficiently. Both the SCRUM and XP software development methodologies embrace interacting with users and understanding their problems.</p>
<p>The term <strong>Domain-Driven Design</strong> (<strong>DDD</strong>) was coined by Eric Evans in his now-iconic book <em>Domain-Driven Design: Tackling Complexity in the Heart of Software</em> published by <span>Addison-Wesley</span> back in 2004. More than a decade after the book was published, interest in the practices and principles described in the book started to grow exponentially. Many factors influenced this growth in popularity, but the most important one is that DDD explains how people from the software industry can build an understanding of their users' needs and create software systems that solve the problem and make an impact.</p>
<p class="mce-root"/>
<p>In this chapter, we will discuss how understanding the business domain, building domain knowledge, and distinguishing essential complexity from accidental complexity can help in creating software that matters.</p>
<p>The objective of this chapter is to explore the following topics:</p>
<ul>
<li>Problem space versus solution space</li>
<li>What went wrong with requirements</li>
<li>Understanding complexity</li>
<li>The role of knowledge in software development</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the problem</h1>
                </header>
            
            <article>
                
<p>We rarely write software to just write some code. Of course, we can create a pet project for fun and to learn new technologies, but professionally we build software to help other people to do their work better, faster, and more efficiently. Otherwise, there is no point in writing any software in the first place. It<span> means that we need to have a </span><em>problem</em> that<span> we intend to solve. Cognitive psychology defines the issue as a restriction between the current state and the desired state.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Problem space and solution space</h1>
                </header>
            
            <article>
                
<p>In their book <em>Human Problem Solving</em>, Allen Newell and Herbert Simon outlined the problem space theory. The theory states that humans solve problems by searching for a solution in the <em>problem space</em>. The problem space describes the initial and desired states, as well as possible intermediate states. It can also contain specific constraints and rules that define the context of the problem. In the software industry, people operating in the problem space are usually customers and users.</p>
<p>Each real problem demands a solution, and if we search properly in the problem space, we can outline which steps we need to take to move from the initial state to the desired state. This outline and all the details about the solution form a <em>solution space</em>.</p>
<p>The classic story of problem and solution spaces, which get completely detached from each other during the implementation, is the story of writing in space. The story goes that in the 1960s, space-exploring nations realized that the usual ballpoint pens wouldn't work in space due to the lack of gravity. NASA then spent a million dollars to develop a pen that would work in space, and the Soviets decided to use the good old pencil, which costs almost nothing. </p>
<p class="mce-root"/>
<p><span>This story is so compelling that it is still circulating, and was even used in the TV show <em>The West Wing</em>, with Martin Sheen playing the US president. </span>It is so easy to believe, not only because we are used to wasteful spending by government-funded bodies, but mostly because we have seen so many examples of inefficiency and misinterpretation of real-world issues, adding enormous unnecessary complexity to their proposed solutions and solving problems that don't exist. </p>
<p><span>This story is a myth. NASA also tried using pencils but decided to get rid of them due to the production of microdust, tips breaking, and the potential flammability of wooden pencils. A private company called </span><span>Fisher developed what is now known as a <strong>space pen</strong>. Later, NASA tested the pen and decided to use it. The company also got an order from the Soviet Union, and pens were sold across the world. The price was the same for everyone, </span><span>$2.39 per pen.</span></p>
<p>Here you can see the other part of the problem space/solution space issue. Although the problem itself appeared to be simple, additional constraints, which we could also call <strong>non-functional requirements</strong>, or, to be more precise, operational requirements, made it more complicated than it looked at first glance.</p>
<p>Jumping to a solution is very easy, and since most of us have a rather rich experience of solving everyday problems, we can find solutions for many issues almost immediately. However, as Bart Barthelemy and Candace Dalmagne-Rouge suggest in their article <span><em>When You're Innovating, Resist Looking for Solutions</em> (2013, </span>Harvard Business Review <a href="https://hbr.org/2013/09/when-youre-innovating-resist-l">https://hbr.org/2013/09/when-youre-innovating-resist-l</a>), thinking about solutions prevents our brain from thinking about the problem. Instead, we start going deeper into the solution that first came to our mind, adding more levels of detail and making it the most ideal solution for a given problem.</p>
<p class="mce-root"/>
<p>There's one more aspect to consider when searching for a solution to a given problem. There is a danger of fixating all your attention on one particular solution, which might <span>not </span>be the best one at all but it was the <span>first to </span>come to mind, based on your previous experiences, your current understanding of the problem, and other factors<span><span>:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/90640ede-7ad8-4720-9d4a-cc36d21d2a30.png" style="width:46.67em;height:24.42em;"/></p>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Refinement versus exploration</div>
<p>The exploratory approach to find and choose solutions involves quite a lot of work to try out a few different things, instead of concentrating on the iterative improvement of the original <em>good idea</em>. However, the answer that is found during this type of exploration will most probably be much more precise and valuable. We will discuss fixation on the first possible solution later in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What went wrong with requirements</h1>
                </header>
            
            <article>
                
<p>We are all familiar with the idea of requirements for software. Developers rarely have direct contact with whoever wants to solve a problem. Usually, some dedicated people, such as requirements analysts, business analysts, or product managers, talk to customers and generalize the outcomes of these conversations in the form of functional requirements.</p>
<p class="mce-root"/>
<p>Requirements can have different forms, from large documents called a <strong>requirements specification</strong> to more <strong>agile</strong> means such as user stories. Let's have a look at this example:</p>
<div class="packt_quote">"Every day, the system shall generate, for each hotel, a list of guests expected to check in and check out on that day."</div>
<p>As you can see, this statement only describes the solution. We cannot possibly know what the user is doing and what problem our system will be solving. Additional requirements might be specified, further refining the solution, but a <span>description of the </span>problem is never included in functional requirements.</p>
<p>In contrast, with user stories, we have more insight into what our user wants. Let's review this real-life user story: <q>"<span>As a warehouse manager, </span><span>I need to be able to print a stock-level report s</span></q><span><q>o that I can order items when they are out of stock."</q> </span>In this case, we have an insight into what our user wants. However, this user story already dictates what the developers need to do. It is describing the <em>solution</em>. The real problem is probably that the customer needs a more efficient procurement process, so they never run out of stock. Or, they need an advanced purchase forecasting system, so they can improve throughput without stockpiling additional inventory in their warehouse.</p>
<p>We should not think that the requirements are a waste of time. There are many excellent analysts out there who produce high-quality requirements specifications. However, it is vital to understand that these requirements almost always represent the understanding of the actual problem from the point of view of the person who wrote them. A misconception that spending more and more time and money on writing higher-quality requirements prevails in the industry.</p>
<p>However, lean and agile methodologies embrace more direct communication between developers and end users. Understanding the problem by all stakeholders, from <span>end users to developers and testers</span>, finding solutions together, eliminating assumptions, building prototypes for end users to evaluate—all <span>these things are being adopted by successful teams, and as we will see later in the book, they are also closely related to DDD.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dealing with complexity</h1>
                </header>
            
            <article>
                
<p><span>Before writing about complexity, I tried to find some fancy, striking definition of the word itself, but it appeared to be a complex task on its own. Merriam-Webster defines the word <strong>complexity</strong> as the quality or state of being complex and this definition is rather obvious and might even sound silly. Therefore, we need to dive a bit deeper into this subject and understand more about complexity.</span></p>
<p>In software, the idea of complexity is not much different from the real world. Most software is written to deal with real-world problems. Those problems might sound simple but be intrinsically complex, or even wicked. Without a doubt, the problem space complexity will be reflected in the software that tries to solve such a problem. Realizing what kind of complexity we are dealing with when creating software thus becomes very important.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types of complexity</h1>
                </header>
            
            <article>
                
<p>In 1986, the Turing Award winner Fred Brooks wrote a paper called <em>No Silver Bullet – Essence and Accident in Software Engineering</em> in which he made a distinction between two types of complexity—essential and accidental complexity. <span><span>Essential </span></span>complexity comes from the domain, from the problem itself, and it cannot be removed without decreasing the scope of the problem. In contrast, accidental complexity is brought to the solution by the solution itself—this could be a framework, a database, or some other infrastructure, with different kinds of optimization and integration.</p>
<p>Brooks argued that the <span>level of </span>accidental complexity decreased substantially when the software industry became more mature. High-level programming languages and efficient tooling give programmers more time to work on business problems. However, as we can see today, more than 30 years later, the industry still struggles to fight accidental complexity. Indeed, we have power tools in our hands, but most of those tools come with the cost of spending the time to learn the tool itself. New JavaScript frameworks appear every year and each of them is different, so before writing anything useful, we need to learn how to be efficient when using the framework of choice. I wrote some JavaScript code many years ago and I saw Angular as a blessing until I realized that I spend more time fighting with it than writing anything meaningful. Or take an example of containers that promised us to bring an easy way to host our applications in isolation, without all that hassle with physical or virtual machines. But then we needed an orchestrator, and we got quite a few, spent time learning to work with them until we got Kubernetes to rule them all and now we spend more time writing YAML files than actual code. We will discuss some possible reasons for this phenomenon in the next section.</p>
<p>You probably noticed that essential complexity has a strong relation to the problem space, and accidental complexity leans towards the solution space. However, we often seem to get problem statements that are more complex than the problems themselves. Usually, this happens due to problems being mixed with solutions, as we discussed earlier, or due to a lack of understanding.</p>
<p>Gojko Adžić, a software delivery consultant and the author of several influential books, such as <em>Specification by Example</em> and <em>Impact Mapping</em>, gives this example in his workshop:</p>
<div class="packt_quote">"A software-as-a-service company got a feature request to provide a particular report in real time, which previously was executed once a month on schedule. After a few months of development, salespeople tried to get an estimated delivery date. The development department then reported that the feature would take at least six more months to deliver and the total cost would be around £1 million. It was because the data source for this report is in a transactional database and running it in real time would mean significant performance degradation, so additional measures such as data replication, geographical distribution, and sharding were required.<br/>
<br/>
The company then decided to analyze the actual need that the customer who requested this feature had. It turned out that the customer wanted to perform the same operations as they were doing before, but instead of doing it monthly, they wanted it weekly. When asked about the desired outcome of the whole feature, the customer then said that running the same report batched once a week would solve the problem. Rescheduling the database job was by far an easier operation that redesigning the whole system, while the impact for the end customer was the same."</div>
<p>This example clearly shows that not understanding the problem can lead to severe consequences. We as developers love principles like DRY. We seek abstraction that will make our code more elegant and concise. However, often that might be entirely unnecessary. Sometimes we fall to the trap of using some tool or framework that promises to solve all issues in the world, easily. Again, that never comes without a cost. As a .NET developer, I can clearly see this when I look at the current obsession with dependency injection among the community.</p>
<p>True enough, Microsoft finally made a DI container that makes sense, but when I see it being used in a small console app just to initialize the logger, I get upset. Sometimes, more code is being written just to satisfy the tool, the framework, the environment, than the code that delivers the actual value. What seemed to be the essential complexity in this example turned out to be a waste:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4edbbd50-d156-407f-9e34-f2c75763bf53.png" style="width:45.33em;height:25.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Complexity growth over time</span></div>
<p>The preceding graph shows that with the ever-growing complexity of the system, the essential complexity is being pushed down and the accidental complexity takes over. You might have doubts about the fact that accidental complexity keeps growing over time when the desired functionality almost flatters out. How could this happen, definitely we can't spend time only creating more accidental complexity? When systems become more prominent, a lot of effort is required to make the system work as a whole and to manage large data models, which large systems tend to have. Supportive code grows and a lot of effort is being spent to keep the system running. We bring cache, optimize queries, split and merge databases, the list goes on. In the end, we might actually decide to reduce the scope of the desired functionality just to keep the system running without too many glitches.</p>
<p>DDD helps you focus on solving complex domain problems and concentrates on the essential complexity. For sure, dealing with a new fancy front-end tool or use a cloud document database is fun. But without understanding what problem are we trying to solve, it all might be just waste. It is much more valuable to any business to get something useful first and try it out than getting a perfect piece of state-of-the-art software that misses the point entirely. To do this, DDD offers several useful techniques for managing complexity by splitting the system into smaller parts and making these parts focus on solving a set of related problems. These techniques are described later in this book.</p>
<p><span>The rule of thumb when dealing with complexity is—embrace essential, or as we might call it, domain complexity, and eliminate or decrease the accidental complexity. </span>Your goal as a developer is not to create too much accidental complexity. Hence, very often, accidental complexity is caused by over-engineering.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Categorizing complexity</h1>
                </header>
            
            <article>
                
<p>When dealing with problems, we don't always know whether these problems are complex. And if they are complex, how complex? Is there a tool for measuring complexity? If there is, it would be beneficial to measure, or at least categorize, the problem's complexity before starting to solve it. Such measurement would help to regulate the solution's complexity as well, since complex problems also demand a complex solution, with rare exceptions to this rule. If you disagree, we will be getting deeper into this topic in the following section.</p>
<p>In 2007, Dave Snowden and Mary Boone published a paper called <em>A Leader's Framework for Decision Making</em> in Harvard Business Review, 2007. This paper won the <strong>Outstanding Practitioner-Oriented Publication in OB</strong> award from the Academy of Management's Organizational Behavior division. What is so unique about it, and which framework does it describe?</p>
<p>The framework is <strong>Cynefin</strong>. This word is Welsh for something like <em>habitat,</em> accustomed<span>,</span> familiar. Snowden started to work on it back in 1999 when he worked at IBM. The work was so valuable that <span>IBM established the Cynefin Center for Organizational Complexity, and Dave Snowden was its founder and director.</span></p>
<p>Cynefin divides all problems into five categories or complexity domains. By describing the properties of problems that fall into each domain, it provides a <em>sense of place</em> for any given problem. After the problem is categorized into one of the domains, Cynefin then also offers some practical approaches to deal with this kind of problem:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7e44da0f-9740-40d0-b0b5-a7a00073bb80.png" style="width:14.33em;height:13.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Cynefin framework, image by Dave Snowden</span></div>
<p>These five realms have specific characteristics, and the framework provides attributes for both, identifying to which domain your problem belongs, and how the problem needs to be addressed.</p>
<p><strong>The first domain is Simple, or Obvious</strong>. Here, you have problems that can be described as <em>known knowns</em>, where best practices and an established set of rules are available, and there is a direct link between a cause and a consequence. The sequence of actions for this domain is <em>sense-categorize-response</em>. Establish facts (sense), identify processes and rules (categorize), and execute them (response).</p>
<p>Snowden, however, warns about the tendency for people to wrongly classify problems as <em>simple</em>. He identifies three cases for this:</p>
<ul>
<li><strong>Oversimplification</strong>: This correlates with some of the cognitive biases described in the following section.</li>
<li><strong>Entrained</strong> <strong>thinking</strong>: When people blindly use the skills and experiences they have obtained in the past and therefore become blinded to new ways of thinking.</li>
<li><strong>Complacency</strong>: When things go well, people tend to relax and overestimate their ability to react to the changing world. The danger of this case is that when a problem is classified as simple, it can quickly escalate to the chaotic domain due to a failure to adequately assess the risks. Notice the <em>shortcut</em> from Simple to Chaotic domain at the bottom of the diagram, which is often being missed by those who study the framework.</li>
</ul>
<p>For this book, it is important to remember two main things:</p>
<ul>
<li>If you identify the problem as obvious, you probably don't want to set up a complex solution and perhaps would even consider buying some off-the-shelf software to solve the problem, if any software is required at all.</li>
<li>Beware, however, of wrongly classifying more complex problems in this domain to avoid applying the wrong best practices instead of doing more thorough exploration and research.</li>
</ul>
<p><strong>The second domain is Complicated</strong>. Here, you find problems that <span>require </span>expertise and skill to find the relation between cause and effect, since there is no single answer to these problems. These are <em>known unknowns</em>. The sequence of actions in this realm is <em>sense-analyze-respond</em>. As we can see, <em>analyze</em> replaces <em>categorize</em> because there is no clear categorization of facts in this domain. Proper analysis needs to be done to identify which good practice to apply. Categorization can be done here too, but you need to go through more choices and analyze the consequences as well. That is where previous experience is necessary. Engineering problems are typically in this category, where a clearly understood problem requires a sophisticated technical solution.</p>
<p>In this realm, assigning qualified people to do some design up front and then perform the implementation makes perfect sense. When a thorough analysis is done, the risk of implementation failure is low. Here, it makes sense to apply DDD patterns for both strategic and tactical design, and to the implementation, but you <span>could </span>probably avoid more advanced exploratory techniques such as EventStorming. Also, you might spend less time on knowledge crunching, if the problem is thoroughly understood.</p>
<p><strong>Complex is the third complexity domain in Cynefin.</strong> Here, we encounter something that no one has done before. Making even a rough estimate is impossible. It is hard or impossible to predict the reaction to our action, and we can only find out about the impact that we have made in retrospect. The sequence of actions in this domain is <em>probe-sense-respond</em>. There are no right answers here and no practices to rely upon. Previous experience won't help either. These are <em>unknown unknowns</em>, and this is the place where all innovation happens. Here, we find our core domain, the concept, which we will get to later in the book.</p>
<p>The course of action for the complex realm is led by experiments and prototypes. There is very little sense in creating a big design up front since we have no idea how it will work and how the world will react to what we are doing. Work here needs to be done in small iterations with continuous and intensive feedback.</p>
<p>Advanced modeling and implementation techniques that are lean enough to respond to changes quickly are the perfect fit in this context. In particular, modeling using EventStorming and implementation using event-sourcing are very much at home in the complex domain. A thorough strategic design is necessary, but some tactical patterns of DDD can be safely ignored when doing spikes and prototypes, to save time. However, again, event-sourcing could be your best friend. Both EventStorming and event-sourcing are described later in the book.</p>
<p><strong>The fourth domain is Chaotic.</strong> This is where hellfire burns and the Earth spins faster than it should. No one wants to be here. Appropriate actions here are <em>act-sense-respond</em>, since there is no time for spikes. It is probably not the best place for DDD since there is no time or budget for any sort of design available at this stage. </p>
<p><strong>Disorder is the fifth and final realm</strong>, right in the middle. The reason for it is that when being at this stage, it is unclear which complexity context applies to the situation. The only way out from disorder is to try breaking the problem into smaller pieces that can be then categorized into those four complexity contexts and then deal with them accordingly.</p>
<p>This is only a brief overview of the categorization of complexity. There is more to it, and I hope your mind gets curious to see examples, videos, and articles about the topic. That was the exact reason for me to bring it in, so please feel free to stop reading now and explore the complexity topic some more. For this book the most important outcome is that DDD can be applied almost everywhere, but it is <span>of </span>virtually no use in obvious and chaotic domains. Using EventStorming as a design technique in complex systems would be useful for both complicated and complex domains, along with event-sourcing, which suits complex domains best. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decision making and biases</h1>
                </header>
            
            <article>
                
<p>The human brain processes a tremendous amount of information every single second. We do many things on autopilot, driven by instinct and habit. Most of our daily routines are like this. Other areas of brain activity are thinking, learning, and decision-making. Such actions are performed significantly more slowly and require much more power than the automatic operations.</p>
<p>Dual process theory in psychology suggests that these types of brain activity are indeed entirely different and there are two different processes for two kinds of thinking. One is the implicit, automatic, unconscious process, and the other one is an explicit conscious process. Unconscious processes are formed over a long time and are also very hard to change because changing such a process would require developing a new habit, and this is not an easy task. Conscious processes, however, can be altered through logical reasoning and education.</p>
<p>These processes, or systems, happily co-exist in one brain but are rather different in the way they operate. Keith Stanovich and Richard West coined the names implicit system, or <strong>System 1</strong> and explicit system, or <strong>System 2</strong> (<span><em>Individual difference in reasoning: implications for the rationality debate</em>? Behavioral and Brain Sciences 2000)</span>. Daniel Kahneman, in his award-winning book <em>Thinking Fast and Slow</em> (<span>New York: Farrar, Straus and Giroux, 2011</span>), assigned several attributes to each system:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f5e16b6f-2a5d-41ac-8343-cc0e7e14df7d.png" style="width:35.42em;height:20.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>System 1 and System 2</span></div>
<p>What does all this have to do with DDD? Well, the point here is more about how we make decisions. It is scientifically proven that all humans are biased, one way or another. As developers, we have our own ways of solving technical problems and of course we're ready to pick up the fight when being challenged by the business about the way we write software to solve their problems. At the other hand, our customers are also biased towards their ways, they probably already were earning money without our software or, they might have some other system created twenty years ago by ancient Cobol programmers and it somehow works, so they just want a <em>modern</em> or even <em>cloud-based</em> version of the same thing. The point I am trying to make here is that we should strive to mitigate our biases and be more open to what other people say and still not fall into a trap of their own biases. It was not without a reason for Google People Operations team to create the <em>Unconscious Bias @ Work</em> workshop to help their colleagues to become aware of their biases and show some methods to deal with them. </p>
<p>The Cynefin complexity model requires us <span>to </span>at least categorize the complexity we are dealing with in our problem space (and also sometimes in the solution space). But to assign the right category, we need to make a lot of decisions, and here we often get our System 1 responding and making assumptions based on our biases and experiences from the past, rather than engaging System 2 to start reasoning and thinking. Of course, every one of us is familiar with a colleague exclaiming <em>yeah, that's easy!</em> before you can even finish describing the problem. We also often see people organizing endless meetings and conference calls to discuss something that we assume to be a straightforward decision to make.</p>
<p>Cognitive biases are playing a crucial role here. Some biases can profoundly influence decision-making, and this is definitely System 1 speaking. Here are some of the biases and heuristics that can affect your thinking about system design:</p>
<ul>
<li><strong>Choice-supportive bias<em>:</em></strong> If you have chosen something, you will be positive about this choice even though it might have been proven to contain significant flaws. Typically, this happens when we come up with the first model and try to stick to it at all costs, even if it becomes evident that the model is not optimal and needs to be changed. Also, this bias can be observed when you choose a technology to use, such as a database or a framework.</li>
<li><strong>Confirmation bias</strong>: Very similar to the previous one, confirmation bias makes you only hear <span>arguments</span> <span>that support your choice or position and ignore arguments that contradict the arguments that support your choice, although these arguments may show that your opinion is wrong.</span></li>
<li><strong>Band-wagon effect</strong>: When the majority of people in the room agree on something, this <em>something</em> begins to make more sense to the minority that previously disagreed. Without engaging System 2, the opinion of the majority gets more credit without any objective reason. Remember that what the majority decides is not the best choice by default!</li>
<li><strong>Overconfidence</strong>: Too often, people tend to be too optimistic about their abilities. This bias might cause them to take more significant risks and make the wrong decisions that have no objective grounds but are based exclusively on their opinion. The most obvious example of this is the estimation process. People invariably underestimate rather than overestimate the time and effort they are going to spend on a problem.</li>
<li><strong>Availability heuristic</strong>: The information we have is not always all the information that we can get about a particular problem. People tend to base their decisions only on the information in hand, without even trying to get more details. This often leads to an over-simplification of the domain problem and an underestimation of the essential complexity. This heuristic can also trick us when we make technological decisions and choose something that has <em>always worked</em> without analyzing the operational requirements, which might be much higher than our technology can handle.</li>
</ul>
<p>The importance of knowing how our decision-making process works is hard to overestimate. The books referenced in this section contain much more information about human behavior and different factors that can have a negative impact on our cognitive abilities. We need to remember to turn on System 2 in order to make better decisions that are not based on emotions and biases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Knowledge</h1>
                </header>
            
            <article>
                
<p>Many junior developers tend to think that software development is just typing code, and when they become more experienced in typing, get to know more IDE shortcuts, and know frameworks and libraries by heart, they will be ninja developers, able to write something like Instagram in a couple of days.</p>
<p>Well, the reality is harshly different. In fact, after getting some experience and after deliberately spending months and maybe years in death-marches towards impossible deadlines and unrealistic goals, people usually slow down. They begin to understand that writing code immediately after receiving a specification might not be the best idea. The reason for this might <span>already </span>be apparent to you if you have read all the previous sections. Being obsessed with solutions instead of understanding the problem, ignoring essential complexity and conforming to biases—all these factors influence us when we are developing software. As soon as we get more experience and learn from our own mistakes and, preferably, from the errors of others, we will realize that the most crucial part of writing useful, valuable software is the knowledge about the problem space, for which we are building a solution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Domain knowledge</h1>
                </header>
            
            <article>
                
<p><span>Not all knowledge is equally useful when building a software system. Knowing about writing Java code in the financial domain might not be very beneficial when you start creating an iOS app for real-estate management. Of course, principles such as clean code, DRY, and so on are helpful no matter what programming language you use. But knowledge of one domain might be vastly different from what you need for another domain.</span></p>
<p>That is where we encounter the concept of domain knowledge. Domain knowledge is knowledge about the domain in which you are going to operate with your software. If you are building a trading system, your domain is financial trading, and you need to gain some knowledge about trading to understand what your users are talking about and what they want.</p>
<p>This all comes to getting into the problem space. If you are not able to at least understand the terminology of the problem space, it would be hard (if not impossible) <span>to </span>even speak to your future users. If you lack domain knowledge, the only source of information for you would be the <strong>specification</strong>. When you do have at least some domain knowledge, conversations with your users become more fruitful since you can understand what they are talking about. One of the consequences of this is building trust between the customer and the developer. Such trust is hard to overestimate. A trusted person gets more insight and mistakes are forgiven more easily. By speaking the <em>domain language</em> to <em>domain experts</em> (your users and customers), you also gain credibility, and they see you and your colleagues as more competent people.</p>
<p>Obtaining domain knowledge is not an easy task. People specialize in their domains for years, they become experts in their domains, and they do this kind of work for a living. Software developers and business analysts do something else, and that particular problem domain might be little known or completely unknown when they need to obtain domain knowledge.</p>
<p>The art of obtaining domain knowledge is through effective collaboration. Domain experts are the source of ultimate truth (at least, we want to treat them like this). However, they might not be. Some organizations have <span>fragmented </span>knowledge; some might just be wrong. Knowledge crunching in such environments is even harder, but there might be bits and pieces of information waiting to be found at the desks of some low-level clerks, and your task is to see it.</p>
<p class="mce-root"/>
<p>The general advice here is to talk to many different people from inside the domain, from the management of the whole organization, and from adjacent domains. There are several ways to obtain domain knowledge, and here are some of them:</p>
<ul>
<li>Conversations are the most popular method, formalized as meetings. However, conversations often turn into a mess without any visible outcome. Still, some value is there, but you need to listen carefully and ask many questions to get valuable information.</li>
<li>Observation is a very powerful technique. Software people need to fight their introversion, leave the ivory tower and go to a trading floor, to a warehouse, to a hotel, to a place where business runs, and then talk to people and see how they work. Jeff Patton gave many good examples in his talk at the DDD Exchange 2017 (<a href="https://skillsmatter.com/skillscasts/10127-empathy-driven-design"><span>https://skillsmatter.com/skillscasts/10127-empathy-driven-design</span></a>).</li>
<li>Domain Storytelling, a technique proposed by Stefan Hofer and his colleagues from Hamburg University (<a href="http://domainstorytelling.org/">http://domainstorytelling.org/</a>), advocates using pictograms, arrows, and a little bit of text, plus numbering actions sequentially, to describe different interactions inside the domain. This technique is easy to use, and typically there is not much to explain to people participating in such a workshop before they start using it to deliver the knowledge.</li>
<li>EventStorming was invented by Alberto Brandolini. He explains the method in his book <em>Introducing EventStorming</em> (2017, Leanpub), and we will also go into more detail later in this book when we start analyzing our sample domain. EventStorming uses post-it notes and a paper roll to model all kinds of activities in a straightforward fashion. Workshop participants write facts from the past (events) on post-its and put them on the wall, trying to make a timeline. It allows the discovery of activities, workflows, business processes, and more. Very often, it also uncovers ambiguities, assumptions, implicit terminology, confusion, and sometimes conflicts and anger. In short—everything that the domain knowledge consists of.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Avoiding ignorance</h1>
                </header>
            
            <article>
                
<p>Back in 2000, Philip Armour published an article called <em>Five Orders of Ignorance </em>(<span>Communications of the ACM, Volume 43 Issue 10, Oct. 2000</span>), with the subtitle <em>Viewing software development as knowledge acquisition and ignorance reduction</em>. This message very much correlates with Alberto's quote from the previous section, although it is somewhat less catchy but by no means less powerful. The article argues that increasing domain knowledge and decreasing ignorance are two keys to creating software that delivers value.</p>
<p>The article concentrates on ignorance and identifies five levels of it:</p>
<ul>
<li>The zero ignorance level, which authors call <em>the lack of ignorance</em>, is the lowest. On this level, you have no ignorance because you have most of the knowledge and know what to do and how to do it.</li>
<li>The first level is the <em>lack of knowledge</em>. It is when you don't know something, but you realize and accept this fact. You want to get more knowledge and decrease your ignorance to level zero, so you have channels to obtain the knowledge.</li>
<li>The second level also called the <em>lack of awareness</em>, is when you don't know that you don't know. Most commonly, this occurs when you get a specification that describes a solution without specifying which problem this solution is trying to solve. This level can also be observed when people pretend to have competence they do not possess, and at the same time are ignorant of it. Such people might be lacking both business and technical knowledge. A lot of wrong decisions are made at this level of ignorance.</li>
<li>The third level is the <em>lack of process</em>. On this level, you don't even know how to find out about your lack of awareness. Literally, you don't have a way to figure out you don't know that you don't know, which sounds like inception, but that's exactly what it is. It is tough to do anything on this level since apparently there is no way to access end users, even to ask if you understand their problem or not, in order to get down to level two. Essentially, with the lack of process, it is nearly impossible to find out if the problem you're trying to solve even exists. Building a system might be the only choice in this case, since it will be the only way to get any feedback.</li>
<li>The fourth and last level of ignorance is meta-ignorance. It is when you don't know about the five degrees of ignorance.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As you can see, ignorance is the opposite of knowledge. The only way to decrease ignorance is to increase understanding. A high level of ignorance, conscious or subconscious, leads to a lack of knowledge and a misinterpretation of the problem, and therefore increases the chance of building the wrong solution:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/67b944a5-c0c1-4671-80c7-0f710d47005e.png" style="width:53.75em;height:30.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Ignorance is highest at the earliest stages</span></div>
<p>Eric Evans, the father of DDD, describes the upfront design as <em>locking in our ignorance</em>. The issue with the upfront design is that we do it at the beginning of a project, and this is when we have the least knowledge and the most ignorance. It has become the norm to make most of the important decisions about the design and architecture of the software at the very beginning of a project when there is virtually nothing to base such decisions on. This practice is quite obviously not optimal.</p>
<p>In the article <em>Introducing Deliberate Discovery</em> (<a href="https://dannorth.net/2010/08/30/introducing-deliberate-discovery/">https://dannorth.net/2010/08/30/introducing-deliberate-discovery/</a>), Dan North suggests that we realize our position of being on at least the second level of ignorance when we start any project. In particular, the following three risks need to be taken into account:</p>
<ul>
<li>A few <em>unpredictable bad things</em> will happen during the project.</li>
<li><em>Being unpredictable</em>, these <em>things</em> are unknown in advance.</li>
<li><em>Being bad</em>, these <em>things</em> will negatively impact the project.</li>
</ul>
<p>To mitigate these risks, Dan recommends using <em>INTRODUCING DELIBERATE DISCOVERY</em>, that is, seeking knowledge from the start. Since not all knowledge is equally important, we need to try to identify those sensitive areas where ignorance is creating the most impediments. By raising knowledge levels in these areas, we enable progress. At the same time, we need to keep an eye on new troublesome areas and resolve them too; and this process is continuous and iterative.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we briefly touched on the concepts of problem and solution spaces, requirements specifications, complexity, knowledge, and ignorance. Although at first, these topics don't seem to be directly related to software development, they have a significant impact on how and what we deliver.</p>
<p>Don't fall into the trap of thinking that you can deliver valuable solutions to your customers just by writing code and that you can deliver faster and better by typing more characters per second and writing cleaner code. Customers do not care about your code or how fast you type. They only care that your software solves their problems in a way that hasn't been done before. As Gojko <span>Adžić</span> wrote in his sweet little book about impact mapping (<span><em>Impact Mapping: Making a Big Impact With Software Products and Projects,</em> 2012,<em> </em>published by Provoking Thoughts</span>), you cannot only formulate user stories like this:</p>
<ul>
<li>As a <em>someone</em></li>
<li>To <em>do something</em></li>
<li>I need to <em>use some functionality</em></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Your user, <em>someone</em>, might be already doing <em>something</em> by executing <em>some functionality</em> even without your software: using a pen and paper, using Excel, or using a system from one of your competitors. What you need to ensure is that you make a difference, make an impact. Your system will let people work faster, more efficiently, allow them to save money or even not to do this work at all if you completely automate it.</p>
<p>To build such software, you must understand the problems of your users. You need to crunch the domain knowledge, decrease the level of ignorance, accurately classify the problem's complexity, and try to avoid cognitive biases on the way to your goal. This is an essential part of DDD, although not all of these topics are covered in the original <em>Domain-Driven Design: Tackling Complexity in the Heart of Software</em> by Eric Evans, although known by the DDD community as the <em>Blue Book</em>.</p>
<p>In the next chapter, we will do a deep dive into the importance of language and discover the definition of Ubiquitous Language.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>Here is a list of information you can refer to:</p>
<ul>
<li><span><em>A Leader's Framework for Decision Making</em>, Snowden D J, Boone M E. (2007), </span>Harvard Business Review 2007 November issue</li>
<li><span><em>Thinking, Fast and Slow</em> (First edition), Kahneman, Daniel (2011),</span> <span>New York: Farrar, Straus, and Giroux</span></li>
<li><em>Impact Mapping: Making a Big Impact With Software Products and Projects</em>, Adžić, G. (2012), Provoking Thoughts. </li>
</ul>


            </article>

            
        </section>
    </body></html>