<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Changes in Requirements</h1>
                
            
            <article>
                
<p class="calibre2">As progress is made on any application, new and different requirements will likely be added. Sometimes these requirements enhance the existing functionality of the application. At other times, these new requirements may conflict with the existing functionalities. When requirements conflict, it's important that issues are resolved so that the proper functionality can be built.</p>
<p class="calibre2">So, what are the changes in requirements you might expect to see? Changes often consist of alterations to a business rule, new features or enhancements, or modifications needed to resolve a bug or defect discovered in the system.</p>
<p class="calibre2">As time goes on, there will often be a need to modify an existing business rule. This may be in response to user feedback, clarification from the business, or a need discovered through use of the system. When the need for change is discovered, then the existing application will need to change. A comprehensive test suite will ensure that the rest of the system still operates as expected once the new changes are implemented. Start by modifying and/or creating new tests to cover the new desired functionality of the system.</p>
<p class="calibre2">There's a common saying in software development that <em class="calibre12">software is never finished; it is merely abandoned</em>. That is to say that an application will continue to grow and evolve through new development if it is to continue to be useful. If new features aren't being added, then it is likely that the project has simply been abandoned. If an application is to continue to be of use, then you can expect that new features will need to be implemented. Again, start with the tests and add new tests which will help guide your implementation of any and all new features.</p>
<p class="calibre2">When a bug is discovered and the root cause identified, then a change will need to be made to resolve the issue. In order to prevent this bug from appearing again in the future, a new test, or series of tests, should be written to cover any potential scenarios that would result in the erroneous behavior.</p>
<p class="calibre2">In this chapter, we will gain an understanding of:</p>
<ul class="calibre7">
<li class="calibre8">Changing requirements</li>
<li class="calibre8">A new feature</li>
<li class="calibre8">Dealing with defects</li>
<li class="calibre8">Changes to Speaker Meet</li>
<li class="calibre8">Premature optimization</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Hello World</h1>
                
            
            <article>
                
<p class="calibre2">Stepping back to one of our first examples, take a look at the sample <em class="calibre12">Hello World</em> application. Remember that, depending on the time of day, a different message is displayed to the user. Before noon, the user is greeted with <span>Good morning</span>, and after noon, <span>Good afternoon</span> is returned to the user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">A change in requirements</h1>
                
            
            <article>
                
<p class="calibre2">Depending on the time of day, the user is greeted with <span>Good morning</span> or <span>Good afternoon</span>. To extend the functionality and introduce a new feature, let's address the user with <span>Good evening</span> if the time of day is between 6 p.m. and midnight.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Good evening </h1>
                
            
            <article>
                
<p class="calibre2">In order to introduce this new feature, begin with the tests. Modification of an existing test will be needed, as well as adding one or more new tests to cover the change in requirements.</p>
<p class="calibre2">Modify the <kbd class="calibre11">Theory</kbd> data provided to <kbd class="calibre11">GivenAfternoon_ThenAfternoonMessage</kbd> so that only noon through 6 p.m. are included for this test. Now, create a new test method, <kbd class="calibre11">GivenEvening_ThenEveningMessage</kbd>:</p>
<pre class="calibre19">[Theory]<br class="title-page-name"/>[InlineData(19)]<br class="title-page-name"/>[InlineData(20)]<br class="title-page-name"/>[InlineData(21)]<br class="title-page-name"/>[InlineData(22)]<br class="title-page-name"/>[InlineData(23)]<br class="title-page-name"/>public void GivenEvening_ThenEveningMessage(int hour)<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange  <br class="title-page-name"/>  var eveningTime = new TestTimeManager();<br class="title-page-name"/>  eveningTime.SetDateTime(new DateTime(2017, 7, 13, hour, 0, 0));<br class="title-page-name"/>  var messageUtility = new MessageUtility(eveningTime);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var message = messageUtility.GetMessage();<br class="title-page-name"/>  <br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal("Good evening", message);<br class="title-page-name"/>}</pre>
<p class="calibre2">Now make the <kbd class="calibre11">Theory</kbd> pass by modifying the existing code:</p>
<pre class="calibre19">public string GetMessage()<br class="title-page-name"/>{<br class="title-page-name"/>  if (_timeManager.Now.Hour &lt; 12)<br class="title-page-name"/>    return "Good morning";<br class="title-page-name"/>  if (_timeManager.Now.Hour &lt;= 18)<br class="title-page-name"/>    return "Good afternoon";<br class="title-page-name"/>  return "Good evening";<br class="title-page-name"/>}</pre>
<p class="calibre2">This is a fairly simple example, for sure. The implementation is starting to grow a design with which you may or may not be satisfied. Feel free to experiment with alternative implementations. You should now have sufficient tests that you feel safe to refactor to a pattern with which you're happier. If you break the implementation or discover a bug you may have introduced, add a test for this scenario.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">FizzBuzz</h1>
                
            
            <article>
                
<p class="calibre2">Moving on to the FizzBuzz example from <a target="_blank" href="part0069.html#21PMQ0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 2</a>, <em class="calibre12">Setting Up the .NET Test Environment</em>, extend the classic behavior of this code kata and introduce some new behavior.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">A new feature</h1>
                
            
            <article>
                
<p class="calibre2">A new requirement has been added to the classic FizzBuzz kata. The new requirement states that when a number is not divisible by 3 or 5, and is greater than 1, then the message <span>Number not found</span> should be returned. This should be easy enough. Start, once again, with the tests, and make the necessary modifications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Number not found</h1>
                
            
            <article>
                
<p class="calibre2">To get started, a new test method is needed to verify that the <span>Number not found</span> message is returned:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenNonDivisibleGreaterThan1ThenNumberNotFound()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = FizzBuzz(2);<br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal("Number not found", result);<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, make the test pass by modifying the existing code:</p>
<pre class="calibre19">private object FizzBuzz(int value)<br class="title-page-name"/>{<br class="title-page-name"/>  if (value % 15 == 0)<br class="title-page-name"/>    return "FizzBuzz";<br class="title-page-name"/>  if (value % 5 == 0)<br class="title-page-name"/>    return "Buzz";<br class="title-page-name"/>  if (value % 3 == 0)<br class="title-page-name"/>    return "Fizz";<br class="title-page-name"/>  if (value == 2)<br class="title-page-name"/>    return "Number not found";<br class="title-page-name"/>}</pre>
<p class="calibre2">This covers the first instance. However, does this satisfy the new requirement? Create a <kbd class="calibre11">Theory</kbd> set to force the proper solution:</p>
<pre class="calibre19">[Theory]<br class="title-page-name"/>[InlineData(2)]<br class="title-page-name"/>[InlineData(4)]<br class="title-page-name"/>[InlineData(7)]<br class="title-page-name"/>[InlineData(8)]<br class="title-page-name"/>public void GivenNonDivisibleGreaterThan1ThenNumberNotFound(int number)<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = FizzBuzz(number);<br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal("Number not found", result);<br class="title-page-name"/>}</pre>
<p class="calibre2">Make the test pass, the right way. Modify the existing code so that the desired results are returned:</p>
<pre class="calibre19">private object FizzBuzz(int value)<br class="title-page-name"/>{<br class="title-page-name"/>  if (value % 15 == 0)<br class="title-page-name"/>    return "FizzBuzz";<br class="title-page-name"/>  if (value % 5 == 0)<br class="title-page-name"/>    return "Buzz";<br class="title-page-name"/>  if (value % 3 == 0)<br class="title-page-name"/>    return "Fizz";<br class="title-page-name"/>  return value == 1 ? (object)value : "Number not found";<br class="title-page-name"/>}</pre>
<p class="calibre2"> </p>
<p class="calibre2">Note that all the existing tests should continue to pass throughout this exercise. If you find a bug, write a new test to verify the scenario, and correct the code accordingly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">TODO app  </h1>
                
            
            <article>
                
<p class="calibre2">The <em class="calibre12">TODO</em> app was another one of our early TDD examples. This app is far from complete, and we have received new requirements from the business, asking to add a feature to the application.</p>
<p class="calibre2">The business now wants the ability to complete a task in the TODO list. This feature is <em class="calibre12">schedule current sprint</em> and is the next story for us to work on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mark complete</h1>
                
            
            <article>
                
<p class="calibre2">For the <em class="calibre12">Mark complete</em> story, we have been asked to allow the user to complete any of the tasks in the TODO list. Adding this feature should be much like any other TDD exercise in this book. Before reading our solution to this problem, try to complete this one on your own. After you have passing tests, come back and look at the solution in this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding tests</h1>
                
            
            <article>
                
<p class="calibre2">In the <kbd class="calibre11">ToDoApplicationTests</kbd> file, we have added a <kbd class="calibre11">yak shaving</kbd> test to force us to create the complete method. This test also helps to define the API for the method:</p>
<pre class="calibre19">[Fact(Skip = "Yak shaving - no longer needed")]<br class="title-page-name"/>public void CompleteTodoExists()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var todo = new TodoList();<br class="title-page-name"/>  var item = new Todo();<br class="title-page-name"/>  <br class="title-page-name"/>  todo.AddTodo(item);<br class="title-page-name"/>  <br class="title-page-name"/>  // Act<br class="title-page-name"/>  todo.Complete(item);<br class="title-page-name"/>}</pre>
<p class="calibre2">This causes us to create a method stub in the <kbd class="calibre11">TodoList</kbd> class. To get this test to pass, we had to remove the not implemented exception from the generated method. After creating the method, we added a skip to this test, similar to the previous <kbd class="calibre11">yak shaving</kbd> test in the same file.</p>
<p class="calibre2">Next, we needed to create a <kbd class="calibre11">TodoListCompleteTests</kbd> file to house the functionality tests for the complete method:</p>
<pre class="calibre19">public class TodoListCompleteTests<br class="title-page-name"/>{<br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItRemovesAnItemFromTheList()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var todo = new TodoList();<br class="title-page-name"/>    var item = new Todo();<br class="title-page-name"/>    <br class="title-page-name"/>    todo.AddTodo(item);<br class="title-page-name"/>    // Act<br class="title-page-name"/>    todo.Complete(item);<br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.Equal(0, todo.Items.Count());<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">After writing this first test and implementing the code to make it pass, we were hard pressed to write another test that would fail. So, we assume that we are done for now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Production code</h1>
                
            
            <article>
                
<p class="calibre2">The code to make the tests for completing a task is quite simple and only requires a single line method:</p>
<pre class="calibre19">public void Complete(Todo item)<br class="title-page-name"/>{<br class="title-page-name"/>  _items.Remove(item);<br class="title-page-name"/>}</pre>
<p class="calibre2">That is all we need. We are now ready for the sprint demo.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">But don't remove from the list!</h1>
                
            
            <article>
                
<p class="calibre2">During the sprint demo, our product owner asked what happened to the task when it was completed. We explained that it was removed from this list. This was not good. The product owner was hoping that we could provide metrics on tasks further down the road. She would like for us to track the completion of the task instead of deleting it.</p>
<p class="calibre2">After some discussion with the other developers, we have decided the task will gain a completed attribute and be hidden from the list. To accomplish this, we will have to do a bit of refactoring and add new tests. Again, try to complete this exercise on your own and then look at our solution for comparison.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding tests</h1>
                
            
            <article>
                
<p class="calibre2">This change required quite a few new tests. Before we could make new tests, though, we had to first rename our existing completion test to represent the correct functionality. Adding two more tests to the <kbd class="calibre11">TodoListCompleteTests</kbd> file, we verify both that the item is marked complete and that it is not removed from the TODO list:</p>
<pre class="calibre19">public class TodoListCompleteTests<br class="title-page-name"/>{<br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItHidesAnItemFromTheList()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var todo = new TodoList();<br class="title-page-name"/>    var item = new Todo { Description = "Test Todo" };<br class="title-page-name"/>  <br class="title-page-name"/>    todo.AddTodo(item);<br class="title-page-name"/>  <br class="title-page-name"/>    // Act<br class="title-page-name"/>    todo.Complete(item);<br class="title-page-name"/>  <br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.Equal(0, todo.Items.Count());<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItMarksAnItemComplete()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var todo = new TodoList();<br class="title-page-name"/>    var item = new Todo { Description = "Test Todo" };<br class="title-page-name"/>  <br class="title-page-name"/>    todo.AddTodo(item);<br class="title-page-name"/>  <br class="title-page-name"/>    // Act<br class="title-page-name"/>    todo.Complete(item);<br class="title-page-name"/>  <br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.True(item.IsComplete);<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  [Fact]<br class="title-page-name"/>  public void ItShowsCompletedItems()<br class="title-page-name"/>  {<br class="title-page-name"/>    // Arrange<br class="title-page-name"/>    var todo = new TodoList();<br class="title-page-name"/>    var item = new Todo { Description = "Test Todo" };<br class="title-page-name"/>  <br class="title-page-name"/>    todo.ShowCompleted = true;<br class="title-page-name"/>    todo.AddTodo(item);<br class="title-page-name"/>  <br class="title-page-name"/>    // Act<br class="title-page-name"/>    todo.Complete(item);<br class="title-page-name"/>  <br class="title-page-name"/>    // Assert<br class="title-page-name"/>    Assert.Equal(1, todo.Items.Count());<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">In order to add <kbd class="calibre11">ShowComplete</kbd>, we created a <kbd class="calibre11">yak shaving</kbd> test in the <kbd class="calibre11">ToDoApplicationTests</kbd> file for completeness:</p>
<pre class="calibre19">[Fact(Skip = "Yak shaving - no longer needed")]<br class="title-page-name"/>public void ShowCompletedExists()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var todo = new TodoList();<br class="title-page-name"/>  <br class="title-page-name"/>  // Act<br class="title-page-name"/>  todo.ShowCompleted = true;<br class="title-page-name"/>}</pre>
<p class="calibre2">We also had to add a similar test to the <kbd class="calibre11">TodoModelTests</kbd> file:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItHasIsComplete()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var todo = new Todo();<br class="title-page-name"/>  <br class="title-page-name"/>  // Act<br class="title-page-name"/>  todo.IsComplete = true;<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Production code</h1>
                
            
            <article>
                
<p class="calibre2">For such a small code base, the changes required by the new tests caused a fairly significant change. First, we added an <kbd class="calibre11">IsComplete</kbd> property to the <kbd class="calibre11">Todo</kbd> model:</p>
<pre class="calibre19">internal class Todo<br class="title-page-name"/>{<br class="title-page-name"/>  public bool IsComplete { get; set; }<br class="title-page-name"/>  public string Description { get; set; }<br class="title-page-name"/>  <br class="title-page-name"/>  internal void Validate()<br class="title-page-name"/>  {<br class="title-page-name"/>    Description = Description ?? throw new DescriptionRequiredException();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">The rest of the changes affect the <kbd class="calibre11">TodoList</kbd> class. A boolean property was added to toggle the visibility of completed items, the <kbd class="calibre11">Complete</kbd> method was modified to only mark the item as complete, and a <kbd class="calibre11">where</kbd> clause was added to the items retrieved from the list:</p>
<pre class="calibre19">internal class TodoList<br class="title-page-name"/>{<br class="title-page-name"/>  private readonly List&lt;Todo&gt; _items = new List&lt;Todo&gt;();<br class="title-page-name"/>         <br class="title-page-name"/>  public IEnumerable&lt;Todo&gt; Items =&gt; _items.Where(t =&gt; !t.IsComplete || ShowCompleted);<br class="title-page-name"/>  <br class="title-page-name"/>  public bool ShowCompleted { get; set; }<br class="title-page-name"/>  <br class="title-page-name"/>  public void AddTodo(Todo item)<br class="title-page-name"/>  {<br class="title-page-name"/>    item = item ?? throw new ArgumentNullException();<br class="title-page-name"/>    item.Validate();<br class="title-page-name"/>    _items.Add(item);<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public void Complete(Todo item)<br class="title-page-name"/>  {<br class="title-page-name"/>    item.IsComplete = true;            <br class="title-page-name"/>  }        <br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Changes to Speaker Meet</h1>
                
            
            <article>
                
<p class="calibre2">Change is inevitable with any application. Requirements change as a result of a new business rule, feature enhancement, discovery and remediation of a defect, and so on. Change is especially certain when test driving an application. Luckily, through the process of TDD, your application should be easily and safely modifiable.</p>
<p class="calibre2">If a system is loosely coupled, then changes to one part of a system should, in theory, have little to no impact on the rest of the system. A comprehensive suite of unit tests should alleviate the fear of making changes.</p>
<p class="calibre2">Unfortunately, the tests are only valid for the scenarios which they define. If sufficient tests aren't written to cover certain scenarios or edge cases, then it is certainly possible that a bug could find its way into production. If the TDD approach is not taken, or worse, tests aren't written at all, then you may discover that it is quite easy for a bug to make it through all of the checks of your code review process and CI/CD build pipeline.</p>
<p class="calibre2">Take a look at the new requirements for the Speaker Meet application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Changes to the back-end</h1>
                
            
            <article>
                
<p class="calibre2">As the Speaker Meet application progressed, a new requirement was introduced. Speakers had to be <em class="calibre12">approved</em> before they were visible in parts of the system. This included the full listing of speakers, returning of speaker detail information, and through search results.</p>
<p class="calibre2">In this scenario, a developer came in to help out with the implementation. This developer was not familiar with TDD and did not write tests to validate his work. The new requirement was implemented and a code review was submitted:</p>
<pre class="calibre19">public Models.SpeakerDetail Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  var speaker = _repository.Get(id);<br class="title-page-name"/><br class="title-page-name"/>  if (speaker == null || speaker.IsDeleted || speaker.IsActive)<br class="title-page-name"/>  {<br class="title-page-name"/>    throw new SpeakerNotFoundException(id);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  var gravatar = _gravatarService.GetGravatar(speaker.EmailAddress);<br class="title-page-name"/><br class="title-page-name"/>  return new Models.SpeakerDetail<br class="title-page-name"/>  {<br class="title-page-name"/>    Id = speaker.Id,<br class="title-page-name"/>    Name = speaker.Name,<br class="title-page-name"/>    Location = speaker.Location,<br class="title-page-name"/>    Gravatar = gravatar<br class="title-page-name"/>  };<br class="title-page-name"/>}</pre>
<p class="calibre2">And a change to the class was added:</p>
<pre class="calibre19">public class Speaker<br class="title-page-name"/>{<br class="title-page-name"/>  public int Id { get; set; }<br class="title-page-name"/><br class="title-page-name"/>  [Required]<br class="title-page-name"/>  [StringLength(50)]<br class="title-page-name"/>  public string Name { get; set; }<br class="title-page-name"/><br class="title-page-name"/>  [Required]<br class="title-page-name"/>  [StringLength(50)]<br class="title-page-name"/>  public string Location { get; set; }<br class="title-page-name"/><br class="title-page-name"/>  [Required]<br class="title-page-name"/>  [StringLength(255)]<br class="title-page-name"/>  public string EmailAddress { get; set; }<br class="title-page-name"/>  <br class="title-page-name"/>  public bool IsDeleted { get; set; }<br class="title-page-name"/>  <br class="title-page-name"/>  public bool IsActive { get; set; }<br class="title-page-name"/>}</pre>
<p class="calibre2">Can you spot the issue?</p>
<p class="calibre2">The code was reviewed and comments left. However, the comments were misunderstood (or just flatly ignored) and the code was committed, merged, and pushed through the deployment process. A breakdown for sure, but one that happens from time to time.</p>
<p class="calibre2">The CI server ran the test suite. The existing tests passed. The bug was not discovered, as there was no existing scenario that would have caught the error. Since new tests were not created, there was no test failure. The CD process ran and the code made it into production.</p>
<p class="calibre2">So what test can be added to ensure the proper code is implemented? When dealing with bugs, it is often best to simply write the test that verifies the incorrect behavior. In this case, we want an error to be thrown. So, the below test should assert that the correct error is thrown:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenSpeakerIsNotActiveThenSpeakerNotFoundException()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var expectedSpeaker = SpeakerFactory.Create(_fakeRepository);<br class="title-page-name"/>  expectedSpeaker.IsActive = false;<br class="title-page-name"/>  var service = new SpeakerService(_fakeRepository, _fakeGravatarService);<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var exception = Record.Exception(() =&gt; service.Get(expectedSpeaker.Id));<br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;SpeakerNotFoundException&gt;(exception);<br class="title-page-name"/>}</pre>
<p class="calibre2">Make this new test pass by modifying the service:</p>
<pre class="calibre19">public Models.SpeakerDetail Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  var speaker = _repository.Get(id);<br class="title-page-name"/><br class="title-page-name"/>  if (speaker == null || speaker.IsDeleted || !speaker.IsActive)<br class="title-page-name"/>  {<br class="title-page-name"/>    throw new SpeakerNotFoundException(id);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  var gravatar = _gravatarService.GetGravatar(speaker.EmailAddress);<br class="title-page-name"/><br class="title-page-name"/>  return new Models.SpeakerDetail<br class="title-page-name"/>  {<br class="title-page-name"/>    Id = speaker.Id,<br class="title-page-name"/>    Name = speaker.Name,<br class="title-page-name"/>    Location = speaker.Location,<br class="title-page-name"/>    Gravatar = gravatar<br class="title-page-name"/>  };<br class="title-page-name"/>}</pre>
<p class="calibre2">However, with this change, a number of existing tests will now break. This is because the default value for the <kbd class="calibre11">IsActive</kbd> property is <kbd class="calibre11">false</kbd>.</p>
<p class="calibre2">To quickly get these tests to pass, you could do something like:</p>
<pre class="calibre19">public bool IsActive { get; set; } = true;</pre>
<p class="calibre2">This could potentially introduce unexpected results, so be sure to create some guard tests to verify correctness.</p>
<p class="calibre2">This explains why this bug wasn't initially caught. The <kbd class="calibre11">IsActive</kbd> property was added to the database with a default value of <kbd class="calibre11">true</kbd>. The bug wasn't discovered until new speakers were added to the database with a value of <kbd class="calibre11">false</kbd> in the <kbd class="calibre11">IsActive</kbd> column. Once the incorrect behavior was discovered, the defect was easily identified and remedied.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Changes to the front-end </h1>
                
            
            <article>
                
<p class="calibre2">There is no difference, from a concept or approach perspective, for changes to the front-end. You will need to write the appropriate test to ensure the desired behavior from the application and then write the production code to make the test pass.</p>
<p class="calibre2">As a quick example though, let's add a new feature to the front-end code we have been working on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Sorted by rating on client side</h1>
                
            
            <article>
                
<p class="calibre2">The feature we are going to add is sorting the speakers by rating. In previous chapters, rating was not discussed or even enforced, so modifications will need to happen to include rating in the model that has been built so far. That is, of course, if you have not already completed the full model as defined by the C# code.</p>
<p class="calibre2">As with earlier examples in this chapter, try to add this behavior yourself and then look at our following solution .</p>
<p class="calibre2">In the <kbd class="calibre11">speakerReducer.spec.js</kbd> file, we have added a single test for default sorting of speakers by rank. The test can be added to the describe block for the speaker reducer:</p>
<pre class="calibre19">it('sorts speakers by rank', () =&gt; {<br class="title-page-name"/>   // Arrange<br class="title-page-name"/>   const initialState = [];<br class="title-page-name"/>   const speaker1 = { id: 'test-speaker-1', firstName: 'Test 1', lastName: 'Speaker', rank: 1};<br class="title-page-name"/>   const speaker2 = { id: 'test-speaker-2', firstName: 'Test 2', lastName: 'Speaker', rank: 2};<br class="title-page-name"/>   const action = actions.getSpeakersSuccess([speaker1, speaker2]);<br class="title-page-name"/>  <br class="title-page-name"/>   // Act<br class="title-page-name"/>   const newState = speakersReducer(initialState, action);<br class="title-page-name"/>  <br class="title-page-name"/>   // Assert<br class="title-page-name"/>   expect(newState).to.have.lengthOf(2);<br class="title-page-name"/>   expect(newState[0]).to.deep.equal(speaker2);<br class="title-page-name"/> });</pre>
<p class="calibre2">And the code to make this test pass is in the <kbd class="calibre11">speakerReducer.js</kbd> file:</p>
<pre class="calibre19">export function speakersReducer(state = [], action) {<br class="title-page-name"/>   switch(action.type) {<br class="title-page-name"/>     case types.GET_SPEAKERS_SUCCESS:<br class="title-page-name"/>       return action.speakers.sort((a, b) =&gt; {<br class="title-page-name"/>         return b.rank &gt; a.rank;<br class="title-page-name"/>       });<br class="title-page-name"/>     default:<br class="title-page-name"/>       return state;<br class="title-page-name"/>   }<br class="title-page-name"/> }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What now?</h1>
                
            
            <article>
                
<p class="calibre2">Moving forward, it should be easy to implement any change necessary. This might include a new feature, a change in requirements, or a discovered defect. That isn't to say that the application is complete or error-free, but you should have some level of confidence that the application behaves in the ways accounted for with the existing test suite.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Premature optimization</h1>
                
            
            <article>
                
<p class="calibre2">For the purpose of clarification, we are defining optimization as anything that obfuscates the code, making it less clear or more difficult to understand, or anything that limits the possibilities further than the test requires. A premature optimization is an optimization that is done for any reason other than specified by a requirement.</p>
<p class="calibre2">Typically, optimizations are done using performance as an excuse. Before these types of modifications of the code are done, a requirement specifying the need for the change should exist.</p>
<p class="calibre2">Even through the practice of Test-Driven Development, it is possible to paint yourself into a corner. Often during refactoring or during the process of designing your next test, it is possible to solve too much of the problem at once or refactor too much. </p>
<p class="calibre2">Always keep in mind that, in TDD, we want to break a problem down into the smallest steps possible. Also, don't go for the solution in the first test if the solution is more than a line or two. At the same time, even for small solutions, if the solution is calculation or algorithm heavy, it should still be broken down, even if the eventual solution is a single line of production code.</p>
<div class="packt_tip"><span class="calibre21">Beware of premature optimizations.</span></div>
<p class="calibre2">Refactoring, according to Kent Beck, is the process of removing duplication. Remember that while refactoring your tests. By only removing duplication, we can avoid premature optimization via refactoring. It is completely possible, and even attractive at times, to refactor a solution and reduce the code significantly, or even to use a fancy new language feature or Linq expression to make your test pass. These solutions are fine in the long run, but while the tests are still being built, these hidden optimizations can cause you and your tests to become derailed extremely quickly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">You can now see how a change in requirements, a new feature request, or a defect might require an application to change. Through TDD and a comprehensive suite of unit tests, these changes can be made safely and easily.</p>
<p class="calibre2">In <a target="_blank" href="part0386.html#BG3P40-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 12</a>, <em class="calibre12">The Legacy Problem</em>, we'll discuss how to deal with a legacy application that may not have been written with testing in mind.</p>


            </article>

            
        </section>
    </body></html>