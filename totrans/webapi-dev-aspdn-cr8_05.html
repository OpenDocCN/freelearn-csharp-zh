<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-101"><a id="_idTextAnchor198"/>5</h1>
<h1 id="_idParaDest-102"><a id="_idTextAnchor199"/>Data Access in ASP.NET Core (Part 1: Entity Framework Core Fundamentals)</h1>
<p>In <a href="B18971_02.xhtml#_idTextAnchor068"><em class="italic">Chapter 2</em></a>, we introduced a simple ASP.NET Core application to manage blog posts, which uses a static field to store the data in memory. In many real-world applications, the data is persisted in databases – such as SQL Server, MySQL, SQLite, PostgreSQL, and so on – so we will need to access the database to implement the CRUD operations.</p>
<p>In this chapter, we will learn about data access in ASP.NET Core. There are many ways to access the database in ASP.NET Core, such as through ADO.NET, Entity Framework Core, and Dapper, among others. In this chapter, we will focus on Entity Framework Core, which is the most <a id="_idIndexMarker452"/>popular <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) framework in .NET Core.</p>
<p><strong class="bold">Entity Framework Core</strong>, or <strong class="bold">EF Core</strong> for <a id="_idIndexMarker453"/>short, is an open-source ORM framework that allows us to create and manage mapping configurations between the database schema and the object models. It provides a set of APIs to perform CRUD operations using LINQ methods, which is like operating the objects in memory. EF Core supports many database providers, such as SQL Server, SQLite, PostgreSQL, MySQL, and so on. It also supports many other features, such as migrations, change tracking, and so on.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Why use ORM?</li>
<li>Configuring the DbContext class</li>
<li>Implementing CRUD controllers</li>
<li>Basic LINQ queries</li>
<li>Configuring the mapping between models and database tables</li>
</ul>
<p>By the end of this chapter, you will be able to use EF Core to access the database in ASP.NET Core applications and perform basic CRUD operations.<a id="_idTextAnchor200"/></p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor201"/>Technical requirements</h1>
<p>The code example in this chapter can be found at <a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter5/">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter5/</a>. You can use VS 2022 or VS Code to open the solution.</p>
<p>You are expected to have basic knowledge of SQL queries and LINQ. If you are not familiar with them, you can refer to the following resources:</p>
<ul>
<li>SQL queries: <a href="https://www.w3schools.com/sql/">https://www.w3schools.com/sql/</a></li>
<li>LINQ: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/linq/">https://learn.microsoft.com/en-us/dotnet/csharp/linq/</a></li>
</ul>
<h1 id="_idParaDest-104"><a id="_idTextAnchor202"/>Why use ORM?</h1>
<p>To operate the<a id="_idIndexMarker454"/> data in relational databases, we need to write SQL statements. However, SQL statements are not easy to maintain and are not type-safe. Every time you update the database schema, you need to update the SQL statements as well, which is error-prone. In many traditional applications, the logic is tightly coupled with the database. For example, the logic could be defined in a SQL database directly, such as stored procedures, triggers, and so on. This makes the application hard to maintain and extend.</p>
<p>ORM helps us to map the database schema to the object model, so we can operate the data in the database just like we operate the objects in memory. ORM can translate the CRUD operations to SQL statements, which means it is like an abstract layer between the application and the database. The data access logic is decoupled from the database, so we can easily change the database without changing the code. Also, it provides strong type safety, so we can avoid runtime errors caused by type mismatch.</p>
<p>Keep in mind that we are not saying that ORM is the best solution for all scenarios. Sometimes, we need to write SQL statements directly to achieve the best performance. For example, if we need to generate a complex data report, we may need to write SQL statements to optimize the performance of the query. However, for most scenarios, ORM provides more benefits than drawbacks.</p>
<p>There are many ORM frameworks in .NET. In this book, we will use EF Core, which is the most popular ORM framework in .NET Core. The following are the reasons why we chose EF Core:</p>
<ul>
<li><strong class="bold">Open-source</strong>: EF Core is an<a id="_idIndexMarker455"/> open-source project and is mainly maintained by Microsoft, so it is well-supported. The contribution is also very active.</li>
<li><strong class="bold">Multiple database support</strong>: EF Core supports<a id="_idIndexMarker456"/> many database providers, such as SQL Server, SQLite, PostgreSQL, MySQL and so on. Developers can use the same APIs to access different databases.</li>
<li><strong class="bold">Migration</strong>: EF Core supports <a id="_idIndexMarker457"/>database migrations, which allows us to update the database schema easily.</li>
<li><strong class="bold">LINQ support</strong>: EF Core <a id="_idIndexMarker458"/>provides support for LINQ, which allows us to use a familiar syntax to query the database.</li>
<li><strong class="bold">Code-first approach</strong>: EF Core<a id="_idIndexMarker459"/> supports the code-first approach, which means we can define the database schema using C# code, and EF Core will generate the database schema automatically.</li>
<li><strong class="bold">Performance</strong>: EF Core<a id="_idIndexMarker460"/> is designed to be lightweight and performant. It supports query caching and lazy loading to help improve performance. Also, EF Core provides asynchronous APIs, which allows us to perform database operations asynchronously to improve the scalability of the application. In addition, EF Core supports raw SQL queries, enabling us to write SQL statements directly to achieve the best performance.</li>
</ul>
<p>Overall, EF Core is a good choice for most scenarios if you are using .NET Core. So, in this book, we will be using EF Core as the ORM framework.</p>
<p>To use the .NET Core CLI to perform EF Core-related tasks, we first need to install the <code>dotnet-ef</code> tool. You can install it using the following command:</p>
<pre class="console">
dotnet tool install --global dotnet-ef</pre> <p>It is recommended to install the tool as a global tool, so you can use it in any project for convenience.</p>
<p>Next, create a new web API project using the following command:</p>
<pre class="console">
dotnet new webapi -n BasicEfCoreDemo -controllers</pre> <p>Then, navigate to the project folder and run the following command to install EF Core packages:</p>
<pre class="console">
dotnet add package Microsoft.EntityFrameworkCore.SqlServerdotnet add package Microsoft.EntityFrameworkCore.Design</pre>
<p>The first package is the database provider, which is used to connect the application to a SQL Server database. For this demo application, we <a id="_idIndexMarker461"/>will use <strong class="bold">LocalDB</strong>, which is a lightweight version of SQL Server. The second package contains shared design-time components for EF Core tools, which are required to perform database migrations.</p>
<p class="callout-heading">What is LocalDB?</p>
<p class="callout">LocalDB is designed to be used as a substitute for the full version of SQL Server; it is suitable for development and testing, but not for production use. We can use LocalDB for development and replace the connection string when we deploy the application to production. LocalDB is installed with VS 2022. If you do not have VS 2022 by default, you can find the installation package at <a href="https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb">https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb</a>.</p>
<p class="callout">LocalDB is supported by Windows only. If you use macOS or Linux, you can use SQLite instead of LocalDB, or use a Docker container to run SQL Server. For more information about SQLite, please refer to <a href="https://docs.microsoft.com/en-us/ef/core/providers/sqlite/">https://docs.microsoft.com/en-us/ef/core/providers/sqlite/</a>.</p>
<p class="callout">For more information about SQL Server on Docker, please refer to <a href="https://learn.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker">https://learn.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker</a>. Note that there are many other database providers, such as SQLite, PostgreSQL, MySQL, and so on. You can find the full list of database providers at <a href="https://docs.microsoft.com/en-us/ef/core/providers/">https://docs.microsoft.com/en-us/ef/core/providers/</a>. Some providers are not maintained by Microsoft.</p>
<p>Next, let’s explore how to use EF Core to access the <a id="_idTextAnchor203"/>database.</p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor204"/>Configuring the DbContext class</h1>
<p>To <a id="_idIndexMarker462"/>represent the database, EF Core uses the <code>DbContext</code> class, which allows us to query and save data. An instance of the <code>DbContext</code> class maintains the database connection and maps the database schema to the object model. It also tracks the changes in objects and manages the transactions. If you are familiar with OOP, you can think of the <code>DbContext</code> class as a bridge between the database and the object model, just like an interface. When you query or save data, you operate the objects through the <code>DbContext</code> class, and EF Core will translate the operations to the corresponding SQL statements.</p>
<p>In this chapter, we will develop a simple application to manage invoices. This application will be used to demonstrate how to use EF Core to access the database, including how to define the database schema, how to perform CRUD operations, and how to use migrations to update the database schema.</p>
<p>You can follow <a href="B18971_01.xhtml#_idTextAnchor012"><em class="italic">Chapter 1</em></a> to define the API contract first. The API contract defines the endpoints and the request/response models. When we define the API contract, note that we need to consult stakeholders to understand the requirements. For example, we need to know the fields of the invoice, the data types of the fields, and so on. We also need to understand the business rules, such as <em class="italic">the invoice number should be unique</em>, and <em class="italic">the invoice amount should be greater than 0</em>, for example. That means we will spend lots of time on the API design phase. Here, we assume that we have already defined the API contract, and we can start to develop the ap<a id="_idTextAnchor205"/>plication.</p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor206"/>Creating models</h2>
<p>The <a id="_idIndexMarker463"/>first step is to define the models. A model, also known as an entity, is a class that represents an object in the real world, which will be mapped to a table (or multiple tables) in the database. In this demo application, we need to define the <code>Invoice</code> model.</p>
<p>An invoice can be defined as the following class:</p>
<pre class="source-code">
namespace BasicEfCoreDemo.Models;public class Invoice{
    public Guid Id { get; set; }
    public string InvoiceNumber { get; set; } = string.Empty;
    public string ContactName { get; set; } = string.Empty;
    public string? Description { get; set; }
    public decimal Amount { get; set; }
    public DateTimeOffset InvoiceDate { get; set; }
    public DateTimeOffset DueDate { get; set; }
    public InvoiceStatus Status { get; set; }
}</pre>
<p><code>InvoiceStatus</code> is a <a id="_idIndexMarker464"/>custom enum type, which is defined as the following code:</p>
<pre class="source-code">
public enum InvoiceStatus{
    Draft,
    AwaitPayment,
    Paid,
    Overdue,
    Cancelled
}</pre>
<p>You can create a file named <code>Invoice.cs</code> in the <code>Models</code> folder and copy the <code>Invoice</code> class code into the file.</p>
<p class="callout-heading">Important note</p>
<p class="callout">We use the <code>Guid</code> type for the <code>Id</code> property, which is the unique identifier for the invoice. You can also use <code>int</code> or <code>long</code> as the identifier. Either way has its pros and cons. For example, <code>int</code> is more efficient than <code>Guid</code>, but it is not unique across databases. When the database grows, you may need to split the data into multiple databases, which means the <code>int</code> identifier may not be unique anymore. On the other hand, <code>Guid</code> is unique no matter how many databases you have, but it is more expensive to store, insert, query, and sort the records than using <code>int</code> or <code>long</code>. The <code>Guid</code> primary key with the cluster index may cause poor performance in some scenarios. In this demo application, we use <code>Guid</code> as the identifier for now. We will discuss more about the techniques to optimize the application performance in future chapters.</p>
<p class="callout">We also use the <code>DateTimeOffset</code> type for the <code>InvoiceDate</code> and <code>DueDate</code> properties, which is the recommended type for date and time in .NET Core. You can also use the <code>DateTime</code> type if you do not care about the time zone. <code>DateTimeOffset</code> includes a time zone offset from UTC time, and it is supported by both .NET type and SQL Server. This is helpful if you want to avoid the time zone issues.</p>
<p>We may need<a id="_idIndexMarker465"/> more properties in the future, such as contact information, invoice items, and so on, but we will add them later. Let’s focus on only the m<a id="_idTextAnchor207"/>odel for now.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor208"/>Creating and configuring the DbContext class</h2>
<p>Next, we will <a id="_idIndexMarker466"/>create a <code>DbContext</code> class to represent the database. Create a file named <code>InvoiceDbContext.cs</code> in the <code>Data</code> folder and add the<a id="_idIndexMarker467"/> following code:</p>
<pre class="source-code">
using BasicEfCoreDemo.Models;using Microsoft.EntityFrameworkCore;
namespace BasicEfCoreDemo.Data;
public class InvoiceDbContext(DbContextOptions&lt;InvoiceDbContext&gt; options) : DbContext(options)
{
    public DbSet&lt;Invoice&gt; Invoices =&gt; Set&lt;Invoice&gt;();
}</pre>
<p>In the <a id="_idIndexMarker468"/>preceding code, we have done the following:</p>
<ul>
<li>Inherited the <code>DbContext</code> class and defined the <code>InvoiceDbContext</code> class, which represents the database.</li>
<li>Defined the <code>Invoices</code> property, which is a <code>DbSet&lt;Invoice&gt;</code> type. It is used to represent the <code>Invoices</code> table in the database.</li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">Why we do not use <code>public DbSet&lt;Invoice&gt; Invoices { get; set; }</code> here? The reason is that if the <code>DbSet&lt;T&gt;</code> properties are not initialized, the compiler will emit warnings from them because the nullable reference type feature is enabled by default. So we can use a <code>Set&lt;TEntity&gt;()</code> method to initialize the property to eliminate the warning. Another way to fix that is to use the null-forgiving operator, <code>!</code>, which forces the silencing of the compiler warnings. The <code>DbContext</code> base constructor will initialize the <code>DbSet&lt;T&gt;</code> properties for us, so it is safe to use <code>!</code> for this case. If you do not mind seeing the warnings, using <code>public DbSet&lt;Invoice&gt; Invoices { get; set; }</code> also works. You can use either method.</p>
<p>Next, let’s configure the database connection string. Open the <code>appsettings.json</code> file and add the following code to the <code>ConnectionStrings</code> section:</p>
<pre class="source-code">
"ConnectionStrings": {    "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=BasicEfCoreDemoDb;Trusted_Connection=True;MultipleActiveResultSets=true"
  }</pre>
<p class="callout-heading">Important note</p>
<p class="callout">You can use other databases, such as SQLite or PostgreSQL, but you need to install the corresponding database provider and change the connection string accordingly. To learn more about connection strings, please refer to <a href="https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/connection-string-syntax">https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/connection-string-syntax</a>. There is a website called <a href="https://connectionstrings.com/">https://connectionstrings.com/</a> that can generate connection strings for different database providers.</p>
<p>In the <a id="_idIndexMarker469"/>preceding connection string, we use <code>Server=(localdb)\\mssqllocaldb </code>to specify the server as a LocalDB instance, and <code>Database=BasicEfCoreDemoDb</code> to specify the name of the database. You can change the database name to whatever you want. The <code>Trusted_Connection=True</code> option specifies that the connection is trusted, which means you do not need to provide the username and password. The <code>MultipleActiveResultSets=true</code> option specifies that the connection can have <code>Include()</code> method in EF Core.</p>
<p>Open the <code>Program.cs</code> file and add the following code after <code>builder</code> is created:</p>
<pre class="source-code">
builder.Services.AddDbContext&lt;InvoiceDbContext&gt;(options =&gt;    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));</pre>
<p>The preceding code registers the <code>InvoiceDbContext</code> class to the dependency injection container. The <code>AddDbContext&lt;TContext&gt;()</code> method is an extension method that accepts a <code>DbContextOptionsBuilder</code> parameter, which calls the <code>UseSqlServer()</code> method to configure the database provider to use SQL Server or LocalDB. Note that we use the <code>UseSqlServer()</code> method for both SQL Server and LocalDB. The difference is that LocalDB has a <code>(localdb)\\mssqllocaldb</code> server name by default. We also pass the database connection string to the <code>UseSqlServer()</code> method, which should be the same as the name we defined in the <code>appsettings.json</code> file.</p>
<p>Currently, this<a id="_idIndexMarker471"/> code just registers the <code>InvoiceDbContext</code> class to the dependency injection container, but we have not created the database yet. Next, we will create the database using the<a id="_idTextAnchor209"/> <code>dotnet </code><code>ef</code> command.</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor210"/>Creating the database</h2>
<p>We <a id="_idIndexMarker472"/>have defined the <code>InvoiceDbContext</code> class, and the instance of <code>InvoiceDbContext</code> is added to the dependency injection container. Next, we need to create the database and the <code>Invoices</code> table before we can use it. To create the database and the <code>Invoices</code> table, we need to run the following command to apply the database migration:</p>
<pre class="console">
dotnet ef migrations add InitialDb</pre> <p>The <code>InitialDb</code> parameter is the migration name. You can use any name you like as long as it is a valid C# identifier. It is recommended to use a meaningful name, such as <code>InitialDb</code>, <code>AddInvoiceTable</code>, and so on.</p>
<p>The preceding command creates a couple of migration files, such as <code>&lt;timestamp&gt;_InitialDb.cs</code> and <code>&lt;timestamp&gt;_InitialDb.Designer.cs</code>, which are stored in the <code>Migrations</code> folder. The <code>&lt;timestamp&gt;_InitialDb.cs</code> migration file contains an <code>Up()</code> method to create the database and the tables. It also has a <code>Down()</code> method to roll back the changes. Note that this command does not create the database; it just creates the migration files. Please do not manually modify or delete the migration files as they are required to apply or roll back the database changes.</p>
<p>Here is a sample of the migration files:</p>
<pre class="source-code">
protected override void Up(MigrationBuilder migrationBuilder){
    migrationBuilder.CreateTable(
        name: "Invoices",
        columns: table =&gt; new
        {
            Id = table.Column&lt;Guid&gt;(type: "uniqueidentifier", nullable: false),
            InvoiceNumber = table.Column&lt;string&gt;(type: "nvarchar(max)", nullable: false),
            ContactName = table.Column&lt;string&gt;(type: "nvarchar(max)", nullable: false),
            Description = table.Column&lt;string&gt;(type: "nvarchar(max)", nullable: true),
            Amount = table.Column&lt;decimal&gt;(type: "decimal(18,2)", nullable: false),
            InvoiceDate = table.Column&lt;DateTimeOffset&gt;(type: "datetimeoffset", nullable: false),
            DueDate = table.Column&lt;DateTimeOffset&gt;(type: "datetimeoffset", nullable: false),
            Status = table.Column&lt;int&gt;(type: "int", nullable: false)
        },
        constraints: table =&gt;
        {
            table.PrimaryKey("PK_Invoices", x =&gt; x.Id);
        });
}
// Omitted for brevity</pre>
<p>As you <a id="_idIndexMarker473"/>can see, the <code>Up()</code> method creates the table, columns, and constraints. The <code>Down()</code> method drops the table. You can use <code>dotnet ef migrations remove</code> to remove the migration files.</p>
<p class="callout-heading">Important note</p>
<p class="callout">You may see a warning message like this:</p>
<p class="callout"><strong class="bold">Microsoft.EntityFrameworkCore.Model.Validation[30000]</strong></p>
<p class="callout"><strong class="bold">No store type was specified for the decimal property ‘Amount’ on entity type ‘Invoice’. This will cause &gt; values to be silently truncated if they do not fit in the default precision and scale. Explicitly &gt; specify the SQL server column type that can accommodate all the values in ‘OnModelCreating’ using &gt; ‘HasColumnType’, specify precision and scale using ‘HasPrecision’, or configure a value converter using &gt; ‘</strong><strong class="bold">HasConversion’.</strong></p>
<p class="callout">This is because we did not specify the precision and scale for the <code>Amount</code> property. We will fix it later. Currently, EF Core will use the default precision and scale for the <code>decimal</code> type, which is <code>decimal(18,2)</code>.</p>
<p>The migration file <a id="_idIndexMarker474"/>has been created, but it has not been applied to the database yet. Next, run the following command to create the database and the <code>Invoices</code> table:</p>
<pre class="console">
dotnet ef database update</pre> <p>If the command is successful, we should find the database file in your user folder, such as <code>C:\Users\{username}\BasicEfCoreDemoDb.mdf</code> if you use Windows. You can use <code>%USERPROFILE%</code> to get the user folder path.</p>
<p class="callout-heading">Important note</p>
<p class="callout">You may encounter an error<code> System.Globalization.CultureNotFoundException</code>: Only the invariant culture is supported in globalizati<a href="https://aka">on-invarian</a>t mode. See https://aka<code>.ms/GlobalizationInvariantMode</code> for more information. <code>(Parameter 'name')</code>. This is because starting in .NET 6, the globalization invariant mode is enabled by default. You can disable it by setting the <code>InvariantGlobalization</code> property to <code>false</code> in the <code>csproj</code> file.</p>
<p>There are several tools you can use to open the LocalDB database file – for example, <strong class="bold">SQL Server Management Studio</strong> (<strong class="bold">SSMS</strong>), which <a id="_idIndexMarker475"/>is supported by Microsoft. Yo<a href="https://learn">u can downloa</a>d it here: <a href="https://learn.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms">https://learn.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms</a>. You can also use other <a href="https://dbeaver">tools, such as </a>Dbeaver (<a href="https://dbeaver.io/">https://dbeaver.io/</a>), a free, universal database tool,<a href="https://www"> or JetBrai</a>ns DataGrip (<a href="https://www.jetbrains.com/datagrip/">https://www.jetbrains.com/datagrip/</a>), a <a id="_idIndexMarker476"/>powerful database IDE. We’ll be using SSMS.</p>
<p>Open the <a id="_idIndexMarker477"/>database file in SSMS, and you will see that the <code>BasicEfCoreDemoDb</code> database has been created. It will have two tables – <code>Invoices</code> and <code>__EFMigrationsHistory</code>:</p>
<div><div><img alt="Figure 5.1 – The database created by EF Core migration" src="img/B18971_05_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The database created by EF Core migration</p>
<p>The <code>__EFMigrationsHistory</code> table is used to track the migrations. It is created automatically by EF Core. Do not manually modify it.</p>
<p>Now that we <a id="_idIndexMarker478"/>have created the database and the <code>Invoices</code> table. Next,let’s add som<a id="_idTextAnchor211"/>e seed data to the table.</p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor212"/>Adding seed data</h2>
<p>Open<a id="_idIndexMarker479"/> the <code>InvoiceDbContext.cs</code> file and add the following code to the <code>OnModelCreating()</code> method:</p>
<pre class="source-code">
protected override void OnModelCreating(ModelBuilder modelBuilder){
    modelBuilder.Entity&lt;Invoice&gt;().HasData(
        new Invoice
        {
            Id = Guid.NewGuid(),
            InvoiceNumber = "INV-001",
            ContactName = "Iron Man",
            Description = "Invoice for the first month",
            Amount = 100,
            InvoiceDate = new DateTimeOffset(2023, 1, 1, 0, 0, 0, TimeSpan.Zero),
            DueDate = new DateTimeOffset(2023, 1, 15, 0, 0, 0, TimeSpan.Zero),
            Status = InvoiceStatus.AwaitPayment
        },
        // Omitted for brevity. You can check the full code in the sample project.
}</pre>
<p>We need to create a new database migration to apply the changes to the database. Run the following command:</p>
<pre class="console">
dotnet ef migrations add AddSeedDatadotnet ef database update</pre>
<p>If you check the <a id="_idIndexMarker480"/>database in SSMS, you will see that the seed data is added to the <code>Invoices</code> table.</p>
<p>The data is ready. Next, we will create the controllers to handle the HTTP requests and operate <a id="_idTextAnchor213"/>the data with the database.</p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor214"/>Implementing CRUD controllers</h1>
<p>In this <a id="_idIndexMarker481"/>section, we will implement the controllers to handle the HTTP requests, which are the <code>GET</code>, <code>POST</code>, <code>PUT</code>, and <code>DELETE</code> operations that are used to retrieve, create, update, an<a id="_idTextAnchor215"/>d delete data, respectively.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor216"/>Creating the controller</h2>
<p>If you<a id="_idIndexMarker482"/> have installed the <code>dotnet aspnet-codegenerator</code> tool following <a href="B18971_02.xhtml#_idTextAnchor068"><em class="italic">Chapter 2</em></a>, you can use the following command to create a controller with the specific <code>DbContext</code>. Do not forget to install the <code>Microsoft.VisualStudio.Web.CodeGeneration.Design</code> NuGet package, which is required by the <code>dotnet </code><code>aspnet-codegenerator</code> tool:</p>
<pre class="console">
# Install the tool if you have not installed it yet.#dotnet tool install -g dotnet-aspnet-codegenerator
dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design
dotnet-aspnet-codegenerator controller -name InvoicesController -api -outDir Controllers ––model Invoice ––dataContext InvoiceDbContext -async -actions</pre>
<p>The preceding command has some parameters as shown here:</p>
<ul>
<li><code>-name</code>: The name of the controller.</li>
<li><code>-api</code>: Indicates that the controller is an API controller.</li>
<li><code>-outDir</code>: The output directory of the controller.</li>
<li><code>--model</code>: The model class name. In this case, it is the <code>Invoice</code> class.</li>
<li><code>--dataContext</code>: The <code>DbContext</code> class name. In this case, it is the <code>InvoiceDbContext</code> class.</li>
<li><code>-async</code>: Indicates that the actions of the controller are asynchronous.</li>
</ul>
<p>For more <a id="_idIndexMarker483"/>information about the <code>dotnet</code><a href="https://learn"><code> aspnet-codeg</code></a><code>enerator</code> tool, see <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/tools/dotnet-aspnet-codegenerator">https://learn.microsoft.com/en-us/aspnet/core/fundamentals/tools/dotnet-aspnet-codegenerator</a>.</p>
<p>The <code>dotnet aspnet-codegenerator</code> tool will create a controller with the following actions:</p>
<pre class="source-code">
using BasicEfCoreDemo.Data;using BasicEfCoreDemo.Models;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
namespace BasicEfCoreDemo.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class InvoicesController : ControllerBase
    {
        private readonly InvoiceDbContext _context;
        public InvoicesController(InvoiceDbContext context)
        {
            _context = context;
        }
        // GET: api/Invoices
        [HttpGet]
        public async Task&lt;ActionResult&lt;IEnumerable&lt;Invoice&gt;&gt;&gt; GetInvoices()
        {
            if (_context.Invoices == null)
            {
                return NotFound();
            }
            return await _context.Invoices.ToListAsync();
        }
        // GET: api/Invoices/5
        [HttpGet("{id}")]
        public async Task&lt;ActionResult&lt;Invoice&gt;&gt; GetInvoice(Guid id)
        {
            if (_context.Invoices == null)
            {
                return NotFound();
            }
            var invoice = await _context.Invoices.FindAsync(id);
            if (invoice == null)
            {
                return NotFound();
            }
            return invoice;
        }
        // PUT: api/Invoices/5
        // To protec<a href="https://go">t from ove</a>rposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754
        [HttpPut("{id}")]
        public async Task&lt;IActionResult&gt; PutInvoice(Guid id, Invoice invoice)
        {
            if (id != invoice.Id)
            {
                return BadRequest();
            }
            _context.Entry(invoice).State = EntityState.Modified;
            try
            {
                await _context.SaveChangesAsync();
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!InvoiceExists(id))
                {
                    return NotFound();
                }
                else
                {
                    throw;
                }
            }
            return NoContent();
        }
        // POST: api/Invoices
        // To protec<a href="https://go">t from ove</a>rposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754
        [HttpPost]
        public async Task&lt;ActionResult&lt;Invoice&gt;&gt; PostInvoice(Invoice invoice)
        {
            if (_context.Invoices == null)
            {
                return Problem("Entity set 'InvoiceDbContext.Invoices'  is null.");
            }
            _context.Invoices.Add(invoice);
            await _context.SaveChangesAsync();
            return CreatedAtAction("GetInvoice", new { id = invoice.Id }, invoice);
        }
        // DELETE: api/Invoices/5
        [HttpDelete("{id}")]
        public async Task&lt;IActionResult&gt; DeleteInvoice(Guid id)
        {
            if (_context.Invoices == null)
            {
                return NotFound();
            }
            var invoice = await _context.Invoices.FindAsync(id);
            if (invoice == null)
            {
                return NotFound();
            }
            _context.Invoices.Remove(invoice);
            await _context.SaveChangesAsync();
            return NoContent();
        }
        private bool InvoiceExists(Guid id)
        {
            return (_context.Invoices?.Any(e =&gt; e.Id == id)).GetValueOrDefault();
        }
    }
}</pre>
<p>It is so easy! The <code>dotnet aspnet-codegenerator</code> tool has generated the controller <a id="_idIndexMarker484"/>with basic CRUD operations. You can run the application and test the API endpoints with the Swagger UI. We will explain the co<a id="_idTextAnchor217"/>de of the controller in detail.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor218"/>How controllers work</h2>
<p>In <a href="B18971_02.xhtml#_idTextAnchor068"><em class="italic">Chapter 2</em></a> and<em class="italic"> </em><a href="B18971_03.xhtml#_idTextAnchor130"><em class="italic">Chapter 3</em></a>, we introduced how HTTP requests are mapped to the controller actions. In this chapter, we focus on data access and database operations.</p>
<p>First, we use DI<a id="_idIndexMarker485"/> to inject the <code>InvoiceDbContext</code> instance into the controller, which handles the database operations. As developers, normally, we do not need to worry about the database connection. <code>InvoiceDbContext</code> is registered as scoped, which means that each HTTP request will create a new <code>InvoiceDbContext</code> instance, and the instance will be disposed of after the request is completed.</p>
<p>Once we get the <code>InvoiceDbContext</code> instance, we can use the <code>DbSet</code> property to access the entity set. The <code>DbSet&lt;Invoice&gt;</code> property represents a collection of the <code>Invoice</code> model class, which is mapped to the <code>Invoices</code> table in the database. We can <a id="_idIndexMarker486"/>use <code>FindAsync()</code>, <code>Add()</code>, <code>Remove()</code>, and <code>Update()</code>, to retrieve, add, remove, and update the entity in the database, respectively. The <code>SaveChangesAsync()</code> method is used to save the changes to the database. In this way, we operate the database through .NET objects, which is much easier than using SQL statements. That is the power of ORMs.</p>
<p class="callout-heading">What is LINQ?</p>
<p class="callout"><strong class="bold">Language-Integrated Query</strong> (<strong class="bold">LINQ</strong>) is a <a id="_idIndexMarker487"/>set of features in .NET that provide a consistent and expressive way to query and manipulate data from various data sources, such as a database, XML, and in-memory collections. With LINQ, you can write queries in a declarative way, which is much easier than using SQL statements. We will show you some basic LINQ queries in the next section. <a href="https://lear">For more info</a>rmation about LINQ, see <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/">https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/</a>.</p>
<p>Let us look <a id="_idIndexMarker488"/>at the generated SQL statements. Use <code>dotnet run</code> to start the application and test the <code>api/Invoices</code> API endpoint with the Swagger UI or any tool you like. You can see the following SQL statements in the <strong class="bold">Debug</strong> window:</p>
<pre class="console">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (26ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]</pre>
<p>The logs are helpful for understanding the SQL statements generated by EF Core. EF Core executes the SQL query and then maps the result to the models. It significantly simplifies d<a id="_idTextAnchor219"/>ata access and database operations.</p>
<p>Next, let us learn how to query data using LINQ in controllers.</p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor220"/>Basic LINQ queries</h1>
<p>This book<a id="_idIndexMarker489"/> is not intended to be a LINQ handbook. However, we will show you some basic LINQ queries in this section:</p>
<ul>
<li>Querying the data</li>
<li>Filtering the data</li>
<li>Sorting the data</li>
<li>Paging the data</li>
<li>Creating the data<a id="_idTextAnchor221"/></li>
<li>Updating the data</li>
<li>Deleting the data</li>
</ul>
<h2 id="_idParaDest-114"><a id="_idTextAnchor222"/>Querying the data</h2>
<p>The <code>DbSet&lt;Invoice&gt; Invoices</code> property in the <code>InvoiceDbContext</code> class represents<a id="_idIndexMarker490"/> a collection of the <code>Invoice</code> entity. We can use LINQ methods to query the data. For example, we can use the <code>ToListAsync()</code> method to retrieve all the invoices from the database:</p>
<pre class="source-code">
var invoices = await _context.Invoices.ToListAsync();</pre> <p>That is how the <code>GetInvoices</code> action method works.</p>
<p>To find a specific invoice, we can use the <code>FindAsync()</code> method, as shown in the <code>GetInvoice()</code> action method:</p>
<pre class="source-code">
var invoice = await _context.Invoices.FindAsync(id);</pre> <p>The <code>FindAsync()</code> method accepts the primary key value as the parameter. EF Core will translate the <code>FindAsync()</code> method to the SQL <code>SELECT</code> statement, as shown here:</p>
<pre class="console">
Executed DbCommand (15ms) [Parameters=[@__get_Item_0='?' (DbType = Guid)], CommandType='Text', CommandTimeout='30']      SELECT TOP(1) [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]
      WHERE [i].[Id] = @__get_Item_0</pre>
<p>We<a id="_idIndexMarker491"/> can also use <code>Single()</code> or <code>SingleOrDefault()</code> methods to find a specific entity. For example, we can use the <code>SingleAsync()</code> method to find the invoice with the specified ID:</p>
<pre class="source-code">
var invoice = await _context.Invoices.SingleAsync(i =&gt; i.Id == id);</pre> <p class="callout-heading">Important note</p>
<p class="callout">You may notice that we use <code>SingleAsync()</code> instead of <code>Single()</code> in the code. Many methods of EF Core have both synchronous and asynchronous versions. The asynchronous versions are suffixed with <code>Async</code>. It is recommended to use the asynchronous versions in the controller actions because they are non-blocking and can improve the performance of the application.</p>
<p>If you have LINQ experience, you may know there are other methods – such as <code>First()</code>, <code>FirstOrDefault()</code>, and so on – that can be used to find a specific entity. The differences are listed as follows:</p>
<ul>
<li><code>Find()</code> or <code>FindAsync()</code> is used to find an entity by the primary key value. If the entity is not found, it returns <code>null</code>. Note that these two methods are related to the tracking state of the entity. If the entity is already tracked by <code>DbContext</code>, the <code>Find()</code> and <code>FindAsync()</code> methods will return the tracked entity immediately without querying the database. Otherwise, they will execute the SQL <code>SELECT</code> statement to retrieve the entity from the database.</li>
<li><code>Single()</code> or <code>SingleAsync()</code> can accept a predicate as the parameter. It returns the <em class="italic">single</em> entity that satisfies the predicate and throws an exception if the entity is not found or more than one entity satisfies the condition. If it is called without a predicate, it returns the only entity of the collection and throws an exception if more than one entity exists in the collection.</li>
<li><code>SingleOrDefault()</code> or <code>SingleOrDefaultAsync()</code> can accept a predicate as the parameter. It also returns the <em class="italic">single</em> entity that satisfies the predicate and throws an exception if more than one entity satisfies the condition but returns a default value if the entity is not found. If it is called without a predicate, it returns a default value (or a specified default value) if the collection is empty and throws an exception if more than one entity exists in the collection.</li>
<li><code>First()</code> or <code>FirstAsync()</code> can accept a predicate as the parameter. It returns the <em class="italic">first</em> entity that satisfies the predicate and throws an exception if the entity is <a id="_idIndexMarker492"/>not found or the collection is null or empty. If it is called without a predicate, it returns the first entity of the collection and throws an exception if the collection is null or empty.</li>
<li><code>FirstOrDefault()</code> or <code>FirstOrDefaultAsync()</code> can accept a predicate as the parameter. It also returns the <em class="italic">first</em> entity that satisfies the predicate. If the entity is not found or the collection is empty, it returns a default value (or a specified default value). If it is called without a predicate, it returns the first entity if the collection is not empty; otherwise, it returns a default value (or a specified default value). If the collection is null, it throws an exception.</li>
</ul>
<p>These methods are kind of confusing. The recommended practice is as follows:</p>
<ul>
<li>If you want to find an entity by the primary key value and leverage the tracking state to improve the performance, use <code>Find()</code> or <code>FindAsync()</code>.</li>
<li>If you are sure that the entity exists and only one entity satisfies the condition, use <code>Single()</code> or <code>SingleAsync()</code>. If you would like to specify a default value when the entity is not found, use <code>SingleOrDefault()</code> or <code>SingleOrDefaultAsync()</code>.</li>
<li>If you are not sure whether the entity exists, or there may be more than one entity that satisfies the condition, use <code>First()</code> or <code>FirstAsync()</code>. If you would like to specify a default value when the entity is not found, use <code>FirstOrDefault()</code> or <code>FirstOrDefaultAsync()</code>.</li>
<li>Do not forget <a id="_idIndexMarker493"/>to check whether the result is <code>null</code> if you use <code>Find()</code>, <code>FindAsync()</code>, <code>SingleOrDefault()</code>, <code>SingleOrDefaultAsync()</code>, <code>Firs<a id="_idTextAnchor223"/>tOrDefault()</code>, and <code>FirstOrDefaultAsync()</code>.</li>
</ul>
<h2 id="_idParaDest-115"><a id="_idTextAnchor224"/>Filtering the data</h2>
<p>If the table <a id="_idIndexMarker494"/>contains a lot of records, we may want to filter the data based on some conditions, instead of returning all of them. We can use the <code>Where()</code> method to filter the invoices by status. Update the <code>GetInvoices</code> action method as shown here:</p>
<pre class="source-code">
[HttpGet]public async Task&lt;ActionResult&lt;IEnumerable&lt;Invoice&gt;&gt;&gt; GetInvoices(InvoiceStatus? status)
{
    // Omitted for brevity
    return await _context.Invoices.Where(x =&gt; status == null || x.Status == status).ToListAsync();
}</pre>
<p>The <code>Where()</code> method accepts a lambda expression as the parameter. A lambda expression is a concise way to define a delegate method inline, which is widely used in LINQ queries to define filtering, sorting, and projection operations. In the preceding example, the <code>x =&gt; status == null || x.Status == status</code> lambda expression means that the <code>Status</code> property of the <code>Invoice</code> entity is equal to the <code>status</code> parameter if the <code>status</code> parameter is not <code>null</code>. EF Core will translate the lambda expression to the SQL <code>WHERE</code> clause.</p>
<p>Run the application and check the Swagger UI. You will find the <code>/api/Invoices</code> endpoint now has a <code>status</code> parameter. You can use the parameter to filter the invoices by status:</p>
<div><div><img alt="Figure 5.2 – Filtering the invoices by status" src="img/B18971_05_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Filtering the invoices by status</p>
<p>Send a <a id="_idIndexMarker495"/>request with a status parameter to the <code>/api/Invoices</code> endpoint. You will get the invoices with the specified status. The SQL query is shown here:</p>
<pre class="console">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (44ms) [Parameters=[@__status_0='?' (Size = 16)], CommandType='Text', CommandTimeout='30']
      SELECT [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]
      WHERE [i].[Status] = @__status_0</pre>
<p>You can<a id="_idIndexMarker496"/> see that the <code>Where()</code> me<a id="_idTextAnchor225"/>thod is translated to the SQL <code>WHERE</code> clause.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor226"/>Sorting and paging</h2>
<p>It is not <a id="_idIndexMarker497"/>always enough to filter the data. We may also want to sort the data based on some properties and return a subset of the data using paging. We can use some methods, such as <code>OrderBy()</code>, <code>OrderByDescending()</code>, <code>Skip()</code>, <code>Take()</code>, and so on, to sort and page the data. Update the <code>GetInvoices</code> action method as<a id="_idIndexMarker498"/> shown here:</p>
<pre class="source-code">
[HttpGet]public async Task&lt;ActionResult&lt;IEnumerable&lt;Invoice&gt;&gt;&gt; GetInvoices(int page = 1, int pageSize = 10, InvoiceStatus? status = null)
{
    // Omitted for brevity
    return await _context.Invoices.AsQueryable().Where(x =&gt; status == null || x.Status == status)
                .OrderByDescending(x =&gt; x.InvoiceDate)
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();
}</pre>
<p>In the preceding code, we use the <code>AsQueryable()</code> method to convert the <code>DbSet&lt;Invoice&gt;</code> to <code>IQueryable&lt;Invoice&gt;</code>. We can use <code>IQueryable</code> to build a query. The <code>Where()</code> and <code>OrderByDescending()</code> methods return a new <code>IQueryable</code> object. So, we can chain the LINQ methods to build a new query. The <code>Where()</code> method is used to filter the data, the <code>OrderByDescending()</code> method is used to sort the data based on the <code>InvoiceDate</code> property in descending order, and the <code>Skip()</code> and <code>Take()</code> methods are used to page the data. The <code>Skip()</code> method skips the first <code>pageSize * (page - 1)</code> records, and the <code>Take()</code> method returns the next <code>pageSize</code> records. At the end of the statement, the <code>ToListAsync()</code> method executes the query and returns the result.</p>
<p>In fact, the <code>AsQueryable()</code> method is not required here because the <code>DbSet&lt;TEntity&gt;</code> class implements the <code>IQueryble&lt;TEntity&gt;</code> interface, which means the <code>DbSet&lt;Invoice&gt;</code> property is already an <code>IQueryable</code> object. We can chain<a id="_idIndexMarker499"/> the <a id="_idIndexMarker500"/>LINQ methods directly.</p>
<p class="callout-heading">What is IQueryable?</p>
<p class="callout">When we <a id="_idIndexMarker501"/>use some LINQ methods, such as <code>Where()</code>, <code>OrderBy()</code>, <code>Skip()</code>, and <code>Take()</code>, EF Core will not execute the query immediately. It will build a query and return a new <code>IQueryable</code> object. <code>IQueryable</code> is an interface in the <code>System.Linq</code> namespace that represents a queryable collection of entities that can be used to compose a query against a specific data source, such as a database. It allows us to build complex queries by chaining the LINQ methods, but it postpones the query execution until the very last moment when the result is needed. Generally, when we call the <code>ToListAsync()</code> method, the query will be translated to a server-specific query language, such as SQL, and executed against the database. This can improve the performance of the application because we do not need to fetch all the data from the database before we can filter and sort the data.</p>
<p>Run the application using <code>dotnet run</code> and check the Swagger UI, you will see the <code>page</code> and <code>pageSize</code> parameters are added to the <code>/api/Invoices</code> endpoint. You can use the parameters to page the invoices as follows:</p>
<div><div><img alt="Figure 5.3 – Sorting and paging the invoices" src="img/B18971_05_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Sorting and paging the invoices</p>
<p>The <a id="_idIndexMarker502"/>generated <a id="_idIndexMarker503"/>SQL query is shown here:</p>
<pre class="source-code">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (40ms) [Parameters=[@__status_0='?' (Size = 16) (DbType = AnsiString), @__p_1='?' (DbType = Int32), @__p_2='?' (DbType = Int32)], CommandType='Text', CommandTimeout='30']
      SELECT [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]
      WHERE [i].[Status] = @__status_0
      ORDER BY [i].[InvoiceDate] DESC
      OFFSET @__p_1 ROWS FETCH NEXT @__p_2 ROWS ONLY</pre>
<p>Note that <a id="_idIndexMarker504"/>the SQL statement uses the <code>OFFSET/FETCH</code> clause to <a id="_idIndexMarker505"/>page the data. These keywords are supported by SQL Server but may not be supported by other databases. For example, MySQL uses the <code>LIMIT</code> clause to page the data. EF Core can eliminate the differences between different databases. It will translate the LINQ query to the correct SQL statement for the database. In this way, developers can focus on writing the LINQ query in a dat<a id="_idTextAnchor227"/>abase-agnostic way. That is the beauty of EF Core.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor228"/>Creating an entity</h2>
<p>Next, let’s see<a id="_idIndexMarker506"/> how to create a new invoice. Check the code of the <code>PostInvoice</code> action method:</p>
<pre class="source-code">
[HttpPost]public async Task&lt;ActionResult&lt;Invoice&gt;&gt; PostInvoice(Invoice invoice)
{
    if (_context.Invoices == null)
    {
        return Problem("Entity set 'InvoiceDbContext.Invoices'  is null.");
    }
    _context.Invoices.Add(invoice);
    await _context.SaveChangesAsync();
    return CreatedAtAction("GetInvoice", new { id = invoice.Id }, invoice);</pre>
<p>}The <code>PostInvoice</code> action method accepts an <code>Invoice</code> object as the request body. It uses the <code>Add()</code> method to add the invoice to the <code>Invoices</code> entity set. Note that this change occurs in the memory. The data will not be added to the database until the <code>SaveChangesAsync()</code> method is called to save the changes to the database. The <code>CreatedAtAction()</code> method returns a <code>201 Created</code> response with the location of the newly created invoice. You can return a <code>200 OK</code> response instead but it is recommended to return a <code>201 Created</code> response for the creation of a new resource.</p>
<p>You can<a id="_idIndexMarker507"/> send a <code>POST</code> request to the <code>/api/invoices</code> endpoint to create a new invoice and see how the SQL statement is generated from the logs. It should be similar to the following:</p>
<pre class="console">
 info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (3ms) [Parameters=[@p0='?' (DbType = Guid), @p1='?' (Precision = 18) (Scale = 2) (DbType = Decimal), @p2='?' (Size = 32), @p3='?' (Size = 256), @p4='?' (DbType = DateTimeOffset), @p5='?' (DbType = DateTimeOffset), @p6='?' (Size = 32) (DbType = AnsiString), @p7='?' (Size = 16) (DbType = AnsiString)], CommandType='Text', CommandTimeout='30']
      SET IMPLICIT_TRANSACTIONS OFF;
      SET NOCOUNT ON;
      INSERT INTO [Invoices] ([Id], [Amount], [ContactName], [Description], [DueDate], [InvoiceDate], [InvoiceNumber], [Status])
      VALUES (@p0, @p1, @p2, @p3, @p4, @p5, @p6, @p7);</pre>
<p class="callout-heading">Important note</p>
<p class="callout">The JSON body for the <code>POST</code> action does not need to contain the <code>Id</code> property. EF Core<a id="_idTextAnchor229"/> will generate a new <code>Guid</code> value for the <code>Id</code> property.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor230"/>Updating an entity</h2>
<p>To update<a id="_idIndexMarker508"/> an entity, we use the <code>Put</code> request. The code of the <code>PutInvoice</code> action method is shown here:</p>
<pre class="source-code">
[HttpPut("{id}")]public async Task&lt;IActionResult&gt; PutInvoice(Guid id, Invoice invoice)
{
    if (id != invoice.Id)
    {
        return BadRequest();
    }
    _context.Entry(invoice).State = EntityState.Modified;
    try
    {
        await _context.SaveChangesAsync();
    }
    catch (DbUpdateConcurrencyException)
    {
        if (!InvoiceExists(id))
        {
            return NotFound();
        }
        else
        {
            throw;
        }
    }
    return NoContent();
}</pre>
<p>The <code>PutInvoice</code> action method accepts the <code>id</code> parameter and the <code>Invoice</code> object as the request body. If you check the Swagger UI, you will see the <code>id</code> parameter is defined in the URL but the <code>Invoice</code> object is defined in the request body. This is because <code>Invoice</code> is not a primitive type, so ASP.NET Core can only get it from the request body. We discussed this in the <em class="italic">Binding source attributes</em> section in <a href="B18971_03.xhtml#_idTextAnchor130"><em class="italic">Chapter 3</em></a>.</p>
<p>Next, we <a id="_idIndexMarker509"/>use the <code>_context.Entry()</code> method to get the <code>EntityEntry</code> object of the invoice. Then, we set the <code>State</code> property to <code>EntityState.Modified</code>. It seems that the <code>EntityState</code> enum plays an important role here. What is the <code>EntityState</code> enum?</p>
<p>In EF Core, each instance of <code>DbContext</code> has a <code>ChangeTracker</code> to track the changes in the entities, which is a powerful feature of EF Core. In other words, EF Core knows the state of each entity – whether it is added, deleted, or modified. When we update the entity, we just update the entity in the memory. EF Core can track the changes. When the <code>SaveChangesAsync()</code> method is called, it will generate the SQL statement to update the data in the database.</p>
<p>The <code>EntityState</code> enum can have the following values:</p>
<ul>
<li><code>Detached</code>: The entity is not being tracked by the context.</li>
<li><code>Unchanged</code>: The entity is being tracked by the context, but the values are not changed.</li>
<li><code>Deleted</code>: The entity is being tracked and exists in the database, but it has been marked for deletion. So, when the <code>SaveChangesAsync()</code> method is called, EF Core will generate the SQL statement to delete the entity from the database.</li>
<li><code>Modified</code>: The entity is being tracked and exists in the database, and the values have been modified in <code>DbContext</code>. When the <code>SaveChangesAsync()</code> method is called, EF Core will generate the SQL statement to update the entity in the database.</li>
<li><code>Added</code>: The entity is being tracked but it does not exist in the database. When the <code>SaveChangesAsync()</code> method is called, EF Core will generate the SQL statement to insert the entity into the database.</li>
</ul>
<p>In the <em class="italic">Creating an entity</em> section, we used the <code>Add()</code> method to add the entity to the entity set. This is equivalent to setting the <code>State</code> property to <code>Added</code>, such as in the following code:</p>
<pre class="source-code">
//_context.Invoices.Add(invoice); This is equivalent to the following code_context.Entry(invoice).State = EntityState.Added;
await _context.SaveChangesAsync();</pre>
<p>Similar to<a id="_idIndexMarker510"/> the <code>Add()</code> method, changing the state of the entity does not modify the data in the database. You must call the <code>SaveChangesAsync()</code> method to save the changes to the database.</p>
<p>Let's try to call the <code>PutInvoice</code> action method to update an invoice. Send a <code>PUT</code> request to the <code>/api/invoices/{id}</code> endpoint in the Swagger UI. The request body is like this:</p>
<pre class="source-code">
{  "id": "0d501380-83d9-44f4-9087-27c8f09082f9",
  "invoiceNumber": "INV-001",
  "contactName": "Spider Man",
  "description": "Invoice for the first month",
  "amount": 100,
  "invoiceDate": "2023-01-01T00:00:00+00:00",
  "dueDate": "2023-01-15T00:00:00+00:00",
  "status": 1
}</pre>
<p>Please update the JSON body to change the <code>contactName</code> property only. The SQL statement generated by EF Core is shown here:</p>
<pre class="console">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (39ms) [Parameters=[@p7='?' (DbType = Guid), @p0='?' (Precision = 18) (Scale = 2) (DbType = Decimal), @p1='?' (Size = 32), @p2='?' (Size = 4000), @p3='?' (DbType = DateTimeOffset), @p4='?' (DbType = DateTimeOffset), @p5='?' (Size = 32) (DbType = AnsiString), @p6='?' (Size = 16) (DbType = AnsiString)], CommandType='Text', CommandTimeout='30']
      SET IMPLICIT_TRANSACTIONS OFF;
      SET NOCOUNT ON;
      UPDATE [Invoices] SET [Amount] = @p0, [ContactName] = @p1, [Description] = @p2, [DueDate] = @p3, [InvoiceDate] = @p4, [InvoiceNumber] = @p5, [Status] = @p6
      OUTPUT 1
      WHERE [Id] = @p7;</pre>
<p>You can see EF Core omits the <code>Id</code> column in the <code>UPDATE</code> statement. This is because the <code>Id</code> column is the primary key of the <code>Invoices</code> table. EF Core knows that it does not need to update the <code>Id</code> column. But EF Core will update the other properties irrespective of whether the values are changed or not because the <code>EntityState</code> of the entity is <code>Modified</code>.</p>
<p>Sometimes <a id="_idIndexMarker511"/>we want to update only the changed properties. For example, if we just want to update the <code>Status</code> property, the SQL statement should not have to update other columns. To do this, we can find the entity that needs to be updated, and then update the properties explicitly. Let us update the <code>PutInvoice</code> action method to do this:</p>
<pre class="source-code">
var invoiceToUpdate = await _context.Invoices.FindAsync(id);if (invoiceToUpdate == null)
{
    return NotFound();
}
invoiceToUpdate.Status = invoice.Status;
await _context.SaveChangesAsync();</pre>
<p>In this example, we first find the entity by the <code>FindAsync()</code> method. Then, we update the <code>Status</code> property. EF Core will mark the <code>Status</code> property as modified. Finally, we call the <code>SaveChangesAsync()</code> method to save the changes to the database. You can see the generated SQL statement only updates the <code>Status</code> property, which <a id="_idIndexMarker512"/>is like this:</p>
<pre class="console">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (2ms) [Parameters=[@__get_Item_0='?' (DbType = Guid)], CommandType='Text', CommandTimeout='30']
      SELECT TOP(1) [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]
      WHERE [i].[Id] = @__get_Item_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (2ms) [Parameters=[@p1='?' (DbType = Guid), @p0='?' (Size = 16) (DbType = AnsiString)], CommandType='Text', CommandTimeout='30']
      SET IMPLICIT_TRANSACTIONS OFF;
      SET NOCOUNT ON;
      UPDATE [Invoices] SET [Status] = @p0
      OUTPUT 1
      WHERE [Id] = @p1;</pre>
<p>However, in an actual scenario, normally, the endpoint will receive the whole entity, not just the changed properties. We may not know which properties are changed. In this case, we can just update all the properties in the code. EF Core can track the state of the entity, so it is smart enough to determine which properties are changed. Let us update the <code>PutInvoice</code> action method to explicitly update all the properties:</p>
<pre class="source-code">
// Omitted for brevityvar invoiceToUpdate = await _context.Invoices.FindAsync(id);
if (invoiceToUpdate == null)
{
    return NotFound();
}
invoiceToUpdate.InvoiceNumber = invoice.InvoiceNumber;
invoiceToUpdate.ContactName = invoice.ContactName;
invoiceToUpdate.Description = invoice.Description;
invoiceToUpdate.Amount = invoice.Amount;
invoiceToUpdate.InvoiceDate = invoice.InvoiceDate;
invoiceToUpdate.DueDate = invoice.DueDate;
invoiceToUpdate.Status = invoice.Status;
await _context.SaveChangesAsync();
// Omitted for brevity</pre>
<p>Send a <code>PUT</code> request to the <code>/api/Invoices/{id}</code> endpoint and attach a JSON body to the <a id="_idIndexMarker513"/>request. If you just update the <code>Status</code> and <code>Description</code> properties, the SQL statement will be like this:</p>
<pre class="console">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (17ms) [Parameters=[@p2='?' (DbType = Guid), @p0='?' (Size = 256), @p1='?' (Size = 16) (DbType = AnsiString)], CommandType='Text', CommandTimeout='30']
      SET IMPLICIT_TRANSACTIONS OFF;
      SET NOCOUNT ON;
      UPDATE [Invoices] SET [Description] = @p0, [Status] = @p1
      OUTPUT 1
      WHERE [Id] = @p2;</pre>
<p>The preceding SQL statement slightly improves the performance because it only updates the changed properties. It might not be a big deal for a small table, but if you have a large table that has many columns, it will be a good practice. However, it needs a <code>SELECT</code> statement to get the entity first. Choose the way that suits your scenario.</p>
<p>There is an issue in<a id="_idIndexMarker514"/> the preceding code. If the entity has many properties, it will be tedious to update all the properties one by one. In this case, we can use the <code>Entry</code> method to get the <code>EntityEntry</code> object and then set the <code>CurrentValues</code> property to the new values. Let us update the <code>PutInvoice</code> action method to use the <code>Entry</code> method:</p>
<pre class="source-code">
// Update only the properties that have changed _context.Entry(invoiceToUpdate).CurrentValues.SetValues(invoice);</pre> <p>The <code>SetValues()</code> method will set all the properties of the entity to the new values. EF Core can detect the changes and mark the properties that have changed as <code>Modified</code>. So, we do not need to manually set each property. This way is a good practice when updating an entity that has many properties. Also, the object used to update the properties does not have to be the same type as the entity. It is useful in a layered application. For example, the entity received from the client is a <strong class="bold">Data Transfer Object</strong> (<strong class="bold">DTO</strong>) object, and <a id="_idIndexMarker515"/>the entity in the database is a domain object. In this case, EF Core will update the properties that match the names of the properties in the DTO object.</p>
<p>Note that the <code>SetValues()</code> method only updates the simple properties, such as <code>string</code>, <code>int</code>, <code>decimal</code>, <code>DateTime</code>, and so on. If the entity has a navigation property, the <code>SetValues()</code> method will not update the navigation property. In this case, we need to update the properties explicitly.</p>
<p>Test the <code>/api/Invoices/{id}</code> endpoint by sending a <code>PUT</code> request again. You can see<a id="_idTextAnchor231"/> the generated SQL statement is similar to the previous one.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor232"/>Deleting an entity</h2>
<p>In the <a id="_idIndexMarker516"/>generated code of the <code>DeleteInvoice</code> action method, we can see the following code:</p>
<pre class="source-code">
[HttpDelete("{id}")]public async Task&lt;IActionResult&gt; DeleteInvoice(Guid id)
{
    if (_context.Invoices == null)
    {
        return NotFound();
    }
    var invoice = await _context.Invoices.FindAsync(id);
    if (invoice == null)
    {
        return NotFound();
    }
    _context.Invoices.Remove(invoice);
    await _context.SaveChangesAsync();
    return NoContent();
}</pre>
<p>The logic is to<a id="_idIndexMarker517"/> find the entity first, and then remove it from <code>DbSet</code> using the <code>Remove()</code> method. Finally, we call the <code>SaveChangesAsync()</code> method to save the changes to the database. If you understand <code>EntityState</code> already, you might know that the <code>Remove()</code> method is equivalent to setting <code>EntityState</code> to <code>Deleted</code>, as follows:</p>
<pre class="source-code">
_context.Entry(invoice).State = EntityState.Deleted;</pre> <p>The generated SQL statement is like this:</p>
<pre class="console">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (2ms) [Parameters=[@__get_Item_0='?' (DbType = Guid)], CommandType='Text', CommandTimeout='30']
      SELECT TOP(1) [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]
      WHERE [i].[Id] = @__get_Item_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (3ms) [Parameters=[@p0='?' (DbType = Guid)], CommandType='Text', CommandTimeout='30']
      SET IMPLICIT_TRANSACTIONS OFF;
      SET NOCOUNT ON;
      DELETE FROM [Invoices]
      OUTPUT 1
      WHERE [Id] = @p0;</pre>
<p>As you can see, EF Core <a id="_idIndexMarker518"/>generates two SQL statements, which seems a little bit unnecessary to find the entity first. When we delete an entity, the only thing we need is the primary key. So, we can update the <code>DeleteInvoice()</code> action like this:</p>
<pre class="source-code">
// Omitted for brevityvar invoice = new Invoice { Id = id };
_context.Invoices.Remove(invoice);
await _context.SaveChangesAsync();
// Omitted for brevity</pre>
<p>Now, the SQL statement is as follows:</p>
<pre class="console">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (2ms) [Parameters=[@p0='?' (DbType = Guid)], CommandType='Text', CommandTimeout='30']
      SET IMPLICIT_TRANSACTIONS OFF;
      SET NOCOUNT ON;
      DELETE FROM [Invoices]
      OUTPUT 1
      WHERE [Id] = @p0;</pre>
<p>It is much simpler than the previous one.</p>
<p>From EF Core 7.0, we<a id="_idIndexMarker519"/> have a new method called <code>ExecuteDeleteAsync()</code> that can be used to delete an entity without loading it first. The code is as follows:</p>
<pre class="source-code">
await _context.Invoices.Where(x =&gt; x.Id == id).ExecuteDeleteAsync();</pre> <p class="callout-heading">Important note</p>
<p class="callout">The <code>ExecuteDeleteAsync()</code> method does not involve the change tracker, so it will execute the SQL statement immediately to the database. It does not need to call the <code>SaveChangesAsync()</code> method at the end. It is a recommended way to delete one entity (or more) from EF Core 7.0 and later versions. However, if the entity already exists in <code>DbContext</code> and is tracked by the change tracker, executing the SQL statement directly may cause the data in <code>DbContext</code> and the database to be inconsistent. In this case, you may need to use the <code>Remove()</code> method or set the <code>EntityState</code> property to <code>Deleted</code> to delete the entity from <code>DbContext</code>. Please consider your scenario carefully before using the <code>ExecuteDeleteAsync()</code> method.</p>
<p>You must be wondering how EF Core knows the names of columns and tables in the database. We will talk about the configu<a id="_idTextAnchor233"/>ration and see how EF Core maps the models to the database next.</p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor234"/>Configuring the mapping between models and database</h1>
<p>ORM, as <a id="_idIndexMarker520"/>the name suggests, is used to map the objects to the relational database. EF Core uses the mapping configuration to map the models to the database. In the previous section, we saw that we did not configure any mappings; however, EF Core could still map the models to the database automatically. This is because EF Core has a set of built-in conventions to configure the mappings. We can also explicitly customize the configuration to meet our needs. In this section, we will discuss the configuration in EF Core, includi<a id="_idTextAnchor235"/>ng the following:</p>
<ul>
<li>Mapping conventions</li>
<li>Data annotations</li>
<li>Fluent API</li>
</ul>
<h2 id="_idParaDest-121"><a id="_idTextAnchor236"/>Mapping conventions</h2>
<p>There are <a id="_idIndexMarker521"/>some conventions in EF Core for mapping the models to the database:</p>
<ul>
<li>The database uses the <code>dbo</code> schema by default.</li>
<li>The table name is the plural form of the model name. For example, we have a <code>DbSet&lt;Invoice&gt; Invoices</code> property in the <code>InvoiceDbContext</code> class, so the table name is <code>Invoices</code>.</li>
<li>The column name is the property name.</li>
<li>The data type of the column is based on the property type and the database providers. Here is a list of the default mapping for some common C# types in SQL Server:</li>
</ul>
<table class="No-Table-Style _idGenTablePara-1" id="table001-5">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">.</strong><strong class="bold">NET type</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">SQL Server </strong><strong class="bold">data type</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>int</code></p>
</td>
<td class="No-Table-Style">
<p><code>int</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>long</code></p>
</td>
<td class="No-Table-Style">
<p><code>bigint</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>string</code></p>
</td>
<td class="No-Table-Style">
<p><code>nvarchar(max)</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>bool</code></p>
</td>
<td class="No-Table-Style">
<p><code>bit</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>datetime</code></p>
</td>
<td class="No-Table-Style">
<p><code>datetime</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>double</code></p>
</td>
<td class="No-Table-Style">
<p><code>float</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>decimal</code></p>
</td>
<td class="No-Table-Style">
<p><code>decimal(18,2)</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>byte</code></p>
</td>
<td class="No-Table-Style">
<p><code>tinyint</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>short</code></p>
</td>
<td class="No-Table-Style">
<p><code>smallint</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>byte[]</code></p>
</td>
<td class="No-Table-Style">
<p><code>varbinary(max)</code></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.1 – Default mapping for some common C# types in SQL Server</p>
<ul>
<li>If a property is named <code>Id</code> or <code>&lt;entity name&gt;Id</code>, EF Core will map it to the primary key.</li>
<li>If EF Core detects that the relationship between two models is one-to-many, it will map the navigation property to a foreign key column in the database automatically.</li>
<li>If a<a id="_idIndexMarker522"/> column is a primary key, EF Core will create a clustered index for it automatically.</li>
<li>If a column is a foreign key, EF Core will create a non-clustered index for it automatically.</li>
<li>An <code>enum</code> type is mapped to the underlying type of the enum. For example, the <code>InvoiceStatus</code> enum is mapped to the <code>int</code> type in the database.</li>
</ul>
<p>However, sometimes we need to refine the mapping. For example, we may want to use the <code>varchar(100)</code> column instead of the <code>nvarchar(max)</code> column for a <code>string</code> property. We may also want to save enums as strings in the database instead of <code>int</code> values. In such cases, we<a id="_idIndexMarker523"/> can override the default conventions to customize the mapping based on our needs.</p>
<p>There are two ways to explicitly configure the mapping between the models and the database:</p>
<ul>
<li>Data annotations</li>
<li>Fluent API</li>
</ul>
<p>Let us see how to use data annotations and Fluent API to customize the mapping<a id="_idTextAnchor237"/>.</p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor238"/>Data annotations</h2>
<p>Data annotations <a id="_idIndexMarker524"/>are attributes that you can apply to the model classes to customize the mapping. For example, you can use the <code>Table</code> attribute to specify the table name and use the <code>Column</code> attribute to specify the column name. The following code shows how to use data annotations to customize the mapping:</p>
<pre class="source-code">
[Table("Invoices")]public class Invoice
{
    [Column("Id")]
    [Key]
    public Guid Id { get; set; }
    [Column(name: "InvoiceNumber", TypeName = "varchar(32)")]
    [Required]
    public string InvoiceNumber { get; set; } = string.Empty;
    [Column(name: "ContactName")]
    [Required]
    [MaxLength(32)]
    public string ContactName { get; set; } = string.Empty;
    [Column(name: "Description")]
    [MaxLength(256)]
    public string? Description { get; set; }
    [Column("Amount")]
    [Precision(18, 2)]
    [Range(0, 9999999999999999.99)]
    public decimal Amount { get; set; }
    [Column(name: "InvoiceDate", TypeName = "datetimeoffset")]
    public DateTimeOffset InvoiceDate { get; set; }
    [Column(name: "DueDate", TypeName = "datetimeoffset")]
    public DateTimeOffset DueDate { get; set; }
    [Column(name: "Status", TypeName = "varchar(16)")]
    public InvoiceStatus Status { get; set; }
}</pre>
<p>In the <a id="_idIndexMarker525"/>preceding code, each property has one or more data annotations. These data annotations are attributes that you can apply to the model classes to customize the mapping. You can specify some mapping information, such as the table name, column name, column data type, and so on.</p>
<p>Here is a list of the most <a id="_idIndexMarker526"/>commonly used data annotations:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-4">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Attribute</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Table</code></p>
</td>
<td class="No-Table-Style">
<p>The table name that the model class is mapped to.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Column</code></p>
</td>
<td class="No-Table-Style">
<p>The column name in the table that a property is mapped to. You can also specify the column data type using the <code>TypeName</code> property.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Key</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies the property as a key.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>ForeignKey</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies the property as a foreign key.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>NotMapped</code></p>
</td>
<td class="No-Table-Style">
<p>The model or property is not mapped to the database.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Required</code></p>
</td>
<td class="No-Table-Style">
<p>The value of the property is required.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>MaxLength</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies the maximum length of the value in the database. Applied to string or array values only.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Index</code></p>
</td>
<td class="No-Table-Style">
<p>Creates an index on the column that the property is mapped to.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Precision</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies the precision and scale of the property if the database supports precision and scale facets.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>DatabaseGenerated</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies how the database should generate the values for the property. If you use <code>int</code> or <code>long</code> as the primary key for an entity, you can use this attribute and set <code>DatabaseGeneratedOption</code> as <code>Identity</code>, such as <code>[DatabaseGenerated(DatabaseGeneratedOption.Identity)]</code>.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>TimeStamp</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies the property is used for concurrency management. The property will map to a <code>rowversion</code> type in SQL Server. The implementation may vary in different database providers.</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.2 – Commonly used data annotations</p>
<p>In this way, the<a id="_idIndexMarker527"/> mapping configuration is embedded in the model classes. It is easy to understand, but it is a little bit intrusive, which means the model classes are polluted with the database-related configuration. To decouple the model classes from the database mapping configuration, we can use Fluent API.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Every time the mapping is changed, you need to run the <code>dotnet ef migrations add &lt;migration name&gt;</code> command to generate a new migration. Then, run the <code>dotnet ef database update</code> command to update the database.<a id="_idTextAnchor239"/></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor240"/>Fluent API</h2>
<p>Fluent API is a <a id="_idIndexMarker528"/>set of extension methods that you can use to configure the mappings gracefully. It is the most flexible and powerful way to apply the mapping configuration without polluting the model classes. Another important thing to note is that Fluent API has a higher priority than data annotations. If you configure the same property in both data annotations and Fluent API, Fluent API will override the data annotations. So, Fluent API is the recommended way to configure the mapping.</p>
<p>Fluent API is applied in the order of the method calls. If there are two calls to configure the same property, the latest call will override the previous configuration.</p>
<p>To use Fluent API, we need to override the <code>OnModelCreating()</code> method in the derived <code>DbContext</code> class. The following code shows how to use Fluent API to configure the mapping:</p>
<pre class="source-code">
protected override void OnModelCreating(ModelBuilder modelBuilder){
    // Seed data is omitted for brevity
    modelBuilder.Entity&lt;Invoice&gt;(b =&gt;
    {
        b.ToTable("Invoices");
        b.HasKey(i =&gt; i.Id);
        b.Property(p =&gt; p.Id).HasColumnName("Id");
        b.Property(p =&gt; p.InvoiceNumber).HasColumnName("InvoiceNumber").HasColumnType("varchar(32)").IsRequired();
        b.Property(p =&gt; p.ContactName).HasColumnName("ContactName").HasMaxLength(32).IsRequired();
        b.Property(p =&gt; p.Description).HasColumnName("Description").HasMaxLength(256);
        // b.Property(p =&gt; p.Amount).HasColumnName("Amount").HasColumnType("decimal(18,2)").IsRequired();
        b.Property(p =&gt; p.Amount).HasColumnName("Amount").HasPrecision(18, 2);
        b.Property(p =&gt; p.InvoiceDate).HasColumnName("InvoiceDate").HasColumnType("datetimeoffset").IsRequired();
        b.Property(p =&gt; p.DueDate).HasColumnName("DueDate").HasColumnType("datetimeoffset").IsRequired();
        b.Property(p =&gt; p.Status).HasColumnName("Status").HasMaxLength(16).HasConversion(
                v =&gt; v.ToString(),
                v =&gt; (InvoiceStatus)Enum.Parse(typeof(InvoiceStatus), v));
    });
}</pre>
<p>In the preceding code, we use the <code>Entity()</code> method to configure the <code>Invoice</code> entity. This method <a id="_idIndexMarker529"/>accepts an <code>Action&lt;EntityTypeBuilder&lt;TEntity&gt;&gt;</code> parameter to specify the mappings. The <code>EntityTypeBuilder&lt;TEntity&gt;</code> class has a lot of methods to configure the entity, such as table name, column name, column data type, and so on. You can chain these methods in a fluent way to configure the entity, so it is called Fluent API.</p>
<p>Here is a list of the most <a id="_idIndexMarker530"/>commonly used Fluent API methods:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table003-4">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Method</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Equivalent </strong><strong class="bold">data annotation</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>HasDefaultSchema()</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies the database schema. The default schema is <code>dbo</code>.</p>
</td>
<td class="No-Table-Style">
<p>N/A</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>ToTable()</code></p>
</td>
<td class="No-Table-Style">
<p>The table name that the model class is mapped to.</p>
</td>
<td class="No-Table-Style">
<p><code>Table</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>HasColumnName()</code></p>
</td>
<td class="No-Table-Style">
<p>The column name in the table that a property is mapped to.</p>
</td>
<td class="No-Table-Style">
<p><code>Column</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>HasKey()</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies the property as a key.</p>
</td>
<td class="No-Table-Style">
<p><code>Key</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Ignore()</code></p>
</td>
<td class="No-Table-Style">
<p>Ignores a model or a property from the mapping. This method can be applied on an entity level or a property level.</p>
</td>
<td class="No-Table-Style">
<p><code>NotMapped</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>IsRequired()</code></p>
</td>
<td class="No-Table-Style">
<p>The value of the property is required.</p>
</td>
<td class="No-Table-Style">
<p><code>Required</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>HasColumnType()</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies the data type of the column that the property is mapped to.</p>
</td>
<td class="No-Table-Style">
<p><code>Column</code> with the <code>TypeName</code> property</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>HasMaxLength()</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies the maximum length of the value in the database. Applied to a string or array only.</p>
</td>
<td class="No-Table-Style">
<p><code>MaxLength</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>HasIndex()</code></p>
</td>
<td class="No-Table-Style">
<p>Creates an index on the specific property.</p>
</td>
<td class="No-Table-Style">
<p><code>Index</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>IsRowVersion()</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies the property is used for concurrency management. The property will map to a <code>rowversion</code> type in SQL Server. The implementation may vary in different database providers.</p>
</td>
<td class="No-Table-Style">
<p><code>TimeStamp</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>HasDefaultValue()</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies a default value for a column. The value must be a constant.</p>
</td>
<td class="No-Table-Style">
<p>N/A</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>HasDefaultValueSql()</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies a SQL expression to generate the default value for a column, such as <code>GetUtcDate()</code>.</p>
</td>
<td class="No-Table-Style">
<p>N/A</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>HasConversion()</code></p>
</td>
<td class="No-Table-Style">
<p>Defines a value converter to map the property to the column data type. It contains two <code>Func</code> expressions to convert the values.</p>
</td>
<td class="No-Table-Style">
<p>N/A</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>ValueGeneratedOnAdd()</code></p>
</td>
<td class="No-Table-Style">
<p>Specifies the value of the property to be generated by the database when a new entity is added. EF Core will ignore this property when inserting a record.</p>
</td>
<td class="No-Table-Style">
<p><code>DatabaseGenerated</code> with the <code>DatabaseGeneratedOption.Identity</code> option</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.3 – Commonly used Fluent API methods</p>
<p>There are some other methods <a id="_idIndexMarker531"/>to configure the relationships using Fluent API, such as <code>HasOne()</code>, <code>HasMany()</code>, <code>WithOne()</code>, <code>WithMany()</code>, and so on. We will cover them in the next chapter.<a id="_idTextAnchor241"/></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor242"/>Separating the mapping configurations</h2>
<p>In a<a id="_idIndexMarker532"/> large project, there may be a lot of model classes. If we put all the mapping configurations in the <code>OnModelCreating()</code> method, the method will be very long and hard to maintain. To make the code more readable and maintainable, we can extract the mapping configuration to one class or a couple of separate classes.</p>
<p>One way to do this is to create an extension method for the <code>ModelBuilder</code> class. Create a new class named <code>InvoiceModelCreatingExtensions</code> in the <code>Data</code> folder. Then, add the following code to the class:</p>
<pre class="source-code">
public static class InvoiceModelCreatingExtensions{
    public static void ConfigureInvoice(this ModelBuilder builder)
    {
        builder.Entity&lt;Invoice&gt;(b =&gt;
        {
            b.ToTable("Invoices");
            // Other mapping configurations are omitted for brevity
        });
    }
}
// You can continue to create the mapping for other entities, or create separate files for each entity.</pre>
<p>Then, in<a id="_idIndexMarker533"/> the <code>OnModelCreating()</code> method, call the extension method:</p>
<pre class="source-code">
modelBuilder.ConfigureInvoice();// You can continue to call the extension methods for other entities. such as
// modelBuilder.ConfigureInvoiceItem();</pre>
<p>Now, the <code>OnModelCreating()</code> method is much cleaner and easier to read.</p>
<p>Another way to separate the mapping configurations is to implement the <code>IEntityTypeConfiguration&lt;TEntity&gt;</code> interface. Create a new class named <code>InvoiceConfiguration</code> in the <code>Data</code> folder. Then, add the following code to the class:</p>
<pre class="source-code">
public class InvoiceConfiguration : IEntityTypeConfiguration&lt;Invoice&gt;{
    public void Configure(EntityTypeBuilder&lt;Invoice&gt; builder)
    {
        builder.ToTable("Invoices");
        // Other mapping configurations are omitted for brevity
    }
}</pre>
<p>Then, in<a id="_idIndexMarker534"/> the <code>OnModelCreating()</code> method, there are two ways to apply the configuration:</p>
<ul>
<li>If you use the <code>ApplyConfiguration()</code> method, add the following code to the <code>OnModelCreating()</code> method:<pre class="source-code">
modelBuilder.ApplyConfiguration(new InvoiceConfiguration());// You can continue to call the ApplyConfiguration method for other entities. such as// modelBuilder.ApplyConfiguration(new InvoiceItemConfiguration());</pre></li> <li>Or you can call the <code>Configure()</code> method directly:<pre class="source-code">
new InvoiceConfiguration().Configure(modelBuilder.Entity&lt;Invoice&gt;());// You can continue to call the Configure method for other entities. such as// new InvoiceItemConfiguration().Configure(modelBuilder.Entity&lt;InvoiceItem&gt;());</pre></li> </ul>
<p>As the <a id="_idIndexMarker535"/>project grows, it might be a little bit tedious to call the mapping configuration for each entity. In this case, EF Core has a method called <code>ApplyConfigurationsFromAssembly()</code> to apply all the configurations in the assembly, as shown in the following code:</p>
<pre class="source-code">
modelBuilder.ApplyConfigurationsFromAssembly(typeof(InvoiceDbContext).Assembly);</pre> <p>You can choose the one that fits your project best. One reminder is that if you use the <code>ApplyConfigurationsFromAssembly()</code> method, you need to make sure that all the configuration classes are in the same assembly as the <code>DbContext</code> class. Also, you cannot control the order of the configurations. If the order matters, you need to call each configuration explicitly in the correct order.</p>
<p>After you run the <code>dotnet ef migrations add &lt;migration name&gt;</code> command, you can find that the generated migration file has the following code:</p>
<pre class="source-code">
migrationBuilder.AlterColumn&lt;string&gt;(    name: "Status",
    table: "Invoices",
    type: "varchar(16)",
    nullable: false,
    oldClrType: typeof(int),
    oldType: "int");
migrationBuilder.AlterColumn&lt;string&gt;(
    name: "InvoiceNumber",
    table: "Invoices",
    type: "varchar(32)",
    nullable: false,
    oldClrType: typeof(string),
    oldType: "nvarchar(max)");</pre>
<p>The preceding snippet shows that the <code>Status</code> property is changed from <code>int</code> to <code>varchar(16)</code>, and the <code>InvoiceNumber</code> property is changed from <code>nvarchar(max)</code> to <code>varchar(32)</code>. Then, you can run the <code>dotnet ef database update</code> command to update the database. You will see the <code>Status</code> column is stored as strings.</p>
<p class="callout-heading">Important note</p>
<p class="callout">During the migration, the data may get lost if the data type is changed. For example, if the data type is changed from <code>nvarchar(max)</code> to <code>varchar(32)</code>, the original data will be truncated to 32 characters. Please make sure you understand the data type change before you run the migration.</p>
<p>It is <a id="_idIndexMarker536"/>recommended to explicitly configure the mapping for each entity in order to ensure optimal performance. For example, <code>nvarchar(max)</code> requires more storage space than <code>varchar</code>, so the default mapping configuration may not be the most efficient. Additionally, the default <code>dbo</code> database schema may not be suitable for your particular scenario. Therefore, explicitly configuring the mapping is a recommended prac<a id="_idTextAnchor243"/>tice.</p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor244"/>Summary</h1>
<p>In this chapter, we learned how to access the database using EF Core. We implemented CRUD operations using the <code>DbContext</code> class. We introduced some basic LINQ queries, such as query, filter, sort, create, update, and delete. We also learned how to configure the mapping using data annotations and Fluent API. With the knowledge gained in this chapter, you can build a simple application to access the database.</p>
<p>However, the application we built in this chapter is quite basic and only has one entity. In a real-world project, there are usually multiple entities and relationships between them.</p>
<p>In the next chapter, we will learn how to configure relationshiseps between entities using EF Core.</p>
</div>
</body></html>