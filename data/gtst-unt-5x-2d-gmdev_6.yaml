- en: Chapter 6. Through a Sea of Sprinkles – Navigation in Artificial Intelligence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 穿越糖霜之海 – 人工智能中的导航
- en: After having given a rendering ([Chapter 4](part0056.xhtml#aid-1LCVG1 "Chapter 4. No
    Longer Alone – Sweet-Toothed Pandas Strike"), *No Longer Alone – Sweet-Toothed
    Pandas Strike*) and a physical shape ([Chapter 5](part0062.xhtml#aid-1R42S1 "Chapter 5. The
    Secret Ingredient Is a Dash of Physics"), *The Secret Ingredient Is a Dash of
    Physics*) to our Pandas, it's now time to give them intelligence. In particular,
    the ability to walk/navigate through the map towards the player's cake to eat
    it. In fact, as we have already pointed out, **artificial intelligence** (**AI**)
    is at the core of giving life to NPCs, so that they can move around and act within
    the world. However, this chapter will focus on navigation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的熊猫赋予渲染（[第4章](part0056.xhtml#aid-1LCVG1 "第4章. 不再孤单 – 甜食熊猫出击")，*不再孤单 – 甜食熊猫出击*）和物理形状（[第5章](part0062.xhtml#aid-1R42S1
    "第5章. 秘密成分是物理学的一点点")，*秘密成分是物理学的一点点*）之后，现在是时候赋予它们智能了。特别是，让它们能够通过地图走向玩家的蛋糕并吃掉它的能力。实际上，正如我们已经指出的，**人工智能**（**AI**）是赋予NPC生命力的核心，使它们能够在世界中移动和行动。然而，本章将专注于导航。
- en: In particular, we will implement a waypoint system for our Pandas. We will do
    it twice, so that we can have two different perspectives on the same thing, and
    we will highlight the advantages and disadvantages of each method.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们将为我们的熊猫实现一个航点系统。我们将做两次，这样我们可以从不同的角度看待同一件事，并突出每种方法的优缺点。
- en: 'Here is an outline of the topics that we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们将要讨论的主题概览：
- en: The importance of AI in video games
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工智能在视频游戏中的重要性
- en: Navigation in video games and an overview of the main techniques
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频游戏中的导航及主要技术概述
- en: Implementing a waypoint system as a static list
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将航点系统作为静态列表实现
- en: Implementing a waypoint system as a dynamic pool of game objects (and display
    them as icons on the map)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将航点系统作为游戏对象的动态池实现（并在地图上显示为图标）
- en: Getting an idea of what's beyond navigation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解导航之外的领域
- en: As in all the other chapters of this book, you can practice your skill at the
    end with the Homework section. So, let's get ready to start!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书的所有其他章节一样，你可以在作业部分练习你的技能。所以，让我们准备开始吧！
- en: Getting ready
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The only requirement for this chapter, is that you have already done all the
    parts of the book that dealt with the `PandaScript` so far.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的唯一要求是，你已经完成了书中所有关于`PandaScript`的部分。
- en: Introduction to artificial intelligence
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能简介
- en: '**Artificial intelligence** (**AI**) is an extensive topic, even if we limit
    ourselves just to video games. In fact, due to its complexity, it''s one of the
    hardest parts to program for a video game. A good AI programmer should have knowledge
    of math (such as graph theory, Bayesian networks, operational research, and so
    on), physics (such as the motion equations) and psychology (to understand how
    the player reacts to AI in the game). Whereas the first two are well known, the
    last one is sometimes neglected, but is just as equally important. In fact, sometimes
    the most believable behavior of an NPC character is not the most enjoyable for
    the player. If you are interested in learning more, I wrote an article that you
    can find on my website at [francescosapio.com](http://francescosapio.com/)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**人工智能**（**AI**）是一个广泛的话题，即使我们只限制在视频游戏领域。实际上，由于其复杂性，它是视频游戏编程中最难的部分之一。一个优秀的AI程序员应该具备数学（如图论、贝叶斯网络、运筹学等）、物理（如运动方程）和心理（以理解玩家对游戏中AI的反应）的知识。前两者是众所周知的，而最后一个有时会被忽视，但同样重要。事实上，有时NPC角色的最可信行为并不是玩家最享受的。如果你对了解更多感兴趣，我写了一篇文章，你可以在我的网站上找到：[francescosapio.com](http://francescosapio.com/)'
- en: However, I hope I haven't scared you by quoting such concepts of mathematics.
    In fact, in these sections, we won't cover such complicated things, but it is
    useful to have an idea about the foundations of what we will do, even if we will
    only create a simple ground to make our tower defense game work. In any case,
    I invite you to learn more about artificial intelligence in video games, since
    what you can achieve is really awesome!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我不希望因为我引用了这样的数学概念而吓到你。实际上，在这些部分，我们不会涉及这样复杂的事情，但了解我们将要做什么的基础是有用的，即使我们只是创建一个简单的地面来使我们的塔防游戏工作。无论如何，我邀请你更多地了解视频游戏中的人工智能，因为你可以实现的事情真的很棒！
- en: The importance of artificial intelligence in video games
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能在视频游戏中的重要性
- en: Imagine a tower defense game without enemies to compete against, it's just you
    and a bunch of towers. Games like *SimCity* ([www.simcity.com](http://www.simcity.com))
    would cease to exist. Games would become predictable experiences, their replay
    value would be greatly diminished, and MMOs would become ordinary. It would be
    the apocalypse of dynamic gameplay, without being too dramatic. Therefore, for
    any game to provide a dynamic and growing experience, AI is essential.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下一款没有敌人可以竞争的塔防游戏，只有你和一堆塔。像 *SimCity* ([www.simcity.com](http://www.simcity.com))
    这样的游戏将不复存在。游戏将变成可预测的体验，它们的重玩价值将大大降低，MMO游戏将变得普通。这将是一场动态游戏玩法的大灾难，尽管不至于太过戏剧化。因此，为了使任何游戏提供动态和不断增长的经验，AI是必不可少的。
- en: Artificial intelligence, or simply AI, allows systems to think and then behave
    just like humans, *or* animals*.* Over time, these systems can learn from the
    behavior of its user; for example, if they are progressing too easily, or if they
    are struggling, then the system is able to make adjustments to the game (in real
    time) so that the game adapts to the player. This concept refers to **machine
    learning***.*
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能，简称AI，允许系统像人类或动物一样思考和行动。随着时间的推移，这些系统可以从其用户的行为中学习；例如，如果它们进展得太容易，或者如果它们在挣扎，那么系统就能够调整游戏（实时）以使游戏适应玩家。这个概念指的是**机器学习**。
- en: AI in computer games refers to the behaviour and decision-making process of
    game components such as non-player characters, or NPCs for short. In modern games,
    there is real-time, very dynamic AI that in some cases feels like you're playing
    against other real players. In this way, well done AI allows you to make fast
    and intelligent decisions in order to progress through the game and achieve greatness.
    Some examples of AI in games can range from early arcade games such as *Pac-Man*,
    to enemies in first person shooters, such as *Battlefield*, *Call of Duty*, and
    *Alpha Protocol*; or *hordes of orcs* and beasts in strategy games, such as *World
    of Warcraft* and *Guild Wars 2*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机游戏中的AI指的是游戏组件（如非玩家角色，简称NPC）的行为和决策过程。在现代游戏中，存在实时、非常动态的AI，在某些情况下感觉就像你在与其他真实玩家对战。这样，做得好的AI允许你快速、明智地做出决定，以便在游戏中取得进步和成就。游戏中AI的例子可以从早期的街机游戏如
    *Pac-Man*，到第一人称射击游戏中的敌人，如 *Battlefield*、*Call of Duty* 和 *Alpha Protocol*；或者策略游戏中的
    *魔兽世界* 和 *剑网3* 中的成群结队的兽人怪物和野兽。
- en: 'In a book about AI (*Artificial Intelligence for Games* by Ian Millington and
    John Funge), which I recommend you to have a look at, we can think of AI as having
    the following states:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在一本关于人工智能的书（《游戏人工智能》由Ian Millington和John Funge所著），我推荐你看看，我们可以将AI视为具有以下状态：
- en: '**Movement**: This refers to AI that involves NPCs making decisions that then
    produce a type of motion, such as attacking or fleeing the player.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动**：这指的是涉及NPC做出决定，然后产生某种运动（如攻击或逃离玩家）的AI。'
- en: '**Decision making**: As the name suggests, this requires that a decision is
    made by the NPC about what to do next. For instance, if the enemy sees you, will
    it attack, run, or call for help?'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**决策**：正如其名所示，这要求NPC做出决定，决定下一步要做什么。例如，如果敌人看到你，它会攻击、逃跑还是呼救？'
- en: '**Strategy**: Imagine trying to coordinate a whole team, like in *S.W.A.T*
    or Tom Clancy''s *Rainbow Six*. In these situations, AI does not affect just one
    or two characters, but the entire team who, in turn, may have his or her own decision
    making tree, such as what to do when they sight an enemy; do they take them out
    on their own or do they notify you?'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略**：想象一下试图协调一个整个团队，比如在 *S.W.A.T* 或汤姆·克兰西的 *Rainbow Six* 中。在这些情况下，AI不仅影响一个或两个角色，还影响整个团队，而团队本身可能有自己的决策树，比如在看到敌人时该做什么；是自己解决他们，还是通知你？'
- en: '**Infrastructure**: This refers to how the AI is structured, which will ultimately
    determine how well it works in a game. This isn''t just about creating the write
    algorithms to make NPCs perform certain actions, it is also about utilizing the
    computer''s resources in an efficient way.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施**：这指的是AI的结构方式，这最终将决定它在游戏中的表现效果。这不仅仅是关于创建正确的算法来使NPC执行某些动作，还涉及到以高效的方式利用计算机资源。'
- en: '**Agent-based AI**: This refers to the concept of creating autonomous NPCs
    that take in information from the game data, determine what actions to take, and
    then carry out those actions.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于代理的AI**：这指的是创建自主的非玩家角色（NPC），它们从游戏数据中获取信息，确定要采取的行动，然后执行这些行动的概念。'
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'A great site to check out is Intel''s: [http://tinyurl.com/IntelAI](http://tinyurl.com/IntelAI),
    which provides a nice explanation and introduction to the use of AI in games.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得查看的网站是英特尔网站：[http://tinyurl.com/IntelAI](http://tinyurl.com/IntelAI)，它提供了关于在游戏中使用人工智能的精彩解释和介绍。
- en: Navigation
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航
- en: Now, we should have a better understanding of why AI is so important and vital
    for video games, but it's such an extensive topic that it cannot be dealt with
    in a small chapter like this. Therefore, we will focus on just one particular
    aspect, which is navigation. Since this is an introductory chapter to the topic,
    we will hope to understand the basic concepts of navigation, but implement just
    one of the simple techniques that we will use in our game.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该更好地理解为什么人工智能对视频游戏如此重要和关键，但这是一个如此广泛的话题，无法在这个小章节中处理。因此，我们将专注于一个特定的方面，即导航。由于这是一个关于该主题的入门章节，我们希望理解导航的基本概念，但只实现我们将要在游戏中使用的一种简单技术。
- en: Aspects of navigation
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航方面
- en: Game characters move within the game and its levels. The movement can be quite
    simple, such as that of arcade games or NPCs following or targeting you, and others
    can be quite complex like in fast paced action and adventure games. Fixed routes
    are simple to implement within a game, but keep in mind that it is possible to
    break their illusion when objects and other characters get in the way. For example,
    in games that are highly populated by NPCs (such as *Assassin's Creed*), characters
    that roam the environment can get stuck on environmental objects and appear to
    be moon walking, or in other words moving but not going anywhere. In a more dynamic
    situation, characters that will follow you or come towards you (friend or foe)
    will not know your future movements and therefore must act accordingly, as you
    do. This can range from waves of enemies in real-time strategy games, to guards
    who you need to avoid in order to infiltrate high-level security buildings.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏角色在游戏及其关卡内移动。移动可以非常简单，例如街机游戏或NPC跟随或瞄准你，而其他角色则可以非常复杂，就像在快节奏的动作和冒险游戏中。在游戏中实现固定路线很简单，但请注意，当物体和其他角色挡道时，可能会打破它们的幻觉。例如，在NPC高度密集的游戏中（如*刺客信条*），在环境中漫游的角色可能会卡在环境物体上，看起来像是在月球行走，或者说是在移动但并没有去任何地方。在更动态的情况下，跟随你或向你走来（朋友或敌人）的角色将不知道你的未来移动，因此必须相应地行动，就像你一样。这可以从实时策略游戏中的敌人波到你需要避开以渗透高级安全建筑物的守卫。
- en: For each of these characters (and situations), the AI must be able to calculate
    a suitable route within the game level, ensuring that it can respond to objects
    that come into its path, in order to reach its goal. Ideally, you want the character
    to act as natural as possible.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些角色（和情况）中的每一个，人工智能必须能够在游戏关卡内计算出一条合适的路径，确保它能够对进入其路径的物体做出反应，以达到其目标。理想情况下，你希望角色尽可能自然地行动。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In larger contexts, navigation can be used in a space, which can represent the
    environment, but also more abstract things, such as the space of moves of a problem.
    For example, in the famous *Eight queens* game (placing eight queens on a chess
    board such that each one of them doesn't attack another; you should try it), finding
    a path in the space of moves might be equivalent to finding a solution.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大的背景下，导航可以用于一个空间，它可以代表环境，也可以代表更抽象的事物，如问题的移动空间。例如，在著名的*八皇后*游戏中（在棋盘上放置八个皇后，使得它们中的每一个都不会攻击另一个；你应该试一试），在移动空间中找到路径可能等同于找到解决方案。
- en: 'In video games, navigation can exist in various forms, such as:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏中，导航可以以各种形式存在，例如：
- en: '**Steering behaviours**: These find an immediate path in front of the agent
    to avoid collisions. It can be used for basic obstacle avoidance, also in multi-agent
    system contexts. Since these behaviours are at a low-level, in video games they
    always have been implemented in a Kinematic way (in the same way we saw in [Chapter
    5](part0062.xhtml#aid-1R42S1 "Chapter 5. The Secret Ingredient Is a Dash of Physics"), *The
    Secret Ingredient Is a Dash of Physics*). However recently, some dynamic steering
    behaviours have arisen in the game development world, bringing more realistic
    games.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转向行为**：这些行为为智能体找到一条避免碰撞的即时路径。它可以用于基本的障碍物避让，也可以在多智能体系统环境中使用。由于这些行为处于低级别，在视频游戏中，它们一直是以运动学方式实现的（就像我们在[第5章](part0062.xhtml#aid-1R42S1
    "第5章。物理学的小调料")，*物理学的小调料*中看到的那样）。然而，最近，游戏开发世界中出现了某些动态转向行为，使得游戏更加逼真。'
- en: '**Pathfinding**: These finds a path from a starting location to a destination.
    This level is the most used, and many techniques have been discovered/invented
    and implemented. It is this type of navigation that will be the focus of this
    chapter.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径查找**：这种查找从起始位置到目的地找到一条路径。这个级别是最常用的，已经发现/发明并实现了许多技术。本章将重点关注这种类型的导航。'
- en: '**Driven pathfinding**: These finds one or multiple paths according to some
    driven behaviours. This is still a level that has never been implemented in the
    game industry, but it''s a field of research for game development in academia,
    and therefore it''s worth mentioning. This level is placed between decision making
    and pathfinding. In fact, some decisions are taken at pathfinding time, bringing
    a more intelligent pathfinding and efficiency in decision processes.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**驱动路径查找**：这种查找根据某些驱动行为找到一条或多条路径。这在游戏行业中从未被实现，但在学术界是游戏开发的研究领域，因此值得提及。这个级别位于决策和路径查找之间。实际上，在路径查找时做出一些决策，这带来了更智能的路径查找和决策过程中的效率。'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'More information about the different types of navigation can be found in more
    detail on my website. Moreover, my research involves directly driven pathfinding,
    such as the BDP (we will see later in the chapter). Here is the link: [francescosapio.com](http://francescosapio.com).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于不同类型导航的信息可以在我的网站上找到更详细的介绍。此外，我的研究涉及直接驱动的路径查找，例如BDP（我们将在本章后面看到）。以下是链接：[francescosapio.com](http://francescosapio.com)。
- en: Pathfinding and its techniques
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径查找及其技术
- en: Over the last few decades, many pathfinding algorithms and techniques have been
    explored. One of the very first pathfinding algorithms that was invented was the
    **dijkstra algorithm**, which gave the foundation for modern pathfinding algorithms.
    Of course, since Dijkstra, much progress has been made and algorithms have become
    much more efficient (especially when we deal with specific information or we have
    a priori knowledge about the problem that we can use). The most used of these
    in video games is the **A* algorithm** (along with all its derivations), which
    uses some additional information about the map. The main concept of Dijkstra was
    to explore in all directions until a route was found; the main concept of A* is
    to explore towards the direction of the destination (which may sound simple, but
    it is not always easy to determine a function that in some way tells you which
    is the direction towards the destination). Of course, this is a simplification,
    but good enough to gain a better overview.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几十年里，已经探索了许多路径查找算法和技术。最早发明的路径查找算法之一是**Dijkstra算法**，它为现代路径查找算法奠定了基础。当然，自从Dijkstra以来，取得了很大的进步，算法变得更加高效（尤其是在我们处理特定信息或我们有关于问题的先验知识可以使用时）。在视频游戏中最常用的是**A*算法**（及其所有衍生算法），它使用一些关于地图的额外信息。Dijkstra的主要概念是在所有方向上探索，直到找到一条路线；A*的主要概念是朝着目的地方向探索（这听起来可能很简单，但并不总是容易确定一个函数，以某种方式告诉你朝向目的地的方向）。当然，这是一个简化，但已经足够获得更好的概述。
- en: The preceding mentioned algorithms work in many situations, but if the route
    which we want to find is easy enough to be found in a small map, it wouldn't be
    worthwhile developing such algorithms, since there are easier techniques. One
    of these techniques is the use of waypoints, which is the technique we will use
    for our game. The main concept is that the map is split into a graph which, potentially,
    is very small (enough to be drawn by hand) and finding a path can happen in a
    distributed way. Of course, there is another entire world beyond distributed pathfinding
    (a practical application would be IP packets that need to travel the world on
    the Internet, and the path between the different routers is determined in a distributed
    way since the map of the network changes continuously).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述提到的算法在许多情况下都有效，但如果我们要找到的路线足够简单，可以在一个小地图上找到，那么开发这样的算法就不再值得，因为还有更简单的技术。其中一种技术是使用航路点，这是我们游戏将使用的技术。主要概念是将地图分成一个图，这个图可能非常小（足够用手绘），路径查找可以以分布式的方式进行。当然，分布式路径查找之外还有另一个广阔的世界（一个实际应用是需要在互联网上穿越世界的IP数据包，不同路由器之间的路径是以分布式方式确定的，因为网络地图不断变化）。
- en: Another important fact that influences pathfinding (but also other techniques
    of AI) is whether the algorithm needs to work online or offline. Online means
    that the algorithm needs to find a solution in real time, whereas offline means
    that the solution can be found a priori. In video games, there are situations
    in which we need to use online solutions (such as finding the path for your NPCs)
    and others where we need an offline solution (for instance, when you have more
    time to compute, such as with turn-based games, or when some AI calculations are
    performed at loading time).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个影响寻路（但也是AI的其他技术）的重要因素是算法是否需要在线工作或离线工作。在线意味着算法需要实时找到解决方案，而离线意味着解决方案可以在事先找到。在视频游戏中，有些情况下我们需要使用在线解决方案（例如为NPC找到路径），而有些情况下我们需要离线解决方案（例如，在回合制游戏中，或者当某些AI计算在加载时执行时）。
- en: Unfortunately, we would need another book just to describe navigation in video
    games, but this chapter is giving you a nice and gentle introduction to the world
    that's behind all of this, and you can use the references (suggested books and
    links) to continue your journey in learning AI in games.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们可能需要另一本书来描述视频游戏中的导航，但这一章为你提供了一个美好而温和的介绍，让你可以继续学习游戏中的AI，并可以使用参考（建议的书籍和链接）继续你的学习之旅。
- en: Waypoints for enemies
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人路径点
- en: A waypoint is a special point on the map where NPCs change their direction to
    move towards another waypoint. They can contain logic to actually lead the character
    to specific places that change over time, such as next to the player. For instance,
    in a shooting game, enemies want to get closer to the player to shoot him/her.
    Waypoints can also perform part of the decision-making process. For example, imagine
    a tower defense level where the path of the enemies splits in two. In this case,
    the waypoints can be used to decide which direction a particular enemy should
    take (we will see this in the last chapter of this book). The advantages of waypoints
    are that, in some cases, they can be more efficient than implementing a complete
    pathfinding algorithm.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 路径点是在地图上的一个特殊点，NPCs会改变方向移动到另一个路径点。它们可以包含逻辑，实际上引导角色移动到随时间变化的具体位置，例如靠近玩家。例如，在射击游戏中，敌人想要靠近玩家射击。路径点还可以执行决策过程的一部分。例如，想象一个塔防关卡，敌人的路径分为两个方向。在这种情况下，路径点可以用来决定特定敌人应该走哪个方向（我们将在本书的最后一章中看到这一点）。路径点的优点是，在某些情况下，它们可能比实现完整的寻路算法更有效率。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In more complex implementations, waypoints can be connected in different ways
    and these connections can also be created automatically by letting the waypoints
    find each other. Furthermore, they can also contain other information, such as
    which is the closest waypoint to the player. Here, the enemy can ask or query
    the waypoints where to head towards in order to find the player without running
    a complete pathfinding algorithm on the map itself.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的实现中，路径点可以通过不同的方式连接，并且这些连接也可以通过让路径点相互寻找来自动创建。此外，它们还可以包含其他信息，例如哪个路径点是玩家最近的。在这里，敌人可以询问或查询路径点，以确定前往玩家的方向，而无需在地图本身上运行完整的寻路算法。
- en: At the moment, we don't need to implement a particular logic behind the waypoints.
    However, they are a useful tool since they allow us to move enemies around the
    map easily, and they are modular enough so to be able to create other levels of
    our game without many problems.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们不需要在路径点后面实现特定的逻辑。然而，它们是一个有用的工具，因为它们允许我们轻松地在地图上移动敌人，并且它们足够模块化，以便能够创建游戏的其他级别而不会遇到太多问题。
- en: In this section, we will learn how to create waypoints. In particular, we will
    see two ways to implement them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何创建路径点。特别是，我们将看到两种实现路径点的方法。
- en: Getting the waypoint coordinates
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取路径点坐标
- en: 'Before we start creating waypoints, we first need to decide where to place
    them on the map. Therefore, we need to find all the places where our Pandas change
    their direction. In this simple map, they are located at all corners of their
    path. In the following image, they are indicated by the red dots:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建路径点之前，我们首先需要决定在地图上放置它们的位置。因此，我们需要找到所有我们的Pandas改变方向的地方。在这个简单的地图上，它们位于路径的所有角落。在下面的图像中，它们由红色圆点表示：
- en: '![Getting the waypoint coordinates](img/image00581.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![获取路径点坐标](img/image00581.jpeg)'
- en: As we can see, there are 11 and we need one waypoint that is on the cake in
    the map. This final waypoint is the finishing spot, where the Panda has succeeded
    in his mission to steal a big bite of the player's cake.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，有 11 个航点，我们需要一个位于地图蛋糕上的航点。这个最终的航点是熊猫成功完成偷吃玩家蛋糕任务的终点。
- en: 'Now that we have spotted them, we need to take note of their coordinates on
    the map. A fast way to do it is to drag the Panda Prefab around the map in the
    **Scene** view and then take note of the position of our waypoints. In this case,
    we could obtain the following data:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经发现了它们，我们需要记录它们在地图上的坐标。一种快速的方法是在 **场景** 视图中拖动 Panda Prefab，然后记录航点的位置。在这种情况下，我们可以获得以下数据：
- en: '| **Waypoint number** | **X coordinate** | **Y coordinate** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **航点编号** | **X 坐标** | **Y 坐标** |'
- en: '| 1 | `-28` | `8` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `-28` | `8` |'
- en: '| 2 | `-28` | `-16` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `-28` | `-16` |'
- en: '| 3 | `-16` | `-16` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `-16` | `-16` |'
- en: '| 4 | `-16` | `7` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 4 | `-16` | `7` |'
- en: '| 5 | `-2` | `7` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 5 | `-2` | `7` |'
- en: '| 6 | `-2` | `-6` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 6 | `-2` | `-6` |'
- en: '| 7 | `12` | `-6` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 7 | `12` | `-6` |'
- en: '| 8 | `12` | `9` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 8 | `12` | `9` |'
- en: '| 9 | `25` | `9` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 9 | `25` | `9` |'
- en: '| 10 | `25` | `-17` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 10 | `25` | `-17` |'
- en: '| 11 | `32` | `-17` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 11 | `32` | `-17` |'
- en: Implementing waypoints – the first/static way
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现航点 – 第一种/静态方法
- en: Now that we have all the waypoint coordinates, we can implement them. In this
    section, we will explore the first way to implement them. The main advantage of
    this method is the simplicity of the implementation and the possibility to learn
    more about static variables and iterating over waypoints.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有的航点坐标，我们可以实现它们。在本节中，我们将探讨实现它们的第一种方法。这种方法的主要优势是实现简单，以及有机会了解更多关于静态变量和遍历航点。
- en: Implementing waypoints in the Game Manager
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在游戏管理器中实现航点
- en: In this first implementation of waypoints, they won't be separate entities in
    the game, but rather a collection of positions in a specific order. All the enemies
    will consult this list, and based on which waypoint they are currently at, take
    the next one in the list.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个航点的首次实现中，它们在游戏中不会是独立的实体，而是一系列按特定顺序排列的位置。所有敌人都会查阅这个列表，并根据它们当前所在的航点，选择列表中的下一个航点。
- en: Of course, this method has some limitations such as we won't be able to implement
    custom features in the waypoints, as we will see in [Chapter 8](part0100.xhtml#aid-2VBO82
    "Chapter 8. What Is beyond the Cake?"), *What Is beyond the Cake?*. However, it
    is simpler to implement, and it gives us the opportunity to explore how to use
    static variables.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种方法有一些限制，例如我们无法在航点中实现自定义功能，正如我们将在第 8 章[What Is beyond the Cake?](part0100.xhtml#aid-2VBO82
    "第 8 章. 蛋糕之外是什么？")中看到的。然而，它更容易实现，并给我们提供了探索如何使用静态变量的机会。
- en: 'First of all, we need to create another script, and call it `GameManagerScript`.
    We will implement more functionality in this script in the next chapter. But at
    the moment, it is needed to store the waypoints. In fact, for now, we just need
    to add an array of positions, so you can write the following in the script:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建另一个脚本，并将其命名为 `GameManagerScript`。我们将在下一章中在这个脚本中实现更多功能。但到目前为止，我们需要存储航点。实际上，目前我们只需要添加一个位置数组，所以你可以在脚本中写下以下内容：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It is a `Vector3` array, which basically just stores a set of positions in
    a specific order. Save the code, and create an empty GameObject in the **Scene**,
    which you can rename `Game Manager`. Attach the script on it, and in the **Inspector**
    you should see something like the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个 `Vector3` 数组，基本上只是按特定顺序存储一组位置。保存代码，并在 **场景** 中创建一个空的游戏对象，你可以将其重命名为 `Game
    Manager`。将脚本附加到它上，在 **检查器** 中你应该看到如下内容：
- en: '![Implementing waypoints in the Game Manager](img/image00582.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![在游戏管理器中实现航点](img/image00582.jpeg)'
- en: 'We need to set the number of elements of our array with the number of waypoints
    we have found, in this case 11\. Therefore, our **Inspector** looks like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将数组的元素数量设置为找到的航点数量，在本例中为 11。因此，我们的 **检查器** 看起来如下：
- en: '![Implementing waypoints in the Game Manager](img/image00583.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![在游戏管理器中实现航点](img/image00583.jpeg)'
- en: 'Finally, we can fill all those values with our waypoint positions. But what
    about the *z*-axis? Since we don''t want the Pandas to change their *z*-axis,
    we can just set its value to the same *z*-axis value of our `PandaPrefab`, which
    is `-1`. At the end, we should have something like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以用航点位置填充所有这些值。那么 *z* 轴怎么办呢？由于我们不希望 Pandas 改变它们的 *z* 轴，我们可以将其值设置为与 `PandaPrefab`
    的相同 *z* 轴值，即 `-1`。最后，我们应该得到如下所示的内容：
- en: '![Implementing waypoints in the Game Manager](img/image00584.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![在游戏管理器中实现航点](img/image00584.jpeg)'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The reader may wonder if it was worthwhile using `Vector2` instead of `Vector3`.
    The answer is: it''s your choice. Nothing prevents you from using `Vector2` and
    forgetting about `Vector3`. But, since we have made the choice to handle the depth
    of our game with z-buffering, I personally prefer to have direct control over
    the *z*-axis as well, so be sure to achieve the intended behavior.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可能会想知道使用 `Vector2` 而不是 `Vector3` 是否值得。答案是：由你决定。没有任何东西阻止你使用 `Vector2` 而忽略 `Vector3`。但是，既然我们已经选择了用
    z 缓冲区来处理游戏中的深度，我个人更倾向于直接控制 *z* 轴，因此请确保实现预期的行为。
- en: Moving along the designed path – static
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沿着设计的路径移动 – 静态
- en: Next, we need to give an opportunity for the enemies to have access to the waypoints
    stored in the `GameManagerScript`. Therefore, we need to get a reference it. There
    are many ways to do so, but for learning's sake, we will use a static variable
    (so as to unravel the use of such variables). In fact, all the Pandas share the
    same game manager, and it's a waste of computational resources if every time a
    Panda is created, it needs to search for the `Game Manager`. A static variable
    is a value which is shared among all the instances of the `PandaScript`. Of course,
    we need to be careful not to assign this variable many times.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要给敌人一个访问存储在 `GameManagerScript` 中的航点的机会。因此，我们需要获取它的引用。有好多方法可以做到这一点，但为了学习的目的，我们将使用一个静态变量（以便揭示此类变量的用途）。实际上，所有的
    Pandas 都共享同一个游戏管理器，如果每次创建 Pandas 时都需要搜索 `Game Manager`，那么这将是计算资源的浪费。静态变量是一个在 `PandaScript`
    的所有实例之间共享的值。当然，我们需要小心不要多次分配这个变量。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that static variables are persistent over different scenes/levels.
    Therefore, if you are planning to release a game with more than one level, most
    likely you will need to reset this variable when the level is changed. We will
    explore this better in [Chapter 8](part0100.xhtml#aid-2VBO82 "Chapter 8. What
    Is beyond the Cake?"), *What Is beyond the Cake?*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，静态变量在不同的场景/级别之间是持久的。因此，如果你计划发布一个包含多个级别的游戏，那么在改变级别时，你很可能需要重置这个变量。我们将在第 8 章
    [What Is beyond the Cake?](part0100.xhtml#aid-2VBO82 "第 8 章。蛋糕之外是什么？") 中更好地探讨这一点。
- en: 'Open the `PandaScript`, and let''s add the static variable to store the reference
    to the `Game Manager`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `PandaScript`，让我们添加一个静态变量来存储对 `Game Manager` 的引用：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At the beginning of the `Start()` function we need to check if another instance
    (another Panda) has already been assigned this variable. If not, we will assign
    it by finding its reference in the scene, even though there will only be one game
    manager in the scene at the time. As a result, this Panda will actually initialize
    the variable. As such, all the other instances of Pandas that will be created
    will have a reference to the `Game Manager` ready, and thanks to this check, we
    are sure that we are assigning it only once:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Start()` 函数的开始处，我们需要检查是否已经有一个实例（另一个 Pandas）分配了这个变量。如果没有，我们将通过在场景中找到它的引用来分配它，尽管当时场景中只有一个游戏管理器。因此，这个
    Pandas 实际上会初始化这个变量。这样，所有将要创建的其他 Pandas 实例都将有一个对 `Game Manager` 的引用准备就绪，并且由于这个检查，我们可以确信我们只分配了一次：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we have to make the Panda move. But first, we need a variable to store
    the current waypoint that the Panda is heading towards:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须让 Pandas 移动。但首先，我们需要一个变量来存储 Pandas 正在前往的当前航点：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we need a constant to establish a threshold after which the waypoint
    is considered as having been reached. In fact, there are numerical instabilities,
    and we cannot check directly if the distance from the waypoint is actually zero,
    only a value very close to it. As you can see, the value assigned to this constant
    is very low:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要一个常量来设置一个阈值，超过这个阈值航点就被认为是已经到达了。实际上，存在数值不稳定性，我们不能直接检查航点的距离是否实际上是零，而只能是一个非常接近零的值。正如你所见，分配给这个常量的值非常低：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we need to implement the mechanism under which the Panda heads towards
    the right waypoint, and changes direction to the next one when the previous is
    reached. Since the `MoveTowards()` function we will use to move the Panda deals
    with physics, we need to implement this whole mechanism of the waypoints within
    the `FixedUpdate()` function, as we learnt from [Chapter 5](part0062.xhtml#aid-1R42S1
    "Chapter 5. The Secret Ingredient Is a Dash of Physics"), *The Secret Ingredient
    Is a Dash of Physics*. So, we can start writing the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要实现熊猫向右的航点移动机制，并在到达前一个航点后改变方向前往下一个航点。由于我们将使用的`MoveTowards()`函数处理物理问题，我们需要在`FixedUpdate()`函数内实现整个航点机制，正如我们在[第五章](part0062.xhtml#aid-1R42S1
    "第五章。物理的调味品")《物理的调味品》中学到的那样。因此，我们可以开始编写以下代码：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In particular, we need to do three things within the `FixedUpdate()` function.
    The first one is to check if the Panda has reached the end of the waypoint list,
    which means it is in front of the delicious player''s cake. If so, we need to
    trigger the eat animation in the same fashion we triggered the others in [Chapter
    4](part0056.xhtml#aid-1LCVG1 "Chapter 4. No Longer Alone – Sweet-Toothed Pandas
    Strike"), *No Longer Alone – Sweet-Toothed Pandas Strike*. Then, we need to remove
    this script from the Panda. In fact, the `State Machine Behaviour` script we wrote
    in [Chapter 4](part0056.xhtml#aid-1LCVG1 "Chapter 4. No Longer Alone – Sweet-Toothed
    Pandas Strike"), *No Longer Alone – Sweet-Toothed Pandas Strike*, will take care
    of removing the Panda from the scene. Finally, we return so that the rest of the
    function is not executed:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，在`FixedUpdate()`函数内我们需要做三件事情。第一件事是检查熊猫是否到达了航点列表的末尾，这意味着它已经站在美味玩家蛋糕的前面。如果是这样，我们需要以与在[第四章](part0056.xhtml#aid-1LCVG1
    "第四章。不再孤单——甜食熊猫出击")《不再孤单——甜食熊猫出击》中触发其他动画相同的方式触发吃动画。然后，我们需要从这个熊猫上移除这个脚本。实际上，我们在[第四章](part0056.xhtml#aid-1LCVG1
    "第四章。不再孤单——甜食熊猫出击")《不再孤单——甜食熊猫出击》中编写的`状态机行为`脚本将负责将熊猫从场景中移除。最后，我们返回，这样函数的其余部分就不会被执行：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second thing, in case the Panda is not at the last waypoint yet, is to
    calculate the distance between the current Panda''s position, through its Transform,
    and the waypoint it is heading towards. This value is stored within a local variable
    `dist`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第二件事，如果熊猫还没有到达最后一个航点，就是计算当前熊猫位置（通过其Transform）与它正前往的航点之间的距离。这个值存储在一个局部变量`dist`中：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The last thing is to check if the Panda is close enough to the waypoint. Enough
    means below the constant threshold stored in the `changeDist`. If so, we just
    increase the counter of the waypoints so that at the next iteration, the Panda
    will head to the next waypoint. Otherwise, we just use the `MoveTowards()` function
    implemented in the previous chapter to move the Panda towards the waypoint:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事情是检查熊猫是否足够接近航点。足够的意思是低于存储在`changeDist`中的常量阈值。如果是这样，我们就增加航点的计数器，这样在下一个迭代中，熊猫就会前往下一个航点。否则，我们只需使用上一章中实现的`MoveTowards()`函数将熊猫移动到航点：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can save our script and test it out. By placing a Panda in the scene somewhere
    near the first waypoint and pressing play, we will see it moving along the path.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以保存我们的脚本并测试它。通过在场景中某个位置放置一个熊猫，靠近第一个航点，然后按下播放，我们将看到它沿着路径移动。
- en: Implementing waypoints – the second/dynamic way
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现航点——第二种/动态方法
- en: In this section, we will explore a second way to implement the waypoint system
    of our game. Of course, the outcome will be the same, but this approach offers
    many other advantages. First of all, it's easier for designers to collocate, change,
    move, and replace waypoints within the map itself. Second, it allows a great flexibility
    in behaviors, which can be implemented in such a way to make it easier for designers
    to use the script created. We will exploit some of the potentiality of this system
    later in the last chapter of the book.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨实现游戏航点系统的第二种方法。当然，结果将是相同的，但这种方法提供了许多其他优点。首先，对于设计师来说，在地图本身中定位、更改、移动和替换航点更容易。其次，它允许在行为上具有很大的灵活性，可以以这种方式实现，使设计师更容易使用创建的脚本。我们将在本书的最后一章中利用这个系统的某些潜力。
- en: Nonetheless, this approach does suffer from some drawbacks, as with every choice
    in life. In particular, the complexity of the system increases. Moreover, it uses
    a different game object for each one of the waypoints, and this is critical if
    the number of waypoints is really high.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法确实存在一些缺点，就像生活中的每一个选择一样。特别是，系统的复杂性增加了。此外，它为每个航点使用不同的游戏对象，如果航点的数量真的很多，这一点至关重要。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To overcome this last problem of having different game objects for each of the
    waypoints, we have many possibilities, but making each one of them work is a challenge
    and at the same time, easy for designers to use. In fact, waypoints can still
    be stored as a list, not as positions this time, but rather of the `waypoint`
    class, and at the same time expose functionalities to allow designers to edit
    and place them within the **Scene** view. This is left as a challenge in the *Homework*
    section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服为每个航点使用不同游戏对象的问题，我们有多种可能性，但让每一个都工作是一个挑战，同时对于设计师来说也很容易使用。实际上，航点仍然可以存储为列表，不是位置，而是`waypoint`类，同时提供功能，允许设计师在**场景**视图中编辑和放置它们。这被留在了*作业*部分作为一个挑战。
- en: Implementing waypoints as separate entities
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将航点作为独立实体实现
- en: So far, we have seen a simple implementation of the waypoints. Now, we will
    implement them again, but this time as separate entities. As such, in [Chapter
    8](part0100.xhtml#aid-2VBO82 "Chapter 8. What Is beyond the Cake?"), *What Is
    beyond the Cake?*, we will explore how to unlock the potential of waypoints in
    a game. In fact, at the end of this section, the effect on our game will be the
    same; however, we will change the script in [Chapter 8](part0100.xhtml#aid-2VBO82
    "Chapter 8. What Is beyond the Cake?"), *What Is beyond the Cake?*, by implementing
    more features.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了航点的简单实现。现在，我们将再次实现它们，但这次作为独立的实体。因此，在[第8章](part0100.xhtml#aid-2VBO82
    "第8章。蛋糕之后是什么？")，*蛋糕之后是什么？*中，我们将探讨如何在游戏中解锁航点的潜力。实际上，在本节结束时，对我们游戏的影响将是相同的；然而，我们将通过实现更多功能来改变[第8章](part0100.xhtml#aid-2VBO82
    "第8章。蛋糕之后是什么？")，*蛋糕之后是什么？*中的脚本。
- en: First of all, we need to erase the `waypoints` variable from the `GameManagerScript`
    (but don't erase the script, even if it is empty, because we will use it; for
    the same reasons, don't erase the `gameManager` variable from the `PandaScript`).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从`GameManagerScript`中删除`waypoints`变量（但不要删除脚本，即使它是空的，因为我们还会使用它；出于同样的原因，不要从`PandaScript`中删除`gameManager`变量）。
- en: Now, we need to create a new script, which will be the actual waypoint. As such,
    we can rename it as `Waypoint`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个新的脚本，它将是实际上的航点。因此，我们可以将其重命名为`Waypoint`。
- en: 'We need a variable of the same class to store the next waypoint. In this way,
    each waypoint will be able to point/reference towards another waypoint. The goal
    is to build a chain which the Pandas will follow. Since the variable is private
    but we still need to have access to it in the **Inspector**, we need to add the
    serializable property. So, we can add the following to our script:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个相同类的变量来存储下一个航点。这样，每个航点都将能够指向/引用另一个航点。目标是构建一个熊猫将跟随的链。由于变量是私有的，但我们仍然需要在**检查器**中访问它，我们需要添加可序列化的属性。因此，我们可以向我们的脚本中添加以下内容：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, from the waypoint, a Panda would like to retrieve its position and the
    next waypoint to follow, once the current one is reached. To achieve this, we
    can expose two functions from our `Waypoint` script.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从航点出发，熊猫想要在到达当前航点后检索其位置和下一个要跟随的航点。为了实现这一点，我们可以从我们的`Waypoint`脚本中公开两个函数。
- en: 'The `GetPosition()` function will return a `Vector3` with the position of the
    waypoint, which (in this specific implementation) is stored in the Transform of
    the waypoint. The code is the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetPosition()`函数将返回一个包含航点位置的`Vector3`，在这个特定的实现中，位置存储在航点的Transform中。代码如下：'
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `GetNextWaypoint()` function, instead, will return just the next waypoint
    (at least for the moment), stored in the `nextWaypoint` variable. In fact, the
    `nextWaypoint` variable is private, and so Pandas need a function to retrieve
    it. Therefore, we can just write the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`GetNextWaypoint()`函数将仅返回下一个航点（至少目前是这样），存储在`nextWaypoint`变量中。实际上，`nextWaypoint`变量是私有的，因此熊猫需要一个函数来检索它。因此，我们可以简单地编写以下代码：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have finished with this script for now, so we can save it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们已经完成了这个脚本，所以我们可以保存它。
- en: The next step is to create a Prefab for our waypoints. Create an empty GameObject
    and attach the `Waypoint` script. Then, in the **Project** panel, create a Prefab
    called `WaypointPrefab` and drag and drop the empty GameObject you have created.
    Finally, erase the empty GameObject from the scene, since now we have our Prefab.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建我们的路标点的 Prefab。创建一个空 GameObject 并附加 `Waypoint` 脚本。然后，在 **项目** 面板中创建一个名为
    `WaypointPrefab` 的 Prefab，并将你创建的空 GameObject 拖放到那里。最后，从场景中删除空 GameObject，因为我们已经有了我们的
    Prefab。
- en: 'Drag and drop as many Prefabs as the number of waypoints you have identified;
    in our example, there are 11\. For your convenience, I suggest you rename them
    in a progressive order, as shown in the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 拖放与已识别路标点数量相同的 Prefabs；在我们的例子中，有 11 个。为了方便起见，我建议你按顺序重命名它们，如下面的截图所示：
- en: '![Implementing waypoints as separate entities](img/image00585.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![将路标点作为独立实体实现](img/image00585.jpeg)'
- en: 'Now, we need to link them to each other. In particular, `waypoint1` will be
    linked to `waypoint2`, which will be linked to `waypoint3`, and so on. For instance,
    `waypoint4` should look linked in the **Inspector** as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将它们相互链接。特别是，`waypoint1` 将链接到 `waypoint2`，`waypoint2` 将链接到 `waypoint3`，依此类推。例如，`waypoint4`
    在 **检查器** 中应该看起来如下链接：
- en: '![Implementing waypoints as separate entities](img/image00586.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![将路标点作为独立实体实现](img/image00586.jpeg)'
- en: 'The only exception is in the last waypoint, which has nothing in the `nextWaypoint`
    variable, as shown in the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的例外是在最后一个路标点，`nextWaypoint` 变量中没有内容，如下面的截图所示：
- en: '![Implementing waypoints as separate entities](img/image00587.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![将路标点作为独立实体实现](img/image00587.jpeg)'
- en: Finally, we need to place them at the coordinates we have identified in the
    *Getting the waypoint coordinates* section. To quickly recognize them, I recommend
    that you add a Gizmo icon. As the name suggests, a Gizmo is an icon that will
    be shown in the Scene view to quickly and easily recognize specific objects, but
    won't be visible once the game is built. Recently, Unity added also the possibility
    to see them within the **Game** view.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将它们放置在 *获取路标坐标* 部分中我们已确定的坐标上。为了快速识别它们，我建议你添加一个 Gizmo 图标。正如其名所示，Gizmo
    是一个在场景视图中显示的图标，可以快速轻松地识别特定对象，但在游戏构建后不可见。最近，Unity 还增加了在 **游戏** 视图中查看它们的可能性。
- en: 'The easiest way to insert a Gizmo is by clicking the cube-shaped icon next
    to the name of the GameObject, highlighted in the following screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 插入 Gizmo 最简单的方式是点击 GameObject 名称旁边的立方体形状图标，如下面的截图所示：
- en: '![Implementing waypoints as separate entities](img/image00588.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![将路标点作为独立实体实现](img/image00588.jpeg)'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The same holds for Prefabs, but their icon is a blue cube.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Prefabs 也是如此，但它们的图标是一个蓝色立方体。
- en: 'Once you have clicked on this icon, a menu appears as shown in the following
    screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦点击此图标，就会出现一个菜单，如下面的截图所示：
- en: '![Implementing waypoints as separate entities](img/image00589.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![将路标点作为独立实体实现](img/image00589.jpeg)'
- en: By selecting one of the ellipse-shaped icons, you will place a label to the
    object with its name in it. We will choose one of these for our waypoints. If
    you click on the circle-shaped or crystal-shaped icons, the Gizmo will look like
    a circle or a crystal, without any text. If you click the **Other…** button, you
    can use your own graphics.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择一个椭圆形状的图标，你将为对象放置一个带有其名称的标签。我们将选择这些之一用于我们的路标点。如果你点击圆形或水晶形状的图标，Gizmo 将看起来像一个圆圈或水晶，没有任何文本。如果你点击
    **其他…** 按钮，你可以使用你自己的图形。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A more complex way to insert Gizmos is through scripting. In fact, there is
    a special function called `OnDrawGizmos()` which is called by Unity when rendering
    Gizmos is enabled. Within this function, you are able to use any of the functions
    listed at [https://docs.unity3d.com/ScriptReference/Gizmos.html](https://docs.unity3d.com/ScriptReference/Gizmos.html),
    which allow you to draw shapes on the screen. This is a very powerful tool, because
    it can enhance tremendously the usability of your scripts. For instance, in our
    specific case of waypoints, we could draw the path that Pandas will follow. This
    is left as an exercise in the *Homework* section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 插入 Gizmos 的更复杂方式是通过脚本。实际上，有一个名为 `OnDrawGizmos()` 的特殊函数，当启用 Gizmos 渲染时，Unity
    会调用该函数。在这个函数内部，你可以使用 [https://docs.unity3d.com/ScriptReference/Gizmos.html](https://docs.unity3d.com/ScriptReference/Gizmos.html)
    中列出的任何函数，这些函数允许你在屏幕上绘制形状。这是一个非常强大的工具，因为它可以极大地增强你脚本的可用性。例如，在我们的特定案例中，我们可以绘制 Pandas
    将会跟随的路径。这被留作 *作业* 部分的练习。
- en: In our case, we can select one of the ellipse-shaped icon for all the waypoints.
    As a result, we are able to see them in the **Scene** view (even if they don't
    have any explicit rendering component and thus they won't be visible in any way
    in the final game) and quickly place them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们可以为所有航点选择一个椭圆形图标。因此，我们能够在**场景**视图中看到它们（即使它们没有任何显式的渲染组件，因此在最终游戏中将无法以任何方式可见）并快速放置它们。
- en: 'At the end, your **Scene** view should look like the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你的**场景**视图应该看起来像以下这样：
- en: '![Implementing waypoints as separate entities](img/image00590.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![实现航点作为独立实体](img/image00590.jpeg)'
- en: 'Now, we need to specify to the game, which one of these waypoints is the first
    of the chain. As such, we can store this information within the `Game Manager`.
    So, let''s add the following variable to the `GameManagerScript`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要告诉游戏，这些航点中的哪一个是最初的链。为此，我们可以在`游戏管理器`中存储这些信息。所以，让我们向`GameManagerScript`添加以下变量：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, after having saved the script, set the variable in the **Inspector**,
    as shown in the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在保存脚本后，在**检查器**中设置变量，如图下截图所示：
- en: '![Implementing waypoints as separate entities](img/image00591.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![实现航点作为独立实体](img/image00591.jpeg)'
- en: In conclusion, we have created a chain of waypoints, which is exactly what we
    need for our game. However, we still need to define how the Pandas get to them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们已经创建了一个航点链，这正是我们游戏所需要的。然而，我们仍然需要定义熊猫如何到达它们。
- en: Moving along the designed path – dynamic
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沿着设计的路径移动 - 动态
- en: The next step is to slightly modify the `PandaScript` to take care of this new
    waypoint system. So, let's open the script again.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是稍微修改`PandaScript`以处理这个新的航点系统。所以，让我们再次打开脚本。
- en: 'First, we need to substitute the integer variable, `currentWaypointNumber`,
    with a proper waypoint variable, as shown here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要用适当的航点变量替换整数变量`currentWaypointNumber`，如图所示：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we need to initialize this new variable; we can do it in the `Start()`
    function, by retrieving the first waypoint from the `Game Manager`, as shown here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要初始化这个新变量；我们可以在`Start()`函数中完成，通过从`游戏管理器`获取第一个航点，如图所示：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, in the first check of the `FixedUpdate()` function, we need to check
    if the variable itself is null (which means that the Panda has reached the cake,
    because the last waypoint will return a null pointer). Here is the code, with
    the modified parts highlighted:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`FixedUpdate()`函数的第一个检查中，我们需要检查变量本身是否为null（这意味着熊猫已经到达了蛋糕，因为最后一个航点将返回一个null指针）。以下是代码，其中修改的部分已突出显示：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Going on in the `FixedUpdate()` function, we need to change how the distance
    is calculated, by using the `GetPosition()` function of our waypoint in the following
    way:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FixedUpdate()`函数中继续进行，我们需要更改距离的计算方式，通过以下方式使用我们的航点的`GetPosition()`函数：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we need to change the last `if` statement of the `FixedUpdate()` function
    to get the next waypoint when the previous one is reached. We also need to decide
    which parameter we should give to our `MoveTowards()` function. Again, the modified
    parts are highlighted:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更改`FixedUpdate()`函数中的最后一个`if`语句，以便在到达前一个航点时获取下一个航点。我们还需要决定应该将哪个参数提供给我们的`MoveTowards()`函数。再次，修改的部分已突出显示：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Save the script. We have finished this second way of implementing waypoints.
    [Chapter 8](part0100.xhtml#aid-2VBO82 "Chapter 8. What Is beyond the Cake?"),
    *What Is beyond the Cake?*, will suggest some ways to take advantage of this structure
    to implement more complex behaviors.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本。我们已经完成了第二种实现航点的方式。[第8章](part0100.xhtml#aid-2VBO82 "第8章。蛋糕之后是什么？")，“蛋糕之后是什么？”，将建议一些利用这种结构来实现更复杂行为的方法。
- en: More about artificial intelligence in games
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于游戏中的更多人工智能内容
- en: In the previous sections, we have seen a couple of implementations of a waypoint
    system to move characters within the game environment. However, as we already
    said in the introduction, this is not even scratching the surface of AI in games.
    This section presents some techniques, without entering into detail, as they are
    not needed to develop our tower defense game. In fact, to master AI in games,
    you need a specific book about it. Therefore, feel free to skip this section,
    or read it. You can always come back here later, maybe when you finish the book,
    for a deeper look at its content. The main goal of this section is just to give
    you a basic understanding of AI in games.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了几个在游戏环境中移动角色的航标系统实现。然而，正如我们在引言中已经说过的，这甚至没有触及游戏AI的表面。本节介绍了几个技术，但不会深入细节，因为它们对我们开发塔防游戏不是必需的。实际上，要掌握游戏中的AI，你需要一本专门关于它的书。因此，您可以自由地跳过这一节，或者阅读它。您总是可以稍后回来，也许在您完成这本书后，更深入地了解其内容。本节的主要目标只是让您对游戏中的AI有一个基本的了解。
- en: Other techniques for navigation at the pathfinding level
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在寻路级别上的其他导航技术
- en: The *Pathfinding and its techniques* section at the beginning of this chapter
    was in no way exhaustive, and of course thousands of other techniques exist at
    the pathfinding level which are used in video games.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开头关于**寻路及其技术**的部分绝不是详尽的，当然，在寻路级别上还有成千上万的其他技术被用于视频游戏中。
- en: 'However, it''s worth quoting one in particular: Navigation Mesh. This is important,
    because it''s built into the Unity engine for 3D games. The main concept behind
    this technique is a pre-analysis of the geometry of the level to extract a graph
    (this is for instance, an offline algorithm) where other pathfinding algorithms
    can extract paths when needed (these, instead, work online).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，特别值得一提的是：导航网格。这是重要的，因为它内置在Unity引擎的3D游戏中。这种技术背后的主要概念是对级别几何形状的预分析，以提取一个图（这是一个离线算法），其他寻路算法可以在需要时从中提取路径（这些算法是在线工作的）。
- en: 'You can generate such a graph by setting some parameters by clicking in the
    top menu bar on **Window | Navigation**. Specifically, you can set the general
    options in the **Bake** tab, as shown in the following screenshot:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在顶部菜单栏中点击**窗口 | 导航**来设置一些参数以生成这样的图表。具体来说，您可以在**烘焙**选项卡中设置通用选项，如下面的截图所示：
- en: '![Other techniques for navigation at the pathfinding level](img/image00592.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![在寻路级别上的其他导航技术](img/image00592.jpeg)'
- en: Once this graph is built, agents can have access to it through specific classes
    in scripts.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建了这个图表，代理可以通过脚本中的特定类来访问它。
- en: 'In any case, this belongs to the 3D part of Unity, and we won''t go into it
    any further. But if you are interested in learning more, you can start from the
    official documentation at: [https://docs.unity3d.com/Manual/Navigation.html](https://docs.unity3d.com/Manual/Navigation.html)
    (as you may notice from the table of contents, it''s quite a large and extensive
    tool in Unity, but powerful).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这都属于Unity的3D部分，我们不会进一步深入。但如果您想了解更多，可以从官方文档开始：[https://docs.unity3d.com/Manual/Navigation.html](https://docs.unity3d.com/Manual/Navigation.html)（如您从目录中注意到的，这是Unity中一个相当庞大且功能强大的工具，但非常强大）。
- en: Navigation at the level of steering behaviours
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转向行为级别的导航
- en: Remember how we could implement physics equations in Unity from [Chapter 5](part0062.xhtml#aid-1R42S1
    "Chapter 5. The Secret Ingredient Is a Dash of Physics"), *The Secret Ingredient
    Is a Dash of Physics*? We can implement all the equations of the motion and we
    will obtain any kind of movement. If then, we mix this with a goal, a destination,
    or even just a direction, along with some obstacle avoidance techniques, we have
    made a steering behaviour.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们如何在[第5章](part0062.xhtml#aid-1R42S1 "第5章。物理学的小秘诀")，“物理学的小秘诀”中实现Unity中的物理方程吗？我们可以实现所有运动方程，我们将获得任何类型的运动。如果然后，我们将这个与目标、目的地或甚至只是一个方向混合，再加上一些避障技术，我们就已经实现了一种转向行为。
- en: For instance, if you implement obstacle avoidance as magnets that repulse the
    NPC, and the goal as an attractive magnet, you obtain a pretty nice steering behaviour.
    Characters could reach destinations without any pathfinding algorithms. Note that
    I said *could*. In fact, they can get stuck, and there are many other issues related
    to steering behaviours as an end-solution. But integrating steering behaviours
    in a pathfinding algorithm (the first deals with high-level navigation, such as
    going from one room to another, the second can navigate within the room to reach
    the door to the next room) is a great addition, which can lead to highly-realistic
    behaviours with very low performance overhead.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你将障碍物避免实现为排斥NPC的磁铁，将目标实现为吸引磁铁，你将获得相当不错的转向行为。角色可以在没有路径寻找算法的情况下到达目的地。注意我说的是“可以”。实际上，他们可能会陷入困境，并且与转向行为作为最终解决方案相关的问题还有很多。但是，将转向行为整合到路径寻找算法中（第一个处理高级导航，例如从一个房间到另一个房间，第二个可以在房间内导航以到达下一个房间的门）是一个很好的补充，这可以带来非常逼真的行为，并且性能开销非常低。
- en: '![Navigation at the level of steering behaviours](img/image00593.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![导航在转向行为层面](img/image00593.jpeg)'
- en: Example of steering behaviour with magnets
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 磁铁转向行为的示例
- en: 'Usually, the attraction range of the goal is extended to the whole map, whereas
    the repulsion force of the obstacles is just local. Moreover, these forces can
    follow different potential laws, and have different shapes. To help you to visualize
    magnetic fields, you can give a look at the picture by Dayna Mason at: [https://www.flickr.com/photos/daynoir/2180507211](https://www.flickr.com/photos/daynoir/2180507211).
    Each compass represents which kind of force the character is subject to when he/she
    is in that position. The same happens in our example, where the character is pushed
    away from obstacles and attracted by goals. It is also interesting to note that
    our goals and obstacles are single pole magnets, but in our physical world they
    don’t exist (only magnetic dipoles exist).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，目标的吸引力范围扩展到整个地图，而障碍物的排斥力仅限于局部。此外，这些力可以遵循不同的势能定律，并具有不同的形状。为了帮助你可视化磁场，你可以看看Dayna
    Mason提供的图片：[https://www.flickr.com/photos/daynoir/2180507211](https://www.flickr.com/photos/daynoir/2180507211)。每个指南针代表当角色处于该位置时所受到的力的类型。在我们的例子中也是如此，角色被障碍物推开，被目标吸引。值得注意的是，我们的目标和障碍物是单极磁铁，但在我们的物理世界中它们并不存在（只有磁偶极子存在）。
- en: Navigation at the level of pathfinding/decision making – belief-driven pathfinding
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航在路径寻找/决策制定层面 – 基于信念的路径寻找
- en: As I have already mentioned, research in academia has recently started to merge
    portions of decision-making within pathfinding. An example of this is one of my
    own publications about **Belief-Driven Pathfinding** (**BDP**).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，学术界最近开始将路径寻找中的决策部分进行整合。我的一个关于**基于信念的路径寻找**（**BDP**）的出版物就是这样一个例子。
- en: The key concept is that NPCs do not necessarily know the entire map. Imagine
    there was a bridge to cross a river, but the player had destroyed the bridge;
    therefore, when the character navigates through the environment, the character
    should consider the map as if the bridge was still there, because he is not aware
    that the bridge is down. Only when he approaches the river, he realizes that the
    bridge is down, and therefore, takes action on it (such as find another path,
    build another bridge, create a raft with the wood, or swim). That is why it is
    belief-driven, because the character navigates through the environment as he/she believes
    the environment is and, as such, makes assumptions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 关键概念是NPC不一定知道整个地图。想象一下有一条桥可以跨越河流，但玩家已经摧毁了这座桥；因此，当角色在环境中导航时，角色应该将地图视为桥还在那里，因为他不知道桥已经塌陷。只有当他接近河流时，他才意识到桥已经塌陷，因此，采取行动（例如找到另一条路，建造另一座桥，用木头制作一艘筏子，或者游泳）。这就是为什么它是基于信念的，因为角色按照他/她相信的环境进行导航，并据此做出假设。
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are interested in learning more about BDP, you can check out my website
    at: [francescosapio.com](http://francescosapio.com).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对了解更多关于BDP（行为决策规划）感兴趣，你可以查看我的网站：[francescosapio.com](http://francescosapio.com)。
- en: Beyond navigation
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越导航
- en: AI in games is not limited to only navigation, but as we said in the introduction,
    there are many levels that AI can be applied to in video games. Imagine turn-based
    games, in which NPCs needs to take strategic decisions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的AI不仅限于导航，正如我们在引言中提到的，AI在视频游戏中可以应用于许多层面。想象一下回合制游戏，其中NPC需要做出战略决策。
- en: 'But AI does not only apply to non-player characters. Some games implement algorithms
    to adapt the difficulty to the game (adaptive and learning algorithms), others
    handle how the camera should move in order to raise a specific emotional state
    in the player (such as in the work of Georgios N. Yannakakis in particular, in
    the paper, *Space Maze: Experience-Driven Game Camera Control*). Other games have
    algorithms of **Procedural Content Generation** (**PCG**), like the famous *Temple
    Run* (Imangi studios, 2011) which procedurally generates the level, or even *Minecraft* (Mojang,
    2011) in which a whole world is procedurally generated.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 但人工智能不仅适用于非玩家角色。有些游戏实现了适应游戏难度的算法（自适应和学习算法），有些处理摄像机应该如何移动以在玩家中唤起特定的情感状态（例如，在Georgios
    N. Yannakakis的工作中特别如此，在论文《空间迷宫：基于经验的游戏摄像机控制》中）。其他游戏有**程序内容生成**（**PCG**）的算法，如著名的*Temple
    Run*（Imangi工作室，2011年）通过程序生成关卡，或者甚至是*Minecraft*（Mojang，2011年）中整个世界都是通过程序生成的。
- en: 'AI is also applied for analysis of games and players, such as to study the
    inner structures of games or to gather psychological player profiles. Regarding
    the latter, you need to imagine the application in serious games, where games
    can be used to evaluate the performance of people within specific contexts. You
    can find an interesting introductory paper titled; *Towards personalized, gamified
    systems: an investigation into game design, personality and player typologies* by
    Lauren S. Ferro (available at: [http://dl.acm.org/citation.cfm?id=2513024](http://dl.acm.org/citation.cfm?id=2513024)).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能也应用于游戏和玩家的分析，例如研究游戏的内部结构或收集玩家的心理档案。关于后者，您需要想象在严肃游戏中的应用，在这些游戏中，游戏可以用来评估特定环境中人们的表现。您可以在Lauren
    S. Ferro撰写的有趣的开篇论文《迈向个性化的游戏化系统：对游戏设计、个性和玩家类型的调查》中找到相关信息（可在[http://dl.acm.org/citation.cfm?id=2513024](http://dl.acm.org/citation.cfm?id=2513024)找到）。
- en: Lastly, it's worth mentioning that the relationship between games and AI is
    not mono-directional. In fact, not only do games use AI, but also the opposite
    applies. Some studies and research on AI are helped by video games, which can
    provide a perfect simulation environment (for instance, for robots), and also
    create algorithms that take the place of the player and play the game (without
    cheating, because the AI within the game always uses additional extra data to
    gather the specific state of the game).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得一提的是，游戏与人工智能之间的关系不是单向的。事实上，不仅游戏使用人工智能，反之亦然。一些关于人工智能的研究和研究表明，视频游戏有助于提供完美的模拟环境（例如，为机器人），并且还可以创建替代玩家并玩游戏（不涉及作弊，因为游戏中的AI总是使用额外的数据来收集游戏的具体状态）。
- en: In any case, keep in mind that when AI is used in games, the most important
    aim is not to be realistic, but to create an immersive and entertaining experience
    for the player (which may also result in learning experiences, if the design of
    the game includes that).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，请记住，当人工智能应用于游戏时，最重要的目标不是追求现实感，而是为玩家创造一个沉浸式和娱乐性的体验（如果游戏设计包含这一目标，这也可能导致学习体验）。
- en: Homework
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作业
- en: 'In this chapter, we gained an overview of AI in games. However, we focused
    only on navigation, and in particular, implementing the waypoint system for our
    game. But you can still improve it, and this section proposes some exercises to
    achieve that. Therefore, before the next chapter, I invite you to do the following
    exercises to develop your skills even more:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了游戏中的人工智能。然而，我们只关注了导航，特别是为我们的游戏实现航点系统。但您仍然可以对其进行改进，本节提出了一些练习来实现这一点。因此，在下一章之前，我邀请您完成以下练习，以进一步提高您的技能：
- en: '**Becoming an AI designer and programmer**: Think of five games that you play,
    and select a part of that game that contains NPCs such as the enemies or even
    the boss. Now, write down a list of behaviors that each of them have. Now, remove
    some behaviors, or even add some and think about how it would alter the experience.
    Does it improve it, or does it change the atmosphere entirely? Could you make
    a relatively realistic behavior into intelligent, yet not realistic, by changing
    some of the behaviors, and vice versa? By doing this, you will begin to understand
    the importance that some behaviors play in not only providing life to your characters,
    but in also giving emotions to the player.'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**成为 AI 设计师和程序员**：想想你玩的五款游戏，并选择其中包含非玩家角色（NPC）的部分，比如敌人或甚至Boss。现在，列出它们各自的行为清单。现在，移除一些行为，甚至添加一些，并思考这会如何改变体验。它是改善了体验，还是完全改变了氛围？你能通过改变一些行为，将相对真实的行为变成智能的，反之亦然吗？通过这样做，你将开始理解某些行为在不仅为你的角色提供生命，而且在为玩家提供情感方面的重要性。'
- en: '**Waypoints as colliders**: From the previous chapter, we learnt how to use
    colliders and detect collisions. In particular, we saw how the sprinkles collided
    with Pandas to trigger actions (in this case, to shoot down the Panda). However,
    the same principle can be applied here as well. Instead, to use the `changeDist`
    constant and check the distance from the Panda to the waypoint, we can use the
    `OnTriggerEnter2D()` function again to check when a Panda has reached a waypoint.
    Implement the changing of waypoints in this way, regardless of whether you are
    using the first or second implementation. Little hint: you probably need to set
    a new tag (remember how to set a tag from [Chapter 2](part0028.xhtml#aid-QMFO1
    "Chapter 2. Baking Cupcake Towers"), *Baking Cupcake Towers*?) for the waypoints,
    and add colliders on them too.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**航点作为碰撞体**：在前一章中，我们学习了如何使用碰撞体和检测碰撞。特别是，我们看到了糖果是如何与熊猫碰撞以触发动作的（在这种情况下，是射下熊猫）。然而，同样的原理也可以应用在这里。相反，为了使用
    `changeDist` 常数并检查熊猫到航点的距离，我们可以再次使用 `OnTriggerEnter2D()` 函数来检查熊猫何时到达航点。以这种方式实现航点的改变，无论你使用的是第一个还是第二个实现。小提示：你可能需要为航点设置一个新的标签（记得如何在[第
    2 章](part0028.xhtml#aid-QMFO1 "第 2 章。制作纸杯蛋糕塔")中设置标签，*制作纸杯蛋糕塔*？），并在它们上添加碰撞体。'
- en: '**Waypoints that auto-reach themselves**: In more complex waypoint systems,
    you shouldn''t manually create the chain (even though the solution becomes hard
    to scale when the map becomes bigger). As such, try to design and implement a
    system where the waypoints auto-connect themselves once placed.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**自动到达的航点**：在更复杂的航点系统中，你不应该手动创建链（即使当地图变大时，解决方案变得难以扩展）。因此，尝试设计和实现一个系统，其中航点一旦放置就会自动连接。'
- en: '**Create a Gizmo path displayer**: Back in [Chapter 2](part0028.xhtml#aid-QMFO1
    "Chapter 2. Baking Cupcake Towers"), *Baking Cupcake Towers*, we saw how it was
    possible to use some Gizmo functions to draw useful stuff on the scene. Use those
    functions, and in particular `Gizmos.DrawLine()`, to show the chain of waypoints
    on the **Scene** view.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建 Gizmo 路径显示器**：在[第 2 章](part0028.xhtml#aid-QMFO1 "第 2 章。制作纸杯蛋糕塔")中，我们介绍了如何使用一些
    Gizmo 函数在场景上绘制有用的东西。使用这些函数，特别是 `Gizmos.DrawLine()`，可以在 **场景** 视图中显示航点的链。'
- en: 'And finally, there is a challenge for you:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，有一个挑战给你：
- en: '**Easy waypoint**: In the second implementation, we use a different game object
    for each one of the waypoints. Design and implement a system that is as easy as
    the one implemented in this chapter for designers (so they can drag around the
    waypoints in the **Scene** view, and possibly see the chain from the previous
    exercise), but at the same time is efficient, since it won''t use game objects
    for waypoints (but rather an array stored somewhere).'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**简单航点**：在第二个实现中，我们为每个航点使用不同的游戏对象。设计和实现一个系统，它对设计师来说尽可能简单（这样他们可以在 **场景** 视图中拖动航点，并可能看到之前练习中的链），同时效率高，因为它不会使用游戏对象作为航点（而是存储在某个地方的数组）。'
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learnt the very basics of artificial intelligence in video
    games. We went through an overview about navigation and some common techniques
    used.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了视频游戏中人工智能的非常基础的知识。我们概述了导航和一些常用的技术。
- en: Then, we built our navigation system for our game, based on waypoints. In particular,
    we have implemented two types of waypoint systems for our game, to learn different
    ways of achieving the same results.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们基于航点构建了我们游戏的导航系统。特别是，我们为我们的游戏实现了两种类型的航点系统，以学习实现相同结果的不同方法。
- en: Finally, we had another general overview about AI in games.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们对游戏中的AI又进行了另一个总的概述。
- en: In the next chapter we will finish our game! Already excited? Well, what are
    you waiting for? The next chapter is just a page away.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将完成我们的游戏！已经兴奋了吗？好吧，你在等什么呢？下一章就在一页之隔。
