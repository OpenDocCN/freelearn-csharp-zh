- en: Chapter 4.  Building an Audio Player Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：构建音频播放器应用程序
- en: In this chapter, we move back to native Xamarin. We will integrate native audio
    functions for processing a sound file using the `AVFramework` in iOS with the
    `AVAudioSessions`, `AVAudioSettings`, and `AVAudioRecorder` objects. In Android
    you will use the `MediaPlayer` object from the `Android.Media` library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回到原生 Xamarin。我们将使用 iOS 中的 `AVFramework` 和 `AVAudioSessions`、`AVAudioSettings`、`AVAudioRecorder`
    对象来集成原生音频功能，以处理音频文件。在 Android 中，你将使用 `Android.Media` 库中的 `MediaPlayer` 对象。
- en: 'Expected knowledge:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 预期知识：
- en: Some knowledge of either iOS `AVAudioSessions`, `AVAudioSettings`, and `AVAudioRecorder`,
    or the Android `MediaPlayer` and `MediaRecorder` classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 iOS 的 `AVAudioSessions`、`AVAudioSettings` 和 `AVAudioRecorder` 或 Android 的
    `MediaPlayer` 和 `MediaRecorder` 类有一定的了解
- en: NSLayoutConstraints
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NSLayoutConstraints
- en: 'In this chapter, you will learn the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Project setup
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置
- en: Inversion of control with MVVMCross
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MVVMCross 的控制反转
- en: View models with Xamarin native
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Xamarin 本地创建视图模型
- en: Creating the bindings
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建绑定
- en: NSLayoutContraints
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NSLayoutContraints
- en: MVVMCross setup inside the Portable Class Library
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在便携式类库中设置 MVVMCross
- en: Setting up MVVMCross with iOS
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 iOS 上的 MVVMCross
- en: Setting up MVVMCross with Android
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Android 上的 MVVMCross
- en: The `SoundHandler` interface
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SoundHandler` 接口'
- en: Implementing the iOS `SoundHandler` using the `AVAudioPlayer` framework
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `AVAudioPlayer` 框架实现 iOS 的 `SoundHandler`
- en: The Mvx IoC container
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mvx IoC 容器
- en: The audio player
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频播放器
- en: A cleaner code approach to `NSLayout`
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSLayout` 的更简洁的代码方法'
- en: Creating `AudioPlayerPageViewModel`
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `AudioPlayerPageViewModel`
- en: Implementing the Android `SoundHandler` using the `MediaPlayer` framework
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `MediaPlayer` 框架实现 Android 的 `SoundHandler`
- en: XML and Mvx bindings
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 和 Mvx 绑定
- en: Solution setup
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案设置
- en: Now that we are back to Xamarin native, it's time to get your mind out of XAML
    and back into native iOS and Android. We aren't going to spend much time on user
    interface design, but more on audio processing using the native frameworks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们回到了 Xamarin 本地，是时候让你的思维从 XAML 转回到本地的 iOS 和 Android 了。我们不会在用户界面设计上花费太多时间，而是更多地关注使用原生框架进行音频处理。
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are testing this application on your computer, the microphone will still
    work as it will be using your laptop's microphone.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这台电脑上测试这个应用程序，麦克风仍然会工作，因为它将使用你的笔记本电脑的麦克风。
- en: 'As we have looked into cross-platform applications and code sharing, we are
    going to apply some of these principles to native development and setup an MVVM
    architecture. Let''s begin by setting up three different projects, an iOS, Android,
    and PCL project:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经探讨了跨平台应用程序和代码共享，我们将应用一些这些原则到原生开发中，并设置一个 MVVM 架构。让我们从设置三个不同的项目开始，一个 iOS、Android
    和 PCL 项目：
- en: '![Solution setup](img/B05293_04_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![解决方案设置](img/B05293_04_01.jpg)'
- en: Inversion of control with MVVMCross
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MVVMCross 的控制反转
- en: In the last two chapters, we looked at the IoC container and bootstrapping fundamentals;
    now it's time to use a different library for this principle with Xamarin native.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两章中，我们探讨了 IoC 容器和引导基础；现在，是时候使用不同的库来用 Xamarin 本地实现这个原则了。
- en: 'For all projects, we want to import the `MVVMCross` library:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有项目，我们希望导入 `MVVMCross` 库：
- en: '![Inversion of control with MVVMCross](img/B05293_04_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![使用 MVVMCross 的控制反转](img/B05293_04_02.jpg)'
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: MVVMCross is available for `Xamarin.Forms`, `Xamarin.iOS`, `Xamarin.Android`,
    `Xamarin.Mac`, and Windows, so take your pick.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: MVVMCross 可用于 `Xamarin.Forms`、`Xamarin.iOS`、`Xamarin.Android`、`Xamarin.Mac`
    和 Windows，所以请选择。
- en: MVVMCross is set up quite differently to `AutoFac`, but the principles are the
    same.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: MVVMCross 的设置与 `AutoFac` 非常不同，但原则是相同的。
- en: View-models with Xamarin native
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Xamarin 本地创建视图模型
- en: 'After we add the libraries, let''s start with the `AudioPlayer.Portable` project.
    Create a new folder called `ViewModels`, and add a new file called `MainPageViewModel.cs`.
    Let''s start implementing our first view-model with MVVMCross:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加库之后，让我们从 `AudioPlayer.Portable` 项目开始。创建一个名为 `ViewModels` 的新文件夹，并添加一个名为
    `MainPageViewModel.cs` 的新文件。让我们开始使用 MVVMCross 实现我们的第一个视图模型：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we built our `Xamarin.Forms` view-models, we created our own base view-model
    for handling property changes; using this library we can cut a few corners with
    base properties. `MvxViewModel` has a similar implementation with handling property
    changes; for our `MainPage`, we are going to develop the same first page as the
    last chapter, so let''s start with the private properties:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建我们的`Xamarin.Forms`视图模型时，我们创建了自己的基视图模型来处理属性更改；使用这个库，我们可以对基属性进行一些简化。`MvxViewModel`在处理属性更改方面有类似的实现；对于我们的`MainPage`，我们将开发与上一章相同的第一页，所以让我们从私有属性开始：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice how we are using a different `Command` type, called `MvxCommand`? It
    works very much the same as the `Xamarin.Forms.Command`. Let''s add the public
    properties and see how we handle property changes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用不同的`Command`类型，称为`MvxCommand`？它与`Xamarin.Forms.Command`非常相似。让我们添加公共属性并看看我们如何处理属性更改：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Easy, right?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 简单，对吧？
- en: It is exactly the same as the `set` function. We are checking whether the value
    has changed; if it has, then we set the `private` property and call `RaisePropertyChanged`.
    The only difference is we are passing an action into the function with the `public`
    property.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`set`函数完全相同。我们正在检查值是否已更改；如果已更改，则设置`private`属性并调用`RaisePropertyChanged`。唯一的区别是我们通过`public`属性将操作传递给函数。
- en: 'Now we can start building the user interface for the `MainPage`. This time,
    we are going to develop the iOS interface entirely off a `.cs` sheet. Add a new
    `.cs` file and call it `MainPage.cs`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始构建`MainPage`的用户界面了。这次，我们将完全基于`.cs`文件来开发iOS界面。添加一个新的`.cs`文件，并将其命名为`MainPage.cs`：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating the bindings
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建绑定
- en: 'Our first step is to build the user interface. We are going to add two `UIButtons`, `UILabel`,
    and `UIImageView` to the view controller:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是构建用户界面。我们将在视图控制器中添加两个`UIButtons`、一个`UILabel`和一个`UIImageView`：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now let''s create the bindings for the user interface elements. Add the following
    to the bottom of the `ViewDidLoad` function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为用户界面元素创建绑定。将以下内容添加到`ViewDidLoad`函数的底部：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When we create a binding context (`BindingSet`), we will set up all the bindings
    through the binding set. The first binding is with the `description` label. The
    object we are binding too must be a string (`DescriptionMessage` is our string
    object from the view-model).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建绑定上下文（`BindingSet`）时，我们将通过绑定集设置所有绑定。第一个绑定是与`description`标签的绑定。我们绑定的对象必须是一个字符串（`DescriptionMessage`是我们从视图模型中得到的字符串对象）。
- en: Further on, we can specify the particular properties of a UI element using the
    `For` function, and in the parameter we specify the name of the property. In our
    case, we are specifying the `Title` property of `UIButton`, then calling the `To`
    function to bind our specified string object. We have also done this with `UIViewController`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，我们可以使用`For`函数指定UI元素的特定属性，并在参数中指定属性的名称。在我们的例子中，我们指定了`UIButton`的`Title`属性，然后调用`To`函数来绑定指定的字符串对象。我们也将此操作应用于`UIViewController`。
- en: Finally, the last bindings we are using are `MvxCommands` from our view-model.
    We don't need to specify the property name for this; all we do is call the `To`
    function and specify the command in the view-model.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用的最后一个绑定是我们视图模型中的`MvxCommands`。我们不需要指定属性名称；我们只需调用`To`函数并在视图模型中指定命令。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the `UIImageView` we created, we used an image called `audio.png`. You can
    put in any image you like, provided the name matches the one being loaded inside
    the `UIImage`. All resources for this example can be found via the GitHub link:
    [https://github.com/flusharcade/chapter4-audioplayer](https://github.com/flusharcade/chapter4-audioplayer).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建的`UIImageView`中，我们使用了一个名为`audio.png`的图片。你可以放入任何你喜欢的图片，只要图片的名称与在`UIImage`中加载的名称相匹配。本例中所有资源都可以通过GitHub链接找到：[https://github.com/flusharcade/chapter4-audioplayer](https://github.com/flusharcade/chapter4-audioplayer)。
- en: NSLayoutContraints
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NSLayoutContraints
- en: Let's have a closer look at where we are initializing our UI elements. The `TranslatesAutoresizingMaskIntoConstraints`
    property is used to determine whether we are going to use `NSLayoutConstraints`
    to build our user interface. When we set it to `false`, it means we have to implement
    the layout constraints for this element.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们初始化UI元素的地方。`TranslatesAutoresizingMaskIntoConstraints`属性用于确定我们是否将使用`NSLayoutConstraints`来构建用户界面。当我们将其设置为`false`时，这意味着我们必须为该元素实现布局约束。
- en: 'Now we want to build the user interface using layout constraints. Let''s add
    the following after the elements are added to `mainView`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想使用布局约束来构建用户界面。在将元素添加到`mainView`之后，添加以下内容：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the first two lines, we are adding constraints for the `UIView`. As the
    view contains only one `UIView`, we create two constraints for the vertical and
    horizontal properties of the `mainView` object. The `vertical` property is set
    to the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两行中，我们为 `UIView` 添加了约束。由于视图只包含一个 `UIView`，我们为 `mainView` 对象的垂直和水平属性创建了两个约束。`vertical`
    属性设置为以下内容：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This means `mainView` will be stretched to the entire height of the containing
    view, and the same applies for the `horizontal` property:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `mainView` 将拉伸到包含视图的整个高度，对于 `horizontal` 属性也是如此：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The width of the `mainView` object will be stretched to the entire width of
    the containing view. These two text lines are known as `VisualFormat.NSLayoutContraints`,
    and they use text input as a visual representation, describing how views present
    in their parent views.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`mainView` 对象的宽度将被拉伸到包含视图的整个宽度。这两行文本被称为 `VisualFormat.NSLayoutContraints`，它们使用文本输入作为视觉表示，描述了视图如何在父视图中呈现。'
- en: 'Looking at the other properties we pass into the `AddConstraints` function,
    we pass in `NSLayoutFormatOption` used for the view to abide by (that is, aligned
    left/top), then the metrics and `NSDictionary`, which will contain the UI elements
    involved in the constraint. You will notice some other constraints, such as these:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们传递给 `AddConstraints` 函数的其他属性，我们传递了 `NSLayoutFormatOption`，用于视图遵守（即，左对齐/顶部对齐），然后是指标和
    `NSDictionary`，它将包含涉及约束的 UI 元素。你会注意到一些其他的约束，例如这些：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These constraints include padding around the UI element:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些约束包括围绕 UI 元素的填充：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can even simply place a dash character around the UI element, which will
    place a default padding of `8`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以简单地围绕 UI 元素放置一个破折号字符，这将放置默认填充 `8`。
- en: MVVMCross setup inside the PCL
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 PCL 内部设置 MVVMCross
- en: Further into the MVVMCross framework, let's begin by building the `MvxApplication`
    class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步深入到 MVVMCross 框架中，让我们首先构建 `MvxApplication` 类。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is not the same as the application class inside a `Xamarin.Forms` application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `Xamarin.Forms` 应用程序内的应用程序类不同。
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Pay attention to the `CreatableTypes` function being called; the function uses
    reflection to find all classes in the core assembly that are `Creatable`, meaning
    they have a public constructor and they are not abstract. Then, following this
    function, only register the class interfaces with their names ending in `Service`
    as lazy singletons.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到正在调用的 `CreatableTypes` 函数；该函数使用反射来查找核心程序集中的所有 `Creatable` 类，这意味着它们有一个公共构造函数，并且它们不是抽象的。然后，在此函数之后，仅注册以
    `Service` 结尾的类接口作为懒单例。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The lazy singleton ensures that if a class implements `IOne` and `ITwo`, then
    the same instance will be returned when resolving both `IOne` and `ITwo`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 懒单例确保如果一个类实现了 `IOne` 和 `ITwo`，则在解析 `IOne` 和 `ITwo` 时将返回相同的实例。
- en: 'There is one more part to add to the `Application` class. We must register
    the starting point, so add the following line under the `RegisterAsLazySingleton`
    function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在 `Application` 类中添加另一个部分。我们必须注册启动点，因此请在 `RegisterAsLazySingleton` 函数下添加以下行：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Setting up MVVMCross with iOS
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 iOS 中设置 MVVMCross
- en: 'Now we move over to the iOS project. For each platform, we must implement a
    `Setup` class that will be used to instantiate the `MvxApplication` class. Add
    a new class called `IosSetup` and implement the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们转向 iOS 项目。对于每个平台，我们必须实现一个 `Setup` 类，该类将用于实例化 `MvxApplication` 类。添加一个名为
    `IosSetup` 的新类，并实现以下内容：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Firstly, we must include a constructor that takes in an `MvxApplicationDelegate`
    and `UIWindow`; these will be passed into the base on instantiation. We also have
    two functions that are overriden as part of the `MvxIosSetup` object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须包含一个接受 `MvxApplicationDelegate` 和 `UIWindow` 的构造函数；这些将在实例化时传递给基类。我们还有两个作为
    `MvxIosSetup` 对象一部分被重写的函数。
- en: Start with the `CreateApp` function. All we are doing here is instantiating
    the `MvxApplication` class that we implemented previously. We will break this
    down into more detail when we implement the `AppDelegate` class.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `CreateApp` 函数开始。我们在这里所做的只是实例化我们之前实现的 `MvxApplication` 类。当我们实现 `AppDelegate`
    类时，我们将对此进行更详细的分解。
- en: 'We must also override the `CreateDebugTrace` functions, which will instantiate
    a new `DebugTrace` object. Firstly, let''s create a new folder called `Logging`
    inside our PCL project, add a new file called `DebugTrace.cs`, and implement the
    following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须重写 `CreateDebugTrace` 函数，这将实例化一个新的 `DebugTrace` 对象。首先，让我们在我们的 PCL 项目中创建一个名为
    `Logging` 的新文件夹，添加一个名为 `DebugTrace.cs` 的新文件，并实现以下内容：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As part of the `IMvxTrace` interface, we must implement all these functions.
    The functions are not complicated; we are simply catching errors and outputting
    text to the console when these functions are called. All the functions called
    via the `DebugTrace` object are routed via a singleton object. We will be sharing
    this object between the two platform projects.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `IMvxTrace` 接口的一部分，我们必须实现所有这些功能。这些功能并不复杂；我们只是在调用这些功能时捕获错误并将文本输出到控制台。所有通过
    `DebugTrace` 对象调用的功能都通过一个单例对象路由。我们将在两个平台项目中共享这个对象。
- en: 'Great! Now that we have completed all our MVVMCross requirements for iOS, let''s
    piece it all together via the `AppDelegate` class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们已经完成了所有 iOS 的 MVVMCross 要求，让我们通过 `AppDelegate` 类将这些内容组合起来：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What exactly are we doing in the `FinishedLaunching` function?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `FinishedLaunching` 函数中到底做了什么？
- en: Firstly, we instantiate our `UIWindow` to the size of the main screen bounds.
    Then we instantiate the `IosSetup` class by passing in the new `UIWindow` object,
    and call the `Initialize` function we implemented in our `MvxApplication` in the
    PCL. Then, we use the Mvx IoC container to resolve the `IMvxAppStart` interface
    and call `Start` to begin the application at our `MainPageViewModel`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 `UIWindow` 实例化为主屏幕边界的大小。然后，我们通过传递新的 `UIWindow` 对象实例化 `IosSetup` 类，并调用我们在
    PCL 中的 `MvxApplication` 实现的 `Initialize` 函数。然后，我们使用 Mvx IoC 容器解析 `IMvxAppStart`
    接口，并调用 `Start` 以在 `MainPageViewModel` 上开始应用程序。
- en: Excellent! We have now set up MVVMCross with our iOS project; let's go ahead
    and do the same for the Android project.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在已经设置了 MVVMCross 与我们的 iOS 项目；接下来，让我们为 Android 项目做同样的事情。
- en: Setting up MVVMCross with Android
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 MVVMCross 与 Android
- en: As we already completed the `PCL` setup for `MVVMCross`, we only need to create
    the setup object, which will inherit the `MvxAndroidSetup` class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经完成了 `MVVMCross` 的 `PCL` 设置，我们只需要创建一个设置对象，该对象将继承 `MvxAndroidSetup` 类。
- en: 'Create a new file called `AndroidSetup.cs` and implement the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `AndroidSetup.cs` 的新文件，并实现以下内容：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is very much the same as the iOS setup, but in the constructor we must
    pass in the Android context.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 iOS 设置非常相似，但在构造函数中我们必须传递 Android 上下文。
- en: 'Now for the final setup on Android. We don''t normally have an application
    to override. Instead, MVVMCross by default provides a splash screen. Delete the
    `MainActivity` class that is automatically created, and replace it with a new
    activity called `SplashScreenActivity`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是 Android 的最终设置。我们通常不需要重写应用程序。相反，MVVMCross 默认提供了一个启动画面。删除自动创建的 `MainActivity`
    类，并用一个新的活动 `SplashScreenActivity` 替换它：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We don''t need to add anything into our constructor, but we must add the `MainLauncher
    = true` flag to the attribute to ensure this is the first thing created when the
    platform starts. We must also create the new XML view for the splash screen activity.
    For this example, we are going to create a simple screen with a `TextView`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在我们的构造函数中添加任何内容，但我们必须将 `MainLauncher = true` 标志添加到属性中，以确保这是平台启动时创建的第一件事。我们还必须创建启动画面活动的新的
    XML 视图。在这个例子中，我们将创建一个简单的屏幕，包含一个 `TextView`：
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Try creating a splash screen that will display an image to give the application
    branding.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建一个启动画面，显示一个图像以提供应用程序的品牌。
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'That''s everything; lets test run both platforms and we should now have the
    following screen:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部了；让我们测试运行这两个平台，我们应该现在看到以下屏幕：
- en: '![Setting up MVVMCross with Android](img/B05293_04_03.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![设置 MVVMCross 与 Android](img/B05293_04_03.jpg)'
- en: The SoundHandler interface
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SoundHandler 接口
- en: One issue with playing audio across multiple platforms is we can't share much
    code when processing audio. We must create an interface and register implementations
    through an IoC container.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个平台上播放音频的问题是我们处理音频时不能共享太多代码。我们必须创建一个接口，并通过 IoC 容器注册实现。
- en: 'Our next step is to create the `ISoundHandler` interface. In the `AudioPlayer.Portable`
    project, add in a new folder called `Sound`. In this folder, add a new file called
    `ISoundHandler.cs` and implement the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是创建 `ISoundHandler` 接口。在 `AudioPlayer.Portable` 项目中，添加一个名为 `Sound` 的新文件夹。在这个文件夹中，添加一个名为
    `ISoundHandler.cs` 的新文件，并实现以下内容：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our interface will describe all the functions we will be using to process our
    audio streams via the `AudioPlayerPage` interface.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的接口将描述我们将通过 `AudioPlayerPage` 接口使用到的所有功能。
- en: Now let's go ahead and start with the iOS implementation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始 iOS 的实现。
- en: Implementing the iOS SoundHandler using the AVAudioPlayer framework
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AVAudioPlayer 框架实现 iOS SoundHandler
- en: 'The `AVAudioPlayer` class is the framework we will be using to play and control
    our audio streams in iOS, so let''s begin by adding a new folder called `Sound`
    to the iOS project. We then want to create a new file called `SoundHandler.cs` that
    will inherit the `ISoundHandler` interface:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`AVAudioPlayer`类是我们将在iOS中用于播放和控制音频流的框架，所以让我们首先在我们的iOS项目中添加一个名为`Sound`的新文件夹。然后我们想要创建一个名为`SoundHandler.cs`的新文件，该文件将继承`ISoundHandler`接口：'
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now let''s create a private `AVAudioPlayer` object and add our public `IsPlaying`,
    which will hold the playing status of the audio player:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个私有的`AVAudioPlayer`对象，并添加我们的公共`IsPlaying`，它将保存音频播放器的播放状态：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then we add in the functions of the interface. In each function, we will be
    using the audio player object to do all our audio processing:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加接口的函数。在每个函数中，我们将使用音频播放器对象来完成所有的音频处理：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first function will load the file from the `Resources` folder. In this example,
    we are going to be loading in a Moby song (personally one of my favorites).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数将从`Resources`文件夹中加载文件。在这个例子中，我们将加载一首Moby的歌曲（我个人非常喜欢的一首）。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can add in any audio file, provided the name matches the filename being
    loaded via the `NSURL` object. If you want to use the same file as this one, visit
    the GitHub link stated previously.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加任何音频文件，只要文件名与通过`NSURL`对象加载的文件名匹配。如果你想使用与这个相同的文件，请访问之前提到的GitHub链接。
- en: The second function will control starting and stopping the audio. If we click
    the play button first, it will play and set the status of `IsPlaying` to `true`.
    Then if we click the play button again, it will stop the audio and set the `IsPlaying`
    to `false`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数将控制音频的播放和停止。如果我们首先点击播放按钮，它将播放并将`IsPlaying`的状态设置为`true`。然后如果我们再次点击播放按钮，它将停止音频并将`IsPlaying`设置为`false`。
- en: 'Now for the rest of the implementation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续实现其余部分：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'All of this is straightforward: our `Stop` function will stop the audio. Our
    `Rewind` function will stop the audio and set the current time to 0 (meaning the
    beginning of the audio stream). Our `Forward` function will stop the audio and
    move the current time to the end of the stream. The last two functions will set
    the current position of the audio stream to the double value passed in. This will
    be used with our progress slider; when the slider position changes, the value
    will be passed into this function to update the position of the audio stream.
    Finally, the last function will retrieve the current time value so we can update
    our user interface with this detail.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是直截了当的：我们的`Stop`函数将停止音频。我们的`Rewind`函数将停止音频并将当前时间设置为0（意味着音频流的开始）。我们的`Forward`函数将停止音频并将当前时间移动到流的末尾。最后两个函数将设置音频流的当前位置为传入的双值。这将与我们的进度滑块一起使用；当滑块位置改变时，值将传递到这个函数以更新音频流的当前位置。最后，最后一个函数将检索当前时间值，以便我们可以用这个细节更新我们的用户界面。
- en: Great! Now that we have our sound handler implemented for iOS, we want to register
    this through the IoC container.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们已经为iOS实现了声音处理，我们想要通过IoC容器注册它。
- en: The Mvx IoC container
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mvx IoC 容器
- en: 'MVVMCross comes with its very own IoC container. It works exactly like our
    previous example with Autofac, but we are not going to be using modules. Let''s
    begin by registering our sound handler implementation; open our `AppDelegate.cs`
    file and create a new private function called `setupIoC`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: MVVMCross自带其自己的IoC容器。它的工作方式与我们的上一个例子中的Autofac完全一样，但我们不会使用模块。让我们首先注册我们的声音处理实现；打开我们的`AppDelegate.cs`文件，创建一个名为`setupIoC`的新私有函数：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We must also register our view-models so we can retrieve registered interfaces
    within our view-model''s constructor. Let''s add a new folder called `IoC` inside
    our `AudioPlayer.Portable` project. Add a new file called `PortableMvxIoCRegistrations.cs`
    and implement the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须注册我们的视图模型，这样我们才能在视图模型的构造函数中检索已注册的接口。让我们在我们的`AudioPlayer.Portable`项目中添加一个名为`IoC`的新文件夹。添加一个名为`PortableMvxIoCRegistrations.cs`的新文件，并实现以下内容：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we must call the static function `InitIoC` from the `AppDelegate` function
    `SetupIoC`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须从`AppDelegate`函数`SetupIoC`中调用静态函数`InitIoC`：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that we have everything we require registered inside the IoC container,
    let's begin building the `AudioPlayerPage`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所有需要注册的内容都注册到IoC容器中，让我们开始构建`AudioPlayerPage`。
- en: The audio player
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频播放器
- en: 'Our next step in this project is to build the user interface for controlling
    the audio. Add a new file called `AudioPlayerPage.cs` inside the `Views` folder;
    don''t forget to add the attribute above the class declaration to register the
    view-model for the MVVMCross framework:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们的下一步是构建控制音频的用户界面。在`Views`文件夹内添加一个名为`AudioPlayerPage.cs`的新文件；别忘了在类声明上方添加属性以注册MVVMCross框架的视图模型：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have declared some local scope variables that need to be used across multiple
    functions; you will see how these will be used later.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一些需要在多个函数中使用的局部作用域变量；你将看到这些是如何被使用的。
- en: 'Now let''s create the UI elements via the `ViewDidLoad` function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过`ViewDidLoad`函数创建UI元素：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have labels for displaying the current track name, the start time, and the
    end time. We also have our buttons for controlling the audio stream (play, pause,
    rewind, and forward). Finally, we have our progress slider for animating the current
    time of the audio; we are also going to be using this to change the position of
    the audio.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有标签用于显示当前曲目名称、开始时间和结束时间。我们还有控制音频流的按钮（播放、暂停、快退和快进）。最后，我们有进度滑块用于动画当前音频时间；我们还将使用它来改变音频的位置。
- en: 'We now want to add the button events for controlling some UI changes on the
    button images; add the event handler assignation under the declaration of the
    play button:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想要为按钮添加控制按钮图像上一些UI变化的按钮事件；在播放按钮声明下添加事件处理程序分配：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `TouchUpInside` event will fire every time we click the button.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`TouchUpInside`事件会在我们点击按钮时触发。'
- en: 'Then create the function for the event handler:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建事件处理程序函数：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Every time we click the play button, it will move the image back and forth
    between the play and pause icon. Now let''s add the rewind and forward button
    handlers; add the following lines under each UI element declaration:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们点击播放按钮时，它都会在播放和暂停图标之间移动图像。现在让我们添加快退和快进按钮处理程序；在每个UI元素声明下添加以下行：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we add the event handler function:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加事件处理程序函数：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is similar to the play button handler, but this time we always set the
    playing status to false, and set the play button image to the play icon.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这与播放按钮处理程序类似，但这次我们总是将播放状态设置为false，并将播放按钮图像设置为播放图标。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For all audio images, please visit the GitHub link given previously.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有音频图像，请访问之前给出的GitHub链接。
- en: A cleaner code approach to NSLayout
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NSLayout的更简洁的代码方法
- en: On our previous screen, we built a very simple user interface using `NSLayoutContraints`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的屏幕上，我们使用`NSLayoutContraints`构建了一个非常简单的用户界面。
- en: Would you agree that the code looked quite clunky?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你会同意代码看起来相当笨拙吗？
- en: 'With our `AudioPlayerPage`, we are going to use a cleaner approach to coding
    the `NSLayoutConstraints`. Firstly, create a new folder called `Extras`, and add
    a new file called `DictionaryViews.cs`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`AudioPlayerPage`，我们将采用更简洁的方法来编写`NSLayoutConstraints`。首先，创建一个名为`Extras`的新文件夹，并添加一个名为`DictionaryViews.cs`的新文件：
- en: '![A cleaner code approach to NSLayout](img/B05293_04_04.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![NSLayout的更简洁的代码方法](img/B05293_04_04.jpg)'
- en: 'This class is going to inherit the `IEnumerable` interface in order to create
    an `NSDictionary`; part of this interface is we must specify the `GetEnumerator`
    function. It will pull this from the `NSDictionary`; we also have our `Add` function,
    which simply adds a new `UIView` to the dictionary. Then we have the static implicit
    operator which will return the object as an `NSDictionary` (this is used so we
    can directly pass the object as an `NSDictionary` to the `FromVisualLayout` function):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将继承`IEnumerable`接口以创建一个`NSDictionary`；该接口的一部分是我们必须指定`GetEnumerator`函数。它将从`NSDictionary`中获取这个函数；我们还有一个`Add`函数，它简单地将一个新的`UIView`添加到字典中。然后我们有静态隐式转换操作符，它将返回一个`NSDictionary`对象（这是为了我们可以直接将对象作为`NSDictionary`传递给`FromVisualLayout`函数）：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now let''s go ahead and create one of these inside our `AudioPlayerPage`; paste
    the following under the declaration of the fast forward button:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续在`AudioPlayerPage`内部创建这些之一；在快进按钮声明下粘贴以下内容：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Great! We now have a new `IEnumerable`/`NSDictionary` with all the required
    views to be used through the entire interface. We can directly pass this object
    into the `NSLayoutConstraint` function `FromVisualFormat` so we don''t need to
    repeat the declaration of new dictionaries when we create each `NSLayoutContraint`.
    Now add all the UI elements to the correct parent views:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在有一个新的`IEnumerable`/`NSDictionary`，其中包含整个界面中需要使用的所有必需视图。我们可以直接将此对象传递给`NSLayoutConstraint`函数`FromVisualFormat`，这样我们就不需要在创建每个`NSLayoutContraint`时重复声明新的字典。现在将所有UI元素添加到正确的父视图中：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then let''s build all the `NSLayoutConstraints`; our first is the `UIViewController''sUIView`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们构建所有的`NSLayoutConstraints`；我们的第一个是`UIViewController'sUIView`：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We have our new approach, using the `System.Linq` function `Concat` to combine
    all the `NSLayoutContraints` required for the view. We only have to call the `AddConstraints`
    function once, and pass in one array of all the required constraints for that
    parent view.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`System.Linq`函数`Concat`来组合所有必需的`NSLayoutContraints`，用于视图。我们只需要调用一次`AddConstraints`函数，并传递一个包含该父视图所需所有约束的数组。
- en: 'Let''s add our constraint for `mainView` and `buttonView`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加对`mainView`和`buttonView`的约束：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is exactly the same approach, but it looks much nicer and it reduces the
    number of times we call `AddConstraints`. The view only needs to add all the constraints
    once, and lay out the elements once, so it is much more efficient.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全相同的方法，但看起来更美观，并且减少了调用`AddConstraints`的次数。视图只需要添加所有约束一次，并布局一次元素，因此效率更高。
- en: 'Our final step in building the user interface is to set up the MVVMCross bindings;
    we use the same approach as the `MainPage`. Let''s create a new binding set between
    the `AudioPlayerPage` and the `AudioPlayerPageViewModel`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 构建用户界面的最后一步是设置MVVMCross绑定；我们使用与`MainPage`相同的方法。让我们在`AudioPlayerPage`和`AudioPlayerPageViewModel`之间创建一个新的绑定集：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Before we get into creating our bindings, let's first build our `AudioPlayerPageViewModel`
    for the `AudioPlayer.Portable` project.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建绑定之前，让我们首先为`AudioPlayer.Portable`项目构建`AudioPlayerPageViewModel`。
- en: Creating AudioPlayerPageViewModel
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建AudioPlayerPageViewModel
- en: 'Our `AudioPlayerPageViewModel` must include our `ISoundHandler` interface.
    We are going to be controlling the audio from this view-model, so our buttons
    can initiate the required events on the sound handler. Let''s begin by making
    a new file inside the `ViewModels` folder called `AudioPlayerPageViewModel.cs`,
    and implementing the private properties to begin with:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`AudioPlayerPageViewModel`必须包含我们的`ISoundHandler`接口。我们将从这个视图模型控制音频，因此我们的按钮可以启动声音处理程序上所需的事件。让我们首先在`ViewModels`文件夹中创建一个名为`AudioPlayerPageViewModel.cs`的新文件，并从实现私有属性开始：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Then we must add the `public` properties.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们必须添加`public`属性。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are only going to show two of the `public` properties as examples, as the
    code is repetitive.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只展示两个`public`属性作为示例，因为代码是重复的。
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We also need to add these two public variables, which are going to take both
    the `CurrentTime` and `EndTime` double values and create a formatted string from
    a `TimeSpan` value.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加这两个公共变量，它们将接受`CurrentTime`和`EndTime`的双精度值，并从`TimeSpan`值创建一个格式化的字符串。
- en: 'Notice how we are also calling `RaisePropertyChanged` on the string inside
    the double setter? Every time we get a new current time value, the formatted string
    needs to update as well:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们也在双setter中的字符串上调用`RaisePropertyChanged`吗？每次我们获取一个新的当前时间值时，格式化的字符串也需要更新：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now for our constructor function:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们的构造函数：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here we are pulling out the `ISoundHandler` implementation from the IoC container,
    as we will be registering this view-model inside the IoC container.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从IoC容器中提取了`ISoundHandler`实现，因为我们将在IoC容器中注册这个视图模型。
- en: Our next step is to add two new functions to the view-model, `Load` and `Dispose`.
    These two functions will be called when the `AudioPlayerPage` is shown, and when
    it disappears. They will also be used when the audio stream is started and stopped.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是向视图模型添加两个新函数，`Load`和`Dispose`。这两个函数将在`AudioPlayerPage`显示和消失时被调用，并且当音频流开始和停止时也会被使用。
- en: 'Let''s first add the `Load` function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加`Load`函数：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `Load` function will be called when the page is shown, and when the audio
    stream starts. The function uses the `Task` framework to run a repeating loop
    in the background, so every second we will retrieve the current time of the audio
    stream from the `ISoundHandler` interface. We propagate the updates to the current
    time label on the `AudioPlayerPage` interface.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面显示和音频流开始时，将调用`Load`函数。该函数使用`Task`框架在后台运行一个重复循环，因此每秒我们将从`ISoundHandler`接口检索音频流的当前时间。我们将更新传播到`AudioPlayerPage`接口上的当前时间标签。
- en: Notice how we are using the `SynchronisationContext.Current` variable?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何使用`SynchronisationContext.Current`变量的？
- en: This is used for threading purposes so we make sure that we set our `CurrentTime`
    variable on the main UI thread. Since this loop is running on a separate thread,
    if we made changes to this variable on a separate thread, it will break the application
    because you are trying to make UI changes off the main UI thread.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于线程目的，所以我们确保我们在主UI线程上设置我们的`CurrentTime`变量。由于这个循环是在一个单独的线程上运行的，如果我们在这个变量上进行了更改，它将破坏应用程序，因为你在尝试在主UI线程之外进行UI更改。
- en: 'Now for the `Dispose` function; this will be called every time the `AudioPlayerPage`
    disappears and when the audio stream is stopped (we don''t need to make updates
    to the UI when the audio stream is not playing). This ensures we stop the background
    loop when the page is not visible:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Dispose`函数；这个函数将在`AudioPlayerPage`消失和音频流停止时被调用（当音频流没有播放时，我们不需要更新UI）。这确保了当页面不可见时停止后台循环：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The private variable `_updating` is used to control the status of whether the
    background loop is running, so we make sure that only one background loop is running
    at any one time.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 私有变量`_updating`用于控制后台循环是否正在运行的状态，因此我们确保在任何时候只有一个后台循环正在运行。
- en: 'Now let''s initiate the audio commands:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始音频命令：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Looking more closely at these commands, using `PlayPauseCommand` we will call
    `Load` or `Dispose` based on the playing status of the audio stream, and it will
    also call `PlayPause` on the `ISoundHandler` interface, which controls the audio
    stream. The `rewindCommand` property will set the current time to 0, set the current
    time on the audio stream to 0, and stop the background loop. The `forwardCommand`
    property will set the current time to the end duration of the audio stream (which
    it will retrieve from the `ISoundHandler` interface), set the current time on
    the audio stream to the end duration, and stop the background loop.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 更仔细地查看这些命令，使用`PlayPauseCommand`，我们将根据音频流的播放状态调用`Load`或`Dispose`，并且它还会在`ISoundHandler`接口上调用`PlayPause`，这控制着音频流。`rewindCommand`属性将当前时间设置为0，将音频流的当前时间设置为0，并停止后台循环。`forwardCommand`属性将当前时间设置为音频流的结束持续时间（它将从`ISoundHandler`接口检索），将音频流的当前时间设置为结束持续时间，并停止后台循环。
- en: 'Finally, we have to create a `public` function to set the current time of the
    audio stream. This will be used by our progress slider every time the value changes,
    this function will be called:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须创建一个`public`函数来设置音频流的当前时间。这个函数将在进度条值每次变化时被我们的进度条使用，这个函数将被调用：
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now revert back to the `AudioPlayerPage` and add the final additions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到`AudioPlayerPage`并添加最终的功能。
- en: 'Since we declared a local variable before for the view-model that is bound
    to the view, we want to pull this out of the data context of the `UIView`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在绑定到视图的视图模型之前声明了一个局部变量，我们希望将其从`UIView`的数据上下文中提取出来：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Our local variable has the bounded view-model. We need to call some public
    methods on the view-model from our view. We must add in our event handler for
    the `ValueChanged` event on the progress slider. Add the following under the declaration
    of the progress slider:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的局部变量绑定了一个视图模型。我们需要从我们的视图中调用视图模型的一些公共方法。我们必须在进度条声明的下面添加对进度条`ValueChanged`事件的`event
    handler`。添加以下内容：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then create the event handler function:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建事件处理函数：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And add the calls to the `Load` function when the page appears:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面出现时，添加对`Load`函数的调用：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Override `ViewDidDisappear` to call the `Dispose` function:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 重写`ViewDidDisappear`以调用`Dispose`函数：
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And create the following bindings in the binding set:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在绑定集中创建以下绑定：
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We have our labels bound to the description, which are hard coded. This is why
    we must make changes to the `CurrentTime` variable on the main UI thread, because
    it affects what is displayed on the `currentLabel`. We also have our `MvxCommand`
    bindings on our audio buttons. Finally, we have our bindings on the `Value` property
    of the progress slider to match the `CurrentTime` variable, and the `MaxValue`
    to match the end time of the audio stream, so it matches the percentage playing
    time of the audio stream.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将标签绑定到描述，这些是硬编码的。这就是为什么我们必须在主UI线程上更改`CurrentTime`变量，因为它会影响`currentLabel`上显示的内容。我们还在音频按钮上绑定了`MvxCommand`。最后，我们在进度条的`Value`属性上绑定了绑定，以匹配`CurrentTime`变量，并将`MaxValue`与音频流的结束时间相匹配，以便与音频流的播放百分比相匹配。
- en: Excellent! Try running the application and playing around with the play/pause
    and progress slider functionality.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！尝试运行应用程序，并尝试播放/暂停和进度滑块功能。
- en: Let's move on to building the equivalent for the Android version.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续构建Android版本的等效功能。
- en: Implementing the Android SoundHandler using the MediaPlayer framework
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MediaPlayer框架实现Android SoundHandler
- en: To implement the same functionality for the sound handler interface in Android,
    we will be using the the `MediaPlayer` framework.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Android中实现声音处理接口的相同功能，我们将使用`MediaPlayer`框架。
- en: 'Let''s create a new folder in the Android project called `Sound`, and create
    a new file called `SoundHandler.cs`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Android项目中创建一个新的文件夹，命名为`Sound`，并创建一个名为`SoundHandler.cs`的新文件：
- en: '[PRE53]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The same as the iOS version, let''s add the `Load` and `PlayPause` functions:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与iOS版本相同，让我们添加`Load`和`PlayPause`函数：
- en: '[PRE54]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We have some exception handling in the `Load` function just in case for any
    reason the file doesn''t load; it will stop our app from crashing. When you place
    the `.mp3` inside the Android project, it must be placed in the `Assets` folder,
    and make sure the file build action is set to `AndroidAsset`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Load`函数中，我们有一些异常处理，以防文件由于任何原因无法加载；这将阻止我们的应用程序崩溃。当你将`.mp3`放入Android项目时，它必须放在`Assets`文件夹中，并确保文件的构建操作设置为`AndroidAsset`：
- en: '![Implementing the Android SoundHandler using the MediaPlayer framework](img/B05293_04_05.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![使用MediaPlayer框架实现Android SoundHandler](img/B05293_04_05.jpg)'
- en: Inside our `load` function, after we initialize the `MediaPlayer` object, we
    set the stream type to `Stream.Music`, and then we use `AssestFileDescriptor`
    to retrieve the `.mp3` file. The `MediaPlayer's` source is then set to the `.mp3`
    file from `AssetFileDescriptor`. We then call `Prepare` and set the volume to
    full (1.0f).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`load`函数中，初始化`MediaPlayer`对象之后，我们将流类型设置为`Stream.Music`，然后使用`AssetFileDescriptor`检索`.mp3`文件。然后，我们将`MediaPlayer`的源设置为来自`AssetFileDescriptor`的`.mp3`文件。接下来，我们调用`Prepare`并设置音量为最大（1.0f）。
- en: Our `PlayPause` function is very simple; we simply check whether the audio is
    playing to determine whether we pause or start the audio stream.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`PlayPause`函数非常简单；我们只需检查音频是否正在播放，以确定是暂停还是开始音频流。
- en: 'Now for the other functions:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是其他函数：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `Stop` function requires the `Reset` function to be called on the `MediaPlayer`
    after we call `Stop`. The `Duration` and `CurrentPosition` functions require the
    value to be divided by 1,000, as the values from `MediaPlayer` are in milliseconds.
    This is the same when we call `SeekTo` on `MediaPlayer`; because we are passing
    in a value in seconds, it has to be multiplied by 1,000 to give the answer in
    milliseconds. Then on to the `Rewind` and `Forward` functions; we must `Pause`
    the audio stream first then call the `SeekTo` method to set the stream position.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stop`函数需要在调用`Stop`之后在`MediaPlayer`上调用`Reset`函数。`Duration`和`CurrentPosition`函数需要将值除以1,000，因为`MediaPlayer`的值是以毫秒为单位的。当我们调用`MediaPlayer`上的`SeekTo`时也是如此；因为我们传递的是以秒为单位的值，所以它必须乘以1,000以得到以毫秒为单位的答案。然后是`Rewind`和`Forward`函数；我们必须首先`Pause`音频流，然后调用`SeekTo`方法来设置流位置。'
- en: Excellent! We now have our Android implementation for the `ISoundHandler` interface,
    so let's get on to building the Android user interface.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在有了`ISoundHandler`接口的Android实现，所以让我们开始构建Android用户界面。
- en: XML and Mvx bindings
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML和Mvx绑定
- en: 'Our Android user interface will start at `MainPage`, so we need to add a new
    file called `MainPage.xml`, and a new `MvxActivity` called `MainPage.cs`. Firstly,
    add in a new folder called `Views`; this is where we will be storing our `MvxActivities`.
    Let''s add a new file called `MainPage.cs` to the `Views` folder, and create a
    new file in the **Resources** | **Layout** folder called `Main.xml`. Our `Main.xml`
    is going to start with a `LinearLayout` and contain four elements: `ImageView`,
    `TextView`, and two `Buttons`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Android 用户界面将从 `MainPage` 开始，因此我们需要添加一个名为 `MainPage.xml` 的新文件，以及一个名为 `MainPage.cs`
    的新 `MvxActivity`。首先，添加一个名为 `Views` 的新文件夹；这是我们将会存储我们的 `MvxActivities` 的地方。让我们将一个名为
    `MainPage.cs` 的新文件添加到 `Views` 文件夹中，并在 **资源** | **布局** 文件夹中创建一个名为 `Main.xml` 的新文件。我们的
    `Main.xml` 将以 `LinearLayout` 开始，并包含四个元素：`ImageView`、`TextView` 和两个 `Buttons`：
- en: '[PRE56]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s look more closely at the `local:Mvxbind` properties on the `Buttons`
    and `TextView`. This is where we will set up our bindings to the view-model. We
    must also add this line:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看 `Buttons` 和 `TextView` 上的 `local:Mvxbind` 属性。这是我们将会设置到视图模型的绑定。我们还需要添加以下这一行：
- en: Does this look familiar?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来熟悉吗？
- en: It is the same as our XAML sheets in `Xamarin.Forms`; we must import this namespace
    so we can use the binding properties on our UI elements.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 它与我们的 `Xamarin.Forms` 中的 XAML 表格相同；我们必须导入此命名空间，以便我们可以在我们的 UI 元素上使用绑定属性。
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't forget to copy all the images into the `drawable` folder before you try
    building the project.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试构建项目之前，别忘了将所有图像复制到 `drawable` 文件夹中。
- en: MvxActivities
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MvxActivities
- en: '`MvxActivities` are an extended object from a regular Android `Activity`; the
    app knows we are using the MVVMCross binding system.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`MvxActivities` 是从常规 Android `Activity` 扩展而来的对象；应用程序知道我们正在使用 MVVMCross 绑定系统。'
- en: 'Let''s implement `MainPageMvxActivity`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现 `MainPageMvxActivity`：
- en: '[PRE57]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We will need to set up our IoC registrations in the IoC container when this
    activity is created. Then we simply set the content view to the XML sheet we created
    previously. Let''s test out the Android application and click run; you should
    now have a `MainPage` screen like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当此活动创建时，我们需要在 IoC 容器中设置我们的 IoC 注册。然后我们只需将内容视图设置为之前创建的 XML 表格。让我们测试一下 Android
    应用程序并点击运行；你现在应该有一个像这样的 `MainPage` 屏幕：
- en: '![MvxActivities](img/B05293_04_06.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![MvxActivities](img/B05293_04_06.jpg)'
- en: 'Now we move on to the fun part: let''s add a new `.xml` and `MvxActivity` for
    the `AudioPlayerPage`. Before we begin implementing the user interfaces for this
    page, we will need to create a custom `SeekBar`, because we want to register a
    new type of event for the `"UP"` motion event. Create a new folder called `Controls`
    and add a new file called `CustomSeekBar.cs`, then implement the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续到有趣的部分：让我们为 `AudioPlayerPage` 添加一个新的 `.xml` 和 `MvxActivity`。在我们开始实现此页面的用户界面之前，我们需要创建一个自定义的
    `SeekBar`，因为我们想要为 `"UP"` 动作事件注册一个新的类型的事件。创建一个名为 `Controls` 的新文件夹，并添加一个名为 `CustomSeekBar.cs`
    的新文件，然后实现以下内容：
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We need to do this custom event because we are binding the progress of the audio
    stream to the SeekBar. Since we want to control the audio position, we need to
    make sure that only this event fires when we finish moving the seek bar.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这样做自定义事件，因为我们正在将音频流的进度绑定到 SeekBar。由于我们想要控制音频位置，我们需要确保只有在我们完成移动 SeekBar 时才触发此事件。
- en: Why can't we just use the `ProgressChanged` event, isn't that the same thing?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不能直接使用 `ProgressChanged` 事件，这不是同一件事吗？
- en: If we were to register the view-model function `UpdateAudioPosition` to the
    `ProgressChanged` event, every time the background loop updates the current time
    property, the SeekBar will call this event and try to set the audio position every
    second we update the SeekBar.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将视图模型函数 `UpdateAudioPosition` 注册到 `ProgressChanged` 事件，每当后台循环更新当前时间属性时，SeekBar
    将调用此事件并尝试每秒更新一次 SeekBar 的音频位置。
- en: 'Now let''s build the XML for the `AudioPlayerPage`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为 `AudioPlayerPage` 构建XML：
- en: '[PRE59]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: It is a fairly large `.xml` sheet. Starting from the top, we have `LinearLayout`,
    which contains `ImageView` at the very top where we will display the album art.
    We then have two `LinearLayouts`, which contain horizontal orientation for the
    three `ImageButtons` and the `TextViews`. These are stacked one under the other.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个相当大的 `.xml` 表格。从顶部开始，我们有 `LinearLayout`，其中包含在最顶部的 `ImageView`，我们将在这里显示专辑封面。然后我们有两个
    `LinearLayouts`，它们包含水平方向的三个 `ImageButtons` 和 `TextViews`。这些是堆叠在一起的。
- en: Finally, we have our custom `SeekBar` at the very bottom under the `TextView`
    items. You will notice the `layout_weight` property used on the `TextView` items,
    so both have the same width. We then use `gravity` to float each label to either
    side of the `SeekBar`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`TextView`项的底部添加了我们自定义的`SeekBar`。你会注意到在`TextView`项上使用了`layout_weight`属性，所以它们都有相同的宽度。然后我们使用`gravity`将每个标签浮动到`SeekBar`的两侧。
- en: 'Fantastic! Now let''s add the `MvxActivity` for the `AudioPlayerPage` to the
    `Views` folder, and implement the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在让我们将`AudioPlayerPage`的`MvxActivity`添加到`Views`文件夹中，并实现以下内容：
- en: '[PRE60]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'It all looks very similar to the iOS page. We assign the same types of event
    for each audio button. Now add the event functions:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来与iOS页面非常相似。我们为每个音频按钮分配相同类型的事件。现在添加事件函数：
- en: '[PRE61]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You will notice the `NoHistory` flag set to true on this `Activity`, so every
    time we load the `Activity`, it loads a new `Activity`, and does not load any
    previously created `AudioPlayerPage`. We also override the `OnDestroy` function
    so it will call the `Dispose` method on our view-model.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这个`Activity`上的`NoHistory`标志被设置为true，所以每次我们加载`Activity`时，它都会加载一个新的`Activity`，而不会加载任何之前创建的`AudioPlayerPage`。我们还重写了`OnDestroy`函数，以便它在我们的视图模型上调用`Dispose`方法。
- en: 'There is an equivalent to the following iOS line:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 下面这行iOS代码有等价物：
- en: '[PRE62]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This is much more straightforward in Android:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在安卓中，这要简单得多：
- en: '[PRE63]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: And voila! We now have our Android version.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦！我们现在有了我们的安卓版本。
- en: Try running the project and relax to one of Moby's greatest hits.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行项目，并放松一下，听听Moby最伟大的作品之一。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we implemented audio on iOS and Android using `Xamarin.iOS`
    and `Xamarin.Android`. We learned how to load audio, stream audio, and process
    audio via start, stop, play, pause, rewind, and fast forward commands. We also
    built an MVVM architecture for native using MVVM Cross. In the next chapter, we
    will build an application for absorbing a web service using `Xamarin.Forms`. We
    will set up a `ListView` and create an `ObservableCollection` for displaying JSON
    objects.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用`Xamarin.iOS`和`Xamarin.Android`在iOS和安卓上实现了音频功能。我们学习了如何通过开始、停止、播放、暂停、倒退和快进命令来加载、流式传输和处理音频。我们还使用MVVM
    Cross为原生应用构建了MVVM架构。在下一章中，我们将使用`Xamarin.Forms`构建一个用于吸收网络服务的应用程序。我们将设置一个`ListView`并创建一个`ObservableCollection`来显示JSON对象。
