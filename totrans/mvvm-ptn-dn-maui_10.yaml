- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Remote Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we’ve dug deep into MVVM and .NET MAUI, covering everything from the
    basics of the MVVM design, from data binding and Dependency Injection to navigation
    and handling user input. But there’s one big piece of the puzzle we haven’t tackled
    yet: getting data from the internet.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s hard to imagine an app these days that doesn’t talk to an online service
    to grab fresh data. Adding backend communications also means we need to tackle
    some architectural challenges such as maintaining separation of concerns, building
    your app with maintainability in mind, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we’ll dive into in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the model architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API communication with Refit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API communication from ViewModels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, our *Recipes!* app will be more than just a standalone
    thing. It’ll communicate with a backend service to fetch fresh data and push updates.
    We’re going to equip it with the essential tools and skills needed for solid MVVM
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we update the general architecture of the *Recipes!* app to
    better facilitate communication with remote APIs. To ensure you’re on the same
    page, all resources and code snippets are available on GitHub: [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter10](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter10).
    If you wish to code along, start with the code in the `Start` folder, which has
    been refactored to serve as the foundation for this chapter. Upon completion,
    you can compare your work with the `Finish` folder to see the finalized version.'
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the model architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our journey so far, our model has been straightforward. We simply used services
    that read local JSON files and fed **Data Transfer Objects (DTOs)** directly to
    our ViewModels. But as we introduce remote data, this simplistic model won’t suffice.
  prefs: []
  type: TYPE_NORMAL
- en: A straightforward approach would be to make an API call directly within our
    service and pass the resulting DTOs to our ViewModels. However, leaning on the
    principle of SoC, I believe services shouldn’t be making API calls. Moreover,
    using API-specific DTOs directly within our ViewModels is a slippery slope. It
    tightly couples our application with the external API, which can lead to maintenance
    nightmares, especially if the API changes often or isn’t under our control.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, I advocate for mapping these DTOs to **Plain Old CLR Objects (POCOs)**,
    or entities or domain models – whatever you prefer to name them. The core idea?
    Work with types we own and control.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: By keeping the interaction points between our app and the API to a minimum,
    our code will be less impacted by potential API changes, enhancing maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'To realize this, we’ll introduce the concept of **repositories** in our architecture.
    These repositories will interface with the API (or any data source), fetch the
    DTOs, map them to our domain models, and then supply them to our services and
    ViewModels. The following diagram captures this envisioned architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: Architectural overview](img/B20941_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Architectural overview'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, one might ask: is this really needed? Can’t we just directly call an API
    from a service while using DTOs in our ViewModels? The answer is no, it is not
    needed; you can perfectly well call an API from a service if you want. This can
    definitely work for smaller “dumb” apps where all the business logic is done on
    the server. But as we scale or tackle more complex scenarios, thoughtful architecture
    becomes crucial for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation of concerns**: By introducing repositories, we distinctly segregate
    the roles within our system. Repositories are primarily concerned with fetching
    data from a data source – be it an API or another data store – and then translating
    it into a format our services can readily use. Positioning the repository layer
    outside of the core project not only emphasizes its distinct responsibility but
    also ensures that changes or expansions to data sources don’t interfere with the
    core business logic. This separation enhances the system’s adaptability and maintainability.
    It becomes clear that the repository’s sole purpose is data retrieval, acting
    as a thin layer that fetches data from various sources and feeds it to the core
    services. With repositories acting as intermediaries, changes to the data source
    or alterations to the data structure are centralized, streamlining modifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved testability**: By introducing a repository layer, we enhance our
    app’s testability. With repositories in place, we can effortlessly mock the data
    layer in our tests. This abstraction ensures our tests focus on the logic within
    our services, free from dependencies on external data sources. In [*Chapter 13*](B20941_13.xhtml#_idTextAnchor223),
    *Unit Testing*, we will be looking at this in much more detail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Augmented services**: The service layer remains free to introduce additional
    features such as caching, business logic, or data aggregation from multiple repositories.
    This decoupling means services aren’t tied directly to specific data sources and
    can evolve independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we dive deep into the concepts of repositories and other details, let’s
    explore the solution found in the `Start` folder of this chapter’s accompanying
    code base to understand the changes that have been made.
  prefs: []
  type: TYPE_NORMAL
- en: Updates to the codebase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we journey deeper into creating a robust MVVM architecture, it’s crucial
    to familiarize ourselves with changes and additions that have been made to the
    code base. If you take a look at the `Start` folder of the accompanying repository
    for this chapter, you’ll notice some changes. Here are notable updates:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Recipes.Web.Api` API project has been added. At its core, it still reads
    from local JSON files, reminiscent of our earlier services. The implementation
    of the API is pretty bare-bones and only for demo purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new `Recipes.Shared` project holds the DTOs that the API returns and accepts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Features` folder of the `Recipes.Client.Core` project, we’ve added new
    POCO or domain entities. These are reflections of our DTOs but designed to be
    entirely under our control, ensuring a smoother integration with the rest of our
    app’s infrastructure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new `Recipes.Client.Repositories` project has been created. This project will
    hold the implementations of the repositories that we will be creating. The idea
    is to keep them separate from the `Recipes.Client.Core` project so that the core
    project is completely isolated from the API and its DTOs. This project also contains
    mappers that map the DTOs returned by the API to POCO entities that we will be
    using throughout the app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The services and ViewModels no longer depend upon DTOs. Now, they interact solely
    with our own POCOs, ensuring a clean and maintainable architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ratings.json` and `recipedetails.json` files have been removed from the
    `Recipes.Mobile` project as we are going to fetch our data from the API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The registrations of `IRecipeService` and `IRatingsService` in the `MauiProgram`
    class have been updated to the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These changes set the stage for the introduction of repositories and interactions
    with the API.
  prefs: []
  type: TYPE_NORMAL
- en: Always return a result
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In conventional coding, exceptions are commonly used to indicate failure. While
    they’re useful for *exceptional* cases, they might not be the best choice for
    regular, expected error scenarios. Using exceptions for expected errors can clutter
    the code and make it harder to follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s why I tend to use a `Result<TSuccess>` object to handle such cases.
    This object acts as a wrapper around the data we expect on success (`TSuccess`)
    and provides fields for an error code, error data, and an `Exception` error in
    the case of failure. It’s a very simple and convenient wrapper, as you can see
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As the following code block shows, this class also contains some static methods
    that instantiate a `Success` or `Fail` `Result` object, facilitating the usage
    of this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the `Result` object, we can easily distinguish between two types of
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unexpected errors**: These are real “exceptions” that we can’t predict and
    don’t know how to handle. They are still best managed by throwing exceptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Result` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, a mobile app unable to retrieve data isn’t an exceptional case;
    it’s a scenario we should plan for. The `Result` object allows us to handle such
    situations gracefully without resorting to exceptions. It offers a richer context
    than simply returning `null` or `false`, letting us understand why an operation
    failed. This even works when we talk to an API that we don’t control: this is
    just a simple wrapper around an object.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Result` object brings clarity and consistency to our code. It removes uncertainties
    such as “*Can this method throw an exception? If so, what type? Is it the same
    exception type thrown in* *similar scenarios?*”
  prefs: []
  type: TYPE_NORMAL
- en: Errors versus exceptions
  prefs: []
  type: TYPE_NORMAL
- en: 'By segregating expected errors from true exceptions, we make the code more
    readable and maintainable. It lets exceptions be what they should be: indicators
    of critical, unexpected failures.'
  prefs: []
  type: TYPE_NORMAL
- en: As we extend our *Recipes!* app to communicate with a backend API, the chances
    for various types of errors increase significantly. To prepare for this complexity,
    we’ll be wrapping the return values of our services and repositories in a `Result`
    object. This approach not only helps us deal effectively with expected errors
    but also brings a level of standardization and clarity to our error-handling strategy.
    Let’s see how this `Result` object brings elegance and robustness to the ViewModels.
  prefs: []
  type: TYPE_NORMAL
- en: Putting the Result object to work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code snippet shows how the `Result` object can gracefully handle
    both successful and unsuccessful outcomes in the `RecipeRatingsDetailViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This example underscores the elegance and robustness the `Result` object brings
    to our ViewModels. By using the `IsSuccess` property, we can immediately determine
    the success of the operation. If it’s successful, we proceed to work with the
    data we’ve received. If not, we offer the user a chance to retry or go back. Additionally,
    the `Result` object also contains valuable error information in `ErrorMessage`,
    `ErrorCode`, and `Exception`, allowing us to tailor our error-handling strategy,
    such as displaying specific error messages to the user. This approach removes
    the necessity of adding exception-handling sections across our ViewModels, leading
    to a cleaner, easier-to-read, and more maintainable code structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we would like to leverage C# **pattern matching** abilities, we could make
    the preceding code even more elegant, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By using pattern matching, we could check for the `Result` object’s `IsSuccess`
    property to be `true`, and in the same statement, assign the `Result` object’s
    `Data` property to the `ratings` variable. This allows us to access the `Data`
    property more easily through the `ratings` variable inside that `if` block. Now
    that we have a good understanding of the `Result` object, we can start adding
    repositories to our architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Adding repository interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start adding repositories, the pieces of code that will directly interact
    with our API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Recipes.Client.Core` project, add an interface called `IRecipeRepository`
    to the `Features/Recipes` folder. Here’s what this interface looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This interface defines the contract that any class needs to implement in order
    to be able to fetch recipes from a data source. There are two methods defined
    in this interface: `LoadRecipes` and `LoadRecipe`. The first method returns a
    `LoadRecipesResponse` object, which is a response containing a paged collection
    of recipes. The second method returns a `RecipeDetail` object for a recipe identified
    by its ID. The return value of both of these methods is wrapped in a `Result`
    object, allowing us to deal with the fact that the requested data (temporarily)
    couldn’t be retrieved, for example.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Head over to the `RecipeService` class and add a parameter of type `IRecipeRepository`
    to its constructor. A field is also added to keep a reference to this instance,
    as shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As there isn’t much “business logic” going on in the `RecipeService` class,
    its methods should just call the injected repository’s methods and return their
    result. Have a look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can add the same treatment to the `RatingsService` class: create a repository
    interface, add it as a dependency to the service, and call the interface’s methods
    from the `RatingsService` class’s methods. We’ll proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an `IRatingsRepository` interface for the `Features/Ratings` folder
    and add the following definitions to the newly created interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are two methods defined in this interface: `GetRatings` and `GetRatingsSummary`.
    The first method returns a collection of `Rating` objects associated with the
    specified recipe ID. The second method returns a `RatingsSummary` for a recipe
    identified by its ID. As noted earlier, the return values are wrapped in a `Result`
    object.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we add `IRatingsRepository` as a dependency of the `RatingsService` class,
    by defining it as a constructor parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, as the `RatingsService` class doesn’t contain any additional logic,
    this class will just call the repository’s methods, as you can see here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That leaves us with one service left to update: `FavoritesService`. Unlike
    the previous services that we’ve been updating, `FavoritesService` does contain
    some additional logic. But let’s first take a look at what the `IFavoritesRepository`
    interface looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface defines three methods: `LoadFavorites`, `Add`, and `Remove`.
    Since our favorites are stored on a centralized server, it’s essential to pass
    the user’s identifier (or `userId`) to the API. This ensures that favorites fetched,
    added, or removed are specific to that user. Neither the `Add` method nor the
    `Remove` method has an intrinsic return value. To be consistent with the rest
    of our APIs, we want to return a value wrapped in a `Result` object. That’s why
    a custom `Nothing` type is returned. This is just an empty struct, as you can
    see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s update the `FavoritesService` so that it leverages the `IFavoritesRepository`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and add the `IFavoritesRepository` interface to the `Features/Favorites`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update `FavoritesService` so that its constructor accepts a parameter of type
    `IFavoritesRepository`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`FavoritesService` keeps a list of the user’s favorites in memory. This in-memory
    list can easily be used in the `IsFavorite` method to rapidly check whether the
    given `recipeId` exists in the list. Here’s how we can load this list in memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `LoadList` method calls the `LoadFavorites` method on the `IFavoritesRepository`
    when the favorites list is `null`. The “dummy” `GetCurrentUserId` method provides
    a fake identifier for the given user of the app. In a real-life scenario, this
    could be retrieved from an injected service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As said before, this in-memory list facilitates the implementation of the `IsFavorite`
    method, as shown in the next code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method calls the `LoadList` method, which will retrieve the favorites from
    the API if the in-memory list is `null`. When favorites have been loaded, we can
    check whether the list contains the given ID.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In contrast to the earlier services we discussed, where each method simply
    invoked a corresponding method in the injected repository, things are slightly
    more complex here due to the presence of an in-memory list. Also, because both
    the `Add` and `Remove` methods send a `FavoriteUpdateMessage` instance, they require
    some extra logic for implementation. Here’s how it’s done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do in `FavoritesService`’s `Add` method is to call the repository’s
    `Add` method, passing in the (fake) `userId` value, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Add` method of the `IFavoritesRepository` returns a `Nothing` object wrapped
    in a `Result` object. Thanks to the `Result` object, we can check if the API call
    was successful or not. If that’s the case, we add the ID of the favorited recipe
    to the in-memory list of favorites and send the `FavoriteUpdateMessage` as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Remove` method is very similar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With all of our code in place, it’s time to add implementations for these repositories
    and make sure they get registered in the DI container.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and registering repository implementations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There’s a dedicated project in which we can place the implementations of the
    repository interfaces. As these repositories will communicate to our API, I tend
    to use `ApiGateway` as the naming. Personally, I think this name perfectly illustrates
    its functionality. In the `Recipes.Client.Repositories` project, we can add three
    classes: `FavoritesApiGateway`, `RatingsApiGateway`, and `RecipeApiGateway`. These
    classes should implement the `IFavoritesRepository`, `IRatingsRepository`, and
    `IRecipeRepository` interfaces respectively. In the next section, we will be discussing
    how to effectively activate API communication using Refit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s turn our attention to registering these repositories in the DI container.
    Instead of handling each registration in the `MauiProgram` class, we’ll delegate
    this task entirely to the code in the `Recipes.Client.Repositories` project:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `Microsoft.Extensions.DependencyInjection.Abstractions` NuGet package
    to the `Recipes.Client.Repositories` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Recipes.Client.Repositories` project, add a `ServiceCollectionExtension`
    class. Here’s what this static class looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This class contains one method: `RegisterRepositories`. This method is an extension
    method that extends the `IServiceCollection` interface. To use `IServiceCollection`,
    ensure you’ve included the `Microsoft.Extensions.DependencyInjection` namespace,
    which is part of the NuGet package we added in the first step. This method is
    all about registering the repositories. Ending the method by returning the `services`
    instance allows us to adopt a builder pattern, enabling the chaining of additional
    extension methods.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can head over to the `MauiProgram.cs` file and add the following to
    the `CreateMauiApp` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `RegisterRepositories` extension method can only be resolved when the `Recipes.Client.Repositories`
    namespace is added.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With all of this in place, the services of our app now depend on repositories
    that will eventually communicate to the app’s API. The implementation of those
    repository interfaces and their registration is done in the dedicated `Recipes.Client.Repositories`
    project. This keeps everything organized and modular and ensures a clear separation
    of concerns, making our codebase more maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Although we now have repositories that are being registered, they still lack
    communication with our API. Moreover, we registered the `RatingsApiGateway`, `RecipeApiGateway`,
    and `FavoritesApiGateway` classes, which don’t exist yet. Let’s see how we can
    add these and leverage Refit to make API requests and receive strongly typed responses,
    making it easier to handle errors and parse data.
  prefs: []
  type: TYPE_NORMAL
- en: API communication with Refit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we’ve set up a neat architecture for our repositories, but
    they’re still missing the ability to talk to our API. To add this functionality,
    we could use `HttpClient` manually to make API calls and deserialize the response.
    While that’s entirely possible, it’s also cumbersome and prone to errors, not
    to mention it takes a lot of boilerplate code to get it right.
  prefs: []
  type: TYPE_NORMAL
- en: This is where Refit comes into the picture. Refit is a powerful library that
    simplifies API calls by providing a more declarative and less error-prone approach.
    Instead of writing tedious HTTP requests and responses, you just define a C# interface
    that maps to the API’s endpoints. Refit takes care of the underlying `HttpClient`
    calls, serialization, and deserialization for you, letting you focus on what matters
    – the logic of your application.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll see how Refit can make our life easier by reducing code
    complexity and increasing readability, while still offering customization options
    for more complex scenarios. So, let’s get our repositories talking to our API
    the smart way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Refit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refit is a type-safe REST client for .NET that allows you to easily make API
    calls by defining an interface. You annotate the interface methods with HTTP attributes
    such as `[Get]`, `[Post]`, and so on, specifying the API endpoints. Refit is then
    able to generate the implementation for you, turning those interface methods into
    API calls. Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define the API endpoints we’ll be interacting with by declaring
    an interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `IRecipeApi` interface defines an API call for fetching a single recipe
    by its ID. The `Refit.Get` attribute is used to define an `HTTP GET` method for
    a specific endpoint. The `{recipeId}` portion of the endpoint specifies a path
    parameter that is used to pass the `recipeId` parameter to the method. When the
    `GetRecipe` method is called with a recipe ID, we want the Refit library to send
    an `HTTP GET` request to the specified endpoint, replacing the `{recipeId}` portion
    of the endpoint with the specified ID.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Secondly, we use `RestService.For` to generate an implementation of your interface,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This single line of code creates an object that knows how to make the API calls
    defined in `IRecipeApi`. This `RestService.For` method accepts a string parameter
    that defines the base URL of the API. Alternatively, an instance of `HttpClient`
    can be passed as a parameter, instead of the string value. Refit will use the
    given `HttpClient` to communicate with the API. Later on in the chapter, we’ll
    see why passing in an `HttpClient` can be useful.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we can use the generated object to make API calls and handle the responses,
    as the following code snippet demonstrates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This would just return the deserialized object. I prefer the approach that returns
    `ApiResponse<T>` because it provides a fuller picture of what’s happening during
    the API interaction, which is crucial for robust error handling and insightful
    logging.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And there you have it: three simple steps to replace what would have otherwise
    been much more boilerplate code. Now, let’s get back to our *Recipes!* app and
    put this into practice.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating API interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s add API interfaces to the `Recipes.Client.Repositories` project. Later
    on, we will be using them together with Refit to generate the required code to
    effectively communicate to the API:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Recipes.Client.Repositories` project and select `Api`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an interface called `IFavoritesApi` to the newly created folder. The following
    code snippet shows what this interface looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This interface maps directly to the API endpoints responsible for managing
    user favorites. The `Get`, `Post` and `Delete` attributes specify the HTTP methods
    that should be used for each API call. Parameters such as `userId` that appear
    in the URL are automatically populated from the method arguments. Notice the `favorite`
    parameter in the `AddFavorite` method. This parameter is not part of the defined
    endpoint URL; instead, it gets serialized and sent as the request body. Alternatively,
    it’s also possible to explicitly indicate that the favorite parameter needs to
    be sent in the message’s body by using the `Body` attribute. This is what that
    looks like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public interface IRatingsApi
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Get("/recipe/{recipeId}/ratings")]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Task<ApiResponse<RatingDto[]>> GetRatings(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: string recipeId);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Get("/recipe/{recipeId}/ratingssummary")]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Task<ApiResponse<RatingsSummaryDto>>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: GetRatingsSummary(string recipeId);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s define the `IRecipeApi` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you probably know by now, as with the previous ones, this interface also
    maps to certain API endpoints. The `pageSize` and `pageIndex` parameters of the
    `GetRecipes` method don’t appear in the endpoint of the `Get` attribute. As a
    result, they will be added as query string parameters when doing the request.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With our API interfaces defined, it’s finally time to bridge the gap between
    our repositories and the actual API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Refit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s integrate Refit into our repositories to make the API calls a breeze.
    It all starts with adding the Refit NuGet package to the `Recipes.Client.Repositories`
    project. To make integrating Refit even easier and avoid duplicate code later
    on, let’s first add a new `ApiGateway` abstract class to the `Recipes.Client.Repositories`
    project. The purpose of this class is to help us in executing a call and mapping
    the `ApiResponse` result to another type. This is what the `InvokeAndMap` method’s
    signature looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This method returns a `Task<TResult>` object and takes in two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The `call` parameter is the API call to make, which returns an `ApiResponse<TDtoResult>`
    object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `mapper` parameter is a method that takes in the `TDtoResult` object from
    the response and maps it to the `TResult` object that the `InvokeAndMap` method
    returns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation is fairly straightforward: the method must execute the provided
    `call` parameter. If the resulting `ApiResponse` instance indicates success, the
    passed-in `mapper` parameter will be used to map the result from `TDtoResult`
    to `TResult`, which is wrapped in a `Result` object that indicates success. If
    the response doesn’t indicate success, a failed result is returned, containing
    the response’s status code. The following code block shows how it’s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'On top of that, we also need to be wary of potential exceptions being thrown,
    which we can handle as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When an exception occurs, we should return a `Result` object that indicates
    failure, containing relevant data about the exception.
  prefs: []
  type: TYPE_NORMAL
- en: A note on robustness
  prefs: []
  type: TYPE_NORMAL
- en: 'When developing mobile applications, it’s important to remember that network
    conditions can be unpredictable. Mobile devices might move between different network
    zones, causing unstable connections. As a best practice, always consider implementing
    resilience patterns such as `ApiGateway` class is the perfect spot to add this
    kind of retry logic instead of directly returning a `Fail` result. Find out more
    about Polly here: [https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In situations where the data type returned by the API interface is identical
    to the type we wish to encapsulate in a `Result` object, we can provide an overloaded
    `InvokeAndMap` method that eliminates the need for a type mapper. This is particularly
    useful when dealing with primitive types. The following snippet shows this overload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This base class will drastically simplify the mapping of a DTO returned by
    the API to a domain entity that gets encapsulated in a `Result` object. Now, let’s
    have a look at how we can utilize this `InvokeAndMap` method in our repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make sure that all of our repositories (`FavoritesApiGateway`, `RatingsApiGateway`,
    and `RecipeApiGateway`) inherit this abstract `ApiGateway` class by adding the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, each of these repositories should get its corresponding API interface
    injected through its constructor. Let’s see what this looks like for `RatingsApiGateway`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The injected `IRatingsApi` interface can now be used to do the network calls
    and retrieve the requested data from the API. The following code block shows the
    implemented `GetRatings` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `GetRatings` method calls the `InvokeAndMap` method of the base class.
    The `GetRatings` API call is passed in as a parameter, as well as the `MapRatings`
    method, which maps the `RatingDto` array returned by the API to an `IReadOnlyCollection`
    of `Rating` objects. The `MapRatings` method is a static method on the static
    `RatingsMapper` class. We can directly access `RatingsMapper`’s static mapping
    methods inside this class without explicitly needing to prepend its name because
    the following `using` statement is added to the class:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now do the exact same thing for the `GetRatingsSummary` method on this
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Analogous to the previous examples, the implementation of the `FavoritesApiGateway`
    class can be done following the same pattern: inject the `IFavoritesApi` interface
    and use its methods to retrieve data from the API, leveraging the `InvokeAndMap`
    method of the `ApiGateway` base class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All of these methods in the `FavoritesApiGateway` use the overloaded `InvokeAndMap`
    method, which doesn’t do additional mapping: the data type returned by the API
    interface is the same as the one the repository returns, but it’s encapsulated
    in a `Result` object.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The implementation of the `RecipeApiGateway` class shouldn’t contain any surprises;
    it only contains more mapping. But at its core, it follows the exact same pattern
    as the previous two classes. First, a field of type `IRecipeApi` needs to be added
    as a member and constructor parameter, as the following snippet shows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `LoadRecipes` method and the mappings it uses look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`LoadRecipes` calls the `InvokeAndMap` method, passing in the `GetRecipes`
    method of the API interface. The `MapRecipesOverview` method is used to map the
    resulting object of type `RecipesOverviewItemsDto` to a `LoadRecipesResponse`
    object.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And finally, we can implement the `LoadRecipe` method. It can use the `GetRecipe`
    method of the `IRecipeApi` to get the data. The result will be mapped using the
    static `MapRecipe` method of the static `RecipeMapper` class. Take a look:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to update our `ServiceCollectionExtension` class. Because every
    repository now has a dependency on a particular API interface, we need to make
    sure these dependencies get registered as well. But first, we might want to add
    a new `RepositorySettings` class to the `Recipes.Client.Repositories` project.
    This class should be a way to pass settings from the app to the repositories,
    such as a specific `HttpClient` instance that needs to be used, for example. As
    the following code block shows, there’s not much to this class for this particular
    demo project. But in more complex applications, things such as particular serialization
    or authentication settings can be added here as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s fit the final pieces of the puzzle together, update the `ServiceCollectionExtension`,
    and call it from our app. Here’s what we need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `RepositorySettings` class, as shown earlier, to the `Recipes.Client.Repositories`
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a parameter of type `RepositorySettings` to the `RegisterRepositories`
    extension method of the `ServiceCollectionExtension` class, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we saw earlier, Refit’s `RestService.For` method can be used to generate
    implementations of the API interfaces. The following snippet shows how we can
    register the generated implementations in the DI container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `RestService.For` method accepts an instance of `HttpClient` that will be
    used by Refit to do the API communication. An `HttpClient`, should be configured
    in the app and passed-in via the `RepositorySettings`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, in the `MauiProgram` class, we can call the updated `RegisterRepositories`
    and pass-in a configured `HttpClient` as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As the Android emulator runs in an isolated network environment behind a virtual
    router, it cannot directly access the development machine using `localhost`. Instead,
    the emulator provides a special `10.0.2.2` alias that routes to the development
    machine’s loopback interface, enabling you to access local web services.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `Recipes.Mobile` project contains an `HttpClientHelper` class that configures
    an `HttpClient` instance to be used for connecting to local web services. This
    is needed as some additional configuration specific to each platform needs to
    be done in order to effectively communicate to web services hosted locally.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Connecting to local web services
  prefs: []
  type: TYPE_NORMAL
- en: 'While developing software, it’s typical to run a local web service and access
    it using an app in either an Android emulator or an iOS simulator. Some additional
    configuration is needed in order for the app to communicate with your local web
    service. More information about connecting to a local web service and how to configure
    each platform can be found here: [https://learn.microsoft.com/dotnet/maui/data-cloud/local-web-services](https://learn.microsoft.com/dotnet/maui/data-cloud/local-web-services).'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to debug the *Recipes!* app, we need to tell Visual Studio to run
    both the mobile app and the API. To do this, right-click **Solution ‘Recipes App’**
    in the **Solution Explorer** and select **Properties**. In the pop-up, select
    **Multiple startup projects** and set the **Action** of both the **Recipes.Mobile**
    and **Recipes.Web.Api** projects to **Start**.
  prefs: []
  type: TYPE_NORMAL
- en: As we wrap up this chapter, let’s briefly turn our attention to how we can call
    APIs from ViewModels, deal with loading indicators, and handle potential errors,
    all while providing a seamless user experience.
  prefs: []
  type: TYPE_NORMAL
- en: API communication from ViewModels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When navigating to the `RecipeDetailPage`, you’ll see some data on the screen
    while the recipe is being loaded. The data being shown is the values defined as
    `FallbackValue` or `TargetNullValue` in the binding statements as a result of
    the data in `RecipeDetailViewModel` not being loaded yet. Although effective,
    I don’t think it looks pretty. Let’s see how we can improve this by showing a
    loading indicator while the data is being loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Showing a loading indicator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the simplest yet effective ways to improve user experience is to provide
    visual feedback during API calls. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set the `IsLoading` property of the `RecipeDetailViewModel` to `true`
    before we start loading the data and it is reverted back to `false` afterward.
    Thanks to the use of `async`/`await`, the UI thread is not blocked during this
    operation, allowing UI elements such as loading indicators to be updated and rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can bind this property to a loading spinner in your XAML like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As a result of this setup, whenever the API call – or any long-running process,
    for that matter – is in progress, the user receives a visual cue, indicating that
    the app is currently busy. In the preceding example, we’ve used a `Grid` property
    that overlays the entire page and contains an `ActivityIndicator`. However, you’re
    not limited to this approach; you could also use a message, an animation, or any
    other UI element that best suits your app’s design and user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Using a property to indicate that a task is in progress, and binding this property
    to the UI, is a common MVVM pattern for managing longer-running operations. The
    responsiveness is made possible by the `async`/`await` construct, which keeps
    the UI thread unblocked, allowing for a smoother user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this chapter, we already saw how the `Result` object can help us
    elegantly handle successful and unsuccessful results. Now, let’s take it a step
    further by enhancing the user experience by handling a `Result` object that indicates
    failure.
  prefs: []
  type: TYPE_NORMAL
- en: Handling failures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we introduced the `Result` object as a way to elegantly
    handle failures. The object’s `IsSuccess` property indicates whether an operation
    is completed successfully or not. We’ve already seen that in successful cases,
    the `Data` property gives us access to the result. However, when `IsSuccess` is
    `false`, it’s crucial not to leave the user guessing. Instead, we should provide
    clear feedback and offer a way to resolve the issue. Let’s see how this is tackled
    in the `LoadRecipes` method of `RecipesOverviewViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, when the task isn’t successful, the `LoadFailed` property is
    set to `true`. Also, the `ReloadCommand` property gets initialized. The following
    code block shows how both properties are data-bound to the UI and will provide
    the user with some information and the ability to retry loading the list of recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, we could show a custom error message to the user when a specific
    failure occurs. The `ErrorMessage`, `ErrorCode`, and `Exception` properties of
    the `Result` object could be used for that. This approach eliminates the need
    for scattering various exception-handling blocks throughout our ViewModels, thereby
    creating a more streamlined, readable, and maintainable code base.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We kicked off this chapter by revisiting the architecture of our *Recipes!*
    app to include repositories. This addition was aimed at adhering to the principle
    of SoC and minimizing our app’s dependency on the API itself. We also introduced
    the `Result` object, a transformative component in our error-handling strategy.
    This single object encapsulates both success and failure states, making our ViewModels
    more robust and intelligible. By using the `Result` object, we’ve made it easier
    to handle anticipated errors in a graceful manner, while still keeping exceptions
    reserved for critical failures.
  prefs: []
  type: TYPE_NORMAL
- en: After setting this architectural foundation, we moved on to explore the power
    and simplicity of Refit, a type-safe REST client. Refit has substantially streamlined
    the way we interact with APIs, making the code more readable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at how the `Result` object elegantly fits into our ViewModels,
    making it far easier to handle expected errors and providing a uniform approach
    to error management. Alongside this, we discussed practical UI considerations,
    including loading indicators and error overlays, to offer the user an engaging
    and informative experience.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a solid understanding of how to make API calls, manage responses,
    and provide real-time user feedback, all in a resilient and easily maintainable
    way.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at how to create MVVM-friendly controls.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Refit documentation: [https://reactiveui.github.io/refit/](https://reactiveui.github.io/refit/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consuming a REST-based web service with `HttpClient`: [https://learn.microsoft.com/dotnet/maui/data-cloud/rest](https://learn.microsoft.com/dotnet/maui/data-cloud/rest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: Mastering MVVM Development'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This final part is all about refining and hardening your .NET MAUI app. We will
    delve deep into crafting controls that seamlessly integrate with MVVM. You will
    learn how to expand your app's reach with techniques for localization and fortify
    your code base with robust unit testing, ensuring stability and reliability. And
    when things don't go as planned, you will be able to rely on valuable troubleshooting
    and debugging tips to steer back on course.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B20941_11.xhtml#_idTextAnchor182), *Creating MVVM-Friendly Controls*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B20941_12.xhtml#_idTextAnchor196), *Localization with MVVM*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B20941_13.xhtml#_idTextAnchor223), *Unit Testing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B20941_14.xhtml#_idTextAnchor238), *Troubleshooting and Debugging
    Tips*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
