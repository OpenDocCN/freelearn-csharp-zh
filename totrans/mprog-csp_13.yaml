- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Applying Cross-Cutting Concerns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用跨领域关注点
- en: As software projects evolve, they gain a certain structure, and if the team
    is disciplined, it will be somewhat consistent. When you get more team members,
    you might even document the structure. In addition to structure, you might also
    have ways of doing things and clear recipes of what needs to be done when creating
    different types of functionalities for the different parts of the stack. For global
    ownership, you might have these written down as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件项目的演变，它们会获得一定的结构，如果团队有纪律，那么这种结构将保持一定的一致性。当团队人数增加时，您甚至可能会记录下这种结构。除了结构之外，您还可能有执行某些任务的方法，以及创建不同类型功能时需要执行的具体操作指南。为了全局所有权，您也可能将这些内容记录下来。
- en: This is where cross-cutting concerns can come to the rescue. In this chapter,
    we will look at how to increase productivity for you as a developer by removing
    mundane tasks and improving consistency, and reducing risks. We will also look
    at how cross-cutting concerns can improve the maintainability of your software.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是跨领域关注点可以提供帮助的地方。在本章中，我们将探讨如何通过移除日常任务、提高一致性和降低风险来提高您作为开发者的生产力。我们还将探讨跨领域关注点如何提高您软件的可维护性。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: What are cross-cutting concerns?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨领域关注点是什么？
- en: Leveraging the ASP.NET pipeline
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用ASP.NET管道
- en: Authorization based on metadata or structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于元数据或结构的授权
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter13](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter13)),
    and it builds on top of the **Fundamentals** code that is found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的特定源代码可以在GitHub上找到 ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter13](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter13))，并且它建立在GitHub上可找到的**基础**代码之上
    ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals))。
- en: You will need Postman ([https://www.postman.com](https://www.postman.com)) for
    testing the APIs created in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用Postman ([https://www.postman.com](https://www.postman.com)) 来测试本章中创建的API。
- en: What are cross-cutting concerns?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨领域关注点是什么？
- en: 'As the lead-in to the chapter suggests, you might find yourself in your project
    with guidelines, formalized or not, that give you recipes for how to do things.
    For instance, to write a **representational state transfer** (**REST**) API that
    performs actions in your application, you might have a list of things defined
    that is there to help you remember what to do:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如章节引言所暗示的，您可能会发现自己处于一个项目中，其中有一些指南，无论是有形的还是无形的，都提供了如何做事的食谱。例如，为了编写执行应用程序中操作的**表示状态转移**（**REST**）API，您可能有一个定义好的清单，旨在帮助您记住要做什么：
- en: Check authorization
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查授权
- en: Check whether the input is valid
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查输入是否有效
- en: Check whether the action is allowed as per business rules
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查操作是否符合业务规则
- en: Add logging for the action
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为操作添加日志
- en: Perform the action by calling the domain logic
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用领域逻辑来执行操作
- en: Translate the result from the domain to something digestible for REST consumption
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果从领域转换为REST消费可接受的格式
- en: Remember to wrap the call to the domain in **try {} catch {}** and return the
    correct error
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记得将调用领域的代码包裹在**try {} catch {}**中，并返回正确的错误信息
- en: For each of these steps, there is always the risk that the developer will forget.
    This can pose a risk, cause security issues, data consistency, or other problems.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些步骤中的每一个，都存在开发者可能会忘记的风险。这可能会带来风险，导致安全问题、数据一致性或其他问题。
- en: Personally, I’m a huge fan of automating anything that is repetitive. Computers
    are really good at doing repetitive tasks, so why not let the human in front focus
    on delivering the business value?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我非常热衷于自动化任何重复性工作。计算机在执行重复性任务方面非常出色，那么为什么不让人类专注于创造业务价值呢？
- en: Cross-cutting concerns are basically those things that are applied once and
    henceforth continue to be there. Some cross-cutting concerns can be entirely automatic
    and need no extra intervention from the developer once applied, while others tend
    to be more configurable and context-based.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 横切关注点基本上是那些一旦应用就持续存在的事情。一些横切关注点可以完全自动，一旦应用就不需要开发者进行额外干预，而其他则更具有可配置性和基于上下文。
- en: Logging is probably the most canonical example of a cross-cutting concern. If
    you, for instance, know what to add in a log statement for every call to a Web
    API controller in your ASP.NET application, you can quite easily do so by adding
    an action filter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 记录可能是最典型的横切关注点的例子。例如，如果你知道在你的 ASP.NET 应用程序中，每次调用 Web API 控制器时应该添加什么到日志语句中，你可以通过添加一个操作过滤器非常容易地做到这一点。
- en: I tend to focus a lot on how we can boost the productivity of a team. With that
    in mind, you can do quite a bit of automation. To understand this better, we can
    use an example from ASP.NET Web APIs. Let’s say you’re building an application
    that has a frontend, and you need to provide an API for the frontend. Typically,
    your domain logic shouldn’t be in the API layer, as that is just a transport mechanism.
    An opportunity here is to automatically generate the API layer from the domain
    layer based on a convention. The convention could be derived from the namespace
    that could then automatically create the correct route. This would then remove
    an entire layer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我倾向于关注如何提高团队的生产力。考虑到这一点，你可以进行相当多的自动化操作。为了更好地理解这一点，我们可以用一个来自 ASP.NET Web APIs
    的例子来说明。假设你正在构建一个包含前端的应用程序，并且需要为前端提供一个 API。通常情况下，你的领域逻辑不应该在 API 层，因为那只是一个传输机制。这里的一个机会是自动从领域层根据约定生成
    API 层。这个约定可以从命名空间中推导出来，然后自动创建正确的路由。这将消除一个完整的层。
- en: One of the possible benefits of applying cross-cutting concerns is that you
    end up writing less code in the implementations where you’d normally add the things
    it automates. This is also a good thing from a maintenance perspective. It makes
    it easier to maintain. For instance, if you want to change the behavior of your
    system rather than having to change it in multiple places, you’d have a single
    place to change it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 应用横切关注点的一个可能的优点是，你最终在实现中写的代码更少，在通常添加自动化的地方。从维护的角度来看，这也是一件好事。它使得维护变得更加容易。例如，如果你想改变系统的行为，而不是在多个地方进行更改，你只需在一个地方进行更改。
- en: One of my favorite cross-cutting concerns is for Web APIs to have a consistent
    result and also not just rely on the HTTP status codes but rather consistently
    include all needed information to the consumer about the call.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的横切关注点之一是确保 Web API 有一个一致的结果，并且不仅仅依赖于 HTTP 状态码，而是始终一致地向消费者提供有关调用的所有必要信息。
- en: Leveraging the ASP.NET pipeline
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用 ASP.NET 管道
- en: REST APIs are based on the HTTP standard. The standard is a protocol standard
    and will not necessarily reflect in a good way what really happened when you performed
    an operation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 基于HTTP标准。这个标准是一个协议标准，并不一定能够很好地反映当你执行操作时实际发生的情况。
- en: One way to do this would be to create a common result object that all Web API
    controller actions need to return. But that would then become one of these recipes
    that could be forgotten and leave the solution in an inconsistent state.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的其中一种方法是为所有 Web API 控制器操作创建一个通用的结果对象。但这样就会成为那些可能会被遗忘的食谱之一，并使解决方案处于不一致的状态。
- en: The idea of having a common result object is undoubtedly desirable, but we should
    work towards returning it automatically for all Web API calls. However, there
    is a difference between performing an operation and getting data. Basically, in
    HTTP, that is what the different verbs are for, HTTP GET represents getting data,
    while verbs such as POST, PUT, or DELETE represent the operations you want to
    perform.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个通用结果对象的想法无疑是可取的，但我们应该努力实现所有 Web API 调用自动返回它。然而，执行操作和获取数据之间有一个区别。基本上，在 HTTP
    中，这就是不同动词的作用，HTTP GET 代表获取数据，而诸如 POST、PUT 或 DELETE 这样的动词代表你想要执行的操作。
- en: These types of operations are typically what you tend to perform as operations
    on a database in a data-driven application. You’ll often use the same model for
    all the operations, and you’re basically just modifying data.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的操作通常是你作为一个数据驱动应用程序中的数据库操作所执行的操作。你通常会使用相同的模型进行所有操作，你基本上只是在修改数据。
- en: I’m an advocate for the **Command Query Responsibility Segregation** (**CQRS**)
    principle, coined by Greg Young ([https://www.martinfowler.com/bliki/CQRS.html](https://www.martinfowler.com/bliki/CQRS.html)),
    which is a further formalization of Bertrand Meyers’ **Command Query Separation**
    (**CQS**) principle ([https://www.martinfowler.com/bliki/CommandQuerySeparation.html](https://www.martinfowler.com/bliki/CommandQuerySeparation.html)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我支持由Greg Young提出的**命令查询责任分离**（**CQRS**）原则，该原则是Bertrand Meyers的**命令查询分离**（**CQS**）原则的进一步形式化（[https://www.martinfowler.com/bliki/CQRS.html](https://www.martinfowler.com/bliki/CQRS.html)），[https://www.martinfowler.com/bliki/CommandQuerySeparation.html](https://www.martinfowler.com/bliki/CommandQuerySeparation.html)）。
- en: The CQRS principle challenges the common approach of treating everything as
    data in a **Create, Read, Update, and Delete** (**CRUD**) manner. It focuses on
    explicitly modeling the state change in a system and represents the intention
    of changing with a **command**, while retrieving data is represented as **queries**.
    Since CQRS is an evolution of CQS, it also implies that commands represent a changing
    state and do not return a value, while queries return a value but do not change
    any state.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS原则挑战了将所有事物都视为**创建、读取、更新和删除**（**CRUD**）数据的一般方法。它侧重于显式地建模系统中的状态变化，并用**命令**表示改变意图，而检索数据则表示为**查询**。由于CQRS是CQS的演变，它还意味着命令代表状态的变化，不返回值，而查询返回值但不改变任何状态。
- en: We’re not going to dive any deeper into CQRS or CQS, but we want to utilize
    the concept of command and, with that, limit the surface area for what we want
    to support in the sample in this chapter. The sample here has nothing to do with
    CQRS, but being an advocate for it, I figured I’d slip it into the conversation,
    hoping it triggers some curiosity…haha.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨CQRS或CQS，但我们想利用命令的概念，并以此限制本章示例中我们想要支持的范围。这里的示例与CQRS无关，但作为它的支持者，我认为我会把它融入到对话中，希望它能激发一些好奇心……哈哈。
- en: Building consistent result objects
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一致的返回对象
- en: Let’s build a simple system that registers employees exposed as a REST API.
    The goal is to provide a consistent result object for all commands being performed.
    We define a command in this context to be an HTTP POST call to any Web API controller.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个简单的系统，该系统将员工注册作为一个REST API。目标是提供所有执行命令的一致返回对象。在这个上下文中，我们将命令定义为对任何Web
    API控制器的HTTP POST调用。
- en: 'Start by creating a folder called **Chapter13**. Change into this folder in
    your command line and create a new web-based project:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个名为**Chapter13**的文件夹。在命令行中切换到这个文件夹，并创建一个新的基于Web的项目：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s take advantage of the **Fundamentals** project in the GitHub repository
    mentioned in the *Technical requirements* section. You should add a project reference
    to it for this chapter by doing the following in your terminal:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用在*技术要求*部分提到的GitHub仓库中的**基础知识**项目。你应该通过在终端执行以下操作为这一章添加对该项目的引用：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will leverage the concept of an **action filter**, a building block provided
    by ASP.NET Core. In [*Chapter 3*](B19418_03.xhtml#_idTextAnchor041), *Demystifying
    through Existing Real-World Examples*, we touched on this building block for changing
    the default behavior related to validation—a good example of a cross-cutting concern.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用ASP.NET Core提供的**操作过滤器**这一构建块。在[*第3章*](B19418_03.xhtml#_idTextAnchor041)，*通过现有现实世界示例去神秘化*中，我们提到了这个构建块，用于改变与验证相关的默认行为——这是一个跨切面关注点的良好示例。
- en: In ASP.NET Core, you, as a developer, have 100% flexibility on the behavior
    of your Web API controllers. That means that you decide what to return to the
    client, and you also decide whether or not you really care about the validation
    result. As we did in [*Chapter 3*](B19418_03.xhtml#_idTextAnchor041), *Demystifying
    through Existing Real-World Examples*, we will be a bit more opinionated and not
    let the controller’s actions decide whether or not something is valid, but handle
    this in a cross-cutting manner. In addition to this, we want to wrap this up in
    a nice way for the consumer to get the result consistently.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core中，作为开发者的你，对Web API控制器的行为有100%的灵活性。这意味着你决定向客户端返回什么，你也决定你是否真的关心验证结果。正如我们在[*第3章*](B19418_03.xhtml#_idTextAnchor041)，*通过现有现实世界示例去神秘化*中所做的那样，我们将更加有见地，不让控制器的行为决定是否有效，而是以跨切面的方式处理这个问题。此外，我们还想以一种优雅的方式将其封装起来，以便消费者能够一致地获取结果。
- en: Create a subfolder in **Chapter13** called **Commands**. This is where you’ll
    create the necessary infrastructure.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Chapter13** 中创建一个名为 **Commands** 的子文件夹。这是你创建必要基础设施的地方。
- en: Let’s start by adding a consistent representation of a validation result. ASP.NET
    Core has the concept of **ModelError**; you could use this directly if you’d like.
    But **ModelError** represents both **Exception** and a validation error. Those
    are different concerns that I personally would like to separate and make clearer.
    Being in an invalid state is different from having an exceptional non-recoverable
    state.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加一个一致的验证结果表示开始。ASP.NET Core 有 **ModelError** 的概念；如果你愿意，可以直接使用它。但 **ModelError**
    既可以表示 **Exception** 也可以表示验证错误。这些是不同的关注点，我个人希望将它们分开并使其更清晰。处于无效状态与处于异常的非恢复状态是不同的。
- en: 'Add a file in the **Commands** folder called **ValidationResult.cs**. You can
    make it look like the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Commands** 文件夹中添加一个名为 **ValidationResult.cs** 的文件。你可以使其看起来如下：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code introduces a type called **ValidationResult**, which holds an error
    and the member the error is for. With the member clearly in the result, the consumer
    can map the error back to the object it sent. As a user interface, this is very
    useful as you can then easily show the error directly for the user input field
    that is invalid.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 代码引入了一个名为 **ValidationResult** 的类型，该类型包含错误和错误对应的成员。由于成员在结果中明确，消费者可以将错误映射回它发送的对象。作为一个用户界面，这非常有用，因为你可以轻松地为无效的用户输入字段显示错误。
- en: 'Since ASP.NET Core has its **ModelError** and you’ve now introduced a type
    representing just the validation result, you would want something that converts
    to your type. Add a file called **ModelErrorExtensions.cs** to the **Commands**
    folder and make it look like the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ASP.NET Core 有其 **ModelError**，而你现在引入了一个仅表示验证结果的类型，你可能需要一个可以转换为你类型的工具。在 **Commands**
    文件夹中添加一个名为 **ModelErrorExtensions.cs** 的文件，并使其看起来如下：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code introduces an extension method for the **ModelError** type and takes
    a specific member as a string to associate the error. By default, all JSON serialization
    in ASP.NET Core will be camel cased; the code, therefore, converts the member
    to camel case. It even supports deeply nested members by its navigational path
    represented with a dot for each level in the nested hierarchy. The **ToCamelCase()**
    method call comes from **StringExtensions** found in the **Fundamentals** project
    referenced previously.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 代码引入了一个针对 **ModelError** 类型的扩展方法，它接受一个特定的成员作为字符串以关联错误。默认情况下，ASP.NET Core 中的所有
    JSON 序列化都将采用驼峰命名法；因此，代码将成员转换为驼峰命名法。它甚至支持通过点表示的导航路径来支持深层嵌套的成员，该路径在每个嵌套层级中用点表示。**ToCamelCase()**
    方法调用来自之前引用的 **Fundamentals** 项目中的 **StringExtensions**。
- en: CommandResult
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CommandResult
- en: 'With a representation of validation, you can now create the common result type
    for all operations or commands. We call this **CommandResult**. It will encapsulate
    all the different aspects of an API call in a structured manner. To do this, add
    a file called **CommandResult.cs** to the **Commands** folder and make it look
    like the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了验证表示之后，你现在可以创建所有操作或命令的通用结果类型。我们称之为 **CommandResult**。它将以结构化的方式封装 API 调用的所有不同方面。为此，在
    **Commands** 文件夹中添加一个名为 **CommandResult.cs** 的文件，并使其看起来如下：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code introduces a **CommandResult** type that holds the concrete information
    related to validation results and whether there was an exception that might have
    occurred. In addition, it contains properties that allow you to easily conclude
    whether or not the result represents success. If the result is not a success,
    you can dive into whether or not it is related to authorization, validity, or
    an exception. It also introduces the **CorrelationId** property, which identifies
    the call that was performed and could be used for tracing back in logs or tracing
    systems to understand whether an exception occurred and why it happened.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中引入了一个名为 **CommandResult** 的类型，该类型包含与验证结果相关的具体信息以及是否发生了可能出现的异常。此外，它还包含一些属性，允许你轻松地判断结果是否代表成功。如果结果不是成功，你可以深入了解它是否与授权、有效性或异常有关。它还引入了
    **CorrelationId** 属性，该属性用于标识已执行的调用，并可用于在日志或跟踪系统中回溯，以了解是否发生了异常以及原因。
- en: With the formalized **CommandResult** in place, you’ll need something that will
    produce this. This is where the ASP.NET Core action filter mechanism comes in
    handy.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在正式的 **CommandResult** 就位后，你需要一些可以生成这种结果的东西。这正是 ASP.NET Core 动作过滤器机制发挥作用的地方。
- en: 'Add a file called **CommandActionFilter.cs** to the **Commands** folder and
    make it look like the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将名为**CommandActionFilter.cs**的文件添加到**Commands**文件夹中，并使其看起来如下：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code gives you a bare-bones action filter by implementing the **IAsyncActionFilter**
    interface. The action filter is only interested in HTTP POST methods, as discussed
    earlier, and the rest of the implementation will take place within that clause.
    If it is not an HTTP POST method, it just forwards the request to the next middleware
    using the **next()** method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过实现**IAsyncActionFilter**接口提供了一个裸骨动作过滤器。动作过滤器只对HTTP POST方法感兴趣，如前所述，其余实现将在该子句中完成。如果不是HTTP
    POST方法，它将使用**next()**方法将请求转发到下一个中间件。
- en: 'Let’s start filling in the blanks. Inside the scope of the HTTP POST method
    clause, add the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始填补空白。在HTTP POST方法子句的作用域内，添加以下代码：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The code handles whether **ModelState** is valid, meaning that all validators
    have run successfully and thus didn’t report anything invalid. This can mean one
    of two things:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 代码处理**ModelState**是否有效，这意味着所有验证器都已成功运行，因此没有报告任何无效内容。这可能意味着以下两种情况之一：
- en: There is an exception
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有异常
- en: It’s all OK, and the action was performed
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一切正常，操作已执行
- en: Within the **IsValid** clause, the code calls **next()**, which invokes the
    rest of the ASP.NET Core pipeline, ultimately calling the Web API controller action.
    The **result** object is of the **ActionExecutedContext** type, which holds information
    about the call to the action. On it, you’ll find **Exception** and **Result**.
    If there is an exception, the code unwinds all the messages recursively through
    **InnerException** of each exception and then resets the **Exception** property
    on the **result** object to **null** to avoid the default output of exceptions
    of ASP.NET Core from kicking in. If there are no exceptions, the code looks to
    capture the actual result if it is **ObjectResult** from the action.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在**IsValid**子句中，代码调用**next()**，这会调用ASP.NET Core管道的其余部分，最终调用Web API控制器操作。**result**对象是**ActionExecutedContext**类型，它包含有关对操作调用的信息。在其上，你可以找到**Exception**和**Result**。如果有异常，代码会递归地通过每个异常的**InnerException**来展开所有消息，然后重置**result**对象上的**Exception**属性为**null**，以避免ASP.NET
    Core默认输出异常。如果没有异常，代码会尝试捕获操作的实际结果，如果它是来自操作的**ObjectResult**。
- en: Important note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Even though we said commands should only perform a state change and not return
    a result, there are cases where you need to return something to the client. This
    could be important information, such as the key of an object created, which could
    then be leveraged directly by the consumer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们说命令应该只执行状态更改而不返回结果，但有时你需要向客户端返回某些内容。这可能很重要，例如创建的对象的键，然后可以直接由消费者利用。
- en: 'The next thing you will need is to create an instance of **CommandResult**
    and populate validation results and exceptions. Add the following code after the
    previous code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来你需要做的是创建一个**CommandResult**实例并填充验证结果和异常。在之前的代码之后添加以下代码：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code creates an instance of the **CommandResult** type and sets the properties
    on it. **CorrelationId** is generated as a new **Guid**, **ValidationResults**
    is derived from **ModelState** using the extension method you put in earlier for
    converting, and **ExceptionMessages** comes from the code you put in for unwinding
    the exceptions. Then it puts in **ExceptionStackTrace** if there is any or just
    **string.Empty** if not. Finally, it forwards the response from the controller
    action directly, if any.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个**CommandResult**类型的实例，并设置了其上的属性。**CorrelationId**生成一个新的**Guid**，**ValidationResults**使用你之前放入的扩展方法从**ModelState**派生，**ExceptionMessages**来自你放入的展开异常的代码。然后，如果有任何或如果没有，它将**ExceptionStackTrace**放入其中，或者只是**string.Empty**。最后，如果有的话，它将控制器操作的响应直接转发。
- en: 'Even though you’ve now encapsulated the result in something that is more readable
    and consistent for the consumer, it is still good practice to set the correct
    HTTP status code. Add the following code after the instantiation of **CommandResult**:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你现在已经将结果封装在更易于阅读和一致的消费者中，但设置正确的HTTP状态码仍然是良好的实践。在**CommandResult**实例化之后添加以下代码：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code says that when we’re not authorized, it is an HTTP **401** status code,
    while if not valid, it is a **409** status code, and if there is an exception,
    it is **500**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代码表示，当我们未授权时，是HTTP **401**状态码，如果无效，则是**409**状态码，如果有异常，则是**500**。
- en: 'For **CommandResult** to be the actual result you get as output, you’ll need
    to explicitly set the **Result** property on **ActionExecutedContext** if we were
    validly authorized, or directly on **ActionExecutingContext**, which is passed
    as the first parameter of the method of the action filter. Add the following code
    right after the previous block:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 **CommandResult** 成为实际输出的结果，如果你被有效授权，你需要在 **ActionExecutedContext** 上显式设置
    **Result** 属性，或者直接在 **ActionExecutingContext** 上设置，这是作为动作过滤器方法第一个参数传递的。在之前的代码块之后添加以下代码：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code creates a new **ObjectResult** with **CommandResult** as content and
    sets it on either the **ActionExecutedContext** object or **ActionExecutingContext**.
    This will guarantee that you consistently get the same structure whether you’ve
    called the controller action or not.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个新的 **ObjectResult**，内容为 **CommandResult**，并将其设置在 **ActionExecutedContext**
    对象或 **ActionExecutingContext** 上。这将保证无论你是否调用了控制器动作，你都能得到相同结构的结果。
- en: 'Let’s create a concrete sample that will make use of this new and improved
    pipeline. Add a file called **Employee.cs** in the root of the **Chapter13** project
    and make it look like the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个具体的示例，将使用这个新改进的管道。在 **Chapter13** 项目的根目录下添加一个名为 **Employee.cs** 的文件，并使其看起来如下：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The code introduces a **record** type that represents an employee with only
    two properties: **FirstName** and **LastName**. It instructs that these properties
    are both required by leveraging the **[****Required]** attribute.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 代码引入了一个表示员工的 **record** 类型，它只有两个属性：**FirstName** 和 **LastName**。它指示这些属性都是必需的，通过利用
    **[Required]** 属性来实现。
- en: 'For the API to work you’ll need a controller. Add a file called **EmployeesController**
    in the root of the **Chapter13** project and make it look like the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 API 工作，你需要一个控制器。在 **Chapter13** 项目的根目录下添加一个名为 **EmployeesController** 的文件，并使其看起来如下：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code introduces a controller with an action for registering an employee.
    The **[FromBody]** attribute in front of the **employee** argument says that the
    content of **employee** is found in the HTTP request body. The action returns
    an integer and is hardcoded to return **1**. Keep in mind that this is more of
    an example of where you could return your key if needed. It would be perfectly
    fine not to return anything and make the method return **void**. With the **[Route]**
    attribute in front of the class, the route for the API will be **/api/employees**.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 代码引入了一个用于注册员工的控制器动作。在 **employee** 参数前面的 **[FromBody]** 属性表示 **employee** 的内容位于
    HTTP 请求体中。动作返回一个整数，并硬编码为返回 **1**。请注意，这更多的是一个示例，说明你可以在需要时返回你的键。不返回任何内容并使方法返回 **void**
    是完全可以接受的。在类前面的 **[Route]** 属性，API 的路由将是 **/api/employees**。
- en: 'Open up the **Program.cs** file and make it look like the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 **Program.cs** 文件并使其看起来如下：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The code adds all controllers by convention and maps the routes of these. When
    adding controllers, the code adds **CommandActionFilter** as a filter to the pipeline.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码按照约定添加所有控制器并映射这些控制器的路由。当添加控制器时，代码将 **CommandActionFilter** 作为过滤器添加到管道中。
- en: 'That should be enough to take it for a spin. Run the project using the following
    command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足够你尝试一下了。使用以下命令运行项目：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should see a similar output to the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下类似的输出：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can now test the API using Postman:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用 Postman 测试 API：
- en: '![](img/B19418_13_01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19418_13_01.jpg)'
- en: Figure 13.1 – Posting with Postman
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 使用 Postman 发布
- en: Set the verb to be **POST**, and then use the URL from the output of your run
    and add **/api/employees** to the URL. Then select **JSON** in the **Body** tab,
    add an empty JSON document, and click **Send**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将动词设置为 **POST**，然后使用运行输出的 URL 并将 **/api/employees** 添加到 URL。然后在 **Body** 选项卡中选择
    **JSON**，添加一个空的 JSON 文档，然后点击 **Send**。
- en: 'The response should be similar to the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 响应应该类似于以下内容：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use **POST** for a valid object:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **POST** 请求有效对象：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In Postman, you should then get a successful result back:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Postman 中，你应该得到一个成功的结果：
- en: '![](img/B19418_13_02.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19418_13_02.jpg)'
- en: Figure 13.2 – A successful posting in Postman
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – Postman 中的成功发布
- en: 'You should see a response similar to the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个类似的响应：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You now have a clear, consistent result object for all **POST** actions. ASP.NET
    Core is very extensible and flexible, and most of the parts can be extended to
    perform cross-cutting concerns; authorization is a good example.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你为所有的 **POST** 动作有一个清晰、一致的结果对象。ASP.NET Core 非常可扩展和灵活，大部分部分都可以扩展以执行跨切面关注点；授权是一个很好的例子。
- en: Authorization based on metadata or structure
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于元数据或结构的授权
- en: By default, the approach for setting authorization for controllers in ASP.NET
    Core uses the **[Authorize]** attribute or the fluent interface when registering
    controllers or endpoints. For some scenarios, this can be very explicit, and in
    applications with a large number of controller endpoints, you might want to consider
    securing them in a cross-cutting manner.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，设置ASP.NET Core中控制器授权的方法使用**[Authorize]**属性或注册控制器或端点时的流畅接口。对于某些场景，这可以非常明确，在具有大量控制器端点的大型应用程序中，你可能希望考虑以跨切面方式对它们进行安全保护。
- en: If sections of your application are just meant to be used by users with a given
    role, this could be a great candidate for applying security policies for all of
    these based on namespace. Through structure, we get the implicit metadata that
    follows the types, and we can use that as a way to make decisions for us.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序的部分只是打算由具有特定角色的用户使用，那么根据命名空间应用安全策略可能是一个很好的选择。通过结构，我们得到跟随类型的隐式元数据，我们可以利用这一点来为我们做出决策。
- en: To do this, we need to put in a few things. First of all, we need to have a
    mechanism for authenticating users. For this sample, we will use hardcoded users
    to avoid the complexity of having to set up proper authentication with an identity
    provider.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个任务，我们需要做一些准备工作。首先，我们需要一个用于验证用户的机制。对于这个示例，我们将使用硬编码的用户来避免设置与身份提供者进行适当身份验证的复杂性。
- en: 'You’ll need a file called **HardCodedAuthenticationOptions.cs** in the root
    of **Chapter13** and then add the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在**Chapter13**的根目录下添加一个名为**HardCodedAuthenticationOptions.cs**的文件，然后添加以下内容：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code introduces an option type that will be used by the custom hardcoded
    identity provider. It doesn’t have any options since the provider will be completely
    hardcoded.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 代码引入了一个选项类型，该类型将由自定义硬编码的身份提供者使用。由于提供者将完全硬编码，因此它没有任何选项。
- en: 'Next, add a file called **HardCodedAuthenticationHandler.cs** in the root of
    **Chapter13** and make it look like the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在**Chapter13**的根目录下添加一个名为**HardCodedAuthenticationHandler.cs**的文件，并使其看起来如下所示：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code implements **AuthenticationHandler<>** and takes the dependencies the
    base class needs into the constructor and passes these down. The **HandleAuthenticateAsync()**
    method will always return a successful authentication with a hardcoded principal
    with an identity on it. For the time being, the identity has the role of **User**.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 代码实现了**AuthenticationHandler<>**，并在构造函数中接收基类需要的依赖项，并将这些依赖项传递下去。**HandleAuthenticateAsync()**方法将始终返回一个成功的身份验证，并带有硬编码的具有身份的principal。目前，该身份的角色是**User**。
- en: You will need an authorization policy that is specific to this sample. It should
    say you have to be an **Admin** within namespaces starting with a specific string.
    In ASP.NET, this is done by implementing a requirement, which is basically the
    configuration object for the policy, and then a handler that is capable of handling
    the requirement.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个针对此示例的特定授权策略。它应该说明你必须是在以特定字符串开头的命名空间中的**Admin**。在ASP.NET中，这是通过实现一个要求来完成的，该要求基本上是策略的配置对象，然后是一个能够处理该要求的处理程序。
- en: 'Add a file called **AdminForNamespace.cs** in the root of **Chapter13** and
    make it look like the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Chapter13**的根目录下添加一个名为**AdminForNamespace.cs**的文件，并使其看起来如下所示：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code holds the configuration in the form of a namespace string that will
    be used in the code that checks the policy. **IAuthorizationRequirement** is an
    empty marker interface with nothing to implement.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 代码以命名空间字符串的形式保存配置，该字符串将在检查策略的代码中使用。**IAuthorizationRequirement**是一个空的标记接口，不需要实现任何内容。
- en: 'Next, you need the handler. Add a file called **AdminForNamespaceHandler.cs**
    in the root of **Chapter13** and make it look like the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要处理程序。在**Chapter13**的根目录下添加一个名为**AdminForNamespaceHandler.cs**的文件，并使其看起来如下所示：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This overrides the abstract **HandleRequirementAsync()** method from the base
    class. In the **context** argument, there is a property called **Resource**. For
    Web API controller actions, this is typical of type **HttpContext**. The code,
    therefore, checks whether it is **HttpContext** and then has the implementation
    of the policy within that clause. In **HttpContext**, you can get the endpoint
    information. In the endpoint, there is metadata associated with it, and for our
    purpose, we’re looking for the specific controller information. The **ControllerActionDescriptor**
    metadata contains the actual method that is supposed to be called on your controller.
    On this, the code gets **DeclaringType** and uses its namespace to see whether
    the namespace requirement matches. If the type has a namespace that starts with
    the requirement and the user does not have the **Admin** role, it fails the **context**,
    meaning that the user is not authorized. You can provide reasons and more details
    for failing, but for this sample, we’re just keeping it clean.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这覆盖了基类中的抽象方法 **HandleRequirementAsync()**。在 **context** 参数中，有一个名为 **Resource**
    的属性。对于 Web API 控制器操作，这通常是 **HttpContext** 类型。因此，代码检查它是否是 **HttpContext**，然后在那个子句中实现策略。在
    **HttpContext** 中，你可以获取端点信息。在端点中，与之关联的元数据，并且为了我们的目的，我们正在寻找特定的控制器信息。**ControllerActionDescriptor**
    元数据包含应该在控制器上调用实际方法。在此，代码获取 **DeclaringType** 并使用其命名空间来查看命名空间要求是否匹配。如果类型具有以要求开始的命名空间，并且用户没有
    **Admin** 角色，它将失败 **context**，这意味着用户未授权。你可以提供失败的原因和更多详细信息，但在这个示例中，我们只是保持简洁。
- en: Tip
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If the user is **Admin**, it will succeed. It will also succeed if the namespace
    does not start with the requirement.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户是 **Admin**，则操作将成功。如果命名空间不以要求开始，它也会成功。
- en: With the policy handler in place, you need it to be hooked up so that it actually
    gets called. The default approach in ASP.NET Core is to add policies during the
    setup of the authorization. This approach, however, takes away the cross-cutting
    opportunity as you would then need to be explicit regarding the controllers whose
    policies should be applied. Instead, you’ll implement **IAuthorizationPolicyProvider**
    and set up the policies in this.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在策略处理程序就绪后，你需要将其连接起来，以便它实际上会被调用。ASP.NET Core 的默认方法是在授权设置期间添加策略。然而，这种方法会剥夺跨切面机会，因为你将需要明确指定应该应用策略的控制器。相反，你将实现
    **IAuthorizationPolicyProvider** 并在此设置策略。
- en: 'Add a file called **CrossCuttingPoliciesProvider.cs** in the root of **Chapter13**.
    It should be made to look like the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Chapter13** 的根目录下添加一个名为 **CrossCuttingPoliciesProvider.cs** 的文件。它应该看起来如下所示：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code sets up **AuthorizationPolicy** that includes the **AdminForNamespace**
    policy. **IAuthorizationPolicyProvider** requires you to implement methods for
    getting policies for different scenarios; all of these return the same policy.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 代码设置了包含 **AdminForNamespace** 策略的 **AuthorizationPolicy**。**IAuthorizationPolicyProvider**
    要求你实现获取不同场景策略的方法；所有这些方法都返回相同的策略。
- en: Important note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Returning the same policy for **GetDefaultPolicyAsync()**, **GetFallbackPolicyAsync()**,
    and **GetPolicyAsync()** might not be the desired behavior. This is done for the
    simplicity of the sample.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **GetDefaultPolicyAsync()**、**GetFallbackPolicyAsync()** 和 **GetPolicyAsync()**
    返回相同的策略可能不是期望的行为。这是为了简化示例而进行的。
- en: Next, you will be tying the authorization back into **CommandActionFilter**
    you created earlier, and to do that, we have to communicate the authorization
    results that are returned. Unfortunately, this information is not easily accessible
    in the following stages of the ASP.NET Core pipeline.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将把授权重新连接到你之前创建的 **CommandActionFilter**，为此，我们必须传达返回的授权结果。不幸的是，这个信息在 ASP.NET
    Core 管道后续阶段中不容易访问。
- en: 'Add a file called **HttpContextExtensions.cs** in the root of **Chapter13**
    and make it look like the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Chapter13** 的根目录下添加一个名为 **HttpContextExtensions.cs** 的文件，并使其看起来如下所示：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The code uses the **Items** dictionary on **HttpContext** and provides both
    a set method and a get method for working with **PolicyAuthorizationResult**.
    **Items** is a key/value store that can hold anything as part of the current Web
    request. This is perfect for when you want to make something available to other
    stages.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 **HttpContext** 上的 **Items** 字典，并为处理 **PolicyAuthorizationResult** 提供了设置方法和获取方法。**Items**
    是一个键/值存储，可以作为当前 Web 请求的一部分存储任何内容。这非常适合当你想要将某些内容提供给其他阶段时。
- en: 'ASP.NET Core provides specific middleware for dealing with the result of authorization.
    Add a file called **CrossCuttingAuthorizationMiddlewareResultHandler.cs** and
    make it look like the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 提供了特定的中间件来处理授权的结果。添加一个名为 **CrossCuttingAuthorizationMiddlewareResultHandler.cs**
    的文件，并使其看起来如下：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code implements the **IAuthorizationMiddlewareResultHandler** interface,
    which holds a **HandleAsync()** method. This method gets called after all policies
    have been handled but before the action filters. The implementation of **HandleAsync()**
    puts **authorizationResult** on **HttpContext** for the availability of later
    stages. It then uses the default implementation of the interface called **AuthorizationMiddlewareResultHandler**
    to invoke the rest of the pipeline, only now simulating a success. The reason
    it simulates success is to trick the handler to perform the action filters. We
    want **CommandActionFilter** to add support for authorization and return the **CommandResult**
    structure consistently.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 代码实现了 **IAuthorizationMiddlewareResultHandler** 接口，该接口包含一个 **HandleAsync()**
    方法。此方法在所有策略都已处理但在操作过滤器之前被调用。**HandleAsync()** 的实现将 **authorizationResult** 放置在
    **HttpContext** 中，以便后续阶段可以使用。然后，它使用接口的默认实现 **AuthorizationMiddlewareResultHandler**
    来调用管道的其余部分，但现在模拟成功。它模拟成功的原因是为了欺骗处理程序执行操作过滤器。我们希望 **CommandActionFilter** 添加对授权的支持并始终如一地返回
    **CommandResult** 结构。
- en: 'Open the **CommandActionFilter.cs** file in the **Commands** folder within
    **Chapter13** and make the top of the method look like the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 **Chapter13** 项目根目录下的 **CommandActionFilter.cs** 文件，并将方法的顶部修改如下：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The change you’re performing is making use of the authorization result. If the
    authorization result has not succeeded, you don’t want to call the rest of the
    pipeline, but you want to capture it in the command result.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在进行的更改正在利用授权结果。如果授权结果未成功，您不希望调用管道的其余部分，但您希望将其捕获在命令结果中。
- en: 'In the same file and method, change how you create **CommandResult** to include
    the **IsAuthorized** property:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件和方法中，更改创建 **CommandResult** 的方式以包括 **IsAuthorized** 属性：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The code now has **CommandResult** that includes **IsAuthorized**. Since the
    rest of the action filter takes this into consideration, you should also be getting
    the correct HTTP status codes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在包含 **CommandResult**，其中包含 **IsAuthorized**。由于操作过滤器的其余部分也考虑了这一点，因此您也应该得到正确的
    HTTP 状态码。
- en: 'Open the **Program.cs** file in the root of the **Chapter13** project and change
    it to look like the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 **Chapter13** 项目根目录下的 **Program.cs** 文件，并修改如下：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The changes introduce both authentication and authorization and hooks **Services**
    into the different handlers and providers you have created. For the authentication,
    it sets up the hardcoded handler as the default authentication schema and configures
    the scheme to use the handler type you created.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改引入了身份验证和授权，并将**服务**钩子连接到您创建的不同处理程序和提供者。对于身份验证，它将硬编码的处理程序设置为默认的身份验证模式，并配置方案以使用您创建的处理程序类型。
- en: 'Running the application and performing the same operation as before using Postman
    should yield the following result:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Postman 运行应用程序并执行与之前相同的操作应该得到以下结果：
- en: '![](img/B19418_13_03.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B19418_13_03.jpg](img/B19418_13_03.jpg)'
- en: Figure 13.3 – An unauthorized result in Postman
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – Postman 中的未授权结果
- en: 'The output should have **isAuthorized** set to **false**:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应将 **isAuthorized** 设置为 **false**：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s try to change the role of the user to **Admin**. Open the **HardCodedAuthenticationHandler.cs**
    file in the root of **Chapter13** and change the role from **User** to **Admin**.
    To do this, find the line that says the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将用户的角色更改为 **Admin**。打开 **Chapter13** 根目录下的 **HardCodedAuthenticationHandler.cs**
    文件，将角色从 **User** 更改为 **Admin**。为此，找到以下内容的行：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then make it look like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使其看起来如下：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Running the application now and performing the same operation again should
    give you a result where you’re authorized:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序并再次执行相同的操作应该会得到一个授权的结果：
- en: '![](img/B19418_13_04.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B19418_13_04.jpg](img/B19418_13_04.jpg)'
- en: Figure 13.4 – An authorized result in Postman
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – Postman 中的授权结果
- en: 'The JSON output should look like the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 输出应如下所示：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This should give you an idea of what is possible. With ASP.NET Core, you can
    go deep into replacing default behavior and customizing it to your needs, which
    is fabulous when you’re looking to apply some cross-cutting concerns.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给您一个想法，了解可能发生的情况。使用 ASP.NET Core，您可以深入替换默认行为并按需定制，这在您想要应用一些横切关注点时非常棒。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Recipes are pieces of code that clearly specify, in a linear manner, what they
    do, are a great tool for new developers. The developer can really see what’s going
    on, reason about the code, and find errors. As the developer, team, and project
    mature, the recipes start to feel like unnecessary chores or at least become very
    repetitive. Not only is this something that potentially affects productivity,
    but these kinds of repetitive tasks are easy to get wrong. Getting it wrong could
    pose multiple risks to the system:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本是明确、线性地指定它们所做事情的代码片段，对于新开发者来说是一个非常好的工具。开发者可以真正看到正在发生的事情，对代码进行推理，并找到错误。随着开发者、团队和项目的成熟，这些脚本开始感觉像是不必要的琐事，或者至少变得非常重复。这不仅可能影响生产力，而且这些重复性任务很容易出错。出错可能会对系统造成多重风险：
- en: Security risks
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全风险
- en: The risk of persisting invalid data
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续无效数据的风险
- en: The risk of allowing operations that are not allowed
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许不允许的操作的风险
- en: The risk of losing operational insight due to a lack of logging
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于缺乏日志记录而失去操作洞察力的风险
- en: The tradeoff between imperative procedural code that a developer can quickly
    reason about and the need for a consistent system is one you should consider.
    In smaller projects, it might not be worth the cognitive load of being “different”
    in applying things cross-cuttingly, while in larger systems, it might be completely
    crucial. There could be a correlation with the size of the team as well—the bigger
    the team, the more things you want to automate and standardize.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发者可以快速推理的命令式过程代码和需要一致的系统之间进行权衡，这是你应该考虑的。在较小的项目中，可能不值得在应用横切方面“不同”的认知负担，而在较大的系统中，这可能是至关重要的。这可能与团队的大小有关——团队越大，你想要自动化和标准化的东西就越多。
- en: Applying cross-cutting concerns can be extremely powerful, but it can feel like
    a black box if the developers don’t know about it and can’t understand why something
    is happening. My advice on that is to make sure all developers are educated on
    how cross-cutting concerns are handled and ensure that it is possible to follow
    code paths. Rather than documenting the recipes, my suggestion would be to document
    how they are automated and how developers can, for instance, debug things.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 应用横切关注点可以非常强大，但如果开发者不了解它，无法理解为什么某些事情会发生，它可能会感觉像是一个黑盒。我的建议是确保所有开发者都了解如何处理横切关注点，并确保能够跟踪代码路径。与其记录脚本，我的建议是记录它们是如何自动化的，以及开发者如何调试问题，例如。
- en: In the next chapter, we’ll dive into how you can go deeper by leveraging aspect-oriented
    programming.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨如何通过利用面向方面编程来进一步深入。
