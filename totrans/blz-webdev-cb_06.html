<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-203">
    <a id="_idTextAnchor203">
    </a>
    
     6
    
   </h1>
   <h1 id="_idParaDest-204">
    <a id="_idTextAnchor204">
    </a>
    
     Building Interactive Forms
    
   </h1>
   <p>
    
     In this chapter, we will focus on the essential skills needed to construct interactive forms in Blazor.
    
    
     Forms are a critical component of many web applications, and Blazor provides tools that significantly simplify form creation
    
    
     
      and handling.
     
    
   </p>
   <p>
    
     We will start by learning how to bind simple and nested models to a form for capturing and managing user input.
    
    
     Next, we will explore the built-in input components provided by Blazor.
    
    
     These components help standardize form behavior across different platforms, ensuring consistency and reducing the amount of custom code needed.
    
    
     We will also cover techniques for interpreting keystrokes and making the form intuitive.
    
    
     At the end of the chapter, we will address
    
    <a id="_idIndexMarker277">
    </a>
    
     the security aspect of form handling and the role of the
    
    <strong class="bold">
     
      anti-forgery
     
    </strong>
    
     token.
    
    
     Implementing these security measures is crucial for
    
    <a id="_idIndexMarker278">
    </a>
    
     protecting your applications from common web threats such as
    
    <strong class="bold">
     
      Cross-Site Request Forgery
     
    </strong>
    
     (
    
    
     <strong class="bold">
      
       CSRF
      
     </strong>
    
    
     
      ) attacks.
     
    
   </p>
   <p>
    
     By the end of this chapter, you will have the practical knowledge to create, manage, and secure forms in Blazor applications – all vital for developing reliable, interactive, and user-friendly
    
    
     
      web applications.
     
    
   </p>
   <p>
    
     Here’s the list of recipes we’ll cover in
    
    
     
      this chapter:
     
    
   </p>
   <ul>
    <li>
     
      Binding a simple model to
     
     
      
       a form
      
     
    </li>
    <li>
     
      Submitting static forms without full
     
     
      
       page reload
      
     
    </li>
    <li>
     
      Binding nested models to
     
     
      
       a form
      
     
    </li>
    <li>
     
      Utilizing built-in
     
     
      
       input components
      
     
    </li>
    <li>
     
      Handling file uploads with
     
     
      
       a form
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-205">
    <a id="_idTextAnchor205">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     We will keep the examples simple and focus on showcasing all the angles of setting up forms in Blazor.
    
    
     At the beginning of each recipe, you will find instructions on where to find required samples and which directories to create.
    
    
     With that said, you will need these basic tools for
    
    
     
      Blazor development:
     
    
   </p>
   <ul>
    <li>
     
      A modern IDE (that supports
     
     
      
       Blazor development)
      
     
    </li>
    <li>
     
      A modern web browser (that
     
     
      
       supports WebAssembly)
      
     
    </li>
    <li>
     
      Browser DevTools (that could be a part of the modern
     
     
      
       browser already)
      
     
    </li>
    <li>
     
      A Blazor project (where you’ll write
     
     
      
       your code)
      
     
    </li>
   </ul>
   <p>
    
     In the
    
    <em class="italic">
     
      Handling file uploads with a form
     
    </em>
    
     recipe, we’ll utilize a NuGet package –
    
    <strong class="source-inline">
     
      Microsoft.AspNetCore.Http.Features
     
    </strong>
    
     – that’s not pre-installed by default, so you might as well add it to your
    
    
     
      project now.
     
    
   </p>
   <p>
    
     You can find all the code samples on GitHub
    
    
     
      at
     
    
    
     
      :
     
    
    <a href="https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter06">
     
      
       https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter06
      
     
    </a>
   </p>
   <h1 id="_idParaDest-206">
    <a id="_idTextAnchor206">
    </a>
    
     Binding a simple model to a form
    
   </h1>
   <p>
    
     In the development of modern web applications, forms are ubiquitous and essential.
    
    
     Whether
    
    <a id="_idIndexMarker279">
    </a>
    
     registering user details, collecting feedback, or entering information, forms serve as the primary interface for user input.
    
    
     Blazor supports a traditional HTML
    
    <strong class="source-inline">
     
      &lt;form&gt;
     
    </strong>
    
     markup but elevates the experience with its native
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     component.
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     integrates seamlessly with Blazor’s data binding capabilities and provides a streamlined, efficient approach to
    
    
     
      form management.
     
    
   </p>
   <p>
    
     Let’s add the first small form that binds to a simple data model and allows the user to create a new event by providing
    
    
     
      its name.
     
    
   </p>
   <h2 id="_idParaDest-207">
    <a id="_idTextAnchor207">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we start creating a form and bind it to a simple model, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter06
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe01
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Models.cs
      
     </strong>
     
      file from the
     
     <strong class="source-inline">
      
       Chapter06
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-208">
    <a id="_idTextAnchor208">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     To implement
    
    <a id="_idIndexMarker280">
    </a>
    
     a form supporting a simple data model, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a routable
     
     
      <strong class="source-inline">
       
        EventManager
       
      </strong>
     
     
      
       component:
      
     
     <pre class="source-code">
@page "/ch06r01"</pre>
    </li>
    <li>
     
      Within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      , declare a
     
     <strong class="source-inline">
      
       Model
      
     </strong>
     
      object and decorate it with a
     
     
      <strong class="source-inline">
       
        SupplyParameterFromForm
       
      </strong>
     
     
      
       attribute:
      
     
     <pre class="source-code">
[SupplyParameterFromForm]
protected Event Model { get; set; }</pre>
    </li>
    <li>
     
      Still inside the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, override the
     
     <strong class="source-inline">
      
       OnInitialized()
      
     </strong>
     
      lifecycle method with conditional initialization of the
     
     <strong class="source-inline">
      
       Model
      
     </strong>
     
      parameter if it’s unset.
     
     
      Additionally, implement a
     
     <strong class="source-inline">
      
       Save()
      
     </strong>
     
      method as a placeholder to simulate saving
     
     
      
       the form:
      
     
     <pre class="source-code">
protected override void OnInitialized()
    =&gt; Model ??= new();
private void Save()
    =&gt; Console.WriteLine($"Saved {Model.Name}.");</pre>
    </li>
    <li>
     
      In the markup of
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      , embed an
     
     <strong class="source-inline">
      
       EditForm
      
     </strong>
     
      component and bind it to the
     
     <strong class="source-inline">
      
       Model
      
     </strong>
     
      parameter.
     
     
      Include an input field for entering
     
     <strong class="source-inline">
      
       Model.Name
      
     </strong>
     
      and a submit button that triggers the
     
     
      <strong class="source-inline">
       
        Save()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
&lt;EditForm FormName="event-form"
          Model="@Model"
          OnSubmit="@Save"&gt;
    &lt;label&gt;
        Name:
        &lt;InputText @bind-Value="@Model.Name" /&gt;
    &lt;/label&gt;
    &lt;button type="submit"&gt;Save&lt;/button&gt;
&lt;/EditForm&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-209">
    <a id="_idTextAnchor209">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we create a routable
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     component, which will serve as the container for
    
    
     
      our form.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , within the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     , we declare a
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     parameter for our form
    
    <a id="_idIndexMarker281">
    </a>
    
     with a form-specific attribute –
    
    <strong class="source-inline">
     
      SupplyParameterFromForm
     
    </strong>
    
     – enabling Blazor to automatically populate the
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     object with values from the associated form.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we finalize the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     .
    
    
     We override the
    
    <strong class="source-inline">
     
      OnInitialized()
     
    </strong>
    
     lifecycle method to seamlessly initialize the
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     parameter to an empty object unless it already carries a value.
    
    
     Additionally, we introduce a
    
    <strong class="source-inline">
     
      Save()
     
    </strong>
    
     method, acting as a placeholder to mimic the saving of changes made to
    
    
     
      the form.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we tackle the implementation of the
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     markup, leveraging Blazor’s built-in
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     component.
    
    
     We assign our
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     object to the
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     parameter of the
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     component and the
    
    <strong class="source-inline">
     
      Save()
     
    </strong>
    
     method to the
    
    <strong class="source-inline">
     
      OnSubmit
     
    </strong>
    
     callback, automating the invocation of
    
    <strong class="source-inline">
     
      Save()
     
    </strong>
    
     upon form submission.
    
    
     Crucially, we set a unique value for the
    
    <strong class="source-inline">
     
      FormName
     
    </strong>
    
     parameter of
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     , allowing Blazor to properly resolve the form data.
    
    
     Within the form, we incorporate a simple input box, binding it to the
    
    <strong class="source-inline">
     
      Model.Name
     
    </strong>
    
     property, and include a submit button to facilitate
    
    
     
      form submission.
     
    
   </p>
   <p>
    
     We opted not to declare any render mode intentionally, resulting in static server-side rendering of our page.
    
    
     While this approach ensures quick rendering and minimal resource utilization on the server, submitting the form requires a full page reload – similar to
    
    <strong class="bold">
     
      MVC
     
    </strong>
    
     or
    
    <strong class="bold">
     
      Razor
     
    </strong>
    
     <strong class="bold">
      
       pages
      
     </strong>
    
    
     
      applications.
     
    
   </p>
   <h2 id="_idParaDest-210">
    <a id="_idTextAnchor210">
    </a>
    
     There’s more
    
   </h2>
   <p>
    
     Each parameter of the
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     component has a corresponding Blazor attribute, compatible
    
    <a id="_idIndexMarker282">
    </a>
    
     with standard HTML, which means you can customize the behavior of your forms extensively without relying on the
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     component.
    
    
     You can retain the standard HTML
    
    <strong class="source-inline">
     
      &lt;form&gt;
     
    </strong>
    
     markup and customize it to
    
    
     
      your needs.
     
    
   </p>
   <p>
    
     To give you a practical example, here’s how you can implement our form using the HTML
    
    <strong class="source-inline">
     
      &lt;
     
    </strong>
    
     <strong class="source-inline">
      
       form&gt;
      
     </strong>
    
    
     
      markup:
     
    
   </p>
   <pre class="source-code">
&lt;form method="post"
      @onsubmit="@Save"
      @formname="event-form"&gt;
    &lt;AntiforgeryToken /&gt;
    &lt;label&gt;
        Name:
        &lt;InputText @bind-Value="@Model.Name" /&gt;
    &lt;/label&gt;
    &lt;button type="submit"&gt;Save&lt;/button&gt;
&lt;/form&gt;</pre>
   <p>
    
     We construct a simple form, leveraging the default HTML
    
    <strong class="source-inline">
     
      form
     
    </strong>
    
     element.
    
    
     We declare the form’s unique name, the method to call on submit, and that Blazor should execute a
    
    <strong class="source-inline">
     
      post
     
    </strong>
    
     action when submitting the data.
    
    
     However, as we no longer leverage the
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     component, Blazor will force us to provide an anti-forgery token for security reasons.
    
    
     For that, we leverage a built-in
    
    <strong class="source-inline">
     
      AntiforgeryToken
     
    </strong>
    
     component, but we will explore that component in detail in the
    
    <em class="italic">
     
      Securing a form with an anti-forgery token
     
    </em>
    
     recipe, at the end of
    
    
     
      the chapter.
     
    
   </p>
   <h1 id="_idParaDest-211">
    <a id="_idTextAnchor211">
    </a>
    
     Submitting static forms without full page reload
    
   </h1>
   <p>
    
     Blazor, leveraging the diffing algorithm (we talked about it in the
    
    <em class="italic">
     
      Hooking into event delegates
     
    </em>
    
     recipe in
    
    <a href="B22020_03.xhtml#_idTextAnchor095">
     
      <em class="italic">
       
        Chapter 3
       
      </em>
     
    </a>
    
     ), offers an
    
    <strong class="bold">
     
      enhanced navigation
     
    </strong>
    
     feature, which optimizes user
    
    <a id="_idIndexMarker283">
    </a>
    
     interactions by reducing unnecessary re-renderings
    
    <a id="_idIndexMarker284">
    </a>
    
     and updating only the parts of the UI that have changed rather than reloading entire pages.
    
    
     Interactive render modes
    
    <a id="_idIndexMarker285">
    </a>
    
     have the diffing algorithm enabled by default, but forms rendered in
    
    <strong class="bold">
     
      static server-side render
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SSR
     
    </strong>
    
     ) mode do not.
    
    
     In this recipe, we will explore how to enable the enhanced navigation on the
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     component using the
    
    
     <strong class="source-inline">
      
       Enhanced
      
     </strong>
    
    
     
      parameter.
     
    
   </p>
   <p>
    
     Let’s enable enhanced navigation on the
    
    <strong class="source-inline">
     
      Event
     
    </strong>
    
     creation form and prevent the form from reloading the entire page upon submission while maintaining its operation in
    
    
     
      SSR mode.
     
    
   </p>
   <h2 id="_idParaDest-212">
    <a id="_idTextAnchor212">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we explore form enhancing, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter06
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe02
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      component from the
     
     <em class="italic">
      
       Binding a simple model to a form
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Chapter06
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe01
      
     </strong>
     
      directory of the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Models.cs
      
     </strong>
     
      file from the
     
     <strong class="source-inline">
      
       Chapter06
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-213">
    <a id="_idTextAnchor213">
    </a>
    
     How to do it…
    
   </h2>
   <ol>
    <li>
     
      To enable enhanced navigation on your form, navigate to the
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      component and set the
     
     <strong class="source-inline">
      
       Enhance
      
     </strong>
     
      parameter value of the
     
     
      <strong class="source-inline">
       
        EditForm
       
      </strong>
     
     
      
       component:
      
     
    </li>
   </ol>
   <pre class="source-code">
&lt;EditForm FormName="event-form"
          Model="@Model"
          OnSubmit="@Save"
          Enhance&gt;
    @* form body *@
&lt;/EditForm&gt;</pre>
   <h2 id="_idParaDest-214">
    <a id="_idTextAnchor214">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In this recipe, we navigate to the
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     component and set the value of the
    
    <strong class="source-inline">
     
      Enhance
     
    </strong>
    
     parameter on the
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     component.
    
    
     Since
    
    <strong class="source-inline">
     
      Enhance
     
    </strong>
    
     is of type
    
    <strong class="source-inline">
     
      bool
     
    </strong>
    
     , merely
    
    <a id="_idIndexMarker286">
    </a>
    
     stating the parameter name is equivalent to declaring
    
    <strong class="source-inline">
     
      Enhance="true"
     
    </strong>
    
     .
    
    
     This simple adjustment is all it takes to enable the enhanced navigation on your form.
    
    
     If you’ve been developing MVC applications, you can conceptualize the enhancement using
    
    <strong class="source-inline">
     
      Html.BeginForm
     
    </strong>
    
     when the form is not enhanced and
    
    <strong class="source-inline">
     
      Ajax.BeginForm
     
    </strong>
    
     with the
    
    <strong class="source-inline">
     
      Enhance
     
    </strong>
    
     attribute
    
    
     
      in place.
     
    
   </p>
   <p>
    
     Although the
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     component continues to render statically on the server, with enhanced navigation activated, Blazor now monitors UI changes more effectively.
    
    
     Full-page reload is no longer required when a user submits the form, which results in a smoother and more responsive user experience while still leveraging the benefits of
    
    
     
      the SSR.
     
    
   </p>
   <h2 id="_idParaDest-215">
    <a id="_idTextAnchor215">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Enhance
     
    </strong>
    
     parameter, similar
    
    <a id="_idIndexMarker287">
    </a>
    
     to other parameters of the
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     component, has an equivalent attribute compatible with plain HTML forms –
    
    
     <strong class="source-inline">
      
       data-enhance
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Here’s how you can attach
    
    <strong class="source-inline">
     
      data-enhance
     
    </strong>
    
     to your
    
    <strong class="source-inline">
     
      &lt;
     
    </strong>
    
     <strong class="source-inline">
      
       form&gt;
      
     </strong>
    
    
     
      tag:
     
    
   </p>
   <pre class="source-code">
&lt;form method="post"
      @onsubmit="@Save"
      @formname="event-form" 
      data-enhance&gt;
    @* form body *@
&lt;/form&gt;</pre>
   <p>
    
     We leverage the default HTML
    
    <strong class="source-inline">
     
      form
     
    </strong>
    
     element and declare the form’s unique name, the method to call on submit, and that Blazor should execute a
    
    <strong class="source-inline">
     
      post
     
    </strong>
    
     action when submitting the data.
    
    
     Next to those already familiar attributes, we attach the
    
    <strong class="source-inline">
     
      data-enhance
     
    </strong>
    
     attribute.
    
    
     The order of attributes has no impact on the
    
    
     
      form’s functionality.
     
    
   </p>
   <h1 id="_idParaDest-216">
    <a id="_idTextAnchor216">
    </a>
    
     Binding nested models to a form
    
   </h1>
   <p>
    
     In this recipe, we’ll explore the management of
    
    <strong class="bold">
     
      nested models
     
    </strong>
    
     within forms in Blazor.
    
    
     Nested models
    
    <a id="_idIndexMarker288">
    </a>
    
     are complex data structures where a model contains other models as properties.
    
    
     They’re common when we capture detailed or structured
    
    <a id="_idIndexMarker289">
    </a>
    
     information, such as a user profile with multiple addresses or an order with multiple items.
    
    
     However, managing forms with complex and nested data models can get out of hand as the depth of the data structure grows.
    
    
     Keeping track of each input field and ensuring proper binding can be challenging, making the form less maintainable and more prone to errors.
    
    
     The
    
    <strong class="source-inline">
     
      Editor&lt;T&gt;
     
    </strong>
    
     component simplifies the handling of complex object scenarios as it encapsulates the binding of each field to its corresponding property, giving you a narrowed view of the current
    
    
     
      form context.
     
    
   </p>
   <p>
    
     Let’s enhance our event creation form with a nested object, allowing us to add information about the
    
    
     
      event’s duration.
     
    
   </p>
   <h2 id="_idParaDest-217">
    <a id="_idTextAnchor217">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we start the implementation of a nested form, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter06
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      component from the
     
     <em class="italic">
      
       Submitting static forms without full page reload
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Chapter06
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe02
      
     </strong>
     
      directory of the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Models.cs
      
     </strong>
     
      file from the
     
     <strong class="source-inline">
      
       Chapter06
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-218">
    <a id="_idTextAnchor218">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these
    
    <a id="_idIndexMarker290">
    </a>
    
     steps to implement a maintainable
    
    
     
      nested form:
     
    
   </p>
   <ol>
    <li>
     
      Create an
     
     <strong class="source-inline">
      
       EventDurationForm
      
     </strong>
     
      component inheriting
     
     
      
       from
      
     
     
      <strong class="source-inline">
       
        Editor&lt;EventPeriod&gt;
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
@inherits Editor&lt;EventPeriod&gt;</pre>
    </li>
    <li>
     
      In the markup of the
     
     <strong class="source-inline">
      
       EventDurationForm
      
     </strong>
     
      component, utilize the
     
     <strong class="source-inline">
      
       InputDate
      
     </strong>
     
      component and add two fields for setting the
     
     <strong class="source-inline">
      
       Start
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       End
      
     </strong>
     
      properties of the base
     
     
      <strong class="source-inline">
       
        EventPeriod
       
      </strong>
     
     
      
       model:
      
     
     <pre class="source-code">
&lt;label&gt;
    From: &lt;InputDate @bind-Value="@Value.Start" /&gt;
&lt;/label&gt;
&lt;label&gt;
    To: &lt;InputDate @bind-Value="@Value.End" /&gt;
&lt;/label&gt;</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      component, navigate to the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block and extend the
     
     <strong class="source-inline">
      
       Save()
      
     </strong>
     
      method to log
     
     <strong class="source-inline">
      
       Model.Period
      
     </strong>
     
      details to
     
     
      
       the console:
      
     
     <pre class="source-code">
private void Save()
{
    Console.WriteLine($"Saved {Model.Name}.");
    Console.WriteLine(
        $"{Model.Period.Start} - {Model.Period.End}"
    );
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      markup, integrate an instance of the
     
     <strong class="source-inline">
      
       EventDurationForm
      
     </strong>
     
      component within
     
     <strong class="source-inline">
      
       EditForm
      
     </strong>
     
      , between the existing label and the
     
     <strong class="source-inline">
      
       submit
      
     </strong>
     
      button, and bind it to the
     
     <strong class="source-inline">
      
       Model.Period
      
     </strong>
     
      
       nested property:
      
     
     <pre class="source-code">
&lt;label&gt;
    Name: &lt;InputText @bind-Value="@Model.Name" /&gt;
&lt;/label&gt;
&lt;EventDurationForm @bind-Value="@Model.Period" /&gt;
&lt;button type="submit"&gt;Save&lt;/button&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-219">
    <a id="_idTextAnchor219">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we create the
    
    <strong class="source-inline">
     
      EventDurationForm
     
    </strong>
    
     component, dedicated to handling the period settings
    
    <a id="_idIndexMarker291">
    </a>
    
     of an event.
    
    
     To properly reference the necessary model, we include a
    
    <strong class="source-inline">
     
      @using
     
    </strong>
    
     directive for the assembly of the
    
    <strong class="source-inline">
     
      EventPeriod
     
    </strong>
    
     model and use the
    
    <strong class="source-inline">
     
      @inherits
     
    </strong>
    
     directive to derive from the generic
    
    <strong class="source-inline">
     
      Editor&lt;T&gt;
     
    </strong>
    
     component, setting
    
    <strong class="source-inline">
     
      T
     
    </strong>
    
     as our
    
    <strong class="source-inline">
     
      EventPeriod
     
    </strong>
    
     model.
    
    
     Next, in
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we add the markup of the
    
    <strong class="source-inline">
     
      EventDurationForm
     
    </strong>
    
     component.
    
    
     As the
    
    <strong class="source-inline">
     
      Editor&lt;T&gt;
     
    </strong>
    
     component implements the
    
    <strong class="source-inline">
     
      @bind-Value
     
    </strong>
    
     pattern, we can directly interact with the underlying model through the local
    
    <strong class="source-inline">
     
      Value
     
    </strong>
    
     property.
    
    
     We embed two date input fields using the
    
    <strong class="source-inline">
     
      InputDate
     
    </strong>
    
     component, binding them to the
    
    <strong class="source-inline">
     
      Value.Start
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Value.End
     
    </strong>
    
     properties.
    
    
     For now, we will skip the built-in form components in Blazor as we explore them in a
    
    
     
      subsequent recipe.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we shift our focus to the
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     component.
    
    
     In the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block, we extend the
    
    <strong class="source-inline">
     
      Save()
     
    </strong>
    
     placeholder method to log
    
    <strong class="source-inline">
     
      Model.Period
     
    </strong>
    
     details to the console.
    
    
     It will allow us to validate the binding of our nested model.
    
    
     Finally, in
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we jump to the markup of the
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     component and integrate the
    
    <strong class="source-inline">
     
      EventDurationForm
     
    </strong>
    
     component into the existing
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     markup, right before the submit button.
    
    
     By utilizing the bind-Value pattern, we bind the
    
    <strong class="source-inline">
     
      Model.Period
     
    </strong>
    
     object directly
    
    
     
      to
     
    
    
     <strong class="source-inline">
      
       EventDurationForm
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     We’ve effectively encapsulated the markup and logic of managing the event period without complexifying the main
    
    
     <strong class="source-inline">
      
       EditForm
      
     </strong>
    
    
     
      instance.
     
    
   </p>
   <h2 id="_idParaDest-220">
    <a id="_idTextAnchor220">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Throughout all the recipes exploring the
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     capabilities, we have consistently utilized static server rendering.
    
    
     It’s a strategic choice, allowing you to highlight any potential edge
    
    <a id="_idIndexMarker292">
    </a>
    
     cases and particularities of the SSR mode and providing a comprehensive understanding of how forms behave under different
    
    
     
      rendering conditions.
     
    
   </p>
   <p>
    
     However, if you choose to employ any of the interactive rendering modes available in Blazor, forms will continue to function correctly.
    
    
     By adding the
    
    <strong class="source-inline">
     
      @renderMode
     
    </strong>
    
     directive to your components, you can easily switch between rendering modes depending on the needs of your application.
    
    
     Whether you need server-side rendering for its robustness and security or client-side rendering for its interactivity and speed —
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     will operate smoothly
    
    
     
      and efficiently.
     
    
   </p>
   <h1 id="_idParaDest-221">
    <a id="_idTextAnchor221">
    </a>
    
     Utilizing built-in input components
    
   </h1>
   <p>
    
     In this recipe, we’ll explore how quickly you can set up both simple and complex forms using Blazor’s
    
    <a id="_idIndexMarker293">
    </a>
    
     native form support and built-in input components.
    
    
     The benefit of using Blazor lies in its ability to handle much of the heavy lifting involved in form creation, such as data binding, event handling, maintaining state, or parsing user input to expected values.
    
    
     You’re then free to focus on other aspects of the
    
    
     
      user interface.
     
    
   </p>
   <p>
    
     Let’s showcase Blazor’s built-in input components by creating a comprehensive form where the system administrator provides a detailed definition of the events they
    
    
     
      are planning.
     
    
   </p>
   <h2 id="_idParaDest-222">
    <a id="_idTextAnchor222">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we build the event creator, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter06
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe04
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       EventDurationForm
      
     </strong>
     
      components from the
     
     <em class="italic">
      
       Binding nested models to a form
      
     </em>
     
      recipe or copy their implementation from the
     
     <strong class="source-inline">
      
       Chapter06
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      directory of the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Models.cs
      
     </strong>
     
      file from the
     
     <strong class="source-inline">
      
       Chapter06
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-223">
    <a id="_idTextAnchor223">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these
    
    <a id="_idIndexMarker294">
    </a>
    
     steps to implement the event creator with built-in
    
    
     
      input components:
     
    
   </p>
   <ol>
    <li>
     
      Open the
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      component and, in the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, update the
     
     
      <strong class="source-inline">
       
        Save()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
private void Save()
    =&gt; Console.WriteLine($"Saved: {Model.Json}");</pre>
    </li>
    <li>
     
      Navigate to the markup section of the
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      component and locate the
     
     <strong class="source-inline">
      
       EditForm
      
     </strong>
     
      markup.
     
     
      All subsequent steps will take place within
     
     
      
       this form.
      
     
    </li>
    <li>
     
      Wrap the existing
     
     <strong class="source-inline">
      
       InputText
      
     </strong>
     
      instance,
     
     <strong class="source-inline">
      
       EventDurationForm
      
     </strong>
     
      instance, and the save button in separate paragraph
     
     <strong class="source-inline">
      
       &lt;
      
     </strong>
     
      <strong class="source-inline">
       
        p&gt;
       
      </strong>
     
     
      
       tags:
      
     
     <pre class="source-code">
&lt;p&gt;
    Name:
    &lt;InputText @bind-Value="@Model.Name" /&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;EventDurationForm @bind-Value="@Model.Period" /&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;button type="submit"&gt;Save&lt;/button&gt;
&lt;/p&gt;</pre>
    </li>
    <li>
     
      In a new paragraph, below the
     
     <strong class="source-inline">
      
       EventDurationForm
      
     </strong>
     
      paragraph, add an
     
     <strong class="source-inline">
      
       InputCheckbox
      
     </strong>
     
      component and bind it to the
     
     
      <strong class="source-inline">
       
        Model.IsActive
       
      </strong>
     
     
      
       property:
      
     
     <pre class="source-code">
&lt;p&gt;
    &lt;InputCheckbox @bind-Value="@Model.IsActive" /&gt;
    Active
&lt;/p&gt;</pre>
    </li>
    <li>
     
      Add another
     
     <a id="_idIndexMarker295">
     </a>
     
      paragraph – this time with an
     
     <strong class="source-inline">
      
       InputNumber
      
     </strong>
     
      component – and bind it to the
     
     
      <strong class="source-inline">
       
        Model.Capacity
       
      </strong>
     
     
      
       property:
      
     
     <pre class="source-code">
&lt;p&gt;
    Capacity
    &lt;InputNumber @bind-Value="@Model.Capacity" /&gt;
&lt;/p&gt;</pre>
    </li>
    <li>
     
      Create another paragraph and embed the
     
     <strong class="source-inline">
      
       InputSelect
      
     </strong>
     
      component within it, binding it to the
     
     <strong class="source-inline">
      
       Model.Type
      
     </strong>
     
      property.
     
     
      Render the select options using values from the
     
     
      <strong class="source-inline">
       
        EventType
       
      </strong>
     
     
      
       enum:
      
     
     <pre class="source-code">
&lt;p&gt;
    &lt;InputSelect @bind-Value="@Model.Type"&gt;
        @foreach (var type in
            Enum.GetValues&lt;EventType&gt;())
        {
            &lt;option value="@type"&gt;@type&lt;/option&gt;
        }
    &lt;/InputSelect&gt;
&lt;/p&gt;</pre>
    </li>
    <li>
     
      In another paragraph, incorporate an
     
     <strong class="source-inline">
      
       InputRadioGroup
      
     </strong>
     
      component and bind it to the
     
     <strong class="source-inline">
      
       Model.Location
      
     </strong>
     
      property.
     
     
      Use
     
     <strong class="source-inline">
      
       EventVenues.All
      
     </strong>
     
      values and an
     
     <strong class="source-inline">
      
       InputRadio
      
     </strong>
     
      component to render each
     
     
      
       radio option:
      
     
     <pre class="source-code">
&lt;p&gt;
    &lt;InputRadioGroup @bind-Value="@Model.Location"&gt;
        @foreach (var venue in EventVenues.All)
        {
            &lt;InputRadio Value="@venue" /&gt;@venue
        }
    &lt;/InputRadioGroup&gt;
&lt;/p&gt;</pre>
    </li>
    <li>
     
      In a separate
     
     <a id="_idIndexMarker296">
     </a>
     
      paragraph, place an
     
     <strong class="source-inline">
      
       InputTextArea
      
     </strong>
     
      component and bind it to the
     
     
      <strong class="source-inline">
       
        Model.Description
       
      </strong>
     
     
      
       property:
      
     
     <pre class="source-code">
&lt;p&gt;
    &lt;InputTextArea @bind-Value="@Model.Description" /&gt;
&lt;/p&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-224">
    <a id="_idTextAnchor224">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In this recipe, we enhance the
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     component.
    
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block and update the
    
    <strong class="source-inline">
     
      Save()
     
    </strong>
    
     method, where, leveraging the
    
    <strong class="source-inline">
     
      Model.Json
     
    </strong>
    
     auto-property, we convert the entire
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     object to JSON and write out the result to the console, so we can peek at the state of the saved
    
    
     <strong class="source-inline">
      
       Model
      
     </strong>
    
    
     
      instance.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we shift to the
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     markup available in the markup of the
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     component.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we wrap the existing fields into organized paragraphs with
    
    <strong class="source-inline">
     
      &lt;p&gt;
     
    </strong>
    
     tags.
    
    
     We use the
    
    <strong class="source-inline">
     
      InputText
     
    </strong>
    
     component to render a text input element bound to the
    
    <strong class="source-inline">
     
      Model.Name
     
    </strong>
    
     property, allowing a user to set the name of an event.
    
    
     Next, with the
    
    <strong class="source-inline">
     
      EventDurationForm
     
    </strong>
    
     component, we encapsulate the setting of the event period, utilizing
    
    <strong class="source-inline">
     
      InputDate
     
    </strong>
    
     components for date entries.
    
    <strong class="source-inline">
     
      InputDate
     
    </strong>
    
     supports a variety of time formats and includes a built-in calendar picker – out of the box.
    
    
     We conclude the structurization of the form by wrapping the submit button in another set of
    
    <strong class="source-inline">
     
      &lt;
     
    </strong>
    
     <strong class="source-inline">
      
       p&gt;
      
     </strong>
    
    
     
      tags.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we introduce an
    
    <strong class="source-inline">
     
      InputCheckbox
     
    </strong>
    
     component in a new paragraph, binding it to the
    
    <strong class="source-inline">
     
      Model.IsActive
     
    </strong>
    
     property.
    
    <strong class="source-inline">
     
      InputCheckbox
     
    </strong>
    
     renders a checkbox input type that’s perfect for handling
    
    <strong class="source-inline">
     
      bool
     
    </strong>
    
     properties, so we allow the user to toggle the active status of
    
    
     
      the event.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we add an
    
    <strong class="source-inline">
     
      InputNumber
     
    </strong>
    
     component in another paragraph, linking it to the
    
    <strong class="source-inline">
     
      Model.Capacity
     
    </strong>
    
     property.
    
    <strong class="source-inline">
     
      InputNumber
     
    </strong>
    
     accepts any primitive numeric type, which makes it ideal for setting the maximum number of event participants.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we embed an
    
    <strong class="source-inline">
     
      InputSelect
     
    </strong>
    
     component within another paragraph and bind it to the
    
    <strong class="source-inline">
     
      Model.Type
     
    </strong>
    
     property to facilitate selecting the event type.
    
    <strong class="source-inline">
     
      InputSelect
     
    </strong>
    
     is a generic component, so you can easily cover a variety of objects within.
    
    
     However, remember that the
    
    <strong class="source-inline">
     
      select
     
    </strong>
    
     option
    
    <strong class="source-inline">
     
      value
     
    </strong>
    
     must be of a primitive type.
    
    
     In our form, we populate the drop-down menu by iterating over the
    
    <strong class="source-inline">
     
      EventType
     
    </strong>
    
     enum from the sample
    
    
     <strong class="source-inline">
      
       Data
      
     </strong>
    
    
     
      directory.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we allow the
    
    <a id="_idIndexMarker297">
    </a>
    
     user to choose the event venue.
    
    
     We render an
    
    <strong class="source-inline">
     
      InputRadioGroup
     
    </strong>
    
     component and bind it to the
    
    <strong class="source-inline">
     
      Model.Location
     
    </strong>
    
     property.
    
    
     We also render multiple
    
    <strong class="source-inline">
     
      InputRadio
     
    </strong>
    
     components, each representing a venue from the
    
    <strong class="source-inline">
     
      EventVenues.All
     
    </strong>
    
     sample collection.
    
    
     Blazor automatically scopes all
    
    <strong class="source-inline">
     
      InputRadio
     
    </strong>
    
     components to the nearest parent element but wrapping them inside
    
    <strong class="source-inline">
     
      InputRadioGroup
     
    </strong>
    
     exposes additional functionalities of the checkbox group and gives us
    
    
     
      more control.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we add an
    
    <strong class="source-inline">
     
      InputTextArea
     
    </strong>
    
     component within the final paragraph, providing a text area for the
    
    <strong class="source-inline">
     
      Model.Description
     
    </strong>
    
     property.
    
    <strong class="source-inline">
     
      InputTextArea
     
    </strong>
    
     generates an input of type
    
    <strong class="source-inline">
     
      textarea
     
    </strong>
    
     – ideal for longer descriptions, although it’s not a rich
    
    
     
      text editor.
     
    
   </p>
   <p>
    
     The form we’ve just built appears simple, but it renders fully functional, secured, and organized markup with little
    
    
     
      coding effort:
     
    
   </p>
   <div><div><img alt="Figure 6.1: Functional, secure, and structured form using only built-in input components" src="img/B22020_06_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.1: Functional, secure, and structured form using only built-in input components
    
   </p>
   <h1 id="_idParaDest-225">
    <a id="_idTextAnchor225">
    </a>
    
     Handling file uploads with a form
    
   </h1>
   <p>
    
     In this recipe, we dive into managing file uploads in Blazor applications.
    
    
     File uploading is crucial for
    
    <a id="_idIndexMarker298">
    </a>
    
     any modern web application that requires users to upload documents or images.
    
    
     The
    
    <strong class="source-inline">
     
      InputFile
     
    </strong>
    
     component simplifies the integration of file uploads with its simple but comprehensive API.
    
    
     Moreover, with a little additional coding, you
    
    <a id="_idIndexMarker299">
    </a>
    
     can enable
    
    <strong class="bold">
     
      drag-and-drop
     
    </strong>
    
     behavior for
    
    
     
      file uploads.
     
    
   </p>
   <p>
    
     Let’s add a simple form that allows users to upload a file representing an
    
    
     
      event cover.
     
    
   </p>
   <h2 id="_idParaDest-226">
    <a id="_idTextAnchor226">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we implement the form with file uploads, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter06
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe05
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       FileStorage
      
     </strong>
     
      from the
     
     <strong class="source-inline">
      
       Chapter06
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-227">
    <a id="_idTextAnchor227">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these
    
    <a id="_idIndexMarker300">
    </a>
    
     steps to enable file uploads in an
    
    
     
      interactive form:
     
    
   </p>
   <ol>
    <li>
     
      Open your application’s
     
     <strong class="source-inline">
      
       Program
      
     </strong>
     
      file and add the
     
     <strong class="source-inline">
      
       FileStorage
      
     </strong>
     
      service to the dependency
     
     
      
       injection container:
      
     
     <pre class="source-code">
builder.Services.AddTransient&lt;FileStorage&gt;();</pre>
    </li>
    <li>
     
      Create an
     
     <strong class="source-inline">
      
       EventCover
      
     </strong>
     
      class with a single
     
     <strong class="source-inline">
      
       File
      
     </strong>
     
      property of
     
     
      
       type
      
     
     
      <strong class="source-inline">
       
        IBrowserFile
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
public class EventCover
{
    public IBrowserFile File { get; set; }
}</pre>
    </li>
    <li>
     
      Create a new routable
     
     <strong class="source-inline">
      
       CoverUploader
      
     </strong>
     
      component that renders in the
     
     
      <strong class="source-inline">
       
        InteractiveWebAssembly
       
      </strong>
     
     
      
       mode:
      
     
     <pre class="source-code">
@page "/ch06r05"
@rendermode InteractiveWebAssembly</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       CoverUploader
      
     </strong>
     
      , inject the
     
     <strong class="source-inline">
      
       FileStorage
      
     </strong>
     
      service and initialize a
     
     <strong class="source-inline">
      
       Model
      
     </strong>
     
      variable of
     
     
      
       type
      
     
     
      <strong class="source-inline">
       
        EventCover
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
[Inject] private FileStorage Storage { get; init; }
public EventCover Model = new();</pre>
    </li>
    <li>
     
      Still within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement a
     
     <strong class="source-inline">
      
       FileChanged()
      
     </strong>
     
      method that takes the
     
     <strong class="source-inline">
      
       InputFileChangeEventArgs
      
     </strong>
     
      parameter and assigns the file data
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        Model.File
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
private void FileChanged(InputFileChangeEventArgs e)
    =&gt; Model.File = e.File;</pre>
    </li>
    <li>
     
      Lastly, in the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement a
     
     <strong class="source-inline">
      
       SaveAsync()
      
     </strong>
     
      method that initializes a file upload from the
     
     <strong class="source-inline">
      
       Model
      
     </strong>
     
      instance, using the
     
     
      <strong class="source-inline">
       
        FileStorage
       
      </strong>
     
     
      
       service:
      
     
     <pre class="source-code">
private Task SaveAsync()
{
    using var stream = Model.File.OpenReadStream();
    return Storage.UploadAsync(stream);
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       CoverUploader
      
     </strong>
     
      markup, add an
     
     <strong class="source-inline">
      
       EditForm
      
     </strong>
     
      component, bind it to the
     
     <strong class="source-inline">
      
       Model
      
     </strong>
     
      instance, and
     
     <a id="_idIndexMarker301">
     </a>
     
      attach the
     
     <strong class="source-inline">
      
       SaveAsync()
      
     </strong>
     
      method to the
     
     <strong class="source-inline">
      
       OnSubmit
      
     </strong>
     
      
       form callback:
      
     
     <pre class="source-code">
&lt;EditForm FormName="cover-upload"
          Model="@Model"
          OnSubmit="@SaveAsync"&gt;
&lt;/EditForm&gt;</pre>
    </li>
    <li>
     
      Inside the
     
     <strong class="source-inline">
      
       EditForm
      
     </strong>
     
      markup, add an
     
     <strong class="source-inline">
      
       InputFile
      
     </strong>
     
      component that invokes the
     
     <strong class="source-inline">
      
       FileChanged()
      
     </strong>
     
      method with its
     
     <strong class="source-inline">
      
       OnChange
      
     </strong>
     
      event and a simple submit button.
     
     
      Wrap both elements
     
     
      
       in paragraphs:
      
     
     <pre class="source-code">
&lt;p&gt;&lt;InputFile OnChange="FileChanged" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;button type="submit"&gt;Save&lt;/button&gt;&lt;/p&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-228">
    <a id="_idTextAnchor228">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to the application’s
    
    <strong class="source-inline">
     
      Program
     
    </strong>
    
     file and register the
    
    <strong class="source-inline">
     
      FileStorage
     
    </strong>
    
     service into the dependency injection container.
    
    <strong class="source-inline">
     
      FileStorage
     
    </strong>
    
     is a fake service that pretends to upload a file to the storage of your choice.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we create an
    
    <strong class="source-inline">
     
      EventCover
     
    </strong>
    
     class with a single
    
    <strong class="source-inline">
     
      File
     
    </strong>
    
     property of type
    
    <strong class="source-inline">
     
      IBrowserFile
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      IBrowserFile
     
    </strong>
    
     interface represents a file received from the user, encapsulating properties such as the file’s name, content type, size, and methods to access the
    
    
     
      file’s content.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we create a routable
    
    <strong class="source-inline">
     
      CoverUploader
     
    </strong>
    
     component and set it to render in
    
    <strong class="source-inline">
     
      InteractiveWebAssembly
     
    </strong>
    
     mode to enable interactivity on our form.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , within the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of the
    
    <strong class="source-inline">
     
      CoverUploader
     
    </strong>
    
     component, we inject the
    
    <strong class="source-inline">
     
      FileStorage
     
    </strong>
    
     service to utilize its API for managing incoming files.
    
    
     We then initialize a
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     object of type
    
    <strong class="source-inline">
     
      EventCover
     
    </strong>
    
     , which forms the backbone of our form.
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , within the same
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block, we implement a
    
    <strong class="source-inline">
     
      FileChanged()
     
    </strong>
    
     method that handles
    
    <strong class="source-inline">
     
      InputFileChangeEventArgs
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      InputFileChangeEventArgs
     
    </strong>
    
     object contains an
    
    <strong class="source-inline">
     
      IBrowserFile
     
    </strong>
    
     payload, which we assign to the
    
    <strong class="source-inline">
     
      File
     
    </strong>
    
     property of our
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     instance, capturing the user-selected file.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we add a
    
    <strong class="source-inline">
     
      SaveAsync()
     
    </strong>
    
     method where we read the
    
    <strong class="source-inline">
     
      File
     
    </strong>
    
     value into a stream and use the
    
    <strong class="source-inline">
     
      FileStorage.UploadAsync()
     
    </strong>
    
     method to upload the file bytes to our selected storage.
    
    
     We
    
    <a id="_idIndexMarker302">
    </a>
    
     leverage the
    
    <strong class="source-inline">
     
      using
     
    </strong>
    
     keyword to ensure efficient resource management and no memory leaks.
    
    
     The
    
    <strong class="source-inline">
     
      using
     
    </strong>
    
     keyword, inside a method, works together with an
    
    <strong class="source-inline">
     
      IDisposable
     
    </strong>
    
     object and creates a temporary, disposable scope that automatically disposes of the attached object when the method
    
    
     
      execution completes.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we set up the markup for
    
    <strong class="source-inline">
     
      CoverUploader
     
    </strong>
    
     using the
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     component.
    
    
     We give the form a unique name, bind it to our
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     instance, and assign the
    
    <strong class="source-inline">
     
      SaveAsync()
     
    </strong>
    
     method as the submission fallback.
    
    
     Finally, in
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we build the body of the
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     component.
    
    
     We incorporate the
    
    <strong class="source-inline">
     
      InputFile
     
    </strong>
    
     component and attach the
    
    <strong class="source-inline">
     
      FileChanged()
     
    </strong>
    
     method to its
    
    <strong class="source-inline">
     
      OnChange
     
    </strong>
    
     callback.
    
    
     The
    
    <strong class="source-inline">
     
      OnChange
     
    </strong>
    
     event seamlessly integrates with the
    
    <strong class="source-inline">
     
      FileChanged()
     
    </strong>
    
     logic in our
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block, handling the file selection initiated by the user.
    
    
     We also add a simple submit button that activates the form’s
    
    
     <strong class="source-inline">
      
       OnSubmit
      
     </strong>
    
    
     
      callback.
     
    
   </p>
   <p>
    
     At the end, your form should look similar
    
    
     
      to mine:
     
    
   </p>
   <div><div><img alt="Figure 6.2: Form containing the InputFile component and a submit button" src="img/B22020_06_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.2: Form containing the InputFile component and a submit button
    
   </p>
   <p>
    
     What about the drag-and-drop feature?
    
    
     Actually, the
    
    <strong class="source-inline">
     
      InputFile
     
    </strong>
    
     component inherently
    
    <a id="_idIndexMarker303">
    </a>
    
     supports drag-and-drop functionality!
    
    
     Even though it looks like a button,
    
    <strong class="source-inline">
     
      InputFile
     
    </strong>
    
     renders an
    
    <strong class="source-inline">
     
      input
     
    </strong>
    
     area that has the drag-and-drop feature already enabled – you don’t need to add any additional code or any additional attributes.
    
    
     You may want to add additional styling to make
    
    <strong class="source-inline">
     
      InputFile
     
    </strong>
    
     look like a drop zone, but the functionality is available out of
    
    
     
      the box.
     
    
   </p>
   <p>
    
     Lastly, we didn’t implement any file type or size validation for the uploading (we will explore validation in
    
    <a href="B22020_07.xhtml#_idTextAnchor236">
     
      <em class="italic">
       
        Chapter 7
       
      </em>
     
    </a>
    
     ).
    
    
     For the enterprise-ready application, you must consider putting such boundaries in place to protect your infrastructure as well as
    
    
     
      server resources.
     
    
   </p>
   <h2 id="_idParaDest-229">
    <a id="_idTextAnchor229">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     What if you want to support file uploads and leverage the newest SSR render mode?
    
    
     In the SSR mode, Blazor pre-renders components on the server and serves only a static markup without any interactivity, so you can’t intercept the file the user tries to upload.
    
    
     However, if we consider
    
    <a id="_idIndexMarker304">
    </a>
    
     enabling enhanced navigation and leveraging the
    
    <strong class="source-inline">
     
      enctype
     
    </strong>
    
     attribute, uploading files will work even in the SSR mode.
    
    
     The
    
    <strong class="source-inline">
     
      enctype
     
    </strong>
    
     HTML attribute specifies how the browser should encode the form data when submitting it to
    
    
     
      the server.
     
    
   </p>
   <p>
    
     Let’s modify our existing interactive form to render in the SSR mode and still allow users to upload
    
    
     
      a file:
     
    
   </p>
   <ol>
    <li>
     
      Update the
     
     <strong class="source-inline">
      
       EventCover
      
     </strong>
     
      class by changing the
     
     <strong class="source-inline">
      
       File
      
     </strong>
     
      property type from
     
     <strong class="source-inline">
      
       IBrowserFile
      
     </strong>
     
      to
     
     <strong class="source-inline">
      
       IFormFile
      
     </strong>
     
      .
     
     
      That’s part of the
     
     <strong class="source-inline">
      
       Microsoft.AspNetCore.Http.Features
      
     </strong>
     
      package, so you may need to add it to your
     
     
      
       project beforehand:
      
     
     <pre class="source-code">
public class EventCover
{
    public IFormFile File { get; set; }
}</pre>
    </li>
    <li>
     
      Next, adjust the
     
     <strong class="source-inline">
      
       CoverUploader
      
     </strong>
     
      component to render in SSR mode by removing the
     
     <strong class="source-inline">
      
       @
      
     </strong>
     
      <strong class="source-inline">
       
        renderMode
       
      </strong>
     
     
      
       directive.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of the
     
     <strong class="source-inline">
      
       CoverUploader
      
     </strong>
     
      component, transform
     
     <strong class="source-inline">
      
       Model
      
     </strong>
     
      into a property
     
     <a id="_idIndexMarker305">
     </a>
     
      and decorate it with
     
     <strong class="source-inline">
      
       SupplyParameterFromForm
      
     </strong>
     
      to enable automatic binding of the
     
     
      
       form data:
      
     
     <pre class="source-code">
[SupplyParameterFromForm]
public EventCover Model { get; set; }</pre>
    </li>
    <li>
     
      Still within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, override the
     
     <strong class="source-inline">
      
       OnInitialized()
      
     </strong>
     
      lifecycle method to adhere to the SSR form binding pattern and remove the
     
     <strong class="source-inline">
      
       FileChanged()
      
     </strong>
     
      method, as we won’t need
     
     
      
       it anymore:
      
     
     <pre class="source-code">
protected override void OnInitialized()
    =&gt; Model ??= new();</pre>
    </li>
    <li>
     
      Within the
     
     <strong class="source-inline">
      
       CoverUploader
      
     </strong>
     
      markup, enhance the
     
     <strong class="source-inline">
      
       EditForm
      
     </strong>
     
      component by adding the
     
     <strong class="source-inline">
      
       Enhance
      
     </strong>
     
      attribute, which activates enhanced navigation, and include the
     
     <strong class="source-inline">
      
       enctype
      
     </strong>
     
      attribute with the
     
     
      
       value
      
     
     
      <strong class="source-inline">
       
        multipart/form-data
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
&lt;EditForm FormName="cover-upload"
          Model="@Model"
          OnSubmit="@SaveAsync"
          Enhance
          enctype="multipart/form-data"&gt;
    @* ... *@
&lt;/EditForm&gt;</pre>
    </li>
    <li>
     
      Lastly, replace the
     
     <a id="_idIndexMarker306">
     </a>
     
      assignment of the
     
     <strong class="source-inline">
      
       OnChange
      
     </strong>
     
      callback on the
     
     <strong class="source-inline">
      
       InputFile
      
     </strong>
     
      component with the
     
     <strong class="source-inline">
      
       name
      
     </strong>
     
      HTML attribute and set its value to match the
     
     <strong class="source-inline">
      
       Model.File
      
     </strong>
     
      property so Blazor knows how to bind the selected file directly from
     
     
      
       the form:
      
     
     <pre class="source-code">
&lt;p&gt;&lt;InputFile name="Model.File" /&gt;&lt;/p&gt;</pre>
    </li>
   </ol>
   <h1 id="_idParaDest-230">
    <a id="_idTextAnchor230">
    </a>
    
     Securing a form with an anti-forgery token
    
   </h1>
   <p>
    
     In this recipe, we explore an essential aspect of web security — protecting your application
    
    <a id="_idIndexMarker307">
    </a>
    
     from CSRF attacks.
    
    
     CSRF attacks
    
    <a id="_idIndexMarker308">
    </a>
    
     exploit the trust between our app and a user’s browser, making the browser perform unwanted actions using the user’s identity.
    
    
     An
    
    <strong class="bold">
     
      anti-forgery token
     
    </strong>
    
     , also known as a CSRF token, is a crucial security measure you
    
    <a id="_idIndexMarker309">
    </a>
    
     must use to ensure that the requests sent to a server are genuine and originated from a legitimate user, not an attacker.
    
    
     Embedding an anti-forgery token in your forms practically creates a unique key sent with each post request.
    
    
     The server checks this token upon receiving a request; if the token is not present or is incorrect, the request is rejected, thus preventing
    
    
     
      unauthorized actions.
     
    
   </p>
   <p>
    
     Let’s secure our event creation form with the anti-forgery token implementation offered
    
    
     
      in Blazor.
     
    
   </p>
   <h2 id="_idParaDest-231">
    <a id="_idTextAnchor231">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we explore securing a form with the anti-forgery token, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter06
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe06
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Models.cs
      
     </strong>
     
      file from the
     
     <strong class="source-inline">
      
       Chapter06
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-232">
    <a id="_idTextAnchor232">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these instructions to secure your form with the
    
    
     
      anti-forgery token:
     
    
   </p>
   <ol>
    <li>
     
      On the
     
     <a id="_idIndexMarker310">
     </a>
     
      server side of your solution, navigate to the
     
     <strong class="source-inline">
      
       Program
      
     </strong>
     
      file and, in the middleware configuration area, register
     
     <a id="_idIndexMarker311">
     </a>
     
      the
     
     
      
       anti-forgery middleware:
      
     
     <pre class="source-code">
var app = builder.Build();
//...
app.UseStaticFiles();
app.UseAntiforgery();
//...
app.Run();</pre>
    </li>
    <li>
     
      Create a routable
     
     
      <strong class="source-inline">
       
        EventManager
       
      </strong>
     
     
      
       component:
      
     
     <pre class="source-code">
@page "/ch06r06"</pre>
    </li>
    <li>
     
      Inside the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of the
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      component, declare a
     
     <strong class="source-inline">
      
       Model
      
     </strong>
     
      object of type
     
     <strong class="source-inline">
      
       Event
      
     </strong>
     
      and decorate it with the
     
     
      <strong class="source-inline">
       
        SupplyParameterFromForm
       
      </strong>
     
     
      
       attribute:
      
     
     <pre class="source-code">
[SupplyParameterFromForm]
protected Event Model { get; set; }</pre>
    </li>
    <li>
     
      Still within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      , override the
     
     <strong class="source-inline">
      
       OnInitialized()
      
     </strong>
     
      lifecycle method to conditionally initialize the
     
     <strong class="source-inline">
      
       Model
      
     </strong>
     
      instance if it is not already set and implement a
     
     <strong class="source-inline">
      
       Save()
      
     </strong>
     
      method to simulate the process of saving the
     
     
      
       form data:
      
     
     <pre class="source-code">
protected override void OnInitialized()
    =&gt; Model ??= new();
private void Save()
    =&gt; Console.WriteLine($"Saved {Model.Name}.");</pre>
    </li>
    <li>
     
      In the markup section of the
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      component, construct a standard HTML form with a unique name that triggers the
     
     <strong class="source-inline">
      
       Save()
      
     </strong>
     
      method
     
     
      
       when submitted:
      
     
     <pre class="source-code">
&lt;form method="post"
      @onsubmit="@Save"
      @formname="event-form"&gt;
&lt;/form&gt;</pre>
    </li>
    <li>
     
      Within the
     
     <strong class="source-inline">
      
       &lt;form&gt;
      
     </strong>
     
      area, include a text input field linked to the
     
     <strong class="source-inline">
      
       Model.Name
      
     </strong>
     
      property
     
     <a id="_idIndexMarker312">
     </a>
     
      and a submit button.
     
     
      Most
     
     <a id="_idIndexMarker313">
     </a>
     
      crucially, embed an
     
     <strong class="source-inline">
      
       AntiforgeryToken
      
     </strong>
     
      component within
     
     
      
       the form:
      
     
     <pre class="source-code">
&lt;AntiforgeryToken /&gt;
&lt;label&gt;
    Name: &lt;InputText @bind-Value="@Model.Name" /&gt;
&lt;/label&gt;
&lt;button type="submit"&gt;Save&lt;/button&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-233">
    <a id="_idTextAnchor233">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      Program
     
    </strong>
    
     file of the server-side project to enable anti-forgery security.
    
    
     We leverage the
    
    <strong class="source-inline">
     
      app.UseAntiforgery()
     
    </strong>
    
     extension method within the middleware area.
    
    
     The order of middleware registration is crucial; you must position the anti-forgery middleware thoughtfully based on other middleware in use.
    
    
     If your application includes authentication and authorization, ensure
    
    <strong class="source-inline">
     
      app.UseAntiforgery()
     
    </strong>
    
     is placed after
    
    <strong class="source-inline">
     
      app.UseAuthentication()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      app.UseAuthorization()
     
    </strong>
    
     .
    
    
     If you have routing configured, place anti-forgery middleware after
    
    <strong class="source-inline">
     
      app.UseRouting()
     
    </strong>
    
     , but before
    
    <strong class="source-inline">
     
      app.UseEndpoints()
     
    </strong>
    
     if you register
    
    
     
      endpoint middleware.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we create a routable
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     component and include the necessary assembly reference with the
    
    <strong class="source-inline">
     
      @using
     
    </strong>
    
     directive to access the
    
    <strong class="source-inline">
     
      Event
     
    </strong>
    
     type.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , within the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of the
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     component, we declare a
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     property of type
    
    <strong class="source-inline">
     
      Event
     
    </strong>
    
     to support our form.
    
    
     We leverage the
    
    <strong class="source-inline">
     
      SupplyParameterFromForm
     
    </strong>
    
     attribute to enable an automatic data binding between the
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     and form fields.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we override the
    
    <strong class="source-inline">
     
      OnInitialized()
     
    </strong>
    
     method to conditionally initialize the
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     instance if it’s still empty.
    
    
     We also implement a
    
    <strong class="source-inline">
     
      Save()
     
    </strong>
    
     method as a placeholder to simulate saving changes to the form.
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we move
    
    <a id="_idIndexMarker314">
    </a>
    
     to the markup of the
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     component.
    
    
     We construct a standard HTML form, using
    
    <strong class="source-inline">
     
      &lt;form&gt;
     
    </strong>
    
     tags, that
    
    <a id="_idIndexMarker315">
    </a>
    
     triggers the
    
    <strong class="source-inline">
     
      Save()
     
    </strong>
    
     method upon submission.
    
    
     In Blazor, each form must have a unique name, so we use the
    
    <strong class="source-inline">
     
      @formname
     
    </strong>
    
     attribute and name ours
    
    <strong class="source-inline">
     
      event-form
     
    </strong>
    
     .
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we implement the form body.
    
    
     First, we embed the
    
    <strong class="source-inline">
     
      AntiforgeryToken
     
    </strong>
    
     component.
    
    
     Next, we add a text input field for the user to provide the event name and bind it to the
    
    <strong class="source-inline">
     
      Model.Name
     
    </strong>
    
     property.
    
    
     Finally, we include a
    
    <strong class="source-inline">
     
      Save
     
    </strong>
    
     button to enable submitting
    
    
     
      the form.
     
    
   </p>
   <p>
    
     With the
    
    <strong class="source-inline">
     
      AntiforgeryToken
     
    </strong>
    
     component in place, Blazor generates a hidden form field containing the anti-forgery token.
    
    
     We’ve embedded the
    
    <strong class="source-inline">
     
      AntiforgeryToken
     
    </strong>
    
     instance at the top of the form, but as it’s a hidden field, you can place it anywhere, as long as it remains part of the form.
    
    
     The token itself is part of the DOM, so you can inspect its value using your browser’s
    
    
     
      development tools:
     
    
   </p>
   <div><div><img alt="Figure 6.3: Inspecting the anti-forgery token generated as part of the from markup" src="img/B22020_06_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.3: Inspecting the anti-forgery token generated as part of the from markup
    
   </p>
   <h2 id="_idParaDest-234">
    <a id="_idTextAnchor234">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     I recommend using the
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     component for all your forms due to its native Blazor integration and extensive API.
    
    
     So, why have we not covered adding the anti-forgery token to the
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     markup?
    
    
     The reason is straightforward:
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     comes with built-in anti-forgery support.
    
    
     Blazor automatically secures the
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     instance, saving you the hassle of explicitly handling
    
    
     
      CSRF protection.
     
    
   </p>
   <p>
    
     Furthermore, we entirely skipped the implementation of anti-forgery tokens for client-side applications.
    
    
     Blazor WebAssembly apps run entirely in the browser and do not have a server-side
    
    <a id="_idIndexMarker316">
    </a>
    
     processing pipeline where you would
    
    <a id="_idIndexMarker317">
    </a>
    
     typically configure a middleware such as
    
    <strong class="source-inline">
     
      app.UseAntiforgery()
     
    </strong>
    
     .
    
    
     If your Blazor WebAssembly app interacts with server-side APIs, you should manage anti-forgery at the API level.
    
    
     However, if you
    
    <a id="_idIndexMarker318">
    </a>
    
     already use
    
    <strong class="bold">
     
      token-based authentication
     
    </strong>
    
     to secure communication, anti-forgery tokens are generally not necessary.
    
    
     Token-based authentication, by its nature, mitigates the risks associated with CSRF, making additional anti-forgery tokens redundant.
    
    
     We will explore authentication and authorization further in
    
    <a href="B22020_08.xhtml#_idTextAnchor273">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-235">
    <a id="_idTextAnchor235">
    </a>
    
     See also
    
   </h2>
   <p>
    
     If you’d like to
    
    <a id="_idIndexMarker319">
    </a>
    
     learn more about token-based authentication, you can check
    
    
     
      this resource:
     
    
   </p>
   <p>
    <a href="https://learn.microsoft.com/en-us/xandr/digital-platform-api/token-based-api-authentication">
     
      
       https://learn.microsoft.com/en-us/xandr/digital-platform-api/token-based-api-authentication
      
     
    </a>
   </p>
  </div>
 </body></html>