<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer015">
<h1 id="_idParaDest-35"><em class="italic"><a id="_idTextAnchor034"/>Chapter 2</em>: Evolution of Multithreaded Programming in .NET</h1>
<p>As .NET and C# have evolved over the last 20 years, new and innovative approaches to multithreaded programming have been introduced. C# has added new language features to support asynchronous programming, and .NET Framework and .NET Core have added new types to support the languages. The most impactful improvements were introduced with C# 5 and .NET Framework 4.0 when Microsoft added the <strong class="bold">Task Parallel Library</strong> (<strong class="bold">TPL</strong>), thread-safe collections, and the <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> keywords.</p>
<p>This chapter will introduce concepts and features that will be explored in greater depth in subsequent chapters. These<a id="_idIndexMarker063"/> concepts<a id="_idIndexMarker064"/> include the .NET <strong class="bold">thread pool</strong>, asynchronous programming with <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong>, concurrent collections, and parallelism. We will start by discovering when and why threading features were added to .NET and C#. Then, we will create some practical examples of how to use the new concepts. Finally, we will wrap up the chapter by discussing when it makes sense to use these new features in your own projects. It is important to select the best tool for every real-world scenario.</p>
<p>In this chapter, you will learn about the following:</p>
<ul>
<li>.NET threading through the years</li>
<li>Beyond threading basics</li>
<li>Introduction to parallelism</li>
<li>Introduction to concurrency</li>
<li>Basics of <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong></li>
<li>Choosing the right path forward</li>
</ul>
<p>By the end of this chapter, you will have learned how your options have expanded when selecting how to approach concurrency in your .NET applications.</p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Technical requirements</h1>
<p>To follow along with the examples in this chapter, the following software is recommended for Windows users:</p>
<ul>
<li>Visual Studio 2022 version 17.0 or later.</li>
<li>.NET 6.</li>
<li>To use the WorkingWithTimers project, you will need to install the Visual Studio workload for <strong class="bold">.NET desktop development</strong>.</li>
</ul>
<p>While these are recommended, if you have .NET 6 installed, you can use your preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later, JetBrains Rider, or Visual Studio Code will work just as well.</p>
<p>All the code examples for this chapter can be found on GitHub at <a href="">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter02</a>.</p>
<p>Let’s start the chapter with a .NET and C# history lesson.</p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>.NET threading through the years</h1>
<p>Working with threads in .NET and C# has undergone much evolution since .NET Framework 1.0 and C# 1.0 were introduced in 2002. Most of the concepts discussed in <a href="B18552_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, regarding the <strong class="source-inline">System.Threading.Thread</strong> objects have been available since those early days of .NET. While the <strong class="source-inline">Thread</strong> object is still available in .NET 6 and can be useful for simple scenarios, there are more elegant and modern solutions that are available today.</p>
<p>This section will highlight when the most impactful parallelism and concurrency features were added. We will begin by skipping ahead 8 years to 2010.</p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>C# 4 and .NET Framework 4.0</h2>
<p>In 2010, Microsoft<a id="_idIndexMarker065"/> released Visual Studio 2010 alongside C# 4 and .NET Framework 4.0. While some earlier language and framework features <a id="_idIndexMarker066"/>such <a id="_idIndexMarker067"/>as <strong class="bold">generics</strong>, <strong class="bold">lambda expressions</strong>, and <strong class="bold">anonymous methods</strong> would <a id="_idIndexMarker068"/>help facilitate later threading features, these 2010 releases were the most significant for threading since 2002. .NET Framework included the following features that will be explored<a id="_idIndexMarker069"/> in more detail in the subsequent sections and chapters:</p>
<ul>
<li><strong class="bold">Thread-safe collections</strong>: This <a id="_idIndexMarker070"/>collection was added to the <strong class="source-inline">System.Collections.Concurrent</strong> namespace to provide safe access to collections of data in multithreaded code.</li>
<li><strong class="bold">Parallel class</strong>: This<a id="_idIndexMarker071"/> provided support for parallel loops via <strong class="source-inline">Parallel.For</strong> and <strong class="source-inline">Parallel.ForEach</strong> and for invoking parallel operations with <strong class="source-inline">Parallel.Invoke</strong>.</li>
<li><strong class="bold">Parallel LINQ</strong> (<strong class="bold">PLINQ</strong>): This <a id="_idIndexMarker072"/>exposed a parallel implementation of the LINQ operations with extensions such as <strong class="source-inline">AsParallel</strong>, <strong class="source-inline">WithCancellation</strong>, and <strong class="source-inline">WithDegreeOfParallelism</strong>.</li>
</ul>
<p>We will cover these features in the <em class="italic">Introduction to concurrency</em> and <em class="italic">Introduction to parallelism</em> sections. Next, we will learn about the important threading features that were included in .NET and C# two years later.</p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>C# 5 and 6 and .NET Framework 4.5.x</h2>
<p>In 2012, Microsoft released<a id="_idIndexMarker073"/> what could be <a id="_idIndexMarker074"/>considered the most important feature for modern multithreaded programming with .NET: asynchronous programming with <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong>. The <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> keywords were added to C# 5 in the same release when .NET Framework 4.5 added the TPL. The centerpiece of the TPL was the <strong class="source-inline">Task</strong> class in the new <strong class="source-inline">System.Threading.Tasks</strong> namespace. </p>
<p>The <strong class="source-inline">Task</strong> object returns from an <strong class="source-inline">async</strong> operation, providing a way for developers to check the status of the operation or wait for its completion. The work of an <strong class="source-inline">async</strong> task is performed on a background thread on the thread pool, rather than in the main thread. We will learn more about thread pools in the <em class="italic">Beyond threading basics</em> section. The basics of the TPL will be discussed in the <em class="italic">Basics of async and await</em> section of this chapter and in more depth in <a href="B18552_05_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 5</em></a>.</p>
<p>Some tooling and language features related to async programming were added in the following years. In 2013, .NET Framework 4.5.1 was released. This release corresponded to the release of Visual Studio 2013, which added async debugging features to the <strong class="bold">Call Stack</strong> and <strong class="bold">Tasks</strong> windows. The C# 6 and Visual Studio 2015 releases added the ability for <a id="_idIndexMarker075"/>developers to await <a id="_idIndexMarker076"/>asynchronous operations in the <strong class="source-inline">catch</strong> and <strong class="source-inline">finally</strong> blocks of exception handlers.</p>
<p>The next features came in 2017 with Microsoft’s continued shift from .NET Framework to .NET Core.</p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>C# 7.x and .NET Core 2.0</h2>
<p>The<a id="_idIndexMarker077"/> second major version of .NET Core released by the .NET team included the new <strong class="source-inline">ValueTask</strong> and <strong class="source-inline">ValueTask&lt;TResult&gt;</strong> types. A <strong class="source-inline">ValueTask</strong> type is a structure that wraps a <strong class="source-inline">Task</strong> or an <strong class="source-inline">IValueTaskSource</strong> instance and includes some additional fields. It is only available when using C# 7.0 or later. The <strong class="source-inline">ValueTask</strong> type was added because many async operations, in practice, complete synchronously but still incur the overhead of allocating a <strong class="source-inline">Task</strong> instance to return to the caller. In these cases, performance can be improved by replacing <strong class="source-inline">Task</strong> with <strong class="source-inline">ValueTask</strong>, which does not incur any allocation when completing its work synchronously. To read more about the motivation behind the introduction of <strong class="source-inline">ValueTask</strong> and when to use it, you can read the following blog post by Stephen Toub of the .NET team: <a href="">https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/</a>. </p>
<p class="callout-heading">Note</p>
<p class="callout">If you are not familiar with Stephen Toub, he is a Partner Software Engineer for Microsoft and works as a developer on the .NET Team. His work on the .NET team was key in bringing <strong class="source-inline">async</strong>, <strong class="source-inline">await</strong>, and the TPL to the .NET developer community. You can read some of his other articles on the .NET Parallel Programming blog at <a href="">https://devblogs.microsoft.com/pfxteam/author/toub/</a>. </p>
<p>C# 7.0 also<a id="_idIndexMarker078"/> introduced <strong class="bold">discards</strong> to the language. A discard in C# is represented by a single underscore character (<strong class="source-inline">_</strong>) to replace an intentionally unused variable. A <strong class="bold">standalone discard</strong> replaces<a id="_idIndexMarker079"/> the need for a declared variable to hold the <strong class="source-inline">Task</strong> instance returned by an async call. By using a discard in this scenario, it signals to the compiler explicitly that you want to ignore the returned <strong class="source-inline">Task</strong> instance. Discards can be used as placeholders for variables in other scenarios, too. Using discards can make the intent of <a id="_idIndexMarker080"/>your code clearer and, in some cases, reduce memory allocation. You can read more about their use on the Microsoft Docs website at <a href="">https://docs.microsoft.com/dotnet/csharp/fundamentals/functional/discards</a>. </p>
<p>Later in 2017, C# 7.1 was released, adding a feature of note for async programming: the ability to declare the <strong class="source-inline">Main</strong> method of a class as async. This made it possible to await other async methods directly from the <strong class="source-inline">Main</strong> method.</p>
<p>The next async features of note came along in 2019 with C# 8.</p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>C# 8 and .NET Core 3.0</h2>
<p>When C# 8 and .NET Core 3.0 <a id="_idIndexMarker081"/>were released in 2019, several languages and .NET features were added to support the new <strong class="bold">async streams</strong> feature. As<a id="_idIndexMarker082"/> the name implies, async streams allow developers to use the new <strong class="source-inline">IAsyncEnumerable</strong> type to provide a streaming source of asynchronous data.</p>
<p>Let’s examine a code snippet that uses <strong class="source-inline">IAsyncEnumerable</strong>:</p>
<pre class="source-code">public async IAsyncEnumerable&lt;Order&gt; </pre>
<pre class="source-code">    GetLargeOrdersForCustomerAsync(int custId)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    await foreach (var order in </pre>
<pre class="source-code">        GetOrdersByCustomerAsync(custId))</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        if (order.Items.Count &gt; 10) yield return order;</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">}</pre>
<p>In this example, the new <strong class="source-inline">await foreach</strong> language feature is used to call an async method to get all the orders for a customer. It then uses a <strong class="source-inline">yield return</strong> operation to return each <strong class="source-inline">order</strong> object with more than 10 items via the <strong class="source-inline">IAsyncEnumerable</strong> type as it is processed. We will cover some more real-world scenarios of using <strong class="source-inline">IAsyncEnumerable</strong> in <a href="B18552_05_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 5</em></a>.</p>
<p>The <a id="_idIndexMarker083"/>other async feature added in C# 8 was the <strong class="source-inline">System.IAsyncDisposable</strong> interface. When implementing <strong class="source-inline">IAsyncDisposable</strong>, your class must implement a parameterless <strong class="source-inline">DisposeAsync</strong> method. If your class consumes managed resources that implement <strong class="source-inline">IAsyncDisposable</strong>, and they cannot be disposed of in line with an <strong class="source-inline">async using</strong> block, you should implement <strong class="source-inline">IAsyncDisposable</strong> and clean up these resources in a protected <strong class="source-inline">DisposeAsyncCore</strong> method. For a comprehensive example that uses both <strong class="source-inline">IDisposable</strong> and <strong class="source-inline">IAsyncDisposable</strong>, you can review the Microsoft Docs example at <a href="">https://docs.microsoft.com/dotnet/standard/garbage-collection/implementing-disposeasync#implement-both-dispose-and-async-dispose-patterns</a>. </p>
<p>This brings us to the most recent releases of C# and .NET. Let’s review what’s new for async developers in these 2021 releases.</p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>C# 10 and .NET 6</h2>
<p>.NET 6 was<a id="_idIndexMarker084"/> released in November 2021 along with C# 10. One of the new features in .NET 6 was the ability of <strong class="source-inline">System.Text.Json</strong> to serialize and deserialize an <strong class="source-inline">IAsyncEnumerable</strong> type. Prior to .NET 6, a serialized <strong class="source-inline">IAsyncEnumerable</strong> type would contain an empty JSON object. This is considered a breaking change in .NET 6, but it is a change for the better. The primary motivation behind the change was to support <strong class="source-inline">IAsyncEnumerable&lt;T&gt;</strong> responses in the ASP.NET Core MVC controller methods.</p>
<p>The other .NET 6 feature of note for async developers is that the C# project templates in Visual Studio 2021 were modernized to leverage several recent language features, including the <strong class="source-inline">async Main</strong> method available in C# 7.1 and later. The .NET team blogged about these updated templates when .NET 6 release candidate 2 was released in October 2021: <a href="">https://devblogs.microsoft.com/dotnet/announcing-net-6-release-candidate-2/#net-sdk-c-project-templates-modernized</a>.</p>
<p>This should give you an idea of when each of the significant threading features was added to C# and .NET, and it sets the stage for the upcoming sections of this chapter, where we will cover some of the basics of parallel programming and concurrency. Let’s begin by looking at some more features of threading, starting with the .NET thread pool.</p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/>Beyond threading basics</h1>
<p>Before we introduce parallel programming, concurrency, and async programming with .NET and C#, we have a few more threading concepts to cover. The most important of these is the .NET managed thread pool, which is used by awaited method calls that execute asynchronously in C#.</p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Managed thread pool</h2>
<p>The <strong class="source-inline">ThreadPool</strong> class <a id="_idIndexMarker085"/>in the <strong class="source-inline">System.Threading</strong> namespace has been part of .NET since the beginning. It provides developers with a pool of worker threads that they can leverage to perform tasks in the background. In fact, that is one of the key characteristics of thread pool threads. They are background threads that run at the default priority. When one of these threads completes its task, it is returned to the pool of available threads to await its next task. You can queue as many tasks to the thread pool as the available memory will support, but the number of active threads is limited by the number that the operating system can allocate to your application, based on the processor capacity and other running processes.</p>
<p>If you were to use the <strong class="source-inline">ThreadPool</strong> class in a .NET 6 application, you would typically do so through the TPL, but let’s explore how it can be used directly with <strong class="source-inline">ThreadPool.QueueUserWorkItem</strong>. The following code takes the example scenario of <a href="B18552_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, but uses a <strong class="source-inline">ThreadPool</strong> thread to perform the background process:</p>
<pre class="source-code">Console.WriteLine("Hello, World!");</pre>
<pre class="source-code">ThreadPool.QueueUserWorkItem((o) =&gt;</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    for (int i = 0; i &lt; 20; i++)</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        bool isNetworkUp = System.Net.NetworkInformation.</pre>
<pre class="source-code">            NetworkInterface.GetIsNetworkAvailable();</pre>
<pre class="source-code">        Console.WriteLine($"Is network available? Answer: </pre>
<pre class="source-code">            {isNetworkUp}");</pre>
<pre class="source-code">        Thread.Sleep(100);</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">});</pre>
<pre class="source-code">for (int i = 0; i &lt; 10; i++)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    Console.WriteLine("Main thread working...");</pre>
<pre class="source-code">    Task.Delay(500);</pre>
<pre class="source-code">}</pre>
<pre class="source-code">Console.WriteLine("Done");</pre>
<pre class="source-code">Console.ReadKey();</pre>
<p>Here, the<a id="_idIndexMarker086"/> key differences are that there is no need to set <strong class="source-inline">IsBackground</strong> to <strong class="source-inline">true</strong>, and you do not call <strong class="source-inline">Start()</strong>. The process will start either as soon as the item is queued on <strong class="source-inline">ThreadPool</strong> or when the next <strong class="source-inline">ThreadPool</strong> becomes available. While you might not explicitly use <strong class="source-inline">ThreadPool</strong> frequently in your code, it is leveraged by many of the common threading features in .NET. So, it’s important to have some understanding of how it works.</p>
<p>One of the common .NET features that use <strong class="source-inline">ThreadPool</strong> is timers. </p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>Threading and timers</h2>
<p>In this <a id="_idIndexMarker087"/>section, we will examine two timer classes that use <strong class="source-inline">ThreadPool</strong>, <strong class="source-inline">System.Timers.Timer</strong> and <strong class="source-inline">System.Threading.Timer</strong>. Both of these<a id="_idIndexMarker088"/> types are safe to use with managed threading and are available on every platform supported by .NET 6.</p>
<p class="callout-heading">Note</p>
<p class="callout">Some additional timers are only applicable to either web or Windows platform development. This section will focus on the timers that are platform agnostic. To read more about the other timers, you can refer to the documentation on the Microsoft Docs website at <a href="">https://docs.microsoft.com/dotnet/standard/threading/timers</a>. </p>
<h3>System.Timers.Timer</h3>
<p>You are<a id="_idIndexMarker089"/> probably most familiar with the <strong class="source-inline">Timer</strong> object in the <strong class="source-inline">System.Timers</strong> namespace. This timer will raise an <strong class="source-inline">Elapsed</strong> event on a thread <a id="_idIndexMarker090"/>pool thread at the interval specified in the <strong class="source-inline">Interval</strong> property. The mechanism can be stopped or started by using the Boolean <strong class="source-inline">Enabled</strong> property. If you need the <strong class="source-inline">Elapsed</strong> event to only fire once, the <strong class="source-inline">AutoReset</strong> property can be set to <strong class="source-inline">false</strong>.</p>
<p class="callout-heading">Note</p>
<p class="callout">To follow along with the code in this example, download the code from the <strong class="bold">WorkingWithTimers</strong> project of this chapter’s GitHub repository: <a href="">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter02</a>.</p>
<p>This example uses a <strong class="source-inline">Timer</strong> object to check for new messages and alert a user if any are found: </p>
<ol>
<li>Start by declaring a <strong class="source-inline">Timer</strong> object and setting it up in an <strong class="source-inline">InitializeTimer</strong> method:<p class="source-code">private System.Timers.Timer? _timer;</p><p class="source-code">private void InitializeTimer()</p><p class="source-code">{</p><p class="source-code">    _timer = new System.Timers.Timer</p><p class="source-code">    {</p><p class="source-code">        Interval = 1000</p><p class="source-code">    };</p><p class="source-code">    _timer.Elapsed += _timer_Elapsed;</p><p class="source-code">}</p></li>
<li>Next, create<a id="_idIndexMarker091"/> the <strong class="source-inline">_timer_Elapsed</strong> event handler to <a id="_idIndexMarker092"/>check for messages and update the users:<p class="source-code">private void _timer_Elapsed(object? sender, </p><p class="source-code">    System.Timers.ElapsedEventArgs e)</p><p class="source-code">{</p><p class="source-code">    int messageCount = CheckForNewMessageCount();</p><p class="source-code">    if (messageCount &gt; 0)</p><p class="source-code">    {</p><p class="source-code">        AlertUser(messageCount);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>After the <strong class="source-inline">_timer</strong> object has its <strong class="source-inline">Enabled</strong> property set to <strong class="source-inline">true</strong>, the <strong class="source-inline">Elapsed</strong> event will fire every second. In the <strong class="bold">WorkingWithTimers</strong> project, the state is being controlled by the <strong class="source-inline">StartTimer()</strong> and <strong class="source-inline">StopTimer()</strong> methods in the <strong class="source-inline">TimerSample</strong> class:<p class="source-code">public void StartTimer()</p><p class="source-code">{</p><p class="source-code">    if (_timer == null)</p><p class="source-code">    {</p><p class="source-code">        InitializeTimer();</p><p class="source-code">    }</p><p class="source-code">    if (_timer != null &amp;&amp; !_timer.Enabled)</p><p class="source-code">    {</p><p class="source-code">        _timer.Enabled = true;</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">public void StopTimer()</p><p class="source-code">{</p><p class="source-code">    if (_timer != null &amp;&amp; _timer.Enabled)</p><p class="source-code">    {</p><p class="source-code">        _timer.Enabled = false;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Run <a id="_idIndexMarker093"/>the <strong class="bold">WorkingWithTimers</strong> project and try using the <strong class="bold">Start Timer</strong> and <strong class="bold">Stop Timer</strong> buttons. </li>
</ol>
<p>You should see <a id="_idIndexMarker094"/>messages in Visual Studio’s debug <strong class="bold">Output</strong> window appearing every second while the timer is enabled.</p>
<p class="callout-heading">Note</p>
<p class="callout">Remember that timer events are firing on a thread pool thread. The code executing in these methods might not have access to<a id="_idIndexMarker095"/> update the UI. These timer examples are part of a <strong class="bold">Windows Forms</strong> (<strong class="bold">WinForms</strong>) project. The most common way to update the UI with WinForms is by checking <strong class="source-inline">InvokeRequired</strong> on the form or user control and then updating the UI with the <strong class="source-inline">Invoke</strong> method, if necessary. More information about how to update a WinForms UI can be found on the Microsoft Docs website at <a href="">https://docs.microsoft.com/dotnet/desktop/winforms/controls/how-to-make-thread-safe-calls</a>. </p>
<p>In your own applications, you would use the <strong class="source-inline">AlertUser</strong> method to present an alert message to the user or update a notification icon in the UI. Next, let’s try the <strong class="source-inline">System.Threading.Timer</strong> class.</p>
<h3>System.Threading.Timer</h3>
<p>Now, we will <a id="_idIndexMarker096"/>create <a id="_idIndexMarker097"/>the same example with the <strong class="source-inline">System.Threading.Timer</strong> class. This <strong class="source-inline">Timer</strong> class must be initialized a little differently:</p>
<p class="callout-heading">Note</p>
<p class="callout">To follow along with the code in this example, download the code from the <strong class="bold">WorkingWithTimers</strong> project of this chapter’s GitHub repository: <a href="">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter02</a>.</p>
<ol>
<li value="1">Start by creating a new <strong class="source-inline">InitializeTimer</strong> method:<p class="source-code">private void InitializeTimer()</p><p class="source-code">{</p><p class="source-code">    var updater = new MessageUpdater();</p><p class="source-code">    _timer = new System.Threading.Timer(</p><p class="source-code">    callback: new TimerCallback(TimerFired),</p><p class="source-code">    state: updater,</p><p class="source-code">    dueTime: 500,</p><p class="source-code">    period: 1000);</p><p class="source-code">}</p></li>
</ol>
<p>The constructor for the <strong class="source-inline">Timer</strong> class takes four parameters. The <strong class="source-inline">callback</strong> parameter is a delegate to invoke on the thread pool when the timer period elapses. The <strong class="source-inline">state</strong> parameter is an object to pass to the callback delegate. The <strong class="source-inline">dueTime</strong> parameter tells the timer how long (in milliseconds) to wait before triggering the timer for the first time. Finally, the <strong class="source-inline">period</strong> parameter specifies the interval (in milliseconds) between each delegate invocation.</p>
<ol>
<li value="2">After <a id="_idIndexMarker098"/>instantiating the timer, it will immediately start. There is <a id="_idIndexMarker099"/>no <strong class="source-inline">Enabled</strong> property to start or stop this timer. When you are done with it, you should dispose of it with either the <strong class="source-inline">Dispose</strong> method or the <strong class="source-inline">DisposeAsync</strong> method. This is happening in our <strong class="source-inline">DisposeTimerAsync</strong> method:<p class="source-code">public void StartTimer()</p><p class="source-code">{</p><p class="source-code">    if (_timer == null)</p><p class="source-code">    {</p><p class="source-code">        InitializeTimer();</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code"><strong class="bold">public async Task DisposeTimerAsync()</strong></p><p class="source-code"><strong class="bold">{</strong></p><p class="source-code"><strong class="bold">    if (_timer != null)</strong></p><p class="source-code"><strong class="bold">    {</strong></p><p class="source-code"><strong class="bold">        await _timer.DisposeAsync();</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code"><strong class="bold">}</strong></p></li>
<li><strong class="source-inline">MessageUpdater</strong> is a class that is used as the <strong class="source-inline">state</strong> object provided to the <strong class="source-inline">TimerCallback</strong> method. It has a single method that handles updates to the message count. The logic to update the user about new messages can be encapsulated by this class. In our case, it will simply update the debug output with the number of new messages:<p class="source-code">internal class MessageUpdater</p><p class="source-code">{</p><p class="source-code">    internal void Update(int messageCount)</p><p class="source-code">    {</p><p class="source-code">        Debug.WriteLine($"You have {messageCount} new </p><p class="source-code">            messages!");</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>The <a id="_idIndexMarker100"/>final piece to examine is the <strong class="source-inline">TimerFired</strong> callback <a id="_idIndexMarker101"/>method:<p class="source-code">private void TimerFired(object? state)</p><p class="source-code">{</p><p class="source-code">    int messageCount = CheckForNewMessageCount();</p><p class="source-code">    if (messageCount &gt; 0 &amp;&amp;</p><p class="source-code">        state is MessageUpdater updater)</p><p class="source-code">    {</p><p class="source-code">        updater.Update(messageCount);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>Similar to the <strong class="source-inline">_timer_Elapsed</strong> method from the previous example, this method simply checks for new messages and triggers an update. However, this time, the update is performed by the <strong class="source-inline">MessageUpdater</strong> class, which, in your application, could be abstracted through an <strong class="source-inline">IMessageUpdater</strong> interface and injected into this class for improved separation of concerns and testability.</p>
<ol>
<li value="5">Try this example by using the <strong class="bold">Start Threading Timer</strong> and <strong class="bold">Stop Threading Timer</strong> buttons in the application. You should see a debug message appearing with new message counts in the <strong class="bold">Output</strong> window, as you did in the previous example.</li>
</ol>
<p>The two<a id="_idIndexMarker102"/> timers <a id="_idIndexMarker103"/>serve similar purposes; however, most of the time, you will want to use <strong class="source-inline">System.Threading.Timer</strong> to leverage its async nature. However, if you need to frequently stop and start your timer processes, the <strong class="source-inline">System.Timers.Timer</strong> class is a better choice.</p>
<p>Now that we have covered some additional managed threading concepts to level-set your knowledge, it’s time to shift gears and introduce the concept of parallel programming with C#.</p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Introduction to parallelism</h1>
<p>While <a id="_idIndexMarker104"/>exploring the history of threading in C# and .NET, we learned that parallelism was introduced to developers in .NET Framework 4.0. In this section, the aspects that will be explored are exposed in the TPL through the <strong class="source-inline">System.Threading.Tasks.Parallel</strong> class. In addition, we will cover some of the basics of PLINQ through examples. These data parallelism concepts will be covered in greater detail with real-world examples in <a href="B18552_06_ePub.xhtml#_idTextAnchor098"><em class="italic">Chapter 6</em></a>, <a href="B18552_07_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 7</em></a>, and <a href="B18552_08_ePub.xhtml#_idTextAnchor130"><em class="italic">Chapter 8</em></a>.</p>
<p>At a high level, parallelism is the concept of executing multiple tasks in parallel. These tasks could be related to one another, but this is not a requirement. In fact, related tasks running in parallel run a greater risk of encountering synchronization issues or blocking one another. For example, if your application loads order data from an orders service and user preferences and application state<a id="_idIndexMarker105"/> from an <strong class="bold">Azure blob store</strong>, these two processes can be run in parallel without having to worry about conflicts or data synchronization. On the other hand, if the application is loading order data from two different order services and combining the results in a single collection, you will need a synchronization strategy.</p>
<p>That type of scenario will be discussed, in greater depth, in <a href="B18552_09_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 9</em></a>. In this section, we will prepare for those advanced scenarios by learning some uses of the <strong class="source-inline">Parallel</strong> class. Let’s start with <strong class="source-inline">Parallel.Invoke</strong>.</p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Using Parallel.Invoke</h2>
<p><strong class="source-inline">Parallel.Invoke</strong> is a <a id="_idIndexMarker106"/>method that can execute multiple actions, and they could be executed in parallel. There is no guarantee of the order in which they will execute. Each action will be queued in the thread pool. The <strong class="source-inline">Invoke</strong> call will return when all the actions have been completed.</p>
<p>In this example, the <strong class="source-inline">Parallel.Invoke</strong> call will execute four actions: another method in the <strong class="source-inline">ParallelInvokeExample</strong> class named <strong class="source-inline">DoComplexWork</strong>, a lambda expression, an <strong class="source-inline">Action</strong> declared inline, and a <strong class="source-inline">delegate</strong>. Here is the complete <strong class="source-inline">ParallelInvokeExample</strong> class:</p>
<pre class="source-code">internal class ParallelInvokeExample</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    internal void DoWorkInParallel()</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        Parallel.Invoke(</pre>
<pre class="source-code">            DoComplexWork,</pre>
<pre class="source-code">            () =&gt; {</pre>
<pre class="source-code">                Console.WriteLine($"Hello from lambda </pre>
<pre class="source-code">                expression. Thread id: </pre>
<pre class="source-code">                {Thread.CurrentThread.ManagedThreadId}");</pre>
<pre class="source-code">            },</pre>
<pre class="source-code">            new Action(() =&gt;</pre>
<pre class="source-code">            {</pre>
<pre class="source-code">                Console.WriteLine($"Hello from Action. </pre>
<pre class="source-code">                Thread id: {Thread.CurrentThread</pre>
<pre class="source-code">                .ManagedThreadId}");</pre>
<pre class="source-code">            }),</pre>
<pre class="source-code">            delegate ()</pre>
<pre class="source-code">            {</pre>
<pre class="source-code">                Console.WriteLine($"Hello from delegate. </pre>
<pre class="source-code">                Thread id: {Thread.CurrentThread</pre>
<pre class="source-code">                .ManagedThreadId}");</pre>
<pre class="source-code">            }</pre>
<pre class="source-code">        );</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">    private void DoComplexWork()</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        Console.WriteLine($"Hello from DoComplexWork </pre>
<pre class="source-code">        method. Thread id: {Thread.CurrentThread</pre>
<pre class="source-code">       .ManagedThreadId}");</pre>
<pre class="source-code">    }</pre>
<pre class="source-code">}</pre>
<p>Creating a<a id="_idIndexMarker107"/> new instance of <strong class="source-inline">ParallelInvokeExample</strong> and executing <strong class="source-inline">DoWorkInParallel</strong> from a console application will produce an output similar to the following, although the order of operations may vary:</p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<img alt="Figure 2.1 – Output produced by the DoWorkInParallel method " height="653" src="image/Figure_2.1_B18552.jpg" width="1251"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Output produced by the DoWorkInParallel method</p>
<p>In the next section, we <a id="_idIndexMarker108"/>will learn how to implement a <strong class="source-inline">Parallel.ForEach</strong> loop and discuss when you might want to leverage it.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Using Parallel.ForEach</h2>
<p><strong class="source-inline">Parallel.ForEach</strong> is <a id="_idIndexMarker109"/>probably the most used member of the <strong class="source-inline">Parallel</strong> class in .NET. This is because, in many cases, you can simply take the body of a standard <strong class="source-inline">foreach</strong> loop and use it inside a <strong class="source-inline">Parallel.ForEach</strong> loop. However, when introducing any parallelism into a code base, you must be sure that the code being invoked is thread-safe. If the body of a <strong class="source-inline">Parallel.ForEach</strong> loop modifies any of the collections, you will either need to employ one of the synchronization methods discussed in <a href="B18552_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, or use one of .NET’s concurrent collections. We will introduce concurrent collections in the <em class="italic">Introduction to concurrency</em> section.</p>
<p>As an example of using <strong class="source-inline">Parallel.ForEach</strong>, we will create a method that accepts a list of numbers and checks whether each number is contained in a string representation of the current time:</p>
<pre class="source-code">internal void ExecuteParallelForEach(IList&lt;int&gt; numbers)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    Parallel.ForEach(numbers, number =&gt;</pre>
<pre class="source-code">    {</pre>
<pre class="source-code">        bool timeContainsNumber = DateTime.Now.</pre>
<pre class="source-code">            ToLongTimeString().Contains(number.ToString());</pre>
<pre class="source-code">        if (timeContainsNumber)</pre>
<pre class="source-code">        {</pre>
<pre class="source-code">            Console.WriteLine($"The current time contains </pre>
<pre class="source-code">            number {number}. Thread id: {Thread.</pre>
<pre class="source-code">            CurrentThread.ManagedThreadId}");</pre>
<pre class="source-code">        }</pre>
<pre class="source-code">        else</pre>
<pre class="source-code">        {</pre>
<pre class="source-code">            Console.WriteLine($"The current time does not </pre>
<pre class="source-code">            contain number {number}. Thread id: </pre>
<pre class="source-code">            {Thread.CurrentThread.ManagedThreadId}");</pre>
<pre class="source-code">        }</pre>
<pre class="source-code">    });</pre>
<pre class="source-code">}</pre>
<p>Here is the<a id="_idIndexMarker110"/> call to <strong class="source-inline">ExecuteParallelForEach</strong> from the console application’s <strong class="source-inline">Main</strong> method:</p>
<pre class="source-code">var numbers = new List&lt;int&gt; { 1, 3, 5, 7, 9, 0 };</pre>
<pre class="source-code">var foreachExample = new ParallelForEachExample();</pre>
<pre class="source-code">foreachExample.ExecuteParallelForEach(numbers);</pre>
<p>Execute the program, and examine the console output. You should see that more than one thread was used to process the loop:</p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<img alt="Figure 2.2 – Console output from a Parallel.ForEach loop " height="657" src="image/Figure_2.2_B18552.jpg" width="1257"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Console output from a Parallel.ForEach loop</p>
<p>Next, we will <a id="_idIndexMarker111"/>wrap up this section on parallelism in .NET with an introduction to PLINQ.</p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Basics of Parallel LINQ</h2>
<p>This <a id="_idIndexMarker112"/>section will look at one of the simplest ways to add some parallelism to your code. By adding the <strong class="source-inline">AsParallel</strong> method to your LINQ query, you can transform it into a PLINQ query, with the operations after <strong class="source-inline">AsParallel</strong> being executed on the thread pool when necessary. There are many factors to consider when deciding when to use PLINQ. We will discuss those in some depth in <a href="B18552_08_ePub.xhtml#_idTextAnchor130"><em class="italic">Chapter 8</em></a>. For this example, we will introduce <strong class="bold">PLINQ</strong> inside a <strong class="bold">LINQ</strong> <strong class="source-inline">Where</strong> clause that checks whether each given integer is an even number. To help illustrate how PLINQ can impact sequences, <strong class="source-inline">Task.Delay</strong> is also introduced. Here is the complete <strong class="source-inline">ParallelLinqExample</strong> class implementation:</p>
<pre class="source-code">internal void ExecuteLinqQuery(IList&lt;int&gt; numbers)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var evenNumbers = numbers.Where(n =&gt; n % 2 == 0);</pre>
<pre class="source-code">    OutputNumbers(evenNumbers, "Regular");</pre>
<pre class="source-code">}</pre>
<pre class="source-code">internal void ExecuteParallelLinqQuery(IList&lt;int&gt; numbers)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var evenNumbers = numbers.AsParallel().Where(n =&gt; </pre>
<pre class="source-code">        IsEven(n));</pre>
<pre class="source-code">    OutputNumbers(evenNumbers, "Parallel");</pre>
<pre class="source-code">}</pre>
<pre class="source-code">private bool IsEven(int number)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    Task.Delay(100);</pre>
<pre class="source-code">    return number % 2 == 0;</pre>
<pre class="source-code">}</pre>
<pre class="source-code">private void OutputNumbers(IEnumerable&lt;int&gt; numbers, string </pre>
<pre class="source-code">    loopType)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    var numberString = string.Join(",", numbers);</pre>
<pre class="source-code">    Console.WriteLine($"{loopType} number string: </pre>
<pre class="source-code">        {numberString}");</pre>
<pre class="source-code">}</pre>
<p>In the <strong class="source-inline">Main</strong> method <a id="_idIndexMarker113"/>of your console application, add some code to pass a list of integers to both the <strong class="source-inline">ExecuteLinqQuery</strong> and <strong class="source-inline">ExecuteParallelLinqQuery</strong> methods:</p>
<pre class="source-code">var linqNumbers = new List&lt;int&gt; { 0, 1, 2, 3, 4, 5, 6, 7, </pre>
<pre class="source-code">    8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };</pre>
<pre class="source-code">var linqExample = new ParallelLinqExample();</pre>
<pre class="source-code">linqExample.ExecuteLinqQuery(linqNumbers);</pre>
<pre class="source-code">linqExample.ExecuteParallelLinqQuery(linqNumbers);</pre>
<p>Examine<a id="_idIndexMarker114"/> the output, and you should see that the order of the numbers in the PLINQ sequence has changed:</p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<img alt="Figure 2.3 – Console output of the LINQ and PLINQ queries " height="570" src="image/Figure_2.3_B18552.jpg" width="1245"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Console output of the LINQ and PLINQ queries</p>
<p>We will explore more aspects of parallelism over several chapters in <em class="italic">Part 2</em>, <em class="italic">Parallel Programming and Concurrency with C#,</em> of this book. Let’s shift gears and learn about some concurrency patterns in C#.</p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/>Introduction to concurrency</h1>
<p>So, what is <a id="_idIndexMarker115"/>concurrency and how does it relate to parallelism in the context of C# and .NET? The terms are frequently used interchangeably, and if you think about it, they do have similar meanings. When multiple threads are executing in parallel, they are running concurrently. In this book, we will use the term concurrency when discussing patterns to follow when designing for managed threading. Additionally, we will discuss concurrency in the context of the concurrent collections that were introduced to .NET developers in .NET Framework 4.0. Let’s start by learning about the concurrent collections in the <strong class="source-inline">System.Collections.Concurrent</strong> namespace.</p>
<p>.NET has several <a id="_idIndexMarker116"/>collections that have been created with thread safety built-in. These collections can all be found in the <strong class="source-inline">System.Collections.Concurrent</strong> namespace. In this section, we will introduce five of the collections. The remaining three are variations of <strong class="source-inline">Partitioner</strong>. These will be explored in <a href="B18552_09_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 9</em></a>, where we will work with each of the collection types through practical examples.</p>
<p class="callout-heading">Note</p>
<p class="callout">While your code does not require the use of locks when using concurrent collections, different techniques for synchronization are being employed inside these collections. Some of them do use locking, while others have retry mechanisms to deal with contention. To read more about how concurrent collections handle contention, check out this Microsoft blog post on the .NET Parallel Programming blog: <a href="">https://devblogs.microsoft.com/pfxteam/faq-are-all-of-the-new-concurrent-collections-lock-free/</a>.</p>
<p>The first collection we will introduce is <strong class="source-inline">ConcurrentBag&lt;T&gt;</strong>.</p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>ConcurrentBag&lt;T&gt;</h2>
<p>The <strong class="source-inline">ConcurrentBag&lt;T&gt;</strong> collection <a id="_idIndexMarker117"/>is a concurrent collection intended to hold a collection of unordered objects. Duplicate values are allowed, as are null values when <strong class="source-inline">T</strong> is a nullable type. It makes an excellent thread-safe replacement for an array, <strong class="source-inline">List&lt;T&gt;</strong>, or other <strong class="source-inline">IEnumerable&lt;T&gt;</strong> instances where the ordering of items is not a requirement.</p>
<p>Internally, <strong class="source-inline">ConcurrentBag&lt;T&gt;</strong> stores a linked list of items for each thread adding items. As items are taken or peeked at from the collection, priority will be given to the internal list, which had items added by the current thread. Let’s suppose thread 1 adds items A, B, and C and thread 2 adds items D, E, F, and G. If thread 1 calls <strong class="source-inline">TryPeek</strong> or <strong class="source-inline">TryTake</strong> four times, <strong class="source-inline">ConcurrentBag&lt;T&gt;</strong> will get items from the A, B, and C list first before taking items from the linked list containing items from thread 2.</p>
<p>The following list details the properties and methods of <strong class="source-inline">ConcurrentBag&lt;T&gt;</strong> that you are likely to use<a id="_idIndexMarker118"/> in most implementations:</p>
<ul>
<li><strong class="source-inline">Add(T)</strong>: This adds an object to the bag.</li>
<li><strong class="source-inline">TryPeek(out T)</strong>: This tries to fetch a value from the bag with an <strong class="source-inline">out</strong> parameter but does not remove that item.</li>
<li><strong class="source-inline">TryTake(out T)</strong>: This attempts to fetch a value from the bag with an <strong class="source-inline">out</strong> parameter and removes it.</li>
<li><strong class="source-inline">Clear()</strong>: This clears all of the objects from the bag.</li>
<li><strong class="source-inline">Count</strong>: This returns the number of objects in the bag.</li>
<li><strong class="source-inline">IsEmpty</strong>: This returns a <strong class="source-inline">bool</strong> value indicating whether the bag is empty.</li>
<li><strong class="source-inline">ToArray()</strong>: This returns an array of objects of type <strong class="source-inline">T</strong>.</li>
</ul>
<p>The <strong class="source-inline">ConcurrentBag&lt;T&gt;</strong> collection has two constructors. One constructor takes no parameters and simply creates a new empty bag. The other accepts an <strong class="source-inline">IEnumerable&lt;T&gt;</strong> type of object to be copied to the new bag.</p>
<p>Next, let’s take a quick look at the <strong class="source-inline">ConcurrentQueue&lt;T&gt;</strong> collection.</p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>ConcurrentQueue&lt;T&gt;</h2>
<p>The .NET <strong class="source-inline">ConcurrentQueue&lt;T&gt;</strong> collection<a id="_idIndexMarker119"/> is similar in implementation to its thread-unsafe counterpart, <strong class="source-inline">Queue&lt;T&gt;</strong>. As such, it makes a great replacement for <strong class="source-inline">Queue&lt;T&gt;</strong> when managed threading is introduced to an existing code base. <strong class="source-inline">ConcurrentQueue&lt;T&gt;</strong> is a strongly typed list of objects that enforces <strong class="bold">first in, first out</strong> (<strong class="bold">FIFO</strong>) logic, which is the<a id="_idIndexMarker120"/> definition of a <strong class="bold">queue</strong>.</p>
<p class="callout-heading">Note</p>
<p class="callout"><strong class="bold">FIFO</strong> logic <a id="_idIndexMarker121"/>is commonly seen in the manufacturing industry and in warehouse management software. When working with perishable goods, it is important to use your oldest raw materials first. Therefore, those pallets of goods that were the first to be put into the warehouse should be the first to be pulled when a pallet of that type is requested by the system.</p>
<p>These are the commonly used members of the <strong class="source-inline">ConcurrentQueue&lt;T&gt;</strong> type:</p>
<ul>
<li><strong class="source-inline">Enqueue(T)</strong>: This adds a new object to the queue.</li>
<li><strong class="source-inline">TryPeek(out T)</strong>: This attempts to get the object at the front of the queue without removing it.</li>
<li><strong class="source-inline">TryDequeue(out T)</strong>: This tries to get the object at the front of the queue and removes it.</li>
<li><strong class="source-inline">Clear()</strong>: This clears the queue.</li>
<li><strong class="source-inline">Count</strong>: This returns the number of objects in the queue.</li>
<li><strong class="source-inline">IsEmpty</strong>: This returns a <strong class="source-inline">bool</strong> value indicating whether the queue is empty.</li>
<li><strong class="source-inline">ToArray()</strong>: This returns the objects in the queue as an array of type <strong class="source-inline">T</strong>.</li>
</ul>
<p>Similar to<a id="_idIndexMarker122"/> the <strong class="source-inline">ConcurrentBag&lt;T&gt;</strong> collection, the <strong class="source-inline">ConcurrentQueue&lt;T&gt;</strong> collection has two constructors: one parameterless and one that takes an <strong class="source-inline">Ienumerable&lt;T&gt;</strong> type to populate the new queue. Next, let’s introduce a similar collection: <strong class="source-inline">ConcurrentStack&lt;T&gt;</strong>.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>ConcurrentStack&lt;T&gt;</h2>
<p><strong class="source-inline">ConcurrentStack&lt;T&gt;</strong> can <a id="_idIndexMarker123"/>be thought of as <strong class="source-inline">ConcurrentQueue&lt;T&gt;</strong>, but it <a id="_idIndexMarker124"/>uses <strong class="bold">last in, first out</strong> (<strong class="bold">LIFO</strong>), or <strong class="bold">stack</strong>, logic<a id="_idIndexMarker125"/> instead of FIFO. The operations it supports are similar, but it has a <strong class="source-inline">Push</strong> method instead of <strong class="source-inline">Enqueue</strong>, and removing items uses a <strong class="source-inline">TryPop</strong> method instead of <strong class="source-inline">TryDequeue</strong>. Another advantage of the <strong class="source-inline">ConcurrentStack&lt;T&gt;</strong> collection is that it can add or remove multiple objects in one operation. These range operations are supported by using the <strong class="source-inline">PushRange</strong> and <strong class="source-inline">TryPopRange</strong> methods. The range operations take arrays of <strong class="source-inline">T</strong> as parameters.</p>
<p>C<strong class="source-inline">oncurrentStack&lt;T&gt;</strong> and <strong class="source-inline">ConcurrentQueue&lt;T&gt;</strong> in .NET 6 both implement the <strong class="source-inline">IReadOnlyCollection&lt;T&gt;</strong> interface. This means that once the collection has been created, it is read-only and cannot be reassigned or set to <strong class="source-inline">null</strong>. You can only add or remove items or use <strong class="source-inline">Clear()</strong> to empty the collection.</p>
<p>Let’s move on to one of the most powerful concurrent collections, <strong class="source-inline">BlockingCollection&lt;T&gt;</strong>.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>BlockingCollection&lt;T&gt;</h2>
<p><strong class="source-inline">BlockingCollection&lt;T&gt;</strong> is a thread-safe collection of objects that implements <a id="_idIndexMarker126"/>several interfaces, including <strong class="source-inline">IProducerConsumerCollection&lt;T&gt;</strong>. The <strong class="source-inline">IProducerConsumerCollection&lt;T&gt;</strong> interface provides a set of members intended to support applications that <a id="_idIndexMarker127"/>need to implement the <strong class="bold">producer/consumer pattern</strong>.</p>
<p class="callout-heading">Note</p>
<p class="callout">The producer/consumer pattern is a concurrency design pattern where a set of data is concurrently fed by one or more producer threads. At the same time, there are one or more consumer threads monitoring and fetching the data being produced to consume and process it concurrently. The <strong class="source-inline">BlockingCollection&lt;T&gt;</strong> collection is the data store in this producer/consumer pattern. You can read more about producer/consumer on Wikipedia at <a href="">https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem</a>. </p>
<p><strong class="source-inline">BlockingCollection&lt;T&gt;</strong> has several methods and properties that assist in a producer/consumer workflow. You can indicate that the producer process is done adding items to the collection by calling the <strong class="source-inline">CompleteAdding</strong> method. Once this method is called, no more items can be added to the collection with the <strong class="source-inline">Add</strong> or <strong class="source-inline">TryAdd</strong> methods. If you plan to use <strong class="source-inline">CompleteAdding</strong> in your workflow, it is best to always use <strong class="source-inline">TryAdd</strong> and check the Boolean result when adding objects to the collection. If the collection has been marked as complete for adding, calling <strong class="source-inline">Add</strong> will throw <strong class="source-inline">InvalidOperationException</strong>. Additionally, you can check the <strong class="source-inline">IsAddingCompleted</strong> property to find out whether <strong class="source-inline">CompleteAdding</strong> has already been called.</p>
<p>Items are removed from <strong class="source-inline">BlockingCollection&lt;T&gt;</strong> by a consumer process with the <strong class="source-inline">Take</strong> or <strong class="source-inline">TryTake</strong> methods. Again, it is safer to use <strong class="source-inline">TryTake</strong> to avoid any exceptions when the collection is empty. If <strong class="source-inline">CompleteAdding</strong> has been called and all objects have been <a id="_idIndexMarker128"/>removed from the collection, the <strong class="source-inline">IsCompleted</strong> property will return true.</p>
<p>We will walk through a real-world producer/consumer implementation in <a href="B18552_09_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 9</em></a><em class="italic"> .NET</em>. Now, let’s move on to our final concurrent collection in this section, <strong class="source-inline">ConcurrentDictionary&lt;T&gt;</strong>.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>ConcurrentDictionary&lt;TKey, TValue&gt;</h2>
<p>As you <a id="_idIndexMarker129"/>have probably guessed, <strong class="source-inline">ConcurrentDictionary&lt;TKey,</strong> <strong class="source-inline">TValue&gt;</strong> is a great replacement for <strong class="source-inline">Dictionary&lt;TKey, TValue&gt;</strong> when working with managed threading. Both collections implement the <strong class="source-inline">IDictionary&lt;TKey, TValue&gt;</strong> interface. The concurrent version of this collection adds the following methods for working with data concurrently:</p>
<ul>
<li><strong class="source-inline">TryAdd</strong>: This<a id="_idIndexMarker130"/> tries to add a new key/value pair to the dictionary and returns a Boolean value indicating whether the object was successfully added to the dictionary. If the key already exists, the method will return <strong class="source-inline">false</strong>.</li>
<li><strong class="source-inline">TryUpdate</strong>: This <a id="_idIndexMarker131"/>operation passes a key along with the existing and new values for the item. It will update the existing item to the new value if it exists in the dictionary with the existing value provided. The Boolean value that is returned indicates whether the object was successfully updated in the dictionary.</li>
<li><strong class="source-inline">AddOrUpdate</strong>: This <a id="_idIndexMarker132"/>method will add or update an item in the dictionary based on whether the key exists and uses an update delegate to perform any logic based on the current and new values for the item.</li>
<li><strong class="source-inline">GetOrAdd</strong>: This<a id="_idIndexMarker133"/> method will add an item if the key does not already exist. If it does exist, the existing value is returned.</li>
</ul>
<p>These are the most important and common concurrent collections in .NET to understand. We will cover some examples of each and learn about more of the collections in <strong class="source-inline">System.Collections.Concurrent</strong> later, but this section should provide a solid base for understanding what is to come.</p>
<p>In the next section, we will introduce the C# <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> keywords that were added to C# 5.0.</p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/>Basics of async and await</h1>
<p>When the TPL was introduced in .NET Framework 4.5, C# 5.0 also added language support for task-based asynchronous programming with the <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> keywords. This immediately became the default method of implementing asynchronous workflows in C# and .NET. Now, 10 years later, <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> and the TPL have become an integral part of building robust, scalable .NET applications. You might be wondering why it is so important to adopt async programming in your applications.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Understanding the async keyword</h2>
<p>There are <a id="_idIndexMarker134"/>many reasons for writing async code. If you’re writing server-side code on a web server, using async allows the server to handle additional requests while your code is awaiting a long-running operation. On a client application, freeing the UI thread to perform other operations with async code allows your UI to remain responsive to users. </p>
<p>Another important reason to adopt async programming in .NET is that many third-party and open source libraries are using <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong>. Even .NET itself is exposing more APIs as async in every release, especially those involving IO operations: networking, file, and database access.</p>
<p>Let’s try writing your first async method with C#.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Writing an async method</h2>
<p>Creating and <a id="_idIndexMarker135"/>consuming an async method is easy. Let’s try a simple example with a new console application:</p>
<ol>
<li value="1">Create a new console application in Visual Studio and name it <strong class="bold">AsyncConsoleExample</strong>.</li>
<li>Add a class to the project, named <strong class="source-inline">NetworkHelper</strong>, and add the following methods <a id="_idIndexMarker136"/>to the class:<p class="source-code">internal async Task CheckNetworkStatusAsync()</p><p class="source-code">{</p><p class="source-code">    Task t = NetworkCheckInternalAsync();</p><p class="source-code">    for (int i = 0; i &lt; 8; i++)</p><p class="source-code">    {</p><p class="source-code">        Console.WriteLine("Top level method </p><p class="source-code">           working...");</p><p class="source-code">        await Task.Delay(500);</p><p class="source-code">    }</p><p class="source-code">    await t;</p><p class="source-code">}</p><p class="source-code">private async Task NetworkCheckInternalAsync()</p><p class="source-code">{</p><p class="source-code">    for (int i = 0; i &lt; 10; i++)</p><p class="source-code">    {</p><p class="source-code">        bool isNetworkUp = System.Net.</p><p class="source-code">           NetworkInformation.NetworkInterface</p><p class="source-code">               .GetIsNetworkAvailable();</p><p class="source-code">        Console.WriteLine($"Is network available? </p><p class="source-code">            Answer: {isNetworkUp}");</p><p class="source-code">        await Task.Delay(100);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>There are a few things to point out in the preceding code. Both methods have an <strong class="source-inline">async</strong> modifier, indicating that they will be awaiting some work and will run asynchronously. Inside the methods, we are using the <strong class="source-inline">await</strong> keyword with the calls to <strong class="source-inline">Task.Delay</strong>. This will ensure that no code after this point will execute until the awaited method has been completed. However, during this time, the active thread can be released to perform other work elsewhere.</p>
<p>Finally, look at <a id="_idIndexMarker137"/>the call to <strong class="source-inline">NetworkCheckInternalAsync</strong>. Instead of awaiting this call, we are capturing the returned <strong class="source-inline">Task</strong> instance in a variable named <strong class="source-inline">t</strong>, and we don’t <strong class="source-inline">await</strong> it until after the <strong class="source-inline">for</strong> loop. This means that the <strong class="source-inline">for</strong> loops in both methods will run concurrently. If we had, instead, awaited <strong class="source-inline">NetworkCheckInternalAsync</strong>, its <strong class="source-inline">for</strong> loop would have been completed before the <strong class="source-inline">for</strong> loop in <strong class="source-inline">CheckNetworkStatusAsync</strong> could begin.</p>
<ol>
<li value="3">Next, replace the code in <strong class="source-inline">Program.cs</strong> with the following:<p class="source-code">using AsyncConsoleExample;</p><p class="source-code">Console.WriteLine("Hello, async!");</p><p class="source-code">var networkHelper = new NetworkHelper();</p><p class="source-code">await networkHelper.CheckNetworkStatusAsync();</p><p class="source-code">Console.WriteLine("Main method complete.");</p><p class="source-code">Console.ReadKey();</p></li>
</ol>
<p>We are awaiting the call to <strong class="source-inline">CheckNetworkStatusAsync</strong>. This is possible because the default <strong class="source-inline">Main</strong> method in a .NET 6 console application is <strong class="source-inline">async</strong> by default. If you try to <strong class="source-inline">await</strong> something in a method that is not marked as <strong class="source-inline">async</strong>, you will get a compiler error. We will explore some of the options you can use when you must call async methods from existing non-async code in <a href="B18552_05_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 5</em></a>.</p>
<ol>
<li value="4">Finally, run the application and examine the output:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer014">
<img alt="Figure 2.4 – Console output for the async sample application " height="628" src="image/Figure_2.4_B18552.jpg" width="1069"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Console output for the async sample application</p>
<p>As expected, capturing <a id="_idIndexMarker138"/>the async method’s result allowed the two loops to run concurrently. Try awaiting the call to <strong class="source-inline">NetworkCheckInternalAsync</strong> and see how the output changes. You should see that all the output from the private method will appear before the output from the <strong class="source-inline">for</strong> loop in <strong class="source-inline">CheckNetworkStatusAsync</strong> begins.</p>
<p>This was a brief introduction to the world of async programming with C#. We’ll be working with it quite a lot throughout the rest of this book. Let’s wrap things up by discussing how to choose which of these options to leverage when building a new project or enhancing an existing application.</p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>Choosing the right path forward</h1>
<p>Now that you <a id="_idIndexMarker139"/>have been introduced to some advanced managed threading concepts, parallel programming, concurrent collections, and the async/await paradigm, let’s discuss how they all fit together in the real world. Choosing the right path forward with multithreaded development in .NET will usually involve more than one of these concepts.</p>
<p>When working with .NET 6, you should usually choose to create <strong class="source-inline">async</strong> methods in your projects. The reasons discussed in this chapter are compelling. Asynchronous programming keeps both client and server applications responsive, and <strong class="source-inline">async</strong> is used extensively throughout .NET itself.</p>
<p>Some <a id="_idIndexMarker140"/>of the <strong class="source-inline">Parallel</strong> class operations can be leveraged when your code needs to process a set of items quickly and the underlying code doing the processing is thread-safe. This is one place where concurrent collections can be introduced. If any parallel or async operations are manipulating shared data, the data should be stored in one of the .NET concurrent collections.</p>
<p>If you are working with existing code, often, the most prudent path is to limit how much multithreaded code is added. Legacy projects such as these are a great place to incrementally add some <strong class="source-inline">ThreadPool</strong> or <strong class="source-inline">Parallel</strong> operations and test the results. It is important to test the application functionally and for performance. Performance testing tools for managed threading will be covered in <a href="B18552_10_ePub.xhtml#_idTextAnchor158"><em class="italic">Chapter 10</em></a>.</p>
<p>This preliminary guidance will help you get an idea of where you can boost your applications’ performance with managed threading. We will build on your learning and this guidance throughout the rest of the book. Let’s wrap up and discuss what you have learned in this chapter.</p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Summary</h1>
<p>In this chapter, we started by looking at a brief history of C#, .NET, and managed threading. We discussed how Microsoft has added features for asynchronous and parallel programming over the last 20 years. Next, we took a tour of parallel programming with .NET, concurrent collections, and asynchronous development with C#. Finally, we examined when you might choose each of these concepts for your own applications and why you will often choose more than one of them. You will be able to take what you learned in this chapter and start thinking about practical applications of managed threading in your day-to-day work.</p>
<p>In the next chapter, we will take what you have learned so far and discuss some of the best practices for the practical application of the concepts.</p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor060"/>Questions</h1>
<ol>
<li value="1">Which class in .NET manages the thread pool threads available to your application?</li>
<li>In which version of C# were the <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> keywords introduced?</li>
<li>In which version of .NET was the TPL introduced?</li>
<li>In which version of .NET Core was <strong class="source-inline">IAsyncEnumerable</strong> introduced?</li>
<li>What type should every <strong class="source-inline">async</strong> method return?</li>
<li>Which concurrent collection would you choose to replace <strong class="source-inline">Dictionary&lt;TKey, TValue&gt;</strong> in a multithreaded scenario?</li>
<li>Which concurrent collection is frequently used with the producer/consumer design pattern in .NET?</li>
<li>Which parallel feature in .NET features the <strong class="source-inline">AsParallel</strong> method?</li>
</ol>
</div>
</div>
</body></html>