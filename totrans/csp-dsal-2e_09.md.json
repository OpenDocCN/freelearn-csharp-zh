["```cs\nlong Fibonacci(int n)\n{\n    if (n == 0) { return 0; }\n    if (n == 1) { return 1; }\n    return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n```", "```cs\nlong result = Fibonacci(25);\n```", "```cs\nDictionary<int, long> cache = [];\nlong Fibonacci(int n)\n{\n    if (n == 0) { return 0; }\n    if (n == 1) { return 1; }\n    if (cache.ContainsKey(n)) { return cache[n]; }\n    long result = Fibonacci(n - 1) + Fibonacci(n - 2);\n    cache[n] = result;\n    return result;\n}\n```", "```cs\nlong Fibonacci(int n)\n{\n    if (n == 0) { return 0; }\n    if (n == 1) { return 1; }\n    long a = 0;\n    long b = 1;\n    for (int i = 2; i <= n; i++)\n    {\n        long result = a + b;\n        a = b;\n        b = result;\n    }\n    return b;\n}\n```", "```cs\nint[] den = [1, 2, 5, 10, 20, 50, 100, 200, 500];\nList<int> coins = GetCoins(158);\ncoins.ForEach(Console.WriteLine);\nList<int> GetCoins(int amount)\n{\n    List<int> coins = [];\n    for (int i = den.Length - 1; i >= 0; i--)\n    {\n        while (amount >= den[i])\n        {\n            amount -= den[i];\n            coins.Add(den[i]);\n        }\n    }\n    return coins;\n}\n```", "```cs\nResult? FindClosestPair(Point[] points)\n{\n    if (points.Length <= 1) { return null; }\n    if (points.Length <= 3) { return Closest(points); }\n    int m = points.Length / 2;\n    Result r = Closer(\n        FindClosestPair(points.Take(m).ToArray())!,\n        FindClosestPair(points.Skip(m).ToArray())!);\n    Point[] strip = points.Where(p => Math.Abs(p.X\n        - points[m].X) < r.Distance).ToArray();\n    return Closer(r, Closest(strip));\n}\n```", "```cs\npublic record Point(int X, int Y)\n{\n    public float GetDistanceTo(Point p) =>\n        (float)Math.Sqrt(Math.Pow(X - p.X, 2)\n            + Math.Pow(Y - p.Y, 2));\n};\n```", "```cs\npublic record Closest and Closer. The first one searches for the closest pair of points, and its code is shown here:\n\n```", "```cs\n\n The `Closer` method is presented in the following code snippet:\n\n```", "```cs\n\n Finally, let’s take a look at a way of calling the described method:\n\n```", "```cs\n\n You provide the collection of points, sort them by *x* coordinates, and call the `FindClosestPair` method, passing the whole array as a parameter. Finally, you show the following result in the console:\n\n```", "```cs\n\n So, you get the same result as received when you analyzed the example at the beginning of this section. Good work – congratulations!\nWhere can you find more information?\nThe examples shown in this chapter are representatives of various popular algorithmic problems, which you can receive even during interviews while recruiting for a job as a developer. These topics are also popular on the internet. For example, you can find more information about the aforementioned approach to the *closest pair of points* problem and its implementation at [https://www.geeksforgeeks.org/closest-pair-of-points-using-divide-and-conquer-algorithm/](https://www.geeksforgeeks.org/closest-pair-of-points-using-divide-and-conquer-algorithm/). As *GeeksForGeeks* contains a huge number of various articles, you can also find entries there about some other problems mentioned in this chapter, together with some implementations, such as about the rat in a maze problem at [https://www.geeksforgeeks.org/rat-in-a-maze/](https://www.geeksforgeeks.org/rat-in-a-maze/) and about the Sudoku puzzle at [https://www.geeksforgeeks.org/sudoku-backtracking-7](https://www.geeksforgeeks.org/sudoku-backtracking-7)/.\nIn my opinion, coding can be understood as a kind of art. Similar to painters who paint beautiful paintings, developers can write beautiful code. So, while we are talking about art, let’s write beautiful code that will paint beautiful fractals!\nFractal generation\nThe **recursion** can be applied to many various algorithms, also related to computer graphics. For this reason, let’s take a look at another example – **fractal generation** creating interesting patterns, such as the following:\n![Figure 9.4 – An exemplary fractal generated using the recursive function](img/B18069_09_4.jpg)\n\nFigure 9.4 – An exemplary fractal generated using the recursive function\nIt’s really beautiful, isn’t it? Can you see some tree patterns in this image? If not, let’s follow the bold line in the middle of the image (the tree *trunk*) and note that it is divided into two lines (*branches*), each rotated by a given degree. Then, follow one of these lines and see that it is divided according to the same rule. This process is applied further and further until the specified number of levels is reached.\nThe description of this recursive algorithm in the natural language is quite easy, so let’s take a look at code to calculate the coordinates of the start and end points of the following lines that together form the beautiful drawing. The code of the `AddLine` method is shown as follows:\n\n```", "```cs\n\n The method takes a few parameters, namely the following:\n\n*   A level of pattern, starting with the non-negative number and leading to 0\n*   The *x* and *y* coordinates of the start point\n*   A length of the line\n*   Its angle, provided in radians\n\nWithin the method, you check the base condition, namely whether the level is smaller than 0\\. If not, you calculate *x* and *y* coordinates of the end point and add the line to the collection of lines (`lines`). At the end, you recursively call the `AddLine` method, passing different parameters. You decrease the level, pass the calculated end point coordinates as coordinates of a start point for the next line, decrease the length by 20% and 40% (depending on the branch), and also modify the angle.\nIt is worth noting that the preceding code uses the `Line` record, the code for which is as follows:\n\n```", "```cs\n\n The next part of the code is presented here:\n\n```", "```cs\nfloat xMin = lines.Min(l => Math.Min(l.X1, l.X2));\nfloat xMax = lines.Max(l => Math.Max(l.X1, l.X2));\nfloat yMin = lines.Min(l => Math.Min(l.Y1, l.Y2));\nfloat yMax = lines.Max(l => Math.Max(l.Y1, l.Y2));\nfloat size = Math.Max(xMax - xMin, yMax - yMin);\nfloat factor = maxSize / size;\nint width = (int)((xMax - xMin) * factor);\nint height = (int)((yMax - yMin) * factor);\n```", "```cs\nusing Bitmap bitmap = new(width, height);\nusing Graphics graphics = Graphics.FromImage(bitmap);\ngraphics.Clear(Color.White);\ngraphics.SmoothingMode = SmoothingMode.AntiAlias;\nusing Pen pen = new(Color.Black, 1);\nforeach (Line line in lines)\n{\n    pen.Width = line.GetLength() / 20;\n    float sx = (line.X1 - xMin) * factor;\n    float sy = (line.Y1 - yMin) * factor;\n    float ex = (line.X2 - xMin) * factor;\n    float ey = (line.Y2 - yMin) * factor;\n    graphics.DrawLine(pen, sx, sy, ex, ey);\n}\nbitmap.Save($\"{DateTime.Now:HH-mm-ss}.png\");\n```", "```cs\nbool Go(int row, int col)\n{\n    if (row == size - 1\n        && col == size - 1\n        && maze[row, col])\n    {\n        solution[row, col] = true;\n        return true;\n    }\n    if (row >= 0 && row < size\n        && col >= 0 && col < size\n        && maze[row, col])\n    {\n        if (solution[row, col]) { return false; }\n        solution[row, col] = true;\n        if (Go(row + 1, col)) { return true; }\n        if (Go(row, col + 1)) { return true; }\n        if (Go(row - 1, col)) { return true; }\n        if (Go(row, col - 1)) { return true; }\n        solution[row, col] = false;\n        return false;\n    }\n    return false;\n}\n```", "```cs\nint size = 8;\nbool t = true;\nbool f = false;\nbool[,] maze =\n{\n    { t, f, t, f, f, t, t, t },\n    { t, t, t, t, t, f, t, f },\n    { t, t, f, t, t, f, t, t },\n    { f, t, t, f, t, f, f, t },\n    { f, t, t, t, t, t, t, t },\n    { t, f, t, f, t, f, f, t },\n    { t, t, t, t, t, t, t, t },\n    { f, t, f, f, f, t, f, t }\n};\nbool[,] solution = new bool[size, size];\nPrint method:\n\n```", "```cs\n\n The result is shown here:\n\n```", "```cs\n\n As we conclude this example, it is worth mentioning how the code is simple and short. Thus, you can define the solution to a problem in a clear way. However, keep in mind that if there is more than one path, an algorithm shows only one.\nAfter helping the rat to find a path in a maze, let’s move on to the next example, where you will learn how to automatically solve a Sudoku puzzle.\nA Sudoku puzzle\nHave you ever solved **Sudoku**? It is a very popular game that requires you to **fill empty cells of a 9x9 board with numbers from 1 to 9**. However, **each row, each column, and each 3x3 box must contain only unique numbers**. An exemplary starting board and a solved one are shown as follows:\n![Figure 9.7 – An example of non-solved and solved Sudoku puzzles](img/B18069_09_7.jpg)\n\nFigure 9.7 – An example of non-solved and solved Sudoku puzzles\nNow, you will learn how to solve Sudoku not with the usage of a pencil and a piece of paper but with an algorithm! You can perform this task using the **back-tracking** approach, trying to assign numbers to empty cells if, of course, they meet the conditions regarding unique numbers in each row, column, and box. If an entered number does not result in solving the whole puzzle, you assign another number and perform the check again. Let’s take a look at the most important part of the code:\n\n```", "```cs\n\n At the beginning of the `Solve` method, you get coordinates of the first empty cell. If there are no empty cells, the `GetEmpty` method returns (`true`, indicating that the game is solved.\nOtherwise, you iterate through all possible numbers (namely from 1 to 9), using the `for` loop. In each iteration, you check whether the number can be correctly entered in this cell, using the `IsCorrect` method, ensuring that the number is unique in a row, a column, and a box. If so, you enter this number into the cell and `Solve` method. If it returns `false`, indicating that this variant does not work, you backtrack by clearing the value entered in the cell, which means that it is empty and another variant needs to be used. If no variants lead to the solution, you return `false`.\nThe presented code uses two auxiliary methods, including `GetEmpty`, which searches for the first cell that is not already filled. Its code is as follows:\n\n```", "```cs\n\n The second auxiliary method is named `IsCorrect` and ensures that after entering a provided number in a given cell (with a specified row and column), the board still meets the criteria of the Sudoku game. Its code is presented here:\n\n```", "```cs\n\n At the beginning, you check whether values are unique in a given row and column. The remaining part checks whether a particular 3x3 box contains only unique numbers.\nThe exemplary code for launching the Sudoku solving algorithm is as follows:\n\n```", "```cs\nvoid Print()\n{\n    for (int r = 0; r < 9; r++)\n    {\n        for (int c = 0; c < 9; c++)\n        {\n            Console.Write($\"{board[r, c]} \");\n        }\n        Console.WriteLine();\n    }\n}\n```", "```cs\n7 5 3 4 8 1 9 2 6\n1 6 2 9 5 7 8 4 3\n9 8 4 3 6 2 7 5 1\n6 2 1 8 9 5 3 7 4\n3 9 8 1 7 4 2 6 5\n5 4 7 6 2 3 1 8 9\n8 7 6 5 1 9 4 3 2\n2 3 9 7 4 6 5 1 8\n4 1 5 2 3 8 6 9 7\n```", "```cs\nconst string Genes = \"abcdefghijklmnopqrstuvwxyz\n    #ABCDEFGHIJKLMNOPQRSTUVWXYZ \";\nconst string Target = \"C# Data Structures and Algorithms\";\nRandom random = new();\nint generationNo = 0;\nList<Individual> population = [];\nfor (int i = 0; i < 1000; i++)\n{\n    string chromosome = GetRandomChromosome();\n    population.Add(new(chromosome,\n        GetFitness(chromosome)));\n}\n```", "```cs\nList<Individual> generation = [];\nwhile (true)\n{\n    population.Sort((a, b) =>\n        b.Fitness.CompareTo(a.Fitness));\n    if (population[0].Fitness == Target.Length)\n    {\n        Print();\n        break;\n    }\n    generation.Clear();\n    for (int i = 0; i < 200; i++)\n    {\n        generation.Add(population[i]);\n    }\n    for (int i = 0; i < 800; i++)\n    {\n        Individual p1 = population[random.Next(400)];\n        Individual p2 = population[random.Next(400)];\n        Individual offspring = Mate(p1, p2);\n        generation.Add(offspring);\n    }\n    population.Clear();\n    population.AddRange(generation);\n    Print();\n    generationNo++;\n}\n```", "```cs\nrecord Chromosome and Fitness. The first stores the string adjusted in the evolution, while the other is the number indicating how this particular individual is fit to survive. Of course, a higher value is better.\nThe `Mate` method is used to generate a new individual using two parents:\n\n```", "```cs\n\n The most interesting part of this method is the `for` loop in which the chromosome of the child is created, according to the following rules:\n\n*   **Approximately 45% of genes are taken from the** **first parent**\n*   **Approximately 45% of genes are taken from the** **second parent**\n*   **The remaining 10%** **are randomized**\n\nAnd how can you get a random single gene or generate a random whole chromosome? You just take a look at the code:\n\n```", "```cs\n\n The next necessary method is named `GetFitness`, which simply returns the number of characters that matches the target book title. Its code is as follows:\n\n```", "```cs\n\n Finally, let’s take a look at the `Print` method:\n\n```", "```cs\n\n When you run the code, the best-fitted individual from each generation is presented, as shown in the following output:\n\n```", "```cs\n\n Is this *magic*? No, it’s just the algorithm you wrote that manages the following generations and evolves the individuals, giving you the expected result.\nA password guess\nAs an example of a **brute-force algorithm**, let’s create a program to **generate all possible passwords and trying to guess your secret one**, which consists of small letters and digits only. The program starts with passwords of a length equal to 2 and proceeds until 8.\nThe first part of the code is presented here:\n\n```", "```cs\n\n First, you specify a secret password, which you will try to guess in the remaining part of the code. Then, you create an array with available characters, namely small letters and digits. At the end of this code snippet, the `charsCount` variable stores the number of available characters.\nThe most interesting part of the code is the `for` loop, where each iteration represents a particular length of a password, between two and eight chars. The code is presented here:\n\n```", "```cs\n\n The `indices` array has a length equal to the value of the `length` variable. Each item stores a current index from the `chars` array, indicating the char that is currently placed on the *i*-th location in the string. In each iteration of the `while` loop, you change values in the `indices` array until all possible combinations of the indices are used.\nFurthermore, you save the guessed password in the `guess` variable, and here, it can be either printed on the console or hashed and compared with the hashed password that you want to guess. As this is only a demonstration of a brute-force algorithm, it does not stop its operation when the password is guessed. Thus, you can get more performance results and observe what impact the password length has on the required time for guessing.\nAs you can see, the brute-force approach is very simple, but what about performance? In the preceding code, you can see the usage of `Stopwatch`, so you can get some results. Generating all possible variants of a password consisting of two chars takes less than 1 millisecond. For three- and four-char passwords, the time is also very small, much less than 100 milliseconds. For five-char passwords, the time goes up to about two seconds, while generating passwords of a length equal to six chars takes almost a minute. If you add a mechanism to hash a password and compare it with the target hash, also taking into account that passwords can also contain capital letters and many other chars, the brute-force algorithm seems to be simply impractical in the case of longer passwords.\nIt is worth mentioning that the presented performance results were received on my computer and can be different on other devices. They are shown only to indicate a trend that as a password length increases, the time necessary to guess it is significantly longer with each added character. Thus, it is also a useful tip that you should always use a complicated password that contains small and capital letters, digits, and special characters. Of course, the length of the password is also important.\nSummary\nYou just completed the ninth chapter of this book, which examined data structures and algorithms in the context of the C# language. This time, we focused on practical examples of algorithms, with code snippets, detailed descriptions, and also brief indications of which types of algorithms the aforementioned examples belong to.\nFirst, you learned how to implement a simple algorithm to calculate a given number from the **Fibonacci series** in three variants. You saw a simple recursive approach as well as top-down and bottom-up approaches to dynamic programming.\nThe next example showed the greedy approach to solve the **minimum coin change** problem. It was followed by the divide-and-conquer algorithm to find the **closest pair of points** located on a two-dimensional surface. The fourth example presented a recursive way of **generating fractals** and drawing them on a bitmap.\nThe following two examples were related to back-tracking algorithms to solve the **rat in a maze** and the **Sudoku** puzzles. These examples used recursion as well.\nAnother interesting approach involved a genetic algorithm as a subtype of a heuristic algorithm. It was used to **guess the title of the book**, with the rules of the Darwinian theory of evolution and natural selection.\nThe last example used a brute-force algorithm to **guess a secret password**, by checking all possible variants of passwords. You saw that with the increasing password length, the time necessary to guess it increased significantly.\nNow, it is high time to proceed to the overall summary to take a look at all of the data structures that have been presented in the book so far. Let’s turn the page and proceed to the last chapter!\n\n```", "```cs\n\n```", "```cs\n\n```"]