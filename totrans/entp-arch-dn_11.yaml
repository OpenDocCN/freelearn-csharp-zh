- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Business Processes and Low Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Business processes are all over information systems, and when talking to CEOs,
    they generally inform the way they see IT: as a way of automating the business
    processes of the company, providing reliability, repeatability, and – in the best
    systems – visibility of what happens that brings value to customers, be they internal
    or external. Business processes are at the heart of the company’s information
    system because each activity is generally ported by an instance of a process.
    When the company is certified with ISO 9001, each of the processes in the certified
    perimeter is precisely documented and its use by each of the actors concerned
    can be verified in practice. The processes thus structure the activity of the
    company.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter details how a clean architecture should behave from the business
    process point of view by explaining the notions of business process modeling,
    business activity monitoring, and business process mining, and then by showing
    how business processes can be used in an IT system. Low-code and no-code approaches
    are discussed, as well as BPMN-2.0-based approaches. Throughout the chapter, we
    will provide examples to relate the practice to our demonstration information
    system and make the processes used in IT more concrete. Finally, another approach
    to business processes through service choreography will also be detailed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Business processes and the BPMN approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business process software-based execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other associated practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other approaches to business process implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should I use BPMN in my information system?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you remember well, [*Chapter 5*](B21293_05.xhtml#_idTextAnchor164) introduced
    the idea of a utopic perfect information system that would be made of only three
    modules. **Master Data Management** (**MDM**) was the first one and it has been
    studied in detail in the previous chapter. Now, we will analyze what the second
    module, namely BPM, is all about. In the next chapter, we will end this with a
    thorough explanation of a BRMS. As you will see, the business process approach
    is not currently very widely adopted in information systems, certainly even less
    than the culture of data referential services. The norms and standards are there
    for the taking, but very little implementation can be observed. This is an important
    point to consider, as what will be shown in this chapter is more of an ideal (at
    least for now) than a recommendation to orient existing information systems. Only
    time will tell whether IT gets structured around this solid approach or whether
    the costs will remain too high for widespread use in the IT industry.
  prefs: []
  type: TYPE_NORMAL
- en: Business processes and the BPMN approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first section, we are going to explain in more detail what business
    processes are and how we can model them with a software approach, using, in particular,
    a norm called BPMN. Before talking about processes in the IT world, it is indeed
    interesting to come back to the definition of a process from a purely functional
    point of view, as we always do in this book about business/IT alignment.
  prefs: []
  type: TYPE_NORMAL
- en: What is a business process?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **business process** is a coordinated set of human and automated actions realized
    to reach an objective. The term “*process*” is often replaceable by the almost
    equivalent “workflow”, which better expresses the fact that the actions (or “tasks”)
    are actual work that is being done by a human actor or a piece of software and
    that they are realized in an organized stream (the “flow”) to achieve the business
    goal that the process aims at.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in the introduction, business processes are everywhere in an organization,
    as an “enterprise” is – by definition – a group of people with a means to achieve
    a goal that cannot be reached alone. Processes are the ways an enterprise achieves
    these goals. There is generally a main strategic goal that explains that several
    processes are, in fact, necessary. For example, the strategic objective of a company
    may be to become the world leader in the editing and publication of software books.
    Its strategy could be, for example, to cover all possible subjects in great detail,
    by employing many different expert authors. Working out how this is going to be
    realized requires several smaller, operational objectives. In our example, this
    means a good recruitment process, since finding the right experts for all the
    software subjects will require a well-organized approach. Another operational
    process will be the follow-ups of writing, enlisting editors, correctors, proofreaders,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of process is the first one we generally think of because it is directly
    oriented toward the goal, which here is to produce and sell books. There are two
    other kinds of business processes, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Support processes** are all business workflows necessary so that the company
    goes on working, without being directly related to the goal of the company. In
    profit-oriented companies, paying employees’ salaries is not the strategic objective;
    it is absolutely necessary to keep the company and the processes running, but
    it is not the reason why the company was created. These processes that are not
    established as goals of the company but are necessary for it to realize these
    goals are called supporting processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Piloting processes** are the ones that deal with the governance and analysis
    of the other workflows. One such workflow is the analysis of the activity indicators
    of the company. Another process that can be classified as “piloting” is the management
    of quality, which covers all operational processes and has the goal of continuously
    improving how efficient they are. Governance or piloting processes, just like
    support processes, are not directly operational. The difference with piloting
    processes is that they sit on top of all other processes, whereas support processes
    are dependencies for the operational processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Granularity in the processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we just saw, there often is a main, high-level, strategic objective for an
    organization, and several processes are necessary to realize the different lower-level
    objectives necessary to reach the high-level goal. When grouping the processes
    at such a large granularity, we often talk about macro-processes, because they
    are very general. They are easy to define as such because their objective is not
    a concrete deliverable outcome but a general idea of what a company does. For
    example, one could talk about “commerce” and “production” as macro-processes,
    because their outcomes are very general, respectively getting money from sales
    and producing goods or services. It is hard to say how we could really achieve
    this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: When talking about business processes, in contrast to macro-processes, the outcome
    is quantifiable. For example, producing a car is a business process because we
    can count how many cars leave the factory in a week. Writing software is another
    example of a business process because the outcome is the release of a piece of
    software, together with the ways to exploit it (documentation, setup software,
    etc.). The tasks that compose the business processes are associated with a type
    of actor, such as “assembling the engine,” “writing the summary of the book,”
    or “producing a commercial quote.” This is how they differ from macro-process
    where a single part of the process can necessitate many different profiles, such
    as “product marketing” or “invoicing”. Units inside a macro-process can be business
    processes. In our editing example, the macro-process of “producing books” needs
    a business process to recruit authors, another one to supervise their writing,
    and yet another one to correct the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same idea of level-based decomposition and granularity of processes can
    be observed one level down, by decomposing the different items of a business process
    into detailed steps, which themselves constitute another process, this time a
    fine-grained one, often called a “procedure”. This time, the procedure not only
    states the tasks that have got to take place for each actor, but the precise operation
    that each of them has to carry out to realize a given task of the business process.
    For example, inside the business process of “selling a book”, there may be a task
    called “sending an invoice”. A detailed procedure for this task would be, for
    example, composed of the following “elements of procedure”:'
  prefs: []
  type: TYPE_NORMAL
- en: Every month, list all the customers that have ordered books.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each customer, gather all books and quantities that have been sent from
    the stock database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the packages have indeed been sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the discount agreement with this customer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the total amount due for the books sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subtract possible credits that the customer may have due to book returns or
    warranties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter all this data into the “invoice” template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print two copies and store one at the accounting office.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send out the other copy to the customer using its billing address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This last example may seem a little bit old-fashioned in the virtual world we
    live in today, filled with Customer Relationship Management (CRM) and Enterprise
    Resource Planning (ERP) systems, selling only e-books and ordering/invoicing online.
    The reason why this example is used is two-fold. First, as has been explained
    previously, it is always interesting in business/IT alignment to consider a problem
    by removing anything related to IT. This allows us to concentrate only on the
    functional problem and understand it in its most intricate details before thinking
    about implementing it technically. This way, software-based hypotheses, which
    can lead to coupling, are left out of the scope, at least in the first analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second reason for showing such an old procedure is to illustrate how the
    software implementation of business processes has led us to almost forget them.
    There are good chances that when reading this list of steps, you thought, “No
    one does this manually anymore.” And you would be right: all these operations
    are mostly done by ERPs and dedicated invoicing software applications nowadays.
    But… there has to be at least one person who knows about these steps, and this
    is the person who will design these software applications! As this is what this
    book is about, it is important – once again – to start from a pure and correct
    understanding of the business aspects before trying to implement them in an information
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, establishing this detailed procedure before automating it will allow you
    to gain some insights from business experts. For example, someone from accounting
    will tell you that you forgot about multiple VAT rates you will have to deal with
    if you want to sell internationally. Another person will add that credits should
    not be taken into account if the customer has a debt towards you. Yet another
    colleague may argue that, in some cases, the payer for the order might be a different
    legal person than the one who should receive the invoice. And so on…
  prefs: []
  type: TYPE_NORMAL
- en: The very principle of processes containing some other processes as detailed
    explanations of a single task is one of the important concepts in the business
    process modeling approach and we will see in this chapter how this can be detailed
    in a formalized way. The three main levels are macro-processes, business processes,
    and procedure but, depending on the context, some other levels may appear.
  prefs: []
  type: TYPE_NORMAL
- en: Limits of the processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have been exposed to business processes in an organization as an actor
    in a given task, there are strong chance that you have a bad opinion about them.
    Business processes have suffered from a bad reputation because of many badly-led
    implementations. There are many ways of missing the point with processes and doing
    more harm than good, but let’s start with the way that works. If you want to improve
    your organization with process management, the very first rule is that the processes
    should always reflect what happens in reality.
  prefs: []
  type: TYPE_NORMAL
- en: 'This might sound obvious at the beginning of the process design: most process
    designers will start by looking at what happens in the organization to draw up
    the process. Yet, there still are some organization leaders who think they know
    better how operational people work and will create a process that is not based
    on reality. This, of course, leads to useless processes, and this is why Gemba
    is one of the important concepts in the Lean method, designating the place where
    the value is created. In industrial organizations, that means going to the factory
    floor to understand what really happens.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another fallacy is to believe that, once the process is well established, improvements
    will flow from optimizing its representation. This is a much-observed sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: A process analyst observes the work of an operational team.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process is drawn up and correctly reflects the actual work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process analyst detects a possible optimization in the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An improved version of the process is designed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The team goes on working with the existing process and no improvement is observed
    in reality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is simply another case where one forgets that the process should always
    reflect what happens in reality. The process analysis might find some place for
    improvement but the only way to achieve improvement is when the operational team
    takes this into account and discerns – by itself and within its own organization
    – how to alter its way of working to avoid the problem. Once this is done (and
    most of the time, the solution found by the team will be different from the one
    imagined by the solution analyst), the process should be updated to account for
    the modification done by the operational team and to keep on reflecting it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The worst that can happen is when a business analyst has hierarchical power
    over the operational team and tries to force them into following a process that
    comes out of pure analysis and does not come from operational observation. Except
    purely randomly, there is no chance this process will have a positive effect and
    improve the way that people actually work. What will happen is the contrary: working
    with an unadapted process will lower the operational team’s morale and increase
    the likelihood of people going around the process, or even failing to realize
    the task by finding a flaw in the process and voluntarily acting on it to show
    how bad the process is. Sounds crazy, doesn’t it? Yet it happens every day in
    many companies, simply because people use processes in a bad way, thinking that
    theoretically knowing them can lead to an improvement “on paper.” Processes get
    a bad reputation in this kind of situation, where they are thought to be more
    important or more correct than the actors themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, processes can only be a representation of what happens in a real, concrete
    organization. They may be a great tool to uncover bottlenecks, design solutions,
    and even in some cases simulate them. But the only reality always comes from the
    factory floor and processes can never be more than a useful representation of
    people’s actual work.
  prefs: []
  type: TYPE_NORMAL
- en: Business process modeling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous section may make you think that processes are a bad tool, and indeed,
    they often are. But that does not mean that they cannot be correctly used and
    their advantages, when doing so, are numerous. First, they are a great visual
    way to communicate around coordinated work for a team. Just like a Kanban board
    is a visual way to share a common view of the advancement of a project, a well-formulated
    process is a great way to share a common understanding of how a team works together.
    When a team comes together around a process description, there is almost never
    a case where it doesn’t lead to an interesting optimization, whether this is by
    better sharing the information (“I did not know you were the person doing this
    task; next time, I will inform you directly of this situation that might affect
    your step in the process”) or by proposing different ways of doing things (“What
    if I passed the information directly to the actor after your job? Since they are
    not dependent on your output, they could start right away and the total cycle
    time would be reduced”).
  prefs: []
  type: TYPE_NORMAL
- en: '“Visualization,” “drawn,” “visual way”: all these terms clearly indicate that
    a process should be a graphical reality and, guess what? I am sure you have already
    drawn many processes in your life without even knowing you did so. How about this
    simple diagram?'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – An extremely simple example of a process diagram](img/B21293_11_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – An extremely simple example of a process diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'This is already a process diagram, even if an admittedly very simple one: it
    contains two tasks; they are coordinated (the arrow shows that the second task
    should be done after the first one is complete); and they are done in order to
    reach an objective, namely getting paid for books.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Business Process Modeling** or **Business Process Management** (you will
    find both decompositions used for the **BPM** acronym) are about formalizing such
    processes in a way that any organization process can be described in detail and
    that the process descriptions can be used for more than just graphical representations,
    which means, for example, clear communication about the tasks of every actor,
    change impact analysis, or process optimization, and so on. When talking about
    formalization, you should normally have the reflex by now to think of a norm or
    standard that would help this. The good news is that these exist; the bad news
    is that they were so numerous that it took almost two decades in order to reach
    a point where a single standard is complete and widely accepted as the reference
    for BPMN.'
  prefs: []
  type: TYPE_NORMAL
- en: The history of BPM standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There have been so many approaches in software text-based representation of
    processes that the evolution of those tentative standards and their cooperation,
    competition, and crossovers can be represented as complex chronological diagrams
    that are almost impossible to display on a single page. You will easily find those
    diagrams with an internet search, but since all of this dates back ten years or
    so, there is simply no use in reproducing it here. What might possibly still be
    useful is to trace the big milestones in this work:'
  prefs: []
  type: TYPE_NORMAL
- en: In 2000, the WfMC consortium created WPDL 1.0, having started the design in
    1997.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few years later, it adopted the then-new XML approach and created Wf-XML 1.0,
    followed by a few other versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WPDL itself evolved into an XML-based grammar called XPDL, which was also developed
    into later versions by WfMC, reaching 2.2 in 2009\. This made for an awkward situation
    where two standards were proposed by the same organization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meanwhile, another consortium called BPMI created BPMN around the same time
    as WPDL was released in the early 2000s. **BPMN** stands for **Business Process
    Modeling Notation**. This standard itself reached 1.0 in 2004 and is about representing
    any process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the same time, IBM was working on WSFL, which evolved under a joint effort
    with Microsoft and BEA into BPEL4WS in 2002\. **BPEL** stands for **Business Process
    Execution Language**, and takes a bit of a different approach than BPMN, as it
    insists on the execution of the process and not its representation. BPEL4WS targets
    web services as the means of execution of the processes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OMG is another consortium that is famous for its definition of **Unified Modeling
    Language** (**UML**). This consortium took care of the evolution of BPMN by replacing
    BPMI in 2006 in this work and releasing BPMN 1.1 in 2008\. BPMN exchanged concepts
    with XPDL, rendering the latter less useful in time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OASIS, another well-known consortium, used the same approach for hosting the
    works on BPEL4WS 1.1 and supervised the transformation into WS-BPEL 2.0 in 2007\.
    OASIS had an older standard called ebXML, which was integrated into WS-BPEL 2.0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lack of support for human activity gave birth to BPEL4People in order to
    complement WS-BPEL 2.0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In 2010, OMG released BPMN 2.0, which effectively grouped most of the concepts
    of the existing standards for business process representation into one XML-based
    grammar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The BPMN 2.0 standard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While XPDL continued to evolve for some years after the birth of BPMN 2.0, and
    WS-BPEL 2.0 is still used but only for process-driven execution of web services,
    BPMN 2.0 is generally considered the go-to standard for process representation
    nowadays. Its versatile approach makes it able to model virtually any human or
    machine process from any kind of organization, thus making it possible to apply
    all operations in formats such as visual representation, of course, but also process
    optimization, transformation, and monitoring with dedicated tools. Execution is
    also possible, since the format is very generic, which makes BPMN 2.0 a serious
    contender for even specialized standards such as WS-BPEL 2.0\. Since the latter
    is also coupled to the web service stack, which is largely considered outdated
    in favor of REST API approaches, it looks very much like BPMN 2.0 is the standard
    to learn if you need to use software-based processes.
  prefs: []
  type: TYPE_NORMAL
- en: You will find plenty of resources on the internet to learn about BPMN 2.0 and
    how to design processes with this standard. If you need a starting place, there
    is a great poster containing – in a single image – all concepts of BPMN 2.0 and
    explaining them all including their relationships to each other, which can be
    found at [http://bpmb.de/index.php/BPMNPoster](http://bpmb.de/index.php/BPMNPoster).
    Nothing can be clearer and more concise than this graphical sheet but I will nonetheless
    provide a few quick explanatory notes about the main concepts of BPMN 2.0 as follows,
    in order to make it more accessible to follow the examples in the rest of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the simplest BPMN diagram possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Simplest BPMN diagram](img/B21293_11_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Simplest BPMN diagram
  prefs: []
  type: TYPE_NORMAL
- en: It contains a start event, a task, and an end event. The events have been labeled
    with text, but this is not mandatory, as their representation is enough to distinguish
    them. The task needs some text, though, and the convention is to always use a
    verb in its imperative form to describe the task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The text representation of this process is the following (as output by the
    Camundi design tool – available online at [https://demo.bpmn.io/](https://demo.bpmn.io/)
    – that I have used for most of this book’s figures):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This may appear quite complex because the XML-based BPMN grammar is quite verbose,
    but it is the smallest possible file, as it represents the process above, consisting
    of only one task.
  prefs: []
  type: TYPE_NORMAL
- en: Note that only the first part of the file is an actual BPMN standard representation,
    as can be seen by the use of `bpmn:` prefixes, associated in the header to the
    [http://www.omg.org/spec/BPMN/20100524/MODEL](http://www.omg.org/spec/BPMN/20100524/MODEL)
    namespace. The rest of the file, where the tags are prefixed with `bpmndi`, corresponds
    to proprietary additions from Camundi in order to overload the graphical positioning
    of the elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without going into too many details, one can notice in the first part of the
    XML representation the following:'
  prefs: []
  type: TYPE_NORMAL
- en: As said previously, the representation clearly states what an event is and what
    a task is, even precisely what kind of event is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All entities receive a unique identifier, which makes it possible to link them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flows (which correspond to the arrows in the visual diagram) are also represented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is volunteer duplication of information between the `incoming/outcoming`
    attributes and the `sourceRef/targetRef` attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is an important notion in BPMN, namely that an activity may be a task
    but also a sub-process itself made of several activities. This allows us to implement
    the different levels of granularity we talked about above. It is thus possible,
    in the BPMN standard, to represent a business process where an activity is described
    in a very generic manner like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Representation of a collapsed sub-process](img/B21293_11_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Representation of a collapsed sub-process
  prefs: []
  type: TYPE_NORMAL
- en: 'And, if the tool supports it, the diagram can be simply expanded into the full
    definition of the content, which provides the following representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Expanded representation of a sub-process](img/B21293_11_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Expanded representation of a sub-process
  prefs: []
  type: TYPE_NORMAL
- en: 'In the BPMN standards, tasks can be decorated with an icon that specifies how
    they will be operated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Different kinds of tasks](img/B21293_11_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Different kinds of tasks
  prefs: []
  type: TYPE_NORMAL
- en: 'Events can also be specialized to account for time-based, message-driven, or
    other kinds of events:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Example of specialized events](img/B21293_11_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Example of specialized events
  prefs: []
  type: TYPE_NORMAL
- en: 'If several actors are needed for a given process, they are drawn with what
    resemble – and as described by the official jargon – swimming lanes in a pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Using lanes in a process](img/B21293_11_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Using lanes in a process
  prefs: []
  type: TYPE_NORMAL
- en: 'The last essential concept to know in BPMN is the one of gateways. Gateways
    can derive the stream of a process depending on conditions, and also duplicate
    the sequences in a given portion of the workflow. Two main types of gateways are
    exemplified in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Two main types of gateways in BPMN](img/B21293_11_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Two main types of gateways in BPMN
  prefs: []
  type: TYPE_NORMAL
- en: The first type of gateway shown on the left-hand side is an exclusive gateway
    (symbol **X**), which means only one path can be used (in our example, the manuscript
    can be accepted or rejected by the editor). The second type, using a **+** symbol,
    is a parallel gateway, used to execute multiple tasks before joining and continuing
    the process when all of them are finished (in our example, when all marketing
    operations have been realized, the process reaches its end event).
  prefs: []
  type: TYPE_NORMAL
- en: There are many other things to know about BPMN, but this book is not the place
    to become proficient in using this standard format, so I will just stop with these
    very basic concepts that will be used afterward and advise you to get deeper into
    BPMN if it will help in the modeling of your organization’s business processes.
    If you doubt at some point that BPMN could correctly represent your activity,
    remember that 20 years of experts in consortiums have finally achieved the creation
    of a global standard that is thought to be able to formalize just about any possible
    assembly of human and computerized tasks. Some may be difficult to design but
    this is always because of a lack of knowledge of the standard. With a bit of practice,
    you will be able to model anything with BPMN, and this will, of course, bring
    a lot of value to your information system design activity, because this means
    that all functional activity in it will be detailed and formalized, which will
    highly favor the much-sought alignment of IT.
  prefs: []
  type: TYPE_NORMAL
- en: Business processes software-based execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As explained, using the BPMN standard already has great value in itself: the
    simple fact that you use a formalized way to represent your business processes
    will provide you with great insight and give rise to questions that you might
    have not thought about but that could become important issues once your information
    system is built if you have not taken them into account. But an additional value
    of BPMN is the capacity, once modeled, to execute your processes with the help
    of software, since the formalism of the representation makes it possible for machines
    to interpret the processes and even automatically execute instances of them.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explain the principles behind BPMN and give a few examples
    related to our example information system to give a better understanding of these
    principles. Then, we will explain how BPMN diagrams are decomposed along roles
    and what kind of software we can use to model and run them. Finally, I will propose
    a small explanation as to why BPMN is not more used in the software industry.
  prefs: []
  type: TYPE_NORMAL
- en: Principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The principles of business process execution are very simple: a piece of software
    called a BPM engine reads the XML-based BPMN-compliant representation of a business
    process and can start as many “instances” of this process as you wish. Once started,
    an instance will roughly have the following behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: The instance is saved on disk or to a database, and instances can be read and
    modified at the different steps of their development, which correspond to the
    advancement in the tasks that constitute the processes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each instance of a given process is completely separated from the other instances,
    though they execute the same process definition. How the process is executed in
    the instances may radically differ depending on how gateways are passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once started, an instance follows the process as it was designed at its moment
    of creation. If the process design evolves afterwards, all running instances will
    go on with the old version, in order to keep workflow consistency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Every task in the flow is “executed” by the engine. The actual execution of
    the step depends on its type and on how the engine is configured to handle it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a service task is reached, the execution is supposed to be automatic. An
    API can be called or a connector to an application, and so on.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When a manual task is reached, the engine warns the user that something needs
    to be done by them. This can be done by a notification through email or any other
    channel. When the user has finished the task, they are usually invited to inform
    the BPM engine about this, so that the execution of the instance of the process
    can go on.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When a user task is reached, the user is also informed but since the action
    expected is to fill in a form or at least realize something on a machine, a pointer
    to the required form can be provided in order to speed up the action.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the engine encounters a gateway, it will react differently depending on
    its type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this is a parallel gateway, all subsequent tasks will be run and the engine
    will take care of waiting for all paths to finish before running the rest of the
    process.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If this is an exclusive gateway, the decision engine (we will come back to this
    in more detail in the next chapter) will be activated and the execution of the
    business rules will define which branch should be taken.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On some advanced engines, notifications can be designed in order for stale process
    instances to emit a warning to a functional administrator, in order for them to
    get things done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the end event is reached, the process instance is considered as finished
    and archived. It is not possible to execute anything in it, but it is kept for
    statistics or traceability reasons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Application to our example information system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to comprehend a technology is with examples, and this is why we
    have followed an example of information system design from the beginning of the
    book. Let’s come back to `DemoEditor` and take a look at what business processes
    could be designed – and maybe even automated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example will show how processes accumulate data throughout their
    execution. After all, processes in IT systems most of the time are about creating
    or gathering data. A book is a piece of data, sales are data even if their main
    goal is to bring money to the company, and so on. A process can be seen as a series
    of tasks that create (or not) data. By the end of the process, enough data has
    been created or retrieved to obtain the objective of the process, at least in
    its instance. In the following example, we request information from an editor
    and ask an author to complete this information because the goal of the process
    is to publish complete information about a new author:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Example of BPMN for author enrolling](img/B21293_11_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Example of BPMN for author enrolling
  prefs: []
  type: TYPE_NORMAL
- en: 'The process should be self-explainable, so we are not going to give any details.
    A second example of a business process of `DemoEditor` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – Example of BPMN for contract signing](img/B21293_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – Example of BPMN for contract signing
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, the collection of data may not be as obvious as in the previous
    process diagram, but we still can think of the process this way:'
  prefs: []
  type: TYPE_NORMAL
- en: The first task collects a piece of data, namely the identity of the selected
    author
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one creates some data, because the contract draft will be a document,
    and thus constitutes electronic data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third task may not produce functional data, but the simple fact that the
    author downloads the contract draft to possibly sign it is a signal nonetheless
    and produces data in the information system (even if very simple, such as a log)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How these processes will be executed in the example software will be part of
    [*Chapter 17*](B21293_17.xhtml#_idTextAnchor608). In the present chapter, we only
    show them as examples of what can be done with BPMN and why a BPM engine is one
    of the three parts of the utopic information system architecture described in
    [*Chapter 5*](B21293_05.xhtml#_idTextAnchor164). They also are going to be used
    in the rest of the present chapter to illustrate some points about process execution.
  prefs: []
  type: TYPE_NORMAL
- en: Link to users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now is the good time to come back to a notion that had hitherto been covered
    a bit too swiftly. When talking about how complex diagrams featuring multiple
    participants are cut into “swimlanes” in a “pool” that the process represents,
    the notion of “actor” was introduced to explain that each of these lanes had to
    be associated (and, by convention, named after) an “actor.” It may sound like
    we are talking about a user, but an actor is more generic than this and should
    rather be associated with a group of users (what some would call a *profile*,
    even if this word is normally used to designate cohesive sets of authorizations,
    as in the “role” semantics in the **Role-Based Access** **Control** paradigm).
  prefs: []
  type: TYPE_NORMAL
- en: In the two preceding examples of BPMN diagrams (*Figures* *11.9* and *11.10*),
    the actors were `Editor` and `Author`. In the user directory, groups with equivalent
    names would normally be found. A good BPMN engine always includes a user directory
    supporting groups of users – or even better, can be plugged into a central enterprise
    directory, using for example the standardized LDAP protocol. This allows a level
    of indirection as when talking about the functional process, which specific author
    or editor we are referring to makes no difference. In the first example, a given
    editor will receive an agreement for enrollment and will then send a request for
    information to a given author.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand this notion correctly and not to couple it too
    much to the user’s directory. Associating a BPMN actor/swimlane with a group is
    the most logical approach, but the coupling should not be too hard. For example,
    if it is decided at some point that only a few senior editors can start a contract,
    the process engine should be able to implement this without being dependent on
    the user’s directory to create a new group for these privileged editors. Of course,
    it is more elegant if this is the situation, but again, a technical prerequisite
    should never block a functional request.
  prefs: []
  type: TYPE_NORMAL
- en: The moment when a process is instantiated is also important from the point of
    view of the actors’ selection. The choice of which precise user will correspond
    to the generic definition of an actor in a “swimlane” will generally be realized
    upon instantiation of the process in the BPM engine. Most engines will show a
    dialog asking for who precisely in their user directory will be associated with
    this or that actor/lane in the process pool. Some even allow the definition of
    default user affectation or rules to select users depending on other elements
    of context. For example, we could have a `DemoEditor` process that would automatically
    select the editor associated with an author when the latter sends its manuscript
    for review.
  prefs: []
  type: TYPE_NORMAL
- en: Available software for BPMN edition and execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In such a book that tries to remain generic and push forward standards instead
    of implementations, we are not likely to find examples of vendors, but the uses
    of BPM engines in the industry are so scarce that I thought it could be useful
    to cite a few of them. Of course, I only will list those vendors who play by the
    rules and make the effort to support the BPMN 2.0 standard, instead of trying
    to tempt their customers into vendor lock-in by providing sweet but proprietary
    features. Here are a few BPMN engines (some of them including a graphical editor):'
  prefs: []
  type: TYPE_NORMAL
- en: Bonitasoft ([https://www.bonitasoft.com/library/the-ultimate-guide-to-bpmn2](https://www.bonitasoft.com/library/the-ultimate-guide-to-bpmn2))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activiti ([https://www.activiti.org/userguide/#bpmn20](https://www.activiti.org/userguide/#bpmn20))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bizagi ([https://www.bizagi.com/en/platform/standards](https://www.bizagi.com/en/platform/standards))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kogito ([https://docs.kogito.kie.org/latest/html_single/#ref-kogito-app-examples_kogito-creating-running](https://docs.kogito.kie.org/latest/html_single/#ref-kogito-app-examples_kogito-creating-running))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The market always changes, and new versions and features appear; this is why
    I am not going to recommend or compare these solutions. There are also certainly
    many others that I simply have not been exposed to. This list is there simply
    to serve as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Why so little use of BPMN in the industry?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw, the norms and standards have existed for quite a long time, and the
    BPMN engines are there, up and ready for global use. Yet, the overall use of BPMN
    in the industry is very small. Apart from some very large companies, and only
    within dedicated perimeters, the use of BPMN-based automated processes is very
    scarce, although there is no problem in terms of the price or complexity of the
    norm. In fact, lots of implementations are free and the norm is quite easy to
    learn, even for a non-technical person. Actually, it may even be one of the easiest
    norms to understand for business-oriented people, as it represents their everyday
    job (at least when used properly). So why do so few use it?
  prefs: []
  type: TYPE_NORMAL
- en: One of the reasons may be that automating a process does not bear so much value
    in many cases. Indeed, setting up a BPM engine is quite a complex task and is
    only worth it when this investment is compensated either by an important complexity
    of the process (BPMN drawn up by business specialists and executed “blindly” by
    the software) or by frequent changes in the process definition (which makes it
    interesting to delegate execution to a generic engine, as this will allow the
    rest of the software to remain stable). And when you think about it, lots of business
    processes are not such frequently moving objects. The process of sending invoices
    does not change every month and all regulation-associated processes tend to be
    quite stable. Even operational processes do not change much more often than new
    versions of applications are released.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another reason is that designing a process inside a BPMN file tends to add
    rigidity to it. In lots of organizations, processes are not so clear and depend
    a lot on how humans execute them, sometimes not respecting a common way of doing
    so, and most of the time finding a creative way to the process objective, which
    is – in the end – the only thing that really matters. Sure, this might upset some
    managers who love the feeling of control that processes can provide. But this
    is also one of the drawbacks of processes that was explained previously in this
    chapter: when they tend to replace human choice, they not only bring down team
    morale but also reduce productivity while trying to increase it.'
  prefs: []
  type: TYPE_NORMAL
- en: Or maybe the reason for BPM engines’ low use is just that BPMN remains a bit
    complicated. Of course, the basics of the BPMN 2.0 standard are very easy to understand
    and apply (a box for each task, a lane for each actor, and arrows between tasks
    to show the stream of activities) but the rest of the norm can require much more
    intellectual engagement.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, BPMN 2.0 is not used as widely as it should be because it could
    really bring more value to the IT industry if it was better known and widespread.
    This is why we need to try other solutions, and this is what the last section
    of this chapter is about showcasing some alternatives that may be used as a lighter
    replacement of BPM, hopefully giving it a new boost, even though not based on
    the BPMN 2.0 standard. But before that, we are going to digress just a little
    bit on other operations that can be performed using BPM – process execution is
    definitely the most advanced one, but not the only one that can deliver operational
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Other associated practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automatic execution of processes is the ideal, but BPM comes with loads of other
    advantages, some of them much easier to obtain. This section outlines some of
    these possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Business activity monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Business Activity Monitoring** (**BAM**) is the use of BPMN process representation
    to extract statistics about the sequence flows in instances of business processes,
    and, of course, to gain some insights into the activity represented by the process.
    The following are some examples of such statistics-based questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Which tasks take the longest in the process?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much time does the process take on average?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does this average time vary in a regular time-related pattern? Are there seasons
    where the process is quicker/slower?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the cycle time and lead time in the process?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What changes in execution times have been associated with the deployment of
    a new version of the process?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has automation of a certain task indeed brought productivity improvement to
    the whole?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from the promise of automated execution (which brings repeatability and
    uniformity), BAM is the most sought-after feature that brings managers to BPMN.
    The reason behind this is that managers need indicators to understand how their
    business behaves. And what better indicators could they have than metrics directly
    borne by their business processes?
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of BAM is actually quite simple if you already use a monitoring
    system. In this case, it is only the adding logs on every input and every output
    of the tasks, and then using your aggregation mechanism to derive the desired
    statistics. In addition, showing these values on a graphical representation of
    the process is a must in order to make them easy to understand. Time-based statistics
    can be interesting, but sometimes, only knowing how many times a given task has
    been executed can bring knowledge to the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine we add counters to our second example of the `DemoEditor`
    business process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – Example of BAM](img/B21293_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – Example of BAM
  prefs: []
  type: TYPE_NORMAL
- en: 'The counters are shown at the bottom of the tasks and should be read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**100** instances of the process have been started'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**98** have passed the first task and 2 remain in this state where the author
    has not been selected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**88** have passed the second task and **10** remain at the state of contract
    drafting (which accounts for the **98** from the previous task)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**88** contracts have been sent to authors, and all messages have been acknowledged'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**75** contracts have been downloaded by authors; **13** authors have received
    the message but not processed it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out of these **75**, **15** have rejected the contract and **60** of them have
    signed and sent the approval message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time-based statistics are at the top of the task. In this example, they
    only target the tasks and not the transitions. The format shows the average time
    first, followed by the minimum -> maximum range between parentheses. This kind
    of statistics could allow us to count how many contracts have been sent over the
    time interval; how many have been signed and returned; how long it takes on average
    to draft a contract versus how long it takes for the author to sign it; whether
    reminders should be used to speed up the process or there would be a waste of
    time because authors sign quickly their contract; and so on.
  prefs: []
  type: TYPE_NORMAL
- en: BAM is also helpful for finding bottlenecks in the processes. Sometimes, where
    the process stops is quite easy to find, but in large organizations where roles
    are scattered, authorizations can be delegated and many steps are involved, some
    in different services with other managers and where politics could apply, so finding
    the reason why the whole process has suddenly degraded can be daunting if you
    do not use BAM. This is just like finding a bug in a distributed cloud application
    can be almost impossible if you do not have a good monitoring system in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, BAM can be used to find out whether the recommended process is indeed
    respected. When a process is put in place (of course, together with the team using
    it), it can happen that newcomers are not told about it and they try to follow
    the lead of the seniors in their field. They may miss some steps of the process
    and effective monitoring can bring these mishaps to light for them or the process
    owner. Remediation then simply involves instructing the person on how to carry
    out the task, but it may be interesting to take a deeper approach and start continuous
    improvement on the process itself: how come the person was not correctly instructed
    about the process? What should have prevented this task from being forgotten?
    Since it is evidently easy to do without, shouldn’t this task be fully automated
    in order to be sure nobody forgets it in the future? All these questions will
    improve how the process works but the trigger, in this example, is BAM.'
  prefs: []
  type: TYPE_NORMAL
- en: Business process simulation and optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another use of BPM, less known but quite valuable in some cases, is to simulate
    possible executions of processes in order to find a good balance of material resources,
    tools, and people, and optimize the whole. Imagine for example the following business
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Base for business process optimization](img/B21293_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – Base for business process optimization
  prefs: []
  type: TYPE_NORMAL
- en: 'Having this diagram may prove particularly helpful if you have to deal with
    masses of incoming letters and need to find a way to balance the people doing
    the five tasks. Let’s start with the overly simplified hypothesis that you have
    ten people in your team, each is able to perform any of the tasks, and each task
    takes as much time as any other. You may think a good repartition of people would
    be two people per task… but think again! The **Send response letter** task is
    necessarily called twice as much as the two preceding tasks. You also do not know
    what percentage of mail will be going to the **Update contact form** task: if
    none goes there, then you will gain some time sharing the two persons initially
    affected by this stage on two other sub-teams.'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the aforementioned hypotheses, once you have a statistical repartition
    of the types of mail, you may be able to calculate how you should partition people
    on the different tasks in order to optimize the whole process with a simple calculator.
    If you start to introduce more realistic behavior, like the fact that not all
    tasks take the same time, you will most certainly need a spreadsheet or at least
    some brain power.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that the shares of the incoming mail change seasonally (for example,
    changes of addresses being more frequent at the beginning of the year and in September);
    that all tasks have a given average time, but some with a much higher spread (meaning
    that they can vary significantly around the average time); that some people may
    be able to handle some tasks and not others, depending on their competencies;
    that you have to account for the probability of a person being sick or for the
    fact that people take holidays, though not everyone at the same time due to internal
    team rules… All of this makes for such a complex system that there is no way you
    will be able to determine an optimal repartition of people for the different tasks.
    Luckily, the BPMN representation may help you get an optimal result simply by
    simulating different team organizations and thousands of process instances, then
    determining the total duration and choosing the best configuration depending on
    your criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'Large populations-based optimization applications already exist (for example,
    with genetic-like algorithms or the Monte-Carlo approach) but they all need something
    to quickly simulate how the system responds: this is where a good BPMN engine
    will help because it can execute purely automated tasks that simulate the time
    taken pseudo-randomly. The optimization engine will thus be able to simulate a
    large number of situations, send them to the BPMN engine for virtual execution,
    collect the outcome, and finally converge on an optimal solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Business process mining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, business process mining should be quickly explained, even if it is
    not a use of BPMN, but rather an activity that can be the source of a business
    process. Business process mining (not abbreviated in order to avoid confusion
    with business process management) consists of determining a business process by
    analyzing other data that generally comes from software, typically logs.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a process mining system could use logs appearing on the website,
    together with history tables of invoicing and stocks/expedition metrics, in order
    to determine a standard process that corresponds to the “normal” act of buying
    on an e-commerce shop.
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of other applications of BPMN, but we should not deviate too
    much from our goal, which is to show how business process management can help
    in reaching business/IT alignment. We have seen how process automation is one
    of the uses of BPMN that brings the most value, but also sadly how the investment
    can be quite high, and – for this reason – the industrial uses of such an approach
    do not frequently arise. Some alternative approaches may help in becoming more
    process-oriented while keeping the required investment low, or even in some cases
    without any additional investment than the usual business application.
  prefs: []
  type: TYPE_NORMAL
- en: Other approaches to business process implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will consider all of the methods that offer an alternative
    to BPMN engines executing business processes. We will discover which are the more
    common/more modern ones and will compare their effectiveness. In the end, everything
    depends on the context, but knowing the specificities should hopefully help you
    know when to apply this or that approach.
  prefs: []
  type: TYPE_NORMAL
- en: Process in the GUI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might have not realized but, if you have ever created a software **Graphical
    User Interface** (**GUI**), chances are you have implemented a process without
    even realizing it. All wizards, for example, are processes since they chain screens
    in order to provide a way to add data in a sequential order. The most complex
    ones allow choices, which are the perfect equivalent of gateways in BPMN. They
    also have a beginning and an end, like any process. Wizards are very similar to
    processes, but when we take the simple definition of a business process as a series
    of human and automated tasks organized to reach an objective, then any GUI is
    indeed a process.
  prefs: []
  type: TYPE_NORMAL
- en: Every GUI allows human interactions that are always the start of a simple process.
    This process will collect data through forms, and then run some “service” tasks
    by calling a backend in order to execute some commands. Like wizards, the behavior
    of the GUI will change depending on business rules or values specified in forms
    (again, like gateways) and the end of the process will generally be signaled by
    a toast notification, a dialog box, or simply the fact that the GUI waits for
    another interaction.
  prefs: []
  type: TYPE_NORMAL
- en: You could argue that a process in the GUI is really a human process where the
    user follows a process within the software. However, a good GUI leads the user
    into a particular way of using it that tends to mimic the business process. This
    is obvious in the case of a wizard, but it also happens in a GUI that has been
    designed with UX competency. Of course, in the simplest interfaces like a command
    line, a very large part – if not all – of the process execution is in the hands
    of the user. But the simple fact that arguments are named after data collected
    by the BPMN process is already a help in respecting the represented workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Process in higher-level APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While we are at simple solutions to the orchestration question, having dedicated
    APIs that implement an organized sequence of calls to other, simpler, APIs is
    also a documented approach. In fact, this is a well-known API structure, organizing
    them in three layers, each building on the one below:'
  prefs: []
  type: TYPE_NORMAL
- en: The first level is the CRUD APIs, which are used to manipulate and read a single
    business entity. This is the kind of API that we talked about in the previous
    chapter when explaining the concept of MDM and showing how it could be implemented
    with REST APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second level is about APIs that compose several first-level API calls in
    order to realize a complex operation in the system. For example, one such API
    could be exposed as `/api/contract` and its `POST` verb implementation could call
    `GET` on `/api/authors` to verify the author is already registered, then make
    a `POST` call to the same API if this is not the case. After that, the code would
    call the service dedicated to proposing a contract amount, then finally reach
    the `/api/pdf-fusion` service in order to retrieve the address of the document
    created and sent to the electronic document management system (of course, using
    the CMIS standard). At any time where a failure happens, this implementation would
    have rules to know what it should do and, in the worst case, would provide notifications
    to a human to clean up the remaining situations that are too complex for the computer
    to resolve.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third level is used to adjust APIs to their callers. This time, they do
    not necessarily compose several calls but rather add some arguments to the request,
    adjust and filter some content to the response, and so on. These tertiary APIs
    are typically used to provide a “backend for a frontend” and, for example, adjust
    the default pagination and sets of attributes retrieved for a mobile application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When using an API gateway to include general features such as authentication,
    authorization, rate limiting, and counting accesses for invoices, the server used
    can be considered as another level, but it does not sit on top of the three levels
    described above. Since it can be used to expose any level, a better representation
    is to show it on the side of the three levels of business-oriented APIs, providing
    a technical coating for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – The three levels of APIs](img/B21293_11_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – The three levels of APIs
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the examples chosen in this schema, APIs on different levels
    do not necessarily use different expositions. For example, it could be decided
    that the API exposing the authors together with their past books uses the `/api/authors`
    route just like the CRUD API exposition of the authors alone does. One rationale
    for this would be to respect the Open Data Protocol standard, and in particular,
    the `$expand` grammar that is well adapted to this case. The API would nonetheless
    be a second-level one.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of this approach to implementing a business process inside
    an API is that it greatly respects the principle of single responsibility. A drawback
    is that the implementation will either be in code, which is more difficult to
    evolve, or with a BPMN engine but, in this case, this creates some coupling to
    a technology. There of course is a bit of coupling when choosing a BPMN engine,
    but using it in many API implementations definitely increases this level of dependency
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have shown two “simple” ways to implement business processes in
    software, let’s analyze some more complex ones. We will start with dedicated middleware
    servers, which we previously talked about in the context of service-oriented architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Process in a MOM/ESB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B21293_08.xhtml#_idTextAnchor271), the notion of middleware
    was introduced and a few well-known implementations were presented, including
    **Message-Oriented Middleware** (**MOM**) and **Enterprise Service Bus** (**ESB**).
    These can of course be used to implement processes and orchestrate the different
    messages or service calls that will practically realize the tasks of a given business
    process. Though MOMs and ESBs do not understand BPMN, the use of **Enterprise
    Integration Patterns** (**EIPs**) can be enough to make a business process concrete,
    then executed and monitored in the middleware.
  prefs: []
  type: TYPE_NORMAL
- en: You might look at this last sentence, as I recommend introducing business functions
    inside the middleware, while I stated in [*Chapter 10*](B21293_10.xhtml#_idTextAnchor344)
    that all business rules should always be inside the MDM service associated with
    the entity bearing it. Is there a possible paradox here? In fact, there is not
    if you make use of the Single Responsibility Principle. When talking about business
    functions that are the responsibility of a given service, it is important that
    the services are clearly made responsible for each function. For example, if an
    accounting service needs the net price for a book and the book service only contains
    the raw price without VAT, it is important not to take the easy path of applying
    the VAT rate inside the middleware simply because it is quicker and will avoid
    a change and the deployment of a new version of the book MDM service. The books
    and all their attributes are clearly under the responsibility of the books referential
    service, another attribute has to be added to the list of what it exposes (which
    does not harm backward compatibility, so should not have any impact if clients
    are correctly written).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, let’s say that when an editor decides a book should be discontinued,
    the command should delete the reference from the CRM and from the commercial website,
    but also set the status of the book to `archived` in the books referential service.
    Clearly, the action will be sent to the book referential service first, but who
    should decide about the other actions? We could ask the data referential service
    to send a message to the CRM and the website, but that would make a clear coupling
    with these applications. Neither the CRM nor the website should be in control
    of this interaction since none of them is supposed to be responsible for what
    happens at the book entity level. The responsibility of this grouped set of commands
    is not unique, and thus hard to give to a single service.
  prefs: []
  type: TYPE_NORMAL
- en: 'How the middleware solves this is by providing another application that is
    responsible for these “orchestration” tasks. It sits on top of messages and has
    only the responsibility of handling them and routing them to whatever service
    needs them. Note that the middleware application does not know anything about
    the content of the message; it simply takes care of the fact that a `DELETE` operation
    on `/api/books` should be sent to the book MDM service, the CRM, and the website.
    What they do with it is none of its business. Of course, there are details that
    should be sorted out. For example, how should the middleware react if one of the
    services sends an error? Is it its responsibility to cancel the transaction and
    ask other services to roll back what they have done? These questions will be addressed
    a bit further on in this section but, for now, keep in mind the old proverb “dumb
    pipes, smart endpoints”: the middleware should never embed any business rules
    other than pure orchestration, which is the simple dispatch of messages and nothing
    else.'
  prefs: []
  type: TYPE_NORMAL
- en: Low-code/no-code approaches to processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have almost certainly heard about the low-code/no-code movement in the industry
    lately. The idea behind these approaches is that specialized platforms can make
    it possible for non-developers to create **Line-Of-Business** (**LOB**) software
    applications by removing most or all code and proposing visual editors to create
    forms, workflows, data structures, and so on. In a way, they contain everything
    that is necessary to create a complete system, just like the utopic system we
    talked about does. The difference resides in the fact that they do so with graphical
    editors and the user never has to type a line of text-based code (or almost, in
    the low-code approach, as opposed to the no-code approach that demands that not
    a single line of code is typed).
  prefs: []
  type: TYPE_NORMAL
- en: Lots of polemics have surrounded these approaches and their associated platforms,
    some presenting them as a revolution allowing the appearance of the “citizen developer”,
    and others explaining that the code logic and algorithms are still there, simply
    in a non-textual form. For them, these platforms are not much more than the next
    avatar of an old promise that went over code generation, fourth-generation frameworks,
    previous approaches of graphical integrated development platforms… and of course,
    all the applications that have been created with the most versatile tool ever,
    which is Excel. As an architect, I try to step away from these opinions and stay
    focused on the kind of value that such tools can bring.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, better tooling may be an answer to the difficulty expressed above
    on the limited use of BPMN engines in the industry. Just like MOMs, BPMN engines
    are quite complex systems and require some setup, maintenance, and expertise.
    With its focus on the simplicity of use by non-developers (I was about to write
    “non-technical persons,” but that would be far-fetched, as you definitely require
    a technically oriented mind to use them), perhaps the low-code/no-code tools could
    be a way to provide an easy-to-use orchestration that would allow the business
    process execution approach to become more widely used?
  prefs: []
  type: TYPE_NORMAL
- en: 'This could happen in two different ways, depending on the kind of tools one
    uses. The first family of tools is the easiest one to use for process automation:
    namely, platforms that are data-driven. As the ideal information system clearly
    separates MDM and business process management (and business rules management),
    that may sound a bit weird, but the concept of reification will help get out of
    this separation. The word “*reification*” means the making of something into a
    concrete entity, typically a relationship between two entities. In the case of
    processes, they can be seen as a series of tasks that contribute to acquiring
    data, but we could also apply reification and consider that an instance of the
    process itself is data, after all. This is how data-driven no-code systems, such
    as Airtable for example, deal with business processes: they simply store data
    about the process in their data structures, each line corresponding to an instance
    of a process. In addition, this is made easier by the fact that most simple processes
    target mainly one business entity, which means that the process and the associated
    entity can simply be turned into the same entity, managed by the MDM that Airtable
    and the like actually are.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s model a process of onboarding for Human Resources. The target
    entity is an employee which concerns the onboarding process. We will thus simply
    create a data structure for these onboarded employees, and complete it with data
    that is more process-oriented, typically the date of entry (beginning of the process),
    the date of full integration (end of the onboarding process), the URL to the picture
    that has been taken of the new employee on their first day at work, maybe a pointer
    to the signed document of IT charts they were required to approve, and so on.
    As you can see, data from the processes and data about the employees themselves
    sometimes have blurred boundaries. For example, the date of joining the company
    is the start of the onboarding process, but this remains important data for the
    employee long after the end of the onboarding process, as it is used by HR to
    calculate how many additional vacation days the person receives (determined by
    how long they have been with the company).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a second family of tools that can be classified as *no code* since
    they allow graphical-only operations: these are the light orchestration tools
    such as Zapier, IFTTT, and many others that are similar in their use. These platforms
    allow us to create simple interactions by binding an event (for example, when
    a GMail account receives an email with an attachment) to an action (storing the
    file in a OneDrive account, under a given directory named `Pictures`). The GUI
    to create these interactions can go a bit further, for example by allowing an
    intermediate task that will filter files based on their extensions and stop if
    the attachment detected does not end with `.png` or `.jpg`, but this will generally
    be the most sophisticated use you can have. This limitation is compensated for
    by providing lots of connectors to third-party platforms. I cited Google Mail
    and Microsoft OneDrive in the example, but there are hundreds or thousands of
    editors that have made their applications accessible with these tools. Exposing
    a public API is generally a prerequisite to doing so, and we will see shortly
    that webhooks can also be very useful here.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – Zapier example](img/B21293_11_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – Zapier example
  prefs: []
  type: TYPE_NORMAL
- en: 'Some platforms such as Microsoft Power Apps are more sophisticated while keeping
    the same approach of associating business events with actions. Simply, they make
    it easier to add intermediate filters, duplicate messages, and so on. They could
    be considered as an implementation of EIPs in their functional approach but, since
    they do not respect the names of the patterns, they are not eligible for this.
    An advantage they have, though, is that EIPs’ implementations are written in Java
    or with a technical **Domain Specialized Language** (**DSL**), both of which are
    code, necessitating true developers to be involved. Let’s not think that the replacement
    of this text by a visual diagram editor radically changes the skills necessary
    to implement “flows,” as they are sometimes called: one needs a developer-oriented
    mindset to be able to set up Microsoft Power Apps workflows correctly. In this
    way, this kind of tool is really *low code* rather than *no code*, since part
    of them, such as the complex attributes mapping functions, involve a programming
    language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To end this section, simply know that low-code/no-code tools can be great tools
    to implement an MDM, but also BPM and BRMS. It is easy to create an information
    system with them but beware: the technical coupling to the platform can be very
    high. If your goal is to design an industrial-grade, long-term evolving information
    system, the most important aspect will always be business/IT alignment, and the
    technical coupling may make you miss some important things and degrade your system’s
    performance. Still, they can be great tools to prototype the orchestration or
    the entity’s definition. And if you keep a clear separation between your services
    behind contract-first APIs, these low-ceremony tools can be absolutely great as
    an implementation of the “dumb pipes,” while API implementations are the “smart
    endpoints.”'
  prefs: []
  type: TYPE_NORMAL
- en: Choreography instead of orchestration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For now, we have only talked about orchestration when considering executing
    a business process in a software approach: in every implementation exposed, something
    (a middleware, a BPMN engine, or a low-code platform) was at the center of the
    game, receiving messages and looking at events from one side, and sending commands
    to services on the other side. What happens in this case when this central router
    fails? Since it is a **Single Point of Failure** (**SPOF**), the whole system
    halts, which is of course a problem. Some people will argue that ESBs have distributed
    brokers and that a network failure can be handled by the broadcasting approach,
    delivering the message even in the case of technical incidents. But the functional
    logic remains centralized and, if a route is badly designed, it may affect the
    whole system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, imagine you have the following process to automate (we
    only represent the first three layers of the CIGREF map, as the hardware layer
    would not change anything here):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15 – Example of a process to be automated](img/B21293_11_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.15 – Example of a process to be automated
  prefs: []
  type: TYPE_NORMAL
- en: After analyzing the content of an incoming letter that has been OCR-ized by
    SimpleOCR, the binary document is stored in the EDM (for example, a Community
    version of Alfresco). If a signature is required, the signing book (implemented
    perhaps by the iXParapheur software) is called and, finally, the signed document
    is also sent to Alfresco to be stored alongside the unsigned version.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the orchestration approach, a BPMN engine, such as Kogito, would
    be added to the software layer (and its function in the BCM) and the file corresponding
    to the business process would be in the same layer, as this is a software artifact.
    Kogito would then call all the functions needed when an instance of the process
    is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16 – Automation by orchestration](img/B21293_11_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.16 – Automation by orchestration
  prefs: []
  type: TYPE_NORMAL
- en: 'It can easily be seen that if the `proc1.bpmn` file, there is a serious problem
    and the whole process will go down. This is how harmful an SPOF is to an organization.
    But it could be even worse in terms of evolution and SPOF: imagine that, instead
    of selecting best-of-breed applications for the different functions in the BCM,
    we had chosen the “fully integrated” approach, with SharePoint used for storing
    the file (**Docs** in the following diagram), its OCR features, and also for the
    workflows (**WFW** in the following diagram) it features. The result would be
    the highly-coupled one below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17 – Higher coupling with integrated orchestration](img/B21293_11_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.17 – Higher coupling with integrated orchestration
  prefs: []
  type: TYPE_NORMAL
- en: In this case, if there is a failure in SharePoint, not only will the process
    be down, but also all the features implemented by this server. And since they
    are most likely used by many other business processes in your organization, the
    SPOF now carries more risk than ever. Of course, Microsoft has a very robust implementation
    of SharePoint 365, but you may lose internet access. And if you think you will
    be better off running SharePoint locally, think again because you will never reach
    the level of robustness Microsoft can provide for its own solution, however gifted
    your admins are. So how can we get rid of this SPOF problem for the process execution?
  prefs: []
  type: TYPE_NORMAL
- en: One radical answer to this problem is to simply eliminate all kinds of centralized
    authority and keep only what is absolutely necessary for the messages to flow
    between the services, which is a network connection. That may sound quite harsh
    but, after all, if we really want dumb pipes, how much dumber can they be than
    simple TCP/IP packets? HTTP and in particular, HTTPS, will add some welcomed low-level
    features such as streaming encryption and receipt acknowledgment, but they will
    remain completely agnostic from the business point of view, which is what we define
    as “dumb”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eliminating any centralized orchestration is realized by setting up what is
    called “choreography.” In the orchestration approach, just like in musical orchestras,
    there is a leader who directs the rhythm and tone of all instruments from a physically
    centralized position. In choreography, a group of dancers does not follow a single
    leader, but each adjusts by observing their neighbors, just like in flocks of
    birds or fish. For example, when moving left, a dancer will stare at the feet
    of their left neighbor; then, when going right, they will synchronize with the
    dancer on the other side. In these groups, there is no “main dancer” but only
    a group that is used to working together. By the way, this means that there still
    is some kind of leader: when learning their choreography, a choreographer will
    explain the expected moves to the group of dancers, show how they can synchronize,
    and so on. Practice will then make it so that, once dancing is “in production,”
    the team will no longer need a choreographer. This goes the same in IT choreography:
    you need an architect to tell each service what signal they should listen to and
    what their reaction should be. But once set up, the system is on its own and the
    architect can simply monitor that everything is going as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, implementing this choreographic approach for our process would
    be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18 – Low-coupling choreography](img/B21293_11_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.18 – Low-coupling choreography
  prefs: []
  type: TYPE_NORMAL
- en: 'There would simply not be any additional software because each application
    would look out for events on the other applications. As a consequence, there would
    be no possible SPOF. In order to implement the process, the “registrations” would
    be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The EDM would wait for a signal from the OCR stating a new document has been
    analyzed. Upon this signal, the EDM would store this document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The signing book would wait for a signal that a new document was stored and
    would use the business rule to filter documents that need to be signed. This could
    be done in two ways:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The signing book could get all the documents and decide by itself depending
    on the metadata whether the document needs to be signed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Even better, if the EDM application supports this, it could tell this application
    to only notify it for specific documents by registering with a “filter expression”
    that the EDM could apply. This would reduce bandwidth and improve performance,
    as only documents actually requiring a signature would be notified to the signing
    book for handling.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The EDM would also wait for signals from the signing book software (just like
    it would for signals coming from the OCR platform) and store the signed document
    when such an event happens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The great thing about not having an SPOF is that all parts not concerned by
    a failure will continue to work in the system. For example, if, for one reason
    or another, the signing book software is not available (let’s say it is a SaaS
    application and your internet connection is down), the rest of the process will
    work fine: documents that do not need any signature will simply be sent to the
    EDM and stored; the problem will only be that documents needing to be signed would
    not be presented for signature (but they would still be stored in the EDM in their
    original form). We will see a bit further in this section that we could even put
    in place a “safety net” so that events are not lost and documents to be signed
    eventually reach the signing book once it is back online.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing choreography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most logical and least-coupled ways to implement this kind of choreographic
    approach is to use webhooks. We talked about webhooks in [*Chapter 8*](B21293_08.xhtml#_idTextAnchor271)
    already and saw they are a great way to invert the order of service. In the context
    of choreography, webhooks are a great way to eliminate all centralized orchestration,
    since the responsibilities are shared between two components only: the emitter
    and the receiver. The emitter can store requests for callbacks on certain events
    and takes care of sending a message to these callback URLs when the business event
    happens in their service. On the other hand, the receiver needs to register for
    the emitter’s events it wants to know about, provide a callback URL and listen
    to it, and deal with the message once it arrives. Almost everything (we will see
    later that a few things *are* missing) is handled by those two participants.'
  prefs: []
  type: TYPE_NORMAL
- en: Then why do platforms like Zapier or IFTTT exist, you might ask? Simply because
    webhooks and business events are not standardized yet. OpenAPI version 3.0.2 supports
    webhook definitions, but it is not complete yet and very few editors support it
    for now. And it will definitely take a long time to define some standards for
    technical events, let alone business-oriented ones. What Zapier and the like bring
    to the game is a centralized market of proprietary connectors to hundreds of LOB
    applications, and this is why they are still in the game. Their value can also
    be in simple flows that could be implemented with only a webhook plugged into
    an API, because using them in the middle provides you with monitoring, error detection,
    automatic retries, and notifications of durable failures, among others.
  prefs: []
  type: TYPE_NORMAL
- en: But in pure theory, it would be possible to implement your **Event-Driven Architecture**
    (**EDA**) (this is the accepted jargon to define this generalized approach) simply
    by registering webhooks on all the services in your information system, telling
    them to call back APIs exposed by others. This would however require that all
    messages be standardized and a global convention on defining all available business
    events to exist.
  prefs: []
  type: TYPE_NORMAL
- en: As always, the devil lies in the details, and everything would work fine in
    such an ideal EDA system until a packet is lost by the dumb pipes, or a network
    card goes down. Since everything is synchronous and in memory, such a technical
    incident would result in a functional loss, with potential business impacts, low
    or catastrophic, depending on what has been lost. This is of course something
    that cannot be tolerated in an industry-grade system and the reason why, for important
    data streams, it is a good idea to keep some kind of middleware, such as a message-queuing
    system. The principle is to keep the pipes dumb, though, and this is where it
    gets difficult because, once a distributed broker is set up, it is hard to restrain
    its use to just orchestration. There may be good reasons to do so because this
    approach can be more adapted to other contexts than the choreography-based one.
  prefs: []
  type: TYPE_NORMAL
- en: Queuing systems will allow for the robust delivery of messages. If you also
    need the ability to go back in time and do some event sourcing (such as for CQRS,
    in order to implement Big Data complex calculation, or even to ease eventual consistency),
    then you may go as far as deploying specialized distributed systems such as Apache
    Kafka. Again, this is quite a heavy machinery to pull up, so be particularly careful
    with the balance between losing messages from time to time (and we really are
    talking about infrequent events, as modern networks are much more resilient than
    their ancestors) and paying for all the extra cost of a middleware (as a rule
    of thumb, you can consider that an average-sized middleware will cost you one
    Full-Time Equivalent). Remember in particular that even huge players in e-commerce
    accept the loss of consistency and implement many strategies to reduce the consequences
    (limited time to retain a basket, stock management and acceptance of reservation
    only if there is enough stock, improved reimbursement if the lock of the product
    failed, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: Again, remember that functional alignment is key. When thinking about how dangerous
    it is to miss an event, do not take a technical approach that will immediately
    draw you into firing up the big guns; think only in functional terms, imagining
    an information system without any piece of software. How could you compensate
    for this? Maybe one way would be that the next time you receive an order event,
    you check with the emitter that all orders that have been passed since the indicated
    date and time; normally, there should only be the one that triggered the event
    but if you missed the previous one, you are now informed about it. Another way
    to implement consistency could be to double the webhook approach with an automated
    job that will query all new orders every five minutes and verify they have indeed
    been treated as they should. If you really want to take it to the next level,
    you could even set up a self-healing system that clones all important data from
    its neighboring services and only reacts to time-based and interaction-based events
    to perform its duties, while always keeping and communicating a value date on
    its operations.
  prefs: []
  type: TYPE_NORMAL
- en: When I talk about this functional-first approach with software architects, they
    generally tend to reply that a good transactional system will take care of consistency,
    allowing us to get rid of these functional complications. Or that Apache Kafka
    is best for this kind of problem and will be the solution – sometimes without
    having a documented estimation of the cost of such solutions. Though this can
    be acceptable at times (again, it all depends on the context), getting the deepest
    possible understanding of the business always brings value to a software architect.
    One should also remember that, even though the technical approach seems to cover
    perfectly the difficulties, there is always a way to fail as well, and this should
    be taken into account (this danger is high when these technologies are SPOFs).
    On the other hand, when you have a clear understanding of how functionally consistent
    your system has to be, failure is included in the debate and thus cannot cause
    surprises anymore. **The functional approach is the only way to solve a problem
    as** **a whole.**
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested in digging into this deeper, a good starting point is
    to understand how sagas work (quickly said, sagas are a way to re-create transactions
    when you have separated your persistence into several databases, as the MDM and
    SRP propose to do in order to reduce coupling). The great article at [https://microservices.io/patterns/data/saga.html](https://microservices.io/patterns/data/saga.html)
    shows how to implement them with orchestration and choreography. Please note,
    though, that in both cases a MOM is necessary, so we still return to the same
    conclusion: since transactions are a technical solution, they cannot fully cover
    a functional problem; if you really want a global solution, you have to provide
    a fully functional solution. In this case, this is about finding business rules
    for eventual consistency and implementing them. As you are probably used to doing
    by now, the best way to find this functional solution is to imagine an office
    without any computer: how would you go about ensuring consistency over a complex
    workflow, for example, a business case that requires two people working in sequence?
    Most simply, you would alternate synchronous calls with asynchronous callbacks:
    “Here is the file, call me when you are done.” And when the callback is made,
    this would trigger passing the business case to the next person, with the same
    request. When the second one tells the initiator they have finished this part
    of the job, the whole process can be considered as complete. If there is a stall
    at any position, the initiator can request the status of the job. If the request
    has been lost at some point, it can be sent again. When one of the executing agents
    expresses they are done with their unit of work, the initiator may be used to
    send them another one, which is great to avoid overloading the agents and building
    up buffers, which are bad for performance at scale.'
  prefs: []
  type: TYPE_NORMAL
- en: Should I use BPMN in my information system?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The length of this chapter may indicate that I am truly passionate about using
    processes for software information system integration. To be fully transparent,
    I have long been against processes as I had been mostly exposed to their bad aspects:
    constraining people into working in a way that has been decided away from the
    people actually doing the work, being rigid as a working process tends to block
    any innovation since “it has always worked this way”, and so on. Following two
    **Massive Open Online Courses** (**MOOCs**) from France Université Numérique (French
    Digital University) named CARTOPRO (mapping business processes) and PILOPRO (using
    business processes to pilot an organization) completely changed my mind by showing
    me the power of BPM when used correctly, which means the process is designed by
    the team using it (the BPMN expert is only there to help them with the BPMN standard
    and ask the right questions) and continuous improvement is at the base of the
    whole process strategy. In fact, I went as far as continuing the two MOOCs with
    an additional digital diploma from the University Jean Moulin (Lyon 3) in France,
    for which my thesis work was on Agile method process representation (a challenge,
    since the very first recommendation in the Agile Manifesto is “people over processes”).'
  prefs: []
  type: TYPE_NORMAL
- en: Why do I tell this personal information? Simply to stress even more the fact
    that, even if it might surprise you very much, I generally do not recommend using
    BPMN engines in your architecture of an information system. I know that may sound
    weird after all I have said and demonstrated here, and particularly since BPM
    is part of this ideal information system that I have tried to show how to reach
    since the beginning of the book. But after many attempts at using this approach
    in production, I can now honestly say that the tools and – more generally – the
    understanding of BPM are, in most organizations, not developed enough for a true
    BPM approach to be worthy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hear me well: I am not saying that the approach does not have value at all.
    If you have a given business process that is complex or moving frequently, the
    investment may be worth it. But this is a very particular case when you will have
    to meet the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: This process is core to your business and you know it will last for years, or
    even be so important that it will stay for as long as the company is around
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You know that the tools are not completely stable and you are prepared to change
    the implementation of a BPMN engine in the middle of the project if needed, considering
    all costs and consequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have the right expertise for BPM modeling and the maintenance of the BPMN
    engine, and you are aware that the chances are you will never be able to group
    this in a single person
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Management understands that turning the workflow of the team into a process-driven
    approach will require training for everyone and a process of change management
    that will be long and complex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you check all these boxes, you have a lot of work in front of you but you
    are in for a treat at the end of this project as, once the investment is done,
    the returns are phenomenal: modifying the implementation of a process by changing
    a few files when the strategy of the company needs to adjust is really the cherry
    on top of a well-aligned information system. You will need to go through decoupling,
    appropriate separation of responsibilities, the long evolution of legacy systems,
    and all the aforementioned BPM hurdles, but once you get there, the information
    system will not only be the spine of your organization… it will be its main asset.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered the second part of the utopic information system,
    namely **business process management**, after talking about MDM. Though the BPMN
    2.0 standard is not much used in the standard LOB systems, it is definitely a
    mature norm, and the tooling is quite complete for edition and runtime. Sadly,
    the use of BPMN 2.0 is still not soaring, which is a pity as it can truly help
    adapted information systems to evolve smoothly. Maybe low-code/no-code approaches
    will achieve a better result at making functional changes easier and less dependent
    on IT people; only time will tell.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming chapter, we will cover the third and final part of the utopic
    information system, which is **business rules management**. We will show what
    this expression covers, how it can be integrated with the two other responsibilities,
    provide examples based on our demonstration information system scenario and, of
    course, discuss how such a function should be implemented with which software
    applications and observing which general recommendations.
  prefs: []
  type: TYPE_NORMAL
