<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Advanced Concepts of C# and .NET"><div class="titlepage" id="aid-LTSU2"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Advanced Concepts of C# and .NET</h1></div></div></div><p>We've seen how the C# language evolved in early versions, 2.0 and 3.0, with important features, such as generics, lambda expressions, the LINQ syntax, and so on.</p><p>Starting with version 4.0, some common and useful practices were eased into the language (and framework libraries), especially everything related to synchronicity, execution threads, parallelism, and dynamic programming. Finally, although versions 6.0 and 7.0 don't include game-changing improvements, we can find many new aspects intended to simplify the way we write code.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">New features in C# 4: covariance and contravariance, tuples, lazy initialization, Dynamic programming, the <code class="literal">Task</code> object and asynchronous calls.</li><li class="listitem">The async/await structure (belongs to C# 5).</li><li class="listitem">What's new in C# 6.0: string interpolation, Exception filters, the <code class="literal">NameOf</code> operator, null-conditional operator, auto-property initializers, static using, expression bodied methods and index initializers.</li><li class="listitem">News in C# 7.0: Binary Literals, Digit Separators, Local Functions, Type switch, Ref Returns, Tuples, Out var, Pattern Matching, Arbitrary async returns and Records.</li></ul></div><div class="section" title="C# 4 and .NET framework 4.0"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec16"/>C# 4 and .NET framework 4.0</h1></div></div></div><p>With the release of Visual <a id="id251" class="indexterm"/>Studio 2010, new versions of the framework showed up, although that was the last time they were aligned (to date). C# 5.0 is linked to <a id="id252" class="indexterm"/>Visual Studio 2012 and .NET framework 4.5, and C# 6, appeared in Visual Studio 2015 and was related to a new (not too big) review of .NET framework: 4.6. The same happens to C#7, although this is aligned with Visual Studio 2017.</p><p>Just to clarify things, I'm including a table that shows the whole evolution of the language and the frameworks aligned to them along with the main features and the corresponding version of Visual Studio:</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>C# version</p>
</th><th valign="bottom">
<p>.NET version</p>
</th><th valign="bottom">
<p>Visual Studio</p>
</th><th valign="bottom">
<p>Main features</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>C# 1.0</p>
</td><td valign="top">
<p>.NET 1.0</p>
</td><td valign="top">
<p>V. S. 2002</p>
</td><td valign="top">
<p>Initial</p>
</td></tr><tr><td valign="top">
<p>C# 1.2</p>
</td><td valign="top">
<p>.NET 1.1</p>
</td><td valign="top">
<p>V. S. 2003</p>
</td><td valign="top">
<p>Minor features and fixes.</p>
</td></tr><tr><td valign="top">
<p>C# 2.0</p>
</td><td valign="top">
<p>.NET 2.0</p>
</td><td valign="top">
<p>V. S. 2005</p>
</td><td valign="top">
<p>Generics, anonymous methods, nullable types, iterator blocks.</p>
</td></tr><tr><td valign="top">
<p>C# 3.0</p>
</td><td valign="top">
<p>.NET 3.5</p>
</td><td valign="top">
<p>V. S. 2008</p>
</td><td valign="top">
<p>Anonymous types, var declarations (implicit typing), lambdas, extension methods, LINQ, expression trees.</p>
</td></tr><tr><td valign="top">
<p>C# 4.0</p>
</td><td valign="top">
<p>.NET 4.0</p>
</td><td valign="top">
<p>V. S. 2010</p>
</td><td valign="top">
<p>Delegate and interface generic variance, dynamic declarations, argument improvements, tuples, lazy instantiation of objects.</p>
</td></tr><tr><td valign="top">
<p>C# 5.0</p>
</td><td valign="top">
<p>.NET 4.5</p>
</td><td valign="top">
<p>V. S. 2012</p>
</td><td valign="top">
<p>Async/await for asynchronous programming and some other minor changes.</p>
</td></tr><tr><td valign="top">
<p>C# 6.0</p>
</td><td valign="top">
<p>.NET 4.6</p>
</td><td valign="top">
<p>V. S. 2015</p>
</td><td valign="top">
<p>Roslyn services and a number of syntax simplification features.</p>
</td></tr><tr><td valign="top">
<p>C# 7.0</p>
</td><td valign="top">
<p>.NET 4.6</p>
</td><td valign="top">
<p>V. S. 2017</p>
</td><td valign="top">
<p>Syntatic "sugar", extended support for tuples, Pattern Matching, and some minor features.</p>
</td></tr></tbody></table></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Table 1: Alignment of C#, .NET, and Visual Studio versions</em></span></p></blockquote></div><p>So, let's start with delegate and interface generic variance, usually called covariance and contravariance.</p><div class="section" title="Covariance and contravariance"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Covariance and contravariance</h2></div></div></div><p>As more developers adopted the previous techniques shown in <a class="link" title="Chapter 2. Core Concepts of C# and .NET" href="part0018.xhtml#aid-H5A41">Chapter 2</a>, <span class="emphasis"><em>Core Concepts of C# and .NET</em></span>, new<a id="id253" class="indexterm"/> necessities came up and new mechanisms appeared to provide<a id="id254" class="indexterm"/> flexibility were required. It's <a id="id255" class="indexterm"/>here where some already well-known principles will apply (there were theoretical and practical <a id="id256" class="indexterm"/>approaches of compilers and authors, such as Bertrand Meyer).</p><div class="note" title="Note"><h3 class="title"><a id="note14"/>Note</h3><p>
<span class="emphasis"><em>Luca Cardelli</em></span> explains as far back as in 1984 the <a id="id257" class="indexterm"/>concept of variant in OOP (refer to <span class="emphasis"><em>A semantics of multiple inheritance</em></span> by Luca Cardelli (<a class="ulink" href="http://lucacardelli.name/Papers/Inheritance%20(Semantics%20of%20Data%20Types).pdf">http://lucacardelli.name/Papers/Inheritance%20(Semantics%20of%20Data%20Types).pdf</a>).</p></div><p>Meyer referred to the need for <a id="id258" class="indexterm"/>generic types in the article <span class="emphasis"><em>Static Typing</em></span> back in 1995 (also available at <a class="ulink" href="http://se.ethz.ch/~meyer/publications/acm/typing.pdf">http://se.ethz.ch/~meyer/publications/acm/typing.pdf</a>), indicating that <span class="emphasis"><em>for safety, flexibility, and efficiency, the proper combination</em></span> (he's talking about static and dynamic<a id="id259" class="indexterm"/> features in a language) <span class="emphasis"><em>is, I believe, static typing and dynamic binding</em></span>.</p><p>In other seminal work, nowadays widely used, <span class="emphasis"><em>ACM A.M. Turing Award</em></span> winner <span class="emphasis"><em>Barbara Liskov</em></span> published his famous <span class="emphasis"><em>Substitution Principle</em></span>, which states that:</p><div class="blockquote"><blockquote class="blockquote"><p>"In a computer program, if S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., objects of type S may substitute objects of type T) without altering any of the desirable properties of that program (correctness, task performed, etc.)."</p></blockquote></div><div class="note" title="Note"><h3 class="title"><a id="note15"/>Note</h3><p>Some ideas about covariance<a id="id260" class="indexterm"/> and contra-variance are explained in an excellent explanation published by Prof. Miguel Katrib and Mario del Valle in the already extinct <span class="emphasis"><em>dotNetMania</em></span> magazine. However, you <a id="id261" class="indexterm"/>can find it (in Spanish) at <a class="ulink" href="https://issuu.com/pacomarin3/docs/dnm_062">https://issuu.com/pacomarin3/docs/dnm_062</a>.</p></div><p>In short, this means that if we have a type, <code class="literal">Polygon</code>, and two subtypes, <code class="literal">Triangle</code> and <code class="literal">Rectangle</code>, which inherit from the former, the following actions are valid:</p><div class="informalexample"><pre class="programlisting">Polygon p = new Triangle();
Polygon.GreaterThan(new Triangle(), new Rectangle());</pre></div><p>The concept of variance is related to situations where you can use classes, interfaces, methods, and delegates defined over a type <code class="literal">T</code> instead of the corresponding elements defined over a subtype or super-type of <code class="literal">T</code>. In other words, if <code class="literal">C&lt;T&gt;</code> is a generic entity of type <code class="literal">T</code>, can I substitute it for another of type <code class="literal">C&lt;T1&gt;</code> or <code class="literal">C&lt;ST&gt;</code>, <code class="literal">T1</code> being a subtype of <code class="literal">T</code> and <code class="literal">ST</code> a super-type of <code class="literal">T</code>?</p><p>Note that in the proposal, basically, the question arises where can I apply Liskov's substitution principle and expect correct behavior?</p><p>This capability of some languages is called (depending on the direction of the inheritance) covariance for the subtypes, and its counterpart, contravariance. These two features are absolutely linked to parametric polymorphism, that is, generics.</p><p>In versions 2.0 and 3.0 of the language, these features were not present. If we write the following code in any of these versions, we will not even get to compile it, since the editor itself will notify us about the problem:</p><div class="informalexample"><pre class="programlisting">List&lt;Triangle&gt; triangles = new List&lt;Triangle&gt;
{
  new Triangle(),
  new Triangle()
};
List&lt;Polygon&gt; polygons = triangles;</pre></div><p>Even before compiling, we will be advised that it's not possible to convert a triangle into a polygon, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00454.jpeg" alt="Covariance and contravariance"/></div><p style="clear:both; height: 1em;"> </p><p>In the previous<a id="id262" class="indexterm"/> example, the solution is easy when we use C# 4.0 or higher: we can convert the <code class="literal">triangles</code> assignment to <code class="literal">List&lt;Polygon&gt;</code> by calling the generic type converter for <code class="literal">List</code> just by adding a simple call:</p><div class="informalexample"><pre class="programlisting">List&lt;Polygon&gt; polygons = triangles.ToList&lt;Polygon&gt;();</pre></div><p>In this case, LINQ extensions come to our rescue, since several converters were added to collections in order to provide them with these type of convenient manipulations, which simplify the use object's hierarchies in a coherent manner.</p><div class="section" title="Covariance in interfaces"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec24"/>Covariance in interfaces</h3></div></div></div><p>Consider this code, where<a id="id263" class="indexterm"/> we change the defined polygons identifier as type <code class="literal">IEnumerable&lt;Polygon&gt;</code>:</p><div class="informalexample"><pre class="programlisting">IEnumerable&lt;Polygon&gt; polygons2 =
  new List&lt;Triangle&gt; {
  new Triangle(), new Triangle()};</pre></div><p>This doesn't lead to a compilation error because the same ideas are applied to interfaces. To allow this, the generic parameter of interfaces such as <code class="literal">IEnumerable&lt;T&gt;</code> is used only as an out value. In such cases, it's interesting to take a look at the definition using the <span class="strong"><strong>Peek Definition</strong></span> option (available on the editor's context menu for any type):</p><div class="mediaobject"><img src="../Images/image00455.jpeg" alt="Covariance in interfaces"/></div><p style="clear:both; height: 1em;"> </p><p>In turn, the <code class="literal">IEnumerable</code> interface only defines the <code class="literal">GetEnumerator</code> method in order to return an iteration mechanism to go through a collection of <code class="literal">T</code> types. It's only used to return <code class="literal">T</code> by means of the <code class="literal">Current</code> property and nothing else. So, there's no danger of the possible manipulation of elements in an incorrect manner.</p><p>In other words, according to <a id="id264" class="indexterm"/>our example, there's no way you can use an object of type <code class="literal">T</code> and place a rectangle where a triangle is expected because the interface specifies that <code class="literal">T</code> is used only in an exit context; it's used as a return type.</p><p>You can see the definition of this in Object Browser, asking for <code class="literal">IEnumerator&lt;T&gt;</code>:</p><div class="mediaobject"><img src="../Images/image00456.jpeg" alt="Covariance in interfaces"/></div><p style="clear:both; height: 1em;"> </p><p>It's not the same situation, though, when you use another interface, such as <code class="literal">IList</code>, which allows the user to change a type once it is assigned in the collection. For instance, the following code generates a compilation error:</p><div class="informalexample"><pre class="programlisting">IList&lt;Polygon&gt; polygons3 =
  new List&lt;Triangle&gt; {
  new Triangle(), new Triangle()};</pre></div><p>As you can see, the code is just the same as earlier, only changing the type of generic interface used for the <code class="literal">polygons3</code> assignment. Why? Because the definition of <code class="literal">IList</code> includes an indexer that you could use to change the internal value, as Object Explorer shows.</p><p>Like any other indexer, the <a id="id265" class="indexterm"/>implementation provides a way to change a value in the collection by a direct assignment. This means that we can write this code to provoke a breach in the hierarchy of classes:</p><div class="informalexample"><pre class="programlisting">polygons3[1] = new Rectangle();</pre></div><p>Notice the definition of interface <code class="literal">IList&lt;T&gt;</code>: <code class="literal">this[int]</code> is read/write, as the next capture shows:</p><div class="mediaobject"><img src="../Images/image00457.jpeg" alt="Covariance in interfaces"/></div><p style="clear:both; height: 1em;"> </p><p>This is due to the ability to set an item in the collection to another value once it is created, as we can see in the preceding screenshot.</p><p>It's worth noting that this <code class="literal">out</code> specification is only applicable when using the interface. <code class="literal">Types</code> derived from <code class="literal">IEnumerable&lt;T&gt;</code> (or any other interface that defines an <code class="literal">out</code> generic parameter) are not obliged to fulfill this requirement.</p><p>Furthermore, this covariance is only applicable to reference types when using references' conversion statements. That's the reason why we cannot assign <code class="literal">IEnumerable&lt;int&gt;</code> to <code class="literal">IEnumerable&lt;object&gt;</code>; such conversion implies boxing (the heap and the stack are implicated), so it's not a <a id="id266" class="indexterm"/>pure reference conversion.</p></div><div class="section" title="Covariance in generic types"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec25"/>Covariance in generic types</h3></div></div></div><p>Covariance can be extended <a id="id267" class="indexterm"/>to generic types and used with predefined delegates (remember, those delegates supplied by the Framework Factory that can be of types <code class="literal">Action</code>, <code class="literal">Predicate</code>, and <code class="literal">Func</code>).</p><p>To place a simple code that shows this feature, observe the following declaration:</p><div class="informalexample"><pre class="programlisting">IEnumerable&lt;Func&lt;Polygon&gt;&gt; dp =
  new List&lt;Func&lt;Rectangle&gt;&gt;();</pre></div><p>Here, we're assigning a list of delegates of type <code class="literal">Rectangle</code> to an enumerable of delegates of type <code class="literal">Polygon</code>. This is possible because three characteristics play their role:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">Rectangle</code> is assignable to <code class="literal">Polygon</code> for Substitution Principle</li><li class="listitem"><code class="literal">Func&lt;Rectangle&gt;</code> is assignable to <code class="literal">Func&lt;Polygon&gt;</code> due to covariance in the generic <code class="literal">out T</code> parameter of <code class="literal">Func&lt;T&gt;</code></li><li class="listitem">Finally, <code class="literal">IEnumerable&lt;Func&lt;Rectangle&gt;&gt;</code> is assignable to <code class="literal">IEnumerable&lt;Func&lt;Polygon&gt;&gt;</code> due to a covariance extension over the generic type <code class="literal">out T</code> of <code class="literal">IEnumerable</code></li></ul></div><p>Note that the mentioned Substitution Principle should not be mistaken with the convertible character of some types (especially, primitive or basic types).</p><p>To illustrate this feature, just think of the following definitions:</p><div class="informalexample"><pre class="programlisting">IEnumerable&lt;int&gt; ints = new int[] { 1, 2, 3 };
IEnumerable&lt;double&gt; doubles = ints;</pre></div><p>The second sentence generates a compilation error because although there is an implicit conversion from <code class="literal">int</code> to <code class="literal">double</code>, such conversion is considered for covariance, since this is only applicable to inheritance relations between types, and that is not the case with <code class="literal">int</code> and <code class="literal">double</code> types because none of them inherits from the other.</p></div><div class="section" title="Covariance in LINQ"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec26"/>Covariance in LINQ</h3></div></div></div><p>Another situation in which <a id="id268" class="indexterm"/>covariance is important shows up when using some of the operators defined by the LINQ syntax. This happens, for instance, with the <code class="literal">Union</code> operator.</p><p>In previous versions, consider that you try to code something like this:</p><div class="informalexample"><pre class="programlisting">polygons = polygons.Union(triangles);</pre></div><p>If you code something like the preceding code, you will get a compilation error, which doesn't happen from version 4.0 onward. This is because in the renewed definition, parameters of operator <code class="literal">Union</code> use the mentioned covariance, since they are of type <code class="literal">IEnumerable&lt;T&gt;</code>.</p><p>However, it's not possible to compile something like this:</p><div class="informalexample"><pre class="programlisting">var y = triangles.Union(rectangles);</pre></div><p>This is because the compiler<a id="id269" class="indexterm"/> indicates that there's no definition of <code class="literal">Union</code> and the best method overload, <code class="literal">Queryable.Union&lt;Program.Rectangle&gt; (IQueryable&lt;Program.Rectangle&gt;, IEnumerable&lt;Program.Rectangle&gt;)</code>, requires a receiver of type <code class="literal">IQueryable&lt;Program.Rectangle&gt;</code>, as shown in the upcoming screenshot.</p><p>This can be avoided this time by means of helping the compiler understand our purpose via generics:</p><div class="informalexample"><pre class="programlisting">var y = triangles.Union&lt;Polygon&gt;(rectangles);</pre></div><p>Observe the way in which the <span class="strong"><strong>Error List</strong></span> window describes the error, justifying it in terms of proper source code elements and their definitions and capabilities (see the following screenshot):</p><div class="mediaobject"><img src="../Images/image00458.jpeg" alt="Covariance in LINQ"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Contravariance"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec27"/>Contravariance</h3></div></div></div><p>The case of contravariance is <a id="id270" class="indexterm"/>different and usually a bit more difficult to understand. To comprehend things through a known example, let's remember the <code class="literal">IComparer&lt;T&gt;</code> interface that we used in the previous chapter.</p><p>We used an implementation of <code class="literal">IComparer&lt;T&gt;</code> to compare collections of types <code class="literal">Customer</code> and <code class="literal">Provider</code> indistinctly:</p><div class="informalexample"><pre class="programlisting">public class GenericComparer : IComparer&lt;IPersonBalance&gt;
{
  public int Compare(IPersonBalance x, IPersonBalance y)
  {
    if (x.Balance &lt; y.Balance) { return -1; }
    else if (x.Balance &gt; y.Balance) return 1;
    else { return 0; }
  }
}</pre></div><p>In this way, we can compare both types as long as the <code class="literal">Customer</code> and <code class="literal">Provider</code> classes implement the <code class="literal">IPersonBalance</code> interface.</p><p>In previous (to C# 4.0) versions of the language, consider that you tried to use a similar code to compare polygons and triangles, as follows:</p><div class="informalexample"><pre class="programlisting">// Contravariance
IComparer&lt;Polygon&gt; polygonComparer = new
  ComparePolygons();
triangles = triangles.Sort(polygonComparer);</pre></div><p>You will then get an error indicating the usual: there's no conversion between <code class="literal">Triangle</code> and <code class="literal">Polygon</code>, while there's really no risk in receiving these types since no change will happen; they will only be used to compare the entities.</p><p>In this case, the inheritance arrow goes upside down—from the specific to the generic—and since both are of type <code class="literal">Polygon</code>, the comparison should be possible.</p><p>Starting from version 4.0 of C#, this was changed. The new definition of the <code class="literal">IComparer</code> interface defines another <code class="literal">in</code> modifier for the <code class="literal">T</code> operator, using the <span class="strong"><strong>Peek Definition</strong></span> feature when you right-click on the declaration:</p><div class="mediaobject"><img src="../Images/image00459.jpeg" alt="Contravariance"/></div><p style="clear:both; height: 1em;"> </p><p>As you can see, the definition indicates that parameter <code class="literal">T</code> is contravariant: you can use the type you specified or any type that is less derived, that is, any antecessor of the type in the inheritance chain.</p><p>In this case, the <code class="literal">in</code> modifier <a id="id271" class="indexterm"/>specifies this possibility and indicates to the compiler that type <code class="literal">T</code> can only be used in entry contexts, such as what happens here because the purpose of <code class="literal">T</code> is to specify the type of entry arguments <code class="literal">x</code> and <code class="literal">y</code>.</p></div></div><div class="section" title="Tuples: a remembrance"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Tuples: a remembrance</h2></div></div></div><p>From very early times, programming languages try to express the idea of tuples, first embodied in the COBOL language. Later, Pascal followed it up with the concept of record: a special type of data structure that, unlike arrays, collects data types of different natures in order to define a particular structure, such as a customer or a product.</p><p>Let's also remember that the <a id="id272" class="indexterm"/>C language itself provided structures (structs) enhanced into objects in the C++ evolution. Usually, every field of this structure represents<a id="id273" class="indexterm"/> a characteristic of the whole, so it makes more sense to access its value through a meaningful description instead of using its position (like in arrays).</p><p>This idea was also related to the database relational model, so it was particularly suitable to represent these entities. With objects, functionalities are added to recreate fragments of real object properties that are required to be represented in an application: the object model.</p><p>Then, in the interest of reusability and adaptability, OOP started promoting objects to hide parts of its state (or the whole state) as a means to preserve its internal coherence. <span class="emphasis"><em>Methods of a class should only have the purpose of maintaining the internal logic of its own state</em></span>, said a theoretician at the beginning of an OOP class in a well-known university whose name I don't want to remember. We can admit that, exceptions aside, this assertion is true.</p><p>If there are parts of the state that can be abstracted (in math terms, you could say that they constitute a pattern), they are candidates for a higher class (abstract or not), so reusability starts with these common factors.</p><p>Along this evolution, the concept of tuple got lost in a way, ceding all the land to the concept of object, and programming languages (with some notable exceptions, mainly in the area of functional languages) ceased to have their own notation in order to work with tuples.</p><p>However, practice has shown that not all work with data requires the wearing of uniform objects. Perhaps one of the most obvious situations shows up when querying data from a database—the way we've seen in LINQ queries. Once the filtered data meets certain requirements, we only need some components (which is known as a projection in the jargon of databases, as we've tested in previous examples).</p><p>This projections are nothing but anonymous objects, which don't deserve to be predefined, since they're usually handled in a single procedure.</p></div><div class="section" title="Tuples: implementation in C#"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Tuples: implementation in C#</h2></div></div></div><p>The implementation<a id="id274" class="indexterm"/> of tuples in .NET 4 is based on the definition (<code class="literal">mscorlib.dll</code> assembly and the <code class="literal">System</code> namespace) of eight generic classes <code class="literal">Tuple&lt;&gt;</code> with different number of type parameters to represent tuples of different cardinalities (it's also called arity).</p><p>As a complement to this family of generic classes, eight overloads of the <code class="literal">Create</code> method in the <code class="literal">Tuple</code> class are provided, converting it into a factory of many possible variations of these types. In order to deliver resources for the creation of longer tuples, the eighth tuple in the list can also be a tuple itself, allowing it to grow as required.</p><p>The following code shows the implementation of one of these methods. Thus, to create tuples, we can take advantage of a more concise notation and write this:</p><div class="informalexample"><pre class="programlisting">Tuple.Create(1, 2, 3, 4, 5);</pre></div><p>We'll discover how the Intellisense system of Visual Studio warns us about the structure generated by this declaration and how it is interpreted by the editor:</p><div class="mediaobject"><img src="../Images/image00460.jpeg" alt="Tuples: implementation in C#"/></div><p style="clear:both; height: 1em;"> </p><p>So, we can express it in this simple way instead of using the following, more explicit code:</p><div class="informalexample"><pre class="programlisting">new Tuple&lt;int,int,int,int,int&gt;(1, 2, 3, 4, 5);</pre></div><p>Since tuples can hold elements of any kind, it is alright to declare a tuple of a variety of types:</p><div class="informalexample"><pre class="programlisting">Tuple.Create("Hello", DateTime.Today, 99, 3.3);</pre></div><p>This is similar to what we would do when defining the elements of an object's state, and we can be sure that the compiler will infer its different types, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00461.jpeg" alt="Tuples: implementation in C#"/></div><p style="clear:both; height: 1em;"> </p><p>This usage becomes obvious when comparing it with a typical record in the database's table, with the ability of<a id="id275" class="indexterm"/> vertically selecting the members (fields, if you want) that we need. We're going to see an example of comparing tuples with anonymous types.</p></div><div class="section" title="Tuples: support for structural equality"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Tuples: support for structural equality</h2></div></div></div><p>With the tuples .NET classes (and, therefore, their bodies treated by reference), comparing two tuples with the <code class="literal">==</code> operator is referential; that is, it relies on memory addresses where the <a id="id276" class="indexterm"/>compared objects reside; therefore, it returns <code class="literal">false</code> for two different objects-tuples even if they store identical values.</p><p>However, the <code class="literal">Equals</code> method has been redefined in order to establish equality based on the comparison of the values of each pair of corresponding elements (the so-called structural equality), which is desired in most tuple's applications and which is also the default semantics for the comparison of tuples' equality in the F# language.</p><p>Note that the implementation of structural equality for tuples has its peculiarities, starting with the fact that tuples with a tupled eighth member have to be accessed in a recursive manner.</p></div><div class="section" title="Tuples versus anonymous types"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Tuples versus anonymous types</h2></div></div></div><p>For the case of projections, tuples adapt perfectly and allow us to get rid of anonymous types. Imagine that we <a id="id277" class="indexterm"/>want to list three fields of a given <code class="literal">Customers</code> table (say, their <code class="literal">Code</code>, <code class="literal">Name</code>, and <code class="literal">Balance</code> fields from dozens of possible fields), and we need to filter them by their <code class="literal">City</code> field.</p><p>If we assume that we have a collection of customers named <code class="literal">Customers</code>, it's easier to write a method in this manner:</p><div class="informalexample"><pre class="programlisting">static IEnumerable&lt;Tuple&lt;int, string, double&gt;&gt; CustBalance(string city)
{
  var result =
    from c in Customers
    where c.City == city
    orderby c.Code, c.Balance
    select Tuple.Create(c.Code, c.Name, c.Balance);
  return result;
}</pre></div><p>So, the method returns <code class="literal">IEnumerable&lt;Tuple&lt;int, string, double&gt;&gt;</code>, which we can refer where required, having extra support from the Intellisense engine and making it very easy to iterate and present in the output.</p><p>To test this feature, I've generated <a id="id278" class="indexterm"/>a random name list from the site (<a class="ulink" href="http://random-name-generator.info/">http://random-name-generator.info/</a>) named <code class="literal">ListOfNames.txt</code> in order to have a list of random customer names, and I have populated the rest of fields with random values so that we have a list of customers <a id="id279" class="indexterm"/>based on the following class:</p><div class="informalexample"><pre class="programlisting">public class Customer
{
  public int Code { get; set; }
  public string Name { get; set; }
  public string City { get; set; }
  public double Balance { get; set; }

  public List&lt;Customer&gt; getCustomers()
  {
    string[] names = File.ReadAllLines("ListOfNames.txt");
    string[] cities = { "New York", "Los Angeles", "Chicago", "New Orleans" };
    int totalCustomers = names.Length;
    List&lt;Customer&gt; list = new List&lt;Customer&gt;();
    Random r = new Random(DateTime.Now.Millisecond);
    for (int i = 1; i &lt; totalCustomers; i++)
    {
      list.Add(new Customer()
      {
        Code = i,
        Balance = r.Next(0, 10000),
        Name = names[r.Next(1, 50)],
        City = cities[r.Next(1, 4)]
      });
    }
    return list;
  }
}</pre></div><div class="note" title="Note"><h3 class="title"><a id="note16"/>Note</h3><p>There are quite a lot of random name generators you can find on the Internet, besides the ones mentioned previously. You can just configure them (they allow a certain degree of tuning) and save the results in a text file within Visual Studio. Only, remember that the copy and paste operation will most likely include a Tab code (<code class="literal">\t</code>) separator.</p></div><p>In the <code class="literal">TuplesDemo</code> class, which holds the entry point, the following code is defined:</p><div class="informalexample"><pre class="programlisting">static List&lt;Customer&gt; Customers;
static IEnumerable&lt;Tuple&lt;int, string, double&gt;&gt; Balances;
static void Main()
{
  Customers = new Customer().getCustomers();
  Balances = CustBalance("Chicago");
  Printout();
  Console.ReadLine();
}

static void Printout()
{
  string formatString = " Code: {0,-6} Name: {1,-20} Balance: {2,10:C2}";
  Console.WriteLine(" Balance: Customers from Chicago");
  Console.WriteLine((" ").PadRight(32, '-'));
  foreach (var f in Balances)
    Console.WriteLine(formatString, f.Item1, f.Item2, f.Item3);
}</pre></div><p>With this structure, everything<a id="id280" class="indexterm"/> works fine, and there's no need to use anonymous objects, as we can see in the Console output:</p><div class="mediaobject"><img src="../Images/image00462.jpeg" alt="Tuples versus anonymous types"/></div><p style="clear:both; height: 1em;"> </p><p>The only imperfection comes from the way we make references to <code class="literal">Balance</code> members, since they lose the type names, so we have to reference them by the identifiers <code class="literal">Item1</code>, <code class="literal">Item2</code>, and so on (this has been improved in version C# 7 where tuples' members can have identifiers).</p><p>But even so, this is an<a id="id281" class="indexterm"/> advantage with respect to the previous approach, and we have more control over the generated members coming out of the LINQ query.</p></div><div class="section" title="Lazy initialization and instantiation"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Lazy initialization and instantiation</h2></div></div></div><p>To finish this review <a id="id282" class="indexterm"/>on the most important features appearing in C# 4.0, I'd like to cover a new way of the instantiation of objects, named lazy initialization. The official documentation defines lazy objects and lazy initialization of an object, indicating that its creation is deferred until it is first used. (Note, here, that both terms are<a id="id283" class="indexterm"/> synonymous: initialization and instantiation).</p><p>This reminds us that <span class="emphasis"><em>Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements</em></span>. Typically, this happens when you have an object that takes some time to create (like a connection) or, for any reason, might produce a bottleneck.</p><p>Instead of creating the <a id="id284" class="indexterm"/>object in the usual way, .NET 4.0 introduces <code class="literal">Lazy&lt;T&gt;</code>, which defers the creation effectively, allowing evident performance improvements, as we'll see in the following demo.</p><p>Let's use the previous code, but this time, we double the method for the creation of customers by adding a lazy version of it. To be able to prove it more accurately, we introduce a delay in the constructor of the <code class="literal">Customer</code> class, so it finally looks like this:</p><div class="informalexample"><pre class="programlisting">public class Customer
{
  public int Code { get; set; }
  public string Name { get; set; }
  public string City { get; set; }
  public double Balance { get; set; }
  public Customer()
  {
    // We force a delay for testing purposes
    Thread.Sleep(100);
  }
  public List&lt;Customer&gt; getCustomers()
  {
    string[] names = File.ReadAllLines("ListOfNames.txt");
    string[] cities = { "New York", "Los Angeles", "Chicago", "New Orleans" };
    int totalCustomers = names.Length;
    List&lt;Customer&gt; list = new List&lt;Customer&gt;();
    Random r = new Random(DateTime.Now.Millisecond);
    for (int i = 1; i &lt; totalCustomers; i++)
    {
      list.Add(new Customer()
      {
        Code = i,
        Balance = r.Next(0, 10000),
        Name = names[r.Next(1, 50)],
        City = cities[r.Next(1, 4)]
      });
    }
    return list;
  }

  public List&lt;Lazy&lt;Customer&gt;&gt; getCustomersLazy()
  {
    string[] names = File.ReadAllLines("ListOfNames.txt");
    string[] cities = { "New York", "Los Angeles", "Chicago", "New Orleans" };
    int totalCustomers = names.Length;
    List&lt;Lazy&lt;Customer&gt;&gt; list = new List&lt;Lazy&lt;Customer&gt;&gt;();
    Random r = new Random(DateTime.Now.Millisecond);
    for (int i = 1; i &lt; totalCustomers; i++)
    {
      list.Add(new Lazy&lt;Customer&gt;(() =&gt; new Customer()
      {
        Code = i,
        Balance = r.Next(0, 10000),
        Name = names[r.Next(1, 50)],
        City = cities[r.Next(1, 4)]
      }));
    }
    return list;
  }
}</pre></div><p>Note two main differences: first, the constructor forces a delay of a tenth of a second for every call. Second, the new <a id="id285" class="indexterm"/>way to create the <code class="literal">Customer</code> list (<code class="literal">getCustomersLazy</code>) is declared as <code class="literal">List&lt;Lazy&lt;Customer&gt;&gt;</code>. Besides, every call to the constructor comes from a lambda expression associated with the <code class="literal">Lazy&lt;Customer&gt;</code> constructor.</p><p>In the <code class="literal">Main</code> method, this time, we don't need to present the results; we only need to present the time elapsed for the creation of <code class="literal">Customers</code> using both approaches. So, we modified it in the following way:</p><div class="informalexample"><pre class="programlisting">static List&lt;Customer&gt; Customers;
static List&lt;Lazy&lt;Customer&gt;&gt; CustomersLazy;
static void Main()
{
  Stopwatch watchLazy = Stopwatch.StartNew();
  CustomersLazy = new Customer().getCustomersLazy();
  watchLazy.Stop();
  Console.WriteLine(" Generation of Customers (Lazy Version)");
  Console.WriteLine((" ").PadRight(42, '-'));
  Console.WriteLine(" Total time (milliseconds): " +
    watchLazy.Elapsed.TotalMilliseconds);
  Console.WriteLine();

  Console.WriteLine(" Generation of Customers (non-lazy)");
  Console.WriteLine((" ").PadRight(42, '-'));
  Stopwatch watch = Stopwatch.StartNew();
  Customers = new Customer().getCustomers();
  watch.Stop();
  Console.WriteLine("Total time (milliseconds): " +
  watch.Elapsed.TotalMilliseconds);
  Console.ReadLine();
}</pre></div><p>With these changes, the same class is called, and the same sentences are also used in creation, only changed to be <a id="id286" class="indexterm"/>lazy in the first creation process. By the way, you can change the order of creation (calling the non-lazy routine in the first place) and check whether there's no meaningful change in performance: the lazy structure executes almost instantly (hardly some more than 100 milliseconds, which is the time forced by <code class="literal">Thread.Sleep(100)</code> in the initial creation of <code class="literal">Customer</code>).</p><p>The difference, as you can see in the following screenshot, can be significant:</p><div class="mediaobject"><img src="../Images/image00463.jpeg" alt="Lazy initialization and instantiation"/></div><p style="clear:both; height: 1em;"> </p><p>So, a new and useful solution for certain scenarios that appeared in version 4.0 of the framework becomes especially interesting when delaying the creation of objects can produce big differences in time for the initial presentation of the data.</p></div><div class="section" title="Dynamic programming"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Dynamic programming</h2></div></div></div><p>One of the most requested features by programmers was the ability to create and manipulate objects<a id="id287" class="indexterm"/> without the restrictions imposed by static typing, since there are many daily situations in which this possibility offers a lot of useful options.</p><p>However, let's not mistake the dynamic features offered by C# 4.0 with the concept of Dynamic Programming in general computer science, in which the definition refers to the case where a problem is divided into smaller problems, and the optimal solution for each of these cases is sought, with the program being able to access each of these smaller solutions at a later time for optimal performance.</p><p>In the context of .NET Framework, though, C# 4.0 introduced<a id="id288" class="indexterm"/> a set of features linked to a new namespace (<code class="literal">System.Dynamic</code>) and a new reserved word, <code class="literal">dynamic</code>, which allows the declaration of elements that get rid of the type-checking feature we've seen so far.</p></div><div class="section" title="Dynamic typing"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Dynamic typing</h2></div></div></div><p>Using the <code class="literal">dynamic</code> keyword, we can declare variables that are not checked in compilation time but can be resolved at runtime. For instance, we can write the following declaration without any problems (at the time of writing):</p><div class="informalexample"><pre class="programlisting">dynamic o = GetUnknownObject();
o.UnknownMethod();</pre></div><p>In this code, <code class="literal">o</code> has been <a id="id289" class="indexterm"/>declared in an static way as dynamic, which is a type supported by the compiler. This code compiles even without knowing what <code class="literal">UnknownMethod</code> means or whether it exists at execution time. If the method doesn't exist, an exception will be thrown. Concretely, due the dynamic binding nature of the process, a <code class="literal">Microsoft.CSharp.RuntimeBinder.RuntimeBinderException</code> comes up, as we see when we misspell a call to the <code class="literal">ToUpper()</code> method in a string (we'll explain the code snippet a bit later):</p><div class="mediaobject"><img src="../Images/image00464.jpeg" alt="Dynamic typing"/></div><p style="clear:both; height: 1em;"> </p><p>When this kind of declaration appeared, there was some confusion related to the differences with declaring the previous sentence, as follows:</p><div class="informalexample"><pre class="programlisting">object p = ReturnObjectType();
((T)p).UnknownMethod();</pre></div><p>The difference here is that we have to know previously that a type <code class="literal">T</code> exists and it has a method called <code class="literal">UnknownMethod</code>. In this case, the casting operation ensures that an IL code is generated to guarantee that the <code class="literal">p</code> reference is conformant with the <code class="literal">T</code> type.</p><p>In the first case, the compiler cannot emit the code to call <code class="literal">UnknownMethod</code> because it doesn't even know whether such a method exists. Instead, it emits a<a id="id290" class="indexterm"/> dynamic call, which will be handled by another, new execution engine called <span class="strong"><strong>Dynamic Language Runtime</strong></span>, or <span class="strong"><strong>DLR</strong></span>.</p><p>The role of DLR, among others, is also to infer the corresponding type, and from that point, treat dynamic objects accordingly:</p><div class="informalexample"><pre class="programlisting">dynamic dyn = "This is a dynamic declared string";
Console.WriteLine(dyn.GetType());
Console.WriteLine(dyn);
Console.WriteLine(dyn.Length);
Console.WriteLine(dyn.ToUpper());</pre></div><p>So, this that means we can not only use the value of <code class="literal">dyn</code>, but also its properties and methods like what the previous code shows, behaving in the way that's expected, and showing that <code class="literal">dyn</code> is a type string object and presenting the results in Console, just as if we have declared <code class="literal">dyn</code> as <code class="literal">string</code> from the beginning:</p><div class="mediaobject"><img src="../Images/image00465.jpeg" alt="Dynamic typing"/></div><p style="clear:both; height: 1em;"> </p><p>Perhaps you remember the reflection characteristics we mentioned in <a class="link" title="Chapter 1. Inside the CLR" href="part0015.xhtml#aid-E9OE2">Chapter 1</a>, <span class="emphasis"><em>Inside the CLR</em></span>, and are wondering why we need this if many of the features available in this manner can be also managed with reflection programming.</p><p>To make a <a id="id291" class="indexterm"/>comparison, let's quickly remember how this possibility would look like (let's say we want to read the <code class="literal">Length</code> property):</p><div class="informalexample"><pre class="programlisting">dynamic dyn = "This is a dynamic declared string";
Type t = dyn.GetType();
PropertyInfo prop = t.GetProperty("Length");
int stringLength = prop.GetValue(dyn, new object[] { });
Console.WriteLine(dyn);
Console.WriteLine(stringLength);</pre></div><p>For this scenario, we get the same output that we expect, and technically, the performance penalty is dismissible:</p><div class="mediaobject"><img src="../Images/image00466.jpeg" alt="Dynamic typing"/></div><p style="clear:both; height: 1em;"> </p><p>It seems that both results are the same, although the way in which we get them is quite different. However, besides the boilerplate involved in reflection techniques, DLR is more efficient, and we also have the possibility of personalizing dynamic invocations.</p><p>It's true that it might seem contradictory for experienced static typing programmers: we lose the Intellisense linked to it, and the dynamic keyword forces the editor behind to understand that methods and<a id="id292" class="indexterm"/> properties accompanying such types will present themselves as dynamic as well. Refer to the tooltip shown in the next screenshot:</p><div class="mediaobject"><img src="../Images/image00467.jpeg" alt="Dynamic typing"/></div><p style="clear:both; height: 1em;"> </p><p>Part of the flexibility of this feature comes from the fact that any reference type can be converted into dynamic, and this can be done (via <code class="literal">Boxing</code>) with any value type.</p><p>However, once we have established our dynamic object to be of a type (such as <code class="literal">String</code>, in this case), the dynamism ends there. I mean, you cannot use other kinds of resources apart from those available in the definition of the <code class="literal">String</code> class.</p></div><div class="section" title="The ExpandoObject object"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>The ExpandoObject object</h2></div></div></div><p>One of the additions linked to this dynamic feature of the language is something called <code class="literal">ExpandoObject</code>, which—as you might have figured out by the name—allows you to expand an object with any number of properties of any type, keeping the<a id="id293" class="indexterm"/> compiler quiet and behaving in a similar way as it would happen when coding in real dynamic languages, such as JavaScript.</p><p>Let's look at how we can use one of these <code class="literal">ExpandoObject</code> object to create an object that grows in a totally dynamic way:</p><div class="informalexample"><pre class="programlisting">// Expando objects allow dynamic creation of properties
dynamic oex = new ExpandoObject();
oex.integerProp = 7;
oex.stringProp = "And this is the string property";
oex.datetimeProp = new ExpandoObject();
oex.datetimeProp.dayOfWeek = DateTime.Today.DayOfWeek;
oex.datetimeProp.time = DateTime.Now.TimeOfDay;
Console.WriteLine("Int: {0}", oex.integerProp);
Console.WriteLine("String: {0}", oex.stringProp);
Console.WriteLine("Day of Week: {0}", oex.datetimeProp.dayOfWeek);
Console.WriteLine("Time: {0}", oex.datetimeProp.time);</pre></div><p>As the preceding code shows, it is not just that we can expand the object with new properties of the type we <a id="id294" class="indexterm"/>want; we can even nest objects inside each other. There's no problem at runtime, as this screenshot shows in the Console output:</p><div class="mediaobject"><img src="../Images/image00468.jpeg" alt="The ExpandoObject object"/></div><p style="clear:both; height: 1em;"> </p><p>Actually, these dynamic features can be used in conjunction with other generic characteristics we've already seen, since the declaration of generic dynamic objects is also allowed in this context.</p><p>To prove this, we can create a method that builds <code class="literal">ExpandoObjects</code> containing some information about Packt Publishing books:</p><div class="informalexample"><pre class="programlisting">public static dynamic CreateBookObject(dynamic title, dynamic pages)
{
  dynamic book = new ExpandoObject();
  book.Title = title;
  book.Pages = pages;
  return book;
}</pre></div><p>Note that everything is declared as dynamic: the method itself and the arguments passed to it as well. Later on, we can use<a id="id295" class="indexterm"/> generic collections with these objects, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var listOfBooks = new List&lt;dynamic&gt;();
var book1 = CreateBookObject("Mastering C# and .NET Programming", 500);
var book2 = CreateBookObject("Practical Machine Learning", 468);
listOfBooks.Add(book1);
listOfBooks.Add(book2);
var bookWith500Pages = listOfBooks.Find(b =&gt; b.Pages == 500);
Console.WriteLine("Packt Pub. Books with 500 pages: {0}",
  bookWith500Pages.Title);
Console.ReadLine();</pre></div><p>Everything works as expected. Internally, <code class="literal">ExpandoObject</code> behaves like <code class="literal">Dictionary&lt;string, object&gt;</code>, where the name of the field added dynamically is the key (of type <code class="literal">String</code>), and the value is an object of any kind. So, in the previous code, the <code class="literal">Find</code> method of the <code class="literal">List</code> collection works correctly, finds the object we're looking for, and retrieves the title to show it the console:</p><div class="mediaobject"><img src="../Images/image00469.jpeg" alt="The ExpandoObject object"/></div><p style="clear:both; height: 1em;"> </p><p>There are some other dynamic features, but we will deal with some of them in the chapter dedicated to Interop, where we'll examine the possibilities of an interaction between a C# application and other applications in the OS, including Office applications and—generally speaking—any other application that implements and exposes a Type library.</p></div><div class="section" title="Optional and named parameters"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Optional and named parameters</h2></div></div></div><p>The declaration of optional <a id="id296" class="indexterm"/>parameters had been requested by programmers a long time ago, especially considering that it's a feature that was present in Visual Basic .NET since the beginning.</p><p>The way the Redmond team<a id="id297" class="indexterm"/> implemented this is simple: you can define a constant value associated with a parameter as long as you locate the parameter at the end of the parameters' list. Thus, we can define one of those methods in this way:</p><div class="informalexample"><pre class="programlisting">static void RepeatStringOptional(int x, string text = "Message")
{
  for (int i = 0; i &lt; x; i++)
  {
    Console.WriteLine("String no {0}: {1}", i, text);
  }
}</pre></div><p>Thus, optional parameters are <a id="id298" class="indexterm"/>characterized by being given an initial value. In this way, if the <code class="literal">RepeatStringOptional</code> method is called with only one <a id="id299" class="indexterm"/>argument, the <code class="literal">text</code> parameter is initialized with the passed value, so it will never be null. The IDE itself reminds us of such a situation when writing a call to the method.</p><div class="mediaobject"><img src="../Images/image00470.jpeg" alt="Optional and named parameters"/></div><p style="clear:both; height: 1em;"> </p><p>Remember that by convention, any element enclosed in square brackets is considered optional in computer science definitions.</p><p>As a variant of the previous feature, we can also provide an argument with name using the <code class="literal">function_name (name: arg)</code> syntax pattern. The same structural pattern of optional arguments is followed; that is, if we pass a named argument to a function, it has to be placed after any other positional argument, although within the named parameters section their relative order does not matter.</p></div><div class="section" title="The Task object and asynchronous calls"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>The Task object and asynchronous calls</h2></div></div></div><p>Although it is not part of the language itself, a <span class="strong"><strong>Base Class Library</strong></span> (<span class="strong"><strong>BCL</strong></span>) feature is <a id="id300" class="indexterm"/>worth mentioning in this chapter, as it is one of the most important innovations in this version of the framework. Up until this point, building and executing threads was<a id="id301" class="indexterm"/> something that was covered mainly in two forms: using the objects provided by the <code class="literal">System.Thread</code> namespace (available since <a id="id302" class="indexterm"/>version 1.0 of the framework) and from version 3.0, using the <code class="literal">BackgroundWorker</code> object, which was a wrapper on top of a functionality available in <code class="literal">System.Thread</code> to facilitate the creation of these objects.</p><p>The latter was primarily used in long duration processes, when a feedback was required during execution (progress bars, among others). It was a first attempt to ease thread programming, but since the new <code class="literal">Task</code> object came up, most of these scenarios (and many others, implying parallel or thread running processes) are mainly coded in this way.</p><p>Its usage is simple (especially when compared to previous options). You can declare a <code class="literal">Task</code> non-generic object and associate it with any method with the help of an <code class="literal">Action</code> delegate, as the IDE suggests when creating a new task by calling its constructor:</p><div class="mediaobject"><img src="../Images/image00471.jpeg" alt="The Task object and asynchronous calls"/></div><p style="clear:both; height: 1em;"> </p><p>So, if we have a slow <a id="id303" class="indexterm"/>method and we have no special requirements about the type returned (so it can be non-generic), it's possible to call it in a separate thread by<a id="id304" class="indexterm"/> writing the following:</p><div class="informalexample"><pre class="programlisting">public static string theString = "";
static void Main(string[] args)
{
  Task t = new Task(() =&gt;
  {
    SlowMethod(ref theString);
  });
  t.Start();
  Console.WriteLine("Waiting for SlowMethod to finish...");
  t.Wait();
  Console.WriteLine("Finished at: {0}",theString);
}

static void SlowMethod(ref string value)
{
  System.Threading.Thread.Sleep(3000);
  value = DateTime.Now.ToLongTimeString();
}</pre></div><p>Note a few details in this code: first, the argument is passed by reference. This means that the value of <code class="literal">theString</code> is changed by <code class="literal">SlowMethod</code>, but no return type is provided because the method should fit the signature of an <code class="literal">Action</code> (no return type); thus, to access the modified value, we pass it by reference and include in our <code class="literal">SlowMethod</code> code how to modify it.</p><p>The other main point is that we need to wait until <code class="literal">SlowMethod </code>finishes before trying to access <code class="literal">theString</code> (observe that the method is forced to take 3 seconds to complete by calling <code class="literal">Thread.Sleep(3000)</code>. Otherwise, execution would continue and the value accessed would be just the original empty string. In between, it's possible to perform other actions, such as printing a message in the console.</p><p>A generic variation of this object is also provided when we need <code class="literal">Task</code> to operate with a given type. As long as we<a id="id305" class="indexterm"/> define a variable of type <code class="literal">Task&lt;T&gt;</code>, the IDE changes the tooltip to remind us that in this case, a delegate of type <code class="literal">Func&lt;T&gt;</code> should be<a id="id306" class="indexterm"/> provided instead of <code class="literal">Action</code>, as is the case. You can compare this screenshot with the previous one:</p><div class="mediaobject"><img src="../Images/image00472.jpeg" alt="The Task object and asynchronous calls"/></div><p style="clear:both; height: 1em;"> </p><p>However, in the following code, we adopt the more common approach of creating the generic Task object by calling the <code class="literal">StartNew&lt;T&gt;</code> method available in the <code class="literal">Factory</code> object of <code class="literal">Task&lt;T&gt;</code>, so we can simplify the former example in this manner:</p><div class="informalexample"><pre class="programlisting">static void Main(string[] args)
{
  Task&lt;string&gt; t = Task.Factory.StartNew&lt;string&gt;(
    () =&gt; SlowMethod());
  Console.WriteLine("Waiting for SlowMethod to finish...");
  t.Wait();
  Console.WriteLine("Finished at: {0}", t.Result);
  Console.ReadLine();
}
static string SlowMethod()
{
  System.Threading.Thread.Sleep(3000);
  return DateTime.Now.ToLongTimeString();
}</pre></div><p>As you can see, this time we don't need an intermediate variable to store the return value, and the <code class="literal">Task&lt;T&gt;</code> definition allows you to create a <code class="literal">Task</code> object of almost any type.</p><p>There's much more about tasks and related features, such as parallel execution, asynchronous calls, and so on, so we'll go deeper into all this in <a class="link" title="Chapter 12. Performance" href="part0078.xhtml#aid-2ACBS2">Chapter 12</a>, <span class="emphasis"><em>Performance</em></span>, which we dedicate to performance and optimization, so take this as a very brief introduction to the subject.</p></div></div></div>
<div class="section" title="C# 5.0: async/await declarations" id="aid-MSDG1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>C# 5.0: async/await declarations</h1></div></div></div><p>In order to enhance the <a id="id307" class="indexterm"/>possibilities of creation and the management of asynchronous processes and to simplify the code even more, version 5.0 of C# introduced a couple of new reserved words in order to facilitate the insertion of asynchronous calls without having to implement an extra method to receive the results: the couple of words are <code class="literal">async</code>/<code class="literal">await</code> (one cannot be used without the other).</p><p>When a method is marked as <code class="literal">async</code>, the compiler will check for the presence of another sentence prefixed with the <code class="literal">await</code> keyword. Although we write the method as a whole, the compiler fragments (internally) the method into two parts: the one where the <code class="literal">async</code> keyword appears initially, and the rest counting from the line in which <code class="literal">await</code> is used.</p><p>At execution time, as soon as the <code class="literal">await</code> sentence is found, the execution flow returns to the calling method and executes the sentences that follow, if any. As soon as the slow process returns, execution continues with the rest of sentences located next to the awaited statement.</p><p>We can view a brief initial <a id="id308" class="indexterm"/>sample of how it works in a transformation of the previous example (as I mentioned in relation with tasks, this topic will also be covered with more detail in the chapter dedicated to performance):</p><div class="informalexample"><pre class="programlisting">static void Main(string[] args)
{
  Console.WriteLine("SlowMethod started at...{0}",
    DateTime.Now.ToLongTimeString());
  SlowMethod();
  Console.WriteLine("Awaiting for SlowMethod...");
  Console.ReadLine();
}
static async Task SlowMethod()
{
  // Simulation of slow method "Sleeping" the thread for 3 secs.
  await Task.Run(new Action(() =&gt; System.Threading.Thread.Sleep(3000)));
  Console.WriteLine("Finished at: {0}", DateTime.Now.ToLongTimeString());
  return;
}</pre></div><p>Note that I'm just writing the same code with a different syntax. When the execution flow reaches the first line of <code class="literal">SlowMethod</code> (marked as <code class="literal">await</code>), it launches another execution thread and returns to the thread in the calling method (<code class="literal">Main</code>). Consequently, we can see the <code class="literal">Awaiting for SlowMethod</code> message before the <code class="literal">Finished at</code> indication located at the end.</p><p>The output it is quite clear, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00473.jpeg" alt="C# 5.0: async/await declarations"/></div><p style="clear:both; height: 1em;"> </p><p>Of course, as we indicated in<a id="id309" class="indexterm"/> relation with the <code class="literal">Task</code> object, there's much more to this than what is expressed here in this ephemeral introduction, and we'll cover this in <a class="link" title="Chapter 10. Design Patterns" href="part0055.xhtml#aid-1KEEU1">Chapter 10</a>, <span class="emphasis"><em>Design Patterns</em></span>. But for now, we can have an idea about the benefits and simplification provided by this code construct.</p></div>
<div class="section" title="What's new in C# 6.0"><div class="titlepage" id="aid-NQU22"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>What's new in C# 6.0</h1></div></div></div><p>Some pretty interesting<a id="id310" class="indexterm"/> features appeared in this version of the language, in many cases, linked to everyday problems and suggestions of developers worldwide. Also, as stated in Table 1 of this chapter, the really huge, meaningful improvement <a id="id311" class="indexterm"/>comes from a set of functionalities linked to Roslyn Services, which provide a different bunch of possibilities related to the editing and compiling features of the IDE. We will cover these in <a class="link" title="Chapter 8. Open Source Programming" href="part0044.xhtml#aid-19UOO2">Chapter 8</a>, <span class="emphasis"><em>Open Source Programming</em></span>.</p><p>However, Roselyn is not the only interesting option that appeared in C# 6.0. There are a number of minor but very useful and syntactic "sweets" this version includes, which help the coder write more succinct expressions and reduce the occurrence of bugs. Let's start with something called string interpolation.</p><div class="section" title="String interpolation"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>String interpolation</h2></div></div></div><p>String interpolation is a way to <a id="id312" class="indexterm"/>simplify string expressions that contain C/C++ style interpolation. For instance, instead of writing the classic <code class="literal">Console.Write("string {0}", data)</code> composition, we can now express this by simply including the identifier inside curly brackets, so the previous expression would become <code class="literal">$"string {data}"</code> as far as we precede the string with the <code class="literal">$</code> symbol in order to make it work.</p><p>Note that we can mix the <code class="literal">@</code> symbol with <code class="literal">$</code> given that the <code class="literal">$</code> symbol goes before the <code class="literal">@</code> symbol.</p><p>Moreover, you can use the <code class="literal">{}</code> area to include a C# expression that will be correctly evaluated at runtime and converted into a string by calling the <code class="literal">ToString</code> method so that it's not limited to identifiers. Thus, we can even include file I/O operations—like we do in the following code—and get the results.</p><p>To test this, I have a text file (<code class="literal">TextFile.txt</code>) with a line of content, which is presented in the output accompanied by a string literal in a single line of code:</p><div class="informalexample"><pre class="programlisting">Console.WriteLine($"File contents: {File.ReadAllText("TextFile.txt")}");
Console.ReadLine();</pre></div><p>As you can see in the next<a id="id313" class="indexterm"/> capture, expressions inside the curly braces are totally evaluated and the result inserted in the output string:</p><div class="mediaobject"><img src="../Images/image00474.jpeg" alt="String interpolation"/></div><p style="clear:both; height: 1em;"> </p><p>This technique, besides simplifying expressions, can be used easily in conjunction with other new C# 6.0 features, such as Exception filters.</p></div><div class="section" title="Exception filters"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Exception filters</h2></div></div></div><p>Another addition refers to<a id="id314" class="indexterm"/> exceptions. Exception filters provide a way to personalize any occurred exception depending on a condition that can be coded using any valid C# expression, which should be located next to the new <code class="literal">when</code> sub-clause that might follow any <code class="literal">Catch</code> clause now.</p><p>In the previous code, let's suppose that we want to create a conditional test for an exception that doesn't have much to do with the exception itself (or maybe it does, but that's not the case here). Or, we can even suppose that we want to catch a situation related to an external state, such as the system's date/time or what have you.</p><p>The following code catches a situation in which the previous file exists but produces an exception on Saturdays, to say something bizarre. We can modify the code in this way:</p><div class="informalexample"><pre class="programlisting">string filename = "TextFile.txt";
try
{
  Console.WriteLine($"File contents: {File.ReadAllText(filename)}");
  Console.ReadLine();
}
catch when (File.Exists(filename) &amp;&amp; 
  DateTime.Today.DayOfWeek == DayOfWeek.Saturday)
{
  Console.WriteLine("File content unreadable on Saturdays");
}
catch (Exception ex)
{
  Console.WriteLine($"I/O Exception generated:{ex.Message}");
}</pre></div><p>This possibility provides us<a id="id315" class="indexterm"/> with new ways to catch exceptions linked to conditions that don't belong (necessarily) to the exception context but to any other situation; just consider that the expression can be much more complex than that in the demo code.</p></div><div class="section" title="The nameof operator"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>The nameof operator</h2></div></div></div><p>The <code class="literal">nameof</code> operator is a <a id="id316" class="indexterm"/>contextual keyword with a syntax similar to <code class="literal">typeof</code>, which yields the name of any program element (usually, an identifier). Or, if you want, it converts the filename variable of the previous example into filename.</p><p>This approach offers several advantages. First, if we need the name of such an element, no reflection technique is required. Besides, the compiler is going to guarantee that whatever we pass as an argument to the operator is a valid element; also, it integrates with the editor's Intellisense and behaves better in some refactoring scenarios.</p><p>It's useful in try-catch structures as well, for example, when indicating the reason for a failure specifying the name of the element that causes the exception and even in attributes, as the "official" example of <a id="id317" class="indexterm"/>MSDN suggests (refer to <a class="ulink" href="https://msdn.microsoft.com/en-us/library/dn986596.aspx">https://msdn.microsoft.com/en-us/library/dn986596.aspx</a>):</p><div class="informalexample"><pre class="programlisting">[DebuggerDisplay("={" + nameof(GetString) + "()}")]
class C
{
  string GetString() { return "Hello"; }
}</pre></div></div><div class="section" title="The null-conditional operator"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>The null-conditional operator</h2></div></div></div><p>This operator is the latest <a id="id318" class="indexterm"/>member of the family of features designed to deal with null values in C#. Since version 1.0, we could, of course, check (<code class="literal">value == null</code>) within a conditional statement to avoid undesired failures.</p><p>Later, <code class="literal">Nullable</code> types arrived (remember, appending a ? symbol to a variable declaration allows it to be null, and these types include a Boolean <code class="literal">HasValue</code> property to check this situation):</p><div class="informalexample"><pre class="programlisting">int? x = 8;
x.HasValue // == true if x != null</pre></div><p>When a conversion is required, the <code class="literal">TryParse</code> method of many basic types allows us to check for valid values (not only null).</p><p>As language evolved, new ways of dealing with null values kept coming up. In C# 4.0, one of the most useful things was the null-coalescing operator. It works a bit like the ? operator: it locates itself between two elements to check for nullability, and if the left-hand side is not null, it returns it; otherwise, it returns the right-hand side operand. It's so simple that it even lets you mix it with string interpolation in this way:</p><div class="informalexample"><pre class="programlisting">string str = null;
Console.WriteLine(str ?? "Unspecified");
Console.WriteLine($"str value: { str  ?? "Unspecified"}");</pre></div><p>We get the expected result in the console:</p><div class="mediaobject"><img src="../Images/image00475.jpeg" alt="The null-conditional operator"/></div><p style="clear:both; height: 1em;"> </p><p>So, the previous code writes <code class="literal">Unspecified</code> in the console, since <code class="literal">str</code> is null.</p><p>Now in C# 6.0, we have another ability: the null conditional operator, or null propagation operator (or even, the <code class="literal">Elvis</code> operator, as it's called by some members of the C# team, assuming that the two lower points are a couple of eyes and the higher part of the question mark the toupee!), which can be inserted in an expression, and it stops evaluating the right-hand side of the expression if the value of the <code class="literal">adorned</code> element with the operator is not present. Let's understand this better through an expression:</p><p>If we want to print out the length of the <code class="literal">str</code> string in the previous case, we can simply add another Console sentence, such as <code class="literal">Console.WriteLine(str.Length.ToString());</code>. The problem is that it would provoke an exception when trying to access the <code class="literal">Length</code> property of <code class="literal">str</code>.</p><p>To fix this, we can use this operator in very simple way:</p><div class="informalexample"><pre class="programlisting">Console.WriteLine(str?.Length.ToString());</pre></div><p>By including the null conditional <code class="literal">?</code> operator, the <code class="literal">Length</code> property is not even accessed, so there's no exception, and we will get the expected output (an empty string, in this case).</p><p>Let's put everything together in <a id="id319" class="indexterm"/>a block of code so that we compare different behaviors for null and non-null strings:</p><div class="informalexample"><pre class="programlisting">// Case 2
string str = null;
string str2 = "string";
Console.WriteLine(str ?? "Unspecified");
Console.WriteLine(str2 ?? "Unspecified");
Console.WriteLine($"str value: { str ?? "Unspecified"}");
Console.WriteLine($"str2 value: { str2 ?? "Unspecified"}");
Console.WriteLine($"str Length: {str?.Length}");
Console.WriteLine($"str2 Length: {str2?.Length}");
Console.ReadLine();</pre></div><p>This code compiles with no problems and generates the following output:</p><div class="mediaobject"><img src="../Images/image00476.jpeg" alt="The null-conditional operator"/></div><p style="clear:both; height: 1em;"> </p><p>Observe the fifth entry: no value is presented because no evaluation has been made of the <code class="literal">Length</code> of <code class="literal">str</code>. There are numerous cases in which this is just the operator we need: it could be checking a null <a id="id320" class="indexterm"/>delegate before invocation or inserting it right before any common <code class="literal">ToString</code> call for usual conversions.</p></div><div class="section" title="Auto-property initializers"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Auto-property initializers</h2></div></div></div><p>Auto-property initializers are another improvement that helps manage immutable properties (those that once given a value, don't change along the life of the application).</p><p>In preceding versions, declaring<a id="id321" class="indexterm"/> read-only properties was kind of redundant. You had to declare the read-only backup private field and take care of its initialization and, later, provide an explicit implementation of such property (instead of using the common auto-properties). Finally, to access the value, a property-get member was included. This was the way good practices recommended you to create this particular type of data.</p><p>This is also why auto-properties are so handy. For example, if our application captures the current username and operating system version of the machine, it's installed in a pair of read-only properties. It suffices to indicate this in the following manner:</p><div class="informalexample"><pre class="programlisting">public static string User { get; } = Environment.UserName;
public static string OpSystem { get; } = Environment.OSVersion.VersionString;
static void Main()
{
  Console.WriteLine($"Current {nameof(User)}: {User}");
  Console.WriteLine($"Version of Windows: : {OpSystem}");
}</pre></div><p>So, we're using a more concise syntax to express the same idea and obtain the same results as what we achieved with the classical approach:</p><div class="mediaobject"><img src="../Images/image00477.jpeg" alt="Auto-property initializers"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Static using declarations"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec48"/>Static using declarations</h2></div></div></div><p>Another way to simplify syntax is based on the idea of extending directives in the code to make them capable of referencing static members of the .NET Framework and using them in the same way as we use other<a id="id322" class="indexterm"/> declarations mentioned in a <code class="literal">using</code> directive.</p><p>That is, we can include a declaration like this:</p><div class="informalexample"><pre class="programlisting">using static System.Math;</pre></div><p>From this point, any reference to a member of the <code class="literal">Math</code> class can be done directly without an indication of the namespace (and the static class) it belongs to:</p><div class="informalexample"><pre class="programlisting">// Static reference of types
Console.WriteLine($"The square root of 9 is {Sqrt(9)}");</pre></div><p>Note that we're using string interpolation all over the demos, since the simplification it allows is very useful, especially for these console-type snippets (I omitted the output in this case, you can figure it out...).</p><p>Moreover, there's another typical case in which this functionality is important: when we use <code class="literal">Enum</code> members. Most of the time, we already know the possible values, so if we are indicating a typical <code class="literal">Enum</code>, such as the day of the week, we can indicate the corresponding <code class="literal">Enum</code> type as a static:</p><div class="informalexample"><pre class="programlisting">using static System.DayOfWeek;</pre></div><p>Then, use it just like earlier (remember, the number of <code class="literal">Enum</code> types in .NET is quite large):</p><div class="informalexample"><pre class="programlisting">Console.WriteLine($"Today is {Friday}");</pre></div><p>We even keep things more generic, using the <code class="literal">nameof</code> operator we already saw:</p><div class="informalexample"><pre class="programlisting">DayOfWeek today = DateTime.Today.DayOfWeek;
Console.WriteLine($"{nameof(today)} is {today}");</pre></div><p>So, we would still get the expected output, though expressed in a much more generic way:</p><div class="mediaobject"><img src="../Images/image00478.jpeg" alt="Static using declarations"/></div><p style="clear:both; height: 1em;"> </p><p>Since the demo is a Console application, even Console can be referenced in this way; so, consider that we want to change the colors of the output in the Console instead of writing something like this:</p><div class="informalexample"><pre class="programlisting">ConsoleColor backcolor = ConsoleColor.Blue;
ConsoleColor forecolor = ConsoleColor.White;
Console.BackgroundColor = backcolor;
Console.ForegroundColor = forecolor;</pre></div><p>We can put it all together in much simpler way (of course, some developers may argue that this is a matter of syntactic tastes.). At the top of the code, we declare the following:</p><div class="informalexample"><pre class="programlisting">using static System.Console;
using static System.ConsoleColor;</pre></div><p>Then, the rest is all simplified:</p><div class="informalexample"><pre class="programlisting">BackgroundColor = DarkBlue;
ForegroundColor = White;
WriteLine($"{nameof(today)} is {today}");
WriteLine($"Using {nameof(BackgroundColor)} : {BackgroundColor}");
WriteLine($"Using {nameof(ForegroundColor)} : {ForegroundColor}");
Read();</pre></div><p>The expected output is presented in <a id="id323" class="indexterm"/>a tuned Console this time:</p><div class="mediaobject"><img src="../Images/image00479.jpeg" alt="Static using declarations"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Expression bodied methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec49"/>Expression bodied methods</h2></div></div></div><p>When coding lambda expressions, we've seen that we could omit the curly braces used to indicate the body of a<a id="id324" class="indexterm"/> method in order to simplify the code. Now, we can do something similar in methods, allowing us to express overriding in a simpler way. Consider this example code:</p><div class="informalexample"><pre class="programlisting">using static System.Console;
namespace Chapter03_03
{
  public class ExpressionBodied
  {
    public static void Main()
    {
      ExpressionBodied eb = new ExpressionBodied();
      WriteLine(eb.ToString());
    }
    public string Name { get; } = "Chris";
    public string LastName { get; } = "Talline";
    public override string ToString() =&gt; $"FullName: {LastName}, {Name}";
  }
}</pre></div><p>Overriding the <code class="literal">ToString()</code> method is expressed using a simpler manner that contains string interpolation. It's pretty readable and concise, and it works just the same as it did in previous versions. (I also omitted the output, but you can easily infer it).</p><p>The same idea is valid to declare <a id="id325" class="indexterm"/>calculated properties in a class, for example. If we need to complete the previous class with a calculated property that returns a Boolean indicating whether the <code class="literal">FullName</code> member is longer that 12 characters (we call it <code class="literal">FullNameFits</code>), we can write this:</p><div class="informalexample"><pre class="programlisting">public bool FullNameFits =&gt; ((Name.Length + LastName.Length) &gt; 12) ? false : true;</pre></div><p>As you can see, this becomes much more concise and expressive than it was before this version.</p></div><div class="section" title="Index initializers"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec50"/>Index initializers</h2></div></div></div><p>Let's, finally, <a id="id326" class="indexterm"/>mention another feature related to initializers. Until now, when initializing index setters, we had to do it in separate statements. To put this in context, now if we have to initialize an array of values that coincides with certain numbers that are already well known, as is the case with Web Errors Dictionary (that is, 404-Not Found, and so on), we can define it in this way (all in one sentence):</p><div class="informalexample"><pre class="programlisting">Dictionary&lt;int, string&gt; HttpWebErrors = new Dictionary&lt;int, string&gt;
{
  [301] = "The page requested has been permanently moved",
  [307] = "The requested resource is available only through a proxy",
  [403] = "Access forbidden by the server",
  [404] = "Page not found. Try to change the URL",
  [408] = "Request timeout. Try again."
};</pre></div><p>So, right in the initialization process, we define the keys required (or, at least, initially required) regardless of whether they have to be changed later or not.</p><p>In all, we can say the C# new features in version 6.0 is not very deep and significant, especially when compared to version 4.0, to mention just one. However, they're quite useful and they reduce the required code on many scenarios in which the programmer already knows the structure to write well <a id="id327" class="indexterm"/>enough so as to get rid of some of the verbosity connected to some programming structures.</p></div></div>
<div class="section" title="What's new in C# 7.0"><div class="titlepage" id="aid-OPEK2"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>What's new in C# 7.0</h1></div></div></div><p>First of all, you have to keep in mind that to work with the new features proposed by version 7.0 of the<a id="id328" class="indexterm"/> language, you will need to have Visual Studio 2017 (any version, including the Community Edition) or Visual Studio Code with the OmniSharp Extension (C# plugin), which also allows to use the language in other popular editors like Vim, Emacs, Sublime, Atom, Brackets, and so on.</p><p>Once you have that ready, C# 7 features will be available in the IDE and we can start playing with these additions. Also, it's important to note that Microsoft is encouraging the contributors of the coming versions of the language to deploy new features in a faster path, although including a smaller set of new features.</p><p>Actually, this version does not include something as foundational to the language as LINQ or async/await. C# 7 adds extra syntactic sugar in some cases, except its most powerful features: the new support for tuples and deconstructions.</p><p>Let's start with the "syntactic sugar."</p><div class="section" title="Binary literals and digit separators"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec51"/>Binary literals and digit separators</h2></div></div></div><p>You can express binary<a id="id329" class="indexterm"/> numbers as literals directly in the definition of the type that holds them, like this, for example:</p><div class="informalexample"><pre class="programlisting">int[] binNumbers = { 0b1, 0b10, 0b100, 0b1000, 0b100000 };</pre></div><p>But when declared in this form, you <a id="id330" class="indexterm"/>can easily end up with long expressions difficult to evaluate and assess at first sight. That's why we now have a new language feature called digit separators.</p><p>That means you can include any number of underscore symbols located in any position inside a number literal and it will be interpreted correctly by the compiler. In this manner, it becomes easier to read the values.</p><p>This is valid for any type of number literal, as it happens in the sixth entry in the next code:</p><div class="informalexample"><pre class="programlisting">int[] binNumbers = { 0b1, 0b10, 0b100, 0b1_000, 0b100_000, 123_456_ };</pre></div><p>In case we want to check the automatic conversion to integers, we can test the result quite easily, adding a couple of lines:</p><div class="informalexample"><pre class="programlisting">binNumbers.ToList().ForEach((n) =&gt; Console.WriteLine($"Item: {n}"));
Console.Read(); </pre></div><p>This produces the following output in the console:</p><div class="mediaobject"><img src="../Images/image00480.jpeg" alt="Binary literals and digit separators"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Pattern matching and switch statements"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec52"/>Pattern matching and switch statements</h2></div></div></div><p>In many cases, we need to check the value of a variable marked as <code class="literal">out</code>. Remember that in order to use <code class="literal">out</code>, the <a id="id331" class="indexterm"/>variable has to be initialized first. To illustrate this situation, consider the following code, in which a function has to evaluate <a id="id332" class="indexterm"/>whether a string parameter passed to it can be interpreted as an integer or not:</p><div class="informalexample"><pre class="programlisting">var theValue = "123";
var result = CheckNumber(theValue);
Console.WriteLine($"Result: {result}");
Console.Read();
//…
static object CheckNumber(string s)
{
  // If the string can be converted to int, we double
  // the value. Otherwise, return it with a prefix
  int i = default(int);  // i must be initialized
  if (int.TryParse(s, out i)) {
    return (i * 2);
  }
  else
  {
    return "NotInt_" + s;
  }
}</pre></div><p>As you can see, we have to declare and initialize the <code class="literal">i</code> variable before we can retrieve the resulting value from the conversion and double it (in case it is an <code class="literal">int</code>).</p><p>How about avoiding the previous declaration and having <code class="literal">i</code> declared and initialized inside the <code class="literal">if</code> statement? That's what we can do now with out inline declarations:</p><div class="informalexample"><pre class="programlisting">static object CheckNumberC7(string s)
{
  // Now i is declared inside the If
  if (int.TryParse(s, out int i))
    return (i * 2);
  else return "NotInt_" + s;
}</pre></div><p>We have a more concise, elegant way of expressing the same idea. We're checking whether <code class="literal">s</code> matches the <code class="literal">int</code> pattern and, if it <a id="id333" class="indexterm"/>does, declaring and assigning the resulting value in a single expression.</p><p>Another way to use <a id="id334" class="indexterm"/>pattern matching is within the <code class="literal">switch</code> statements, which have also been extended with more patterns to evaluate the value passed to it. Actually, you can now switch on anything, not just primitive types such as <code class="literal">int</code> or <code class="literal">string</code>.</p><p>Let's see it in some code:</p><div class="informalexample"><pre class="programlisting">static object CheckObjectSwitch(object o)
{
  var result = default(object);
  switch (o)
  {
    case null:
      result = "null";
      break;
    case int i:
    case string s when int.TryParse(s, out i):
      result = i * 2;
      break;
    case string v:
      result = "NotInt_" + v;
      break;
    default:
      result = "Unknown value";
      break;
  }
  return result;
}</pre></div><p>The previous function assumes it is going to receive an object and has to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">If the object is null or different from an <code class="literal">int</code> or a string, return a string value indicating so</li><li class="listitem">If the object is an <code class="literal">int</code> or if it is an string convertible to an <code class="literal">int</code>, duplicate its value and return it</li><li class="listitem">It it is a string not convertible to an <code class="literal">int</code>, add a prefix and return it</li></ul></div><p>As per the preceding code, now you can indicate pattern matching to check whatever the value is, and we can even<a id="id335" class="indexterm"/> combine similar situations, such as checking for an <code class="literal">int</code> or for a string containing an <code class="literal">int</code> in sequential <code class="literal">case</code> statements.</p><p>Observe the use of <code class="literal">when</code> in the string pattern matching, which plays the role of an <code class="literal">if</code>, really.</p><p>Finally, if it is a <a id="id336" class="indexterm"/>string but it's not convertible, we use the prefix procedure. These two features are syntactic sugar (as they call it), but they're pretty expressive and help in simplifying type checking and complex checking situations such as the one coded here.</p><div class="section" title="Tuples"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec28"/>Tuples</h3></div></div></div><p>In the section named <span class="emphasis"><em>Tuples: implementation in C#</em></span>, we saw how to declare and use tuples using the <code class="literal">Tuple</code> class, and, also, some of the drawbacks linked to that early version or these objects.</p><p>Now, in C# 7, tuples reach a <a id="id337" class="indexterm"/>new dimension. You no longer have to use the <code class="literal">Tuple</code> class to declare tuples, and thanks to pattern matching, the compiler is perfectly <a id="id338" class="indexterm"/>comfortable with declarations that include a tuple syntax next to a <code class="literal">var</code> definition or use a tuple as the return type of a method (allowing us to return more than a value, without requiring out parameters):</p><div class="informalexample"><pre class="programlisting">(int n, string s) = ( 4, "data" );</pre></div><p>The previous declaration is now understood by the compiler, as the next capture shows:</p><div class="mediaobject"><img src="../Images/image00481.jpeg" alt="Tuples"/></div><p style="clear:both; height: 1em;"> </p><p>That makes the use of the <code class="literal">Tuple</code> class unnecessary and also it makes much natural to work with these<a id="id339" class="indexterm"/> types. Besides, we had to use the members <code class="literal">Item1</code>, <code class="literal">Item2</code>, and so on to access the values of the tuple. Now we can give descriptive names to each member of the tuple to clarify its purpose (such as <code class="literal">n</code> and <code class="literal">s</code> in this sample).</p><p>Another advantage is that you can return a tuple in a function. Let's follow an adapted version of the official demo that PM Mads Torgersen usually presents to explain this feature.</p><p>Imagine that we want to<a id="id340" class="indexterm"/> know how many items there are inside the initial declaration of <code class="literal">binNumbers</code> and also perform a sum of all its members, in the same function. We could write a method like this:</p><div class="informalexample"><pre class="programlisting">static (int sum, int count) ProcessArray(List&lt;int&gt; numbers)
{
  var result = (sum:0 , count:0);
  numbers.ForEach(n =&gt;
  {
    result.count++;
    result.sum += n;
  });
  return result;
}</pre></div><p>Now, invoke the method and present the results in this way:</p><div class="informalexample"><pre class="programlisting">var res = ProcessArray(binNumbers.ToList());
Console.WriteLine($"Count: {res.count}");
Console.WriteLine($"Sum: {res.sum}");
Console.Read();</pre></div><p>We obtain the expected results. But let's go through the code to view the details of the implementation.</p><p>First, the return value of the function is a tuple and its members, named accordingly, which makes the calling code more readable. Also, the internal <code class="literal">result</code> variable is defined and initialized with the tuple syntax: a list of comma-separated values, optionally prefixed with a name for<a id="id341" class="indexterm"/> clarity.</p><p>The return value is then <a id="id342" class="indexterm"/>assigned to the <code class="literal">res</code> variable, which can use the named parameters to output them in the console using string interpolation.</p></div><div class="section" title="Decomposition"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec29"/>Decomposition</h3></div></div></div><p>Decomposition is a <a id="id343" class="indexterm"/>characteristic that allows us to deconstruct or decompose an object into its parts, or some of its parts.</p><p>For instance, in the declaration <a id="id344" class="indexterm"/>of the <code class="literal">res</code> variable, we could even avoid the use of <code class="literal">res</code> by declaring the named members of the tuple, to obtain exactly the same results:</p><div class="informalexample"><pre class="programlisting">var (count, sum) = ProcessArray(binNumbers.ToList());</pre></div><p>As you can see, we can have access to the required returning values, but there's no need to hold them in a named variable; thus, we say that the resulting value has been "decomposed" into its forming parts.</p><p>Of course, in this case, we're taking advantage that the type to deconstruct is a tuple already. What about other objects? You can deconstruct any object as long as it has a <code class="literal">Deconstruct</code> method defined or you create an extension method with that name.</p><p>Let's say we want to be able to decompose a <code class="literal">DateTime</code> value. Of course, there's no <code class="literal">Deconstruct</code> method defined inside the <code class="literal">DateTime</code> object, but we can create one pretty easily:</p><div class="informalexample"><pre class="programlisting">static void Deconstruct(this DateTime dt, out int hour,
  out int minute, out int second)
{
  hour = dt.Hour;
  minute = dt.Minute;
  second = dt.Second;
}</pre></div><p>Once we have that definition accessible, we could "extract" those values from the current time with a sentence like this:</p><div class="informalexample"><pre class="programlisting">var (hour, minute, second) = DateTime.Now;
Console.WriteLine($"Hour: {hour} - Minute: {minute} - Second: {second}");</pre></div><p>And we would get the output shown in the following capture, which also shows the previous calculation on the number or items in the array and its sum:</p><div class="mediaobject"><img src="../Images/image00482.jpeg" alt="Decomposition"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Local functions"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec30"/>Local functions</h3></div></div></div><p>JavaScript programmers are used to passing functions as parameters and returning functions as a return value. That's <a id="id345" class="indexterm"/>not available in C#, except for the functionality available through lambda expressions that we saw in the previous chapter.</p><p>Local functions are not that, but<a id="id346" class="indexterm"/> they allow us to declare a function that is local to another closing function, with the ability to access the variables defined in the upper function. Therefore, they are local to the function in which they are declared.</p><p>Go back to our demo of <code class="literal">ProcessArray</code> and imagine you want to separate the code inside the <code class="literal">ForEach</code> loop aside in another function, but you want to modify the values directly (without the <code class="literal">out</code> references).</p><p>You could rewrite the process with an inside function of this kind with the following syntax:</p><div class="informalexample"><pre class="programlisting">static (int sum, int count) ProcessArrayWithLocal(List&lt;int&gt; numbers)
{
  var result = (s: 0, c: 0);
  foreach (var item in numbers)
  {
    ProcessItem(item, 1);
  }
  return result;
  void ProcessItem(int s, int c) { result.s+= s; result.c += c; };
}</pre></div><p>This time, we go through the collection using a <code class="literal">ForEach</code> loop and, inside the loop, we call the local function <code class="literal">ProcessItem</code>, which has access to the result members.</p><p>In which cases do these<a id="id347" class="indexterm"/> inside functions make sense? One case would be when a helper method is only going to be used inside a single function, like in this case.</p></div><div class="section" title="Ref return values"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec31"/>Ref return values</h3></div></div></div><p>Finally, let's learn a bit about these feature, which is only partially available, since they plan to extend it along the<a id="id348" class="indexterm"/> quick-path-release cadence of the language they announced in Connect(); 2016 event.</p><p>The idea is that in the same way<a id="id349" class="indexterm"/> you can pass values by reference, now you can return reference values and even store values in reference variables.</p><p>The Mads Torgersen code mentioned previously includes the following (self-explaining) code, to see how we would declare such a function a how we could use it:</p><div class="informalexample"><pre class="programlisting">public ref int Find(int number, int[] numbers)
{
  for (int i = 0; i &lt; numbers.Length; i++)
  {
    if (numbers[i] == number) 
    {
      return ref numbers[i]; // return the storage location, not the value
    }
  }
  throw new IndexOutOfRangeException($"{nameof(number)} not found");
}

int[] array = { 1, 15, -39, 0, 7, 14, -12 };
ref int place = ref Find(7, array); // aliases 7's place in the array
place = 9; // replaces 7 with 9 in the array
WriteLine(array[4]); // prints 9</pre></div><p>In the code, the function is marked with <code class="literal">ref</code> right before declaring the return type (<code class="literal">int</code>). Later, after declaring an array of numbers, the function is called with a 7 as the first parameter.</p><p>The value 7 occupies the fifth position in the array, so its order number is 4. But since the returned value is stored as <code class="literal">ref</code>, a subsequent assignment of 9 changes that value inside the array to 9. That's why the final sentence prints 9.</p><p>In all, perhaps the changes included in this last version of the language are not as meaningful as there were those in versions<a id="id350" class="indexterm"/> 2, 3, or 4 of the language, but even so, they facilitate the programmer's tasks in some situations.</p></div></div></div>
<div class="section" title="Summary" id="aid-PNV61"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Summary</h1></div></div></div><p>We saw the most renowned features included in recent versions of the C# language and .NET Framework from their 4.0 versions.</p><p>We covered the C# 4.0 version, with a review of Delegate and Interface generic variance (covariance and contravariance), dynamic declarations, argument improvements, tuples and Lazy Instantiation of objects, which implied important changes in expressiveness and the power of the C# language.</p><p>Then, we gave a brief introduction to the <code class="literal">async/await</code> structure as a means to simplify asynchronous calls by coding the two parts usually required in only one method.</p><p>Next, we did a review of the most important features included in version C# 6.0, which is mainly based on new ways to reduce verbosity in the language.</p><p>Finally, we've seen the most important features added to the recently published version 7.0, which are mainly based on syntactic sugar to make expressions more meaningful and the new pattern matching features which make the use of tuples a very feasible option in many common situations.</p><p>In the next chapter, we'll do a comparison of languages, including the F# and TypeScript support in Visual Studio as well as provide some prospects about their use in the future.</p></div></body></html>