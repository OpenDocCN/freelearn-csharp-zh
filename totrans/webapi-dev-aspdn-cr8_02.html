<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-37"><a id="_idTextAnchor068"/>2</h1>
<h1 id="_idParaDest-38"><a id="_idTextAnchor069"/>Getting Started with ASP.NET Core Web APIs</h1>
<p><strong class="bold">ASP.NET Core</strong> is a <a id="_idIndexMarker119"/>cross-platform, open-source web application framework for building modern, cloud-enabled web applications and APIs. It is primarily used with the C# programming language. ASP.NET Core provides features to help you build web apps in various ways – for example, through ASP.NET MVC, web APIs, Razor Pages, Blazor, and so on. This book will mainly cover web APIs. In this chapter, we will learn how to build a simple REST web API with ASP.NET Core.</p>
<p>In this chapter, we’ll be covering the following topics:</p>
<ul>
<li>Setting up the development environment</li>
<li>Creating a simple REST web API project</li>
<li>Building and running the project</li>
<li>Understanding the MVC pattern</li>
<li><strong class="bold">Dependency </strong><strong class="bold">injection</strong> (<strong class="bold">DI</strong>)</li>
<li>Introduction to minimal APIs</li>
</ul>
<p>This chapter will provide you with the necessary information to create a basic REST web API project with ASP.NET Core. By the end of this chapter, you should have a better understanding of the steps required to create your first ASP.NET Core web API project.</p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor070"/>Technical requirements</h1>
<p>You are expected to know the basic concepts of <strong class="bold">.NET Framework</strong> or <strong class="bold">.NET Core</strong>, and <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>). You should also have a basic understanding of the <strong class="bold">C#</strong> programming language. If you are not familiar with these concepts, you can refer to the following resources:</p>
<ul>
<li><strong class="bold">.NET </strong><strong class="bold">fundamentals</strong>: <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/">https://learn.microsoft.com/en-us/dotnet/fundamentals/</a></li>
<li><strong class="bold">C#</strong>: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/">https://learn.microsoft.com/en-us/dotnet/csharp/</a></li>
<li><strong class="bold">OOP (</strong><strong class="bold">C#)</strong>: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/oop">https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/oop</a></li>
</ul>
<p>The code examples in this chapter can be found at  <a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter2">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter2</a>.<a id="_idTextAnchor071"/></p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor072"/>Setting up the development environment</h1>
<p>.NET Core is <a id="_idIndexMarker120"/>fully cross-platform and can run on Windows, Linux, and macOS, so you can use any of these platforms to develop ASP.NET Core applications. The code samples in this book are written on Windows 11. However, you can run the same code on Linux and macOS.</p>
<p>There are also several IDEs available for ASP.NET Core, such as Visual Studio, <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>), Visual Studio <a id="_idIndexMarker121"/>for Mac, and Rider. In this book, we will mainly use VS Code.</p>
<p class="callout-heading">Why not Visual Studio?</p>
<p class="callout">Visual Studio is a powerful IDE for the .NET platform. It provides a bunch of tools and features to elevate and enhance every stage of software development. However, VS Code is more lightweight and is open-source and cross-platform. We will use VS Code to understand the concepts of ASP.NET Core, then migrate to Visual Studio to use its rich features. If you are familiar with Visual Studio or any other IDE, feel free to use it.</p>
<p>Here is a list of <a id="_idIndexMarker122"/>software, SDKs, and <a id="_idIndexMarker123"/>tools you need to install:</p>
<ul>
<li><strong class="bold">VS </strong><strong class="bold">Code</strong>: <a href="https://code.visualstudio.com/download">https://code.visualstudio.com/download</a></li>
<li><strong class="bold">.NET 8 </strong><strong class="bold">SDK</strong>: <a href="https://dotnet.microsoft.com/en-us/download">https://dotnet.microsoft.com/en-us/download</a></li>
</ul>
<p>Both VS Code and the .NET 8 SDK are cross-platform, so please choose the correct one for your OS. When you install VS Code, please make sure you check the <strong class="bold">Add to </strong><strong class="bold">PATH</strong> option.</p>
<p>If you use Windows, you may want to<a id="_idIndexMarker124"/> install <strong class="bold">Windows Terminal</strong> to run the command line. Windows Terminal is available for Windows 10 and above, and it provides a better user experience. But it is optional because you can also use the command line dire<a id="_idTextAnchor073"/>ctly.</p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor074"/>Configuring VS Code</h2>
<p>Strictly <a id="_idIndexMarker125"/>speaking, VS Code is a code editor. It <a id="_idIndexMarker126"/>cannot recognize all the coding languages. Therefore, you’ll need to install some extensions to support your development workflow. You can browse and install extensions by clicking on the <strong class="bold">Extensions</strong> icon in the <strong class="bold">Activity</strong> bar on the left-hand side of the VS Code interface. Then, you will see a list of the most popular extensions on the VS Code Marketplace:</p>
<div><div><img alt="Figure 2.1 – The C# Dev Kit extension for VS Code" src="img/B18971_02_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Overview of the C# Dev Kit extension for VS Code</p>
<p>You need to install this extension to support .NET development:</p>
<ul>
<li><strong class="bold">C# Dev Kit</strong>: This is <a id="_idIndexMarker127"/>the official C# extension for VS Code provided by Microsoft. When you install C# Dev Kit, the following extensions will automatically be installed:<ul><li><strong class="bold">C# extension</strong>: This<a id="_idIndexMarker128"/> extension provides C# language support powered by OmniSharp</li><li><strong class="bold">IntelliCode for C# Dev Kit</strong>: This<a id="_idIndexMarker129"/> extension provides AI-assisted IntelliSense for C#</li><li><strong class="bold">.NET Runtime Install Tool</strong>: This<a id="_idIndexMarker130"/> extension provides a unified way to install local, private versions of the .NET runtime</li></ul></li>
</ul>
<p>The C# Dev Kit extension <a id="_idIndexMarker131"/>provides a lot of features to help you develop .NET applications. Press <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">P</em> (on Windows) or <em class="italic">Command</em> + <em class="italic">Shift</em> + <em class="italic">P</em> (on macOS) to open the Command Palette, then type <code>.net</code> to see the commands provided by the C# Dev Kit extension. You can use these commands to create new projects, generate <a id="_idIndexMarker132"/>assets for build and debug, run tests, and more.</p>
<p>You can also install the following extensions to improve your productivity:</p>
<ul>
<li><strong class="bold">EditorConfig for VS Code</strong>: This<a id="_idIndexMarker133"/> extension provides EditorConfig support for VS Code. EditorConfig helps teams of multiple developers maintain consistent coding styles when working on the same project across various editors and IDEs.</li>
<li><strong class="bold">GitHub Copilot</strong>: GitHub Copilot is<a id="_idIndexMarker134"/> your AI pair programmer. You can get code suggestions in real-time based on your context and comments in VS Code. This extension is not free, but you can try it for free for 30 days. If you are a student, a teacher, or a maintainer of a popular open-source project, you can get it for free.</li>
</ul>
<p>To configure EditorConfig, you can create a file named <code>.editorconfig</code> in the root folder of the project. You can find a sample EditorConfig file at <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/code-style-rule-options">https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/code-style-rule-options</a>.</p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor076"/>Checking the .NET SDK</h2>
<p>Once<a id="_idIndexMarker135"/> you install the .NET SDK, you can check the version by running the following command:</p>
<pre class="console">
dotnet --version</pre> <p>You should be able to see the version number as follows:</p>
<pre class="console">
8.0.101-rc.2.23502.2</pre> <p>Microsoft releases new versions of .NET SDKs frequently. If you encounter a different version number, <a id="_idIndexMarker136"/>that is acceptable.</p>
<p>You can list all available SDKs by running the following command:</p>
<pre class="console">
dotnet --list-sdks</pre> <p>The preceding command will list all the available SDKs on your machine. For example, it may show the following output if have multiple .NET SDKs installed:</p>
<pre class="console">
6.0.415 [C:\Program Files\dotnet\sdk]7.0.402 [C:\Program Files\dotnet\sdk]
8.0.100 [C:\Program Files\dotnet\sdk]
8.0.101 [C:\Program Files\dotnet\sdk]</pre>
<p>Multiple versions of .NET SDKs can be installed at the same time. We can specify the version of the .NET SDKs in the project file.</p>
<p class="callout-heading">Which version of the SDKs should I use?</p>
<p class="callout">Every Microsoft <a id="_idIndexMarker137"/>product has a lifecycle. .NET and .NET Core provides <strong class="bold">Long-term support</strong> (<strong class="bold">LTS</strong>) releases that get 3 years of patches and free support. When this book was written, .NET 7 is still supported, until May 2024. Based on Microsoft's policy, even numbered releases are LTS releases. So .NET 8 is the latest LTS release. The code samples in this book are written with .NET 8.0.</p>
<p class="callout">To learn more about .NET support policies, please visit <a href="https://dotnet.microsoft.com/en-us/platform/support/policy">https://dotnet.microsoft.com/en-us/platform/support/policy</a>.</p>
<p>We are now prepared to start developing ASP.NET Core applications. L<a id="_idTextAnchor077"/>et’s get to work!</p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor078"/>Creating a simple REST web API project</h1>
<p>In this section, we<a id="_idIndexMarker138"/> will use the <strong class="bold">.NET command-line interface</strong> (<strong class="bold">.NET CLI</strong>) to create a basic web API project and see how it works.</p>
<p>The .NET CLI is a<a id="_idIndexMarker139"/> command-line tool that helps you to create, develop, build, run, and publish .NET applications. It is included in the .NET SDK.</p>
<p>You have multiple ways to run .NET CLI commands. The most common way is to run the command in the terminal window or command prompt. Also, you can run the command in VS Code directly. VS Code provides an integrated terminal that starts at the root of your workspace. To open the terminal in VS Code, you can do any one of the following:</p>
<ul>
<li>Press <em class="italic">Ctrl</em> + <em class="italic">`</em> (on Windows) or <em class="italic">Command</em> + <em class="italic">`</em> (on macOS) to open the terminal</li>
<li>Use the <strong class="bold">View</strong> | <strong class="bold">Terminal</strong> menu item to open the terminal</li>
<li>From the Command Palette, use the <strong class="bold">View: Toggle Terminal</strong> command to open the terminal</li>
</ul>
<p>In the terminal, navigate to a folder where you want to create the project, then create a web API project by running the following command:</p>
<pre class="console">
dotnet new webapi -n MyFirstApi -controllerscd MyFirstApi
code .</pre>
<p>The preceding commands create a new web API project and open it in VS Code. <code>dotnet new</code> provides many options to create various types of projects, such as web APIs, console apps, class libraries, and so on.</p>
<p>There are some options we can use to specify the project:</p>
<ul>
<li><code>-n|--name &lt;OUTPUT_NAME&gt;</code>: The name for the created output. If not specified, the name of the current directory is used.</li>
<li><code>-o|--output &lt;OUTPUT_PATH&gt;</code>: The output path for the created project. If not specified, the current directory is used.</li>
<li><code>-controllers|--use-controllers</code>: Indicates whether to use controllers for actions. If not specified, the default value is <code>false</code>.</li>
<li><code>-minimal|--use-minimal-apis</code>: Indicates whether to use minimal APIs. The default value is <code>false</code>, but the <code>-controllers</code> option will override the <code>-minimal</code> option. If neither <code>-controllers</code> nor <code>-minimal</code> is specified, the default value of the <code>-controllers</code> option, which is <code>false</code>, will be used, so a minimal API will be created.</li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">Since .NET 6.0, ASP.NET Core 6.0 provides a new way to create web API projects, which is called <code>--</code><code>use-controllers</code> option.</p>
<p>To learn<a id="_idIndexMarker141"/> more about the <code>dotnet new</code> command, check this page: <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new">https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new</a>. We will introduce more details on the <code>dotnet</code> command in the following sections.</p>
<p>When you use VS Code to open the project, the C# Dev Kit extension can create a solution file for you. This feature makes VS Code more friendly to C# developers. You can see the following structure in the Explorer view:</p>
<p>The reason is that VS 2022 will create a sln file for the project, but .NET CLI does not. When using VS Code to open the project, the C# DevKit will create the sln file. I think it's worth mentioning it here.</p>
<p>The C# Dev Kit <a id="_idIndexMarker142"/>extension provides a new feature, the solution explorer, which is located at the bottom. This feature is especially useful when working with multiple projects in one solution. You can drag and drop the <strong class="bold">SOLUTION EXPLORER</strong> to the top to make it more visible.</p>
<p>When you use VS Code to open the project, the C# Dev Kit extension can create a solution file for you. This feature makes VS Code more friendly to C# developers. You can see the following structure in the Explorer view:</p>
<div><div><img alt="Figure 2.2 – The solution explorer and the folder structure" src="img/B18971_02_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – The solution explorer and the folder structure</p>
<p>Next, we can <a id="_idIndexMarker143"/>start to buil<a id="_idTextAnchor079"/>d and run the project.</p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor080"/>Building and running the project</h1>
<p>In this section, we <a id="_idIndexMarker144"/>will learn how to build and run the project and introduce some useful tools to help you test the APIs. To make it compatible with all platforms, we will use .NET CLI commands to build and run the project. We will also learn how to debug <a id="_idTextAnchor081"/>the project in VS Code.</p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor082"/>Building the project</h2>
<p>The easiest way to<a id="_idIndexMarker145"/> build and run the project is to use the <code>dotnet</code> command. You can run the following command to build the project:</p>
<pre class="console">
dotnet build</pre> <p>The preceding command will build the project and its dependencies and generate a set of binaries. You can find these binaries in the <code>bin</code> folder. The <code>bin</code> folder is the default output folder for the <code>dotnet build</code> command. You can use the <code>--output</code> option to specify the output folder. However, it is recommended to use the default <code>bin</code> folder. The binaries are<a id="_idIndexMarker146"/> some <code>.</code><code>dll</code> extension.</p>
<p>You might see the following popups when you use VS Code to open the project:</p>
<div><div><img alt="Figure 2.3 – VS Code prompts to restore dependencies" src="img/B18971_02_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – VS Code prompts to restore dependencies</p>
<p>This is because VS Code inspects that the project is a .NET project, and it is trying to restore the dependencies. You can click the <strong class="bold">Restore</strong> button to restore the dependencies. Similarly, if you see other prompts from VS Code to add assets to debug the project, please select <strong class="bold">Yes</strong> in the dialog:</p>
<div><div><img alt="Figure 2.4 – VS Code prompts to add required assets to build and debug" src="img/B18971_02_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – VS Code prompts to add required assets to build and debug</p>
<p>Some commands, such as <code>dotnet build</code>, <code>dotnet run</code>, <code>dotnet test</code>, and <code>dotnet publish</code>, will <a id="_idIndexMarker147"/>implicitly restore dependencies. So don't worry if you missed out on these prompts.</p>
<p>If no errors or warnings are shown, that means <a id="_idTextAnchor083"/>the build is successful.</p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor084"/>Running the project</h2>
<p>You<a id="_idIndexMarker148"/> can run the following command to run the project:</p>
<pre class="console">
dotnet run</pre> <p>The <code>dotnet run</code> command is a convenient way of running the project from the source code. Keep in mind that it is useful in development, but not for production. The reason is that if the dependencies are outside of the shared runtime, the <code>dotnet run</code> command will resolve the dependencies from the NuGet cache. To run the application in production, you need to create a deployment package with the <code>dotnet publish</code> command and deploy it. We will explore the deployment process in future chapters.</p>
<p>You should be able to see the following output:</p>
<pre class="console">
Building...info: Microsoft.Hosting.Lifetime[14]
      Now listening on: https://localhost:7291
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: http://localhost:5247
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Development
info: Microsoft.Hosting.Lifetime[0]
      Content root path: C:\example_code\chapter2\MyFirstApi\MyFirstApi
info: Microsoft.Hosting.Lifetime[0]
      Application is shutting down...</pre>
<p>There is a<a id="_idIndexMarker149"/> link in the output, such as <code>http://localhost:5247</code>. The port number was randomly generated when we created the project. In a browser, navigate to <code>http://localhost:&lt;your_port&gt;/swagger</code>. You will see the web API documentation with <strong class="bold">Swagger UI</strong>, which<a id="_idIndexMarker150"/> offers a web-based UI to provide information and tools to interact with the API. You can use Swagger UI to test APIs:</p>
<div><div><img alt="Figure 2.5 – Swagger UI" src="img/B18971_02_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Swagger UI</p>
<p>The <a id="_idIndexMarker151"/>API project<a id="_idIndexMarker152"/> is now running! You can see the web API template provides a <code>/WeatherForecast</code> endpoint. If you navigate to the <code>http://localhost:5247/WeatherForecast</code> link in the browser, you will see the API response.</p>
<p>To support HTTPS, you may need to trust the HTTPS development certificate by running the following command:</p>
<pre class="console">
dotnet dev-certs https --trust</pre> <p>You will see a dialog if the certificate was not previously trusted. Select <strong class="bold">Yes</strong> to trust the development certificate:</p>
<div><div><img alt="Figure 2.6 – Installing the certificate for local development" src="img/B18971_02_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Installing the certificate for local development</p>
<p>Please note<a id="_idIndexMarker153"/> that the preceding command does not work on Linux. See your Linux distribution docu<a id="_idTextAnchor085"/>mentation for more details.</p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor086"/>Changing the port number</h2>
<p>The port number is <a id="_idIndexMarker154"/>defined in the <code>launchSettings.json</code> file in the <code>Properties</code> folder. You can change the port number by editing the file. Based on the convention, when the web API project was created, a port from <code>5000</code> to <code>5300</code> will be selected for HTTP, and from <code>7000</code> to <code>7300</code> for HTTPS. Here is an example of the <code>launchSettings.json</code> file:</p>
<pre class="source-code">
{  "$schema": "https://json.schemastore.org/launchsettings.json",
  ...
  "profiles": {
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "https://localhost:7291;http://localhost:5247",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    ...
  }
}</pre>
<p>You can update the port number here. Just keep in mind that the port number should be unique on your<a id="_idTextAnchor087"/> machine to avoid conflicts.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor088"/>Hot Reload</h2>
<p>When you use <code>dotnet run</code> to run<a id="_idIndexMarker155"/> the project, if you change the code, you need to stop the project and start it again. If your project is complicated, it takes time to stop and restart. To speed up development, you can use the <code>dotnet watch</code> command to enable the Hot Reload feature.</p>
<p>.NET Hot Reload is a feature that allows you to apply code changes to a running app without restarting the app. It was first provided with .NET 6. Instead of using <code>dotnet run</code>, you can use <code>dotnet watch</code> to activate Hot Reload in development. Once you update the code, the web browser will automatically refresh the page. However, Hot Reload does not support all code changes. In some cases, <code>dotnet watch</code> will ask you if you want to restart the application. There are some options: <code>Yes</code>, <code>No</code>, <code>Always</code>, and <code>Never</code>. Choose the appropriate option for the code change you want to apply, as shown next:</p>
<pre class="console">
dotnet watch  File changed: .\Services\IService.cs.dotnet watch  Unable to apply hot reload because of a rude edit.
   Do you want to restart your app - Yes (y) / No <a id="_idTextAnchor089"/>(n) / Always (a) / Never (v)?</pre>
<p>The API project is now running, and we can start to test the API.</p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor090"/>Testing the API endpoint</h2>
<p>The <a id="_idIndexMarker156"/>browser can send a <code>GET</code> request easily, but it is not as simple for <code>POST</code> endpoints. There are various ways to call the API for testing purposes, such as Swagger UI, Postman, and other tools. In this section, we will introduce some tools you can<a id="_idTextAnchor091"/> use in the<a id="_idTextAnchor092"/> development stage.</p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor093"/>Swagger UI</h2>
<p>We <a id="_idIndexMarker157"/>introduced <a id="_idIndexMarker158"/>how to use SwaggerHub to design APIs in <a href="B18971_01.xhtml#_idTextAnchor012"><em class="italic">Chapter 1</em></a>. From version 5.0, ASP.NET Core enables OpenAPI support by default. It uses the <code>Swashbuckle.AspNetCore</code> NuGet package, which provides the Swagger UI to document and test the APIs.</p>
<p>We can use Swagger UI to test the API directly. Expand the first <code>/WeatherForecast</code> API in <a id="_idIndexMarker159"/>Swagger UI and click the <strong class="bold">Try it out</strong> button. You<a id="_idIndexMarker160"/> will see an <strong class="bold">Execute</strong> button. Click the button, and you will see the following response:</p>
<div><div><img alt="Figure 2.7 – Testing an endpoint in Swagger UI" src="img/B18971_02_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Testing an endpoint in Swagger UI</p>
<p><em class="italic">Figure 2</em><em class="italic">.7</em> demonstrates <a id="_idIndexMarker161"/>that the API is functioning correctly and is providing the expected response. To learn more about Swagger and<a id="_idIndexMarker162"/> OpenAPI, you <a id="_idIndexMarker163"/>can <a id="_idIndexMarker164"/>check the following links:</p>
<ul>
<li><strong class="bold">Swagger</strong>: <a href="https://swagger.io/">https://swagger.io/</a></li>
<li><strong class="bold">OpenAPI</strong>: <a href="https://www.openapis.org/">https://www.openapis.org/</a></li>
<li><strong class="bold">S<a id="_idTextAnchor094"/>martBear</strong>: <a href="https://www.smartbear.com/">https://www.smartbear.com/</a></li>
</ul>
<h3>Postman</h3>
<p><strong class="bold">Postman</strong> is a <a id="_idIndexMarker165"/>powerful API platform for building and using APIs. It is widely used by many individual developers and organizations. You can<a id="_idIndexMarker166"/> download it here: <a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a>.</p>
<p>Click the <code>http://localhost:5247/WeatherForecast</code> as the URL. Then, click the <strong class="bold">Send</strong> button. You will see the response next:</p>
<div><div><img alt="Figure 2.8 – Using Postman to call the API" src="img/B18971_02_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Using Postman to call the API</p>
<p>Postman provides a rich set of features to test APIs. To learn more about Postman, check the official documentation: <a href="https://learning.postman.com/docs/getting-started/introduction/">https://learning.postman.com/docs/getting-started/introduction/</a>.</p>
<h3>HttpRepl</h3>
<p><code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>HEAD</code>, <code>OPTIONS</code>, and <code>PATCH</code> HTTP verbs.</p>
<p>To install HttpRepl, you can use the following command:</p>
<pre class="console">
dotnet tool install -g Microsoft.dotnet-httprepl</pre> <p>After the installation, you can use the following command to connect to our API:</p>
<pre class="console">
httprepl &lt;ROOT URL&gt;/</pre> <p><code>&lt;ROOT URL&gt;</code> is the base URL of the web API, such as the following:</p>
<pre class="console">
httprepl http://localhost:5247/</pre> <p>After the <a id="_idIndexMarker168"/>connection is built, you can use the <code>ls</code> or <code>dir</code> command to list the endpoints, such as the following:</p>
<pre class="console">
http://localhost:5247/&gt; ls.                 []
WeatherForecast   [GET]</pre>
<p>The preceding command shows the <code>WeatherForecast</code> endpoint supports a <code>GET</code> operation. Then, we can use the <code>cd</code> command to navigate to the endpoint, such as the following:</p>
<pre class="console">
http://localhost:5247/&gt; cd WeatherForecast/WeatherForecast    [GET]</pre>
<p>Then, we can use the <code>get</code> command to test the endpoint, such as the following:</p>
<pre class="console">
http://localhost:5247/WeatherForecast&gt; get</pre> <p>The output looks like this:</p>
<div><div><img alt="Figure 2.9 – Output of HttpRepl" src="img/B18971_02_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Output of HttpRepl</p>
<p>To <a id="_idIndexMarker169"/>disconnect, press <em class="italic">Ctrl</em> + <em class="italic">C</em> to exit.</p>
<p>You can fi<a id="_idTextAnchor096"/>nd more information about HttpRepl at <a href="https://docs.microsoft.com/en-us/aspnet/core/web-api/http-repl/">https://docs.microsoft.com/en-us/aspnet/core/web-api/http-repl/</a>.</p>
<h3>Thunder Client</h3>
<p>If you prefer to do everything in <a id="_idIndexMarker170"/>VS Code, <strong class="bold">Thunder Client</strong> is a great tool for testing APIs. Thunder Client is a lightweight REST API client extension for VS Code, allowing users to test their APIs without having to leave VS Code. This makes it an ideal choice for developers who want to streamline their workflow:</p>
<div><div><img alt="Figure 2.10 – The Thunder Client extension for VS Code" src="img/B18971_02_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – The Thunder Client extension for VS Code</p>
<p>After the<a id="_idIndexMarker171"/> installation, click the <strong class="bold">Thunder Client</strong> icon on the <strong class="bold">Action</strong> bar. From the sidebar, click the <strong class="bold">New Request</strong> button. The following UI will be shown:</p>
<div><div><img alt="Figure 2.11 – Testing the API with Thunder Client" src="img/B18971_02_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – Testing the API with Thunder Client</p>
<p>To learn more about Thunder Client, visit their GitHub page: <a href="https://github.com/rangav/thunder-client-support">https://github.com/rangav/thunder-client-support</a>.</p>
<h3>Using .http files in VS 2022</h3>
<p>If you use <a id="_idIndexMarker172"/>Visual Studio 2022, you can use the <code>.http</code> file to test the API. The <code>.http</code> file is a text file that contains definitions of HTTP requests. The latest ASP.NET Core 8 template project provides a default <code>.http</code> file. You<a id="_idIndexMarker173"/> can find it in the <code>MyFirstApi</code> folder. The content of the file is as follows:</p>
<pre class="console">
@MyFirstApi_HostAddress = http://localhost:5247GET {{MyFirstApi_HostAddress}}/weatherforecast/
Accept: application/json
###</pre>
<p>The first line defines a variable named <code>MyFirstApi_HostAddress</code> with the value of the root URL of the API. The second line defines a <code>GET</code> request to the <code>/weatherforecast</code> endpoint. The third line defines an <code>Accept</code> header. In this case, it accepts the <code>application/json</code> content type. Open this file in Visual Studio 2022, and you will see the <strong class="bold">Send Request</strong> button on the left side of the request. Click the button, and you will see the response as follows:</p>
<div><div><img alt="Figure 2.12 – Using the .http file to test the API in Visual Studio 2022" src="img/B18971_02_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – Using the .http file to test the API in Visual Studio 2022</p>
<p>However, when <a id="_idIndexMarker174"/>this book was written, the <code>.http</code> files lacked some features, such as environment variables. Also, this feature is only <a id="_idIndexMarker175"/>available in Visual Studio 2022, so we will not use it in this book. But if you are interested in exploring this feature further, please refer to the Microsoft docs at <a href="https://learn.microsoft.com/en-us/aspnet/core/test/http-files">https://learn.microsoft.com/en-us/aspnet/core/test/http-files</a> for more information.</p>
<p>We have introduced some tools to test <a id="_idTextAnchor097"/>APIs. Let's now learn how to debug APIs.</p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor098"/>Debugging</h2>
<p>VS Code has a<a id="_idIndexMarker176"/> built-in debugging feature that allows you to debug code. Unlike Visual Studio, it needs a <code>launch.json</code> configuration for debugging. When you open an ASP.NET Core project in VS Code, it will prompt you to add some assets. If you choose <code>launch.json</code> file in the <code>.</code><code>vscode</code> folder.</p>
<p>If you missed it, you can add it manually from the Debug view:</p>
<div><div><img alt="Figure 2.13 – Creating a launch.json file from the Debug view" src="img/B18971_02_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13 – Creating a launch.json file from the Debug view</p>
<p>If you <a id="_idIndexMarker177"/>cannot see the buttons in <em class="italic">Figure 2</em><em class="italic">.13</em>, you can open the Command Palette by pressing <em class="italic">Ctrl </em>+<em class="italic"> Shift </em>+<em class="italic"> P</em> (on Windows) or <em class="italic">Command </em>+<em class="italic"> Shift </em>+<em class="italic"> P</em> (on macOS), then type <code>.net</code> and choose <code>launch.json</code> file in the <code>.</code><code>vscode</code> folder:</p>
<div><div><img alt="Figure 2.14 – Generating a launch.json file from the Command Palette" src="img/B18971_02_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14 – Generating a launch.json file from the Command Palette</p>
<p>The <a id="_idIndexMarker178"/>content of the default <code>launch.json</code> configuration is shown next:</p>
<pre class="source-code">
{<code>    "version": "0.2.0",</code>
<code>    "configurations": [</code>
<code>        {</code>
<code>            // Use IntelliSense to find out which attributes exist for C# debugging</code>
<code>            // Use hover for the description of the existing attributes</code>
<code>            // For further information visit https://github.com/dotnet/vscode-csharp/blob/main/debugger-launchjson.md.</code>
<code>            "name": ".NET Core Launch (web)",</code>
<code>            "type": "coreclr",</code>
<code>            "request": "launch",</code>
<code>            "preLaunchTask": "build",</code>
<code>            // If you have changed target frameworks, make sure to update the program path.</code>
<code>            "program": "${workspaceFolder}/bin/Debug/net8.0/MyFirstApi.dll",</code>
<code>            "args": [],</code>
<code>            "cwd": "${workspaceFolder}",</code>
<code>            "stopAtEntry": false,</code>
<code>            // Enable launching a web browser when ASP.NET Core starts. For more information: https://aka.ms/VSCode-CS-LaunchJson-WebBrowser</code>
<code>            "serverReadyAction": {</code>
<code>                "action": "openExternally",</code>
<code>                "pattern": "\\bNow listening on:\\s+(https?://\\S+)"</code>
<code>            },</code>
<code>            "env": {</code>
<code>                "ASPNETCORE_ENVIRONMENT": "Development"</code>
<code>            },</code>
<code>            "sourceFileMap": {</code>
<code>                "/Views": "${workspaceFolder}/Views"</code>
<code>            }</code>
<code>        },</code>
<code>        {</code>
<code>            "name": ".NET Core Attach",</code>
<code>            "type": "coreclr",</code>
<code>            "request": "attach"</code>
<code>        }</code>
<code>    ]</code>
<code>}</code></pre>
<p>This file specifies <a id="_idIndexMarker179"/>the configuration for debugging. Some important attributes are described next:</p>
<ul>
<li>The <code>program</code> attribute specifies the path to the executable file</li>
<li>The <code>args</code> attribute specifies the arguments to pass to the executable file</li>
<li>The <code>cwd</code> attribute specifies the working directory</li>
<li>The <code>env</code> attribute specifies the environment variables</li>
</ul>
<p>We do not need to change anything in this file now.</p>
<p>Set up a breakpoint in the app. For example, we can set a breakpoint in the <code>Get()</code> method in the <code>WeatherForecastController.cs</code> file by clicking in the left margin of the code window. Once the breakpoint is set, you will see a red dot before the line number in the left margin:</p>
<div><div><img alt="Figure 2.15 – Setting up a breakpoint in VS Code" src="img/B18971_02_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15 – Setting up a breakpoint in VS Code</p>
<p>To debug the app, open the <strong class="bold">Debug</strong> view by selecting the <strong class="bold">Debugging</strong> icon on the left-side menu. Make sure you choose the correct debugging configuration from the drop-down menu. For this case, please select <strong class="bold">.NET Core Launch (web)</strong>. Then, select the green <a id="_idIndexMarker180"/>arrow at the top of the pane:</p>
<div><div><img alt="Figure 2.16 – Debugging the API in VS Code" src="img/B18971_02_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16 – Debugging the API in VS Code</p>
<p>Send a<a id="_idIndexMarker181"/> request from any of the tools in the previous section, and you will see the program execution stops when it reaches the breakpoint, as shown next:</p>
<div><div><img alt="Figure 2.17 – Hitting the breakpoint in VS Code" src="img/B18971_02_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17 – Hitting the breakpoint in VS Code</p>
<p>The <strong class="bold">Locals</strong> section of the <strong class="bold">VARIABLES</strong> window will display the values of variables that are defined in the current context.</p>
<p>You can also type a<a id="_idIndexMarker182"/> variable in the <strong class="bold">DEBUG CONSOLE</strong> window to check the value directly. To execute the next step, you can use the control toolbar at the top of the VS Code window. You can run the code line by line to monitor its execution. It is helpful if we need to know how the program works.</p>
<p>Now we have learned how to build, run, and test AP<a id="_idTextAnchor099"/>Is, it is time to look at the code of APIs.</p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor100"/>Understanding the MVC pattern</h1>
<p>ASP.NET Core MVC is a rich <a id="_idIndexMarker183"/>framework for building web applications with the <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) design pattern. The MVC pattern enables web applications to separate the presentation from the business logic. An ASP.NET Core web API project follows the basic MVC pattern, but it does not have views, so it only has a Model layer and a Controller layer. Let’s look at this in a bit more detail:</p>
<ul>
<li><strong class="bold">Models</strong>: Models<a id="_idIndexMarker184"/> are classes that represent the data that is used in the application. Normally, the data is stored in a database.</li>
<li><code>Contro<a id="_idTextAnchor101"/>llers</code> folder. <em class="italic">Figure 2</em><em class="italic">.18</em> shows an example of the MVC pattern in an web API project. However, the view layer is not included in the web API project. The request from the client will be mapped to the controller, and the controller will execute the business logic and return the response to the client.</li>
</ul>
<div><div><img alt="Figure 2.18 – The MVC pattern" src="img/B18971_02_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18 – The MVC pattern</p>
<p>Next, we will look at the code of the model and the controller in an ASP.NET Core web API project.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor102"/>The model and the controller</h2>
<p>In the ASP.NET Core template project, you can find a file named <code>WeatherForecast.cs</code>. This file is a model. It is a pure C# class that represents a data model.</p>
<p>The controller is the <code>WeatherForecastController.cs</code> file located in the <code>Controllers</code> folder. It <a id="_idIndexMarker186"/>contains <a id="_idIndexMarker187"/>the business logic.</p>
<p>It looks like this:</p>
<pre class="source-code">
[ApiController][Route("[controller]")]
public class WeatherForecastController : ControllerBase
{
    // Some code is ignored
    private readonly ILogger&lt;WeatherForecastController&gt; _logger;
    public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger)
    {
        _logger = logger;
    }
    [HttpGet(Name = "GetWeatherForecast")]
    public IEnumerable&lt;WeatherForecast&gt; Get()
    {
        return Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast
        {
            Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),
            TemperatureC = Random.Shared.Next(-20, 55),
            Summary = Summaries[Random.Shared.Next(Summaries.Length)]
        })
        .ToArray();
    }
}</pre>
<p>The constructor of the controller class has a parameter named <code>ILogger&lt;WeatherForecastController&gt; logger</code>. This parameter is used to log messages. It is injected with DI by the ASP.NET Core framework. We will talk about DI in the next section.</p>
<p>This class has an <code>[ApiController]</code> attribute that indicates that it is a web API controller. It also has a <code>[Route("[controller]")]</code> attribute that indicates the URL of the controller.</p>
<p>The <code>Get()</code> method has a <code>[HttpGet(Name = "GetWeatherForecast")]</code> attribute that indicates the name of the endpoint, and the <code>Get()</code> method is a <code>GET</code> operation. This method returns a list of weather forecasts as the response.</p>
<p>Note that the <code>[Route("[controller]")]</code> attribute is marked on the controller class. It means the path of the controller is <code>/WeatherForecast</code>. Currently, there is no <code>[Route]</code> attribute on the <code>Get()</code> method. We will learn more about routing in future sections.</p>
<p>We should now <a id="_idIndexMarker188"/>have a basic <a id="_idIndexMarker189"/>understanding of how ASP.NET Core web API works. The client sends the request to the web API, and the request will be mapped to the controller and the method. The controller will execute the business logic and return the response. We can use some methods to get, save, update, and delete data from the database in the controllers.</p>
<p>Next, let us create a new A<a id="_idTextAnchor103"/>PI endpoint by adding a new model and controller.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor104"/>Creating a new model and controller</h2>
<p>In <a href="B18971_01.xhtml#_idTextAnchor012"><em class="italic">Chapter 1</em></a>, we showed an example REST API on <a href="https://jsonplaceholder.typicode.com/posts">https://jsonplaceholder.typicode.com/posts</a>. It <a id="_idIndexMarker190"/>returns a list of posts, as shown next:</p>
<pre class="source-code">
[  {
    "userId": 1,
    "id": 1,
    "title": "sunt aut facere repellat provident occaecati excepturi optio reprehenderit",
    "body": "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto"
  },
  {
    "userId": 1,
    "id": 2,
    "title": "qui est esse",
    "body": "est rerum tempore vitae\nsequi sint nihil reprehenderit dolor beatae ea dolores neque\nfugiat blanditiis voluptate porro vel nihil molestiae ut reiciendis\nqui aperiam non debitis possimus qui neque nisi nulla"
  },
  ...
]</pre>
<p>Let us implement a similar API. First, we need to create a new model. Create a new folder named <code>Models</code> in the project. Then, create<a id="_idIndexMarker191"/> a new file named <code>Post.cs</code> in the <code>Models</code> folder:</p>
<pre class="source-code">
namespace MyFirstApi.Models;public class Post
{
    public int UserId { get; set; }
    public int Id { get; set; }
    public string Title { get; set; } = string.Empty;
    public string Body { get; set; } = string.Empty;
}</pre>
<p class="callout-heading">File-scoped namespace declaration</p>
<p class="callout">From C# 10, you can use a new form of namespace declaration, as shown in the previous code snippet, which is called a file-scoped namespace declaration. All the members in this file are in the same namespace. It saves space and reduces indentation.</p>
<p class="callout-heading">Nullable reference types</p>
<p class="callout">You may be wondering why we assign an empty string to the <code>Title</code> and <code>Body</code> properties. This is because the properties are of type <code>string</code>. If we do not initialize the property, the compiler will complain:</p>
<p class="callout"><code>Non-nullable property 'Title' must contain a non-null value when exiting constructor. Consider declaring the property </code><code>as nullable.</code></p>
<p class="callout">By default, the ASP.NET Core web API project template enabled the <code>&lt;Nullable&gt;enable&lt;/Nullable&gt;</code> in the <code>&lt;</code><code>PropertyGroup&gt;</code> section.</p>
<p class="callout">Nullable reference types were introduced in C# 8.0. They can minimize the likelihood of errors that cause the runtime to throw a <code>System.NullReferenceException</code> error. For example, if we forget to initialize the <code>Title</code> property, we may get a <code>System.NullReferenceException</code> error when we try to access a property of it, such as <code>Title.Length</code>.</p>
<p class="callout">With this feature enabled, any variable of a reference type is considered to be non-nullable. If you want to allow a variable to be nullable, you must append the type name with the <code>?</code> operator to declare the variable as a nullable reference type; for example, <code>public string Title? { get; set; }</code>, which explicitly marks the property as nullable.</p>
<p class="callout">To learn more about this feature, see <a href="https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references">https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references</a>.</p>
<p>Next, create <a id="_idIndexMarker193"/>a new file named <code>PostController.cs</code> in the <code>Controllers</code> folder. You can manually add it, or install the <code>dotnet-aspnet-codegenerator</code> tool to create it. To install the tool, run the following commands from the project folder:</p>
<pre class="console">
dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Designdotnet tool install -g dotnet-aspnet-codegenerator</pre>
<p>The preceding commands install a NuGet package required for scaffolding. The <code>dotnet-aspnet-codegenerator</code> tool is a scaffolding engine that is used to generate code.</p>
<p>Then, run the following command to generate a controller:</p>
<pre class="console">
dotnet-aspnet-codegenerator controller -name PostsController -api -outDir Controllers</pre> <p>The preceding command generates an empty controller. The <code>-name</code> option specifies the name of the controller. The <code>-api</code> option indicates that the controller is an API controller. The <code>-outDir</code> option specifies the output directory. Update the content of the <a id="_idIndexMarker194"/>controller as follows:</p>
<pre class="source-code">
using Microsoft.AspNetCore.Mvc;using MyFirstApi.Models;
namespace MyFirstApi.Controllers;
[Route("api/[controller]")]
[ApiController]
public class PostsController : ControllerBase
{
    [HttpGet]
    public ActionResult&lt;List&lt;Post&gt;&gt; GetPosts()
    {
        return new List&lt;Post&gt;
        {
            new() { Id = 1, UserId = 1, Title = "Post1", Body = "The first post." },
            new() { Id = 2, UserId = 1, Title = "Post2", Body = "The second post." },
            new() { Id = 3, UserId = 1, Title = "Post3", Body = "The third post." }
        };
    }
}</pre>
<p class="callout-heading">Target-typed new expressions</p>
<p class="callout">When we create a new <code>List</code> instance of a specific type, we will normally use code like this:</p>
<p class="callout"><code>var list = </code><code>new List&lt;Post&gt;</code></p>
<p class="callout"><code>{</code></p>
<p class="callout"><code> new Post() { Id = 1, UserId = 1, Title = "Post1", Body = "The first </code><code>post." },</code></p>
<p class="callout"><code>};</code></p>
<p class="callout">When the list is declared as <code>List&lt;Post&gt;</code>, the type is known, so it is not necessary to use <code>new Post()</code> here when adding new elements. The type specification can be omitted for constructors, such as <code>new()</code>. This feature was introduced in C# 9.0.</p>
<p>The<a id="_idIndexMarker195"/> controller is named <code>PostsController</code>. The convention is the resource name with the <code>Controller</code> suffix. It is marked with the <code>ApiController</code> attribute, which indicates that the controller is a web API controller. It also has a <code>[Route("api/[controller]")]</code> attribute that indicates the URL of the controller. <code>[controller]</code> is like a placeholder, which will be replaced with the name of the controller in the routing. So, the route of this controller is <code>/api/posts</code>.</p>
<p>In this controller, we have a method named <code>GetPosts()</code>. This method returns a list of posts as the response. The method is marked with the <code>[HttpGet]</code> attribute, which indicates that this method is a <code>GET</code> operation. It does not have any route template, because it will match <code>/api/posts</code>. For other methods, we can use the <code>[Route("[action]")]</code> attribute to specify the route template.</p>
<p>The return type of the <code>GetPosts()</code> method is <code>ActionResult&lt;IEnumerable&lt;Post&gt;&gt;</code>. ASP.NET Core can automatically convert the object to JSON and return it to the client in the response message. Also, it can return other HTTP status codes, such as <code>NotFound</code>, <code>BadRequest</code>, <code>InternalServerError</code>, and so on. We will see more examples later.</p>
<p>If you run <code>dotnet run</code> or <code>dotnet watch</code>, then navigate to Swagger UI, such as <code>https://localhost:7291/swagger/index.html</code>, you will see the new API listed. The API is accessible at <code>/api/posts</code>.</p>
<p>Currently, the <code>/api/posts</code> endpoint <a id="_idIndexMarker196"/>returns a hardcoded list of posts. Let us update <a id="_idTextAnchor105"/>the controller to return a list of posts from a service.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor106"/>Creating a service</h2>
<p>Create a <code>Services</code> folder<a id="_idIndexMarker197"/> in the project. Then, create a new file named <code>PostService.cs</code> in the <code>Services</code> folder, as shown next:</p>
<pre class="source-code">
using MyFirstApi.Models;namespace MyFirstApi.Services;
public class PostsService
{
    private static readonly List&lt;Post&gt; AllPosts = new();
    public Task CreatePost(Post item)
    {
        AllPosts.Add(item);
        return Task.CompletedTask;
    }
    public Task&lt;Post?&gt; UpdatePost(int id, Post item)
    {
        var post = AllPosts.FirstOrDefault(x =&gt; x.Id == id);
        if (post != null)
        {
            post.Title = item.Title;
            post.Body = item.Body;
            post.UserId = item.UserId;
        }
        return Task.FromResult(post);
    }
    public Task&lt;Post?&gt; GetPost(int id)
    {
        return Task.FromResult(AllPosts.FirstOrDefault(x =&gt; x.Id == id));
    }
    public Task&lt;List&lt;Post&gt;&gt; GetAllPosts()
    {
        return Task.FromResult(AllPosts);
    }
    public Task DeletePost(int id)
    {
        var post = AllPosts.FirstOrDefault(x =&gt; x.Id == id);
        if (post != null)
        {
            AllPosts.Remove(post);
        }
        return Task.CompletedTask;
    }
}</pre>
<p>The <code>PostsService</code> class is <a id="_idIndexMarker198"/>a simple demo service that manages the list of posts. It has methods to create, update, and delete posts. To simplify the implementation, it uses a static field to store the list of posts. This is just for demonstration purposes; please do not use this in production.</p>
<p>Next, we will follow the API design to implement CRUD operations. You can review <a id="_idTextAnchor107"/>the <em class="italic">REST-based API design</em> section of the previous chapter.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor108"/>Implementing a GET operation</h2>
<p>The<a id="_idIndexMarker199"/> design for the <code>viewPost()</code> operation is as follows:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Operation name</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">URL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">HTTP method</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Input</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Response</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>viewPost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/{postId}</code></p>
</td>
<td class="No-Table-Style">
<p><code>GET</code></p>
</td>
<td class="No-Table-Style">
<p>PostId</p>
</td>
<td class="No-Table-Style">
<p>Post, 200</p>
</td>
<td class="No-Table-Style">
<p>View a post detail</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Figure">Table 2.1 – The design for the <code>viewPost()</code> operation</p>
<p>Update <a id="_idIndexMarker200"/>the <code>PostController</code> class as follows:</p>
<pre class="source-code">
using Microsoft.AspNetCore.Mvc;using MyFirstApi.Models;
using MyFirstApi.Services;
namespace MyFirstApi.Controllers;
[Route("api/[controller]")]
[ApiController]
public class PostsController : ControllerBase
{
    private readonly PostsService _postsService;
    public PostsController()
    {
        _postsService = new PostsService();
    }
    [HttpGet("{id}")]
    public async Task&lt;ActionResult&lt;Post&gt;&gt; GetPost(int id)
    {
        var post = await _postsService.GetPost(id);
        if (post == null)
        {
            return NotFound();
        }
        return Ok(post);
    }
    // Omitted for brevity
}</pre>
<p>In the<a id="_idIndexMarker201"/> constructor method of the controller, we initialize the <code>_postsService</code> field. Note that we use the <code>new()</code> constructor to create an instance of the service. That means the controller is coupled with the <code>PostsService</code> class. We will see how to decouple the controller and the service in the next chapter.</p>
<p>Then, create a <code>GetPost()</code> method that returns a post with the specified ID. It has a <code>[HttpGet("{id}")]</code> attribute to indicate the URL of the operation. The URL will be mapped to <code>/api/posts/{id}</code>. <code>id</code> is a placeholder, which will be replaced with the ID of the post. Then, <code>id</code> will be passed to the <code>GetPost()</code> method as a parameter.</p>
<p>If the post is not found, the method will return a <code>NotFound</code> response. ASP.NET Core provides a set of built-in response messages, such as <code>NotFound</code>, <code>BadRequest</code>, <code>InternalServerError</code>, and so on.</p>
<p>If you call the API now, it will return <code>NotFound</code> because we have not created a post<a id="_idTextAnchor109"/>.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor110"/>Implementing a CREATE operation</h2>
<p>The design<a id="_idIndexMarker202"/> for the <code>createPost()</code> operation is as follows:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-1">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Operation name</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">URL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">HTTP method</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Input</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Response</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>createPost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts</code></p>
</td>
<td class="No-Table-Style">
<p><code>POST</code></p>
</td>
<td class="No-Table-Style">
<p>Post</p>
</td>
<td class="No-Table-Style">
<p>Post, 201</p>
</td>
<td class="No-Table-Style">
<p>Create a new post</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Figure">Table 2.2 – The design for the <code>createPost()</code> operation</p>
<p>Create a new method named <code>CreatePost()</code> in the controller. As the controller has been mapped to <code>api/posts</code>, we do not need to specify the route of this method. The content of the method is as follows:</p>
<pre class="source-code">
[HttpPost]public async Task&lt;ActionResult&lt;Post&gt;&gt; CreatePost(Post post)
{
    await _postsService.CreatePost(post);
    return CreatedAtAction(nameof(GetPost), new { id = post.Id }, post);
}</pre>
<p>When<a id="_idIndexMarker203"/> we call this endpoint, the <code>post</code> object will be serialized in the JSON format that is attached to the <code>POST</code> request body. In this method, we can get the post from the request and then call the <code>CreatePost()</code> method in the service to create a new post. Then, we will return the built-in <code>CreatedAtAction</code>, which returns a response message with the specified action name, route values, and post. For this case, it will call the <code>GetPost()</code> action to return the newly created post.</p>
<p>Now, we can test the API. For example, we can send a <code>POST</code> request in Thunder Client.</p>
<p>Change the method to <code>POST</code>. Use the following JSON data as the body:</p>
<pre class="source-code">
{  "userId": 1,
  "id": 1,
  "title": "Hello ASP.NET Core",
  "body": "ASP.NET Core is a cross-platform, high-performance, open-source framework for building modern, cloud-enabled, Internet-connected apps."
}</pre>
<p>Click the <code>201 Created</code>:</p>
<div><div><img alt="Figure 2.19 – Sending a POST request" src="img/B18971_02_19.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.19 – Sending a POST request</p>
<p>Then, send<a id="_idIndexMarker204"/> a <code>GET</code> request to the <code>api/posts/1</code> endpoint. We can get a response like this:</p>
<div><div><img alt="Figure 2.20 – Sending a GET request" src="img/B18971_02_20.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.20 – Sending a GET request</p>
<p><a id="_idTextAnchor111"/>Please note<a id="_idIndexMarker205"/> that the post we created is stored in the memory of the service. Because we have not provided a database to store the data, if we restart the application, the post will be lost.</p>
<p>Next, let us see how to implement an update operation.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor112"/>Implementing an UPDATE operation</h2>
<p>The design<a id="_idIndexMarker206"/> for the <code>updatePost()</code> operation is as follows:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table003-1">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Operation name</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">URL</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">HTTP method</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Input</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Response</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>updatePost()</code></p>
</td>
<td class="No-Table-Style">
<p><code>/</code><code>posts/{postId}</code></p>
</td>
<td class="No-Table-Style">
<p><code>PUT</code></p>
</td>
<td class="No-Table-Style">
<p>Post</p>
</td>
<td class="No-Table-Style">
<p>Post, 200</p>
</td>
<td class="No-Table-Style">
<p>Update a new post</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Figure">Table 2.3 – The design for the <code>updatePost()</code> operation</p>
<p>Create a new <code>UpdatePost()</code> method in the controller, as shown next:</p>
<pre class="source-code">
[HttpPut("{id}")]public async Task&lt;ActionResult&gt; UpdatePost(int id, Post post)
{
    if (id != post.Id)
    {
        return BadRequest();
    }
    var updatedPost = await _postsService.UpdatePost(id, post);
    if (updatedPost == null)
    {
        return NotFound();
    }
    return Ok(post);
}</pre>
<p>This <a id="_idIndexMarker207"/>method has a <code>[HttpPut("{id}")]</code> attribute to indicate that it is a <code>PUT</code> operation. Similarly, <code>id</code> is a placeholder, which will be replaced with the ID of the post. In the <code>PUT</code> request, we should attach the serialized content of the post to the request body.</p>
<p>This time, let us test the API with HttpRepl. Run the following command to connect to the server:</p>
<pre class="console">
httprepl https://localhost:7291/api/postsconnect https://localhost:7291/api/posts/1
put -h Content-Type=application/json -c "{"userId": 1,"id": 1,"title": "Hello ASP.NET Core 8","body": "ASP.NET Core is a cross-platform, high-performance, open-source framework for building modern, cloud-enabled, Internet-connected apps."}"</pre>
<p>You will see this output:</p>
<pre class="source-code">
HTTP/1.1 200 OKContent-Type: application/json; charset=utf-8
Date: Thu, 18 Aug 2022 11:25:26 GMT
Server: Kestrel
Transfer-Encoding: chunked
{
  "userId": 1,
  "id": 1,
  "title": "Hello ASP.NET Core 8",
  "body": "ASP.NET Core is a cross-platform, high-performance, open-source framework for building modern, cloud-enabled, Internet-connected apps."
}</pre>
<p>Then, we<a id="_idIndexMarker208"/> can update the <code>GetPosts()</code> method as follows:</p>
<pre class="source-code">
[HttpGet]public async Task&lt;ActionResult&lt;List&lt;Post&gt;&gt;&gt; GetPosts()
{
    var posts = await _postService.GetAllPosts();
    return Ok(posts);
<a id="_idTextAnchor113"/>}</pre>
<p>We have implemented <code>GET</code>, <code>POST</code>, and <code>PUT</code> operations. Next, you can try to implement the <code>DeletePost()</code> method using the <code>DELETE</code> operation by yourself.</p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor114"/>Dependency injection</h1>
<p>In the preceding <a id="_idIndexMarker209"/>example of the controller, there is a <code>_postsService</code> field that is initialized in the constructor method of the controller by using the <code>new()</code> constructor:</p>
<pre class="source-code">
private readonly PostsService _postsService;public PostsController()
{
    _postsService = new PostsService();
}</pre>
<p>That says the <code>PostsController</code> class depends on the <code>PostsService</code> class, and the <code>PostsService</code> class is a dependency of the <code>PostsController</code> class. If we want to replace <code>PostsService</code> with a different implementation to save the data, we have to update the code of <code>PostsController</code>. If the <code>PostsService</code> class has its own dependencies, they must also be initialized by the <code>PostsController</code> class. When the project grows larger, the dependencies will become more complex. Also, this kind of implementation is not easy to test and maintain.</p>
<p><strong class="bold">Dependency injection</strong> (<strong class="bold">DI</strong>) is one of the most well-known design patterns in the software development world. It helps decouple classes that depend on each other. You may find the following terms being used<a id="_idIndexMarker210"/> interchangeably: <strong class="bold">Dependency Inversion Principle</strong> (<strong class="bold">DIP</strong>), <strong class="bold">Inversion of Control</strong> (<strong class="bold">IoC</strong>), and DI. These<a id="_idIndexMarker211"/> terms are commonly confused even though they are related. You can find multiple articles and blog posts that explain them. Some say they are the same thing, but some say not. What are t<a id="_idTextAnchor115"/>hey?</p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor116"/>Understanding DI</h2>
<p>The Dependency Inversion Principle is <a id="_idIndexMarker212"/>one of the <em class="italic">SOLID</em> principles in <strong class="bold">object-oriented</strong> (<strong class="bold">OO</strong>) design. It was <a id="_idIndexMarker213"/>defined by Robert C. Martin in his book <em class="italic">Agile Software Development: Principles, Patterns, and Practices</em>, <em class="italic">Pearson</em>, in 2002. The principle states, “<em class="italic">high-level modules should not depend on low-level modules; both should depend on abstractions. Abstractions should not depend on details. Details should depend </em><em class="italic">upon abstractions</em>.”</p>
<p>In the preceding controller, we said <code>PostsController</code> depends on <code>PostsService</code>. The controller is the high-level module, and the service is the low-level module. When the service is changed, the controller must be changed as well. Keep in mind that the term <em class="italic">inversion</em> does not mean that the low-level module will depend on the high level. Instead, both of them should depend on abstractions that expose the behavior needed by high-level modules. If we invert this dependency relationship by creating an interface for the service, both the controller and the service will <a id="_idIndexMarker214"/>depend on the interface. The implementation of the service can change as long as it respects the interface.</p>
<p><strong class="bold">IoC</strong> is a <a id="_idIndexMarker215"/>programming principle that inverts the flow of control in an application. In traditional programming, custom code is responsible for instantiating objects and controlling the execution of the main function. IoC inverts the flow of control as compared to traditional control flow. With IoC, the framework does the instantiation, calling custom or task-specific code.</p>
<p>It can be used to differentiate a framework from a class library. Normally, the framework calls the application code, and the application code calls the library. This kind of IoC is sometimes referred to as the Hollywood principle: “<em class="italic">Don’t call us, we’ll </em><em class="italic">call you</em>.”</p>
<p>IoC is related to DIP, but it is not the same. DIP concerns decoupling dependencies between high-level modules and low-level modules through shared abstractions (interfaces). IoC is used to increase the modularity of the program and make it extensible. There are<a id="_idIndexMarker216"/> several technologies to implement IoC, such as <strong class="bold">Service Locator</strong>, DI, the template method design pattern, the strategy design pattern, and so on.</p>
<p>DI is a form of IoC. This term was coined by Martin Fowler in 2004. It separates the concerns of constructing objects and using them. When an object or a function (the client) needs a dependency, it does not know how to construct it. Instead, the client only needs to declare the interfaces of the dependency, and the dependency is injected into the client by external code (an injector). It makes it easier to change the implementation of the dependency. It is often similar to the strategy design pattern. The difference is that the strategy pattern can use different strategies to construct the dependency, while DI typically only uses a single instance of the dependency.</p>
<p>There are three main types of DI:</p>
<ul>
<li><strong class="bold">Constructor injection</strong>: The<a id="_idIndexMarker217"/> dependencies are provided as parameters of the client’s constructor</li>
<li><strong class="bold">Setter injection</strong>: The<a id="_idIndexMarker218"/> client exposes a setter method to accept the dependency</li>
<li><strong class="bold">Interface injection</strong>: The<a id="_idIndexMarker219"/> dependency’s interface provides an injector method that will inject the dependency into any client passed to it</li>
</ul>
<p>As you can see, these three terms are related, but there are some differences. Simply put, DI is a technique for achieving IoC between classes and their dependencies. ASP.NET Core supports DI as a first-cl<a id="_idTextAnchor117"/>ass citizen.</p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor118"/>DI in ASP.NET Core</h2>
<p>ASP.NET Core <a id="_idIndexMarker220"/>uses constructor injection to request dependencies. To use it, we need to do the following:</p>
<ol>
<li>Define interfaces and their implementations.</li>
<li>Register the interfaces and the implementations to the service container.</li>
<li>Add services as the constructor parameters to inject the dependencies.</li>
</ol>
<p>You can download the example project named <code>DependencyInjectionDemo</code> from the folder <code>samples/chapter2/ DependencyInjectionDemo/DependencyInjectionDemo</code> in the chapter's GitHub repository.</p>
<p>Follow the steps below to use DI in ASP.NET Core:</p>
<ol>
<li>First, we will create an interface and its implementation. Copy the <code>Post.cs</code> file and the <code>PostService.cs</code> file from the previous <code>MyFirstApi</code> project to the <code>DependencyInjectionDemo</code> project. Create a new interface named <code>IPostService</code> in the <code>Service</code> folder, as shown next:<pre class="source-code">
public interface IPostService{    Task CreatePost(Post item);    Task&lt;Post?&gt; UpdatePost(int id, Post item);    Task&lt;Post?&gt; GetPost(int id);    Task&lt;List&lt;Post&gt;&gt; GetAllPosts();    Task DeletePost(int id);}
public class PostsService : IPostService</pre><p class="list-inset">You may also need to update the namespace of the <code>Post</code> class and the <code>PostService</code> class.</pre></li> <li>Next, we can register the <code>IPostService</code> interface and the <code>PostService</code> implementation to the service container. Open the <code>Program.cs</code> file, and you will find that an instance of <code>WebApplicationBuilder</code> named builder is created by calling the <code>WebApplication.CreateBuilder()</code> method. The <code>CreateBuilder()</code> method is the entry point of the application. We can configure the application by using the builder instance, and then call the <code>builder.Build()</code> method to build the <code>WebApplication</code>. Add the following code:<pre class="source-code">
builder.Services.AddScoped&lt;IPostService, PostsService&gt;();</pre><p class="list-inset">The preceding code utilizes the <code>AddScoped()</code> method, which indicates that the service is created once per client request and disposed of upon completion of the request.</p></li> <li>Copy the <code>PostsController.cs</code> file from the previous <code>MyFirstApi</code> project to the <code>DependencyInjectionDemo</code> project. Update the namespace and the <code>using</code> statements. Then, update the constructor method of the controller as follows:<pre class="source-code">
private readonly IPostService _postsService;public PostsController(IPostService postService){    _postsService = postService;}</pre><p class="list-inset">The preceding code uses the <code>IPostService</code> interface as the constructor parameter. The service container will inject the correct implementation into the controller.</p></li> </ol>
<p>DI has four roles: services, clients, interfaces, and injectors. In this example, <code>IPostService</code> is the interface, <code>PostService</code> is the service, <code>PostsController</code> is the client, and <code>builder.Services</code> is the injector, which is a collection of services for the application to compose. It is sometimes referred to as a DI container.</p>
<p>The <code>PostsController</code> class requests the instance of <code>IPostService</code> from its constructor. The <a id="_idIndexMarker222"/>controller, which is the client, does not know where the service is, nor how it is constructed. The controller only knows the interface. The service has been registered in the service container, which can inject the correct implementation into the controller. We do not need to use the <code>new</code> keyword to create an instance of the service. That says the client and the service are decoupled.</p>
<p>This DI feature is provided in a NuGet package called <code>Microsoft.Extensions.DependencyInjection</code>. When an ASP.NET Core project is created, this package is added automatically. If you create a console project, you may need to install it manually by using the following command:</p>
<pre class="console">
dotnet add package Microsoft.Extensions.DependencyInjection</pre> <p>If we want to replace the <code>IPostService</code> with another implementation, we can do so by registering the new implementation to the service container. The code of the controller does not need to be changed. That is one of the benefits of DI.</p>
<p>Next, let us discuss the lifeti<a id="_idTextAnchor119"/>me of services.</p>
<h3>DI lifetimes</h3>
<p>In the previous example, the service is registered using the <code>AddScoped()</code> method. In ASP.NET Core, there <a id="_idIndexMarker223"/>are three lifetimes when the service is registered:</p>
<ul>
<li><strong class="bold">Transient</strong>: A transient service<a id="_idIndexMarker224"/> is created each time it is requested and disposed of at the end of the request.</li>
<li><strong class="bold">Scoped</strong>: In <a id="_idIndexMarker225"/>web applications, a scope means a request (connection). A scoped service is created once per client request and disposed of at the end of the request.</li>
<li><strong class="bold">Singleton</strong>: A singleton service<a id="_idIndexMarker226"/> is created the first time it is requested or when providing the implementation instance to the service container. All subsequent requests will use the same instance.</li>
</ul>
<p>To demonstrate the difference between these lifetimes, we will use a simple demo service:</p>
<p>Create a new interface named <code>IDemoService</code> and its implementation named <code>DemoService</code> in the <code>Services</code> folder, as shown next:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">IDemoService.cs:</p>
<pre class="source-code">
<code>namespace DependencyInjectionDemo.Services;</code><code>public interface IDemoService</code>
<code>{</code>
<code>    SayHello();</code>
<code>}</code></pre>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">DemoService.cs:</p>
<pre class="source-code">
<code>namespace DependencyInjectionDemo.Services;</code><code>public class DemoService : IDemoService</code>
<code>{</code>
<code>    private readonly Guid _serviceId;</code>
    private readonly DateTime _createdAt;
<code>    public DemoService()</code>
<code>    {</code>
<code>        _serviceId = Guid.NewGuid();</code>
        _createdAt = DateTime.Now;
<code>    }</code>
<code>    public string SayHello()</code>
<code>    {</code>
<code>        return $"Hello! My Id is {_serviceId}. I was created at {_createdAt:yyyy-MM-dd HH:mm:ss}.</code>
<code>";</code>
<code>    }</code>
<code>}</code></pre>
<p class="list-inset">The implementation will generate an ID and a time when it was created, and output it when the <code>SayHello()</code> method is called.</p>
<ol>
<li>Then, we<a id="_idIndexMarker227"/> can register the interface and the implementation to the service container. Open the <code>Program.cs</code> file and add the code as follows:<pre class="source-code">
<code>builder.Services.AddScoped&lt;IDemoService, DemoService&gt;();</code></pre></li> <li>Create a controller named <code>DemoController.cs</code>. Now, we can add the service as constructor parameters to inject the dependency:<pre class="source-code">
<code>[ApiController]</code><code>[Route("[controller]")]</code><code>public class DemoController : ControllerBase</code><code>{</code><code>    private readonly IDemoService _demoService;</code><code>    public DemoController(IDemoService demoService)</code><code>    {</code><code>        _demoService = demoService;</code><code>    }</code><code>    [HttpGet]</code><code>    public ActionResult Get()</code><code>    {</code><code>        return Content(_demoService.SayHello());</code><code>    }</code><code>}</code></pre></li> </ol>
<p>For this <a id="_idIndexMarker228"/>example, if you test the <code>/demo</code> endpoint, you will see the GUID value and the creation time in the output change every time:</p>
<pre class="console">
<code>http://localhost:5147/&gt; get demo</code><code>HTTP/1.1 200 OK</code>
<code>Content-Length: 91</code>
<code>Content-Type: text/plain; charset=utf-8</code>
<code>Date: Fri, 20 Oct 2023 22:06:46 GMT</code>
<code>Server: Kestrel</code>
<code>Hello! My Id is 6ca84d82-90cb-4dd6-9a34-5ea7573508ac. I was created at 2023-10-21 11:06:46.</code>
<code>http://localhost:5147/&gt; get demo</code>
<code>HTTP/1.1 200 OK</code>
<code>Content-Length: 91</code>
<code>Content-Type: text/plain; charset=utf-8</code>
<code>Date: Fri, 20 Oct 2023 22:07:02 GMT</code>
<code>Server: Kestrel</code>
<code>Hello! My Id is 9bc5cf49-661d-45bb-b9ed-e0b3fe937827. I was created at 2023-10-21 11:07:02.</code></pre>
<p>We can<a id="_idIndexMarker229"/> change the lifetime to <code>AddSingleton()</code>, as follows:</p>
<pre class="source-code">
builder.Services.AddSingleton&lt;IDemoService, DemoService&gt;();</pre> <p>The GUID values and the creation time values will be the same for all requests:</p>
<pre class="console">
http://localhost:5147/&gt; get demoHTTP/1.1 200 OK
Content-Length: 91
Content-Type: text/plain; charset=utf-8
Date: Fri, 20 Oct 2023 22:08:57 GMT
Server: Kestrel
Hello! My Id is a1497ead-bff6-4020-b337-28f1d3af7b05. I was created at 2023-10-21 11:08:02.
http://localhost:5147/&gt; get demo
HTTP/1.1 200 OK
Content-Length: 91
Content-Type: text/plain; charset=utf-8
Date: Fri, 20 Oct 2023 22:09:12 GMT
Server: Kestrel
Hello! My Id is a1497ead-bff6-4020-b337-28f1d3af7b05. I was created at 2023-10-21 11:08:02.</pre>
<p>As the <code>DemoController</code> class only requests the <code>IDemoService</code> interface once for each request, we cannot differentiate the behavior between <code>scoped</code> and <code>transient</code> services. Let us look at a more complex example.</p>
<ol>
<li>You can <a id="_idIndexMarker230"/>find the example code in the <code>DependencyInjectionDemo</code> project. There are three interfaces along with their implementations:<pre class="source-code">
public interface IService{    string Name { get; }    string SayHello();}public interface ITransientService : IService{}public class TransientService : ITransientService{    private readonly Guid _serviceId;<code>    private readonly DateTime _createdAt;</code>    public TransientService()    {        _serviceId = Guid.NewGuid();        _createdAt = DateTime.Now;    }    public string Name =&gt; nameof(TransientService);    public string SayHello()    {        return $"Hello! I am {Name}. My Id is {_serviceId}. <code>I was created at {_createdAt:yyyy-MM-dd HH:mm:ss}.</code>";    }}public interface ISingletonService : IService{}public class SingletonService : ISingletonService{    private readonly Guid _serviceId;    private readonly DateTime _createdAt;    public SingletonService()    {        _serviceId = Guid.NewGuid();        _createdAt = DateTime.Now;    }    public string Name =&gt; nameof(SingletonService);    public string SayHello()    {        return $"Hello! I am {Name}. My Id is {_serviceId}.<code> I was created at {_createdAt:yyyy-MM-dd HH:mm:ss}.</code>";    }}public interface IScopedService : IService{}public class ScopedService : IScopedService{    private readonly Guid _serviceId;    private readonly DateTime _createdAt;    private readonly ITransientService _transientService;    private readonly ISingletonService _singletonService;    public ScopedService(ITransientService transientService, ISingletonService singletonService)    {        _transientService = transientService;        _singletonService = singletonService;        _serviceId = Guid.NewGuid();        _createdAt = DateTime.Now;    }    public string Name =&gt; nameof(ScopedService);    public string SayHello()    {        var scopedServiceMessage = $"Hello! I am {Name}. My Id is {_serviceId}.<code> I was created at {_createdAt:yyyy-MM-dd HH:mm:ss}.</code>";        var transientServiceMessage = $"{_transientService.SayHello()} I am from {Name}.";        var singletonServiceMessage = $"{_singletonService.SayHello()} I am from {Name}.";        return            $"{scopedServiceMessage}{Environment.NewLine}{transientServiceMessage}{Environment.NewLine}{singletonServiceMessage}";    }}</pre></li> <li>In the <code>Program.cs</code> file, we can register them to the service container as follows:<pre class="source-code">
builder.Services.AddScoped&lt;IScopedService, ScopedService&gt;();builder.Services.AddTransient&lt;ITransientService, TransientService&gt;();builder.Services.AddSingleton&lt;ISingletonService, SingletonService&gt;();</pre></li> <li>Then, create <a id="_idIndexMarker231"/>a controller named <code>LifetimeController.cs</code>. The code is shown next:<pre class="source-code">
[ApiController][Route("[controller]")]public class LifetimeController : ControllerBase{    private readonly IScopedService _scopedService;    private readonly ITransientService _transientService;    private readonly ISingletonService _singletonService;    public LifetimeController(IScopedService scopedService, ITransientService transientService,        ISingletonService singletonService)    {        _scopedService = scopedService;        _transientService = transientService;        _singletonService = singletonService;    }    [HttpGet]    public ActionResult Get()    {        var scopedServiceMessage = _scopedService.SayHello();        var transientServiceMessage = _transientService.SayHello();        var singletonServiceMessage = _singletonService.SayHello();        return Content(            $"{scopedServiceMessage}{Environment.NewLine}{transientServiceMessage}{Environment.NewLine}{singletonServiceMessage}");    }}</pre></li> </ol>
<p>In this <a id="_idIndexMarker232"/>example, <code>ScopedService</code> has two dependencies: <code>ITransientService</code> and <code>ISingletonService</code>. So, when <code>ScopedService</code> is created, it will ask for the instances of these dependencies from the service container. On the other hand, the controller also has dependencies: <code>IScopedService</code>, <code>ITransientService</code>, and <code>ISingletonService</code>. When the controller is created, it will ask for these three dependencies. That means <code>ITransientService</code> and <code>ISingletonService</code> will be needed twice for each request. But let us check the output of the following requests:</p>
<pre class="console">
<code>http://localhost:5147/&gt; get lifetime</code><code>HTTP/1.1 200 OK</code>
<code>Content-Length: 625</code>
<code>Content-Type: text/plain; charset=utf-8</code>
<code>Date: Fri, 20 Oct 2023 22:20:44 GMT</code>
<code>Server: Kestrel</code>
<code>Hello! I am ScopedService. My Id is df87d966-0e86-4f08-874f-ba6ce71de560. I was created at 2023-10-21 11:20:44.</code>
<code>Hello! I am TransientService. My Id is 77e29268-ad48-423c-94e5-de1d09bd3ba5. I was created at 2023-10-21 11:20:44. I am from ScopedService.</code>
<code>Hello! I am SingletonService. My Id is 95a44c5b-8678-48c6-a2f0-cc6b90423773. I was created at 2023-10-21 11:20:44. I am from ScopedService.</code>
<code>Hello! I am TransientService. My Id is e77564d1-e146-4d29-b74b-a07f8f6640c1. I was created at 2023-10-21 11:20:44.</code>
<code>Hello! I am SingletonService. My Id is 95a44c5b-8678-48c6-a2f0-cc6b90423773. I was created at 2023-10-21 11:20:44.</code>
<code>http://localhost:5147/&gt; get lifetime</code>
<code>HTTP/1.1 200 OK</code>
<code>Content-Length: 625</code>
<code>Content-Type: text/plain; charset=utf-8</code>
<code>Date: Fri, 20 Oct 2023 22:20:57 GMT</code>
<code>Server: Kestrel</code>
<code>Hello! I am ScopedService. My Id is e5f802ed-5e4c-4abd-9213-8f13f97c1008. I was created at 2023-10-21 11:20:57.</code>
<code>Hello! I am TransientService. My Id is daccb91b-438f-4561-9c86-13b02ad8e358. I was created at 2023-10-21 11:20:57. I am from ScopedService.</code>
<code>Hello! I am SingletonService. My Id is 95a44c5b-8678-48c6-a2f0-cc6b90423773. I was created at 2023-10-21 11:20:44. I am from ScopedService.</code>
<code>Hello! I am TransientService. My Id is 94e9e6c1-729a-4033-8a27-550ea10ba5d0. I was created at 2023-10-21 11:20:57.</code>
<code>Hello! I am SingletonService. My Id is 95a44c5b-8678-48c6-a2f0-cc6b90423773. I was created at 2023-10-21 11:20:44.</code></pre>
<p>We can see that in each <a id="_idIndexMarker233"/>request, <code>ScopedService</code> was created once, while <code>ITransientService</code> was created twice. In both requests, <code>SingletonService</code> was created only once.</p>
<h3>Group registration</h3>
<p>As the<a id="_idIndexMarker234"/> project grows, we may have more and more services. If we register all services in <code>Program.cs</code>, this file will be very large. For this case, we can use group registration to register multiple services at once. For example, we can create a service group named <code>LifetimeServicesCollectionExtensions.cs</code>:</p>
<pre class="source-code">
public static class LifetimeServicesCollectionExtensions{
    public static IServiceCollection AddLifetimeServices(this IServiceCollection services)
    {
        services.AddScoped&lt;IScopedService, ScopedService&gt;();
        services.AddTransient&lt;ITransientService, TransientService&gt;();
        services.AddSingleton&lt;ISingletonService, SingletonService&gt;();
        return services;
    }
}</pre>
<p>This is an extension method for the <code>IServiceCollection</code> interface. It is used to register all services at once in the <code>Program.cs</code> file:</p>
<pre class="source-code">
// Group registrationbuilder.Services.AddLifetimeServices();</pre>
<p>In this way, the <code>Program.cs</code> file will be <a id="_idTextAnchor120"/>smaller and easier to read.</p>
<h3>Action injection</h3>
<p>Sometimes, one<a id="_idIndexMarker235"/> controller may need many services but may not need all of them for all actions. If we inject all the dependencies from the constructor, the constructor method will be large. For this case, we can use action injection to inject dependencies only when needed. See the following example:</p>
<pre class="source-code">
[HttpGet]public ActionResult Get([FromServices] ITransientService transientService)
{
  ...
}</pre>
<p>The <code>[FromServices]</code> attribute enables the service container to inject dependencies when needed without using constructor injection. However, if you find that a service needs a lot of dependencies, it may indicate that the class has too many responsibilities. Based on<a id="_idIndexMarker236"/> the <strong class="bold">Single Responsibility Principle</strong> (<strong class="bold">SRP</strong>), consider refactoring the class to split the responsibilities into smaller classes.</p>
<p>Keep in mind that this kind of action injection only works for actions in the controller. It does not support normal classes. Additionally, since ASP.NET Core 7.0, the <code>[FromServices]</code> attribute can be omitted as the framework will automatically attempt to resolve any complex type parameters registered in the DI container.</p>
<h3>Keyed services</h3>
<p>ASP.NET Core 8.0 introduces <a id="_idIndexMarker237"/>a new feature known as keyed services, or named services. This feature allows developers to register services with a key, allowing them to access the service with that key. This makes it easier to manage multiple services that implement the same interface within an application, as the key can be used to identify and access the service.</p>
<p>For example, we have a service interface named <code>IDataService</code>:</p>
<pre class="source-code">
<code>public interface IDataService</code><code>{</code>
<code>    string GetData();</code>
<code>}</code></pre>
<p>This <code>IDataService</code> interface has two implementations: <code>SqlDatabaseService</code> and <code>CosmosDatabaseService</code>:</p>
<pre class="source-code">
<code>public class SqlDatabaseService : IDataService</code><code>{</code>
<code>    public string GetData()</code>
<code>    {</code>
<code>        return "Data from SQL Database";</code>
<code>    }</code>
<code>}</code>
<code>public class CosmosDatabaseService : IDataService</code>
<code>{</code>
<code>    public string GetData()</code>
<code>    {</code>
<code>        return "Data from Cosmos Database";</code>
<code>    }</code>
<code>}</code></pre>
<p>We can register<a id="_idIndexMarker238"/> them to the service container using different keys:</p>
<pre class="source-code">
<code>builder.Services.AddKeyedScoped&lt;IDataService, SqlDatabaseService&gt;("sqlDatabaseService");</code><code>builder.Services.AddKeyedScoped&lt;IDataService, CosmosDatabaseService&gt;("cosmosDatabaseService");</code></pre>
<p>Then, we can inject the service by using the <code>FromKeyedServices</code> attribute:</p>
<pre class="source-code">
<code>[ApiController]</code><code>[Route("[controller]")]</code>
<code>public class KeyedServicesController : ControllerBase</code>
<code>{</code>
<code>    [HttpGet("sql")]</code>
<code>    public ActionResult GetSqlData([FromKeyedServices("sqlDatabaseService")] IDataService dataService) =&gt;</code>
        <code>Content(dataService.GetData());</code>
    <code>[HttpGet("cosmos")]</code>
    <code>public ActionResult GetCosmosData([FromKeyedServices("cosmosDatabaseService")] IDataService dataService) =&gt;</code>
        <code>Content(dataService.GetData());</code>
<code>}</code></pre>
<p>The <code>FromKeyedServices</code> attribute <a id="_idIndexMarker239"/>is used to inject the service by using the specified key. Test the API with HttpRepl, and you will see the output as follows:</p>
<pre class="source-code">
<code>http://localhost:5147/&gt; get keyedServices/sql</code><code>HTTP/1.1 200 OK</code>
<code>Content-Length: 22</code>
<code>Content-Type: text/plain; charset=utf-8</code>
<code>Date: Fri, 20 Oct 2023 22:48:49 GMT</code>
<code>Server: Kestrel</code>
<code>Data from SQL Database</code>
<code>http://localhost:5147/&gt; get keyedServices/cosmos</code>
<code>HTTP/1.1 200 OK</code>
<code>Content-Length: 25</code>
<code>Content-Type: text/plain; charset=utf-8</code>
<code>Date: Fri, 20 Oct 2023 22:48:54 GMT</code>
<code>Server: Kestrel</code>
<code>Data from Cosmos Database</code></pre>
<p>The <a id="_idIndexMarker240"/>keyed services can be used to register singleton or transient services as well. Just use the <code>AddKeyedSingleton()</code> or <code>AddKeyedTransient()</code> method respectively; for example:</p>
<pre class="source-code">
<code>builder.Services.AddKeyedSingleton&lt;IDataService, SqlDatabaseService&gt;("sqlDatabaseService");</code><code>builder.Services.AddKeyedTransient&lt;IDataService, CosmosDatabaseService&gt;("cosmosDatabaseService");</code></pre>
<p>It is important to note that if an empty string is passed as the key, a default implementation<a id="_idIndexMarker241"/> for the service must be registered with a key of an empty string, otherwise the service <a id="_idTextAnchor121"/>container will throw an exception.</p>
<p>Microsoft releases new versions of .NET SDKs frequently. If you encounter a different version number, that is acceptable.</p>
<p>The preceding command will list all the available SDKs on your machine. For example, it may show the following output if have multiple .NET SDKs installed.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Every Microsoft product has a lifecycle. .NET and .NET Core provides <strong class="bold">Long-term support</strong> (<strong class="bold">LTS</strong>) releases that get 3 years of patches and free support. When this book was written, .NET 7 is still supported, until May 2024. Based on Microsoft’s policy, even numbered releases are LTS releases. So .NET 8 is the latest LTS release. The code samples in this book are written with .NET 8.0.</p>
<p>When you use VS Code to open the project, the C# Dev Kit extension can create a solution file for you. This feature makes VS Code more friendly to C# developers. You can see the following structure in the Explorer view:</p>
<p>It uses the <code>Swashbuckle.AspNetCore</code> NuGet package, which provides the Swagger UI to document and test the APIs.</p>
<p>Follow the steps below to use DI in ASP.NET Core:</p>
<p>We can see that in each request, <code>ScopedService</code> was created once, while <code>ITransientService</code> was created twice. In both requests, <code>SingletonService</code> was created only once.</p>
<h3>Using primary constructors to inject dependencies</h3>
<p>Beginning with .NET 8 and C# 12, we can use the <a id="_idIndexMarker242"/>primary constructor<a id="_idIndexMarker243"/> to inject dependencies. A primary constructor allows us to declare the constructor parameters directly in the class declaration, instead of <a id="_idIndexMarker244"/>using a separate constructor method. For example, we can update the <code>PostsController</code> class as follows:</p>
<pre class="source-code">
```csharppublic class PostsController(IPostService postService) : ControllerBase
{
    // No need to define a private field to store the service 
    // No need to define a constructor method
}
```</pre>
<p>You can <a id="_idIndexMarker245"/>find a sample named <code>PrimaryConstructorController.cs</code> in the <code>Controller</code> folder of the <code>DependencyInjectionDemo</code> project.</p>
<p>When using the primary constructor in a class, note that the parameters passed to the class declaration cannot be used as properties or members. For example, if a class declares a parameter named <code>postService</code> in the class declaration, it cannot be accessed as a class member using <code>this.postService</code> or from external code. To learn more about the primary constructor, please refer to the documentation at https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/instance-constructors#primary-constructors.</p>
<p>Primary constructors can save us from writing fields and constructor methods. So, we’ll use them in the following examples.</p>
<p>Do not use <code>new</code> to create service B, otherwise, service A will be tightly coupled with service B.</p>
<h3>Resolving a service when the app starts</h3>
<p>If we <a id="_idIndexMarker246"/>need a service in the <code>Program.cs</code> file, we cannot use constructor injection. For this situation, we can resolve a scoped service for a limited duration at app startup, as follows:</p>
<pre class="source-code">
var app = builder.Build();using (var serviceScope = app.Services.CreateScope())
{
    var services = serviceScope.ServiceProvider;
    var demoService = services.GetRequiredService&lt;IDemoService&gt;();
    var message = demoService.SayHello()<a id="_idTextAnchor122"/>;
    Console.WriteLine(message);
}</pre>
<p>The preceding code creates a scope and resolves the <code>IDemoService</code> service from the service container. Then, it can use the service to do something. After the scope is disposed of, the service will be disposed of as well.</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor123"/>DI tips</h2>
<p>ASP.NET Core <a id="_idIndexMarker247"/>uses DI heavily. The following are some tips to help you use DI:</p>
<ul>
<li>When designing your services, make the services as stateless as possible. Do not use static classes and members unless you have to do so. If you need to use a global state, consider using a singleton service instead.</li>
<li>Carefully design dependency relationships between services. Do not create a cyclic dependency.</li>
<li>Do not use <code>new</code> to create a service instance in another service. For example, if service A depends on service B, the instance of service B should be injected into service A with DI. Do not use <code>new</code> to create service B, otherwise, service A will be tightly coupled with service B.</li>
<li>Use a <a id="_idIndexMarker248"/>DI container to manage the lifetime of services. If a service implements the <code>IDisposable</code> interface, the DI container will dispose of the service when the scope is disposed of. Do not manually dispose of it.</li>
<li>When registering a service, do not use <code>new</code> to create an instance of the service. For example, <code>services.AddSingleton(new ExampleService());</code> registers a service instance that is not managed by the service container. So, the DI framework will not be able to dispose of the service automatically.</li>
<li>Avoid using the service locator pattern. If DI can be used, do not use the <code>GetService()</code> method to obtain a service instance.</li>
</ul>
<p>You can learn more about the DI guidelines at <a href="https://docs.microsoft.com/zh-cn/dotnet/core/extensions/dependency-injection-guidelines">https://docs.microsoft.com/zh-cn/dotnet/core/extensions/dependency-injection-guidelines</a>.</p>
<p class="callout-heading">Why there is no configuration method for the logger in the template project?</p>
<p class="callout">ASP.NET Core provides a built-in DI implementation for the logger. When the project was created, logging was registered by the ASP.NET Core framework. Therefore, there is no configuration method for the logger in the template project. Actually, there are more than 250 services that are automatically registered by the ASP.NET Core framework.</p>
<p class="callout-heading">Can I use third-party DI containers?</p>
<p class="callout">It is highly recommended that you use the built-in DI implementation in ASP.NET Core. But if you need any specific features that it does not support, such as property injection, <code>Func&lt;T&gt;</code> support for lazy initialization, and so on, you can use third-party DI containers, such as <em class="italic">Autofac</em> (<a href="https://autofac.org/">https://autofac.org/</a>).</p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor124"/>Introduction to minimal APIs</h1>
<p>In the <a id="_idIndexMarker249"/>previous section, <em class="italic">Creating a simple web API project</em>, we created a simple web API project using the <code>dotnet new webapi -n MyFirstApi -controllers</code> command. The <code>-controllers</code> option (or <code>--use-controllers</code>) indicates that the project will use controller-based routing. Alternatively, the             <code>-minimal</code> or <code>--use-minimal-apis</code> option can be used to create a project that uses minimal APIs. In this section, we will introduce minimal APIs.</p>
<p>Minimal APIs is a new feature introduced in ASP.NET Core 6.0. It is a new way to create APIs without using controllers. Minimal APIs are designed to be simple and lightweight with minimal dependencies. They are a good choice for small projects or prototypes, and also for projects that do not need the full features of controllers.</p>
<p>To create a minimal API project, we can use the following command:</p>
<p><code>dotnet new webapi -n </code><code>MinimalApiDemo -minimal</code></p>
<p>There is no <code>Controllers</code> folder in the project. Instead, you can find the following code in the <code>Program.cs</code> file:</p>
<pre class="source-code">
app.MapGet("/weatherforecast", () =&gt;{
    var forecast =  Enumerable.Range(1, 5).Select(index =&gt;
        new WeatherForecast
        (
            DateOnly.FromDateTime(DateTime.Now.AddDays(index)),
            Random.Shared.Next(-20, 55),
            summaries[Random.Shared.Next(summaries.Length)]
        ))
        .ToArray();
    return forecast;
})
.WithName("GetWeatherForecast")
.WithOpenApi();</pre>
<p>The preceding<a id="_idIndexMarker250"/> code uses the <code>MapGet()</code> method to map the <code>GET</code> request to the <code>/weatherforecast</code> endpoint. The <code>MapGet()</code> method is an extension method of the <code>IEndpointRouteBuilder</code> interface. This interface is used to configure the endpoints in the application. Its extension method, <code>MapGet()</code>, returns an <code>IEndpointConventionBuilder</code> interface that allows us to use fluent APIs to configure the endpoint by using other extension methods, such as <code>WithName()</code> and <code>WithOpenApi()</code>. The <code>WithName()</code> method is used to set the name of the endpoint. The <code>WithOpenApi()</code> method is used to generate an OpenAPI document for the endpoint.</p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor125"/>Creating a simple endpoint</h2>
<p>Let us<a id="_idIndexMarker251"/> create a new <code>/posts</code> endpoint that supports CRUD operations. First, add the following code to the end of the <code>Program.cs</code> file to define a <code>Post</code> class:</p>
<pre class="source-code">
public class Post{
    public int Id { get; set; }
    public string Title { get; set; } = string.Empty;
    public string Content { get; set; } = string.Empty;
}</pre>
<p>Add the following code to the <code>Program.cs</code> file:</p>
<pre class="source-code">
var list = new List&lt;Post&gt;(){
    new() { Id = 1, Title = "First Post", Content = "Hello World" },
    new() { Id = 2, Title = "Second Post", Content = "Hello Again" },
    new() { Id = 3, Title = "Third Post", Content = "Goodbye World" },
};
app.MapGet("/posts",
    () =&gt; list).WithName("GetPosts").WithOpenApi().WithTags("Posts");
app.MapPost("/posts",
    (Post post) =&gt;
    {
        list.Add(post);
        return Results.Created($"/posts/{post.Id}", post);
    }).WithName("CreatePost").WithOpenApi().WithTags("Posts");
app.MapGet("/posts/{id}", (int id) =&gt;
{
    var post = list.FirstOrDefault(p =&gt; p.Id == id);
    return post == null ? Results.NotFound() : Results.Ok(post);
}).WithName("GetPost").WithOpenApi().WithTags("Posts");
app.MapPut("/posts/{id}", (int id, Post post) =&gt;
{
    var index = list.FindIndex(p =&gt; p.Id == id);
    if (index == -1)
    {
        return Results.NotFound();
    }
    list[index] = post;
    return Results.Ok(post);
}).WithName("UpdatePost").WithOpenApi().WithTags("Posts");
app.MapDelete("/posts/{id}", (int id) =&gt;
{
    var post = list.FirstOrDefault(p =&gt; p.Id == id);
    if (post == null)
    {
        return Results.NotFound();
    }
    list.Remove(post);
    return Results.Ok();
}).WithName("DeletePost").WithOpenApi().WithTags("Posts");</pre>
<p>The preceding <a id="_idIndexMarker252"/>code defines five endpoints:</p>
<ul>
<li><code>GET /posts</code>: Get all posts</li>
<li><code>POST /posts</code>: Create a new post</li>
<li><code>GET /posts/{id}</code>: Get a post by ID</li>
<li><code>PUT /posts/{id}</code>: Update a post by ID</li>
<li><code>DELETE /posts/{id}</code>: Delete a post by ID</li>
</ul>
<p>We use the <code>WithTags</code> extension method to group these endpoints into a tag named <code>Posts</code>. In this example, a list is used to store the posts. In a real-world application, we should use a database to store the data.</p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor126"/>Using DI in minimal APIs</h2>
<p>Minimal APIs <a id="_idIndexMarker253"/>support DI as well. You can find the <code>IPostService</code> interface and its <code>PostService</code> implementation in the <code>Services</code> folder. Here is an example of using DI in minimal APIs:</p>
<pre class="source-code">
app.MapGet("/posts", async (IPostService postService) =&gt;{
    var posts = await postService.GetPostsAsync();
    return posts;
}).WithName("GetPosts").WithOpenApi().WithTags("Posts");
app.MapGet("/posts/{id}", async (IPostService postService, int id) =&gt;
{
    var post = await postService.GetPostAsync(id);
    return post == null ? Results.NotFound() : Results.Ok(post);
}).WithName("GetPost").WithOpenApi().WithTags("Posts");
app.MapPost("/posts", async (IPostService postService, Post post) =&gt;
{
    var createdPost = await postService.CreatePostAsync(post);
    return Results.Created($"/posts/{createdPost.Id}", createdPost);
}).WithName("CreatePost").WithOpenApi().WithTags("Posts");
app.MapPut("/posts/{id}", async (IPostService postService, int id, Post post) =&gt;
{
    try
    {
        var updatedPost = await postService.UpdatePostAsync(id, post);
        return Results.Ok(updatedPost);
    }
    catch (KeyNotFoundException)
    {
        return Results.NotFound();
    }
}).WithName("UpdatePost").WithOpenApi().WithTags("Posts");
app.MapDelete("/posts/{id}", async (IPostService postService, int id) =&gt;
{
    try
    {
        await postService.DeletePostAsync(id);
        return Results.NoContent();
    }
    catch (KeyNotFoundException)
    {
        return Results.NotFound();
    }
}).WithName("DeletePost").WithOpenApi().WithTags("Posts");</pre>
<p>In the<a id="_idIndexMarker254"/> preceding code, the <code>IPostService</code> interface is used as a parameter of the action method. The DI container will inject the correct implementation into the action method. You can run the project and test the endpoints. It should have the same behavior as the controller-based project.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor127"/>What is the difference between minimal APIs and controller-based APIs?</h2>
<p>Minimal APIs are <a id="_idIndexMarker255"/>simpler than controller-based APIs, allowing us to map endpoints to methods directly. This makes minimal APIs a good choice for quickly creating simple APIs or demo projects. However, minimal APIs do not support the full range of features that controllers provide, such as model binding, model validation, and so on. These features may be added in the future. Therefore, we will mainly use controller-based APIs and not discuss minimal APIs in detail in this book. If you want to learn more about minimal APIs, please refer to the official documentation at <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis">https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis</a>.</p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor129"/>Summary</h1>
<p>In this chapter, we created a simple web API project and introduced how to run the project locally and call the APIs with different clients. We implemented basic CRUD operations using an in-memory list. Also, we explained how to use DI in ASP.NET Core. We explored the lifetime of services and learned some tips. In addition, we introduced minimal APIs. In the next chapter, we will delve further into the built-in components of ASP.NET Core.</p>
</div>
</body></html>