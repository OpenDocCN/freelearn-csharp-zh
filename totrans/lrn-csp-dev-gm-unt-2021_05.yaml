- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Working with Classes, Structs, and OOP
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与类、结构体和OOP一起工作
- en: 'For obvious reasons, the goal of this book isn''t to give you a splitting headache
    from information overload. However, these next topics will take you out of the
    beginner''s cubicle and into the open air of **object-oriented programming** (**OOP**).
    Up to this point, we''ve been relying exclusively on predefined variable types
    that are part of the C# language: under-the-hood strings, lists, and dictionaries
    that are classes, which is why we can create them and use their properties through
    dot notation. However, relying on built-in types has one glaring weakness—the
    inability to deviate from the blueprints that C# has already set.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于显而易见的原因，本书的目标不是让你因为信息过载而头痛欲裂。然而，接下来的这些主题将带你走出初学者的隔间，进入**面向对象编程**（**OOP**）的广阔天地。到目前为止，我们一直在依赖C#语言中作为其一部分的预定义变量类型：底层的字符串、列表和字典都是类，这就是为什么我们可以通过点符号创建它们并使用它们的属性。然而，依赖内置类型有一个明显的弱点——无法偏离C#已经设定的蓝图。
- en: Creating your classes gives you the freedom to define and configure blueprints
    of your design, capturing information and driving action that is specific to your
    game or application. In essence, custom classes and OOP are the keys to the programming
    kingdom; without them, unique programs will be few and far between.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你的类为你提供了定义和配置设计蓝图的自由，捕捉特定于你的游戏或应用程序的信息和驱动动作。本质上，自定义类和OOP是编程王国的钥匙；没有它们，独特的程序将寥寥无几。
- en: 'In this chapter, you''ll get hands-on experience creating classes from scratch
    and discuss the inner workings of class variables, constructors, and methods.
    You''ll also be introduced to the differences between reference and value type
    objects, and how these concepts can be applied inside Unity. The following topics
    will be discussed in more detail as you move along:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将亲自动手从头创建类，并讨论类变量、构造函数和方法的工作原理。你还将了解到引用类型和值类型对象的区别，以及这些概念如何在Unity中应用。随着你的学习深入，以下主题将更详细地讨论：
- en: Introducing OOP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程简介
- en: Defining classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义类
- en: Declaring structs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明结构体
- en: Understanding reference and value types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解引用类型和值类型
- en: Integrating the object-oriented mindset
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整合面向对象思维
- en: Applying OOP in Unity
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity中应用OOP
- en: Introducing OOP
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程简介
- en: OOP is the main programming paradigm that you'll use when coding in C#. If class
    and struct instances are the blueprints of our programs, then OOP is the architecture
    that holds everything together. When we refer to OOP as a programming paradigm,
    we are saying that it has specific principles for how the overall program should
    work and communicate.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）是你在使用C#进行编码时将使用的主要编程范式。如果类和结构体实例是我们程序的原型，那么OOP就是将一切联系起来的架构。当我们提到OOP作为编程范式时，我们是在说它有特定的原则来指导整体程序应该如何工作和通信。
- en: Essentially, OOP focuses on objects rather than pure sequential logic—the data
    they hold, how they drive action, and, most importantly, how they communicate
    with each other.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，OOP关注的是对象而不是纯粹的顺序逻辑——它们持有的数据、它们如何驱动动作，以及最重要的是，它们如何相互通信。
- en: Defining classes
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义类
- en: Back in *Chapter 2*, *The Building Blocks of Programming*, we briefly talked
    about how classes are blueprints for objects and mentioned that they can be treated
    as custom variable types. We also learned that the `LearningCurve`script is a
    class, but a special one that Unity can attach to objects in the scene. The main
    thing to remember with classes is that they are *reference types*—that is, when
    they are assigned or passed to another variable, the original object is referenced,
    not a new copy. We'll get into this after we discuss structs. However, before
    any of that, we need to understand the basics of creating classes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 回到*第二章*，*编程的基本元素*，我们简要地讨论了类是如何作为对象的原型，并提到它们可以被当作自定义变量类型。我们还了解到`LearningCurve`脚本是一个类，但它是Unity可以附加到场景中对象的特殊类。关于类，我们需要记住的主要事情是它们是*引用类型*——也就是说，当它们被分配或传递给另一个变量时，引用的是原始对象，而不是一个新的副本。在讨论结构体之后，我们再深入探讨这一点。然而，在所有这些之前，我们需要了解创建类的基础知识。
- en: 'For now, we''re going to set aside how classes and scripts work in Unity and
    focus on how they are created and used in C#. Classes are created using the `class`
    keyword, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将暂时放下Unity中类和脚本的工作方式，专注于在C#中它们是如何创建和使用的。类是通过使用`class`关键字创建的，如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Any variables or methods declared inside a class belong to that class and are
    accessed through its unique class name.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在类内部声明的任何变量或方法都属于该类，并且可以通过其唯一的类名来访问。
- en: To make the examples as cohesive as possible throughout this chapter, we'll
    be creating and modifying a simple `Character` class that a typical game would
    have. We'll also be moving away from code screenshots to get you accustomed to
    reading and interpreting code as you would see it "in the wild." However, the
    first thing we need is a custom class of our own, so let's create one.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本章中的示例尽可能连贯，我们将创建和修改一个典型的游戏会有的简单 `Character` 类。我们还将从代码截图转向让你习惯于像在“野外”看到的那样阅读和解释代码。然而，我们首先需要的是我们自己的自定义类，所以让我们创建一个。
- en: 'We''ll need a class to practice with before we can understand their inner workings,
    so let''s create a new C# script and start from scratch:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够理解它们的内部工作原理之前，我们需要一个类来练习，所以让我们创建一个新的 C# 脚本并从头开始：
- en: Right-click on the `Scripts` folder that you created in *Chapter 1*, *Getting
    to Know Your Environment*, and choose **Create** | **C# Script**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击你在 *第一章*，*了解你的环境* 中创建的 `Scripts` 文件夹，然后选择 **创建** | **C# 脚本**。
- en: Name the script `Character`, open it up in Visual Studio, and delete all the
    generated code.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本命名为 `Character`，在 Visual Studio 中打开它，并删除所有生成的代码。
- en: 'Declare a public class called `Character` followed by a set of curly braces,
    and then save the file. Your class code should exactly match the following code:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `Character` 的公共类，然后跟着一组花括号，然后保存文件。你的类代码应该与以下代码完全匹配：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We deleted the generated code because we won't need to attach this script to
    a Unity GameObject.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们删除了生成的代码，因为我们不需要将此脚本附加到 Unity GameObject 上。
- en: '`Character` is now registered as a public class blueprint. This means that
    any class in the project can use it to create characters. However, these are just
    the instructions—to create a character takes an additional step. This creational
    step is called *instantiation* and is the subject of the next section.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Character` 现在已注册为公共类蓝图。这意味着项目中的任何类都可以使用它来创建角色。然而，这些只是指令——创建一个角色需要额外的步骤。这个创建步骤被称为
    *实例化*，也是下一节的主题。'
- en: Instantiating class objects
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化类对象
- en: Instantiation is the act of creating an object from a specific set of instructions,
    which is called an instance. If classes are blueprints, instances are the houses
    built from their instructions; every new instance of `Character` is its object,
    just like two houses built from the same instructions are still two different
    physical structures. What happens to one doesn't have any repercussions on the
    other.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化是从一组特定的指令创建对象的行为，这些指令被称为实例。如果类是蓝图，那么实例就是根据它们的指令建造的房屋；每个新的 `Character` 实例都是它的对象，就像根据相同指令建造的两个房屋仍然是两个不同的物理结构一样。一个发生的事情不会对另一个有任何影响。
- en: In *Chapter 4*, *Control Flow and Collection Types*, we created lists and dictionaries,
    which are default classes that come with C#, using their types and the `new` keyword.
    We can do the same thing for custom classes such as `Character`, which you'll
    do next.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第四章*，*控制流和集合类型* 中，我们创建了列表和字典，这些是 C# 中的默认类，使用它们的类型和 `new` 关键字。我们也可以为自定义类，如
    `Character`，做同样的事情，你将在下一节中这样做。
- en: We declared the `Character` class as public, which means that a `Character`
    instance can be created in any other class. Since we have `LearningCurve`working
    already, let's declare a new character in the `Start()` method.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `Character` 类声明为公共的，这意味着可以在任何其他类中创建 `Character` 实例。由于我们已经有了 `LearningCurve`
    在工作，让我们在 `Start()` 方法中声明一个新的角色。
- en: 'Open `LearningCurve` and declare a new `Character` type variable, called `hero`,
    in the `Start()` method:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `LearningCurve` 并在 `Start()` 方法中声明一个新的 `Character` 类型变量，名为 `hero`：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s break this down one step at a time:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地分解这个过程：
- en: The variable type is specified as `Character`, meaning that the variable is
    an instance of that class.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量类型指定为 `Character`，这意味着该变量是该类的一个实例。
- en: The variable is named `hero`, and it is created using the `new` keyword, followed
    by the `Character` class name and two parentheses. This is where the actual instance
    is created in the program's memory, even if the class is empty right now.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量名为 `hero`，它使用 `new` 关键字、`Character` 类名称和两个括号创建。这是在程序内存中创建实际实例的地方，即使类目前为空。
- en: We can use the `hero` variable just like any other object we've worked with
    so far. When the `Character` class gets variables and methods of its own, we can
    access them from `hero` using dot notation.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `hero` 变量就像我们迄今为止使用的任何其他对象一样。当 `Character` 类有自己的变量和方法时，我们可以通过点符号从 `hero`
    访问它们。
- en: 'You could just as easily have used an inferred declaration when creating the
    `hero` variable, like so:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你同样可以在创建`hero`变量时使用推断声明，如下所示：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now our character class can't do much without any class fields to work with.
    You'll be adding class fields, and more, in the next few sections.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们没有类字段来工作，我们的角色类几乎什么也做不了。你将在接下来的几节中添加类字段和其他内容。
- en: Adding class fields
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加类字段
- en: 'Adding variables, or fields, to a custom class is no different than what we''ve
    already been doing with `LearningCurve`. The same concepts apply, including access
    modifiers, variable scope, and value assignments. However, any variables belonging
    to a class are created with the class instance, meaning that if there are no values
    assigned, they will default to zero or null. In general, choosing to set initial
    values comes down to what information they will store:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 向自定义类添加变量或字段与我们在`LearningCurve`中已经做过的操作没有区别。同样的概念适用，包括访问修饰符、变量作用域和值赋值。然而，属于类的任何变量都是与类实例一起创建的，这意味着如果没有分配值，它们将默认为零或null。一般来说，选择设置初始值取决于它们将存储的信息：
- en: If a variable needs to have the same starting value whenever a class instance
    is created, setting an initial value is a solid idea. This would be useful for
    something like experience points or the starting score.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果变量需要在每次创建类实例时具有相同的起始值，设置初始值是一个好主意。这对于像经验值或起始分数这样的东西很有用。
- en: If a variable needs to be customized in every class instance, like `CharacterName`,
    leave its value unassigned and use a class constructor (a topic that we'll get
    to in the *Using constructors* section).
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要为每个类实例定制变量，如`CharacterName`，则保留其值未分配，并使用类构造函数（我们将在*使用构造函数*部分讨论这个话题）。
- en: Every character class is going to need a few basic fields; it's your job to
    add them in the following section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个角色类都需要一些基本字段；你的任务是添加它们在下面的部分。
- en: 'Let''s incorporate two variables to hold the character''s name and the number
    of starting experience points:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们包含两个变量来存储角色的名称和起始经验点数：
- en: Add two `public` variables inside the `Character` class's curly braces—a `string`
    variable for the name, and an `integer` variable for the experience points.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Character`类的花括号内添加两个`public`变量——一个用于名称的`string`变量和一个用于经验点的`integer`变量。
- en: 'Leave the `name` value empty, but set the experience points to `0` so that
    every character starts from the bottom:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`name`值留空，但将经验值设置为`0`，这样每个角色都从底部开始：
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add a debug log in `LearningCurve`right after the `Character` instance was
    initialized. Use it to print out the new character''s `name` and `exp` variables
    using dot notation:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LearningCurve`中在`Character`实例初始化后立即添加一个调试日志。使用它通过点符号打印出新角色的`name`和`exp`变量：
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When `hero` is initialized, `name` is assigned a null value that shows up as
    an empty space in the debug log, while `exp` prints out `0`. Notice that we didn't
    have to attach the `Character` script to any GameObjects in the scene; we just
    referenced them in `LearningCurve` and Unity did the rest. The console will now
    debug out our character information, which is referenced as follows:![](img/B17573_05_01.png)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`hero`初始化时，`name`被分配一个null值，在调试日志中显示为空格，而`exp`打印出`0`。注意，我们不需要将`Character`脚本附加到场景中的任何GameObject上；我们只是在`LearningCurve`中引用了它们，Unity就完成了剩余的工作。控制台现在将调试我们的角色信息，如下所示：![](img/B17573_05_01.png)
- en: 'Figure 5.1: Screenshot of custom class properties printed in the console'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.1：控制台中打印的自定义类属性截图
- en: At this point, our class is working, but it's not very practical with these
    empty values. You'll need to fix that with what's called a class constructor.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的类已经可以工作，但使用这些空值并不实用。你需要通过所谓的类构造函数来修复这个问题。
- en: Using constructors
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用构造函数
- en: 'Class constructors are special methods that fire automatically when a class
    instance is created, which is similar to how the `Start` method runs in `LearningCurve`.
    Constructors build the class according to its blueprint:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造函数是特殊方法，在创建类实例时自动触发，这与`LearningCurve`中的`Start`方法运行方式类似。构造函数根据其蓝图构建类：
- en: If a constructor is not specified, C# generates a default one. The default constructor
    sets any variables to their default type values—numeric values are set to zero,
    Booleans to false, and reference types (classes) to null.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有指定构造函数，C#将生成一个默认的构造函数。默认构造函数将任何变量设置为它们的默认类型值——数值设置为零，布尔值设置为false，引用类型（类）设置为null。
- en: Custom constructors can be defined with parameters, just like any other method,
    and are used to set class variable values at initialization.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以像任何其他方法一样定义具有参数的自定义构造函数，并用于在初始化时设置类变量值。
- en: A class can have multiple constructors.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以有多个构造函数。
- en: Constructors are written like regular methods but with a few differences; for
    instance, they need to be public, have no return type, and the method name is
    always the class name. As an example, let's add a basic constructor with no parameters
    to the `Character` class and set the name field to something other than null.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的编写方式与常规方法类似，但有一些区别；例如，它们需要是公开的，没有返回类型，并且方法名总是类名。作为一个例子，让我们向 `Character`
    类添加一个不带参数的基本构造函数，并将名称字段设置为非空值。
- en: 'Add this new code directly underneath the class variables, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将此新代码直接放在类变量下面，如下所示：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the project in Unity and you''ll see the `hero` instance using this new
    constructor. The debug log will show the hero''s name as **Not assigned** instead
    of a null value:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中运行项目，你会看到使用这个新构造函数的 `hero` 实例。调试日志将显示英雄的名称为 **未分配** 而不是空值：
- en: '![](img/B17573_05_02.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![img/B17573_05_02.png](img/B17573_05_02.png)'
- en: 'Figure 5.2: Screenshot of unassigned custom class variables printed to the
    console'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：控制台打印的未分配自定义类变量的截图
- en: This is good progress, but we need the class constructor to be more flexible.
    This means that we need to be able to pass in values so that they can be used
    as starting values, which you'll do next.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个不错的进展，但我们还需要使类构造函数更加灵活。这意味着我们需要能够传入值，以便它们可以作为起始值使用，这将是你的下一个任务。
- en: 'Now, the `Character` class is starting to behave more like a real object, but
    we can make this even better by adding a second constructor to take in a name
    at initialization and set it to the `name` field:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Character` 类开始更像一个真实对象的行为，但我们可以通过添加一个接受初始化时名称并设置到 `name` 字段的第二个构造函数来使其更好：
- en: Add another constructor to `Character` that takes in a `string` parameter, called
    `name`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Character` 添加另一个接受 `string` 参数的构造函数，称为 `name`。
- en: 'Assign the parameter to the class''s `name` variable using the `this` keyword.
    This is called *constructor overloading*:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `this` 关键字将参数赋值给类的 `name` 变量。这被称为 *构造函数重载*：
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For convenience, constructors will often have parameters that share a name with
    a class variable. In these cases, use the `this` keyword to specify which variable
    belongs to the class. In the example here, `this.name` refers to the class's name
    variable, while `name` is the parameter; without the `this` keyword, the compiler
    will throw a warning because it won't be able to tell them apart.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了方便，构造函数通常会具有与类变量共享名称的参数。在这些情况下，使用 `this` 关键字来指定哪个变量属于类。在这个例子中，`this.name`
    指的是类的 `name` 变量，而 `name` 是参数；如果没有 `this` 关键字，编译器将抛出警告，因为它无法区分它们。
- en: 'Create a new `Character` instance in `LearningCurve`, called `heroine`. Use
    the custom constructor to pass in a name when it''s initialized and print out
    the details in the console:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LearningCurve` 中创建一个新的 `Character` 实例，称为 `heroine`。使用自定义构造函数在初始化时传入一个名称，并在控制台打印出详细信息：
- en: '[PRE8]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When a class has multiple constructors or a method has multiple variations,
    Visual Studio will show a set of arrows in the autocomplete popup that can be
    scrolled through using the arrow keys:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当一个类有多个构造函数或一个方法有多个变体时，Visual Studio 将在自动完成弹出窗口中显示一组箭头，可以使用箭头键滚动浏览：
- en: '![](img/B17573_05_03.png)'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![img/B17573_05_03.png](img/B17573_05_03.png)'
- en: 'Figure 5.3: Screenshot of multiple method constructors in Visual Studio'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.3：Visual Studio 中多个方法构造函数的截图
- en: We can now choose between the basic and custom constructor when we initialize
    a new `Character` class. The `Character` class itself is now far more flexible
    when it comes to configuring different instances for different situations:![](img/B17573_05_04.png)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以选择在初始化新的 `Character` 类时使用基本构造函数或自定义构造函数。`Character` 类本身在配置不同情况下的不同实例方面现在更加灵活了！![img/B17573_05_04.png](img/B17573_05_04.png)
- en: 'Figure 5.4: Screenshot of multiple custom class instances printed in the console'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.4：控制台打印的多个自定义类实例的截图
- en: Now the real work starts; our class needs methods to be able to do anything
    useful besides acting as a storage facility for variables. Your next task is to
    put this into practice.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在真正的挑战开始了；我们的类需要方法来执行除了作为变量存储设施之外的有用操作。你的下一个任务是将其付诸实践。
- en: Declaring class methods
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明类方法
- en: Adding methods to custom classes is no different from adding them to `LearningCurve`.
    However, this is a good opportunity to talk about a staple of good programming—**Don't
    Repeat Yourself** (**DRY**). DRY is a benchmark of all well-written code. Essentially,
    if you find yourself writing the same line, or lines, over and over, it's time
    to rethink and reorganize. This usually takes the form of a new method to hold
    the repeated code, making it easier to modify and call that functionality elsewhere
    in the current script or even from other scripts.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 向自定义类添加方法与向 `LearningCurve` 添加方法没有区别。然而，这是一个讨论良好编程的一个基本准则——**不要重复自己**（**DRY**）的好机会。DRY
    是所有良好代码的标准。本质上，如果你发现自己一遍又一遍地写相同的行或几行，那么是时候重新思考和重新组织了。这通常以一个新的方法的形式出现，以保存重复的代码，使其更容易修改并在当前脚本或甚至在其他脚本中调用该功能。
- en: In programming terms, you'll see this referred to as **abstracting** out a method
    or feature.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程术语中，你会看到这被称为**抽象**一个方法或特性。
- en: We have a fair bit of repeated code already, so let's take a look and see where
    we can increase the legibility and efficiency of our scripts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了相当多的重复代码，所以让我们看看我们可以在哪里提高脚本的易读性和效率。
- en: 'Our repeated debug logs are a perfect opportunity to abstract out some code
    directly into the `Character` class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的重复调试日志是直接将一些代码抽象到 `Character` 类中的完美机会：
- en: Add a new `public` method with a `void` return type, called `PrintStatsInfo`,
    to the `Character` class.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `Character` 类添加一个新的 `public` 方法，具有 `void` 返回类型，名为 `PrintStatsInfo`。
- en: Copy and paste the debug log from `LearningCurve` into the method body.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `LearningCurve` 中的调试日志复制并粘贴到方法体中。
- en: 'Change the variables to `name` and `exp`, since they can now be referenced
    from the class directly:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将变量改为 `name` 和 `exp`，因为它们现在可以直接从类中引用：
- en: '[PRE9]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Replace the character debug log that we previously added to `LearningCurve`with
    method calls to `PrintStatsInfo`, and click on play:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用 `PrintStatsInfo` 方法调用替换我们之前添加到 `LearningCurve` 中的角色调试日志，然后点击播放：
- en: '[PRE10]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that the `Character` class has a method, any instance can freely access
    it using dot notation. Since `hero` and `heroine` are both separate objects, `PrintStatsInfo`
    debugs their respective `name` and `exp` values to the console.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在 `Character` 类有了方法，任何实例都可以使用点符号自由访问它。由于 `hero` 和 `heroine` 都是单独的对象，`PrintStatsInfo`
    将它们各自的 `name` 和 `exp` 值调试到控制台。
- en: This behavior is better than having the debug logs directly in `LearningCurve`.
    It's always a good idea to group functionality into a class and drive action through
    methods. This makes the code more readable—as our `Character` objects are giving
    a command when printing out the debug logs, instead of repeating code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为比直接在 `LearningCurve` 中放置调试日志要好。总是将功能分组到类中并通过方法驱动动作是一个好主意。这使得代码更易于阅读——因为我们的
    `Character` 对象在打印调试日志时发出命令，而不是重复代码。
- en: 'The entire `Character` class should look like the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 `Character` 类应该看起来像以下代码：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With classes covered, you're well on your way to writing modularized code that's
    readable, lightweight, and reusable. Now it's time to tackle the class's cousin
    object —the struct!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了类之后，你已经朝着编写模块化、易于阅读、轻量级和可重用的代码迈出了很大一步。现在是时候处理类的表亲——结构体了！
- en: Declaring structs
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明结构体
- en: '**Structs** are similar to classes in that they are also blueprints for objects
    you want to create in your programs. The main difference is that they are *value
    types*, meaning they are passed by value instead of reference, like classes are.
    When structs are assigned or passed to another variable, a new copy of the struct
    is created, so the original isn''t referenced at all. We''ll go into this in more
    detail in the next section. First, we need to understand how structs work and
    the specific rules that apply when creating them.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构体**与类相似，因为它们也是你想要在程序中创建的对象的蓝图。主要区别在于它们是**值类型**，这意味着它们是通过值传递而不是引用传递，就像类一样。当结构体被分配或传递给另一个变量时，会创建结构体的一个新副本，因此原始结构体不会被引用。我们将在下一节中更详细地介绍这一点。首先，我们需要了解结构体是如何工作的以及创建它们时适用的特定规则。'
- en: 'Structs are declared in the same way as classes, and can hold fields, methods,
    and constructors:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体的声明方式与类相同，可以包含字段、方法和构造函数：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Like classes, any variables and methods belong exclusively to the struct and
    are accessed by its unique name.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于类，任何变量和方法都属于结构体，并且通过其唯一名称访问。
- en: 'However, structs have a few limitations:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，结构体有一些限制：
- en: Variables cannot be initialized with values inside the struct declaration unless
    they're marked with the `static` or `const` modifier—you can read more about this
    in *Chapter 10*, *Revisiting Types, Methods, and Classes*.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非变量被标记为 `static` 或 `const` 修饰符，否则不能在结构体声明中使用其内部的值来初始化变量——你可以在 *第10章，重新审视类型、方法和类*
    中了解更多关于这个内容。
- en: Constructors without parameters aren't permitted.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不带参数的构造函数是不允许的。
- en: Structs come with a default constructor that will automatically set all variables
    to their default values according to their type.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体自带一个默认构造函数，它会自动根据其类型将所有变量设置为默认值。
- en: Every character requires a good weapon, and these weapons are the perfect fit
    for a struct object over a class. We'll discuss why that is in the *Understanding
    reference and value types* section of this chapter. However, first, you're going
    to create one to play around with.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个角色都需要一把好武器，而这些武器对于结构体对象来说比类更合适。我们将在本章的 *理解引用和值类型* 部分讨论为什么是这样。然而，首先，你需要创建一个来试验一下。
- en: 'Our characters are going to need good weapons to see them through quests, which
    are good candidates for a simple struct:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的角色将需要好的武器来完成他们的任务，这些任务非常适合简单的结构体：
- en: Right-click on the `Scripts` folder, choose **Create**, and select **C# Script**.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 `Scripts` 文件夹，选择 **创建**，然后选择 **C# 脚本**。
- en: Name it `Weapon`, open it up in Visual Studio, and delete all the generated
    code after `using UnityEngine`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为 `Weapon`，在 Visual Studio 中打开它，并删除 `using UnityEngine` 之后的所有生成的代码。
- en: Declare a public struct called `Weapon`, followed by a set of curly braces,
    and then save the file.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `Weapon` 的公共结构体，然后是一组花括号，然后保存文件。
- en: 'Add a field for `name` of type `string` and another field for `damage` of type
    `int`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `name` 字段，类型为 `string`，以及一个 `damage` 字段，类型为 `int`：
- en: You can have classes and structs nested within each other, but this is generally
    frowned upon because it clutters up the code.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以将类和结构体嵌套在一起，但这通常是不受欢迎的，因为它会使代码变得混乱。
- en: '[PRE13]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Declare a constructor with the `name` and `damage` parameters, and set the
    struct fields using the `this` keyword:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `name` 和 `damage` 参数声明一个构造函数，并使用 `this` 关键字设置结构体字段：
- en: '[PRE14]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add a debug method below the constructor to print out the weapon information:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数下方添加一个调试方法来打印出武器信息：
- en: '[PRE15]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In `LearningCurve`, create a new `Weapon` struct using the custom constructor
    and the `new` keyword:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LearningCurve` 中，使用自定义构造函数和 `new` 关键字创建一个新的 `Weapon` 结构体：
- en: '[PRE16]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our new `huntingBow` object uses the custom constructor and provides values
    for both fields on initialization.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们新的 `huntingBow` 对象使用自定义构造函数，并在初始化时为两个字段提供值。
- en: It's a good idea to limit scripts to a single class, but it's fairly common
    to see structs that are used exclusively by a class included in the file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 限制脚本只在一个类中是很不错的想法，但通常可以看到只由一个类使用的结构体被包含在文件中。
- en: Now that we have an example of both reference (class) and value (struct) objects,
    it's time to get acquainted with each of their finer points. More specifically,
    you'll need to understand how each of these objects is passed and stored in memory.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了引用（类）和值（结构体）对象的示例，是时候熟悉它们各自的细节了。更具体地说，你需要了解每个对象是如何在内存中传递和存储的。
- en: Understanding reference and value types
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解引用和值类型
- en: Other than keywords and initial field values, we haven't seen much difference
    between classes and structs so far. Classes are best suited for grouping together
    complex actions and data that will change throughout a program; structs are a
    better choice for simple objects and data that will remain constant for the most
    part. Besides their uses, they are fundamentally different in one key area—that
    is, how they are passed or assigned between variables. Classes are *reference
    types*, meaning that they are passed by reference; structs are *value types*,
    meaning that they are passed by value.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关键字和初始字段值之外，到目前为止，我们在类和结构体之间并没有看到太大的区别。类最适合于组合程序中会改变复杂动作和数据；结构体更适合于简单对象和大部分保持不变的数据。除了它们的用途之外，它们在关键领域上本质上是不同的——那就是，它们如何在变量之间传递或分配。类是
    *引用类型*，意味着它们是通过引用传递的；结构体是 *值类型*，意味着它们是通过值传递的。
- en: Reference types
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用类型
- en: When the instances of our `Character` class are initialized, the `hero` and
    `heroine` variables don't hold their class information—instead, they hold a reference
    to where the object is located in the program's memory. If we assigned `hero`
    or `heroine` to another variable in the same class, the memory reference is assigned,
    not the character data. This has several implications, the most important being
    that if we have multiple variables storing the same memory reference, a change
    to one affects them all.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的`Character`类实例初始化时，`hero`和`heroine`变量不持有其类信息——相反，它们持有对象在程序内存中的位置引用。如果我们将`hero`或`heroine`赋值给同一类中的另一个变量，分配的是内存引用，而不是角色数据。这有几个含义，其中最重要的是，如果我们有多个变量存储相同的内存引用，对其中一个的更改会影响它们所有。
- en: Topics like this are better demonstrated than explained; it's up to you to try
    this out in a practical example, next.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的主题最好是演示而不是解释；这取决于你，在下一个实际示例中尝试一下。
- en: 'It''s time to test that the `Character` class is a reference type:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候测试`Character`类是否是一个引用类型了：
- en: Declare a new `Character` variable in `LearningCurve` called `hero2`. Assign
    `hero2` to the `hero` variable and use the `PrintStatsInfo` method to print out
    both sets of information.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LearningCurve`中声明一个新的`Character`变量，命名为`hero2`。将`hero2`赋值给`hero`变量，并使用`PrintStatsInfo`方法打印出两组信息。
- en: 'Click playand take a look at the two debug logs that show up in the console:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击播放并查看控制台出现的两个调试日志：
- en: '[PRE17]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The two debug logs will be identical because `hero2` was assigned to `hero`
    when it was created. At this point, both `hero2` and `hero` point to where `hero`
    is located in memory:![](img/B17573_05_05.png)
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个调试日志将完全相同，因为当创建`hero2`时，它被赋值给了`hero`。在这个时候，`hero2`和`hero`都指向内存中`hero`的位置！![图片](img/B17573_05_05.png)
- en: 'Figure 5.5: Screenshot of the struct stats printed to the console'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.5：控制台打印出的结构体统计截图
- en: 'Now, change the name of `hero2` to something fun and click playagain:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`hero2`的名字改为一个有趣的名字，然后再次点击播放：
- en: '[PRE18]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You'll see that both `hero` and `hero2` now have the same name, even though
    only one of our characters' data was changed:![](img/B17573_05_06.png)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到`hero`和`hero2`现在拥有相同的名字，尽管我们只更改了其中一个角色的数据！![图片](img/B17573_05_06.png)
- en: 'Figure 5.6: Screenshot of class instance properties printed to the console'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.6：控制台打印出的类实例属性的截图
- en: The lesson here is that reference types need to be treated carefully and not
    copied when assigned to new variables. Any change to one reference trickles through
    all other variables holding the same reference.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训是，引用类型需要小心处理，并且在赋值给新变量时不要复制。对任何一个引用的任何更改都会渗透到持有相同引用的所有其他变量中。
- en: If you're trying to copy a class, either create a new, separate instance or
    reconsider whether a struct might be a better choice for your object blueprint.
    You'll get a better glimpse of value types in the following section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图复制一个类，要么创建一个新的、独立的实例，要么重新考虑结构体是否可能是你对象蓝图更好的选择。你将在下一节中更好地了解值类型。
- en: Value types
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值类型
- en: When a struct object is created, all of its data is stored in its corresponding
    variable with no references or connections to its memory location. This makes
    structs useful for creating objects that need to be copied quickly and efficiently,
    while still retaining their separate identities. Try this out with our `Weapon`
    struct in the following exercise.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建结构体对象时，所有数据都存储在其对应的变量中，没有引用或与其内存位置的连接。这使得结构体对于创建需要快速高效复制且保持各自独立身份的对象非常有用。在下面的练习中尝试使用我们的`Weapon`结构体。
- en: 'Let''s create a new weapon object by copying `huntingBow` into a new variable
    and updating its data to see whether the changes affect both structs:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将`huntingBow`复制到一个新变量并更新其数据来创建一个新的武器对象，看看这些更改是否会影响两个结构体：
- en: 'Declare a new `Weapon` struct in `LearningCurve`, andassign `huntingBow` as
    its initial value:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LearningCurve`中声明一个新的`Weapon`结构体，并将其初始值设置为`huntingBow`：
- en: '[PRE19]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Print out each weapon''s data using the debug method:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用调试方法打印出每件武器的数据：
- en: '[PRE20]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The way they're set up now, both `huntingBow` and `warBow` will have the same
    debug logs, just like our two characters did before we changed any data:![](img/B17573_05_07.png)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在它们的设置方式是，`huntingBow`和`warBow`将具有相同的调试日志，就像我们在更改任何数据之前我们的两个角色一样！![图片](img/B17573_05_07.png)
- en: 'Figure 5.7: Screenshot of the struct instances printed to the console'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.7：控制台打印出的结构体实例的截图
- en: 'Change the `warBow.name` and `warBow.damage` fields to values of your choice
    and click on play again:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`warBow.name`和`warBow.damage`字段更改为你选择的值，然后再次点击播放：
- en: '[PRE21]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The console will show that only the data relating to `warBow` was changed, and
    that `huntingBow` retains its original data.![](img/B17573_05_08.png)
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 5.8: Screenshot of updated struct properties printed to console'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The takeaway from this example is that structs are easily copied and modified
    as their separate objects, unlike classes, which retain references to an original
    object. Now that we understand a little more about how structs and classes work
    under the hood, and confirmed how reference and value types behave in their natural
    habitat, we're in a good place to start talking about one of the most important
    coding topics, OOP, and how it fits into the programming landscape.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the object-oriented mindset
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Things in the physical world operate on a similar level to OOP; when you want
    to buy a soft drink, you grab a can of soda, not the liquid itself. The can is
    an object, grouping related information and actions together in a self-contained
    package. However, there are rules when dealing with objects, both in programming
    and the grocery store —for instance, who can access them. Different variations
    and generic actions all play into the nature of the objects all around us.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'In programming terms, these rules are the main tenets of OOP: *encapsulation*,
    *inheritance*, and *polymorphism*.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the best things about OOP is that it supports encapsulation—defining
    how accessible an object's variables and methods are to outside code (this is
    sometimes referred to as *calling code*). Take our soda can as an example—in a
    vending machine, the possible interactions are limited. Since the machine is locked,
    not just anyone can come up and grab one; if you happen to have the right change,
    you'll be allowed provisional access to it, but in a specified quantity. If the
    machine itself is locked inside a room, only someone with the door key will even
    know the soda can exists.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The question you're asking yourself now is, how do we set these limitations?
    The simple answer is that we've been using encapsulation this entire time by specifying
    access modifiers for our object variables and methods.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: If you need a refresher, go back and visit the *Access modifiers* section in
    *Chapter 3*, *Diving into Variables, Types, and Methods*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try out a simple encapsulation example to understand how this works
    in practice. Our `Character` class is public, as are its fields and methods. However,
    what if we wanted a method that can reset a character''s data to its initial values?
    This could come in handy, but could prove disastrous if it was accidentally called,
    making it a perfect candidate for a private object member:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `private` method called `Reset`, with no return value inside the `Character`
    class. Set the `name` and `exp` variables back to `"Not assigned"` and `0`, respectively:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Try and call `Reset()` from `LearningCurve` after printing out the `hero2` data:![](img/B17573_05_09.png)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 5.9: Screenshot of an inaccessible method in the Character class'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：Character类中不可访问方法的屏幕截图
- en: If you're wondering whether Visual Studio is broken, it's not. Marking a method
    or variable as private will make it inaccessible inside this class or struct using
    dot notation; if you manually type it in and hover over `Reset()`, you'll see
    an error message regarding the method being protected.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你怀疑Visual Studio是否出了问题，其实并没有。将方法或变量标记为私有会使它在这个类或结构体中使用点符号无法访问；如果你手动输入并悬停在`Reset()`上，你会看到一个关于方法受保护的错误信息。
- en: 'To actually call this private method, we could add a reset command inside the
    class constructor:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际调用这个私有方法，我们可以在类构造函数中添加一个重置命令：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Encapsulation does allow more complex accessibility setups with objects; however,
    for now, we're going to stick with `public` and `private` members. As we begin
    to flesh out our game prototype in the next chapter, we'll add in different modifiers
    as needed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 封装确实允许使用对象进行更复杂的可访问性设置；然而，现在，我们将坚持使用`public`和`private`成员。在我们下一章开始充实我们的游戏原型时，我们将根据需要添加不同的修饰符。
- en: Now, let's talk about inheritance, which is going to be your best friend when
    creating class hierarchies in your future games.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈继承，这在你在未来游戏中创建类层次结构时将成为你的好朋友。
- en: Inheritance
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: A C# class can be created in the image of another class, sharing its member
    variables and methods, but able to define its unique data. In OOP, we refer to
    this as *inheritance*, and it's a powerful way of creating related classes without
    having to repeat code. Take the soda example again—there are generic sodas on
    the market that have all the same basic properties, and then there are special
    sodas. The special sodas share the same basic properties but have different branding,
    or packaging, that sets them apart. When you look at both side by side, it's obvious
    that they're both cans of soda—but they're also obviously not the same.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一个C#类可以按照另一个类的形象创建，共享其成员变量和方法，但能够定义其独特的数据。在面向对象编程中，我们称这为*继承*，这是一种无需重复代码就能创建相关类的强大方式。再次以汽水为例——市场上有一些通用的汽水，它们具有所有相同的基本属性，然后还有特殊的汽水。特殊的汽水具有相同的基本属性，但有不同的品牌或包装，使其与众不同。当你将它们并排放在一起看时，很明显它们都是汽水瓶——但它们显然也不相同。
- en: The original class is usually called the base or parent class, while the inheriting
    class is called the derived or child class. Any base class members marked with
    the `public`, `protected`, or `internal` access modifiers are automatically part
    of the derived class—except for constructors. Class constructors always belong
    to their containing class, but they can be used from derived classes to keep repeated
    code to a minimum. Don't worry too much about the different base class scenarios
    right now. Instead, let's try out a simple game example.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类通常被称为基类或父类，而继承的类被称为派生类或子类。任何用`public`、`protected`或`internal`访问修饰符标记的基类成员都会自动成为派生类的一部分——除了构造函数。类构造函数始终属于其包含的类，但它们可以从派生类中使用，以将重复的代码量保持在最低。现在不必太担心不同的基类场景。相反，让我们尝试一个简单的游戏示例。
- en: 'Most games have more than one type of character, so let''s create a new class
    called `Paladin` that inherits from the `Character` class. You can add this new
    class to the `Character` script or create a new one. If you''re adding the new
    class to the `Character` script, make sure it''s outside the `Character` class''s
    curly brackets:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏都有不止一种类型的角色，所以让我们创建一个新的类，称为`Paladin`，它继承自`Character`类。你可以将这个新类添加到`Character`脚本中或创建一个新的脚本。如果你要将新类添加到`Character`脚本中，确保它位于`Character`类的花括号之外：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Just as `LearningCurve`inherits from `MonoBehavior`, all we need to do is add
    a colon and the base class we want to inherit from, and C# does the rest. Now,
    any `Paladin` instances will have access to a `name` property and an `exp` property
    along with a `PrintStatsInfo` method.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`LearningCurve`继承自`MonoBehavior`一样，我们只需要添加一个冒号和我们要继承的基类，C#就会完成剩下的工作。现在，任何`Paladin`实例都将能够访问`name`属性和`exp`属性以及`PrintStatsInfo`方法。
- en: It's generally considered best practice to create a new script for different
    classes instead of adding them to existing ones. This separates your scripts and
    avoids having too many lines of code in any single file (called a bloated file).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通常认为，为不同的类创建新的脚本而不是将它们添加到现有脚本中是最佳实践。这可以分离你的脚本，并避免任何单个文件中有太多的代码行（称为膨胀文件）。
- en: This is great, but how do inherited classes handle their construction? You can
    find out in the following section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但是继承的类是如何处理它们的构造的呢？你可以在下面的部分中找到答案。
- en: Base constructors
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础构造函数
- en: 'When a class inherits from another class, they form a pyramid of sorts with
    member variables flowing down from the parent class to any of its derived children.
    The parent class isn''t aware of any of its children, but all children are aware
    of their parent. However, parent class constructors can be called directly from
    child constructors with a simple syntax modification:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类从另一个类继承时，它们形成一种金字塔结构，成员变量从父类流向其任何派生子类。父类不知道任何子类，但所有子类都知道它们的父类。然而，父类构造函数可以直接从子类构造函数中通过简单的语法修改来调用：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `base` keyword stands in for the parent constructor—in this case, the default
    constructor. However, since `base` is standing in for a constructor, and a constructor
    is a method, a child class can pass parameters up the pyramid to its parent constructor.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`base`关键字代表父构造函数——在这种情况下，默认构造函数。然而，由于`base`代表一个构造函数，而构造函数是一个方法，子类可以将参数向上传递到金字塔中的父构造函数。'
- en: 'Since we want all `Paladin` objects to have a name, and `Character` already
    has a constructor that handles this, we can call the `base` constructor directly
    from the `Paladin` class and save ourselves the trouble of rewriting a constructor:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望所有的`Paladin`对象都有一个名字，而`Character`已经有一个构造函数来处理这一点，我们可以在`Paladin`类中直接调用`base`构造函数，从而避免重写构造函数的麻烦：
- en: 'Add a constructor to the `Paladin` class that takes in a `string` parameter,
    called `name`. Use a `colon` and the `base` keyword to call the parent constructor,
    passing in `name`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Paladin`类添加一个接受名为`name`的`string`参数的构造函数。使用冒号和`base`关键字调用父构造函数，传递`name`：
- en: '[PRE26]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In `LearningCurve`, create a new `Paladin` instance called `knight`. Use the
    base constructor to assign a value. Call `PrintStatsInfo` from `knight` and take
    a look at the console:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LearningCurve`中创建一个新的名为`knight`的`Paladin`实例。使用基础构造函数分配值。从`knight`调用`PrintStatsInfo`并查看控制台：
- en: '[PRE27]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The debug log will be the same as our other `Character` instances, but with
    the name that we assigned to the `Paladin` constructor:![](img/B17573_05_10.png)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试日志将与我们的其他`Character`实例相同，但带有我们分配给`Paladin`构造函数的名字：![图片](img/B17573_05_10.png)
- en: 'Figure 5.10: Screenshot of base character constructor properties'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10：基本角色构造函数属性截图
- en: When the `Paladin` constructor fires, it passes the `name` parameter to the
    `Character` constructor, which sets the `name` value. Essentially, we used the
    `Character` constructor to do the initialization work for the `Paladin` class,
    making the `Paladin` constructor only responsible for initializing its unique
    properties, which it doesn't have at this point.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Paladin`构造函数被触发时，它将`name`参数传递给`Character`构造函数，该构造函数设置`name`值。本质上，我们使用了`Character`构造函数来完成`Paladin`类的初始化工作，使得`Paladin`构造函数只负责初始化其独特的属性，而目前它没有这些属性。
- en: Aside from inheritance, there will be times when you want to make new objects
    out of a combination of other existing objects. Think of Lego; you don't start
    building from nothing—you already have blocks of different colors and structures
    to work with. In programming terms, this is called *composition*, which we'll
    discuss in the following section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 除了继承之外，有时你想要通过组合其他现有对象来创建新的对象。想想乐高；你不会从无到有开始建造——你已经有不同颜色和结构的积木块可以工作。在编程术语中，这被称为*组合*，我们将在下一节中讨论。
- en: Composition
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组成
- en: 'Aside from inheritance, classes can be composed of other classes. Take our
    `Weapon` struct, for example. `Paladin` can easily contain a `Weapon` variable
    inside itself and have access to all its properties and methods. Let''s do that
    by updating `Paladin` to take in a starting weapon and assign its value in the
    constructor:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 除了继承之外，类还可以由其他类组成。以我们的`Weapon`结构体为例。`Paladin`可以轻松地在自身内部包含一个`Weapon`变量，并访问其所有属性和方法。让我们通过更新`Paladin`以接受一个起始武器并在构造函数中分配其值来实现这一点：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since `weapon` is unique to `Paladin` and not `Character`, we need to set its
    initial value in the constructor. We also need to update the `knight` instance
    to include a `Weapon` variable. So, let''s use `huntingBow`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`weapon`是`Paladin`特有的，而不是`Character`，我们需要在构造函数中设置它的初始值。我们还需要更新`knight`实例以包含一个`Weapon`变量。所以，让我们使用`huntingBow`：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you run the game now, you won't see anything different because we're using
    the `PrintStatsInfo` method from the `Character` class, which doesn't know about
    the `Paladin` class's `weapon` property. To tackle this problem, we need to talk
    about polymorphism.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，你不会看到任何不同，因为我们正在使用来自`Character`类的`PrintStatsInfo`方法，它不知道`Paladin`类的`weapon`属性。为了解决这个问题，我们需要讨论多态。
- en: Polymorphism
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态
- en: 'Polymorphism is the Greek word for *many-shaped* and applies to OOP in two
    distinct ways:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是希腊语中“多形态”的意思，并且以两种不同的方式应用于面向对象编程（OOP）：
- en: Derived class objects are treated the same as parent class objects. For example,
    an array of `Character` objects could also store `Paladin` objects, as they derive
    from `Character`.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生类对象被当作父类对象对待。例如，一个`Character`对象的数组也可以存储`Paladin`对象，因为它们是从`Character`派生出来的。
- en: Parent classes can mark methods as `virtual`, meaning that their instructions
    can be modified by derived classes using the `override` keyword. In the case of
    `Character` and `Paladin`, it would be useful if we could debug different messages
    from `PrintStatsInfo` for each one.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父类可以标记方法为`virtual`，这意味着它们的指令可以被派生类使用`override`关键字修改。在`Character`和`Paladin`的情况下，如果我们能够从每个`PrintStatsInfo`中调试不同的消息，那将是有用的。
- en: Polymorphism allows derived classes to keep the structure of their parent class
    while also having the freedom to tailor actions to fit their specific needs. Any
    method you mark as `virtual` will give you the freedom of object polymorphism.
    Let's take this new knowledge and apply it to our character debug method.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 多态允许派生类保持其父类的结构，同时也有自由来调整操作以适应其特定需求。你标记为`virtual`的任何方法都会给你对象多态的自由。让我们利用这个新知识并将它应用到我们的角色调试方法中。
- en: 'Let''s modify `Character` and `Paladin` to print out different debug logs using
    `PrintStatsInfo`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`Character`和`Paladin`，使用`PrintStatsInfo`打印出不同的调试日志：
- en: 'Change `PrintStatsInfo` in the `Character` class by adding the `virtual` keyword
    between `public` and `void`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`public`和`void`之间添加`virtual`关键字来更改`Character`类中的`PrintStatsInfo`：
- en: '[PRE30]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Declare the `PrintStatsInfo` method in the `Paladin` class using the `override`
    keyword. Add a debug log to print out the `Paladin` properties in whatever way
    you like:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`override`关键字在`Paladin`类中声明`PrintStatsInfo`方法。添加一个调试日志，以你喜欢的任何方式打印出`Paladin`属性：
- en: '[PRE31]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This might look like repeated code, which we already said is bad form, but this
    is a special case. What we've done by marking `PrintStatsInfo` as `virtual` in
    the `Character` class is to tell the compiler that this method can have many shapes
    according to the calling class.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可能看起来像是重复的代码，我们之前已经说过这是不好的形式，但这是一个特殊情况。我们在`Character`类中将`PrintStatsInfo`标记为`virtual`所做的是告诉编译器，这个方法可以根据调用类有多种形态。
- en: When we declared the overridden version of `PrintStatsInfo` in `Paladin`, we
    added the custom behavior that only applies to that class. Thanks to polymorphism,
    we don't have to choose which version of `PrintStatsInfo` we want to call from
    a `Character` or `Paladin` object—the compiler already knows:![](img/B17573_05_11.png)
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在`Paladin`中声明覆盖版本的`PrintStatsInfo`时，我们添加了仅适用于该类的自定义行为。多态的功劳，我们不需要从`Character`或`Paladin`对象中选择要调用的`PrintStatsInfo`版本——编译器已经知道了！:![img/B17573_05_11.png](img/B17573_05_11.png)
- en: 'Figure 5.11: Screenshot of polymorphic character properties'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.11：多态角色属性的截图
- en: 'This was a lot to take in, I know. So, let''s review some of the main points
    of OOP as we approach the finish line:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这有很多内容需要消化。因此，在我们接近终点时，让我们回顾一下面向对象编程（OOP）的一些主要点：
- en: OOP is all about grouping related data and actions into objects—objects that
    can communicate and act independently from each other.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）的全部内容都是将相关的数据和操作组合成对象——这些对象可以相互通信并独立行动。
- en: Access to class members can be set using access modifiers, just like variables.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用访问修饰符设置对类成员的访问，就像变量一样。
- en: Classes can inherit from other classes, creating trickle-down hierarchies of
    parent/child relationships.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类可以继承自其他类，创建父/子关系的级联层次结构。
- en: Classes can have members of other class or struct types.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类可以有其他类或结构体类型的成员。
- en: Classes can override any parent methods marked as `virtual`, allowing them to
    perform custom actions while retaining the same blueprint.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类可以覆盖标记为`virtual`的任何父方法，允许它们执行自定义操作，同时保留相同的蓝图。
- en: 'OOP is not the only programming paradigm that can be used with C#—you can find
    practical explanations of the other main approaches here: [http://cs.lmu.edu/~ray/notes/paradigms](http://cs.lmu.edu/~ray/notes/paradigms).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）不是唯一可以与C#一起使用的编程范式——你可以在以下链接中找到其他主要方法的实用解释：[http://cs.lmu.edu/~ray/notes/paradigms](http://cs.lmu.edu/~ray/notes/paradigms)。
- en: All the OOP you've learned in this chapter is directly applicable to the C#
    world. However, we still need to put this into perspective with Unity, which is
    what you'll spend the rest of the chapter focusing on.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你学到的所有面向对象编程知识都直接适用于C#世界。然而，我们仍然需要将Unity与之结合起来，这是本章剩余部分将重点关注的。
- en: Applying OOP in Unity
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Unity中应用面向对象编程
- en: If you're around OOP languages enough, you'll eventually hear the phrase *everything
    is an object* whispered like a secret prayer between developers. Following OOP
    principles, everything in a program should be an object, but GameObjects in Unity
    can represent your classes and structs. However, that's not to say all objects
    in Unity have to be in the physical scene, so we can still use our newfound programmed
    classes behind the scenes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你足够了解面向对象的语言，你最终会听到开发者之间像秘密祈祷一样低声说出“万物皆对象”的短语。遵循面向对象的原则，程序中的所有内容都应该是一个对象，但Unity中的GameObject可以代表你的类和结构体。然而，这并不意味着Unity中的所有对象都必须在物理场景中，因此我们仍然可以在幕后使用我们新发现的程序化类。
- en: Objects are a class act
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象是一流的
- en: Back in *Chapter 2*, *The Building Blocks of Programming*, we discussed how
    a script is transformed into a component when it's added to a GameObject in Unity.
    Think of this in terms of the OOP principle of composition—GameObjects are the
    parent containers, and they can be made up of multiple components. This might
    sound contradictory to the idea of one C# class per script but, in truth, that's
    more of a guideline for better readability than an actual requirement. Classes
    can be nested inside one another—it just gets messy fast. However, having multiple
    script components attached to a single GameObject can be very useful, especially
    when dealing with manager classes or behaviors.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2章*，*编程的基本要素*中，我们讨论了当脚本被添加到Unity中的GameObject时，脚本是如何转换为组件的。从面向对象原则的组合角度来考虑这个问题——GameObject是父容器，它们可以由多个组件组成。这听起来可能有些矛盾，但实际上，这与其说是一个实际要求，不如说是一个更好的可读性的指南。类可以嵌套在彼此内部——但这很快就会变得混乱。然而，将多个脚本组件附加到单个GameObject上可能非常有用，尤其是在处理管理类或行为时。
- en: Always try to boil down objects to their most basic elements, and then use composition
    to build bigger, more complex objects out of those smaller classes. It's easier
    to modify a GameObject made out of small, interchangeable components than one
    large, clunky one.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 总是尝试将对象简化为其最基本元素，然后使用组合来构建由这些较小的类组成的大而复杂的对象。由小型可互换组件组成的GameObject比一个大而笨拙的GameObject更容易修改。
- en: 'Let''s take a look at **Main Camera** to see this in action:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看**主摄像机**来了解这一动作：
- en: '![](img/B17573_05_12.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_05_12.png)'
- en: 'Figure 5.12: Screenshot of the Main Camera object in the Inspector'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12：主摄像机对象在检查器中的截图
- en: Each component in the preceding screenshot (**Transform**, **Camera**, **Audio
    Listener**, and the **Learning Curve** script) started as a class in Unity. Like
    instances of `Character` or `Weapon`, these components become objects in computer
    memory when we click on play, complete with their member variables and methods.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 前一截图中的每个组件（**Transform**、**Camera**、**Audio Listener**和**Learning Curve**脚本）最初都是Unity中的一个类。就像`Character`或`Weapon`的实例一样，当我们点击播放时，这些组件成为计算机内存中的对象，包括它们的成员变量和方法。
- en: If we were to attach `LearningCurve` (or any script or component) to 1,000 GameObjects
    and click on play, 1,000 separate instances of `LearningCurve` would be created
    and stored in memory.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`LearningCurve`（或任何脚本或组件）附加到1,000个GameObject上并点击播放，就会在内存中创建并存储1,000个单独的`LearningCurve`实例。
- en: We can even create our instances of these components using their component name
    as the data type. Like classes, Unity component classes are reference types and
    can be created like any other variable. However, finding and assigning these Unity
    components is slightly different than what you've seen so far. For that, you'll
    need to understand a little more about how GameObjects work in the following section.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用它们的组件名称作为数据类型来创建这些组件的实例。就像类一样，Unity组件类是引用类型，可以像任何其他变量一样创建。然而，找到和分配这些Unity组件的方式与之前看到的不同。为此，你需要了解以下部分中关于GameObject工作方式的一些更多内容。
- en: Accessing components
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问组件
- en: 'Now that we know how components act on GameObjects, how do we go about accessing
    their specific instances? Lucky for us, all GameObjects in Unity inherit from
    the `GameObject` class, which means we can use their member methods to find anything
    we need in a scene. There are two ways to assign or retrieve GameObjects that
    are active in the current scene:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了组件在GameObject上的行为，我们该如何访问它们的特定实例呢？幸运的是，Unity中的所有GameObject都继承自`GameObject`类，这意味着我们可以使用它们的成员方法在场景中找到我们需要的任何东西。有几种方法可以分配或检索当前场景中活动的GameObject：
- en: Through the `GetComponent()` or `Find()` methods in the `GameObject` class,
    which work with public and private variables.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`GameObject`类中的`GetComponent()`或`Find()`方法，它们与公共和私有变量一起工作。
- en: By dragging and dropping the GameObjects themselves from the `Project` panel
    directly into variable slots in the **Inspector** tab. This option only works
    with public variables in C#, since they are the only ones that will appear in
    the Inspector. If you decide you need a private variable displayed in the Inspector,
    you can mark it with the `SerializeField` attribute.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`Project`面板中的GameObject本身拖放到**检查器**选项卡中的变量槽中。此选项仅适用于C#中的公共变量，因为它们是唯一会出现在检查器中的变量。如果你决定需要在检查器中显示私有变量，你可以使用`SerializeField`属性对其进行标记。
- en: 'You can learn more about attributes and `SerializeField` in the Unity documentation:
    [https://docs.unity3d.com/ScriptReference/SerializeField.html](https://docs.unity3d.com/ScriptReference/SerializeField.html).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Unity文档中了解更多关于属性和`SerializeField`的信息：[https://docs.unity3d.com/ScriptReference/SerializeField.html](https://docs.unity3d.com/ScriptReference/SerializeField.html)。
- en: Let's take a look at the syntax of the first option.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第一个选项的语法。
- en: Accessing components in code
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在代码中访问组件
- en: 'Using `GetComponent` is fairly simple, but its method signature is slightly
    different from other methods that we''ve seen so far:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GetComponent`相当简单，但它的方法签名与我们迄今为止看到的其他方法略有不同：
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: All we need is the component type that we're looking for, and the `GameObject`
    class will return the component if it exists and null if it doesn't. There are
    other variations of the `GetComponent` method, but this one is the simplest because
    we don't need to know specifics about the `GameObject` class that we're looking
    for. This is called a `generic` method, which we'll discuss further in *Chapter
    13*, *Exploring Generics, Delegates, and Beyond*. However, for now, let's just
    work with the camera's transform.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的只是我们正在寻找的组件类型，如果存在，`GameObject`类将返回该组件，如果不存在，则返回null。`GetComponent`方法有其他变体，但这个是最简单的，因为我们不需要知道我们正在寻找的`GameObject`类的具体信息。这被称为`泛型`方法，我们将在第13章*探索泛型、委托以及其他内容*中进一步讨论。然而，现在，让我们只处理相机的变换。
- en: 'Since `LearningCurve`is already attached to the **Main Camera** object, let''s
    grab the camera''s `Transform` component and store it in a public variable. The
    `Transform` component controls an object''s position, rotation, and scale in Unity,
    so it''s a handy example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`LearningCurve`已经附加到**主相机**对象，让我们获取相机的`Transform`组件并将其存储在一个公共变量中。`Transform`组件控制Unity中对象的位置、旋转和缩放，因此它是一个方便的例子：
- en: 'Add a new public `Transform` type variable, called `CamTransform`, to `LearningCurve`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个新的公共`Transform`类型变量`CamTransform`添加到`LearningCurve`中：
- en: '[PRE33]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Initialize `CamTransform` in `Start` using the `GetComponent` method from the
    `GameObject` class. Use the `this` keyword, since `LearningCurve`is attached to
    the same `GameObject` component as the `Transform` component.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start`中使用`GameObject`类的`GetComponent`方法初始化`CamTransform`。使用`this`关键字，因为`LearningCurve`附加到与`Transform`组件相同的`GameObject`组件。
- en: 'Access and debug the `localPosition` property of `CamTransform` using dot notation:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用点符号访问和调试`CamTransform`的`localPosition`属性：
- en: '[PRE34]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We've added an uninitialized `public Transform` variable at the top of `LearningCurve`
    and initialized it using the `GetComponent` method inside `Start`. `GetComponent`
    finds the `Transform` component attached to this `GameObject` component and returns
    it to `CamTransform`. With `CamTransform` now storing a `Transform` object, we
    have access to all its class properties and methods—including `localPosition`
    in the following screenshot:![](img/B17573_05_13.png)
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`LearningCurve`的顶部添加了一个未初始化的`public Transform`变量，并在`Start`方法中使用`GetComponent`方法对其进行初始化。`GetComponent`找到附加到该`GameObject`组件的`Transform`组件，并将其返回给`CamTransform`。现在`CamTransform`存储了一个`Transform`对象，我们可以访问其所有类属性和方法——包括以下截图中的`localPosition`：![](img/B17573_05_13.png)
- en: 'Figure 5.13: Screenshot of the Transform position printed to the console'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13：Transform位置打印到控制台的截图
- en: The `GetComponent` method is fantastic for quickly retrieving components, but
    it only has access to components on the GameObject that the calling script is
    attached to. For instance, if we use `GetComponent` from the `LearningCurve` script
    attached to the **Main Camera**, we'll only be able to access the **Transform**,
    **Camera**, and **Audio Listener** components.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetComponent`方法对于快速检索组件非常出色，但它只能访问调用脚本附加到的GameObject上的组件。例如，如果我们从附加到**主相机**的`LearningCurve`脚本中使用`GetComponent`，我们只能访问**Transform**、**Camera**和**音频监听器**组件。'
- en: If we want to reference a component on a separate GameObject, such as **Directional
    Light**, we would need to get a reference to the object first using the `Find`
    method. All it takes is the name of a GameObject, and Unity will kick back the
    appropriate GameObject for us to store or manipulate.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要引用一个位于独立GameObject上的组件，例如**方向光**，我们首先需要使用`Find`方法获取该对象的引用。只需提供GameObject的名称，Unity就会返回相应的GameObject供我们存储或操作。
- en: 'For reference, the name of each GameObject can be found at the top of the **Inspector**
    tab with the object selected:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了参考，当对象被选中时，每个GameObject的名称都可以在**检查器**标签的顶部找到：
- en: '![](img/B17573_05_14.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![拖放](img/B17573_05_14.png)'
- en: 'Figure 5.14: Screenshot of the Directional Light object in the Inspector'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14：检查器中方向光对象的截图
- en: Finding objects in your game scenes is crucial in Unity, so you'll need to practice.
    Let's take the objects we have to work with and practice finding and assigning
    their components.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，查找游戏场景中的对象至关重要，因此你需要练习。让我们拿我们正在处理的对象来练习查找和分配它们的组件。
- en: 'Let''s take the `Find` method out for a spin and retrieve the **Directional
    Light** object from `LearningCurve`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下`Find`方法，并从`LearningCurve`中检索**方向光**对象：
- en: 'Add two variables to `LearningCurve` underneath `CamTransform`—one of type
    `GameObject` and one of type `Transform`:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CamTransform`下添加两个变量到`LearningCurve`——一个是`GameObject`类型，另一个是`Transform`类型：
- en: '[PRE35]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Find the `Directional Light` component by name, and use it to initialize `DirectionLight`
    inside the `Start()` method:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过名称查找`DirectionLight`组件，并在`Start()`方法中使用它来初始化`DirectionLight`：
- en: '[PRE36]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Set the value of `LightTransform` to the `Transform` component attached to
    `DirectionLight`, and debug its `localPosition`. Since `DirectionLight` is its
    `GameObject` now, `GetComponent` works perfectly:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`LightTransform`的值设置为`DirectionLight`附加的`Transform`组件，并调试其`localPosition`。由于`DirectionLight`现在是它的`GameObject`，`GetComponent`工作得非常完美：
- en: '[PRE37]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Before running the game, it''s important to understand that method calls can
    be chained together to cut down the number of code steps. For instance, we could
    initialize `LightTransform` in a single line by combining `Find` and `GetComponent`
    without having to go through `DirectionLight`:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行游戏之前，重要的是要理解方法调用可以串联起来以减少代码步骤的数量。例如，我们可以通过组合`Find`和`GetComponent`，而不必通过`DirectionLight`来初始化`LightTransform`，从而在单行中完成：
- en: '[PRE38]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A word of warning—long lines of chained code can lead to poor readability and
    confusion when working on complex applications. It's a good rule of thumb to avoid
    lines longer than this example.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一句——长串的代码链在处理复杂应用程序时可能会导致可读性差和混淆。避免超过这个示例的长行是一个好的经验法则。
- en: While finding objects in code always works, you can also simply drag and drop
    the objects themselves into the **Inspector** tab. Let's demonstrate how to do
    that in the following section.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在代码中查找对象总是可行的，但你也可以直接将对象拖放到**检查器**标签中。让我们在下一节中演示如何做到这一点。
- en: Drag and drop
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拖放
- en: Now that we've covered the code-intensive way of doing things, let's take a
    quick look at Unity's drag and drop functionality. Although dragging and dropping
    is much faster than using the `GameObject` class in code, Unity sometimes loses
    the connections between objects and variables made this way when saving or exporting
    projects, or when Unity updates.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了代码密集型的方法，让我们快速看一下Unity的拖放功能。尽管拖放比使用代码中的`GameObject`类要快得多，但Unity在保存或导出项目，或者当Unity更新时，有时会丢失通过这种方式建立的对象和变量之间的连接。
- en: When you need to assign a few variables quickly, then, by all means, take advantage
    of this feature. For most cases, I'd advise sticking with code.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要快速分配几个变量时，不妨利用这个特性。在大多数情况下，我建议坚持使用代码。
- en: 'Let''s change `LearningCurve`to show how to assign a `GameObject` component
    using drag and drop:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变`LearningCurve`来展示如何使用拖放分配`GameObject`组件：
- en: 'Comment out the following line of code, where we used `GameObject.Find()` to
    retrieve and assign the `Directional Light` object to the `DirectionLight` variable:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉以下代码行，其中我们使用了`GameObject.Find()`来检索并分配`Directional Light`对象到`DirectionLight`变量：
- en: '[PRE39]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Select the **Main Camera** GameObject, drag **Directional Light** to the `Direction
    Light` field in the **Learning Curve** component, and click on play:![](img/B17573_05_15.png)
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**主摄像机**GameObject，将**方向光**拖动到**学习曲线**组件中的`方向光`字段，然后点击播放！![img/B17573_05_15.png](img/B17573_05_15.png)
- en: 'Figure 5.15: Screenshot of dragging Directional Light to the script property'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.15：将方向光拖动到脚本属性中的截图
- en: The **Directional Light** GameObject is now assigned to the `DirectionLight`
    variable. No code was involved because Unity assigned the variable internally,
    with no change to the `LearningCurve`class.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**方向光**GameObject现在被分配给`DirectionLight`变量。没有涉及代码，因为Unity内部分配了变量，没有改变`LearningCurve`类。'
- en: It is important to understand a few things when deciding whether to assign variables
    using drag and drop or `GameObject.Find()`. First, the `Find()` method is marginally
    slower, leaving your game open to performance issues if you are calling the method
    multiple times in multiple scripts. Second, you need to be sure your GameObjects
    all have unique names in the scene hierarchy; if they don't, it may lead to some
    nasty bugs in situations where you have several objects of the same name or change
    the object names themselves.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是否使用拖放或`GameObject.Find()`来分配变量时，理解以下几点很重要。首先，`Find()`方法稍微慢一些，如果你在多个脚本中多次调用该方法，可能会使你的游戏面临性能问题。其次，你需要确保场景层次结构中的GameObject都具有唯一的名称；如果没有，当有多个同名对象或更改对象名称时，可能会导致一些棘手的错误。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Our journey into classes, structs, and OOP marks the end of the first section
    on the fundamentals of C#. You've learned how to declare your classes and structs,
    which is the scaffolding for every application or game you'll ever make. You've
    also identified the differences in how these two objects are passed and accessed
    and how they relate to OOP. Finally, you got hands-on with the tenets of OOP—creating
    classes using inheritance, composition, and polymorphism.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对类、结构和面向对象编程的探索标志着C#基础知识第一部分的结束。你已经学会了如何声明你的类和结构体，这是你将制作的每个应用程序或游戏的基础。你还确定了这两个对象在传递和访问方面的差异以及它们与面向对象编程的关系。最后，你亲身体验了面向对象编程的原则——使用继承、组合和多态创建类。
- en: Identifying related data and actions, creating blueprints to give them shape,
    and using instances to build interactions are a strong foundation for approaching
    any program or game. Add the ability to access components to the mix, and you've
    got the makings of a Unity developer.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 识别相关数据和操作，创建蓝图以赋予它们形状，并使用实例来构建交互是处理任何程序或游戏的基础。将访问组件的能力加入其中，你就有了Unity开发者的雏形。
- en: The next chapter will segue into the basics of game development and scripting
    object behavior directly in Unity. We'll start by fleshing out the requirements
    of a simple open-world adventure game, work with GameObjects in the scene, and
    finish off with a white-boxed environment ready for our characters.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将过渡到游戏开发的基础和直接在Unity中脚本化对象行为。我们将从细化一个简单开放世界冒险游戏的需求开始，在场景中与GameObject一起工作，并以一个为我们的角色准备好的白盒环境结束。
- en: Pop quiz – all things OOP
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速问答——所有关于面向对象编程的内容
- en: What method handles the initialization logic inside a class?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个方法处理类内部的初始化逻辑？
- en: Being value types, how are structs passed?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为值类型，结构体是如何传递的？
- en: What are the main tenets of OOP?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 面向对象编程的主要原则是什么？
- en: Which `GameObject` class method would you use to find a component on the same
    object as the calling class?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪个`GameObject`类方法来在调用类相同的对象上找到组件？
- en: JOIN us on Discord!
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity/C#专家和哈里森·费罗尼一起阅读这本书。提问，为其他读者提供解决方案，通过“问我任何问题”的环节与作者聊天，以及更多。
- en: Join Now!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在加入我们！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code_9781801813945.png)'
