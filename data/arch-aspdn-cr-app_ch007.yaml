- en: 6 Model-View-Controller
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 模型-视图-控制器
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始之前：加入我们的 Discord 书籍社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的 Discord 服务器上与其他早期读者聊天（在“architecting-aspnet-core-apps-3e”频道下找到，属于早期访问订阅）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file29.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![二维码描述自动生成](img/file29.png)'
- en: 'This chapter delves into the Model-View-Controller (MVC) design pattern, a
    cornerstone of modern software architecture that intuitively structures your code
    around entities. MVC is perfect for CRUD operations or to tap into the advanced
    features unavailable in Minimal APIs. The MVC pattern partitions your application
    into three interrelated parts: Models, Views, and Controllers.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了模型-视图-控制器（MVC）设计模式，这是现代软件架构的基石，它直观地将代码围绕实体组织。MVC 适用于 CRUD 操作或利用 Minimal
    APIs 中不可用的高级功能。MVC 模式将应用程序划分为三个相互关联的部分：模型、视图和控制器。
- en: '**Models**, which represent our data and business logic.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**，代表我们的数据和业务逻辑。'
- en: '**Views**, which are the user-facing components.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**，即面向用户的组件。'
- en: '**Controllers**, that act as intermediaries, mediating the interaction between
    Models and Views.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**，作为中介，在模型和视图之间进行交互。'
- en: 'With its emphasis on the separation of concerns, the MVC pattern is a proven
    pattern for creating scalable and robust web applications. In the context of ASP.NET
    Core, MVC has provided a practical approach to building applications efficiently
    for years. While we discussed REST APIs in *Chapter 4*, this chapter provides
    insight into how to use MVC to create REST APIs. We also address using Data Transfer
    Objects (DTOs) within this framework.In this chapter, we cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 重视关注点分离的 MVC 模式是创建可扩展和健壮 Web 应用的有效模式。在 ASP.NET Core 的背景下，MVC 多年来提供了一种高效构建应用程序的实际方法。虽然我们在第
    4 章，*REST API* 中讨论了 REST API，但本章提供了如何使用 MVC 创建 REST API 的见解。我们还讨论了在此框架中使用数据传输对象（DTOs）。在本章中，我们涵盖了以下主题：
- en: The Model-View-Controller design pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-视图-控制器设计模式
- en: Using MVC with DTOs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MVC 和 DTOs
- en: Our ultimate goal is clean, maintainable, and scalable code; the ASP.NET Core
    MVC framework is a favored tool for achieving this. Let's dive in!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终目标是编写干净、可维护和可扩展的代码；ASP.NET Core MVC 框架是实现这一目标的首选工具。让我们深入探讨吧！
- en: The Model View Controller design pattern
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型视图控制器设计模式
- en: 'Now that we have explored the basics of REST and Minimal APIs, it is time to
    explore the MVC pattern to build ASP.NET Core REST APIs.Model-View-Controller
    (MVC) is a design pattern commonly used in web development. It has a long history
    of building REST APIs in ASP.NET and is widely used and praised by many.This pattern
    divides an application into three interconnected components: the Model, the View,
    and the Controller. A View in MVC formerly represented a user interface. However,
    in our case, the View is a data contract that reflects the REST API’s data-oriented
    nature.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了 REST 和 Minimal APIs 的基础知识，是时候探索 MVC 模式来构建 ASP.NET Core REST API 了。模型-视图-控制器（MVC）是常用于
    Web 开发的设计模式。它在 ASP.NET 中构建 REST API 的历史很长，并且被许多人广泛使用和赞誉。这个模式将应用程序划分为三个相互关联的组件：模型、视图和控制器。在
    MVC 中，视图以前代表用户界面。然而，在我们的案例中，视图是一个数据合约，反映了 REST API 的数据导向特性。
- en: Dividing responsibilities this way aligns with the **Single Responsibility Principle**
    (**SRP**) explored in *Chapter 3*, *Architectural Principles*. However, this is
    not the only way to build REST APIs with ASP.NET Core, as we saw in *Chapter 5*,
    *Minimal APIs*.
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以这种方式划分责任与第 3 章，*架构原则* 中探讨的**单一职责原则（SRP**）相一致。然而，这并不是使用 ASP.NET Core 构建 REST
    API 的唯一方法，正如我们在第 5 章，*Minimal APIs* 中所看到的。
- en: ''
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The new minimal API model mixed with the Request-EndPoint-Response (REPR) pattern
    can make building REST APIs leaner. We cover that pattern in *Chapter 18*, *Request-EndPoint-Response
    (REPR)*. We could see REPR as what ASP.NET Core Razor Pages are to page-oriented
    web applications, but for REST APIs.
  id: totrans-17
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 新的极简 API 模型与请求-端点-响应（REPR）模式相结合，可以使构建 REST API 更加精简。我们在第 18 章，*请求-端点-响应（REPR）*
    中介绍了这个模式。我们可以将 REPR 视为 ASP.NET Core Razor Pages 对页面导向型 Web 应用程序的作用，但它是针对 REST
    API 的。
- en: 'We often design MVC applications around entities, and each entity has a controller
    that orchestrates its endpoints. We called those CRUD controllers. However, you
    can design your controller to fit your needs.In the past few decades, the number
    of REST APIs just exploded to a gazillion; everybody builds APIs nowadays, not
    because people follow the trend but based on good reasons. REST APIs have fundamentally
    transformed how systems communicate, offering various benefits that make them
    indispensable in modern software architecture. Here are a few key factors that
    contribute to their widespread appeal:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常围绕实体设计 MVC 应用程序，每个实体都有一个控制器来协调其端点。我们称之为 CRUD 控制器。然而，你可以根据你的需求设计你的控制器。在过去几十年里，REST
    API 的数量激增到了数以亿计；如今，每个人都在构建 API，这不仅仅是因为人们跟风，而是基于良好的理由。REST API 已经从根本上改变了系统之间的通信方式，提供了各种使它们在现代软件架构中不可或缺的好处。以下是几个有助于其广泛吸引力的关键因素：
- en: '**Data Efficiency**: REST APIs promote efficient data sharing across different
    systems, fostering seamless interconnectivity.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据效率**：REST API 促进不同系统之间高效的数据共享，促进无缝的互联互通。'
- en: '**Universal Communication**: REST APIs leverage universally recognized data
    formats like JSON or XML, ensuring broad compatibility and interoperability.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用通信**：REST API 利用普遍认可的数据格式，如 JSON 或 XML，确保广泛的兼容性和互操作性。'
- en: '**Backend Centralization**: REST APIs enable the backend to serve as a centralized
    hub, supporting multiple frontend platforms, including mobile, desktop, and web
    applications.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后端集中化**：REST API 使后端能够作为中央枢纽，支持多个前端平台，包括移动、桌面和 Web 应用程序。'
- en: '**Layered Backends**: REST APIs facilitate the stratification of backends,
    allowing for the creation of foundational, low-level APIs that provide basic functionalities.
    These, in turn, can be consumed by higher-level, product-centric APIs that offer
    specialized capabilities, thus promoting a flexible and modular backend architecture.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分层后端**：REST API 促进后端的分层，允许创建提供基本功能的基础、低级 API。这些 API 可以被更高层次、以产品为中心的 API 消费，这些
    API 提供了专门的功能，从而促进灵活和模块化的后端架构。'
- en: '**Security Measures**: REST APIs can function as gateways, providing security
    measures to protect downstream systems and ensuring data access is appropriately
    regulated—a good example of layering APIs.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全措施**：REST API 可以作为网关，提供安全措施以保护下游系统，并确保数据访问得到适当的监管——这是分层 API 的一个好例子。'
- en: '**Encapsulation**: REST APIs allow for the encapsulation of specific units
    of logic into reusable, independent modules, often leading to cleaner, more maintainable
    code.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：REST API 允许将特定的逻辑单元封装到可重用、独立的模块中，这通常会导致更干净、更易于维护的代码。'
- en: '**Scalability**: due to their stateless nature, REST APIs are easier to scale
    up to accommodate increasing loads.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：由于它们是无状态的，REST API 更容易扩展以适应不断增长的负载。'
- en: These advantages greatly facilitate the reuse of backend systems across various
    user interfaces or even other backend services. Consider, for instance, a typical
    mobile application that needs to support iOS, Android, and web platforms. By utilizing
    a shared backend through REST APIs, development teams can streamline their efforts,
    saving significant time and cost. This shared backend approach ensures consistency
    across platforms while reducing the complexity of maintaining multiple codebases.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优势极大地促进了后端系统在各种用户界面或甚至其他后端服务中的重用。例如，考虑一个典型的需要支持 iOS、Android 和 Web 平台的移动应用程序。通过利用通过
    REST API 共享的后端，开发团队能够简化他们的工作，节省大量时间和成本。这种共享后端方法确保了平台之间的一致性，同时减少了维护多个代码库的复杂性。
- en: We explore different such patterns in *Chapter 19*, *Introduction to Microservices
    Architecture*.
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在 *第 19 章，微服务架构简介* 中探讨了不同的此类模式。
- en: Goal
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: In the context of REST APIs, the MVC pattern aims to streamline the process
    of managing an entity by breaking it down into three separate, interacting components.
    Rather than struggling with large, bloated blocks of code that are hard to test,
    developers work with smaller units that enhance maintainability and promote efficient
    testing. This compartmentalization results in small, manageable pieces of functionality
    that are simpler to maintain and test.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REST API 的背景下，MVC 模式旨在通过将其分解为三个独立的、相互作用的组件来简化实体的管理过程。开发者不必与难以测试的大而臃肿的代码块作斗争，而是与更小的单元一起工作，这增强了可维护性并促进了高效的测试。这种模块化导致的功能小块更易于维护和测试。
- en: Design
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: 'MVC divides the application into three distinct parts, where each has a single
    responsibility:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 将应用程序分为三个不同的部分，每个部分都有单一的责任：
- en: '**Model**: The model represents the data and business logic we are modeling.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：模型代表我们正在建模的数据和业务逻辑。'
- en: '**View**: The view represents what the user sees. In the context of REST APIs,
    that usually is a serialized data structure.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：视图代表用户所看到的内容。在 REST API 的上下文中，这通常是一个序列化的数据结构。'
- en: '**Controller**: The controller represents a key component of MVC. It orchestrates
    the flow between the client request and the server response. The primary role
    of the controller is to act as an HTTP bridge. Essentially, the controller facilitates
    the communication in and out of the system.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：控制器代表 MVC 的关键组件。它协调客户端请求和服务器响应之间的流程。控制器的主要角色是充当 HTTP 桥接器。本质上，控制器促进了系统内外部的通信。'
- en: The code of a controller should remain minimalistic and not contain complex
    logic, serving as a thin layer between the clients and the domain.
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 控制器的代码应保持简洁，不包含复杂逻辑，作为客户端和领域之间的薄层。
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We explore alternative points of view in *Chapter 14*, *Layering and Clean Architecture*.
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在 *第 14 章*，*分层和清洁架构* 中探讨了不同的观点。
- en: 'Here is a diagram that represents the MVC flow of a REST API:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个表示 REST API MVC 流的图：
- en: '![Figure 6.1: Workflow of a REST API using MVC](img/file30.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1：使用 MVC 的 REST API 工作流程](img/file30.png)'
- en: 'Figure 6.1: Workflow of a REST API using MVC'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：使用 MVC 的 REST API 工作流程
- en: In the preceding diagram, we send the model directly to the client. In most
    scenarios, this is not ideal. We generally prefer sending only the necessary data
    portion, formatted according to our requirements. We can design robust API contracts
    by leveraging the Data Transfer Object (DTO) pattern to achieve that. But before
    we delve into that, let's first explore the basics of ASP.NET Core MVC.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们直接将模型发送到客户端。在大多数情况下，这并不理想。我们通常更喜欢只发送必要的数据部分，并按照我们的要求进行格式化。我们可以通过利用数据传输对象（DTO）模式来设计健壮的
    API 合同来实现这一点。但在我们深入探讨之前，让我们首先了解 ASP.NET Core MVC 的基础知识。
- en: Anatomy of ASP.NET Core web APIs
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ASP.NET Core Web API 的解剖结构
- en: There are many ways to create a REST API project in .NET, including the `dotnet
    new webapi` CLI command, also available from Visual Studio’s UI. Next, we explore
    a few pieces of the MVC framework, starting with the entry point.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中创建 REST API 项目有许多方法，包括 `dotnet new webapi` CLI 命令，该命令也可从 Visual Studio
    的 UI 中访问。接下来，我们将探索 MVC 框架的一些组件，从入口点开始。
- en: The entry point
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 入口点
- en: 'The first piece is the entry point: the `Program.cs` file. Since .NET 6, there
    is no more `Startup` class by default, and the compiler autogenerates the `Program`
    class. As explored in the previous chapter, using the minimal hosting model leads
    to a simplified `Program.cs` file with less boilerplate code.Here is an example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是入口点：`Program.cs` 文件。自 .NET 6 以来，默认情况下不再有 `Startup` 类，编译器自动生成 `Program`
    类。正如前一章所探讨的，使用最小托管模型会导致 `Program.cs` 文件简化，并减少样板代码。以下是一个示例：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding `Program.cs` file, the highlighted lines identify the minimum
    code required to enable ASP.NET Core MVC. The rest is very similar to the Minimal
    APIs code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `Program.cs` 文件中，突出显示的行标识了启用 ASP.NET Core MVC 所需的最小代码。其余部分与 Minimal APIs
    代码非常相似。
- en: Directory structure
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 目录结构
- en: The default directory structure contains a `Controllers` folder to host the
    controllers. On top of that, we can create a `Models` folder to store your model
    classes or use any other structure.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认目录结构包含一个 `Controllers` 文件夹来托管控制器。在此基础上，我们可以创建一个 `Models` 文件夹来存储模型类，或者使用任何其他结构。
- en: While controllers are typically housed in the `Controllers` directory for organizational
    purposes, this convention is more for the benefit of developers than a strict
    requirement. ASP.NET Core is indifferent to the file's location, offering us the
    flexibility to structure our project as we see fit.
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然控制器通常存放在 `Controllers` 目录中以进行组织，但这种约定更多的是为了开发者的便利，而不是严格的要求。ASP.NET Core 对文件的存储位置不感兴趣，为我们提供了灵活性，可以根据我们的需求来构建项目结构。
- en: ''
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Section 4, Applications Patterns*, explores many ways of designing applications.'
  id: totrans-52
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*第 4 节，应用模式* 探讨了许多设计应用程序的方法。'
- en: Next, we look at the central part of this pattern—the controllers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨这个模式的核心部分——控制器。
- en: Controller
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制器
- en: The easiest way to create a controller is to create a class inheriting from
    `ControllerBase`. However, while `ControllerBase` adds many utility methods, the
    only requirement is to decorate the controller class with the `[ApiController]`
    attribute.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 创建控制器最简单的方法是创建一个继承自`ControllerBase`的类。然而，尽管`ControllerBase`添加了许多实用方法，但唯一的要求是使用`[ApiController]`属性装饰控制器类。
- en: 'By convention, we write the controller’s name in its plural form and suffix
    it with `Controller`. For example, if the controller relates to the `Employee`
    entity, we’d name it `EmployeesController`, which, by default, leads to an excellent
    URL pattern that is easy to understand:'
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 按照惯例，我们用复数形式编写控制器名称，并在其后加上`Controller`后缀。例如，如果控制器与`Employee`实体相关，我们将其命名为`EmployeesController`，默认情况下，这将导致一个易于理解的优秀URL模式：
- en: 'Get all employees: `/employees`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取所有员工：`/employees`
- en: 'Get a specific employee: `/employees/{id}`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取特定员工：`/employees/{id}`
- en: And so on.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等。
- en: 'Once we have a controller class, we must add actions. Actions are public methods
    that represent the operations that a client can perform. Each action represents
    an HTTP endpoint.More precisely, the following defines a controller:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了控制器类，我们必须添加动作。动作是公共方法，代表客户端可以执行的操作。每个动作代表一个HTTP端点。更精确地说，以下定义了一个控制器：
- en: A controller exposes one or more actions.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器公开一个或多个动作。
- en: An action can take zero or more input parameters.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个动作可以接受零个或多个输入参数。
- en: An action can return zero or one output value.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个动作可以返回零个或一个输出值。
- en: The action is what handles the HTTP request.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作处理HTTP请求。
- en: We should group cohesive actions under the same controller, thus creating a
    loosely coupled unit.
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们应该将具有凝聚力的动作放在同一个控制器下，从而创建一个松散耦合的单元。
- en: 'For example, the following represents the `SomeController` class containing
    a single `Get` action:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下表示包含单个`Get`动作的`SomeController`类：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding `Get` method (action) returns an empty `200 OK` response to the
    client. We can reach the endpoint at the `/api/some` URI. From there, we can add
    more actions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`Get`方法（动作）向客户端返回一个空的`200 OK`响应。我们可以通过`/api/some` URI访问端点。从那里，我们可以添加更多动作。
- en: The `ControllerBase` class gives us access to most of the same utility methods
    as we had with the Minimal APIs `TypedResults` class.
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ControllerBase`类为我们提供了与Minimal APIs `TypedResults`类相同的许多实用方法的访问权限。'
- en: Next, we look at returning value.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看看返回值。
- en: Returning values
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: Building a REST API aims to return data to clients and execute remote operations.
    Most of the plumbing is done for us by the ASP.NET Core code, including serialization.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 构建REST API旨在向客户端返回数据并执行远程操作。大部分的管道工作都由ASP.NET Core代码为我们完成，包括序列化。
- en: Most of the ASP.NET Core pipeline is customizable, which is out of the scope
    of this chapter.
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大部分ASP.NET Core管道都是可定制的，这超出了本章的范围。
- en: 'Before returning values, let’s look at a few valuable helper methods provided
    by the `ControllerBase` class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回值之前，让我们看看`ControllerBase`类提供的几个有用的辅助方法：
- en: '| Method | Description |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| `StatusCode` | Produces an empty response with the specified status code.We
    can optionally include a second argument to serialize in the response body. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `StatusCode` | 产生一个带有指定状态码的空响应。我们可以选择性地包含一个用于序列化到响应体的第二个参数。 |'
- en: '| `Ok` | Produces a `200 OK` response, indicating the operation was successful.We
    can optionally include a second argument to serialize in the response body. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `Ok` | 产生一个`200 OK`响应，表示操作成功。我们可以选择性地包含一个用于序列化到响应体的第二个参数。 |'
- en: '| `Created` | Produces a `201 Created` response, indicating the system created
    the entity.We can optionally specify the location where to read the entity and
    the entity itself as arguments.The `CreatedAtAction` and `CreatedAtRoute` methods
    give us options to compose the location value. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `Created` | 产生一个`201 Created`响应，表示系统创建了实体。我们可以选择性地指定读取实体的位置和实体本身作为参数。《CreatedAtAction》和《CreatedAtRoute》方法为我们提供了组合位置值的选项。
    |'
- en: '| `NoContent` | Produces an empty `204 No Content` response. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `NoContent` | 产生一个空的`204 No Content`响应。 |'
- en: '| `NotFound` | Produces a `404 Not Found` response, indicating the resource
    was not found. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `NotFound` | 产生一个`404 Not Found`响应，表示未找到资源。 |'
- en: '| `BadRequest` | Produces a `400 Bad Request` response, indicating an issue
    with the client request, often a validation error. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `BadRequest` | 产生一个`400 Bad Request`响应，表示客户端请求存在问题，通常是验证错误。 |'
- en: '| `Redirect` | Produces a `302 Found` response, accepting the `Location` URL
    as an argument.Different `Redirect*` methods produce `301 Moved Permanently`,
    `307 Temporary Redirect`, and `308 Permanent Redirect` responses instead. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `Redirect` | 返回一个 `302 Found` 响应，接受 `Location` URL 作为参数。不同的 `Redirect*` 方法会产生
    `301 Moved Permanently`、`307 Temporary Redirect` 和 `308 Permanent Redirect` 响应。|'
- en: '| `Accepted` | Produces a `202 Accepted` response, indicating the beginning
    of an asynchronous process.We can optionally specify the location the client can
    query to learn about the status of the asynchronous operation. We can also optionally
    specify an object to serialize in the response body.The `AcceptedAtAction` and
    `AcceptedAtRoute` methods give us options to compose the location value. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `Accepted` | 返回一个 `202 Accepted` 响应，表示异步过程的开始。我们可以选择指定客户端可以查询以了解异步操作状态的位置。我们还可以选择指定要序列化到响应体中的对象。《AcceptedAtAction》和《AcceptedAtRoute》方法为我们提供了组合位置值的选项。|'
- en: '| `Conflict` | Produces a `409 Conflict` response, indicating a conflict occurred
    when processing the request, often a concurrency error. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `Conflict` | 返回一个 `409 Conflict` 响应，表示在处理请求时发生了冲突，通常是并发错误。|'
- en: 'Table 6.1: a subset of the ControllerBase methods producing an IActionResult.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1：`ControllerBase` 类中产生 `IActionResult` 的方法子集。
- en: Other methods in the `ControllerBase` class are self-discoverable using IntelliSense
    (code completion) or in the official documentation. Most, if not all, of what
    we covered in *Chapter 5*, *Minimal APIs*, is also available to controllers.
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ControllerBase` 类中的其他方法可以使用 IntelliSense（代码补全）或在官方文档中自行发现。我们涵盖的 *第5章*，*最小化API*
    中的大多数，如果不是全部，也都可以用于控制器。'
- en: 'The advantage of using a helper method is leveraging the ASP.NET Core MVC mechanism,
    making our life easier. However, you could manually manage the HTTP response using
    lower-level APIs like `HttpContext` or create custom classes that implement the
    `IActionResult` interface to hook your custom response classes into the MVC pipeline.Now
    let’s look at the multiple ways we can use to return data to the client:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用辅助方法的优势在于利用 ASP.NET Core MVC 机制，使我们的工作更轻松。然而，您可以使用像 `HttpContext` 这样的低级API手动管理HTTP响应，或者创建实现
    `IActionResult` 接口的自定义类，将自定义响应类钩入 MVC 管道。现在让我们看看我们可以用来向客户端返回数据的多重方式：
- en: '| Return type | Description |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 返回类型 | 描述 |'
- en: '| `void` | We can return `void` and manually manage the HTTP response using
    the `HttpContext` class.This is the most low-level and complex way. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `void` | 我们可以返回 `void` 并使用 `HttpContext` 类手动管理HTTP响应。这是最底层和最复杂的方法。|'
- en: '| `TModel` | We can directly return the model, which ASP.NET Core will serialize.
    The problem with this approach is that we don’t control the status code, nor can
    we return multiple different results from the action. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `TModel` | 我们可以直接返回模型，ASP.NET Core 将对其进行序列化。这种方法的缺点是我们无法控制状态码，也无法从操作中返回多个不同的结果。|'
- en: '| `ActionResult``IActionResult` | We can return one of those two abstractions.
    The concrete result can take many forms depending on the implementation that the
    action method returns.However, doing this makes our API less auto-discoverable
    by tools like SwaggerGen. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `ActionResult`/`IActionResult` | 我们可以返回这两个抽象之一。具体的结果可以有多种形式，具体取决于操作方法返回的实现。然而，这样做会使我们的API对像
    SwaggerGen 这样的工具的自动发现性降低。|'
- en: '| `ActionResult<TModel>` | We can return the `TModel` directly and other results
    like a `NotFoundResult` or a `BadRequestResult`.This is the most flexible way
    that makes the API the most discoverable by the ApiExplorer. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `ActionResult<TModel>` | 我们可以直接返回 `TModel` 和其他结果，如 `NotFoundResult` 或 `BadRequestResult`。这是最灵活的方法，使API对
    `ApiExplorer` 来说最具可发现性。|'
- en: 'Table 6.2: multiple ways to return data'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.2：返回数据的多重方式。
- en: 'We start with an example where the actions return an instance of the `Model`
    class by leveraging the `Ok` method (highlighted code):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个示例开始，其中操作通过利用 `Ok` 方法（高亮代码）返回 `Model` 类的实例：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The problem with the preceding code is API discoverability. The `ApiExplorer`
    can’t know what the endpoints return. The `ApiExplorer` describes the actions
    as returning `200 OK` but doesn’t know about the `Model` class.To overcome this
    limitation, we can decorate our actions with the `ProducesResponseType` attribute,
    effectively circumventing the limitation as shown below:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的问题在于API的可发现性。《ApiExplorer》无法知道端点返回的内容。《ApiExplorer》将操作描述为返回 `200 OK`，但不知道
    `Model` 类。为了克服这一限制，我们可以使用 `ProducesResponseType` 属性装饰我们的操作，有效地绕过限制，如下所示：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we specify the return type as the first argument and
    the status code as the second. Using the constants of the `StatusCodes` class
    is a convenient way to reference standard status codes. We can decorate each action
    with multiple `ProducesResponseType` attributes to define alternate states, such
    as `404` and `400`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将返回类型指定为第一个参数，将状态码指定为第二个参数。使用 `StatusCodes` 类的常量是引用标准状态码的便捷方式。我们可以用多个
    `ProducesResponseType` 属性装饰每个操作，以定义不同的状态，例如 `404` 和 `400`。
- en: With ASP.NET Core MVC, we can also define conventions that apply broad rules
    to our controllers, allowing us to define those conventions once and reuse them
    throughout our application. I left a link in the *Further reading* section.
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core MVC 中，我们还可以定义应用于我们控制器的约定，允许我们定义这些约定一次，并在整个应用程序中重用它们。我在 *进一步阅读*
    部分留下了一个链接。
- en: 'Next, We explore how we can return a `Model` instance directly. The `ApiExplorer`
    can discover the return value of the method this way, so we do not need to use
    the `ProducesResponseType` attribute:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何直接返回 `Model` 实例。`ApiExplorer` 可以通过这种方式发现方法的返回值，因此我们不需要使用 `ProducesResponseType`
    属性：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, thanks to **class conversion operators** (see *Appendix A* for more info),
    we can do the same with `ActionResult<T>`, like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，多亏了 **类转换运算符**（更多信息请参阅 *附录 A*），我们也可以用 `ActionResult<T>` 做同样的事情，如下所示：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The main benefit of using `ActionResult<T>` is to return other types of results.
    Here is an example showing this where the method returns either `Ok` or `NotFound`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ActionResult<T>` 的主要好处是返回其他类型的结果。以下是一个示例，展示了方法返回 `Ok` 或 `NotFound` 的情况：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, the `ApiExplorer` does not know about the `404 Not Found`, so we must
    document it using the `ProducesResponseType` attribute.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`ApiExplorer` 并不知道 `404 Not Found`，因此我们必须使用 `ProducesResponseType` 属性来记录它。
- en: We can return a `Task<T>` or a `ValueTask<T>` from the action method when the
    method body is asynchronous. Doing so lets you write the async/await code from
    the controller.
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当方法体是异步的时，我们可以从操作方法返回 `Task<T>` 或 `ValueTask<T>`。这样做可以让您从控制器中编写异步/等待代码。
- en: ''
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I highly recommend returning a `Task<T>` or a `ValueTask<T>` whenever possible
    because it allows your REST API to handle more requests using the same resources
    without effort. Nowadays, non-Task-based methods in libraries are infrequent,
    so you will most likely have little choice.
  id: totrans-109
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我强烈建议尽可能返回 `Task<T>` 或 `ValueTask<T>`，因为这允许您的 REST API 使用相同的资源轻松处理更多请求。如今，库中非
    Task 基础的方法很少见，所以您可能几乎没有选择。
- en: We learned multiple ways to return values from an action. The `ActionResult<T>`
    class is the most flexible regarding feature support. On the other hand, `IActionResult`
    is the most abstract one.Next, we look at routing requests to those action methods.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了多种从操作返回值的方法。在功能支持方面，`ActionResult<T>` 类是最灵活的。另一方面，`IActionResult` 是最抽象的。接下来，我们将探讨如何将请求路由到这些操作方法。
- en: Attribute routing
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 属性路由
- en: 'Attribute routing maps an HTTP request to a controller action. Those attributes
    decorate the controllers and the actions to create the complete routes. We already
    used some of those attributes. Nonetheless, let’s visit those attributes:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 属性路由将 HTTP 请求映射到控制器操作。这些属性装饰控制器和操作以创建完整的路由。我们已经使用了一些这些属性。尽管如此，让我们来看看这些属性：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `Route` attributes and `Http[Method]` attributes define what a user should
    query to reach a specific resource. The `Route` attribute allows us to define
    a routing pattern that applies to all HTTP methods under the decorated controller.
    The `Http[Method]` attributes determine the HTTP method used to reach that action
    method. They also offer the possibility to set an optional and additive route
    pattern to handle more complex routes, including specifying route parameters.
    Those attributes are beneficial in crafting concise and clear URLs while keeping
    the routing system close to the controller. All routes must be unique.Based on
    the code, `[Route("empty/[controller]")]` means that the actions of this controller
    are reachable through `empty/customers` (MVC ignores the `Controller` suffix).
    Then, the other attributes tell ASP.NET to map specific requests to specific methods:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Route` 属性和 `Http[Method]` 属性定义了用户应该查询什么以到达特定的资源。`Route` 属性允许我们定义一个路由模式，该模式适用于装饰的控制器下的所有
    HTTP 方法。`Http[Method]` 属性确定用于到达该操作方法的 HTTP 方法。它们还提供了设置可选和可添加的路由模式的可能性，以处理更复杂的路由，包括指定路由参数。这些属性在构建简洁清晰的
    URL 同时保持路由系统靠近控制器方面很有益。所有路由都必须是唯一的。根据代码，`[Route("empty/[controller]")]` 表示此控制器的操作可以通过
    `empty/customers`（MVC 忽略 `Controller` 后缀）访问。然后，其他属性告诉 ASP.NET 将特定请求映射到特定方法：'
- en: '| Routing Attribute | HTTP Method | URL |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 路由属性 | HTTP 方法 | URL |'
- en: '| `HttpGet` | `GET` | `empty/customers` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `HttpGet` | `GET` | `empty/customers` |'
- en: '| `HttpGet("{id}")` | `GET` | `empty/customers/{id}` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `HttpGet("{id}")` | `GET` | `empty/customers/{id}` |'
- en: '| `HttpPost` | `POST` | `empty/customers` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `HttpPost` | `POST` | `empty/customers` |'
- en: '| `HttpPut("{id}")` | `PUT` | `empty/customers/{id}` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `HttpPut("{id}")` | `PUT` | `empty/customers/{id}` |'
- en: '| `HttpDelete("{id}")` | `DELETE` | `empty/customers/{id}` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `HttpDelete("{id}")` | `DELETE` | `empty/customers/{id}` |'
- en: 'Table 6.3: routing attributes of the example controller and their final URL'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.3：示例控制器中的路由属性及其最终 URL
- en: 'As we can see from the preceding table, we can even use the same attribute
    for multiple actions as long as the URL is unique. In this case, the `id` parameter
    is the `GET` discriminator.Next, we can use the `FromBody` attribute to tell the
    model binder to use the HTTP request body to get the value of that parameter.
    There are many of those attributes; here’s a list:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的表中我们可以看出，只要 URL 是唯一的，我们甚至可以使用相同的属性为多个操作。在这种情况下，`id` 参数是 `GET` 区分符。接下来，我们可以使用
    `FromBody` 属性来告诉模型绑定器使用 HTTP 请求体来获取该参数的值。有许多这样的属性；以下是一个列表：
- en: '| Attribute | Description |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| `FromBody` | Binds the JSON body of the request to the parameter’s type.
    |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `FromBody` | 将请求的 JSON 主体绑定到参数的类型。 |'
- en: '| `FromForm` | Binds the form value that matches the name of the parameter.
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `FromForm` | 绑定与参数名称匹配的表单值。 |'
- en: '| `FromHeader` | Binds the HTTP header value that matches the name of the parameter.
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `FromHeader` | 绑定与参数名称匹配的 HTTP 标头值。 |'
- en: '| `FromQuery` | Binds the query string value that matches the name of the parameter.
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `FromQuery` | 绑定与参数名称匹配的查询字符串值。 |'
- en: '| `FromRoute` | Binds the route value that matches the name of the parameter.
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `FromRoute` | 绑定与参数名称匹配的路由值。 |'
- en: '| `FromServices` | Inject the service from the ASP.NET Core dependency container.
    |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `FromServices` | 从 ASP.NET Core 依赖注入容器中注入服务。 |'
- en: 'Table 6.4: MVC binding sources'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.4：MVC 绑定源
- en: ASP.NET Core MVC does many implicit binding, so you don’t always need to decorate
    all parameters with an attribute. For example, .NET injects the services we needed
    in the code samples, and we never used the `FromServices` attribute. Same with
    the `FromRoute` attribute.
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC 进行了许多隐式绑定，因此您不必总是需要用属性装饰所有参数。例如，.NET 在代码示例中注入了我们需要的服务，我们从未使用过
    `FromServices` 属性。同样，`FromRoute` 属性也是如此。
- en: 'Now, if we look back at `CustomersController`, the route map looks like the
    following (I excluded non-route-related code to improve readability):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们回顾一下 `CustomersController`，路由映射看起来如下（我排除了与路由无关的代码以提高可读性）：
- en: '| **URL** | **Action/Method** |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **URL** | **Action/Method** |'
- en: '| `GET empty/customers` | `GetAllAsync()` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `GET empty/customers` | `GetAllAsync()` |'
- en: '| `GET empty/customers/{id}` | `GetOneAsync(int id)` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `GET empty/customers/{id}` | `GetOneAsync(int id)` |'
- en: '| `POST empty/customers` | `PostAsync([FromBody] Customer value)` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `POST empty/customers` | `PostAsync([FromBody] Customer value)` |'
- en: '| `PUT empty/customers/{id}` | `PutAsync(int id, [FromBody] Customer value)`
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `PUT empty/customers/{id}` | `PutAsync(int id, [FromBody] Customer value)`
    |'
- en: '| `DELETE empty/customers/{id}` | `DeleteAsync(int id)` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE empty/customers/{id}` | `DeleteAsync(int id)` |'
- en: 'Table 6.5: the map between the URLs and their respective action methods'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.5：URL与其相应操作方法之间的映射
- en: When designing a REST API, the URL leading to our endpoints should be clear
    and concise, making it easy for consumers to discover and learn. Hierarchically
    grouping our resources by responsibility (concern) and creating a cohesive URL
    space help achieve that goal. Consumers (a.k.a. other developers) should understand
    the logic behind the endpoints easily. Think about your endpoints as if you were
    the consumer of the REST API. I would even extend that suggestion to any API;
    always consider the consumers of your code to create the best possible APIs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计REST API时，通向我们的端点的URL应该是清晰简洁的，这样消费者就可以轻松发现和学习。通过按责任（关注点）分层组织我们的资源并创建一个统一的URL空间，有助于实现这一目标。消费者（即其他开发者）应该能够轻松理解端点背后的逻辑。想想看，如果你是REST
    API的消费者，你会如何看待你的端点。我甚至会将这个建议扩展到任何API；始终考虑你的代码的消费者，以创建最佳可能的API。
- en: Conclusion
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'This section explored the MVC pattern, how to create controllers and action
    methods, and how to route requests to those actions.We could talk about MVC for
    the remainder of the book, but we would be missing the point. The subset of features
    we covered here should be enough theory to fill the gap you might have had and
    allow you to understand the code samples that leverage ASP.NET Core MVC.Using
    the MVC pattern helps us follow the SOLID principles in the following ways:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了MVC模式，如何创建控制器和操作方法，以及如何将请求路由到这些操作。我们本可以继续讨论MVC，但那样会偏离主题。我们在这里涵盖的功能子集应该足以填补你可能存在的理论空白，并允许你理解利用ASP.NET
    Core MVC的代码示例。使用MVC模式有助于我们以下列方式遵循SOLID原则：
- en: '**S**: The MVC pattern divides the rendering of a data structure into three
    different roles. The framework handles most of the serialization portion (the
    View), leaving us only two pieces to manage: the Model and the Controller.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：MVC模式将数据结构的渲染分为三个不同的角色。框架处理大部分序列化部分（视图），只留下两个部分需要我们管理：模型和控制器。'
- en: '**O**: N/A'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：N/A'
- en: '**L**: N/A'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：N/A'
- en: '**I**: Each controller handles a subset of features and represents a smaller
    interface into the system. MVC makes the system easier to manage than having a
    single entry point for all routes, like a single controller.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：每个控制器处理功能的一个子集，并代表对系统的一个较小接口。MVC使得系统比所有路由只有一个入口点（如单个控制器）更容易管理。'
- en: '**D**: N/A'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：N/A'
- en: Next, we explore the **Data Transfer Object** pattern to isolate the API’s model
    from the domain.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨**数据传输对象**（**DTO**）模式，以隔离API的模型和领域。
- en: Using MVC with DTOs
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MVC与DTOs
- en: This section explores leveraging the **Data Transfer Object** (**DTO**) pattern
    with the MVC framework.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了利用MVC框架中的**数据传输对象**（**DTO**）模式。
- en: This section is the same as we explore in *Chapter 5*, *Minimal APIs*, but in
    the context of MVC. Moreover, the two code projects are part of the same Visual
    Studio solution for convenience, allowing you to compare the two implementations.
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本节与我们在*第5章*，*最小API*中探讨的内容相同，但是在MVC的背景下。此外，这两个代码项目是同一个Visual Studio解决方案的一部分，以便于比较两种实现。
- en: Goal
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: As a reminder, DTOs aim to *control the inputs and outputs of an endpoint* by
    decoupling the API contract from the application’s inner workings. DTOs empower
    us to define our APIs without thinking about the underlying data structures, leaving
    us to craft our REST APIs how we want.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，DTOs（数据传输对象）旨在通过将API合同与应用程序的内部工作解耦来**控制端点的输入和输出**。DTOs使我们能够定义我们的API，而不必考虑底层的数据结构，从而让我们能够按照自己的意愿构建REST
    API。
- en: We discuss REST APIs and DTOs more in-depth in *Chapter 4*, *REST APIs*.
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在*第4章*，*REST API*中更深入地讨论了REST API和DTOs。
- en: Other possible objectives are to save bandwidth by limiting the amount of information
    the API transmits, flattening the data structure, or adding API features that
    cross multiple entities.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可能的目标是通过限制API传输的信息量来节省带宽，简化数据结构，或添加跨多个实体的API功能。
- en: Design
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: 'Let’s start by analyzing a diagram that expands MVC to work with DTOs:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从分析一个扩展MVC以与DTOs一起工作的图表开始：
- en: '![Figure 6.2: MVC workflow with a DTO](img/file31.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：带有DTO的MVC工作流程](img/file31.png)'
- en: 'Figure 6.2: MVC workflow with a DTO'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：带有DTO的MVC工作流程
- en: DTOs allow the decoupling of the domain from the view (data) and empower us
    to manage the inputs and outputs of our REST APIs independently from the domain.
    The controller still manipulates the domain model but returns a serialized DTO
    instead.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: DTO 允许将领域（数据）与视图解耦，并使我们能够独立于领域管理 REST API 的输入和输出。控制器仍然操作领域模型，但返回一个序列化的 DTO。
- en: Project – MVC API
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – MVC API
- en: '*This code sample is the same as in the previous chapter but uses the MVC framework
    instead of Minimal APIs*.**Context**: we must build an application to manage customers
    and contracts. We must track the state of each contract and have a primary contact
    in case the business needs to contact the customer. Finally, we must display the
    number of contracts and the number of opened contracts for each customer on a
    dashboard.As a reminder, the model is the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*此代码示例与上一章相同，但使用 MVC 框架而不是 Minimal APIs*。**上下文**：我们必须构建一个用于管理客户和合同的应用程序。我们必须跟踪每个合同的状态，并在业务需要联系客户时有一个主要联系人。最后，我们必须在仪表板上显示每个客户的合同数量和已打开合同数量。作为提醒，模型如下：'
- en: '[PRE8]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code is straightforward. The only piece of logic is the `WorkStatus.State`
    property that returns `WorkState.New` when the work has not yet started on that
    contract, `WorkState.Completed` when all the work is completed, or `WorkState.InProgress`
    otherwise.The controllers leverage the `ICustomerRepository` interface to simulate
    database operations. The implementation is unimportant. It uses a `List<Customer>`
    as the database. Here’s the interface that allows querying and updating the data:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码很简单。唯一的逻辑是 `WorkStatus.State` 属性，当该合同上的工作尚未开始时返回 `WorkState.New`，当所有工作都已完成时返回
    `WorkState.Completed`，否则返回 `WorkState.InProgress`。控制器利用 `ICustomerRepository`
    接口来模拟数据库操作。实现并不重要。它使用 `List<Customer>` 作为数据库。以下是允许查询和更新数据的接口：
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we know about the underlying foundation, we explore a CRUD controller
    that does not leverage DTOs.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了底层基础，我们来探讨一个不利用 DTO 的 CRUD 控制器。
- en: Raw CRUD Controller
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 原始 CRUD 控制器
- en: 'Many issues can arise if we create a CRUD controller to manage the customers
    directly (see `RawCustomersController.cs`). First, a little mistake from the client
    could erase several data points. For example, if the client forgets to send the
    contracts during a `PUT` operation, that would delete all the contracts associated
    with that customer. Here’s the controller code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个 CRUD 控制器来直接管理客户，可能会出现许多问题（参见 `RawCustomersController.cs`）。首先，客户端的一个小错误可能会删除几个数据点。例如，如果客户端在
    `PUT` 操作中忘记发送合同，那么就会删除与该客户关联的所有合同。以下是控制器代码：
- en: '[PRE10]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The highlighted code represents the customer update. So to mistakenly remove
    all contracts, a client could send the following HTTP request (from the `MVC.API.http`
    file):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的代码代表客户更新。因此，为了错误地删除所有合同，客户端可以发送以下 HTTP 请求（来自 `MVC.API.http` 文件）：
- en: '[PRE11]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That request would result in the following response entity:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该请求将导致以下响应实体：
- en: '[PRE12]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Previously, however, that customer had contracts (seeded when we started the
    application). Here’s the original data:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，之前那个客户已经有了合同（在我们开始应用程序时创建的）。以下是原始数据：
- en: '[PRE13]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we can see, by exposing our entities directly, we are giving a lot of power
    to the consumers of our API. Another issue with this design is the dashboard.
    The user interface would have to calculate the statistics about the contracts.
    Moreover, if we implement paging the contracts over time, the user interface could
    become increasingly complex and even overquery the database, hindering our performance.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通过直接公开我们的实体，我们给了 API 的消费者很多权力。这种设计的一个问题是仪表板。用户界面将不得不计算合同的统计数据。此外，如果我们实现分页合同，用户界面可能会变得越来越复杂，甚至可能过度查询数据库，从而阻碍我们的性能。
- en: I implemented the entire API, which is available on GitHub but without UI.
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我实现了整个 API，它可在 GitHub 上找到，但没有 UI。
- en: Next, we explore how we can fix those two use cases using DTOs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何使用 DTO 修复这两个用例。
- en: DTO controller
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DTO 控制器
- en: 'To solve our problems, we reimplement the controller using DTOs. To make it
    easier to follow along, here are all the DTOs as a reference:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决我们的问题，我们使用 DTO 重新实现了控制器。为了更容易地跟踪，以下是所有 DTO 的参考：
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'First, let’s fix our update problem, starting with the reimplementation of
    the update endpoint leveraging DTOs (see the `DTOCustomersController.cs` file):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们修复我们的更新问题，从重新实现利用 DTO 的更新端点开始（参见 `DTOCustomersController.cs` 文件）：
- en: '[PRE15]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, the main differences are (highlighted):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，主要的不同点在于（突出显示）：
- en: The request body is now bound to the `UpdateCustomer` class instead of the `Customer`
    itself.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在请求体绑定到`UpdateCustomer`类，而不是`Customer`本身。
- en: The action method returns an instance of the `CustomerDetails` class instead
    of the `Customer` itself.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作方法返回`CustomerDetails`类的实例，而不是`Customer`本身。
- en: 'However, we can see more code in our controller action than before. That’s
    because the controller now handles the data changes instead of the clients. The
    action now does:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在控制器操作中看到的代码比以前更多。这是因为控制器现在处理数据变化，而不是客户端。现在的操作包括：
- en: Load the data from the database.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库加载数据。
- en: Ensure the entity exists.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保实体存在。
- en: Use the input DTO to update the data, limiting the clients to a subset of properties.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用输入DTO更新数据，限制客户端只能访问属性子集。
- en: Proceed with the update.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续更新。
- en: Ensure the entity still exists (handles conflicts).
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保实体仍然存在（处理冲突）。
- en: Copy the Customer into the output DTO and return it.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将客户复制到输出DTO并返回。
- en: 'By doing this, we now control what the clients can do when they send a `PUT`
    request through the input DTO (`UpdateCustomer`). Moreover, we encapsulated the
    logic to calculate the statistics on the server. We hid the computation behind
    the output DTO (`CustomerDetails`), which lowers the complexity of our user interface
    and allows us to improve the performance without impacting any of our clients
    (loose coupling).Furthermore, we now use the `customerId` parameter.If we send
    the same HTTP request as before, which sends more data than we accept, only the
    customer''s name will change. On top of that, we get all the data we need to display
    the customer’s statistics. Here’s a response example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们现在控制客户端在通过输入DTO（`UpdateCustomer`）发送`PUT`请求时可以做什么。此外，我们将计算统计数据的逻辑封装在服务器上。我们将计算隐藏在输出DTO（`CustomerDetails`）后面，这降低了用户界面的复杂性，并允许我们在不影响任何客户端的情况下提高性能（松散耦合）。此外，我们现在使用`customerId`参数。如果我们发送与以前相同的HTTP请求，发送比我们接受更多的数据，只有客户的名字会改变。更重要的是，我们得到了显示客户统计所需的所有数据。以下是一个响应示例：
- en: '[PRE16]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see from the preceding response, only the customer’s name changed,
    but we now received the `statusWorkDone` and `statusTotalWork` fields. Lastly,
    we flattened the data structure.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的响应所示，只有客户的名字改变了，但我们现在收到了`statusWorkDone`和`statusTotalWork`字段。最后，我们简化了数据结构。
- en: DTOs are a great resource to flatten data structures, but you don’t have to.
    You must always design your systems, including DTOs and data contracts, for specific
    use cases.
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: DTOs是简化数据结构的绝佳资源，但您不必这样做。您必须始终为特定用例设计系统，包括DTO和数据合约。
- en: 'As for the dashboard, the “get all customers” endpoint achieves this by doing
    something similar. It outputs a collection of `CustomerSummary` objects instead
    of the customers themselves. In this case, the controller executes the calculations
    and copies the entity''s relevant properties to the DTO. Here’s the code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 至于仪表板，“获取所有客户”端点通过执行类似操作来实现这一点。它输出`CustomerSummary`对象集合，而不是客户本身。在这种情况下，控制器执行计算并将实体的相关属性复制到DTO中。以下是代码：
- en: '[PRE17]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, the action method:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，动作方法：
- en: Read the entities
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取实体
- en: Create the DTOs and calculate the number of open contracts.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建DTOs并计算未完成合同的数量。
- en: Return the DTOs.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回DTOs。
- en: As simple as that, we now encapsulated the computation on the server.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们现在在服务器上封装了计算。
- en: You should optimize such code based on your real-life data source. In this case,
    a `static` `List<T>` is low latency. However, querying the whole database to get
    a count can become a bottleneck.
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您应根据实际数据源优化此类代码。在这种情况下，`static` `List<T>`具有低延迟。然而，查询整个数据库以获取计数可能会成为瓶颈。
- en: 'Calling the endpoint results in the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 调用端点会产生以下结果：
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is now super easy to build our dashboard. We can query that endpoint once
    and display the data in the UI. The UI offloaded the calculation to the backend.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建我们的仪表板变得超级简单。我们可以查询该端点一次，并在UI中显示数据。UI将计算任务卸载到后端。
- en: User interfaces tend to be more complex than APIs because they are stateful.
    As such, offloading as much complexity to the backend helps. You can use a Backend-for-frontend
    (BFF) to help with this task. We explore ways to layer APIs, including the BFF
    pattern in *Chapter 19*, *Introduction to Microservices Architecture*.
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用户界面通常比API更复杂，因为它们是状态化的。因此，将尽可能多的复杂性卸载到后端有助于。您可以使用后端-for-前端（BFF）来帮助完成这项任务。我们在第19章“微服务架构简介”中探讨了分层API的方法，包括BFF模式。
- en: 'Lastly, you can play with the API using the HTTP requests in the `MVC.API.DTO.http`
    file. I implemented all the endpoints using a similar technique. If your controller
    logic becomes too complex, it is good practice to encapsulate it into other classes.
    We explore many techniques to organize application code in *Section 4*: *Applications
    patterns*.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用`MVC.API.DTO.http`文件中的HTTP请求来玩转API。我使用类似的技术实现了所有端点。如果您的控制器逻辑变得过于复杂，将它们封装到其他类中是一种良好的做法。我们在*第4节*：*应用模式*中探讨了组织应用程序代码的许多技术。
- en: Conclusion
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'A data transfer object allows us to design an API endpoint with a specific
    data contract (input and output) instead of exposing the domain or data model.
    This separation between the presentation and the domain is a crucial element that
    leads to having multiple independent components instead of a bigger, more fragile
    one. Using DTOs to control the inputs and outputs gives us more control over what
    the clients can do or receive.Using the data transfer object pattern helps us
    follow the SOLID principles in the following ways:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 数据传输对象允许我们设计一个具有特定数据契约（输入和输出）的API端点，而不是暴露领域或数据模型。这种表示层和领域之间的分离是导致拥有多个独立组件而不是更大、更脆弱的一个的关键元素。使用DTO来控制输入和输出，使我们能够更好地控制客户端可以做什么或接收什么。使用数据传输对象模式有助于我们以下列方式遵循SOLID原则：
- en: '**S**: A DTO adds clear boundaries between the domain model and the API contract.
    Moreover, having an input and an output DTO help further separate the responsibilities.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**: DTO在领域模型和API契约之间添加了清晰的边界。此外，拥有输入和输出DTO有助于进一步分离责任。'
- en: '**O**: N/A'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**: N/A'
- en: '**L**: N/A'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**: N/A'
- en: '**I**: A DTO is a small, specifically crafted data contract (abstraction) with
    a clear purpose in the API contract.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**: 一个DTO是一个小型、专门定制的数据契约（抽象），在API契约中有明确的目的。'
- en: '**D**: Due to those smaller interfaces (ISP), DTOs allow changing the implementation
    details of the endpoint without affecting the clients because they depend only
    on the API contract (an abstraction).'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**: 由于那些较小的接口（ISP），DTO允许在不影响客户端的情况下更改端点的实现细节，因为它们只依赖于API契约（一个抽象）。'
- en: You have learned DTOs' added value, their role in an API contract, and the ASP.NET
    Core MVC framework.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学习了DTO的附加价值，它们在API契约中的作用，以及ASP.NET Core MVC框架。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter explored the Model-View-Controller (MVC) design pattern, a well-established
    framework in the ASP.NET ecosystem that offers more advanced features than its
    newer Minimal APIs counterpart. Minimal APIs are not competing against MVC; we
    can use them together. The MVC pattern emphasizes the separation of concerns,
    making it a proven pattern for creating maintainable, scalable, and robust web
    applications. We broke down the MVC pattern into its three core components: Models,
    Views, and Controllers. Models represent data and business logic, Views are user-facing
    components (serialized data structures), and Controllers act as intermediaries,
    mediating the interaction between Models and Views. We also discussed using Data
    Transfer Objects (DTOs) to package data in the format we need, providing many
    benefits, including flexibility, efficiency, encapsulation, and improved performance.
    DTOs are a crucial part of the API contract.Now that we have explored principles
    and methodologies, it is time to continue our learning and tackle more design
    patterns and features. The following two chapters explore our first Gang of Four
    (GoF) design patterns and deep dive into ASP.NET Core dependency injection (DI).
    All of this will help us to continue on the path we started: to learn the tools
    to design better software.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了模型-视图-控制器（MVC）设计模式，这是ASP.NET生态系统中的一个成熟框架，它比其较新的最小API对等体提供了更多高级功能。最小API并不是与MVC竞争；我们可以将它们一起使用。MVC模式强调关注点的分离，使其成为创建可维护、可扩展和健壮的Web应用的成熟模式。我们将MVC模式分解为其三个核心组件：模型、视图和控制器。模型表示数据和业务逻辑，视图是面向用户的组件（序列化的数据结构），控制器作为中介，在模型和视图之间进行调解。我们还讨论了使用数据传输对象（DTO）以我们需要的格式打包数据，提供了许多好处，包括灵活性、效率、封装和性能提升。DTO是API契约的关键部分。现在我们已经探讨了原则和方法，是时候继续我们的学习，并解决更多设计模式和功能了。接下来的两章将探讨我们的第一个四人帮（GoF）设计模式，并深入探讨ASP.NET
    Core依赖注入（DI）。所有这些都将帮助我们继续我们开始的道路：学习设计更好软件的工具。
- en: Questions
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s look at a few practice questions:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个练习问题：
- en: What are the three components of the MVC design pattern?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MVC设计模式的三个组件是什么？
- en: What is the role of a Controller in the MVC pattern?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MVC模式中，控制器的作用是什么？
- en: What are Data Transfer Objects (DTOs), and why are they important?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据传输对象 (DTO) 是什么，为什么它们很重要？
- en: How does the MVC pattern contribute to the maintainability of an application?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MVC 模式如何有助于提高应用程序的可维护性？
- en: How does attribute routing work in MVC?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MVC 中的属性路由是如何工作的？
- en: Further reading
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some links to build on what we have learned in the chapter:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些链接，可以帮助我们巩固本章所学的内容：
- en: 'Using web API conventions: [https://adpg.link/ioKV](https://adpg.link/ioKV)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Web API 规范：[https://adpg.link/ioKV](https://adpg.link/ioKV)
- en: 'Getting started with Swashbuckle and ASP.NET Core: [https://adpg.link/ETja](https://adpg.link/ETja)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 Swashbuckle 和 ASP.NET Core：[https://adpg.link/ETja](https://adpg.link/ETja)
- en: Answers
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: The three components of the MVC design pattern are Models, Views, and Controllers.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MVC 设计模式的三个组件是模型、视图和控制器。
- en: In the MVC pattern, a Controller acts as an intermediary, mediating the interaction
    between Models and Views.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MVC 模式中，控制器充当中间件，在模型和视图之间进行交互调解。
- en: We use Data Transfer Objects (DTOs) to package data into a format that provides
    many benefits, including efficient data sharing, encapsulation, and improved maintainability.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用数据传输对象 (DTO) 将数据打包成一种格式，它提供了许多好处，包括高效的数据共享、封装和改进的可维护性。
- en: The MVC pattern contributes to the maintainability of an application by separating
    concerns. Each component (Model, View, Controller) has a specific role and responsibility,
    making the code easier to manage, test, and extend. This separation allows changes
    to one component to have minimal impact on the others.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MVC 模式通过分离关注点来提高应用程序的可维护性。每个组件（模型、视图、控制器）都有特定的角色和责任，这使得代码更容易管理、测试和扩展。这种分离使得对一个组件的更改对其他组件的影响最小化。
- en: Attribute routing in MVC maps an HTTP request to a controller action. These
    attributes decorate the controllers and the actions to create the complete routes.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MVC 中，属性路由将 HTTP 请求映射到控制器操作。这些属性装饰控制器和操作以创建完整的路由。
