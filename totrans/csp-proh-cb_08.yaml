- en: Chapter 8. Code Contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will introduce you to code contracts. This is a very powerful
    technology and one that will enable you to secure your code from unnecessary errors.
    This is especially true when you are writing a class that is shared between several
    developers. Code contracts allow you to inspect and handle data passed to your
    method under contract. If the contract fails its validation, you can take decisive
    action within your method to handle this eventuality. This chapter will cover
    the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading, installing, and integrating code contracts into Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating code contract preconditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating code contract postconditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating code contract invariant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating code contract `Assert` and `Assume` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating code contract `ForAll` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating code contract `ValueAtReturn` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating code contract `Result` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using code contracts on abstract classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using contract abbreviator methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tests using IntelliTest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using code contracts in extension methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might be wondering what code contracts are exactly. To explain it in layman's
    terms, a code contract is a definition that you add to your methods. It tells
    the compilers that the method under contract will always adhere to specific conditions.
    An example of this is that the method will never return a null value to the calling
    code or that the method will always expect a parameter greater than a specific
    value. If any of these conditions are not met, your code can emit an exception,
    and the developer integrating with your class will be prompted to refine their
    calling code. On the flip side, when a developer calls your class, they can be
    sure that the method under contract will always behave in a specific way and never
    deviate from it.
  prefs: []
  type: TYPE_NORMAL
- en: Code contracts really stand out when working within a team of developers, but
    implementing this technology in a single-developer solution will only improve
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading, installing, and integrating code contracts into Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you can use code contracts in your applications, you need to download
    and install them. The easiest way of doing this is via extensions and updates.
    After the installation is complete, you will need to define a few settings for
    the code contracts to start functioning against the code they are implemented
    in. Let's have a look at the following recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will create a new class and add it to our Visual Studio project. We
    will then get the Code Contracts installer and install it for our project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new class by right-clicking on your solution and selecting **Add**
    and then **New Project** from the context menu:![How to do it…](img/B05391_08_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Add New Project** dialog screen, select **Class Library** from the
    installed templates and call your class `Chapter8`:![How to do it…](img/B05391_08_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your new class library will be added to your solution with a default name of
    `Class1.cs`, which we renamed to `Recipes.cs` in order to distinguish the code
    properly. You can, however, rename your class to whatever you like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To rename your class, simply click on the class name in **Solution Explorer**
    and select **Rename** from the context menu:![How to do it…](img/B05391_08_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio will ask you to confirm a rename of all references to the code
    element **Class1** in the project. Just click on **Yes**:![How to do it…](img/B05391_08_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on the **Tools** menu and select **Extensions and Updates…**:![How
    to do it…](img/B05391_08_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see the **Extensions and Updates** window appear. Be sure to click
    on the **Visual Studio Gallery** on the left-hand side and type `Code Contracts`
    as the search term. If you have not got the Code Contracts installer, you will
    see a download button appear on the **Code Contracts for .NET** result. Click
    on it to download and install code contracts:![How to do it…](img/B05391_08_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After code contracts have been installed, you might need to restart Visual Studio.
    After doing this, right-click on the `Chapter8` project and select **Properties**
    from the context menu:![How to do it…](img/B05391_08_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will notice that a new **Code Contracts** tab has been added to the properties
    page for your `Chapter8` project. Click on this tab and make sure that **Perform
    Runtime Contract Checking** is checked. Then, save your changes and close the
    properties page:![How to do it…](img/B05391_08_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, add a reference to your `Chapter8` project in the console application
    created earlier. Do this by expanding your console application project and right-clicking
    on the **References** item. Select **Add Reference** from the context menu:![How
    to do it…](img/B05391_08_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that you have selected `Chapter8` in the project references section
    and click on **OK**:![How to do it…](img/B05391_08_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have now installed and configured the minimum requirements to enable code
    contracts in your `Chapter8` class. You can now go ahead and build your solution
    to make sure that everything builds successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Creating code contract preconditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Preconditions allow you to control exactly what the parameters need to look
    like before they are used in your method. This means that you can assume a lot
    of things about the data being sent to your method by the calling code. You can,
    for example, specify that a parameter should never be null or that a value must
    always be within a specific value range. Dates can be checked, and objects can
    be verified and vetted.
  prefs: []
  type: TYPE_NORMAL
- en: You have complete control over the data coming in to your method. It gives you
    the peace of mind to use that data once it has passed your contract without having
    to do additional checks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be sure that you have installed code contracts and that you have configured
    the settings correctly in the project properties, as described in the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In your `Recipes` class, create a new method called `ValueGreaterThanZero()`
    and have it take an integer as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `ValueGreaterThanZero()` method, type the start of the `Contract` declaration,
    and you will notice that the code is underlined with a red squiggly line. Hold
    down *Crtl* + *.* (period) to bring up the suggestions for potential fixes. Click
    on the suggestion to add the `using` statement for the code contracts to your
    class:![How to do it…](img/B05391_08_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you have done that, continue entering the precondition. Define that the
    parameter value must be greater than zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you go back to the console application, add the following `using` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we have created a static class and brought it into scope with the `using`
    statement, you can just call the method name in the `Recipes` class directly.
    To see how code contracts work, pass a zero parameter to the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, run your console application and see the exception generated:![How
    to do it…](img/B05391_08_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code contract has inspected the precondition and determined that the parameter
    value passed to the method under contract failed the precondition check. An exception
    is thrown and output to the console window.
  prefs: []
  type: TYPE_NORMAL
- en: Creating code contract postconditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as code contract preconditions control what information is passed to the
    method under contract, code contract postconditions control what information the
    method under contract returns to the calling code. You can, therefore, specify
    that the method will never return a null value or an empty dataset, for example.
    The actual condition does not matter; this is something that will change on a
    case-by-case basis. The important thing to remember here is that this code contract
    allows you to have more control over the data returned by your code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assume that the method under contract needs to ensure that the value returned
    will always be greater than zero. Using a code contract postcondition, we can
    easily enforce this rule.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you start, make sure that you have added the following `using` statement
    to the top of your `Recipes` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Recipes` class, add a method called `NeverReturnZero()` and pass an
    integer parameter to this method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the method, add your postcondition contract. As one could expect, the
    method in the contract class is called `Ensures`. This is quite descriptive of
    its function. The code contract ensures that a specific method result is never
    returned. You can see this in the signature of the `Contract.Ensures` method.
    The postcondition, therefore, ensures that the result of this method will never
    be zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go back to the console application, and add the following `using` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since you have created a static class and brought it into scope with the `using`
    statement, you can just call the method name in the `Recipes` class directly.
    Pass the `NeverReturnZero()` method a value of `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, run your console application and review the output in the console window:![How
    to do it…](img/B05391_08_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the value of `1` was passed to the method under contract, it resulted in
    a return value of zero being returned. We forced this by subtracting `1` from
    the parameter passed to the method. As the method ensures non-zero values, an
    exception was thrown with the message we defined.
  prefs: []
  type: TYPE_NORMAL
- en: Creating code contract invariant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Something that is defined as invariant tells us that it will never change. It
    will always be the same, no matter what. This brings up a vast array of use cases
    if we consider this in the context of code contracts. The invariant code contract
    is basically used to validate the internal state of a class. So, what do we mean
    by the "internal state?" Well, the properties of the class give that class a specific
    state. Let's assume that we wanted to guarantee that the properties of the class
    we are using only accept specific values, thereby assuring the internal state
    of that class. This is where the code contract invariant comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can understand the use of the invariant better with the use of the following
    example. Assume that the class needs to store dates. We can't ever store a date
    in the past though. Any date used in the class must be a current or future date.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you go on, ensure that you have added the code contracts `using` statement
    to the top of your `Recipes.cs` class file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will add a new class called `InvariantClassState` to the `Recipes.cs`
    class file. This is so that we can create an instance class and not a static class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `private` properties to your `InvariantClassState` class
    that will accept integer values for the year, month, and day:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now add a constructor to our `InvariantClassState` class. The constructor
    will accept parameters to set the properties created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you create `public` properties, it is always a good practice to create them
    with `private` setters such as `public int Value { get; private set; }`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next method we need to add is the contract invariant method. You can call
    this method any name you like, and in this example, it is called `Invariants()`.
    You will read many developers stating that a commonly accepted practice is to
    call this method `ObjectInvariant()`. The naming of this method, however, has
    no impact on the invariant code contract. You will notice that we decorate this
    method with `[ContractInvariantMethod]`, and it is this that defines this method
    (whatever the name) as the invariant code contract. Another important thing to
    remember is that the invariant code contract method must be a `void` method and
    be specified as a `private` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside our code contract invariant method, we now specify which properties
    are invariant. In other words, those properties that can never be any other value
    than what we specify inside this code contract invariant method. For starters,
    we will specify that the year value cannot be in the past. We will also ensure
    that the month value is a valid value between `1` and `12`. Finally, we will specify
    that the day value cannot be a value outside the days contained in the month supplied
    or a value less than `1`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can further extend the `Contract.Invariant` methods by supplying an exception
    message. Your `Invariants()` method will then look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add another method that returns the date formatted as month/day/year:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you are finished, your `InvariantClassState` class will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Head back to the console application and add the following `using` statement
    to your console application `Program.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now add a new instance of our `InvariantStateClass` class and pass
    the values to the constructor. First, pass the current year less than `1` to the
    constructor. This will result in the last year being passed to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running your console application will result in the code contract invariant
    throwing an exception because the year passed to the constructor is in the past:![How
    to do it…](img/B05391_08_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s modify our code by passing a valid year value to the constructor, but
    keep the rest of the parameter values the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running the console application will again result in an exception message stating
    that the month value cannot be greater then `12`:![How to do it…](img/B05391_08_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once again, modify the parameters passed to the method and supply a valid year
    and month value, but pass an invalid day value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running the console application again will result in the code contract invariant
    throwing an exception because the day is clearly wrong. No month contains 32 days:![How
    to do it…](img/B05391_08_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the parameters passed to the constructor again, and this time, add valid
    values for year, month, and day:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because November 25, 2016 is a valid date (because the current year is 2016),
    the formatted date is returned to the console application window:![How to do it…](img/B05391_08_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s mix things up a little by passing 29 February, 2017 to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, the code contract invariant method throws an exception because 2017 is
    not a leap year:![How to do it…](img/B05391_08_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code contract invariant method is a simple yet effective way to ensure that
    the state of your class is not modified. You can then assume that the properties
    you use inside your class are always correct and will never contain unexpected
    values. We like to think of the code contract invariant as a type of immutable
    (which it isn't). Strings are immutable, which means that the original value is
    never modified when the value changes. A new space in memory is always created
    when you change the value of a string. Similarly, this reminds me of the properties
    defined as invariant. These property values can never change to values other than
    those defined by our code contract invariant method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating code contract Assert and Assume methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code contract `Assert` and `Assume` methods might seem confusing at first,
    but both provide a specific function. Where the previous code contract conditions
    had to appear at the beginning of the methods they were defined in, the `Assert`
    method can be placed somewhere inside a method. This means that it will have an
    effect on the code at that specific time in the compilation. If you, for example,
    perform a calculation somewhere in your method under contract and you need to
    check the value calculated, you can use `Assert` to perform a check in place to
    ascertain whether the calculated value passes the contract.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't confuse `Debug.Assert` with `Contract.Assert`. They aren't the same thing.
    `Debug.Assert` will only have an effect if your code is run in the **Debug** mode.
    `Contract.Assert` will run in the **Debug** and **Release** modes.
  prefs: []
  type: TYPE_NORMAL
- en: With `Contract.Assume`, however, we are telling the code contract that it needs
    to assume that the condition it needs to check is true. This is only applicable
    when the static checker is switched on, and this will become clearer in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the same method under contract to illustrate the use of `Assert`
    and `Assume` methods with the static checker switched on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you go on, ensure that you have added the code contracts `using` statement
    to the top of your `Recipes.cs` class file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a method called `ValueIsValid()` to the class, which accepts two integer
    parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To this method, add a calculation (it appears first in the method before the
    contract) that subtracts `1` from the `valueForCalc` parameter. The `Contract.Assert`
    method is placed after the calculation to check the value of the calculated value.
    We want to ensure that the value is not zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the console application, add the relevant `using` statement to the `Program.cs`
    class to bring the static class into scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `ValueIsValid()` method by passing two integer values to it. As you
    can see, the first parameter will result in a zero value being calculated inside
    the method under contract:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run your console application and inspect the output window. We can see that
    the `Assert` contract correctly threw an exception because the calculated value
    was zero:![How to do it…](img/B05391_08_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, what if we want our code to be checked when we build our application?
    This is where the static checker comes into play. Right-click on the `Chapter8`
    project and select **Properties**:![How to do it…](img/B05391_08_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Code Contracts** tab and select the checkbox next to **Perform
    Static Contract Checking**. Also, uncheck the **Check in background** box and
    select **Fail build on warnings**. Moreover, set **Warning Level** to **hi**:![How
    to do it…](img/B05391_08_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We assume that the developers of Code Contracts meant to make the warning level
    between low and high. "Hi" is probably a typo in the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Save your code contract settings and run your console application. You will
    notice that your build fails:![How to do it…](img/B05391_08_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we have a look at the `ValueIsValid()` method, we can see that the static
    checker has identified that the method under contract needs an additional contract
    defined. The static checker has identified that we need to add `Contract.Requires`
    to our method to check whether the `valueForCalc` parameter is greater than zero:![How
    to do it…](img/B05391_08_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we had to correct this, we would add `Contract.Requires` to the method as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For now, let''s ignore the recommendation of the static checker and, instead,
    add `Contract.Assume` to our method. Here, we are telling the static checker to
    assume that the value will never be zero after the calculation is done on the
    `valueForCalc` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we run our console application again, we will get a clean build, because
    the static checker assumes that you know best and that the value will never equal
    zero after the calculation. If, however, the calculated value turns out to be
    zero, `Assume` still checks the value at runtime and will throw an exception if
    the value equals zero:![How to do it…](img/B05391_08_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be wondering what the use of `Assume` in code contracts is. As it
    turns out, this is quite useful when working with code that you have no control
    over. If you implement code that you can't edit or that does not contain code
    contracts, you can tell the static checker to ignore specific portions of the
    code that produce errors based on the check it does.
  prefs: []
  type: TYPE_NORMAL
- en: Creating code contract ForAll method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If this code contract sounds like it is validating some or the other collection,
    then you would be correct. The code contract `ForAll` will perform validation
    of `IEnumerable` collections. This is very handy, because as a developer, you
    do not need to do any kind of iteration over the collection and writing validation
    logic. This contract does it for you.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a simple list of integers and populate the list with values.
    Our code contract will validate that the list does not contain any zero values.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you go on, ensure that you have added the code contracts `using` statement
    to the top of your `Recipes.cs` class file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a method called `ValidateList()` to your class and pass a `List<int>` collection
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `ValidateList()` method, add the `Contract.ForAll` contract. Interestingly,
    you will notice that we are using `Contract.Assert` here to check whether this
    list passes our contract conditions. The `Contract.ForAll` will use a lambda expression
    to check that none of the values contained in our list of integers equals zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the console application, add the relevant `using` statement to the `Program.cs`
    class to bring the static class into scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then add a simple list of integers containing at least one zero value
    and pass it to the `ValidateList()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the console application and inspect the results in the output:![How to do
    it…](img/B05391_08_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can see that the `ForAll` contract has worked exactly as we had expected.
    This is an extremely useful code contract to use, especially since you need not
    add copious amounts of boilerplate code to check the collection for various invalid
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Creating code contract ValueAtReturn method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best example we can think of when using the code contract `ValueAtReturn`
    is `out` parameters. Personally, I do not use `out` parameters often, but there
    are times when you need to use them. Code contracts make provision for this, and
    you can check the value at the time it is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a simple method that subtracts a value from a parameter. The
    `out` parameter will be validated by the code contract, and the result will be
    output to the console window.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you go on, ensure that you have added the code contracts `using` statement
    to the top of your `Recipes.cs` class file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Recipes` class, create a new method called `ValidOutValue()` and pass
    an `out` parameter called `secureValue` to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add `Contract.ValueAtReturn` to the method. Interestingly, you will
    note that this needs to be contained in `Contract.Ensures`. This actually makes
    sense, because the code contract ensures that the value that we will return will
    adhere to a specific condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the console application, add the relevant `using` statement to the `Program.cs`
    class to bring the static class into scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add some code to call the `ValidOutValue()` method and pass an `out`
    parameter to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the console application and inspect the results in the output window:![How
    to do it…](img/B05391_08_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can see that the `out` parameter has been successfully validated. As soon
    as the condition was not met, the code contract threw an exception that we were
    able to catch.
  prefs: []
  type: TYPE_NORMAL
- en: Creating code contract Result method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we simply want a way to validate the result of a method. We want
    to be able to check what is returned and validate it against some or the other
    condition. It is here that the code contract `Result` can be used. It will inspect
    the value returned by the method under contract against the contract specified,
    and then it will succeed or fail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you go on, ensure that you have added the code contracts `using` statement
    to the top of your `Recipes.cs` class file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Recipes` class, add a new method called `ValidateResult()` that takes
    two integer values as parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To this method, add the code contract `Result` that checks the resultant value
    of the method. It has to be mentioned that the code contract `Result` can never
    be used in a `void` method. This is obvious, because the very purpose of this
    code contract is to examine and validate the result of a method. You will also
    notice that the code contract `Result` method is used in conjunction with the
    `Contract.Ensures` method. The format of `Contract.Result` is made up of the return
    type `<int>()` and the condition `>= 0` that the return value needs to adhere
    to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the console application, add the relevant `using` statement to the `Program.cs`
    class to bring the static class into scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the call to the static method under contract and pass to it parameters
    that will cause the code contract to throw an exception. In this case, we are
    passing `10` and `23`, which will result in a negative result being returned from
    the `ValidateResult()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, run the console application and inspect the result returned to the
    console output window:![How to do it…](img/B05391_08_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will see that the code contract has inspected the resultant value of the
    `ValidateResult()` method and found that it contravenes the contract. An exception
    is then thrown and displayed in the console window.
  prefs: []
  type: TYPE_NORMAL
- en: Using code contracts on abstract classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you use abstract classes in your code, you will know that being able to control
    how they are used with code contracts will result in more robust code. But how
    exactly can we use code contracts with abstract classes? Especially since abstract
    classes are supposed to contain no implementation? Well, it is definitely possible,
    and here is how we do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have not worked with abstract classes before, we advise you to first
    read [Chapter 2](ch02.html "Chapter 2. Classes and Generics"), *Classes and Generics*,
    to familiarise yourself with how abstract classes are used and created.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you go on, ensure that you have added the code contracts `using` statement
    to the top of your `Recipes.cs` class file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an abstract class called `Shape` that defines two methods called `Length()`
    and `Width()` which each take an integer value as a parameter. Remember that abstract
    classes contain no implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another abstract class called `ShapeContract` that inherits the `Shape`
    abstract class. It is here that our code contracts will reside:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `Length()` and `Width()` methods of the `Shape` abstract class
    and ensure that they require a non-zero parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to associate the `ShapeContract` contract class to the `Shape`
    abstract class. We will do this via the use of attributes. Add the following attribute
    to the top of your `Shape` abstract class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After doing this, your `Shape` abstract class will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to associate the `Shape` abstract class to the `ShapeContract`
    abstract class as a means of telling the compiler which class the contracts need
    to act upon. We will do this by adding the following attribute to the top of the
    `ShapeContract` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you have done this, your `ShapeContract` class will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now ready to implement the `Shape` abstract class. Create a new class
    called `Rectangle` and inherit the `Shape` abstract class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will notice that Visual Studio underlines the `Rectangle` class with a red
    squiggly line. This is because no implementation of the `Shape` class exists yet.
    Hover your mouse cursor over the red squiggly line and look at the lightbulb pop-up
    suggestion provided by Visual Studio:![How to do it…](img/B05391_08_28.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By holding down *Ctrl* + *.* (period), you will see the suggested fixes that
    you can implement to correct the error that Visual Studio is warning you about.
    In this instance, there is only a single fix that Visual Studio suggests we implement,
    which is to implement the abstract class:![How to do it…](img/B05391_08_29.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you have clicked on the **Implement Abstract Class** suggestion in the
    lightbulb suggestion, Visual Studio will insert the implementation of the `Shape`
    abstract class. You will notice that the methods inserted for you still don't
    contain any implementation and will throw `NotImplementedException` if you don't
    add any implementation to the `Length()` and `Width()` methods:![How to do it…](img/B05391_08_30.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To add implementation to our `Rectangle` class, create two properties for the
    `Length()` and `Width()` methods and set these properties equal to the value of
    the supplied parameter value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the console application, add the relevant `using` statement to the `Program.cs`
    class to bring the `Chapter8` class into scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new instance of the `Rectangle` class and pass some values to the
    `Length()` and `Width()` methods of the `Rectangle` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, run the console application and inspect the output window:![How to
    do it…](img/B05391_08_31.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have added a zero value to the `Length()` method, the code contract on
    the abstract class has correctly thrown an exception. Being able to implement
    code contracts on abstract classes allows developers to create better code, especially
    when working in teams where you need to convey implementation limitations based
    on certain business rules.
  prefs: []
  type: TYPE_NORMAL
- en: Using contract abbreviator methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abbreviator methods are a great addition to the features of code contracts.
    They allow us to create a single abbreviator method that contains often used or
    grouped code contracts. This means that we can simplify our code and make it more
    readable.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create two methods with the same code contract requirements. We will
    then simplify the methods under contract by implementing an abbreviator method
    to contain the code contracts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you go on, ensure that you have added the code contracts `using` statement
    to the top of your `Recipes.cs` class file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Consider the following methods before you add them. We have two methods here,
    and each method requires that the parameter passed to it is not equal to zero
    and that the result is also not zero. The implementation within each method is
    different, but the code contracts applied are identical. To avoid a situation
    where code contracts are unnecessarily repeated, we can use abbreviator methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new method called `StandardMethodContract()` to your `Recipes` class.
    This method''s name can be anything you like, but the signature needs to match
    the methods it abbreviates. Inside this method, add the required code contracts
    defined earlier in `MethodOne()` and `MethodTwo()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following attribute to the top of the `StandardMethodContract()` method
    to identify it as an abbreviator method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you have done this, your abbreviator method should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now go ahead and simplify `MethodOne()` and `MethodTwo()` by simply
    referencing the abbreviator method in place of the code contracts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the console application, add the relevant `using` statement to the `Program.cs`
    class to bring the static class into scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, call the two methods using the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you run your console application, you will notice that the code contract
    throws an exception in the abbreviator contract, telling us that the supplied
    parameter can't be zero:![How to do it…](img/B05391_08_32.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, modify your calling code and pass a valid value for `MethodOne()`, but
    leave the call to `MethodTwo()` as is. Run your console application again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This time, you will see that the code contract in the abbreviator method throws
    an exception on the return value that can't be zero:![How to do it…](img/B05391_08_33.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Abbreviator methods allow us to create more readable code and to group often
    used code contracts in a common method decorated with the `[ContractAbbreviator]`
    attribute. Abbreviator methods are a powerful feature of code contracts that developers
    can utilize to produce better code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating tests using IntelliTest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IntelliTest allows developers to create and run tests against their code contracts.
    This allows developers to create the most robust code possible by creating additional
    code contracts to pass the test failures reported by IntelliTest. One thing to
    note, however, is that IntelliTest is included in the Visual Studio Enterprise
    only.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to use Visual Studio Enterprise 2015 to be able to create and
    run IntelliTests.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you go on, ensure that you have added the code contracts `using` statement
    to the top of your `Recipes.cs` class file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new class called `CodeContractTests` to your `Recipes.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add a method called `Calculate()` to the `CodeContractTests` class and
    pass two integer values as parameters to the `Calculate()` method. Inside the
    `Calculate()` method, add a code contract to ensure that the result from this
    method is never equal to zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select the `Calculate()` method and right-click on it. From the context menu,
    click on the **Create IntelliTest** menu item:![How to do it…](img/B05391_08_34.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio will then show the **Create IntelliTest** window. Here, you can
    define several settings for your IntelliTest. One thing to note is that you can
    use a different test framework than **MSTest**. For our purposes, however, we
    will use **MSTest** and keep the rest of the settings set to their defaults:![How
    to do it…](img/B05391_08_35.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you click on the **OK** button, Visual Studio will continue to create a
    new test project for you:![How to do it…](img/B05391_08_36.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the project creation is complete, you will see the new test project created
    in the **Solution Explorer**. In this case, because we kept the default settings
    in the **Create IntelliTest** window, our new test project will be called `Chapter8.Tests`:![How
    to do it…](img/B05391_08_37.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go ahead and expand the `Chapter8.Tests` project and then click on the `CodeContractTestsTest.cs`
    file created for you. You will see the following code created for you by Visual
    Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Back in the `CodeContractTests` class, right-click on the `Calculate()` method
    and select **Run IntelliTest** from the context menu:![How to do it…](img/B05391_08_38.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IntelliTest will jump into action and open the **IntelliTest Exploration Results**
    window:![How to do it…](img/B05391_08_39.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the test results we ran for the `Calculate()` method, we can see that we
    have three failed tests and one successful test. The test failures reported are
    `DivideByZeroException`, `ContractException`, and `OverflowException`. Clicking
    on individual test failures allows you to view the test details as well as the
    **Stack trace**:![How to do it…](img/B05391_08_40.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s modify the `Calculate()` method by adding the following additional code
    contracts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the additional code contracts, we can see that by requiring the `valueTwo`
    parameter to be greater than zero, we have resolved the `DivideByZeroException`.
    We can also see that the code contract that requires `valueOne` is always greater
    than `valueTwo`. Thus, we have resolved the `ContractException`. Finally, by requiring
    that both parameters be greater than zero, we have automatically resolved the
    `OverflowException`:![How to do it…](img/B05391_08_41.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `Calculate()` method and run the IntelliTest again. This
    time, you will see that all the tests have passed, and our method under contract
    is now ready for use in production code:![How to do it…](img/B05391_08_42.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IntelliTest allows developers to quickly and efficiently create tests for your
    code contracts with a few clicks of your mouse.
  prefs: []
  type: TYPE_NORMAL
- en: Using code contracts in extension methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipes illustrated how a developer might create various code contracts
    to secure your code from unexpected input and output, but let's look at how a
    developer could leverage code contracts. The idea of extension methods come to
    mind, where we create code that can be used throughout your project to perform
    actions that are often used.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the code contract `ForAll` method. This has an impact on a collection,
    so naturally, its use in extension methods leads us to a possible implementation.
    In this recipe, we will create an extension method that uses a code contract to
    validate the list we have just created.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a static class for our extension method and then use the `ForAll`
    code contract to validate the `List` collection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you go on, ensure that you have added the code contracts `using` statement
    to the top of your `Recipes.cs` class file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new static class called `ExtensionMethods` and add it to your `Recipes.cs`
    class file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add an extension method called `ContainsInvalidValue()` that takes the
    given list of anonymous type `T` and an invalid value to check as type `T` as
    parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside our extension method, add code contract `ForAll` wrapped in a `try`
    `catch` statement that checks the existence of the given parameter in the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you have added all the code to your extension method, it should look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the console application, add the relevant `using` statement to the `Program.cs`
    class to bring the `Chapter8` class into scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we did earlier, create a simple list, but this time, call the extension
    method that is exposed via the static extension methods class on the list. We
    will now be able to directly validate our list via the use of extension methods
    and code contracts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running the application will result in the following output:![How to do it…](img/B05391_08_43.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we are using an anonymous type here, we can easily call this extension method
    on lists containing different types. Here is an example of an implementation on
    a list of strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running the application again will result in the following output:![How to do
    it…](img/B05391_08_44.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can see that using code contracts along with other powerful features of C#
    allows us to utilize very powerful code checking and validation techniques. The
    extension methods can be used throughout your project to perform frequent validation
    or other code logic specific to your project.
  prefs: []
  type: TYPE_NORMAL
