<html><head></head><body>
		<div id="_idContainer086">
			<h1 id="_idParaDest-175" class="chapter-number"><a id="_idTextAnchor197"/>8</h1>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor198"/>Adding Windows Notifications to WinUI Applications</h1>
			<p>The Windows App SDK provides<a id="_idIndexMarker602"/> developers with the ability to implement <strong class="bold">raw push notifications</strong> and <strong class="bold">app notifications</strong> in their WinUI apps. It’s important<a id="_idIndexMarker603"/> to understand the use case for each of these notification types. They have different implementations, and each has its own set of advantages and limitations. Push notifications<a id="_idIndexMarker604"/> can be surfaced to the user or received by the app to perform internal operations. App notifications, on the other hand, are used to communicate with the user. We’ll cover examples of when you would want to use a particular notification type and add an app notification to the <strong class="bold">My Media Collection</strong> <span class="No-Break">sample application.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Understanding the different notification types in the Windows App SDK and the use case for <span class="No-Break">each type</span></li>
				<li>Discovering how to leverage push notifications in a <span class="No-Break">WinUI application</span></li>
				<li>Exploring how to use app notifications <span class="No-Break">with WinUI</span></li>
			</ul>
			<p>By the end of this chapter, you will understand the differences between push notifications and other app notifications exposed by the Windows App SDK. You will understand when to choose each notification type and how they are handled in a WinUI <span class="No-Break">3 projec<a id="_idTextAnchor199"/>t.</span></p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor200"/>Technical requirements</h1>
			<p>To follow along with the examples in this chapter, the following software <span class="No-Break">is required:</span></p>
			<ul>
				<li>Windows 10 version 1809 (build 17763) <span class="No-Break">or newer</span></li>
				<li>Visual Studio 2022 or later with the .NET Desktop Development workload configured for Windows App <span class="No-Break">SDK development</span></li>
			</ul>
			<p>The source code for this chapter is available on GitHub at this <span class="No-Break">URL: </span><a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter08"><span class="No-Break">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter08</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor201"/>Overview of push notifications in the Windows App SDK</h1>
			<p>WinUI applications can leverage different<a id="_idIndexMarker605"/> types of notifications in the Windows App SDK. The notifications APIs were added in Windows App SDK 1.3 and can be either sent locally or through a cloud service, depending on the notification type. We most often associate notifications<a id="_idIndexMarker606"/> with the small, pop-up windows in the corner of the screen, called <strong class="bold">toast notifications</strong>, in Windows. However, a visual indicator isn’t required for all notifications. They can also be used to signal your app to activate and perform an action or sync data from a remote service without relying on a timer in <span class="No-Break">the app.</span></p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor202"/>Raw push notifications</h2>
			<p>These internal<a id="_idIndexMarker607"/> notifications are known as <strong class="bold">raw push notifications</strong>. They require no<a id="_idIndexMarker608"/> user interaction<a id="_idIndexMarker609"/> and don’t signal the user with a <strong class="bold">toast notification</strong>. Push notifications leverage the <strong class="bold">Windows Push Notification Services</strong> (<strong class="bold">WNS</strong>), which is part of the <strong class="bold">Microsoft Store</strong> services. To publish an application <a id="_idIndexMarker610"/>in the Store or leverage<a id="_idIndexMarker611"/> any of its services, a Store account is required, and your app must be registered in the <span class="No-Break">Store’s dashboard.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">We will discuss publishing apps to the Microsoft Store in <a href="B20908_14.xhtml#_idTextAnchor582"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, <em class="italic">Packaging and Deploying WinUI Applications</em>. We won’t cover the Store registration process in this chapter, but you can skip ahead to review the process in <a href="B20908_14.xhtml#_idTextAnchor582"><span class="No-Break"><em class="italic">Chapter 14</em></span></a> if it’s new <span class="No-Break">to you.</span></p>
			<p>Push notifications from WNS can be received directly by the app to signal the app to perform some action. In fact, your app doesn’t need to be active to receive a notification. Windows will activate the app so it can process the notification and perform the requested action. Using notifications saves device resources and can reduce or eliminate the need for polling <span class="No-Break">and timers.</span></p>
			<p>Notifications<a id="_idIndexMarker612"/> from WNS may<a id="_idIndexMarker613"/> also notify the user. This is one type of <span class="No-Break">app notification.</span></p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor203"/>Cloud-based app notifications</h2>
			<p>App notifications involve notifying<a id="_idIndexMarker614"/> the user that some event has occurred or action<a id="_idIndexMarker615"/> is required. App notifications can be local or originate from the cloud. The cloud-based notifications, like raw notifications, <span class="No-Break">leverage WNS.</span></p>
			<p>The process for creating and sending these app notifications is similar to creating raw push notifications. The header and content types will distinguish the app notifications and signal Windows to display a visible, transient notification. Any notifications that haven’t been dismissed or cleared by the user can be viewed in Windows settings in <span class="No-Break"><strong class="bold">Notification Center</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Certain types of self-contained apps or apps running with admin privileges may not be eligible to receive notifications. To view more information about these limitations, you can review this section of the push notifications<a id="_idIndexMarker616"/> documentation on Microsoft <span class="No-Break">Learn: </span><a href="https://learn.microsoft.com/windows/apps/windows-app-sdk/notifications/push-notifications/#limitations"><span class="No-Break">https://learn.microsoft.com/windows/apps/windows-app-sdk/notifications/push-notifications/#limitations</span></a><span class="No-Break">.</span></p>
			<p>App notifications can also be local to the user’s PC. Let’s discuss this type of <span class="No-Break">notification next.</span></p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor204"/>Local app notifications</h2>
			<p>Local app notifications <a id="_idIndexMarker617"/>do not involve the cloud and WNS is not involved in sending<a id="_idIndexMarker618"/> the notification. They originate from your app, are displayed to the user, and are handled by your app when the user acts on the toast notification. Users are familiar with these types of notifications from using Microsoft apps such as Outlook, Teams, and even the Microsoft <span class="No-Break">Store app.</span></p>
			<p>Sometimes, these notifications are informational, such as when the Store app displays a message after an app has been updated. The notifications can also prompt the user to take an action, such as snoozing an Outlook calendar reminder. In this case, the notification window contains a drop-down control that allows the user to select the <span class="No-Break">snooze duration.</span></p>
			<p>Later in this chapter, we’ll add a local app<a id="_idIndexMarker619"/> notification to the <strong class="bold">My Media Collection</strong> app to prompt<a id="_idIndexMarker620"/> our users to add a new book to their collection. Now, we’ll dive a little deeper into the implementation of raw push notifications and how they can be used to quietly receive a notification from <span class="No-Break">the cloud.</span></p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor205"/>Using raw push notifications in WinUI applications</h1>
			<p>As we discussed in the previous section, push notifications<a id="_idIndexMarker621"/> that are handled by the app<a id="_idIndexMarker622"/> without notifying the user are generated through WNS and Azure. In this section, we will briefly examine how these notifications can be leveraged in WinUI applications. The Azure configuration needed to get started is somewhat lengthy and not very interesting. Because the Azure Notification Hubs configuration for WNS<a id="_idIndexMarker623"/> is already well documented in the Azure docs on Microsoft Learn, you should review them before we get started: <a href="https://learn.microsoft.com/azure/notification-hubs/notification-hubs-windows-store-dotnet-get-started-wns-push-notification">https://learn.microsoft.com/azure/notification-hubs/notification-hubs-windows-store-dotnet-get-started-wns-push-notification</a>. It’s also a good idea to familiarize yourself with the WNS overview<a id="_idIndexMarker624"/> in the Windows design documentation on Microsoft <span class="No-Break">Learn: </span><a href="https://learn.microsoft.com/windows/apps/design/shell/tiles-and-notifications/windows-push-notification-services--wns--overview"><span class="No-Break">https://learn.microsoft.com/windows/apps/design/shell/tiles-and-notifications/windows-push-notification-services--wns--overview</span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Azure documentation was written for UWP apps, but the configuration instructions work just as well for a WinUI <span class="No-Break">3 application.</span></p>
			<p>Once the Azure configuration is complete, the steps to use notifications in a WinUI 3 app are similar to UWP but not exactly the same. For a detailed example of working with push notifications from the cloud, you can read this Microsoft Learn article: <a href="https://learn.microsoft.com/windows/apps/windows-app-sdk/notifications/push-notifications/push-quickstart">https://learn.microsoft.com/windows/apps/windows-app-sdk/notifications/push-notifications/push-quickstart</a>. In this chapter, we are focusing on app notifications, and will add those to our sample<a id="_idIndexMarker625"/> app in the next section. The high-level steps you will need to complete are <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Add the COM<a id="_idIndexMarker626"/> activation information<a id="_idIndexMarker627"/> to your <strong class="source-inline">Package.appxmanifest</strong> file. Here’s <span class="No-Break">an example:</span><pre class="source-code">
&lt;Extensions&gt;
  &lt;!--Register COM activator--&gt;
  &lt;com:Extension Category="windows.comServer"&gt;
    &lt;com:ComServer&gt;
      &lt;com:ExeServer Executable="MyApp\MyApp.exe" DisplayName="My App" Arguments="----WindowsAppRuntimePushServer:"&gt;
        &lt;com:Class Id="[Azure AppId for App]" DisplayName="WinUI Push Notify" /&gt;
      &lt;/com:ExeServer&gt;
    &lt;/com:ComServer&gt;
  &lt;/com:Extension&gt;
&lt;/Extensions&gt;</pre></li>				<li>Register with <strong class="source-inline">PushNotificationManager</strong> in <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">Microsoft.Windows.Push</strong></span><strong class="source-inline"> Notifications</strong> namespace and subscribe to <strong class="source-inline">PushNotificationChannel</strong> for the <span class="No-Break">notification type.</span></li>
				<li>Add code to the <strong class="source-inline">App</strong> class to check whether the application was launched or activated from the background as a result of a <span class="No-Break">push notification.</span></li>
				<li>Create a WNS channel and register that channel with the WNS service. These are the HTTP endpoints that will receive the notification data to be pushed to <span class="No-Break">your app.</span></li>
				<li>Use a tool such as <strong class="bold">Postman</strong> (<a href="https://postman.com/">https://postman.com/</a>) to send an HTTP <strong class="source-inline">POST</strong> request<a id="_idIndexMarker628"/> with the push notification<a id="_idIndexMarker629"/> data. You will need to get an access token<a id="_idIndexMarker630"/> for the request with your Azure tenant ID, app ID, and client secret. For more information, see this <span class="No-Break">page: </span><a href="https://learn.microsoft.com/azure/active-directory/develop/howto-create-service-principal-portal#get-tenant-and-app-id-values-for-signing-in"><span class="No-Break">https://learn.microsoft.com/azure/active-directory/develop/howto-create-service-principal-portal#get-tenant-and-app-id-values-for-signing-in</span></a><span class="No-Break">.</span></li>
			</ol>
			<p>Those are the basic steps, but there’s much more to be learned. Make sure you read all of the articles linked in this section<a id="_idIndexMarker631"/> to learn about the nuances<a id="_idIndexMarker632"/> of using raw push notifications in a <span class="No-Break">WinUI application.</span></p>
			<p>Now, let’s learn more about app notifications and adding send-and-receive capabilities to our <span class="No-Break">sample application.</span></p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor206"/>Adding Windows app notifications with the Windows App SDK</h1>
			<p>In this section, we’re going<a id="_idIndexMarker633"/> to add some local app notifications to the <strong class="bold">My Media Collection</strong> project. The code we’ll add to the project is based on the Windows App SDK local app notification sample app created by the Microsoft Learn team. You can download the code for that project on <span class="No-Break">GitHub: </span><a href="https://github.com/microsoft/WindowsAppSDK-Samples/tree/main/Samples/Notifications/App/CsUnpackagedAppNotifications"><span class="No-Break">https://github.com/microsoft/WindowsAppSDK-Samples/tree/main/Samples/Notifications/App/CsUnpackagedAppNotifications</span></a><span class="No-Break">.</span></p>
			<p>We are adding two buttons to the MainPage in the app to trigger two types of notifications. One will have an image and some text. The second will add a text entry field to demonstrate how we can receive input from a user in the notification toast and act on it within <span class="No-Break">our application.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">There is a lot of configuration and code required to implement notification handling. If you would like to open the completed solution and follow along, the code is available on <span class="No-Break">GitHub: </span><a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter08/Complete"><span class="No-Break">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter08/Complete</span></a><span class="No-Break">.</span></p>
			<p>To get started, open your <strong class="bold">MyMediaCollection</strong> solution from the previous chapter or the starter solution for <a href="B20908_08.xhtml#_idTextAnchor197"><span class="No-Break"><em class="italic">Chapter 8</em></span></a> on <span class="No-Break">GitHub: </span><a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter08/Start"><span class="No-Break">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter08/Start</span></a><span class="No-Break">:</span></p>
			<ol>
				<li>The first step is to add<a id="_idIndexMarker634"/> some configuration to the <strong class="source-inline">Package.appxmanifest</strong> file to enable notification handling in the app. Start by adding two namespace declarations to the <span class="No-Break"><strong class="source-inline">Package</strong></span><span class="No-Break"> element:</span><pre class="source-code">
xmlns:com="http://schemas.microsoft.com/appx/manifest/com/windows10"
xmlns:desktop="http://schemas.microsoft.com/appx/manifest/desktop/windows10"</pre></li>				<li>Next, add an <strong class="source-inline">Extensions</strong> section inside the <strong class="source-inline">Application</strong> node, immediately after the <span class="No-Break"><strong class="source-inline">uap:VisualElements</strong></span><span class="No-Break"> section:</span><pre class="source-code">
&lt;Extensions&gt;
  &lt;desktop:Extension Category="windows.toastNotificationActivation"&gt;
    &lt;desktop:ToastNotificationActivation ToastActivatorCLSID=<strong class="bold">"NEW GUID HERE"</strong> /&gt;
  &lt;/desktop:Extension&gt;
  &lt;com:Extension Category="windows.comServer"&gt;
    &lt;com:ComServer&gt;
      &lt;com:ExeServer Executable="MyMediaCollection\MyMediaCollection.exe" DisplayName="My Media Collection" Arguments="----AppNotificationActivated:"&gt;
        &lt;com:Class Id=<strong class="bold">"SAME NEW GUID HERE"</strong> /&gt;
      &lt;/com:ExeServer&gt;
    &lt;/com:ComServer&gt;
  &lt;/com:Extension&gt;
&lt;/Extensions&gt;</pre><p class="list-inset">Generate a new <strong class="bold">GUID</strong> and replace the two preceding<a id="_idIndexMarker635"/> highlighted sections of code with that GUID. It will be unique to your app. You can generate GUIDs in Visual Studio in the menu with <strong class="bold">Tools</strong> | <span class="No-Break"><strong class="bold">Create GUID</strong></span><span class="No-Break">.</span></p></li>				<li>Next, we’re going<a id="_idIndexMarker636"/> to create some shared code and helper classes. Your project is not going to compile without errors until we’re finished with this section. First, create a new folder in your solution <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">Helpers</strong></span><span class="No-Break">.</span></li>
				<li>Now create a new class named <strong class="source-inline">NotificationShared</strong> in the <strong class="source-inline">Helpers</strong> folder. Start by adding a constant and a struct to <span class="No-Break">this class:</span><pre class="source-code">
public const string scenarioTag = "scenarioId";
public struct Notification
{
    public string Originator;
    public string Action;
    public bool HasInput;
    public string Input;
};</pre><p class="list-inset">The <strong class="source-inline">Notification</strong> struct will represent the data received in an app notification. <strong class="source-inline">scenarioTag</strong> is a constant that will be needed when each notification to send is <span class="No-Break">being constructed.</span></p></li>				<li>Next, add the following static methods to the <strong class="source-inline">NotificationShared</strong> class. These will be used<a id="_idIndexMarker637"/> by the app to notify the UI when notifications are sent <span class="No-Break">or received:</span><pre class="source-code">
public static void CouldNotSendToast()
{
    MainPage.Current.NotifyUser("Could not send toast", InfoBarSeverity.Error);
}
public static void ToastSentSuccessfully()
{
    MainPage.Current.NotifyUser("Toast sent successfully!", InfoBarSeverity.Success);
}
public static void AppLaunchedFromNotification()
{
    MainPage.Current.NotifyUser("App launched from notifications", InfoBarSeverity.Informational);
}
public static void NotificationReceived()
{
    MainPage.Current.NotifyUser("Notification received", InfoBarSeverity.Informational);
}
public static void UnrecognizedToastOriginator()
{
    MainPage.Current.NotifyUser("Unrecognized Toast Originator or Unknown Error", InfoBarSeverity.Error);
}</pre><p class="list-inset"><strong class="source-inline">MainPage</strong> doesn’t have a <strong class="source-inline">Current</strong> property, so this code won’t compile yet. We’ll take care<a id="_idIndexMarker638"/> of that soon. If Visual Studio didn’t add the necessary <strong class="source-inline">using</strong> statements, make sure these are present <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">NotificationShared</strong></span><span class="No-Break">:</span></p><pre class="source-code">using Microsoft.UI.Xaml.Controls;
using MyMediaCollection.Views;</pre></li>				<li>Now we are going to create two classes to represent the two types of notifications that the app will send and receive. First, create a new class named <strong class="source-inline">ToastWithAvatar</strong> and start by adding two constants to <span class="No-Break">the class:</span><pre class="source-code">
using Microsoft.Windows.AppNotifications.Builder;
using Microsoft.Windows.AppNotifications;
using MyMediaCollection.Views;
namespace MyMediaCollection.Helpers
{
    public class ToastWithAvatar
    {
        public const int ScenarioId = 1;
        public const string ScenarioName = "Local Toast with Image";
    }
}</pre></li>				<li>Next, add a method named <strong class="source-inline">SendToast</strong> to the class. This method will construct and show a Windows notification toast containing some text, an avatar image, and a button to display <span class="No-Break">our app:</span><pre class="source-code">
public static bool SendToast()
{
    var appNotification = new AppNotificationBuilder()
        .AddArgument("action", "ToastClick")
        .AddArgument(NotificationShared.scenarioTag, ScenarioId.ToString())
        .SetAppLogoOverride(new System.Uri($"file://{App.GetFullPathToAsset(" Square150x150Logo.scale-200.png")}"), AppNotificationImageCrop.Circle)
        .AddText(ScenarioName)
        .AddText("This is a notification message.")
        .AddButton(new AppNotificationButton("Open App")
            .AddArgument("action", "OpenApp")
            .AddArgument(NotificationShared.scenarioTag, ScenarioId.ToString()))
        .BuildNotification();
    AppNotificationManager.Default.Show(appNotification);
    // If notification is sent, it will have an Id. Success.
    return appNotification.Id != 0;
}</pre></li>				<li>Now add a <strong class="source-inline">NotificationReceived</strong> method, which will be invoked when this type of notification<a id="_idIndexMarker639"/> is received from Windows by our app. This method creates a <strong class="source-inline">Notification</strong> struct and calls a <strong class="source-inline">NotificationReceived</strong> method on <strong class="source-inline">MainPage</strong>, which we will create later in this section. We will also create the <strong class="source-inline">ToForeground</strong> method to bring our app to the front if it’s hidden behind other windows <span class="No-Break">or minimized:</span><pre class="source-code">
public static void NotificationReceived(AppNotificationActivatedEventArgs notificationActivatedEventArgs)
{
    var notification = new NotificationShared.Notification
    {
        Originator = ScenarioName,
        Action = notificationActivatedEventArgs.Arguments["action"]
    };
    MainPage.Current.NotificationReceived(notification);
    App.ToForeground();
}</pre></li>				<li>The <strong class="source-inline">ToastWithText</strong> class will be similar to <strong class="source-inline">ToastWithAvatar</strong>, but it will add a call to <strong class="source-inline">AddTextBox</strong> in <strong class="source-inline">AppNotificationBuilder</strong> to create the input field in the Windows<a id="_idIndexMarker640"/> toast. It also adds the result of that user input to the <strong class="source-inline">Notification</strong> class created in <strong class="source-inline">NotificationReceived</strong>. To view the full code for this class, check out the completed solution on <span class="No-Break">GitHub: </span><a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter08/Complete/MyMediaCollection/Helpers/ToastWithText.cs"><span class="No-Break">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter08/Complete/MyMediaCollection/Helpers/ToastWithText.cs</span></a><span class="No-Break">.</span></li>
				<li>Now it’s time to create the <strong class="source-inline">NotificationManager</strong> class. This class will do exactly that – manage notifications. It will initialize and unregister notification receiving. It will do the actual sending and receiving of notifications. Create the <strong class="source-inline">NotificationManager</strong> class in the <strong class="source-inline">Helpers</strong> folder and start by adding the constructor and <span class="No-Break">finalization code:</span><pre class="source-code">
using Microsoft.Windows.AppNotifications;
using System;
using System.Collections.Generic;
namespace MyMediaCollection.Helpers
{
    internal class NotificationManager
    {
        private bool isRegistered;
        private Dictionary&lt;int, Action&lt;AppNotificationActivatedEventArgs&gt;&gt; notificationHandlers;
        public NotificationManager()
        {
            isRegistered = false;
            notificationHandlers = new Dictionary&lt;int, Action&lt;AppNotificationActivatedEventArgs&gt;&gt;
            {
                { ToastWithAvatar.ScenarioId, ToastWithAvatar.NotificationReceived },
                { ToastWithText.ScenarioId, ToastWithText.NotificationReceived }
            };
        }
        ~NotificationManager()
        {
            Unregister();
        }
        public void Unregister()
        {
            if (isRegistered)
            {
                AppNotificationManager.Default.Unregister();
                isRegistered = false;
            }
        }
    }
}</pre></li>				<li>Next, add the <strong class="source-inline">Init</strong> method<a id="_idIndexMarker641"/> that we’ll call from the <span class="No-Break"><strong class="source-inline">App</strong></span><span class="No-Break"> class:</span><pre class="source-code">
public void Init()
{
    AppNotificationManager notificationManager = AppNotificationManager.Default;
    // Add handler before calling Register.
    notificationManager.NotificationInvoked += OnNotificationInvoked;
    notificationManager.Register();
    isRegistered = true;
}</pre></li>				<li><strong class="source-inline">OnNotificationInvoked</strong> is hooked up in the <strong class="source-inline">Init</strong> method. This will fire when notifications are received by the app. It makes different calls to <strong class="source-inline">NotificationShared</strong>, depending on whether the notification is recognized <span class="No-Break">or not:</span><pre class="source-code">
public void OnNotificationInvoked(object sender, AppNotificationActivatedEventArgs notificationActivatedEventArgs)
{
    NotificationShared.NotificationReceived();
    if (!DispatchNotification(notificationActivatedEventArgs))
    {
        NotificationShared.UnrecognizedToastOriginator();
    }
}</pre></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">If you have any unhandled exceptions in your code that process incoming notifications, they will also trigger this call <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">NotificationShared.UnrecognizedToastOriginator</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="13">Finally, create<a id="_idIndexMarker642"/> the <strong class="source-inline">ProcessLaunchActivationArgs</strong> and <strong class="source-inline">DispatchNotification</strong> methods <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">NotificationManager</strong></span><span class="No-Break">:</span><pre class="source-code">
public void ProcessLaunchActivationArgs(AppNotificationActivatedEventArgs notificationActivatedEventArgs)
{
    DispatchNotification(notificationActivatedEventArgs);
    NotificationShared.AppLaunchedFromNotification();
}
private bool DispatchNotification(AppNotificationActivatedEventArgs notificationActivatedEventArgs)
{
    var scenarioId = notificationActivatedEventArgs.Arguments[NotificationShared.scenarioTag];
    if (scenarioId.Length != 0)
    {
        try
        {
            notificationHandlers[int.Parse(scenarioId)](notificationActivatedEventArgs);
            return true;
        }
        catch
        {
            // No matching handler
            return false;
        }
    }
    else
    {
        // No scenarioId provided
        return false;
    }
}</pre></li>				<li>Now let’s add the code to <strong class="source-inline">App.xaml.cs</strong> to initialize <strong class="source-inline">NotificationManager</strong> and handle some<a id="_idIndexMarker643"/> of the common calls. Let’s start by adding the <strong class="source-inline">using</strong> statements that we’ll need for the <span class="No-Break">new code:</span><pre class="source-code">
using Microsoft.Windows.AppLifecycle;
using Microsoft.Windows.AppNotifications;
using MyMediaCollection.Helpers;
using System.Runtime.InteropServices;
using WinRT.Interop;</pre></li>				<li>Next, add a private <strong class="source-inline">notificationManager</strong> object, add <strong class="source-inline">DllImport</strong> to help bring the window to the foreground, and make <span class="No-Break"><strong class="source-inline">m_window</strong></span><span class="No-Break"> static:</span><pre class="source-code">
[DllImport("user32.dll", SetLastError = true)]
static extern void SwitchToThisWindow(IntPtr hWnd, bool turnOn);
private NotificationManager notificationManager;
private <strong class="bold">static</strong> Window m_window;</pre></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">Be careful when choosing which Win32 APIs to use in your production WinUI applications. The <strong class="source-inline">SwitchToThisWindow</strong> API is documented as “<em class="italic">not suitable for general use</em>,” but it works for our purposes<a id="_idIndexMarker644"/> in a sample app. There are other APIs you can explore, including <span class="No-Break"><strong class="source-inline">ShowWindow</strong></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-showwindow"><span class="No-Break">https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-showwindow</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="16">Next, add the following code to <strong class="source-inline">OnLaunched</strong> right before calling <strong class="source-inline">m_window.Activate</strong>. This gets the arguments<a id="_idIndexMarker645"/> passed to the app from the <span class="No-Break">Windows notification:</span><pre class="source-code">
var currentInstance = AppInstance.GetCurrent();
if (currentInstance.IsCurrent)
{
    AppActivationArguments activationArgs = currentInstance.GetActivatedEventArgs();
    if (activationArgs != null)
    {
        ExtendedActivationKind extendedKind = activationArgs.Kind;
        if (extendedKind == ExtendedActivationKind.AppNotification)
        {
            var notificationActivatedEventArgs = (AppNotificationActivatedEventArgs)activationArgs.Data;
            notificationManager.ProcessLaunchActivationArgs(notificationActivatedEventArgs);
        }
    }
}</pre></li>				<li>Next, add some code to the <strong class="source-inline">App</strong> constructor to initialize <strong class="source-inline">NotificationManager</strong> and handle the <strong class="source-inline">AppDomain.CurrentDomain.ProcessExit</strong> event to unregister the manager when the <span class="No-Break">app closes:</span><pre class="source-code">
public App()
{
    this.InitializeComponent();
<strong class="bold">    notificationManager = new NotificationManager();</strong>
<strong class="bold">    notificationManager.Init();</strong>
<strong class="bold">    AppDomain.CurrentDomain.ProcessExit += CurrentDomain_ProcessExit;</strong>
}
private void CurrentDomain_ProcessExit(object sender, EventArgs e)
{
    notificationManager.Unregister();
}</pre></li>				<li>The final items to be added to the <strong class="source-inline">App</strong> class are three static helper methods to get some application-related paths<a id="_idIndexMarker646"/> and the <strong class="source-inline">ToForeground</strong> method to bring the app to the front when it’s hidden <span class="No-Break">or minimized:</span><pre class="source-code">
public static void ToForeground()
{
    if (m_window != null)
    {
        IntPtr handle = WindowNative.GetWindowHandle(m_window);
        if (handle != IntPtr.Zero)
        {
            SwitchToThisWindow(handle, true);
        }
    }
}
public static string GetFullPathToExe()
{
    var path = AppDomain.CurrentDomain.BaseDirectory;
    var pos = path.LastIndexOf("\\");
    return path.Substring(0, pos);
}
public static string GetFullPathToAsset(string assetName)
{
    return $"{GetFullPathToExe()}\\Assets\\{assetName}";
}</pre></li>				<li>Now let’s work on <strong class="source-inline">MainPage</strong>. Start in <strong class="source-inline">MainPage.xaml</strong>. We’re going to add two buttons to send notifications<a id="_idIndexMarker647"/> and an <strong class="source-inline">InfoBar</strong> control to display messages at the bottom of the page when notifications are sent or received. Add another <strong class="source-inline">RowDefinition</strong> to the outermost <span class="No-Break"><strong class="source-inline">Grid</strong></span><span class="No-Break"> control:</span><pre class="source-code">
&lt;Grid.RowDefinitions&gt;
    &lt;RowDefinition Height="Auto"/&gt;
    &lt;RowDefinition Height="*"/&gt;
    &lt;RowDefinition Height="Auto"/&gt;
<strong class="bold">    &lt;RowDefinition Height="Auto"/&gt;</strong>
&lt;/Grid.RowDefinitions&gt;</pre></li>				<li>Add two buttons to the beginning of <strong class="source-inline">StackPanel</strong> that contains the existing <span class="No-Break"><strong class="source-inline">Button</strong></span><span class="No-Break"> controls:</span><pre class="source-code">
&lt;StackPanel HorizontalAlignment="Right"
            Orientation="Horizontal"&gt;
    <strong class="bold">&lt;Button Command="{x:Bind ViewModel.SendToastCommand}"</strong>
<strong class="bold">            Content="Send Notification"</strong>
<strong class="bold">            Margin="8,8,0,8"/&gt;</strong>
<strong class="bold">    &lt;Button Command="{x:Bind ViewModel.SendToastWithTextCommand}"</strong>
<strong class="bold">            Content="Send Notification with Text"</strong>
<strong class="bold">            Margin="8,8,0,8"/&gt;</strong>
<strong class="bold">...</strong>
&lt;/StackPanel&gt;</pre></li>				<li>Add an <strong class="source-inline">InfoBar</strong> control just before the closing tag for the <span class="No-Break">outer </span><span class="No-Break"><strong class="source-inline">Grid</strong></span><span class="No-Break">:</span><pre class="source-code">
&lt;InfoBar x:Name="notifyInfoBar" Grid.Row="3"/&gt;</pre></li>				<li>Next, open the <strong class="source-inline">MainPage.xaml.cs</strong> file, in which we need<a id="_idIndexMarker648"/> to add some code to handle the incoming notifications. The first thing we’ll do is add a <strong class="source-inline">using</strong> statement <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">MyMediaCollection.Helpers</strong></span><span class="No-Break">.</span></li>
				<li>Next, add the code to expose the current instance of <strong class="source-inline">MainPage</strong> so the notifications can be <span class="No-Break">routed properly:</span><pre class="source-code">
<strong class="bold">public static MainPage Current;</strong>
public MainPage()
{
    ViewModel = App.HostContainer.Services.GetService&lt;MainViewModel&gt;();
    this.InitializeComponent();
<strong class="bold">    Current = this;</strong>
    Loaded += MainPage_Loaded;
}</pre></li>				<li>Next, add some code to update <strong class="source-inline">InfoBar</strong> whenever notifications<a id="_idIndexMarker649"/> are sent or received. This is the code that will be called by the methods in the <span class="No-Break"><strong class="source-inline">NotificationShared</strong></span><span class="No-Break"> class:</span><pre class="source-code">
public void NotifyUser(string message, InfoBarSeverity severity, bool isOpen = true)
{
    if (DispatcherQueue.HasThreadAccess)
    {
        UpdateStatus(message, severity, isOpen);
    }
    else
    {
        DispatcherQueue.TryEnqueue(() =&gt;
        {
            UpdateStatus(message, severity, isOpen);
        });
    }
}
private void UpdateStatus(string message, InfoBarSeverity severity, bool isOpen)
{
    notifyInfoBar.Message = message;
    notifyInfoBar.IsOpen = isOpen;
    notifyInfoBar.Severity = severity;
}</pre><p class="list-inset">The <strong class="source-inline">DispatcherQueue</strong> methods check whether the code has access to the UI thread. If not, <strong class="source-inline">TryEnqueue</strong> is used to queue the work to be performed when the UI thread is available. Otherwise, errors will be encountered when accessing UI elements from a <span class="No-Break">background thread.</span></p></li>				<li>Create a <strong class="source-inline">NotificationReceived</strong> method to handle incoming<a id="_idIndexMarker650"/> notification information. This method parses through the incoming data and builds a message string <span class="No-Break">to display:</span><pre class="source-code">
public void NotificationReceived(NotificationShared.Notification notification)
{
    var text = $"{notification.Originator}; Action: {notification.Action}";
    if (notification.HasInput)
    {
        if (string.IsNullOrWhiteSpace(notification.Input))
            text += "; No input received";
        else
            text += $"; Input received: {notification.Input}";
    }
    if (DispatcherQueue.HasThreadAccess)
        DisplayMessageDialog(text);
    else
    {
        DispatcherQueue.TryEnqueue(() =&gt;
        {
            DisplayMessageDialog(text);
        });
    }
}</pre><p class="list-inset">The final code to add to <strong class="source-inline">MainPage</strong> is a simple<a id="_idIndexMarker651"/> method to display <strong class="source-inline">ContentDialog</strong> with the <span class="No-Break">notification data:</span></p><pre class="source-code">private void DisplayMessageDialog(string message)
{
    ContentDialog notifyDialog = new()
    {
        XamlRoot = this.XamlRoot,
        Title = "Notification received",
        Content = message,
        CloseButtonText = "Ok"
    };
    notifyDialog.ShowAsync();
}</pre><p class="list-inset"><strong class="source-inline">MainViewModel</strong> is the final class to be updated. We need to create two command methods for the new buttons to invoke when sending app notifications. Create two methods named <strong class="source-inline">SendToast</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">SendToastWithText</strong></span><span class="No-Break">:</span></p><pre class="source-code">[RelayCommand]
private void SendToast()
{
    if (ToastWithAvatar.SendToast())
        NotificationShared.ToastSentSuccessfully();
    else
        NotificationShared.CouldNotSendToast();
}
[RelayCommand]
private void SendToastWithText()
{
    if (ToastWithText.SendToast())
        NotificationShared.ToastSentSuccessfully();
    else
        NotificationShared.CouldNotSendToast();
}</pre><p class="list-inset">Don’t forget to add <strong class="source-inline">using MyMediaCollection.Helpers;</strong> to the list of using statements <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">MainViewModel</strong></span><span class="No-Break">.</span></p></li>			</ol>
			<p>We’re ready to run the app<a id="_idIndexMarker652"/> and test the notifications. Start debugging and click the <strong class="bold">Send Notification</strong> button. You should see a toast appear in the lower-right portion of the <span class="No-Break">main screen:</span></p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B20908_08_01.jpg" alt="Figure 8.1 – A Windows toast notification"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – A Windows toast notification</p>
			<p>Bring another window in front of <strong class="bold">My Media Collection</strong> and then click <strong class="bold">Open App</strong> on the toast. The app should be brought<a id="_idIndexMarker653"/> back to the front of the screen and <strong class="bold">ContentDialog</strong> will display a message with information about the <span class="No-Break">notification received:</span></p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B20908_08_02.jpg" alt="Figure 8.2 – Receiving an app notification"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Receiving an app notification</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you click one of the buttons to send a notification multiple times without acknowledging the toast window, the toasts will not stack. The subsequent toasts will go straight to Windows’ <strong class="bold">Notifications Center</strong>. Once they go there, it’s not possible to use interactive fields such as a text box. In addition, if the user has <em class="italic">Do Not Disturb</em> or <em class="italic">Focus</em> mode enabled, all notifications will be suppressed and sent directly to <span class="No-Break"><strong class="bold">Notifications Center</strong></span><span class="No-Break">.</span></p>
			<p>Now click the <strong class="bold">Send Notification with Text</strong> button. When this toast<a id="_idIndexMarker654"/> appears, it will have a text box where you can <strong class="bold">Enter </strong><span class="No-Break"><strong class="bold">a reply</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B20908_08_03.jpg" alt="Figure 8.3 – Displaying a toast window with a text box"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Displaying a toast window with a text box</p>
			<p>Type <strong class="source-inline">Hello world</strong> and click the <strong class="bold">Reply</strong> button. Now, when <strong class="bold">My Media Collection</strong> displays <strong class="bold">ContentDialog</strong>, it will include the reply that was entered in the <span class="No-Break">toast window:</span></p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B20908_08_04.jpg" alt="Figure 8.4 – Displaying the reply text from the toast window in our app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Displaying the reply text from the toast window in our app</p>
			<p>Now you’re ready to start building<a id="_idIndexMarker655"/> notifications into your own WinUI applications. Let’s wrap up the chapter and discuss what <span class="No-Break">we’ve learned.</span></p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor207"/>Summary</h1>
			<p>In this chapter, we learned about the types of Windows notifications available to WinUI developers in the Windows App SDK. We discussed how notifications can be used to save Windows resources, reduce the need for timers, and prompt users to act. We explored how to configure raw push notifications and added a local app notification to the <strong class="bold">My Media Collection</strong> sample app. You should now feel prepared to add any of these types of notifications to your own <span class="No-Break">WinUI applications.</span></p>
			<p>In the next chapter, we’ll explore the <strong class="bold">Windows Community Toolkit</strong> (<strong class="bold">WCT</strong>) and learn how, together with the .NET Community Toolkit, you can save development time by leveraging existing helpers, styles, <span class="No-Break">and controls.</span></p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor208"/>Questions</h1>
			<ol>
				<li>What type of Windows notification can be used to initiate a data sync from <span class="No-Break">the cloud?</span></li>
				<li>Which type of notification doesn’t rely <span class="No-Break">on WNS?</span></li>
				<li>Where do you register your app before configuring notification services <span class="No-Break">in Azure?</span></li>
				<li>Which Windows App SDK namespace contains the objects for working with <span class="No-Break">app notifications?</span></li>
				<li>Which class has methods to register and unregister your app for handling <span class="No-Break">app notifications?</span></li>
				<li>Which property can be set if you would like notifications from your app to disappear after a <span class="No-Break">system reboot?</span></li>
				<li>Can notifications from WNS prompt the user with a <span class="No-Break">toast notification?</span></li>
			</ol>
		</div>
	</body></html>