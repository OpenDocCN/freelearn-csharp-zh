<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-151">
    <a id="_idTextAnchor152">
    </a>
    
     10
    
   </h1>
   <h1 id="_idParaDest-152">
    <a id="_idTextAnchor153">
    </a>
    
     Continuous Integration with GitHub Actions
    
   </h1>
   <p>
    
     Welcome to the chapter on
    
    <strong class="bold">
     
      Continuous Integration
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CI
     
    </strong>
    
     ) with GitHub Actions.
    
    
     As we delve into this chapter, we will gain a comprehensive understanding of how GitHub Actions can enhance our development workflow, streamline our processes, and ensure our code base remains robust and reliable, as well as how Visual Studio helps us
    
    
     
      with this.
     
    
   </p>
   <p>
    
     First, we will explore the fundamentals of GitHub Actions, a powerful CI/CD tool integrated directly into GitHub.
    
    
     Next, we will dive into configuring workflows in GitHub Actions.
    
    
     This section will guide you through setting up and managing workflows tailored to your project’s needs.
    
    
     Finally, we will focus on generating GitHub Actions files using Visual Studio.
    
    
     Visual Studio provides robust support for creating and managing GitHub Actions for Azure deployment, making it easier for us to integrate CI/CD into your development environment.
    
    
     We’ll cover the
    
    
     
      following topics:
     
    
   </p>
   <ul>
    <li>
     
      Understanding GitHub Actions
     
     
      
       for CI/CD
      
     
    </li>
    <li>
     
      Configuring workflows in
     
     
      
       GitHub Actions
      
     
    </li>
    <li>
     
      Generating GitHub Actions files with
     
     
      
       Visual Studio
      
     
    </li>
   </ul>
   <p>
    
     Mastering GitHub Actions for CI/CD is crucial for any modern developer.
    
    
     By the end of this chapter, you will have the knowledge and skills required to set up and manage automated workflows, significantly improving your
    
    
     
      development efficiency.
     
    
   </p>
   <h1 id="_idParaDest-153">
    <a id="_idTextAnchor154">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     While writing this chapter, I used the following version of
    
    
     
      Visual Studio:
     
    
   </p>
   <ul>
    <li>
     
      Visual Studio Enterprise 2022
     
     
      
       Version
      
     
     
      
       17.12.0
      
     
    </li>
    <li>
     
      
       Preview
      
     
     
      
       1.0
      
     
    </li>
   </ul>
   <p>
    
     To fully follow the chapter, you will also need a valid GitHub account, which you can set up
    
    
     
      at
     
    
    <a href="https://github.com/">
     
      
       https://github.com/
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-154">
    <a id="_idTextAnchor155">
    </a>
    
     Understanding GitHub Actions for CI/CD
    
   </h1>
   <p>
    
     In this section, we will dive into GitHub Action to recognize its role in automating software workflows directly within GitHub
    
    <a id="_idIndexMarker607">
    </a>
    
     repositories and facilitating CI and
    
    <strong class="bold">
     
      continuous deployment
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CD
     
    </strong>
    
     ) processes.
    
    
     CI/CD practices aim to accelerate
    
    <a id="_idIndexMarker608">
    </a>
    
     development cycles, enhance code quality, and streamline application
    
    
     
      deployment processes.
     
    
   </p>
   <p>
    
     GitHub Actions enables the
    
    <a id="_idIndexMarker609">
    </a>
    
     direct automation of software workflows within GitHub repositories, encompassing CI/CD processes.
    
    
     By automating these workflows, development cycles can be expedited, code quality can be ensured, and application deployment processes can be streamlined.
    
    
     An example of this automation could be running tests on code automatically upon pushing changes to
    
    
     
      the repository.
     
    
   </p>
   <p>
    
     In the context of CI/CD, CI involves regularly merging all developers’ working copies to a shared mainline several times a day.
    
    
     This helps to detect and address bugs quickly.
    
    
     By integrating code frequently, teams can identify and fix issues early in the development cycle, reducing the cost and effort required to resolve them later.
    
    
     For instance, we can set up a GitHub Action to run unit tests every time a pull request is merged into the
    
    
     
      main branch.
     
    
   </p>
   <p>
    
     CD takes CI one step further by automating the deployment of code changes to selected infrastructure environments after they pass through the CI pipeline.
    
    
     CD ensures that new features and fixes are released quickly and reliably, improving the overall efficiency of the software release process.
    
    
     GitHub allows us to automatically deploy a web application to a staging environment whenever there’s a successful build from the
    
    
     
      CI pipeline.
     
    
   </p>
   <p>
    
     GitHub Actions offers several benefits for implementing CI/CD pipelines, including ease of setup, integration with GitHub’s ecosystem, and the ability to customize workflows to fit specific project needs.
    
    
     These benefits make it accessible for teams of all sizes, from individuals working on personal projects to large organizations managing complex software products.
    
    
     A team can easily set up a CI/CD pipeline without needing extensive DevOps expertise, leading to faster development cycles and
    
    
     
      higher-quality releases.
     
    
   </p>
   <p>
    
     GitHub Actions streamlines the setup of CI/CD pipelines, removing the need for manual configurations such as setting up webhooks, purchasing hardware, and managing security patches.
    
    
     Its seamless integration with GitHub allows it to respond to any webhook, enabling flexible event triggers for automation or CI/CD pipelines.
    
    
     The GitHub community contributes a vast array of pre-built CI/CD workflows through the GitHub Marketplace, making it easier for
    
    <a id="_idIndexMarker610">
    </a>
    
     users to use existing solutions or share their own.
    
    
     Additionally, GitHub Actions supports any platform, language, and cloud, offering unparalleled flexibility for
    
    <a id="_idIndexMarker611">
    </a>
    
     
      various technologies.
     
    
   </p>
   <p>
    
     For a better understanding of the process, we will explore the different components of
    
    
     
      GitHub Actions:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Workflows
      
     </strong>
     
      : A workflow is a configurable automated process that you can set up in your repository to
     
     <a id="_idIndexMarker612">
     </a>
     
      build, test, package, release, or deploy any project on GitHub.
     
     
      Workflows are defined using
     
     <strong class="bold">
      
       YAML
      
     </strong>
     
      files stored in the
     
     <strong class="source-inline">
      
       .github/workflows
      
     </strong>
     
      directory of your repository.
     
     
      YAML originally
     
     <a id="_idIndexMarker613">
     </a>
     
      stood for
     
     <strong class="bold">
      
       Yet Another Markup Language
      
     </strong>
     
      , but it later became the recursive
     
     <a id="_idIndexMarker614">
     </a>
     
      acronym
     
     <strong class="bold">
      
       YAML Ain’t
      
     </strong>
     
      <strong class="bold">
       
        Markup Language
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="bold">
      
       Events
      
     </strong>
     
      : An event is something that
     
     <a id="_idIndexMarker615">
     </a>
     
      happens in a GitHub repository, which can trigger a workflow.
     
     
      Examples include pushing code (
     
     <strong class="source-inline">
      
       push
      
     </strong>
     
      ), opening a pull request (
     
     <strong class="source-inline">
      
       pull_request
      
     </strong>
     
      ), and creating a new
     
     
      
       issue (
      
     
     
      <strong class="source-inline">
       
        issue_comment
       
      </strong>
     
     
      
       ).
      
     
    </li>
    <li>
     <strong class="bold">
      
       Jobs
      
     </strong>
     
      : A job is a set of steps that
     
     <a id="_idIndexMarker616">
     </a>
     
      execute on the same runner.
     
     
      Each job runs in its own fresh instance of the virtual environment specified
     
     
      
       by
      
     
     
      <strong class="source-inline">
       
        runs-on
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="bold">
      
       Actions
      
     </strong>
     
      : Actions are reusable units of
     
     <a id="_idIndexMarker617">
     </a>
     
      code that perform a specific task, such as building a Docker image, running tests, or deploying to a server.
     
     
      They can be written in JavaScript (using Node.js) or TypeScript and can be hosted in GitHub Marketplace
     
     
      
       or self-hosted.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Runners
      
     </strong>
     
      : Runners are servers where
     
     <a id="_idIndexMarker618">
     </a>
     
      the jobs live while they are being executed.
     
     
      There are two types of runners: GitHub-hosted runners and
     
     
      
       self-hosted runners.
      
     
    </li>
   </ul>
   <p>
    
     After this overview of GitHub Actions, we will learn how to
    
    
     
      configure workflows.
     
    
   </p>
   <h1 id="_idParaDest-155">
    <a id="_idTextAnchor156">
    </a>
    
     Configuring workflows in GitHub Actions
    
   </h1>
   <p>
    
     All components of GitHub can be configured through  YAML file.
    
    
     In this section, I will explain how the GitHub Actions
    
    <a id="_idIndexMarker619">
    </a>
    
     configuration file is organized to help you understand
    
    
     
      its functionality.
     
    
   </p>
   <p>
    
     The YAML files are placed in the
    
    <strong class="source-inline">
     
      .github/workflows
     
    </strong>
    
     directory of our repository.
    
    
     These files, known as workflow files, define
    
    <a id="_idIndexMarker620">
    </a>
    
     the scenarios of our
    
    
     
      CI/CD pipelines.
     
    
   </p>
   <p>
    
     A typical GitHub Actions workflow configuration file consists of several
    
    
     
      key sections:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       name
      
     </strong>
     
      : A human-readable name for
     
     
      
       the workflow.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       on
      
     </strong>
     
      : Specifies the event(s) that trigger
     
     
      
       the workflow.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       jobs
      
     </strong>
     
      : Defines the jobs that make up the workflow.
     
     
      Each job runs on a runner environment specified
     
     
      
       by
      
     
     
      <strong class="source-inline">
       
        runs-on
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       steps
      
     </strong>
     
      : Within each job, steps are executed sequentially.
     
     
      Steps can run commands, set up tasks, or perform an action in your repository, a public repository, or an action published in a
     
     
      
       Docker registry.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       env
      
     </strong>
     
      : Allows you to set environment variables for all steps in
     
     
      
       a job.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       defaults
      
     </strong>
     
      : Sets default behaviors for all jobs and steps in
     
     
      
       the workflow.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       permissions
      
     </strong>
     
      : Controls the permissions granted to the GitHub Actions runner during the
     
     
      
       job execution.
      
     
    </li>
   </ul>
   <p>
    
     Let’s break down these key sections with a real-world CI workflow for a
    
    
     
      C# application.
     
    
   </p>
   <p>
    
     Here’s the content of a workflow file that we will
    
    
     
      name
     
    
    
     <strong class="source-inline">
      
       CI.yaml
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
name: C# CI
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
jobs:
  build:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v2
        with:
          fetch-depth: 0 # Fetches all history for all tags
                         # and branches
      - name: Setup .NET
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: '3.1.x' # Specify the .NET version
                                # you need
      - name: Build
      run: dotnet build --configuration Release
      - name: Test
      run: dotnet test --no-build --verbosity normal</pre>
   <p>
    
     Now, let’s understand
    
    <a id="_idIndexMarker621">
    </a>
    
     how this workflow works and is articulated.
    
    
     There are four parts in this file, and they are organized
    
    
     
      as follows:
     
    
   </p>
   <p>
    <strong class="bold">
     
      Part 1: the
     
    </strong>
    
     <strong class="bold">
      
       Workflow Metadata
      
     </strong>
    
    
     
      :
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       name
      
     </strong>
     
      :
     
     
      <strong class="source-inline">
       
        C# CI
       
      </strong>
     
     <p class="list-inset">
      
       This is a descriptive
      
      <a id="_idIndexMarker622">
      </a>
      
       name for the workflow, making it easier to identify in the
      
      
       
        GitHub UI.
       
      
     </p>
    </li>
   </ul>
   <p>
    <strong class="bold">
     
      Part 2: the
     
    </strong>
    
     <strong class="bold">
      
       Trigger Conditions
      
     </strong>
    
    
     
      :
     
    
   </p>
   <ul>
    <li>
     
      <strong class="source-inline">
       
        on:
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        push:
       
      </strong>
     
    </li>
    <li>
     <strong class="source-inline">
      
       branches: [
      
     </strong>
     
      <strong class="source-inline">
       
        main ]
       
      </strong>
     
     <p class="list-inset">
      
       This means the workflow will run whenever there’s a push to the main branch.
      
      
       Similarly, the following workflow will run when a pull request is opened, synchronized, or reopened targeting the
      
      
       
        main branch:
       
      
     </p>
    </li>
    <li>
     
      <strong class="source-inline">
       
        pull_request:
       
      </strong>
     
    </li>
    <li>
     <strong class="source-inline">
      
       branches: [
      
     </strong>
     
      <strong class="source-inline">
       
        main ]
       
      </strong>
     
    </li>
   </ul>
   <p>
    <strong class="bold">
     
      Part 3:
     
    </strong>
    
     <strong class="bold">
      
       the Jobs
      
     </strong>
    
    
     
      :
     
    
   </p>
   <ul>
    <li>
     
      <strong class="source-inline">
       
        jobs
       
      </strong>
     
     
      
       :
      
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        build:
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        runs-on
       
      </strong>
     
     
      
       :
      
     
     
      <strong class="source-inline">
       
        windows-latest
       
      </strong>
     
     <p class="list-inset">
      
       This specifies that the job should run on the latest Windows environment provided by GitHub Actions.
      
      
       This is important because .NET Core/.NET 5+ applications often require a Windows environment to build and
      
      
       
        run correctly.
       
      
     </p>
    </li>
   </ul>
   <p>
    <strong class="bold">
     
      Part 4:
     
    </strong>
    
     <strong class="bold">
      
       the Steps
      
     </strong>
    
    
     
      :
     
    
   </p>
   <p class="list-inset">
    
     Each job consists of a sequence of steps that are executed in order.
    
    
     Here’s what each
    
    
     
      step does:
     
    
   </p>
   <ol>
    <li>
     
      
       Checkout code:
      
     
     <ul>
      <li>
       
        <strong class="source-inline">
         
          uses
         
        </strong>
       
       
        
         :
        
       
       
        <strong class="source-inline">
         
          actions/checkout@v2
         
        </strong>
       
      </li>
     </ul>
     <p class="list-inset">
      
       This action checks out our repository under
      
      <strong class="source-inline">
       
        $GITHUB_WORKSPACE
       
      </strong>
      
       , allowing subsequent steps
      
      <a id="_idIndexMarker623">
      </a>
      
       in the job to access it.
      
      
       The
      
      <strong class="source-inline">
       
        fetch-depth: 0
       
      </strong>
      
       option ensures that all history for all tags and branches is fetched, not just the
      
      
       
        default branch.
       
      
     </p>
    </li>
    <li>
     
      Set
     
     
      
       up .NET:
      
     
     <ul>
      <li>
       
        <strong class="source-inline">
         
          name
         
        </strong>
       
       
        
         :
        
       
       
        <strong class="source-inline">
         
          Setup.NET
         
        </strong>
       
      </li>
      <li>
       
        <strong class="source-inline">
         
          uses
         
        </strong>
       
       
        
         :
        
       
       
        <strong class="source-inline">
         
          actions/setup-dotnet@v1
         
        </strong>
       
      </li>
     </ul>
     <p class="list-inset">
      
       This action sets up the .NET environment.
      
      
       The
      
      <strong class="source-inline">
       
        dotnet-version: '3.1.x'
       
      </strong>
      
       input specifies which version of .NET to use.
      
      
       We can adjust this to match the requirements of
      
      
       
        our project.
       
      
     </p>
    </li>
    <li>
     
      
       Build:
      
     
     <ul>
      <li>
       
        <strong class="source-inline">
         
          name
         
        </strong>
       
       
        
         :
        
       
       
        <strong class="source-inline">
         
          Build
         
        </strong>
       
      </li>
      <li>
       <strong class="source-inline">
        
         run
        
       </strong>
       
        :
       
       <strong class="source-inline">
        
         dotnet build --
        
       </strong>
       
        <strong class="source-inline">
         
          configuration Release
         
        </strong>
       
      </li>
     </ul>
     <p class="list-inset">
      
       This step compiles the application using the .NET CLI.
      
      
       The
      
      <strong class="source-inline">
       
        --configuration Release
       
      </strong>
      
       flag indicates that the build should produce a
      
      <strong class="source-inline">
       
        release build
       
      </strong>
      
       , optimizing the output
      
      
       
        for performance.
       
      
     </p>
    </li>
    <li>
     
      
       Test:
      
     
     <ul>
      <li>
       
        <strong class="source-inline">
         
          name
         
        </strong>
       
       
        
         :
        
       
       
        <strong class="source-inline">
         
          Test
         
        </strong>
       
      </li>
      <li>
       <strong class="source-inline">
        
         run
        
       </strong>
       
        :
       
       <strong class="source-inline">
        
         dotnet test --no-build --
        
       </strong>
       
        <strong class="source-inline">
         
          verbosity normal
         
        </strong>
       
      </li>
     </ul>
     <p class="list-inset">
      
       This step runs any unit tests in the project without rebuilding the project first (
      
      <strong class="source-inline">
       
        --no-build
       
      </strong>
      
       ).
      
      
       The
      
      <strong class="source-inline">
       
        --verbosity normal
       
      </strong>
      
       option controls the amount of logging output.
      
      
       This helps keep the log clean and focused on
      
      
       
        essential information.
       
      
     </p>
    </li>
   </ol>
   <p>
    
     This workflow provides a straightforward CI pipeline for a C# project, ensuring that every push or pull request to the main branch is built and tested automatically.
    
    
     By adjusting the .NET version and possibly adding more jobs or steps, we can tailor this workflow to fit the specific needs of
    
    
     
      our project.
     
    
   </p>
   <p>
    
     After pushing our YAML file to GitHub, we might now go to the
    
    <strong class="bold">
     
      Actions
     
    </strong>
    
     tab in our GitHub repository to see
    
    <a id="_idIndexMarker624">
    </a>
    
     our workflow running.
    
    
     When we push changes to the main branch or open a pull request, the workflow will
    
    
     
      automatically run.
     
    
   </p>
   <h1 id="_idParaDest-156">
    <a id="_idTextAnchor157">
    </a>
    
     Generating GitHub Actions file with Visual Studio
    
   </h1>
   <p>
    
     In this section, we will see how Visual Studio allows us to generate our GitHub Actions file for our Azure deployment.
    
    
     Please note that you will need a valid subscription, as mentioned in the
    
    <em class="italic">
     
      Technical requirements
     
    </em>
    
     section, to complete
    
    
     
      this section.
     
    
   </p>
   <p>
    
     First, we need an application to deploy to
    
    <a id="_idIndexMarker625">
    </a>
    
     Azure, and for that, I simply
    
    <a id="_idIndexMarker626">
    </a>
    
     initiated a Blazor project, with the template provided by Visual Studio, which I named
    
    <strong class="source-inline">
     
      BlazorServerApp
     
    </strong>
    
     .
    
    
     After that, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Right-click on the top node of our project in order to launch the publish wizard and
     
     
      
       select
      
     
     
      <strong class="bold">
       
        Azure
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 10.1 – Publish Azure" src="img/B22218_10_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.1 – Publish Azure
    
   </p>
   <ol>
    <li value="2">
     
      Then, select the type
     
     <a id="_idIndexMarker627">
     </a>
     
      of target you want.
     
     
      It is up to you to choose the target that will suit your
     
     <a id="_idIndexMarker628">
     </a>
     
      budget and company politics.
     
     
      For this example, we will choose
     
     <strong class="bold">
      
       Azure App
      
     </strong>
     
      <strong class="bold">
       
        Service (Linux)
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 10.2 – Specific target" src="img/B22218_10_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.2 – Specific target
    
   </p>
   <ol>
    <li value="3">
     
      Once we choose the
     
     <a id="_idIndexMarker629">
     </a>
     
      target, we will jump
     
     <a id="_idIndexMarker630">
     </a>
     
      to the selection of the new
     
     <strong class="bold">
      
       App Service
      
     </strong>
     
      .
     
     
      Here, we have to select an existing instance in
     
     
      
       our subscription.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 10.3 – App Service subscription" src="img/B22218_10_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.3 – App Service subscription
    
   </p>
   <p class="list-inset">
    
     If none are available, you might need to create a new one by clicking on the
    
    <strong class="bold">
     
      Create a new instance
     
    </strong>
    
     link
    
    <a id="_idIndexMarker631">
    </a>
    
     and following the instructions in
    
    
     
      the wizard.
     
    
   </p>
   <p class="list-inset">
    
     Finally, in the last
    
    <a id="_idIndexMarker632">
    </a>
    
     step, we will determine the
    
    
     <strong class="bold">
      
       Deployment type
      
     </strong>
    
    
     
      .
     
    
   </p>
   <ol>
    <li value="4">
     
      Choose
     
     <strong class="bold">
      
       CI/CD using GitHub Actions workflows (generates yml file)
      
     </strong>
     
      , which will generate the appropriate YAML file according to
     
     
      
       our configuration:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 10.4 – Deployment type" src="img/B22218_10_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.4 – Deployment type
    
   </p>
   <ol>
    <li value="5">
     
      Now in the
     
     <strong class="bold">
      
       Solution Explorer
      
     </strong>
     
      , we can see the Blazor Server project and also the
     
     <a id="_idIndexMarker633">
     </a>
     
      generated
     
     <strong class="source-inline">
      
       BlazorServerApp.yml
      
     </strong>
     
      file under a
     
     <strong class="bold">
      
       GitHub
      
     </strong>
     
      <strong class="bold">
       
        Actions
       
      </strong>
     
     
      
       node.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 10.5 – GitHub Actions node" src="img/B22218_10_5.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 10.5 – GitHub Actions node
    
   </p>
   <p>
    
     We have now seen how to generate a GitHub Actions file.
    
    
     We were able to customize it to add code quality to our
    
    <a id="_idIndexMarker634">
    </a>
    
     pipeline, using external
    
    <a id="_idIndexMarker635">
    </a>
    
     tools, for example SonarCloud, a widely used static analysis solution, among others.
    
    
     GitHub Actions is a powerful asset to explore, and I advise you to read the book
    
    <em class="italic">
     
      Mastering GitHub Actions
     
    </em>
    
     by Eric Chapman (
    
    <a href="https://www.packtpub.com/en-us/product/mastering-github-actions-9781805128625">
     
      https://www.packtpub.com/en-us/product/mastering-github-actions-9781805128625
     
    </a>
    
     ) to dig deeper into
    
    
     
      the subject.
     
    
   </p>
   <h1 id="_idParaDest-157">
    <a id="_idTextAnchor158">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we explored the power of GitHub Actions for CI and CD, learning how to automate and streamline our development workflows.
    
    
     We began by understanding the fundamental concepts of GitHub Actions.
    
    
     Next, we moved on to configuring workflows in GitHub Actions.
    
    
     We then learned how to write and manage YAML files that define our CI/CD pipelines.
    
    
     In the final section, we focused on generating GitHub Actions files using Visual Studio.
    
    
     Visual Studio’s robust support for GitHub Actions for Azure’s deployment simplifies the process of integrating CI/CD into your
    
    
     
      development environment.
     
    
   </p>
   <p>
    
     Having established a strong foundation in automating CI/CD with GitHub Actions, it’s time to expand our collaborative capabilities.
    
    
     In the next chapter, we will explore how Azure DevOps can enhance team collaboration, streamline project management, and further optimize your
    
    
     
      development processes.
     
    
   </p>
  </div>
 </body></html>