- en: AR for Tourism with ARKit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ARKit进行旅游
- en: In this chapter, we will explore ARKit, Apple's own AR SDK, which offers many
    features such as spatial tracking, image tracking, collaborative AR, and more.
    We will also learn how to exploit world tracking in order to create a different
    AR experience for the tourism sector.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将探索ARKit，这是苹果公司自己的AR SDK，它提供了许多功能，如空间跟踪、图像跟踪、协作AR等。我们还将学习如何利用世界跟踪来为旅游行业创造不同的AR体验。
- en: The main goals of this chapter are to introduce you to ARKit and how it works
    by searching and tracking flat surfaces in the real world. Then, you will learn
    how to use these features to place elements in AR and anchor them in order to
    create a dimensional portal that will introduce the user to a 3D world. The second
    goal of this chapter is to present a different way of viewing tourism. You will
    learn how to take advantage of AR to create unique experiences that can be implemented
    in museums, landscapes, points of interest, and so on. By doing this, you will
    be able to modify and apply this project to your own interests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是向您介绍ARKit及其工作原理，通过在现实世界中搜索和跟踪平面表面。然后，您将学习如何使用这些功能在AR中放置元素并锚定它们，以创建一个三维门户，将用户引入一个三维世界。本章的第二个目标是展示一种不同的旅游观。您将学习如何利用AR创造独特体验，这些体验可以应用于博物馆、景观、兴趣点等。通过这样做，您将能够根据您的兴趣修改和应用此项目。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using AR for tourism
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AR进行旅游
- en: Exploring ARKit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索ARKit
- en: Developing an ARKit app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发ARKit应用程序
- en: Creating an AR portal
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建AR门户
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求如下：
- en: A Mac computer with macOS Sierra 10.12.4 or above (we used a Mac mini, Intel
    Core i5, 4 GB memory, with macOS Mojave in this book)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行macOS Sierra 10.12.4或更高版本的Mac电脑（本书中使用的是Mac mini，Intel Core i5，4 GB内存，运行macOS
    Mojave）
- en: The latest version of Xcode (10.3 in this book)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xcode的最新版本（本书中为10.3）
- en: An ARKit-compatible iPhone/iPad with iOS 11+ (we tested the project on an iPad
    Pro 10.5 with iOS 13.1.1)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兼容iOS 11+的ARKit兼容iPhone/iPad（我们在iPad Pro 10.5上运行iOS 13.1.1进行了测试）
- en: The code files and resources for this chapter can be found here: [https://github.com/PacktPublishing/Enterprise-Augmented-Reality-Projects/tree/master/Chapter08](https://github.com/PacktPublishing/Enterprise-Augmented-Reality-Projects/tree/master/Chapter08)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件和资源可以在以下链接找到：[https://github.com/PacktPublishing/Enterprise-Augmented-Reality-Projects/tree/master/Chapter08](https://github.com/PacktPublishing/Enterprise-Augmented-Reality-Projects/tree/master/Chapter08)
- en: You can view the compatible devices at [https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/DeviceCompatibilityMatrix/DeviceCompatibilityMatrix.html](https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/DeviceCompatibilityMatrix/DeviceCompatibilityMatrix.html)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处查看兼容的设备：[https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/DeviceCompatibilityMatrix/DeviceCompatibilityMatrix.html](https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/DeviceCompatibilityMatrix/DeviceCompatibilityMatrix.html)
- en: When we explore ARKit, we will explain the device requirements you'll need,
    depending on the ARKit features that you want to use, since not all devices can
    use them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们探索ARKit时，我们将解释您根据想要使用的ARKit功能所需满足的设备要求，因为并非所有设备都能使用它们。
- en: Finally, take into account that this chapter is dedicated to iOS devices. Therefore,
    you will need an Apple account (free or developer account) to compile the project
    on your iOS device. You can find more information here: [https://developer.apple.com/support/compare-memberships/](https://developer.apple.com/support/compare-memberships/)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，本章专门针对iOS设备。因此，您需要一个Apple账户（免费或开发者账户）来在您的iOS设备上编译项目。您可以在以下链接中找到更多信息：[https://developer.apple.com/support/compare-memberships/](https://developer.apple.com/support/compare-memberships/)
- en: Using AR for tourism
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AR进行旅游
- en: AR is mainly a visual technology. Although it can combine other effects such
    as sounds to make the experience more realistic or vibrations on the phone when
    we are playing a game, its main attraction is the visual content it displays over
    the real world. That makes this technology perfect for enhancing traveling experiences,
    from showing skyline information to making animals in a museum come to life or
    even translating signs and guides in real time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: AR主要是一种视觉技术。尽管它可以结合其他效果，如声音以使体验更加真实，或者在我们玩游戏时在手机上产生震动，但其主要吸引力在于它在现实世界之上显示的视觉内容。这使得这项技术非常适合增强旅行体验，从展示天际线信息到使博物馆中的动物栩栩如生，甚至实时翻译标志和指南。
- en: Back in the late 2000s/early 2010s, when smartphones started to become popular,
    some of the first AR apps that appeared were tourism-oriented. In 2010, for example,
    the Museum of London released an iPhone app that showed historical photos of the
    city over the real places. This example has also been carried to other cities
    and scopes, such as in Navarra, Spain, where users can replay scenes of famous
    films shot in different locations of the region in AR by pointing their mobile
    devices to the panels that had been placed in said locations. In this case, the
    mobile devices use image recognition (the panel) to launch the AR experience.
    However, back in the early 2010s, the most stable and widespread AR technology
    was location-based and used a device's GPS, accelerometer, and compass. AR engines
    and apps such as Layar and Wikitude were mostly used as they allowed developers
    to generate routes, gymkhanas, and even games based on **points of interest**
    (**POIs**) across cities.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 回到2000年代末/2010年代初，当智能手机开始流行时，最早出现的AR应用之一就是以旅游为导向的。例如，2010年，伦敦博物馆发布了一款iPhone应用，可以在真实地点上显示城市的历史照片。这个例子也被推广到其他城市和范围，如在西班牙纳瓦拉，用户可以通过指向放置在不同地点的板面，在AR中重新播放该地区不同地点拍摄的名场景。在这种情况下，移动设备使用图像识别（板面）来启动AR体验。然而，在2010年代初，最稳定和最广泛使用的AR技术是基于位置的，使用设备的GPS、加速度计和指南针。Layar和Wikitude等AR引擎和应用程序被广泛使用，因为它们允许开发者基于城市中的**兴趣点**（**POI**）生成路线、障碍赛和甚至游戏。
- en: 'Nowadays, some of the most common uses of AR in tourism are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，AR在旅游中最常见的应用如下：
- en: To serve as a live guide in the streets of a new city, where a user can go around
    the city while the AR app is showing them where the most interesting points to
    see are through the use of arrows.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为新城市街道上的现场导游，用户可以在AR应用显示他们最感兴趣的景点位置的同时在城市中四处走动，通过使用箭头来指示。
- en: To show attractions and POIs over a map. Here, when a user points at a map with
    the camera, the POIs pop up from it and they can interact with them to find out
    more.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地图上展示景点和POI。在这里，当用户用摄像头指向地图时，POI会从地图上弹出，他们可以与之互动以获取更多信息。
- en: To provide extra information about paintings, sculptures, or monuments. Here,
    when a user points at a painting, it can show a video about the artist and the
    place and time where it was painted, or even make it come to life as a 3D simulation.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供关于画作、雕塑或纪念碑的额外信息。在这里，当用户指向一幅画作时，它可以显示关于艺术家以及画作创作地点和时间的视频，甚至可以将其以3D模拟的形式栩栩如生地呈现出来。
- en: Apart from all these experiences, when AR is combined with other immersive technologies
    such as virtual worlds or 360º videos, the experience goes one step ahead, allowing
    users to visit several places at the same time (for example, in a museum network,
    while visiting one of them, to be able to virtually visit the others).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些体验之外，当AR与其他沉浸式技术如虚拟世界或360度视频结合时，体验又向前迈出一步，使用户能够同时访问多个地方（例如，在博物馆网络中，在访问其中一个的同时，能够虚拟访问其他地方）。
- en: In this chapter, we will learn about how to mix these experiences using Apple's
    ARKit SDK to create an art experience. We will create an AR portal, and when users
    go through it, they will land on a painting represented in 3D. In our case, we
    will use a painting from Van Gogh (Bedroom in Arles) that's been downloaded from
    Sketchfab to give the users the illusion of being inside a 3D Van Gogh painting: [https://sketchfab.com/3d-models/van-gogh-room-311d052a9f034ba8bce55a1a8296b6f9](https://sketchfab.com/3d-models/van-gogh-room-311d052a9f034ba8bce55a1a8296b6f9).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用苹果的ARKit SDK将这些体验混合在一起，以创建一个艺术体验。我们将创建一个AR门户，当用户通过它时，他们将降落在3D呈现的画作上。在我们的案例中，我们将使用从Sketchfab下载的梵高的画作（阿尔勒的卧室）来给用户一种仿佛置身于3D梵高画作中的错觉：[https://sketchfab.com/3d-models/van-gogh-room-311d052a9f034ba8bce55a1a8296b6f9](https://sketchfab.com/3d-models/van-gogh-room-311d052a9f034ba8bce55a1a8296b6f9)。
- en: To implement this, we will create an app oriented to the tourism field that
    can be displayed in museums, galleries, and more. Regarding the tool we are going
    to use, in the next section, we will explain how ARKit works and its main features.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将创建一个面向旅游领域的应用程序，可以在博物馆、画廊等地方展示。关于我们将要使用的工具，在下一节中，我们将解释ARKit是如何工作的以及其主要功能。
- en: Exploring ARKit
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索ARKit
- en: 'Apple launched the first version of ARKit in 2017 along with Xcode 9 and iOS
    11 to bring AR to iOS devices. The framework, which is included in Xcode, offered
    developers the possibility to produce AR experiences in their apps or games with
    software that''s combined with an iOS device''s motion features and camera tracking.
    It allows users to place virtual content in the real world. Months after its official
    release, it added new features such as 2D image detection and face detection.
    The main features that are available for iOS 11 and above are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果在2017年与Xcode 9和iOS 11一起发布了ARKit的第一个版本，将AR引入iOS设备。该框架包含在Xcode中，为开发者提供了在他们的应用程序或游戏中创建AR体验的可能性，这些软件结合了iOS设备的运动特性和相机追踪功能。它允许用户在现实世界中放置虚拟内容。在官方发布几个月后，它增加了新功能，如2D图像检测和面部检测。iOS
    11及以上版本可用的主要功能如下：
- en: Tracking and visualizing planes (iOS 11.3+), such as a table or the ground,
    in the physical environment
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在物理环境中追踪和可视化平面（iOS 11.3+），例如桌子或地面
- en: Tracking known 2D images (iOS 11.3+) in the real world and placing AR content
    over them (image recognition)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现实世界中追踪已知的2D图像（iOS 11.3+），并在其上放置AR内容（图像识别）
- en: Tracking faces (iOS 11.0+) in the camera feed and laying virtual content over
    them (for example, a virtual avatar face) that react to facial expressions in
    real-time
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在相机流中追踪面部（iOS 11.0+），并在其上叠加虚拟内容（例如，虚拟头像面部），这些内容会实时对面部表情做出反应
- en: Apart from these features, the AR experience can also be enhanced by using sound
    effects attached to virtual objects or integrating other frameworks such as vision
    to add computer vision algorithms to the app, or Core ML, for machine learning
    models.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些功能之外，AR体验还可以通过使用附加到虚拟对象上的音效或集成其他框架（如视觉框架）来增强，以向应用程序添加计算机视觉算法，或者使用Core ML来添加机器学习模型。
- en: 'In 2018, with the iOS 12 release, ARKit 2 was launched with new features:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年，随着iOS 12的发布，ARKit 2推出了新功能：
- en: 3D object tracking, where real-world objects are the ones that trigger the AR
    elements
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D物体追踪，其中真实世界中的物体是触发AR元素的那些
- en: Multiuser AR experiences, allowing users near each other to share the same AR
    environment
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多用户AR体验，允许彼此靠近的用户共享相同的AR环境
- en: Adding realistic reflections to the AR objects to make the experience more realistic
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为AR对象添加逼真的反射，以使体验更加真实
- en: Saving the world-mapping data so that when a user places a virtual element in
    the real world, the next time the app restarts, the virtual elements will appear
    in the same place
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存世界映射数据，以便当用户在现实世界中放置虚拟元素时，下次应用程序重新启动，虚拟元素将出现在相同的位置
- en: At the time of writing this book, iOS 13 with ARKit 3 has just been launched
    and promises a huge improvement to the current state since it's added a new way
    of interacting with virtual elements, such as hiding virtual objects when a person
    is detected in front of them. It also allows users to interact with 3D objects
    by gestures and captures not only facial expressions but the motions of a person.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，iOS 13与ARKit 3刚刚发布，并承诺对当前状态有巨大的改进，因为它增加了一种与虚拟元素交互的新方式，例如当检测到有人站在它们前面时隐藏虚拟对象。它还允许用户通过手势与3D物体交互，并捕捉到人的面部表情和动作。
- en: Because of the changes that are made in each iOS launch, not all the features
    that we mentioned here are available on all devices. The developers' page at [https://developer.apple.com/documentation/arkit](https://developer.apple.com/documentation/arkit)
    enumerates the current ARKit features and required minimum Xcode and iOS versions
    to develop and test with.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每次 iOS 启动时都会进行更改，因此我们在这里提到的并非所有功能都适用于所有设备。在 [https://developer.apple.com/documentation/arkit](https://developer.apple.com/documentation/arkit)
    的开发者页面上列出了当前的 ARKit 功能以及开发测试所需的最小 Xcode 和 iOS 版本。
- en: For this project, we will be using plane detection, which is a basic feature
    that can be run on iOS 11 and above. We will look at this in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将使用平面检测，这是一个可以在 iOS 11 及以上版本上运行的基本功能。我们将在下一节中探讨这一点。
- en: Developing an ARKit app
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 ARKit 应用程序
- en: To start developing an app with ARKit, make sure you have the required hardware
    we discussed in the *Technical requirements* section, including an iOS device,
    since it's necessary to run the app.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 ARKit 开发应用程序，请确保您拥有我们在 *技术要求* 部分中讨论的所需硬件，包括 iOS 设备，因为运行应用程序是必要的。
- en: 'You will also need an Apple account to build your project on a real device.
    If you don''t have a paid account, you can also sign in with your regular free
    Apple ID. The current limits when using a free account are as follows: up to three
    installed apps on your device at the same time and the ability to create up to
    10 different apps every seven days.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要一个 Apple 账户才能在真实设备上构建项目。如果您没有付费账户，您也可以使用您的常规免费 Apple ID 登录。使用免费账户时的当前限制如下：同一时间在您的设备上安装最多三个应用程序，并且每七天可以创建最多
    10 个不同的应用程序。
- en: In this section, we will create an AR project using Xcode's template and go
    through its main components. Then, we will modify the basic app to visualize the
    detected surfaces and display important messages to users.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Xcode 的模板创建一个 AR 项目，并介绍其主要组件。然后，我们将修改基本应用程序以可视化检测到的表面并向用户显示重要信息。
- en: Creating a new AR project
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的 AR 项目
- en: 'Let''s create a new AR application using ARKit. We will start by creating the
    project in Xcode, the developer toolset for macOS that we can download freely
    from the Mac App Store, by following these steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 ARKit 创建一个新的增强现实应用程序。我们将通过以下步骤在 Xcode 中创建项目，Xcode 是 macOS 的开发者工具集，我们可以从
    Mac App Store 免费下载：
- en: 'Create a new project, select Augmented Reality App, and click Next. This will
    give us the basic frame so that we can start working with AR:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新项目，选择增强现实应用程序，然后点击“下一步”。这将为我们提供一个基本框架，以便我们可以开始使用 AR：
- en: '![](img/8b402154-364c-49ec-baf9-ae93b83c45b2.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b402154-364c-49ec-baf9-ae93b83c45b2.png)'
- en: Selecting the Augmented Reality App template
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 选择增强现实应用程序模板
- en: 'Fill in the Product Name, Team (here, you have to enter your Apple ID, and
    although you can leave it as None (as shown in the following screenshot), you
    will have to fill it in later to deploy the project onto the device), and Organization
    Name:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写产品名称、团队（在这里，您必须输入您的 Apple ID，尽管您可以将它留为“无”（如下面的截图所示），但您稍后必须填写它以将项目部署到设备上），以及组织名称：
- en: '![](img/7dd9290f-7072-4965-a964-19f21df413e4.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7dd9290f-7072-4965-a964-19f21df413e4.png)'
- en: Filling in the main values of our project
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 填写我们项目的核心值
- en: Press Next, select a location for the project, and press Create.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“下一步”，选择项目位置，然后点击“创建”。
- en: 'If you didn''t enter your developer ID in *step 2*, the project''s general
    window for the Signing tab will show an error that will prevent the app from building
    on a device, as shown in the following screenshot. Fix it now to be able to run
    the app:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在 *步骤 2* 中没有输入您的开发者 ID，则项目的签名选项卡的一般窗口将显示错误，这将阻止应用程序在设备上构建，如下面的截图所示。现在修复它以便能够运行应用程序：
- en: '![](img/efca0b52-6969-408c-9094-de5aa0229329.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/efca0b52-6969-408c-9094-de5aa0229329.png)'
- en: The signing tab of the project shows an error when a team hasn't been selected
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当未选择团队时，项目的签名选项卡会显示错误
- en: 'We already have an AR app ready to be executed. To test it, connect your device
    and select it from the top-left corner of the window, as shown in the following
    screenshot:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经有一个可以执行的应用程序。要测试它，连接您的设备，并从窗口的左上角选择它，如下面的截图所示：
- en: '![](img/d73d79c6-36d2-407c-84c3-6856757d4e43.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d73d79c6-36d2-407c-84c3-6856757d4e43.png)'
- en: Selecting the device to run the app
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 选择运行应用程序的设备
- en: 'Run the app by clicking on the play button in the top-left corner of the window
    (see the preceding screenshot). The first time you launch it, it will ask for
    the camera''s permission, and as soon as the camera feed appears, it will anchor
    a spaceship to the middle of your environment:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击窗口左上角的播放按钮来运行应用。第一次启动时，它会请求摄像头的权限，一旦摄像头流出现，它就会将一艘宇宙飞船锚定在你的环境中间：
- en: '![](img/7eb32643-e5e9-4b69-ad42-90d1439d9971.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb32643-e5e9-4b69-ad42-90d1439d9971.png)'
- en: The ship appears anchored to the real environment
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 船只看起来锚定在真实环境中
- en: 'Since ARKit will be tracking your environment, try to move around the ship and
    get close to it or look at it from different angles, as shown in the following
    screenshot:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 ARKit 将会跟踪你的环境，请尝试移动船只并靠近它或从不同的角度观察它，如下面的截图所示：
- en: '![](img/d6eb9708-0bbc-4649-8f20-9944e543b52e.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6eb9708-0bbc-4649-8f20-9944e543b52e.png)'
- en: Now, let's take a look at the main parts that form this project, that is, `Main.storyboard`,
    where the UI elements are, and `ViewController.swift`, where the logic of the
    app resides.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看构成这个项目的主体部分，即 `Main.storyboard`，其中包含 UI 元素，以及 `ViewController.swift`，其中包含应用的逻辑。
- en: Main.storyboard
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Main.storyboard
- en: Open the `Main.storyboard` file by clicking on it. This file contains the UI
    elements. At the moment, it only contains an ARSCNView, which occupies the whole
    screen.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击它打开 `Main.storyboard` 文件。此文件包含 UI 元素。目前，它只包含一个 ARSCNView，占据了整个屏幕。
- en: 'If you right-click on the scene view, you will see the Referencing Outlets
    that are linked to the View Controller with the sceneView variable, as shown in
    the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你右键单击场景视图，你会看到与场景视图变量链接的引用出口，如下面的截图所示：
- en: '![](img/0c927ebb-8c95-48eb-b1be-73a14a456178.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c927ebb-8c95-48eb-b1be-73a14a456178.png)'
- en: The UI element ScenView and its Referencing Outlets
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: UI 元素 ScenView 及其引用的出口
- en: Let's take a closer look at the view controller element.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看视图控制器元素。
- en: ViewController.swift
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ViewController.swift
- en: Now, click on `ViewController.swift`, which is where the main logic of our application
    lies.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击 `ViewController.swift`，这是我们应用的主要逻辑所在。
- en: The first thing you will see is that the class requires the `ARKit` library
    for the AR, the `UIKit` library for the interface, and the `SceneKit` library.
    This last one is a high-level 3D framework that Apple offers so that you can create,
    import, and manipulate 3D objects and scenes. We will be using it later in this
    chapter to import our external 3D models into the scene.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会看到，该类需要 `ARKit` 库进行 AR，`UIKit` 库进行界面，以及 `SceneKit` 库。最后一个是一个高级 3D 框架，苹果提供它，以便你可以创建、导入和操作
    3D 对象和场景。我们将在本章后面使用它来将我们的外部 3D 模型导入场景。
- en: 'Our only variable at the moment is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前唯一的变量如下：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the `ARSCNView` element from `Main.storyboard`. It will allow us to
    control the AR scene.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自 `Main.storyboard` 的 `ARSCNView` 元素。它将允许我们控制 AR 场景。
- en: 'Our `ViewController` class inherits from `UIViewController`. From here, we
    have three `override` methods. The first one is `viewDidLoad`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `ViewController` 类继承自 `UIViewController`。从这里，我们有三个 `override` 方法。第一个是 `viewDidLoad`：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This method is called when the view is loaded in memory and is used to initialize
    elements. In this case, we attach the `sceneView` element's delegate to the class
    itself, we activate the statistics that will appear at the bottom of the app,
    we create a scene with the ship model, and we assign that scene to the scene from
    the `scenView` element. This will make the battleship appear as soon as the app
    is launched.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当视图加载到内存中时，会调用此方法，并用于初始化元素。在这种情况下，我们将 `sceneView` 元素的代理附加到类本身，激活将在应用底部显示的统计信息，创建一个带有船只模型的场景，并将该场景分配给
    `scenView` 元素。这将使战舰在应用启动时立即出现。
- en: 'The second method is `viewWillAppear`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法是 `viewWillAppear`：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This method is called when the device is ready to show the interface to the
    user. The AR session is launched from here. The `ARSession`is the main element
    that controls the AR experience; it reads the data from the sensors of your device,
    controls the device's camera, and analyzes the image coming from it to create
    a correspondence between the real world and a virtual space where you place the
    AR objects.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备准备好向用户显示界面时，会调用此方法。AR 会话从这里启动。`ARSession` 是控制 AR 体验的主要元素；它从你的设备传感器读取数据，控制设备的摄像头，并分析从它传来的图像，以在放置
    AR 对象的真实世界和虚拟空间之间创建对应关系。
- en: Before running the session, we need to make use of the `ARConfiguration` class,
    which will determine the ARKit features that have been enabled for the session.
    In this case, it will track the device's position and orientation in relation
    to surfaces, people, images, or objects using the device's back camera and then
    run the session with that configuration. We could use a different configuration
    if we wanted to track only people's faces or only images, for example. (See [https://developer.apple.com/documentation/arkit/arconfiguration](https://developer.apple.com/documentation/arkit/arconfiguration)
    for more information.)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行会话之前，我们需要使用`ARConfiguration`类，该类将确定会话中启用的ARKit功能。在这种情况下，它将使用设备的后置摄像头跟踪设备相对于表面、人物、图像或对象的位置和方向，然后使用该配置运行会话。如果我们只想跟踪人们的面孔或只想跟踪图像，我们可以使用不同的配置。（有关更多信息，请参阅[https://developer.apple.com/documentation/arkit/arconfiguration](https://developer.apple.com/documentation/arkit/arconfiguration)。）
- en: 'The third override method is `viewWillDisappear`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个重写方法是`viewWillDisappear`：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method is called when the view is about to be removed. When that happens,
    the view's session is paused.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当视图即将被移除时，会调用此方法。当这种情况发生时，视图的会话将被暂停。
- en: These are the methods we have implemented at the moment. Now, we are going to
    start changing and adding code to see how ARKit tracks planes and find out about
    the different state changes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是目前我们实现的方法。现在，我们将开始更改和添加代码，以了解ARKit如何跟踪平面以及了解不同的状态变化。
- en: Modifying the basic app
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改基本应用
- en: Starting from the current code in `ViewController.swift`, we are going to modify
    it so that it only detects horizontal surfaces (not verticals, faces, or known
    images) and displays those horizontal surfaces as they are being detected to show
    extra information about the `ARSession`, such as whenever `ARTracking` is ready
    or if a new horizontal surface has been detected.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ViewController.swift`中的当前代码开始，我们将对其进行修改，使其只检测水平表面（不是垂直面、面或已知图像），并在检测过程中显示这些水平表面，以显示有关`ARSession`的额外信息，例如当`ARTracking`准备就绪或检测到新的水平表面时。
- en: 'Before we do this, though, we will delete the ship model as we no longer need
    it. Follow these steps to delete the ship model:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行这个操作之前，我们将删除船模型，因为我们不再需要它。按照以下步骤删除船模型：
- en: Delete the `art.scnassets` folder from the project.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目中删除`art.scnassets`文件夹。
- en: 'In the `viewDidLoad()` method of `ViewController.swift`, delete the reference
    to the ship from the scene, leaving the `scene` line like so:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewController.swift`的`viewDidLoad()`方法中，从场景中删除对船的引用，使`scene`行如下所示：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We are also going to enable an AR debug option that will let us see the feature
    points of our environment. As we have seen already in this book, feature points
    are unique points of an image that make it possible for that image to be identified
    and tracked. The more features we have, the more stable the tracking will be.
    We will activate this option for now so that we can see how well our environment
    is detected, and deactivate it for our final app. For that, in the `viewDidLoad()`
    method, after the `sceneView.showStatistics = true` line, add the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将启用一个AR调试选项，这将使我们能够看到我们环境的特征点。正如我们在这本书中已经看到的，特征点是图像的独特点，使得该图像可以被识别和跟踪。特征点越多，跟踪就越稳定。我们现在将激活此选项，以便我们可以看到我们的环境检测得有多好，并在我们的最终应用中将其禁用。为此，在`viewDidLoad()`方法中，在`sceneView.showStatistics
    = true`行之后，添加以下代码：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: And with this, we can proceed to plane detection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以继续进行平面检测。
- en: Detecting and showing horizontal planes
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测并显示水平平面
- en: As we mentioned previously, `ARSession` is the main element of the AR app. Another
    essential element of ARKit is `ARAnchor`, which is the representation of an interesting
    point in the real world, along with its position and orientation. We can use anchors
    to place and track virtual elements in the real world that are relative to the
    camera. When we add those anchors to the session, ARKit optimizes the world-tracking
    accuracy around that anchor, meaning that we can walk around the virtual objects
    as if they were placed in the real world.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，`ARSession`是AR应用的主要元素。ARKit的另一个基本元素是`ARAnchor`，它是现实世界中一个有趣点的表示，包括其位置和方向。我们可以使用锚点在现实世界中放置和跟踪与相机相关的虚拟元素。当我们将这些锚点添加到会话中时，ARKit会优化该锚点周围的全球跟踪精度，这意味着我们可以像它们被放置在现实世界中一样在虚拟对象周围行走。
- en: Apart from adding anchors manually, some ARKit features can automatically add
    their own special anchors to a session. For example, when we activate the plane
    detection feature in the `ARConfiguration` class, the `ARPlaneAnchor` elements
    are created automatically whenever a new plane is detected.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了手动添加锚点之外，一些 ARKit 功能可以自动将它们自己的特殊锚点添加到会话中。例如，当我们激活 `ARConfiguration` 类中的平面检测功能时，每当检测到新的平面时，就会自动创建
    `ARPlaneAnchor` 元素。
- en: 'Let''s make these plane anchors visible so that we can see how ARKit works.
    Let''s get to it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使这些平面锚点可见，这样我们就可以看到 ARKit 的工作原理。让我们开始吧：
- en: 'In the `viewWillAppear` method, *after*the `configuration` definition, add
    the following code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `viewWillAppear` 方法中，在 `configuration` 定义之后，添加以下代码：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, ARKit will only look for horizontal surfaces to track.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，ARKit 将只寻找水平表面进行跟踪。
- en: 'Uncomment the `renderer` method that''s already present in the class:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消注释类中已经存在的 `renderer` 方法：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method is called when a new `ARAnchor` is added to the scene. It helps
    us create a `SceneKit` node called `SCNNode` for that anchor.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景中添加新的 `ARAnchor` 时，会调用此方法。它帮助我们为该锚点创建一个名为 `SCNNode` 的 `SceneKit` 节点。
- en: 'Now, to paint the planes, *between* the creation of the node and the `return`
    statement, add the following:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了绘制平面，在节点创建和 `return` 语句之间添加以下代码：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, if our anchor is an `ARPlaneAnchor`, we create a new semi-transparent
    orange plane that's the same size as the `planeAnchor`. Then, we create a `SCNNode`
    with that plane and add it to the empty node that was already created. Finally,
    we return this parent node so that it's related to our current anchor and displayed
    in the scene.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果我们的锚点是一个 `ARPlaneAnchor`，我们创建一个新的半透明的橙色平面，其大小与 `planeAnchor` 相同。然后，我们创建一个带有该平面的
    `SCNNode` 并将其添加到已经创建的空节点中。最后，我们返回这个父节点，以便它与我们的当前锚点相关联并在场景中显示。
- en: 'Instead of this method, we could also implement another method from `ARSCNViewDelegate`: `func
    renderer(_ renderer: SCNSceneRenderer, didAdd node: SCNNode, for anchor: ARAnchor){}`.
    Here, the empty node has already been created, so we would only have to add the
    same preceding code extract.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '除了这种方法，我们还可以从 `ARSCNViewDelegate` 实现另一种方法：`func renderer(_ renderer: SCNSceneRenderer,
    didAdd node: SCNNode, for anchor: ARAnchor){}`。在这里，空节点已经创建好了，所以我们只需要添加相同的先前代码片段。'
- en: 'If you test the app now, you will see how it paints orange planes whenever
    it detects a flat surface. However, you will see that once a plane is painted,
    even if ARKit detects more points around it, the plane''s size is not updated,
    as shown in the following screenshot:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在测试这个应用，你会看到每当它检测到平坦表面时，它会如何绘制橙色平面。然而，你会看到一旦一个平面被绘制，即使 ARKit 检测到更多围绕它的点，平面的尺寸也不会更新，如下面的截图所示：
- en: '![](img/8d5c686b-1ad5-4ce4-99a0-3616ee5af2af.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d5c686b-1ad5-4ce4-99a0-3616ee5af2af.png)'
- en: ARKit detecting a flat surface and placing a plane
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ARKit 检测平坦表面并放置平面
- en: Let's add some more code to make the displayed plane change its size and position
    when more points are detected.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些代码，以便在检测到更多点时，显示的平面会改变其大小和位置。
- en: 'At the beginning of the class, after `sceneView`, create an array to save all
    the planes in the scene and their respective anchors:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的开头，在 `sceneView` 之后创建一个数组来保存场景中的所有平面及其相应的锚点：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, in the `renderer` method, *after* creating the plane, and *before* the
    `return` statement, add the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `renderer` 方法中，在创建平面之后，并在 `return` 语句之前，添加以下代码：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will save our plane node and anchor for later.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将保存我们的平面节点和锚点以供以后使用。
- en: 'Let''s add a new method:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个新的方法：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This method is called when the anchor is updated. First, we check that the anchor
    is an `ARPlaneAnchor`. Then, we take the plane that corresponds to that anchor
    from the array and change its `width` and `height`. Finally, we update the `position`
    of the `child` node (remember that we added our plane node to an empty node; we
    want to update our plane's position, not the empty node's position).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当锚点更新时，会调用此方法。首先，我们检查锚点是否为 `ARPlaneAnchor`。然后，我们从数组中取出与该锚点对应的平面，并更改其 `width`
    和 `height`。最后，我们更新 `child` 节点的 `position`（记住我们添加了我们的平面节点到一个空节点中；我们想要更新平面的位置，而不是空节点位置）。
- en: 'Run the app to see how the more you move the device around, the bigger the
    planes will become:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用以查看当你移动设备时，平面会变得越来越大：
- en: '![](img/2d086147-7369-4893-ba00-c8e395bca86a.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d086147-7369-4893-ba00-c8e395bca86a.png)'
- en: The detected plane becomes bigger as ARKit detects more of its points
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当 ARKit 检测到更多点时，检测到的平面会变得更大
- en: In this section, we have learned how plane anchors are created and how to visualize
    them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何创建平面锚点以及如何可视化它们。
- en: When testing the app, you may have noticed that the device needs a little time
    before it starts showing the plane anchors. That's the time when ARKit is initializing.
    In the next section, we are going to create a track for the ARKit state changes
    so that the user knows when the app is ready.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试应用时，你可能已经注意到设备需要一点时间才开始显示平面的锚点。这是ARKit初始化的时间。在下一节中，我们将创建一个ARKit状态变化的跟踪，以便用户知道应用何时准备就绪。
- en: Adding ARSessionDelegate to track state changes
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将ARSessionDelegate添加以跟踪状态变化
- en: In our class, we already have three methods that can be used to notify session
    changes to the user when the session fails or is interrupted. We are also going
    to add two new methods, that is, for when an anchor is added to the session and
    when the camera changes its tracking state. But before we do any of this, we need
    to create a label in our UI to display all the messages.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类中，我们已经有三个方法可以用来在会话失败或中断时通知用户会话变化。我们还将添加两个新方法，即当锚点添加到会话中以及当相机改变其跟踪状态时。但在我们做任何这些之前，我们需要在我们的UI中创建一个标签来显示所有消息。
- en: Adding a label UI element
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加标签UI元素
- en: 'Let''s add a new UI element, that is, a label, to show notifications to users.
    For that, follow these steps:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个新的UI元素，即标签，以向用户显示通知。为此，请按照以下步骤操作：
- en: 'Open `Main.storyboard` and open the library button located in the top-right
    corner of the screen (the first button of its set, with a square inside a circle):'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Main.storyboard`，并打开屏幕右上角的库按钮（其集合中的第一个按钮，内部有一个正方形在圆圈中）：
- en: '![](img/5b903266-34ee-43ef-9e3c-21c4a7e1814d.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b903266-34ee-43ef-9e3c-21c4a7e1814d.png)'
- en: Library button
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图书馆按钮
- en: 'Find and drag a Label onto the view:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图中查找并拖动一个标签：
- en: '![](img/46f84b3d-49b1-4d12-b294-ae4df4aa3722.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/46f84b3d-49b1-4d12-b294-ae4df4aa3722.png)'
- en: Selecting the Label from the library
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从库中选择标签
- en: With the label selected, use *Ctrl* + mouse drag to create constraints for the
    label regarding the view, or in the toolbar *below* the phone view, click on the
    Add New Constraints button. Constraints help us fix the elements on the screen
    so that they appear properly on any device screen and in any orientation.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择标签后，使用*Ctrl* + 鼠标拖动为标签创建关于视图的约束，或者在工具栏中点击位于手机视图*下方*的添加新约束按钮。约束帮助我们固定屏幕上的元素，以便它们在任何设备屏幕和任何方向上都能正确显示。
- en: 'Then, modify the values of the left, right, and bottom constraints to `20`,
    `20`, and `0`, respectively (the icon of the constraint will turn a bright red).
    Check the Height constraint box and set it to `60`, as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将左侧、右侧和底部约束的值分别修改为`20`、`20`和`0`（约束的图标将变为鲜红色）。勾选高度约束框并将其设置为`60`，如下所示：
- en: '![](img/4be967d7-1d1f-4059-9e1d-3fa993424d9e.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4be967d7-1d1f-4059-9e1d-3fa993424d9e.png)'
- en: Adding constraints to the label
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为标签添加约束
- en: 'The new constraints will appear on the right-hand side window, under the Show
    the Size Inspector tab, as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的约束将出现在右侧窗口的“显示大小检查器”选项卡下，如下所示：
- en: '![](img/57657991-3f36-40c0-b2bd-2b133ce38ed3.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/57657991-3f36-40c0-b2bd-2b133ce38ed3.png)'
- en: The four new constraints added at the bottom of the Show the Size tab
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在“显示大小”选项卡底部添加的四个新约束
- en: 'In the Show the Attributes Inspector tab, *delete* the default Text, set the
    label Color to *green*, check the Dynamic Type checkbox, and set the Alignment
    of the text to centered, as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“显示属性检查器”选项卡中，*删除*默认文本，将标签颜色设置为*绿色*，勾选动态类型复选框，并将文本对齐设置为居中，如下所示：
- en: '![](img/518357cc-5622-4835-a711-2ea12e3cc48b.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/518357cc-5622-4835-a711-2ea12e3cc48b.png)'
- en: Changing the properties of the label
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 修改标签的属性
- en: 'To connect the label to our `ViewController.swift` script and use it in our
    methods, click on the Show the Assistant Editor button in the top-right corner
    (two circles intersecting) to open the script:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将标签连接到我们的`ViewController.swift`脚本并在我们的方法中使用它，请点击右上角的“显示辅助编辑器”按钮（两个圆圈相交）以打开脚本：
- en: '![](img/a62ddb0d-00bf-4fae-b2c1-d308fb55a449.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a62ddb0d-00bf-4fae-b2c1-d308fb55a449.png)'
- en: Selecting the Assistant Editor
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 选择辅助编辑器
- en: 'Press *Ctrl* + drag the label (you will see a blue line as you drag the mouse)
    from the hierarchical view to the code, below the `sceneView` variable. Release
    the mouse. Then, on the pop-up window shown in the following screenshot, enter
    the Name of the variable, which will be `infoLabel` in this case, and click Connect:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl*并拖动标签（当你拖动鼠标时，你会看到一个蓝色线条），从层次视图拖动到代码，在`sceneView`变量下方。释放鼠标。然后，在以下截图所示的弹出窗口中，输入变量的名称，在本例中将是`infoLabel`，然后点击连接：
- en: '![](img/52710e29-4e60-4d9b-bacf-6ea9a3091ce3.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52710e29-4e60-4d9b-bacf-6ea9a3091ce3.png)'
- en: The label from the UI will be attached to the infoLabel variable
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: UI 中的标签将附加到 infoLabel 变量
- en: 'Open the `ViewController.swift` file to check that the new variable has been
    added correctly, as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ViewController.swift` 文件以检查新变量是否已正确添加，如下所示：
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we can start sending messages to the user through the interface.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过界面开始向用户发送消息。
- en: Sending notifications to the user
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向用户发送通知
- en: 'Now that we have our label to display messages to the user, let''s use the
    `session` methods we already have in our `ViewController` class and create new
    ones to display useful information, as shown in the following steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了用于向用户显示消息的标签，让我们使用 `ViewController` 类中已有的 `session` 方法，并创建新的方法来显示有用的信息，如下步骤所示：
- en: 'In the `ViewController.swift` file, within the `didFailWithError` session,
    add a new message:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewController.swift` 文件中，在 `didFailWithError` 会话内，添加一条新信息：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This message will appear when there is an error in the `ARSession`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `ARSession` 中出现错误时，将显示此消息。
- en: 'In the `sessionWasInterrupted` method, add the following message:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `sessionWasInterrupted` 方法中，添加以下信息：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will be executed when the session is interrupted; for example, when the
    app is minimized.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在会话中断时执行；例如，当应用最小化时。
- en: 'In the `sessioInterruptionEnded` method, add the following message and code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `sessioInterruptionEnded` 方法中，添加以下信息和代码：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When the session interruption finishes, we have to reset the tracking. For that,
    we will create the configuration parameter again and run the session by removing
    the previously existing anchors.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当会话中断完成时，我们必须重置跟踪。为此，我们将再次创建配置参数并通过移除之前存在的锚点来运行会话。
- en: 'Now, let''s create a new method that will detect whenever the tracking state
    has changed:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个新的方法，用于检测跟踪状态何时发生变化：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Your Xcode window will look like the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 Xcode 窗口将如下截图所示：
- en: '![](img/dbf9bedd-e177-4a9d-8f5d-35bf8f635b38.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbf9bedd-e177-4a9d-8f5d-35bf8f635b38.png)'
- en: The new method in ViewController
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ViewController 中的新方法
- en: This method checks the tracking state and displays messages when the session
    is initializing or there are problems. We also display a message when the tracking
    state is normal, but we haven't found a plane anchor yet, so the user keeps looking
    around.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法检查跟踪状态，并在会话初始化或存在问题时显示消息。我们还在跟踪状态正常但尚未找到平面锚点时显示消息，因此用户需要继续四处张望。
- en: 'Now, we have to notify the user when an anchor has been added so that they
    don''t have to look around anymore. For that, we are going to use `ARSessionDelegateProtocol`.
    The first thing we will do is add the delegate to the class, as shown in the following
    code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须在添加锚点时通知用户，这样他们就不必再四处张望了。为此，我们将使用 `ARSessionDelegateProtocol`。我们首先将要做的是将代理添加到类中，如下代码所示：
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The class declaration will look as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 类声明将如下所示：
- en: '![](img/61312d51-3339-4462-abef-7e4b3e1851e0.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61312d51-3339-4462-abef-7e4b3e1851e0.png)'
- en: The ViewController class with the added delegate
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了代理的 ViewController 类
- en: 'In the `viewWillAppear` method, just after the `sceneView.session.run(configuration)` line,
    add the following code:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `viewWillAppear` 方法中，在 `sceneView.session.run(configuration)` 行之后，添加以下代码：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With this line, we assign the delegate to the class. The `viewWillAppear` method
    will now look as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一行，我们将代理分配给类。`viewWillAppear` 方法现在将如下所示：
- en: '![](img/53c58d57-e002-4862-967c-c365228d0c79.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53c58d57-e002-4862-967c-c365228d0c79.png)'
- en: The viewWillAppear method
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewWillAppear` 方法'
- en: 'Now, create the new method to show the message when an anchor has been added:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个新的方法来显示添加锚点时的消息：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the app to see how the label changes according to the state of the camera,
    as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用以查看标签如何根据摄像头的状态变化，如下所示：
- en: '![](img/3e8b4532-5542-4e3a-a36f-db6ef3c36432.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e8b4532-5542-4e3a-a36f-db6ef3c36432.png)'
- en: The label notifying the user that the AR session is initializing
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通知用户AR会话正在初始化的标签
- en: 'After the AR has been initialized, the label changes to detecting the horizontal
    surfaces message, as shown in the following screenshot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AR 初始化后，标签将变为检测水平表面的信息，如下截图所示：
- en: '![](img/a1e5f1fa-49d9-4a72-96d8-4daa0dabb0d5.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1e5f1fa-49d9-4a72-96d8-4daa0dabb0d5.png)'
- en: The label asking the user to move the device to detect horizontal surfaces
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 询问用户将设备移动以检测水平表面的标签
- en: The debugging messages of the `cameraDidChangeTrackingState` session method
    come from the *Tracking and Visualizing Planes* example, which is available at
    [https://developer.apple.com/documentation/arkit/tracking_and_visualizing_planes](https://developer.apple.com/documentation/arkit/tracking_and_visualizing_planes).
    This example project uses more methods to show planes and messages that we won't
    need for this project. You can download and test it if you want to learn about
    them.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`cameraDidChangeTrackingState`会话方法的调试信息来自*跟踪和可视化平面*示例，该示例可在[https://developer.apple.com/documentation/arkit/tracking_and_visualizing_planes](https://developer.apple.com/documentation/arkit/tracking_and_visualizing_planes)找到。此示例项目使用了更多方法来显示平面和消息，而我们在这个项目中不需要它们。如果您想了解它们，可以下载并测试。'
- en: Now that we have our app's base, let's create an AR portal where we will display
    a *door* to a virtual 3D painting. Once we physically go through that door, we
    will find ourselves immersed in that virtual painting.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们app的基础，让我们创建一个AR门户，我们将在这里展示一个通向虚拟3D画作的*门*。一旦我们物理上穿过那扇门，我们就会发现自己沉浸在那个虚拟画作中。
- en: Creating an AR portal
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个AR门户
- en: 'Currently, we have an app that detects horizontal planes and notifies us about
    the state of the tracking system. Now, we want to create an AR experience where
    users will tap on the screen to create a portal and, when going through it, see
    themselves inside a 3D representation of Van Gogh''s *Bedroom in Arles* painting.
    The following diagram depicts the scene in SceneKit''s coordinate system:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个检测水平平面并通知我们跟踪系统状态的app。现在，我们想要创建一个AR体验，其中用户将触摸屏幕来创建一个门户，并且通过它时，可以看到自己身处梵高的*阿尔勒的卧室*画作的三维表示。以下图显示了SceneKit坐标系中的场景：
- en: '![](img/98445e9c-d3b8-40a1-8c31-31da4433b42c.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/98445e9c-d3b8-40a1-8c31-31da4433b42c.png)'
- en: The scene in the XYZ coordinates
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: XYZ坐标中的场景
- en: From the user's perspective, we will have a portal with a hole in it, as shown
    in the previous diagram. The hole will let us see the model in the background,
    that is, the 3D painting. The portal will not be gray; it will be transparent
    so that we can see the camera feed instead of the whole 3D painting scene that
    hides behind it. In this section, we will learn how to make this possible.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的视角来看，我们将有一个带有孔的门户，如图中所示。这个孔将让我们看到背景中的模型，即3D画作。门户不会是灰色的；它将是透明的，这样我们就可以看到摄像头传输的内容，而不是隐藏在它后面的整个3D画作场景。在本节中，我们将学习如何实现这一点。
- en: For that, we need to add the 3D model, create the screen-tapping functionality,
    and create the actual portal, which only shows part of the painting from the outside.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要添加3D模型，创建屏幕触摸功能，并创建实际的门户，它只从外面显示画作的局部。
- en: From this point on, you can specify whether you want the showFeaturePoints option
    and the two `renderer` methods showing the planes. We will leave them until the
    end of the project because it's best if we understand how ARKit works first.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，您可以指定是否要显示特征点选项以及显示平面的两个`renderer`方法。我们将把它们留到项目结束时，因为最好是在我们首先理解ARKit的工作原理之后再进行这些操作。
- en: 'In the following subsections, we will do the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下子节中，我们将做以下事情：
- en: Import a 3D model into our project and scene
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将3D模型导入我们的项目和场景
- en: Add the user interaction so that when a user touches the screen, the 3D model
    will appear over the touched anchor plane
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加用户交互，以便当用户触摸屏幕时，3D模型将出现在被触摸的锚平面之上
- en: Add the walls to the portal to make the model invisible from the outside, except
    for the door
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将墙壁添加到门户中，使模型从外面不可见，除了门
- en: Improve the app by adding textures to the walls and a compass image to help
    users find out where the portal will appear
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过给墙壁添加纹理和指南针图像来改进应用，以帮助用户找到门户出现的位置
- en: Now, let's start by adding the 3D model we want to show.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们先添加我们想要展示的3D模型。
- en: Importing the 3D model
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入3D模型
- en: SceneKit's preferred 3D model type is Collada (`.dae` files). However, it can
    also read OBJ (`.obj`) files, and in this case, the downloaded model is in the
    latter format. We have slightly modified it using a 3D modeling program and put
    the pivot point on the floor, in the nearest edge away from us. This way, when
    we place it in the real world, we will see the model in front of us, instead of
    surrounding us. If you try this with another model or you don't know how to modify
    a pivot point, you can adjust the transform's position directly in the code (we
    will explain how later).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: SceneKit首选的3D模型类型是Collada（.dae文件）。然而，它也可以读取OBJ（.obj）文件，在这种情况下，下载的模型是后一种格式。我们使用3D建模程序对其进行略微修改，并将基点放在离我们最近的边缘的地板上。这样，当我们将其放置在现实世界中时，我们将看到模型在我们面前，而不是围绕我们。如果您尝试使用其他模型或不知道如何修改基点，您可以直接在代码中调整变换的位置（我们稍后会解释）。
- en: Adding the model to the project
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将模型添加到项目中
- en: 'To import the model and show it in our scene, download it from the resources
    of this project and follow these steps:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入模型并在我们的场景中显示它，请从本项目的资源中下载它并遵循以下步骤：
- en: 'Right-click on the project and select New Group, as shown in the following
    screenshot. Call it `Models`:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击项目并选择新建组，如下截图所示。命名为`Models`：
- en: '![](img/ab1a3672-02ee-48b6-91b4-697bf26913f8.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab1a3672-02ee-48b6-91b4-697bf26913f8.png)'
- en: Creating a New Group to contain our model
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新组来包含我们的模型
- en: 'Right-click on the `Models` folder and select Add Files to "ARPortal"…, as
    follows:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`Models`文件夹，选择将文件添加到“ARPortal”…，如下所示：
- en: '![](img/028756b0-d07d-4140-aebb-9c2529a1a9d2.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/028756b0-d07d-4140-aebb-9c2529a1a9d2.png)'
- en: Adding files to our folder
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件添加到我们的文件夹中
- en: 'Navigate to the `vangogh_room` folder, which contains the model, material,
    and textures. Select it, make sure that it''s added to our app in Add to targets,
    and click Add, as shown in the following screenshot:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到包含模型、材质和纹理的`vangogh_room`文件夹。选择它，确保它已添加到我们的应用中，并点击添加，如下截图所示：
- en: '![](img/7a74e69c-9b32-4193-a3c9-fcd1213c86b0.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a74e69c-9b32-4193-a3c9-fcd1213c86b0.png)'
- en: Selecting the folder and adding it to the target app
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 选择文件夹并将其添加到目标应用中
- en: 'If you unfold the `vangogh_room` folder, you will see all the files inside
    it. Click on the `vangogh_room.obj` file to visualize the 3D model on the screen.
    When we create the portal, we will enter the model from the open wall, as shown
    in the following screenshot:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您展开`vangogh_room`文件夹，您将看到其中的所有文件。点击`vangogh_room.obj`文件在屏幕上可视化3D模型。当我们创建门户时，我们将从开放的墙壁进入模型，如下截图所示：
- en: '![](img/f12fe0e6-64eb-40a7-8a49-9595e325f9f8.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f12fe0e6-64eb-40a7-8a49-9595e325f9f8.png)'
- en: The .obj file displayed in 3D
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D中显示的.obj文件
- en: Now, we can use our model in our code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的代码中使用我们的模型。
- en: Adding the model to our scene
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将模型添加到我们的场景中
- en: 'Now that we have imported the model into our project, let''s add it to our
    scene using code, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将模型导入到我们的项目中，让我们使用以下代码将其添加到我们的场景中：
- en: 'Create a new file by right-clicking on the `ARPortal` folder and selecting
    New File…, as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击`ARPortal`文件夹并选择新建文件…来创建一个新文件，如下所示：
- en: '![](img/591f9573-6060-49de-8f3a-de014427a839.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/591f9573-6060-49de-8f3a-de014427a839.png)'
- en: Creating a new file
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新文件
- en: 'Select Swift File and click Next:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Swift文件并点击下一步：
- en: '![](img/0205cf66-b19d-42df-b7a2-2931706b9f16.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0205cf66-b19d-42df-b7a2-2931706b9f16.png)'
- en: Selecting Swift File
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 选择Swift文件
- en: Call it `Portal.swift` and click Create. This will be the class where we will
    create our full portal, including the 3D model we imported previously.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名为`Portal.swift`并点击创建。这将是我们创建完整门户的类，包括我们之前导入的3D模型。
- en: 'Delete the code and add the `ARKit` library:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除代码并添加`ARKit`库：
- en: '[PRE20]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a `class`:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`class`：
- en: '[PRE21]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our portal will be of the `SCNNode` type.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的门户将是`SCNNode`类型。
- en: 'Now, inside the class, we''ll create a new method to load the 3D model. Add
    the following code:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在类内部，我们将创建一个新的方法来加载3D模型。添加以下代码：
- en: '[PRE22]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we load the scene from the `.obj` file and take the node out of it. Then,
    we attach the node as a child of our portal.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从`.obj`文件中加载场景并从中提取节点。然后，我们将节点作为我们的门户的子节点附加。
- en: 'If you use another model and it doesn''t appear where you want it to be (displaced
    in one or more axes), you can adjust its position inside this method by adding
    the following before the `self.addChildNode(modelNode)` line: `modelNode.position
    = SCNVector3(x: YourValue, y: YourValue, z: YourValue)`. You can check how coordinates
    work in SceneKit by looking at the diagram at the beginning of this section.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你使用另一个模型并且它没有出现在你想要的位置（在一个或多个轴上偏移），你可以在`self.addChildNode(modelNode)`行之前添加以下内容来调整其位置：`modelNode.position
    = SCNVector3(x: YourValue, y: YourValue, z: YourValue)`。你可以通过查看本节开头的图解来检查SceneKit中的坐标如何工作。'
- en: 'Now, `override` the `init` method, as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照如下方式`重写``init`方法：
- en: '[PRE23]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the first method, we initialize our portal by adding the 3D model. The second
    method is required for a subclass of `SCNNode`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个方法中，我们通过添加3D模型来初始化我们的传送门。第二个方法是`SCNNode`子类所必需的。
- en: Now that we have added our 3D model, we want to show it in our scene.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了我们的3D模型，我们想在场景中显示它。
- en: 'We could just open `ViewController.swift` and add the following at the end
    of the `viewDidLoad()` method, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接打开`ViewController.swift`文件，并在`viewDidLoad()`方法的末尾添加以下内容，如下所示：
- en: '[PRE24]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `viewDidLoad` method will now look as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad`方法现在将如下所示：'
- en: '![](img/739265e0-4a5a-4d2e-9948-3e7b4c56148f.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/739265e0-4a5a-4d2e-9948-3e7b4c56148f.png)'
- en: The viewDidLoad method with the Portal added
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 添加传送门后的`viewDidLoad`方法
- en: In this case, the 3D model will appear like the ship we saw at the beginning
    of this chapter, from the start of the session and in the middle of the screen
    (we would have to translate it downward for a better view). However, we want to
    add a twist and attach it to one of the plane anchors when the user taps on the
    screen, so delete those two lines. We'll learn how to do this in the next section.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，3D模型将像我们在本章开头看到的船一样出现，从会话开始到屏幕中间（我们可能需要向下翻译以获得更好的视角）。然而，我们想要添加一个转折，并在用户触摸屏幕时将其附加到其中一个平面锚点上，因此删除这两行。我们将在下一节中学习如何做到这一点。
- en: Including user interaction
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包括用户交互
- en: 'Let''s add some user interaction to the app. Instead of just making the virtual
    content appear in the scene from the beginning, we will make it appear when the
    user taps the screen. For that, follow these steps:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给应用添加一些用户交互。而不是一开始就使虚拟内容出现在场景中，我们将使其在用户触摸屏幕时出现。为此，请按照以下步骤操作：
- en: 'In `Main.storyboard`, click on the library button (the square inside a circle
    button) and look for Tap Gesture Recognizer. Drag it onto the view:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main.storyboard`中，点击库按钮（圆圈内的正方形按钮）并查找触摸手势识别器。将其拖到视图中：
- en: '![](img/76088aa8-5eb7-442e-8f6d-e03af4963264.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/76088aa8-5eb7-442e-8f6d-e03af4963264.png)'
- en: Selecting Tap Gesture Recognizer from the library
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从库中选择触摸手势识别器
- en: 'It will appear on the hierarchy, as shown in the following screenshot:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将显示在以下截图所示的层次结构中：
- en: '![](img/d02d7268-ce13-4502-9ac6-1c0cafca5611.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d02d7268-ce13-4502-9ac6-1c0cafca5611.png)'
- en: Tap Gesture Recognizer in the View Controller Scene hierarchy
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图控制器场景层次结构中点击“触摸手势识别器”
- en: 'Show the Assistant Editor (two circles intersecting button) and open `ViewController.swift` on
    the right-hand side. *Ctrl* + drag the Tap Gesture Recognizer over to the code,
    as shown in the following screenshot:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示辅助编辑器（两个相交的圆圈按钮）并在右侧打开`ViewController.swift`。*Ctrl* + 将触摸手势识别器拖到代码中，如下所示：
- en: '![](img/e639ee1d-23e1-4a6f-8c94-724b5638c928.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e639ee1d-23e1-4a6f-8c94-724b5638c928.png)'
- en: Dragging the Tap Gesture Recognizer to the code to create the connection
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将触摸手势识别器拖到代码中以创建连接
- en: 'Fill in the box that appears with the following parameters:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的框中填写以下参数：
- en: Connection: `Action`
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接：`Action`
- en: Object: `View Controller`
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象：`视图控制器`
- en: Name: `didTapOnScreen`
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称：`didTapOnScreen`
- en: Type: `UITapGestureRecognizer`
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型：`UITapGestureRecognizer`
- en: 'Open the `ViewController.swift` file to ensure the method has been created:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ViewController.swift`文件以确保已创建该方法：
- en: '[PRE25]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, include the following variable at the beginning of the class, after the
    `planes` variable:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在类开始处，在`planes`变量之后包含以下变量：
- en: '[PRE26]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We will use this variable to make sure we only have one portal in the view.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个变量来确保视图中只有一个传送门。
- en: 'Modify the text of the session''s `didAdd` method to instruct the user to place
    the portal when an anchor is detected, but no portal has been added yet. For that,
    modify `infoLabel.text`, as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改会话的`didAdd`方法中的文本，指示用户在检测到锚点但尚未添加传送门时放置传送门。为此，修改`infoLabel.text`，如下所示：
- en: '[PRE27]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, go to the `didTapOnScreen` method and add the following code:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，前往`didTapOnScreen`方法并添加以下代码：
- en: '[PRE28]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we are taking out the location of the tap and checking whether the tap
    is hitting an existing plane. (You can check the options for the `ARHitTestResult`
    here: [https://developer.apple.com/documentation/arkit/arhittestresult](https://developer.apple.com/documentation/arkit/arhittestresult).)
    We take the first plane of the hit results. If the portal already exists, we delete
    it to ensure we only have one portal in view. If the user taps in different places
    on the screen, the portal will appear to move from one place to the other. Then,
    we will apply the position from the plane to our portal object. Finally, we will
    add the portal to our scene and we''ll clear the information label as we no longer
    need to tell our users to tap on the screen. The resulting method will look like
    this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们取出点击的位置并检查点击是否击中了一个现有的平面。（您可以在`ARHitTestResult`的选项中检查：[https://developer.apple.com/documentation/arkit/arhittestresult](https://developer.apple.com/documentation/arkit/arhittestresult)。）我们取击中结果中的第一个平面。如果传送门已经存在，我们将删除它以确保我们只有一个传送门在视图中。如果用户在屏幕的不同位置点击，传送门将看起来从一个地方移动到另一个地方。然后，我们将平面的位置应用到我们的传送门对象上。最后，我们将传送门添加到我们的场景中，并且我们将清除信息标签，因为我们不再需要告诉用户点击屏幕。结果的方法将如下所示：
- en: '![](img/6eea8e1c-ac1f-455d-9546-7e7a21faac6c.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6eea8e1c-ac1f-455d-9546-7e7a21faac6c.png)'
- en: The didTapOnScreen method
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`didTapOnScreen`方法'
- en: 'In the `sessionWasInterrupted` method, after `infoLabel.text`, we are going
    to delete the portal so that it doesn''t appear when the session is recovered.
    For that, add the following code:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`sessionWasInterrupted`方法中，在`infoLabel.text`之后，我们将删除传送门，以确保在会话恢复时它不会出现。为此，添加以下代码：
- en: '[PRE29]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `sessionWasInterrupted` method should look as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`sessionWasInterrupted`方法应如下所示：'
- en: '![](img/f4a93b66-7582-4a9f-84d7-88fe4aef6029.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f4a93b66-7582-4a9f-84d7-88fe4aef6029.png)'
- en: The sessionWasInterrupted method
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`sessionWasInterrupted`方法'
- en: 'Run the app and tap the screen to place the 3D model. It will appear over the
    orange planes, as shown in the following screenshot:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用并点击屏幕以放置3D模型。它将出现在橙色平面上，如下面的截图所示：
- en: '![](img/aeb20833-bbf8-4034-a4b6-11c71866e392.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aeb20833-bbf8-4034-a4b6-11c71866e392.png)'
- en: The 3D painting appearing in AR when tapping on the screen
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当在屏幕上点击时出现在AR中的3D绘画
- en: 'If you enter the model and look back, you will see the real world from the
    open wall in the 3D model, as shown in the following screenshot:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进入模型并回头看，你将看到从3D模型中开放的墙壁看到的现实世界，如下面的截图所示：
- en: '![](img/e4bd540a-2240-4d92-99cf-8b7a1d67a4cc.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e4bd540a-2240-4d92-99cf-8b7a1d67a4cc.png)'
- en: The opening to the real world from the 3D room
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 从3D房间到现实世界的开口
- en: Move around the room and explore the 3D space from different angles. You will
    see how you are immersed in the virtual environment while the real world is still
    on the other side.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在房间内四处走动，从不同的角度探索3D空间。你会看到你沉浸在虚拟环境中，而现实世界仍然在另一边。
- en: Now, it's time to actually create a portal that hides most of the model until
    the *door* is crossed. For that, we are going to create transparent walls and
    play with the rendering order property.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候真正创建一个隐藏模型大部分直到*门*被穿越的传送门了。为此，我们将创建透明墙壁并玩渲染顺序属性。
- en: Adding the walls of the portal
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加传送门的墙壁
- en: 'The main trick of an AR portal is based on two things: the transparency and
    the rendering order. We are going to create a wall with an opening (we will call
    it the *doo*r) in the middle, through which we will see the 3D painting. Open
    the `Portal.swift` file and follow these steps:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: AR传送门的主要技巧基于两个东西：透明度和渲染顺序。我们将创建一个带有中间开口（我们将称之为*门*）的墙壁，通过这个开口我们将看到3D绘画。打开`Portal.swift`文件并按照以下步骤操作：
- en: 'Create a new method called `createWall` with the following code:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`createWall`的新方法，代码如下：
- en: '[PRE30]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, we created a parent node. Then, we created a box with the given size
    and set its material to white. We created a node with the box geometry that we
    attached to the parent node and returned it. This will be our base to create the
    portal walls:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个父节点。然后，我们创建了一个给定大小的盒子，并将其材质设置为白色。我们创建了一个具有盒子几何形状的节点，并将其附加到父节点上，然后返回它。这将是我们创建传送门墙壁的基础：
- en: '![](img/5f1c4372-d514-4496-bac5-2a5727620054.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5f1c4372-d514-4496-bac5-2a5727620054.png)'
- en: The new createWall method
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`createWall`方法
- en: 'Let''s create another method called `createPortal`:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建另一个名为`createPortal`的方法：
- en: '[PRE31]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Inside it, let''s define the variables for the sizes of the walls. Add the
    following code:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内部，让我们定义墙壁大小的变量。添加以下代码：
- en: '[PRE32]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We will have four walls, that is, on the left, right, top, and bottom of our
    portal door. The first three have to be big enough to hide the model from being
    displayed behind the portal. Their length will be the only thing that's displayed
    (thereby simulating a door to another dimension). The bottom wall will close that
    opening.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会有四面墙壁，即在传送门门的左侧、右侧、顶部和底部。前三个必须足够大，以隐藏模型不被显示在传送门后面。它们的长度将是唯一显示的东西（从而模拟通往另一个维度的门）。底部墙壁将关闭那个开口。
- en: 'Now, create the main node and the four walls using the previous method `createWall`:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用之前的方法`createWall`创建主节点和四面墙壁：
- en: '[PRE33]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the walls to the portal node and then the portal itself to the class''
    node, as shown in the following code:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将墙壁添加到传送门节点，然后将传送门本身添加到类的节点，如下所示代码：
- en: '[PRE34]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Our 3D portal is ready. Your code should appear as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的3D传送门已经准备好了。你的代码应该如下所示：
- en: '![](img/a2907acc-775e-4e63-b09d-bc9bbd7e0b66.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2907acc-775e-4e63-b09d-bc9bbd7e0b66.png)'
- en: The createPortal method
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`createPortal`方法'
- en: 'Now, let''s call this method from `init`. After adding the 3D model, add the
    following code:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们从`init`中调用这个方法。在添加3D模型后，添加以下代码：
- en: '[PRE35]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we run the app, when we tap on the floor, we will see a white wall, and
    through its gap, the 3D model. When we cross it, we will find ourselves in the
    3D painting, as shown in the following screenshot:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序，当我们点击地板时，我们会看到一个白色的墙壁，通过它的缝隙，我们可以看到3D模型。当我们穿过它时，我们会发现自己身处3D画作中，如下面的截图所示：
- en: '![](img/82486f5f-0d73-4962-923f-89d8e2f0eb07.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82486f5f-0d73-4962-923f-89d8e2f0eb07.png)'
- en: The white wall covering most of the 3D painting
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖大部分3D画作的白色墙壁
- en: 'We can also see the walls so that we can go back to the real world:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以让墙壁变得可见，这样我们就可以回到现实世界：
- en: '![](img/37db3ab1-3198-4281-b976-ca8530bf32de.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37db3ab1-3198-4281-b976-ca8530bf32de.png)'
- en: The view from inside the 3D painting
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 3D画作内部的视图
- en: 'However, from the outside, we don''t want to see a white wall; the portal should
    just be an opening in the air (the gap on the wall). To get that effect, let''s
    add another box to the `createWall` method before the `return node` call. Add
    the following code:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，从外面看，我们不想看到一个白色的墙壁；传送门应该只是空气中的一个开口（墙上的缝隙）。为了达到这种效果，在调用`return node`之前，让我们在`createWall`方法中添加另一个盒子。添加以下代码：
- en: '[PRE36]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This new wall, located before the other one, has a transparency of near 0 (if
    set to `0`, it is painted black) so that we can see the background. But this alone
    won't work.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新墙壁位于另一个墙壁之前，其透明度接近0（如果设置为`0`，则被涂成黑色），这样我们就可以看到背景。但仅此还不够。
- en: 'Add a rendering order of `100` to `wallNode` and a rendering order of `10`
    to `maskedWallNode`, but leave the final code for the `createWall` method like
    this:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`wallNode`的渲染顺序设置为`100`，将`maskedWallNode`的渲染顺序设置为`10`，但将`createWall`方法的最终代码保持如下：
- en: '[PRE37]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `createWall` method should now look as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`createWall`方法现在应该看起来如下：'
- en: '![](img/d3d94cbd-181c-4ecd-a45e-0af78c299c9b.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3d94cbd-181c-4ecd-a45e-0af78c299c9b.png)'
- en: The createWall method with the final code
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 最终代码的`createWall`方法
- en: 'To finish this, add a rendering order of `200` to `modelNode`, which we created
    in the `add3DModel` method:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个，给我们在`add3DModel`方法中创建的`modelNode`添加一个渲染顺序`200`：
- en: '[PRE38]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The lower the rendering order, the faster the object will be rendered in the
    scene. This means that we will see `maskedWallNode` first, then `wallNode`, and
    finally `modelNode`. This way, whenever the masked wall is in view, the 3D elements
    behind its surface won't be rendered, leaving us with a transparent surface that
    will show the camera feed directly. The only part of the 3D painting that will
    be rendered will be the one that's not covered by the walls, that is, our portal
    door. Once we go through the portal, we will see the 3D painting in full, and
    when we look back, we will see our white wall.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染顺序越低，物体在场景中的渲染速度越快。这意味着我们将首先看到`maskedWallNode`，然后是`wallNode`，最后是`modelNode`。这样，每当遮挡墙在视图中时，其表面后面的3D元素将不会被渲染，留下一个透明的表面，直接显示摄像头画面。唯一会被渲染的3D画作部分是未被墙壁覆盖的部分，即我们的传送门门。一旦我们穿过传送门，我们将看到完整的3D画作，当我们回头看时，我们将看到我们的白色墙壁。
- en: 'Run the app to see how the portal appears by touching the screen. In the following
    screenshot, we can see how the masked wall shows us the camera feed hiding the
    rest of the elements. Here, we can only see the opening from the wall (since we
    have placed it behind the masked wall in the *z *axis) and the painting through
    the opening:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，通过触摸屏幕来查看传送门是如何出现的。在下面的截图中，我们可以看到遮挡墙如何显示摄像头画面，隐藏其他元素。在这里，我们只能看到墙壁的开口（因为我们已经将其放置在遮挡墙的*z*轴后面）和通过开口的画作：
- en: You can comment on the `showFeaturePoints` line and the `renderer` methods so
    that the feature points and anchor planes don't interfere with our 3D scene.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`showFeaturePoints`行和`renderer`方法上添加注释，这样特征点和锚平面就不会干扰我们的3D场景。
- en: '![](img/aa05326a-34fc-4777-84f3-7e176824db18.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa05326a-34fc-4777-84f3-7e176824db18.png)'
- en: The portal appearing in AR
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 出现在AR中的门户
- en: Once inside the painting, if we look back, we will still see the white walls
    and the opening to go back to the real world, like before.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入绘画，如果我们回头，我们仍然会看到白色的墙壁和通往现实世界的出口，就像之前一样。
- en: Now that the scene is ready, let's improve it by adding some texture to the
    walls.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在场景已经准备好了，让我们通过给墙壁添加一些纹理来改进它。
- en: Improving the portal
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进门户
- en: 'We are going to improve our portal by adding some texture to the walls and
    a compass image that will show where the portal will appear. For that, we have
    to add the texture image and the compass image to our project. To do this, follow
    these steps:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过给墙壁添加一些纹理和一个将显示门户出现位置的指南针图像来改进我们的门户。为此，我们必须将纹理图像和指南针图像添加到我们的项目中。要这样做，请按照以下步骤操作：
- en: 'Right-click on the ARPortal project and select New File... In this case, select
    SceneKit Catalog from the Resource tab, as shown in the following screenshot:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击ARPortal项目，选择“新建文件...”在此情况下，从资源选项卡中选择SceneKit目录，如图所示：
- en: '![](img/b7a7b3e9-df78-487e-b35b-b45eb5c39717.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7a7b3e9-df78-487e-b35b-b45eb5c39717.png)'
- en: Selecting a new SceneKit Catalog
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 选择新的SceneKit目录
- en: 'Name it `Media.scnassets` and create it, as follows:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`Media.scnassets`并创建它，如下所示：
- en: '![](img/d105107c-e110-4365-9352-ba39e3b7084c.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d105107c-e110-4365-9352-ba39e3b7084c.png)'
- en: The SceneKit catalog has been successfully created
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: SceneKit目录已成功创建
- en: Right-click on the newly created `Media.scnassets` and select Add Files to "Media.scnassets"....
    Now, select the `wood.jpg` image from the resources of this project and accept
    it. Our image is ready to be used.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击新创建的`Media.scnassets`，选择“将文件添加到'Media.scnassets'...”。现在，从本项目的资源中选择`wood.jpg`图像并接受它。我们的图像已准备好使用。
- en: Repeat *step 3* with the `compass.png` image.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`compass.png`图像重复*步骤3*。
- en: 'Open `Portal.swift` and, in the `createWall` method, find the following line:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Portal.swift`，在`createWall`方法中找到以下行：
- en: '[PRE39]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Change it so that it reads like so:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 将其修改为如下所示：
- en: '[PRE40]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we have added the wooden texture to our portal.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已将木质纹理添加到我们的门户中。
- en: 'Now, we will paint the compass in `ViewController.swift`. For that, create
    the following variable after the portal variable:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在`ViewController.swift`中绘制指南针。为此，在门户变量之后创建以下变量：
- en: '[PRE41]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, uncomment the first `renderer` method, which is where the anchor planes
    are added (if you had it commented), and substitute the code inside it with the
    following:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，取消注释第一个`renderer`方法，这是添加锚平面的地方（如果你已经注释了它），并用以下代码替换其中的代码：
- en: '[PRE42]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, when a plane anchor is detected, if there is no portal or compass in view
    (the first time a plane is detected), we will paint a semitransparent compass
    showing the user the place and orientation of the future portal. Then, we'll save
    the node as the anchor so that we can use it in *step 9*.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当检测到平面锚点时，如果没有门户或指南针在视图中（第一次检测到平面时），我们将绘制一个半透明的指南针，向用户显示未来门户的位置和方向。然后，我们将保存节点作为锚点，以便我们可以在*步骤9*中使用它。
- en: Comment the `didUpdate` renderer method if you haven't. We won't need it anymore.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有注释`didUpdate`渲染方法，请现在注释它。我们以后不再需要它了。
- en: 'In the `didTapOnScreen` method, remove the code between `portal = Portal()`
    and `self.sceneView.scene.rootNode.addChildNode(portal!)` and include the following
    code instead:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`didTapOnScreen`方法中，删除`portal = Portal()`和`self.sceneView.scene.rootNode.addChildNode(portal!)`之间的代码，并替换为以下代码：
- en: '[PRE43]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, when the user taps on the screen for the first time (the compass is in
    view), we place the portal using the compass position and rotation, and we delete
    the compass as we no longer need it. From that moment on, if the user keeps tapping
    on the screen, the portal will move according to the taps and anchor plane position,
    like before.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当用户第一次点击屏幕（指南针在视图中）时，我们使用指南针的位置和旋转放置门户，因为我们不再需要它，所以我们会删除指南针。从那时起，如果用户继续点击屏幕，门户将根据点击和锚平面位置移动，就像之前一样。
- en: 'Run the app to see how the compass appears as soon as the device detects an
    anchor plane:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用以查看设备检测到锚平面时指南针如何立即出现：
- en: '![](img/3595a725-8ac4-45a2-a992-a973fc70a4b1.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3595a725-8ac4-45a2-a992-a973fc70a4b1.png)'
- en: The compass appearing on the screen, signaling the place and orientation of
    the future portal
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 出现在屏幕上的指南针，指示未来门户的位置和方向
- en: 'Now, tap the screen to see how the portal has a wooden frame. This can be seen
    in the following screenshot:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，轻触屏幕以查看门户有一个木制框架。这可以在以下屏幕截图中看到：
- en: '![](img/f7a79db0-7ce4-411a-a4fe-5699e063428c.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7a79db0-7ce4-411a-a4fe-5699e063428c.png)'
- en: The portal now has a wooden frame
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 门户现在有一个木制框架
- en: 'From the inside, the texture of the walls has changed too, as shown in the
    following screenshot:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从内部看，墙壁的纹理也发生了变化，如下面的屏幕截图所示：
- en: '![](img/c2498a8b-33ee-46b7-82fe-1432036002f4.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2498a8b-33ee-46b7-82fe-1432036002f4.png)'
- en: The view from the inside of the 3D painting
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 绘画内部的视角
- en: And that's it. Now, you can place the portal wherever you want and play with
    different options such as changing the 3D painting or creating more than one portal
    at the same time. It's up to you!
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在，你可以将门户放置在任何你想去的地方，并玩转不同的选项，比如更改 3D 绘画或同时创建多个门户。这取决于你！
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned what ARKit is and how it works. We have seen
    how the camera recognizes the feature points and how it creates anchor planes
    where you can place virtual elements. We have also learned to use SceneKit to
    insert 3D models into the scene and manipulate them to create an AR portal that
    leads the user to a 3D environment.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了什么是 ARKit 以及它是如何工作的。我们看到了相机如何识别特征点以及如何创建锚定平面，在这些平面上你可以放置虚拟元素。我们还学习了如何使用
    SceneKit 将 3D 模型插入场景并操纵它们以创建一个 AR 门户，引导用户进入 3D 环境。
- en: By now, you should have the basic skills to continue improving the current project
    and adapt it to your personal needs in the tourism sector or even other sectors.
    You could try to add buttons to the interface to change the 3D content of the
    portal, add particle effects when the portal first appears, or even try to use
    360º videos instead of 3D models. AR is a transversal tool that can be used in
    several ways and applied to many different needs, so you could also create this
    portal for fields such as marketing or retail.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经掌握了基本技能，可以继续改进当前项目，并适应旅游行业或其他行业的个人需求。你可以尝试在界面中添加按钮来更改门户的 3D 内容，当门户首次出现时添加粒子效果，或者甚至尝试使用
    360 度视频代替 3D 模型。AR 是一种跨领域的工具，可以用多种方式使用，并应用于许多不同的需求，因此你也可以为营销或零售等领域创建这个门户。
- en: This is the last chapter of this book and it is dedicated to the use of AR in
    enterprises. By now, you should have a broader idea of how AR can be useful for
    many purposes, including tourism. Now, all you need to do is start playing around
    with the different frameworks and tools you have learned about and adapt them
    to your own needs and projects. Have fun!
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一章，它致力于企业中 AR 的应用。到现在为止，你应该对 AR 如何在许多用途中发挥作用有一个更广泛的认识，包括旅游。现在，你需要做的就是开始尝试使用你所学到的不同框架和工具，并将它们适应到自己的需求和项目中。祝你好玩！
- en: Further reading
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you want to explore ARKit, either to push the current project further or
    to try out new things, we recommend Apple''s example projects, which can be found
    at [https://developer.apple.com/documentation/arkit](https://developer.apple.com/documentation/arkit).
    Some of these projects are as follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要探索 ARKit，无论是为了推进当前项目还是尝试新事物，我们推荐查看苹果的示例项目，这些项目可以在 [https://developer.apple.com/documentation/arkit](https://developer.apple.com/documentation/arkit)
    找到。以下是一些这些项目的例子：
- en: The mentioned [https://developer.apple.com/documentation/arkit/tracking_and_visualizing_planes](https://developer.apple.com/documentation/arkit/tracking_and_visualizing_planes) project,
    which you can use to track and visualize the plane anchors
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提到的 [https://developer.apple.com/documentation/arkit/tracking_and_visualizing_planes](https://developer.apple.com/documentation/arkit/tracking_and_visualizing_planes)
    项目，你可以使用它来跟踪和可视化平面锚点
- en: The [https://developer.apple.com/documentation/arkit/detecting_images_in_an_ar_experience](https://developer.apple.com/documentation/arkit/detecting_images_in_an_ar_experience) project,
    which you can use to detect 2D images (the portal could appear over a real painting
    instead of in the middle of the street, for example)
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/documentation/arkit/detecting_images_in_an_ar_experience](https://developer.apple.com/documentation/arkit/detecting_images_in_an_ar_experience)
    项目，你可以使用它来检测 2D 图像（例如，门户可以出现在真实的画作上而不是街道中间）'
- en: The [https://developer.apple.com/documentation/arkit/tracking_and_visualizing_faces](https://developer.apple.com/documentation/arkit/tracking_and_visualizing_faces) project,
    which you can use to track faces and animate virtual avatars through real expressions
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/documentation/arkit/tracking_and_visualizing_faces](https://developer.apple.com/documentation/arkit/tracking_and_visualizing_faces)
    项目，你可以使用它来跟踪面部并通过真实表情动画虚拟头像'
- en: With the launch of iOS 13, there are even more features and projects you can
    try out, such as occluding virtual objects when people move in front of them or
    interacting with the virtual content by using gestures.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 iOS 13 的发布，你可以尝试更多功能和项目，例如当人们站在虚拟物体前面时遮挡它们，或者通过手势与虚拟内容进行交互。
