- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Pipelines and Composition
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道和组合
- en: In this chapter, we will combine all knowledge from previous chapters and first
    discuss function composition, which allows us to combine simple functions to create
    more complex operations. Then, we will see how to construct pipelines using the
    `Pipe` method. We will also recall how to create monadic pipelines that gracefully
    handle errors. Furthermore, the fluent interface technique, which helps to write
    code that can be read almost like regular text, will be presented.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将结合前几章的所有知识，首先讨论函数组合，它允许我们将简单的函数组合成更复杂的操作。然后，我们将看到如何使用 `Pipe` 方法构建管道。我们还将回顾如何创建可以优雅处理错误的单子管道。此外，还将介绍流畅接口技术，它有助于编写几乎可以像普通文本一样阅读的代码。
- en: 'To sum it up, this chapter walks us through these topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本章带我们了解了以下主题：
- en: Function composition
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组合
- en: Building pipelines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建管道
- en: The fluent interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流畅的接口
- en: Advanced composition with monads
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单子的高级组合
- en: I could not betray our tradition and, for the last time, prepared three self-check
    tasks for you.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我不能背叛我们的传统，最后一次，为你准备了三个自检任务。
- en: Task 1 – Enemy wave processing pipeline
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 1 – 敌军波处理管道
- en: 'Compose a series of functions into a pipeline that processes a list of enemy
    waves, applying increased difficulty (hard mode), validating the result, and transforming
    it into a formatted string using the following code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将一系列函数组合成一个管道，处理敌军波列表，应用增加难度（困难模式），验证结果，并使用以下代码将其转换为格式化的字符串：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Task 2 – Game data file processing
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 2 – 游戏数据文件处理
- en: 'Using the following code, compose a series of monadic functions into a pipeline
    that processes a game data file, reads its content, processes it, and writes the
    result to another file:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码，将一系列单子函数组合成一个管道，处理游戏数据文件，读取其内容，处理它，并将结果写入另一个文件：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Task 3 – Dynamic SQL query generation using currying and partial application
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 3 – 使用柯里化和部分应用生成动态 SQL 查询
- en: 'Use currying to build a function for dynamic query generation for tower defense
    game data and partially applied functions for querying enemy types and levels.
    Use the following function to generate query scripts:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用柯里化构建用于塔防游戏数据动态查询生成的函数，以及用于查询敌军类型和级别的部分应用函数。使用以下函数生成查询脚本：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These tasks should be already familiar to you since they were discussed in previous
    chapters. However, you still might feel that there is room for improvement in
    your mastery of composition, currying, or partial application. If so, you are
    more than welcome to proceed with reading this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务应该已经熟悉，因为它们在前几章中已经讨论过。然而，你可能仍然觉得你在组合、柯里化或部分应用方面的掌握还有提升空间。如果是这样，你非常欢迎继续阅读本章。
- en: Function composition
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数组合
- en: Steve looked at Julia with a mix of excitement and nervousness.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫带着兴奋和紧张的情绪看着朱莉娅。
- en: 'Steve: *So, we’re finally putting all the pieces together? I’m excited but
    a* *little overwhelmed.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：*所以，我们终于要把这些碎片拼在一起了？我很兴奋，但有点* *不知所措。*
- en: 'Julia: *Don’t worry, Steve. We’ll take it step by step. Remember, these concepts
    build on each other. You’ve already learned* *a lot!*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*别担心，史蒂夫。我们会一步步来。记住，这些概念是相互关联的。你已经学到了* *很多！*
- en: 'Steve: *You’re right. I’m ready to dive in. Where do* *we start?*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：*你说得对。我准备好了，从哪里* *开始呢？*
- en: 'Julia: *Let’s begin with function composition. It’s a great way to combine
    everything we’ve learned* *so far...*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*让我们从函数组合开始。这是结合我们到目前为止所学内容的绝佳方式* *...*
- en: Function composition is the process of combining two or more functions to produce
    a new function. Let’s spice things up a notch and add higher-order functions to
    our composition example.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合是将两个或更多函数组合起来产生一个新的函数的过程。让我们再加一点料，给我们的组合示例添加高阶函数。
- en: 'Consider a scenario where we need to transform a list of user data. We have
    the following higher-order functions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个场景，我们需要转换用户数据列表。我们有以下高阶函数：
- en: '**map**: Applies a function to each element in a list'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**map**：将函数应用于列表中的每个元素'
- en: '**filter**: Filters elements in a list based on a predicate'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**filter**：根据谓词过滤列表中的元素'
- en: 'We will define these functions in the following way:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按以下方式定义这些函数：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, let’s define our transformation and filtering functions:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义我们的转换和过滤函数：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can now compose `map` and `filter` to create a function that will do all
    these actions at once:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以组合 `map` 和 `filter` 来创建一个一次性执行所有这些操作的功能：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As a result, we have the `processUsers` function filter the list first to only
    include strings that start with “a” and then capitalize each remaining string.
    Of course, we could write all code using just one `processUsers` method, but the
    current solution allows us to reuse small functions in different places. The idea
    here is to start replacing big methods with compositions of smaller ones. Additional
    benefits are that small methods have much lower cognitive load and cyclomatic
    complexity, making them much easier to read and maintain.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们让`processUsers`函数首先过滤列表，只包含以“a”开头的字符串，然后对剩余的每个字符串进行大写转换。当然，我们也可以只用一个`processUsers`方法来编写所有代码，但当前的解决方案允许我们在不同的地方重用小函数。这里的想法是将大方法替换为较小方法的组合。额外的优势是，小方法具有更低的认知负荷和循环复杂度，这使得它们更容易阅读和维护。
- en: As Julia finished explaining function composition, Steve nodded thoughtfully.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当朱莉亚解释完函数组合后，史蒂夫深思地点了点头。
- en: 'Steve: I think I’m starting to see how this all fits together. But how do we
    use this in larger applications?'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：我想我开始明白这一切是如何结合在一起的。但我们如何在更大的应用中使用它呢？
- en: 'Julia: Great question! That’s where pipelines come in. They allow us to chain
    these composed functions in a more structured way. Let me show you...'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉亚：这是个好问题！这正是管道发挥作用的地方。它们允许我们以更结构化的方式链式调用这些组合函数。让我给你展示一下...
- en: Building pipelines
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建管道
- en: 'Before constructing pipelines, let’s briefly recap two key concepts from the
    previous chapter: currying and partial application. These techniques are fundamental
    to creating flexible, reusable function components that serve as excellent pipeline
    building blocks.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建管道之前，让我们简要回顾一下前一章中的两个关键概念：柯里化和部分应用。这些技术对于创建灵活、可重用的函数组件至关重要，这些组件是优秀的管道构建块。
- en: 'Currying, as we learned, transforms a function that takes multiple arguments
    into a sequence of functions, each accepting a single argument. Here’s an example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，柯里化将接受多个参数的函数转换为一串函数，每个函数接受单个参数。以下是一个示例：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Partial application, on the other hand, involves fixing a number of arguments
    to a function, producing another function with fewer parameters:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，部分应用涉及将一些参数固定到函数中，产生一个具有较少参数的另一个函数：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These concepts naturally lead on to pipeline construction. By currying functions
    or partially applying them, we create specialized, single-purpose functions that
    can be easily composed into pipelines. This approach allows us to do the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念自然地引出了管道构建。通过柯里化函数或部分应用它们，我们创建了专门的、单用途的函数，这些函数可以轻松地组合成管道。这种方法使我们能够做到以下几点：
- en: Break down complex operations into simpler, more manageable pieces
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将复杂操作分解为更简单、更易于管理的片段
- en: Reuse these pieces across different pipelines or contexts
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的管道或上下文中重用这些片段
- en: Create more expressive and readable code by chaining these specialized functions
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过链式调用这些专用函数来创建更具有表达性和可读性的代码
- en: 'For instance, consider a pipeline for processing game data:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个处理游戏数据的管道：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Each step in this pipeline could be a curried or partially applied function,
    allowing for easy customization and reuse. As we explore pipeline construction
    further, remember how currying and partial application can be leveraged to create
    more flexible and powerful pipelines.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个管道中的每一步都可以是一个柯里化或部分应用的函数，这允许我们轻松地进行定制和重用。当我们进一步探索管道构建时，请记住柯里化和部分应用如何被利用来创建更灵活和强大的管道。
- en: Now, let’s move on to building pipelines.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续构建管道。
- en: Pipelines process data through a sequence of processing steps, each represented
    by a function. This approach is particularly useful for tasks that require multiple
    transformations, validations, or computations. You most probably have already
    encountered pipelines while using LINQ to manipulate collections.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 管道通过一系列处理步骤处理数据，每个步骤由一个函数表示。这种方法对于需要多个转换、验证或计算的任务特别有用。你很可能在使用LINQ操作集合时已经遇到了管道。
- en: 'Let’s consider a real-world scenario: an **Extract, Transform, Load** (**ETL**)
    process for publishing manuscripts. This process involves several steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个现实世界的场景：用于发布手稿的**提取、转换、加载**（**ETL**）过程。这个过程涉及几个步骤：
- en: Extracting (querying) the manuscript from a database
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库中提取（查询）手稿
- en: Validating its content
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证其内容
- en: Transforming it into the required format
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其转换为所需的格式
- en: Loading (submitting) it for publication
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交（提交）以供发布
- en: 'Each step can be represented as a function, and we can use a pipeline to streamline
    this process. To do this, let’s create a method that applies a sequence of functions
    to an initial value, passing the result of each function to the next, and name
    it `Pipe`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个步骤都可以表示为一个函数，我们可以使用管道来简化这个过程。为此，让我们创建一个方法，将一系列函数应用于初始值，将每个函数的结果传递给下一个函数，并将其命名为`Pipe`：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s consider book manuscript processing: querying the manuscript from a database,
    validating its content, transforming it into the required format, and finally
    submitting it for publication:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑书籍手稿处理：从数据库中查询手稿，验证其内容，将其转换为所需的格式，并最终提交以供出版：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here’s how we might execute this flow without using the `Pipe` method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在不使用`Pipe`方法的情况下执行此流程：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, using the `Pipe` method, our code becomes 10 times better:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`Pipe`方法，我们的代码变得好10倍：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Of course, it adds a bit of overhead, and the program might work noticeably
    more slowly, but it’s so much easier and faster to read!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这增加了一点点开销，程序可能运行得明显更慢，但阅读起来容易得多，也快得多！
- en: Performance considerations
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能考虑
- en: Talking about the overhead, while functional programming techniques such as
    composition and pipelines offer improved readability and maintainability, it’s
    important to understand their performance implications. When we compose functions,
    the compiler generates a series of nested method calls. This can lead to multiple
    stack frame allocations, impacting performance for deeply nested compositions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到开销，虽然诸如组合和管道之类的函数式编程技术提供了更好的可读性和可维护性，但了解它们的性能影响很重要。当我们组合函数时，编译器生成一系列嵌套的方法调用。这可能导致多个栈帧分配，影响深层嵌套组合的性能。
- en: 'To better understand the difference, let’s benchmark different approaches:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解差异，让我们基准测试不同的方法：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Running these benchmarks might yield results similar to the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些基准测试可能会得到以下类似的结果：
- en: '![](img/B21069_10_001.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21069_10_001.jpg)'
- en: As we can see, the imperative approach is almost twice as fast as the functional
    approach. However, the performance of a usual LINQ pipeline and our own is almost
    identical! While the imperative approach shows better performance, it’s important
    to note that functional approaches often provide benefits in code readability,
    maintainability, and composability.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，命令式方法的速度几乎是函数式方法的近两倍。然而，通常的LINQ管道和我们的管道性能几乎相同！虽然命令式方法表现出更好的性能，但重要的是要注意，函数式方法通常在代码可读性、可维护性和可组合性方面提供优势。
- en: The fluent interface
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流畅接口
- en: The fluent interface is the API pattern that allows us to chain method calls
    in a readable and intuitive manner. This term became widely known in 2005, but
    some people still think of it as just method chaining. However, the main idea
    is to make the code look like a **domain-specific language** (**DSL**). Let’s
    rework our previous example by introducing a fluent interface technique.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 流畅接口是一种API模式，允许我们以可读和直观的方式链式调用方法。这个术语在2005年变得广为人知，但有些人仍然认为它只是方法链。然而，主要思想是使代码看起来像**领域特定语言**（**DSL**）。让我们通过引入流畅接口技术来重构先前的示例。
- en: 'First, let’s define a class to encapsulate the pipeline steps for processing
    a manuscript:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个类来封装处理手稿的管道步骤：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Using the fluent interface, we can rewrite the pipeline more expressively:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流畅接口，我们可以更清晰地重写管道：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, it looks almost identical to the example with the `Pipe` method,
    but the `Query` and `Submit` methods differ. It is because they do not depend
    on external validation or transformation rules that might change the logic but
    are rather straightforward. It’s a good idea to use a fluent interface when there
    is enough logic that will probably not change in the future. But if there isn’t
    any, we can use the `Pipe` method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它几乎与使用`Pipe`方法的示例相同，但`Query`和`Submit`方法不同。这是因为它们不依赖于可能改变逻辑的外部验证或转换规则，而是相当直接。当有足够的逻辑且未来可能不会改变时，使用流畅接口是个好主意。但如果没有，我们可以使用`Pipe`方法。
- en: Advanced composition with monads
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单子的高级组合
- en: Steve scratched his head, looking a bit confused.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫挠了挠头，看起来有些困惑。
- en: 'Steve: *Julia, I thought we were done with monads. Why are we* *revisiting
    them?*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：*朱莉娅，我以为我们已经完成了关于单子的讨论。为什么我们要* *重新讨论它们？*
- en: 'Julia: *Good observation, Steve. We’re circling back to monads because they’re
    incredibly powerful for composing complex operations, especially when dealing
    with error handling and asynchronous processes. Let me show you how they fit into*
    *our pipelines...*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 'Julia: *Steve，你的观察很敏锐。我们再次回到单子的概念，因为它们在组合复杂操作方面非常强大，尤其是在处理错误处理和异步过程时。让我向你展示它们如何融入我们的管道...*'
- en: Monads provide a mechanism for chaining operations as well. In previous chapters,
    you learned about the basic concept of monads and the `Bind` method. We will use
    the `Bind` method to chain operations in more complex contexts, such as error
    handling and asynchronous processing.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 单子提供了一种链式操作机制。在之前的章节中，你学习了单子的基本概念和 `Bind` 方法。我们将使用 `Bind` 方法在更复杂的环境中链式操作，例如错误处理和异步处理。
- en: In our first scenario, we need to fetch and process user data from an external
    API. Each step in the process might fail, and we need to handle these errors gracefully.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个场景中，我们需要从外部API获取和处理用户数据。过程中的每一步都可能失败，我们需要优雅地处理这些错误。
- en: 'First, let’s recall our `Result` monad definition:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下我们的 `Result` 单子定义：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, rewrite our previous example to use the `Result` type:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将我们之前的示例重写为使用 `Result` 类型：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can now compose these functions using `Bind` to create a monadic pipeline:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用 `Bind` 来创建一个单调管道来组合这些函数：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s use the pipeline to process user data:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用管道来处理用户数据：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The expected console output is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的控制台输出如下：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Again, the `processManuscript` method looks quite similar to the previous ones;
    however, this time, it includes graceful error handling.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`processManuscript` 方法看起来与之前的方法非常相似；然而，这次它包括了优雅的错误处理。
- en: 'Let’s now see how we can combine currying, partial application, and monadic
    operations to create a robust error-handling pipeline:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何结合柯里化、部分应用和单调操作来创建一个健壮的错误处理管道：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This example demonstrates the power of combining currying, partial application,
    and monadic composition. We’ve created a pipeline that parses input, validates
    it, and performs a transformation, all while handling potential errors in each
    step. The use of curried and partially applied functions makes our pipeline both
    flexible and easy to extend.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了结合柯里化、部分应用和单调组合的力量。我们创建了一个管道，它解析输入，验证它，并执行转换，同时处理每一步中可能出现的错误。使用柯里化和部分应用函数使我们的管道既灵活又易于扩展。
- en: As they wrapped up their discussion, Steve looked both tired and accomplished.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们结束讨论时，Steve看起来既疲惫又成就感十足。
- en: 'Steve: *Wow, Julia. This has been quite a journey. I never thought I’d understand
    these concepts when* *we started*.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'Steve: *哇，Julia。这真是一段旅程。我从没想到当我们开始的时候，我会理解这些概念*。'
- en: 'Julia: *You’ve come a long way, Steve. How do you feel about functional* *programming
    now*?'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 'Julia: *Steve，你已经走了很长的路。你现在对函数式编程有什么看法*？'
- en: 'Steve: *I’m excited to start applying these concepts in our projects. It’s
    amazing how much clearer and more structured our code* *can be*.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 'Steve: *我很兴奋开始在我们项目中应用这些概念。代码变得更加清晰和结构化真是太神奇了*。'
- en: Julia smiled, proud of Steve’s progress.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Julia微笑着，为Steve的进步感到自豪。
- en: 'Julia: *That’s great to hear, Steve. Remember, practice makes perfect. Keep
    experimenting and don’t be afraid to ask questions. Ready for some exercises to
    cement what* *we’ve learned?*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 'Julia: *很高兴听到这个，Steve。记住，熟能生巧。继续实验，不要害怕提问。准备好做一些练习来巩固我们学到的知识了吗*？'
- en: 'Steve: *Absolutely! Bring* *them on!*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 'Steve: *当然！来吧*！'
- en: Exercises
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Exercise 1
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1
- en: 'Compose a series of functions into a pipeline that processes a list of enemy
    waves, applying increased difficulty (hard mode), validating the result, and transforming
    it into a formatted string using the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将一系列函数组合成一个管道，处理一系列敌军波次，应用增加难度（困难模式），验证结果，并使用以下代码将其转换为格式化的字符串：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Exercise 2
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2
- en: 'Using the following code, compose a series of monadic functions into a pipeline
    that processes a game data file, reads its content, processes it, and writes the
    result to another file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码，将一系列单调函数组合成一个管道，处理游戏数据文件，读取其内容，处理它，并将结果写入另一个文件：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Exercise 3
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3
- en: 'Use currying to build a function for dynamic query generation for tower defense
    game data and partially applied functions for querying enemy types and levels.
    Use the following function to generate query scripts:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用柯里化构建一个用于动态查询生成塔防游戏数据的函数，并使用部分应用函数查询敌军类型和等级。使用以下函数生成查询脚本：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Solutions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解答
- en: Here are the solutions to the exercises provided in the previous section. Use
    them to ensure your understanding and to correct any mistakes you might have made.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是上一节提供的练习题的解决方案。使用它们来确保你的理解，并纠正你可能犯的错误。
- en: Solution 1
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案1
- en: 'First, we compose these functions to create a transaction processing pipeline:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将这些函数组合起来创建一个事务处理管道：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we test it:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对其进行测试：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here’s the expected result:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的结果：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Solution 2
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案2
- en: 'We start by creating the monadic pipeline using the given functions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用给定的函数创建单调管道：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s test the pipeline:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试这个管道：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here’s the expected result:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的结果：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Solution 3
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案3
- en: 'In this solution, we create a curried version of the function first:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个解决方案中，我们首先创建函数的柯里化版本：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we use it to generate queries:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们用它来生成查询：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We write the code to use them:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写代码来使用它们：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here’s the expected result:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的结果：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After finishing these exercises, you should have a better understanding of how
    to use pipelines, currying, and partial applications in your code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些练习后，你应该对如何在代码中使用管道、柯里化和部分应用有更好的理解。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we integrated knowledge from previous chapters to revisit pipelines
    and composition. We started with function composition, showing how to combine
    simple functions into complex operations using higher-order functions for mapping
    and filtering collections.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将前几章的知识整合起来，重新审视管道和组合。我们从函数组合开始，展示了如何使用高阶函数映射和过滤集合将简单函数组合成复杂操作。
- en: We then introduced the `Pipe` method, which simplifies a pipeline’s function
    chaining. When applied to our book publishing system example, it enabled clear
    processing steps for querying, validating, transforming, and submitting a manuscript.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了`Pipe`方法，它简化了管道的函数链。当应用于我们的图书出版系统示例时，它为查询、验证、转换和提交稿件提供了清晰的步骤。
- en: Then, we examined the fluent interface pattern, which allows quite intuitive
    method chaining. The `ManuscriptProcessor` class demonstrated how a fluent interface
    can make our code more expressive and user-friendly. We also covered advanced
    composition with monads using the `Result` type for graceful error handling in
    monadic pipelines.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们考察了流畅接口模式，它允许相当直观的方法链。`ManuscriptProcessor`类展示了流畅接口如何使我们的代码更具表达性和用户友好。我们还介绍了使用`Result`类型进行优雅错误处理的单子高级组合。
- en: The next chapter will be the last of our journey, and I truly hope you enjoy
    the process. So, finish the exercises if you haven’t yet done so, and see you
    in the next chapter!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将是我们旅程的最后一章，我真心希望你喜欢这个过程。所以，如果你还没有完成，请完成练习，我们下一章再见！
- en: Part 4:Conclusion and Future Directions
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：结论与未来方向
- en: In the final part, we reflect on the journey we’ve taken through functional
    programming in C#. We’ll summarize the key concepts learned, reinforcing your
    understanding of how these techniques can be applied to write cleaner, more maintainable
    code. We’ll also look ahead to what’s next in your functional programming journey,
    providing guidance on how to further advance your skills and stay up-to-date with
    evolving best practices in the field.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一部分，我们将反思我们通过C#函数式编程所走过的旅程。我们将总结学习到的关键概念，加强你对如何将这些技术应用于编写更干净、更易于维护的代码的理解。我们还将展望你在函数式编程旅程中的下一步，提供如何进一步提高技能并跟上该领域不断发展的最佳实践的指导。
- en: 'This part has the following chapter:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 11*](B21069_11.xhtml#_idTextAnchor446)*, Reflecting and Looking Ahead*'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B21069_11.xhtml#_idTextAnchor446)*，反思与展望*'
