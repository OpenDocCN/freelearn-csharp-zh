<html><head></head><body>
		<div id="_idContainer163">
			<h1 id="_idParaDest-206"><em class="italic"><a id="_idTextAnchor1228"/>Chapter 11</em>: Creating an ASP.NET Core 6 Web Application</h1>
			<p>Up until now, we have built all the core components of the application, such as the data access layer and service layer, and all these components are primarily server-side components, also known as <strong class="bold">backend components</strong>. </p>
			<p>In this chapter, we will build the presentation layer/<strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) for our e-commerce application, which is also known as the <strong class="bold">client-side component</strong>. The UI is the face of the application; having a good presentation layer not only helps with keeping users engaged in the application but also encourages users to come back to the application. This is especially the case with enterprise applications, where a good presentation layer helps users to navigate through the application easily and helps them in performing various day-to-day activities that are dependent on the application with ease.</p>
			<p>We will focus on understanding ASP.NET Core MVC and developing a web application using ASP.NET Core MVC. Primarily, we will cover the following topics:</p>
			<ul>
				<li>Introduction to frontend web development</li>
				<li>Integrating APIs with the service layer</li>
				<li>Creating the controller and actions</li>
				<li>Creating a UI using ASP.NET Core MVC</li>
				<li>Understanding Blazor</li>
			</ul>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor1229"/><a id="_idTextAnchor1230"/>Technical requirements</h1>
			<p>For this chapter, you need a basic knowledge of C#, .NET Core, HTML, and CSS. The code examples for the chapter can be found here: <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter11/RazorSample">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter11/RazorSample</a>.</p>
			<p>You can find more code examples here: <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application</a>.</p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor1231"/><a id="_idTextAnchor1232"/>Introduction to frontend web development</h1>
			<p>The <a id="_idIndexMarker988"/>presentation <a id="_idIndexMarker989"/>layer is all about code that a browser can render and display to the user. Wheneve<a id="_idTextAnchor1233"/>r a page gets loaded in a browser, it creates a hierarchy of various elements, such as textboxes and labels, that are presen<a id="_idTextAnchor1234"/>t on the page. This hierarchy is known <a id="_idIndexMarker990"/>as the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>). </p>
			<p>A good frontend is all about the ability to manipulate the DOM as needed, and there are many technologies/libraries that support manipulating the DOM and loading data dynamically using the de facto language of the web, JavaScript. Be it jQuery (which simplifies the use of JavaScript), full-blown client-side frameworks such as Angular, React, or Vue (which support complete client-side rendering), or ASP.NET Core frameworks such as ASP.NET Core MVC, Razor Pages, or Blazor, it all boils down to handling the three major building blocks of the web: HTML, CSS, and JavaScript. Let's look into these three building blocks:</p>
			<ul>
				<li><strong class="bold">Hypertext Markup Language</strong> (<strong class="bold">HTML</strong>): HTML, as the full form states, is a mark<a id="_idTextAnchor1235"/>up<a id="_idIndexMarker991"/> language that browsers can understand and display the contents. It primarily consists of a series of tags, which <a id="_idTextAnchor1236"/>are known <a id="_idIndexMarker992"/>as <strong class="bold">HTML elements</strong>, and allows developers to define the structure of the page. For example, if you want to create a form that needs to allow the user to enter their first name and last name, it can be defined by using input HTML elements.</li>
				<li><strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>): The<a id="_idIndexMarker993"/> presentation layer is all about presenting data in a way that makes a web application more appealing to users and en<a id="_idTextAnchor1237"/>sures that the application is usable, irrespective of the device/resolution that a user tries to load the application in. This is where CSS plays a critical role in defining how the content is displayed on the browser. It controls various things, such as the styling of the pages, the theme of the application, and the color palette, and, more importantly, makes them responsive so that users have the same experience using the application, be it loaded on a mobile or a desktop.</li>
			</ul>
			<p>The good thing <a id="_idIndexMarker994"/>about modern web development is we don't need to write everythin<a id="_idTextAnchor1238"/>g from scratch and many libraries are available that can be picked and used as they are, in the application. We will be using one such library for an e-commerce application, which is explained in the <em class="italic">Creating a UI using ASP.NET Core MVC</em> section.</p>
			<ul>
				<li><strong class="bold">JavaScript</strong>: JavaScript is <a id="_idIndexMarker995"/>a scripting language that helps in performing various advanced dynamic operations, for example, validating input text entered in a form or<a id="_idTextAnchor1239"/> things such as enabling/disabling HTML elements conditionally or retrieving data from an API. JavaScript gives more power to web pages and adds many programming features that a developer can use to perform advanced operations on the client side. Just like HTML and CSS, all browsers can understand JavaScript, which forms an important part of the presentation layer. All these components can be linked to each other, as shown in the following di<a id="_idTextAnchor1240"/>agram:</li>
			</ul>
			<div>
				<div id="_idContainer149" class="IMG---Figure">
					<img src="image/Figure_11.1_B18507.jpg" alt="Figure 11.1 – HTML, CSS, and JavaScript&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – HTML, CSS, and JavaScript</p>
			<p class="callout-heading">Note</p>
			<p class="callout">HTML, CSS, and JavaScript all go hand in hand and play an important role in developing client-side/frontend applications and would require dedicated books to explain fully. Some related links can be found in the <em class="italic">Further reading</em> section.</p>
			<p>Now that we <a id="_idIndexMarker996"/>understand the importance of HTML, CSS, and JavaScript, we need to know how we can use them to build the presentation layer of a web application so that it can support multiple browsers and devices with different resolutions and is able to manage the state (HTTP being stateless). </p>
			<p>One technique could be to create all the HTML pages a<a id="_idTextAnchor1241"/>nd host them on a web server; however, while this works well with static sites and also involves building everything from the ground up, if we want the content to be more dynamic and want a rich UI, we need to use technologies that can generate the HTML pages dynamically and provide seamless support to interact with the backend. Let's look, in the next section, at various technologies that can be used to generate dynami<a id="_idTextAnchor1242"/><a id="_idTextAnchor1243"/>c HTML.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor1244"/>Razor syntax</h2>
			<p>Before<a id="_idIndexMarker997"/> we start understanding the various possible frameworks provided by ASP.NET Core, let's first understand what the Razor syntax is. It is a<a id="_idIndexMarker998"/> markup syntax to embed server-side c<a id="_idTextAnchor1245"/>omponents into HTML. We can use <a id="_idTextAnchor1246"/>the Razor syntax to bind any dynamic data for display or send it back to the server from a view/page for further processing. The Razor syntax is primarily written in Razor files/Razor view pages, which are nothing more than files used by C# to generate dynamic HTML. They go with the <strong class="source-inline">.cshtml</strong> extension and support the Razor syntax. The Razor <a id="_idTextAnchor1247"/>syntax is processed by an engine called <a id="_idIndexMarker999"/>the <strong class="bold">view engine</strong>, and t<a id="_idTextAnchor1248"/>he default view engine is known as the <strong class="bold">Razor engine</strong>.</p>
			<p>To embed <a id="_idIndexMarker1000"/>the Razor syntax, we typically use <strong class="source-inline">@</strong>, which tells the Razor engine to parse and generate HTML out of the engine. <strong class="source-inline">@</strong> can be followed by any C# built-in methods to generate HTML. For example, <strong class="source-inline">&lt;b&gt;@DateTime.Now&lt;/b&gt;</strong> can be used to display the current date and time in a Razor view/page. Apart from this, just like C#, the Razor syntax also supports code blocks and controls structures and variables, among other things. Some sample Razor syntax going through the Razor engine is shown in the followi<a id="_idTextAnchor1249"/>ng figure:</p>
			<div>
				<div id="_idContainer150" class="IMG---Figure">
					<img src="image/Figure_11.2_B18507.jpg" alt="Figure 11.2 – Razor syntax&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – Razor syntax</p>
			<p>The <a id="_idIndexMarker1001"/>R<a id="_idTextAnchor1250"/>azor syntax<a id="_idIndexMarker1002"/> also supports defining HTML controls; for example, to define a textbox, we can use the following Razor syntax:</p>
			<pre class="source-code">&lt;input asp-for=' FirstName ' /&gt;</pre>
			<p>T<a id="_idTextAnchor1251"/>he preceding code is known as an <strong class="source-inline">input</strong> tag helper and the Razor syntax takes care of what is known as <strong class="bold">directive</strong> tag helpers to bind data to an HTML control and generate rich, dynamic HTML. Let's discuss this briefly:</p>
			<ul>
				<li><strong class="bold">Directives</strong>: Under <a id="_idIndexMarker1003"/>the hood, each Razor view/page is parsed by the Razor engine, and <a id="_idTextAnchor1252"/>a C# class is used to generate dynamic HTML and then send it back to the browser. Directives can be used to control the behavior of this class, which further controls the dynamic HTML that is generated.</li>
			</ul>
			<p>For example, the <strong class="source-inline">@using</strong> directive can be used to include any namespaces in the Razor view/page, or the <strong class="source-inline">@code</strong> directive can be used to include any C# members.</p>
			<p>One of the most used directives is <strong class="source-inline">@model</strong>, which allows you to bind a model to a view, which helps in validating the type of view as well <a id="_idTextAnchor1253"/>as helps with IntelliSense. This process <a id="_idIndexMarker1004"/>of binding views to a specific class/model is known as <strong class="bold">strongly typing</strong> views. We will be strongly typing all our views in our e-commerce application, which we will see in the <em class="italic">Creating a UI using ASP.NET Core MVC</em> section.</p>
			<ul>
				<li><strong class="bold">Tag helpers</strong>: If you <a id="_idIndexMarker1005"/>used ASP.NET MVC before ASP.NET Core, you would h<a id="_idTextAnchor1254"/>ave come across HTML helpers, which are classes that help to bind data and generate HTML controls.</li>
			</ul>
			<p>However, with <a id="_idIndexMarker1006"/>ASP.NET Core, we have tag helpers, which help us to bind data to an HTML control. The benefit of tag helpers over HTML helpers is that tag helpers<a id="_idIndexMarker1007"/> use the same syntax as HTML with additional attributes assigned to the standard HTML controls that can be generated from dynamic data. For example, to generate an HTML textbox control, typically, we write the following code:</p>
			<p class="source-code">&lt;input type='text' id='Name' name='Name' value=' Mastering enterprise application development Book'&gt;</p>
			<p>Using tag helpers, this would be rewritten as shown in the following code, where <strong class="source-inline">@Name</strong> is the property of the model that the view is strongly typed to:</p>
			<p class="source-code">&lt;input type='text' asp-for='@Name'&gt;</p>
			<p>So, as you can see, it's all about writing HTML but taking advantage of Razor m<a id="_idTextAnchor1255"/>arkup to generate dyna<a id="_idTextAnchor1256"/>mic HTML. ASP.NET Core comes with many built-in tag helpers, and more details about them can be found here: <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/built-in/?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/built-in/?view=aspnetcore-6.0</a>.</p>
			<p>I<a id="_idTextAnchor1257"/>t is not required to know about/remember every tag helper, and we will use this reference documentation as and when we develop our application UI.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since Razor syntax is markup, it's not necessary to know all the syntax. The foll<a id="_idTextAnchor1258"/>owing link can be used as a reference for Razor syntax: <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-6.0</a>.</p>
			<p>With this, let's look into the various options in ASP.NET Core as well as other common frameworks to develop the pr<a id="_idTextAnchor1259"/><a id="_idTextAnchor1260"/>esentation layer.</p>
			<h2 id="_idParaDest-210">Exploring Razor Pag<a id="_idTextAnchor1261"/>es</h2>
			<p>Razor Pages<a id="_idIndexMarker1008"/> is <a id="_idTextAnchor1262"/>the default way to implement a web <a id="_idIndexMarker1009"/>application using ASP.NET Core. Razor Pages relies on the concept of having a Razor file that can serve requests directly and an optional C# file associated with that Razor file for any additional processing. A typical Razor application can be created with the following command:</p>
			<pre class="source-code"><strong class="bold">dotnet new webapp</strong> <strong class="bold">--framework net6.0 -o RazorSample</strong> </pre>
			<p>As you can see, the project has Razor pages and their corresponding C# files. On opening any Razor view, we see a directive called <strong class="source-inline">@page</strong>, which helps in browsing the page. So, for example, <strong class="source-inline">/index</strong> will be routed to <strong class="source-inline">index.cshtml</strong>. It's important that all Razor pages have the <strong class="source-inline">@page</strong> directive at the top of the page and are placed in the <strong class="source-inline">Pages</strong> folder, as the ASP.NET Core runtime looks for all the Razor pages in this folder.</p>
			<p>A Razor page can be further associated with a C# class, also known as a <strong class="source-inline">PageModel</strong> class, by using another directive called <strong class="source-inline">@model</strong>. The following is the code for the <strong class="source-inline">index.cshtml</strong> page:</p>
			<pre class="source-code">@page</pre>
			<pre class="source-code">@model IndexModel</pre>
			<pre class="source-code">@{</pre>
			<pre class="source-code">    ViewData["Title"] = "Home page";</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">&lt;form method="post"&gt;</pre>
			<pre class="source-code">    &lt;div class="text-center"&gt;</pre>
			<pre class="source-code">        &lt;select asp-for="WeekDaySelected" </pre>
			<pre class="source-code">          asp-items="Model.WeekDay"&gt;&lt;/select&gt;</pre>
			<pre class="source-code">        &lt;button type=Submit name="Submit"&gt;Submit&lt;/button&gt;</pre>
			<pre class="source-code">        &lt;br&gt;</pre>
			<pre class="source-code">        &lt;h3&gt;@ViewData["Message"]&lt;/h3&gt;</pre>
			<pre class="source-code">    &lt;/div&gt;</pre>
			<pre class="source-code">&lt;/form&gt;</pre>
			<p><a id="_idTextAnchor1263"/>The <strong class="source-inline">PageModel</strong> cl<a id="_idTextAnchor1264"/>ass is nothing more than a C# class that can have specific methods for <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> calls <a id="_idIndexMarker1010"/>so that data on the Razor page can be dynamically fetched, say, from an API. This class needs to be inherited by <strong class="source-inline">Microsoft.AspNetCore.Mvc.RazorPages.PageModel</strong> and is a standard C# class. <strong class="source-inline">PageModel</strong> for <strong class="source-inline">index.cshtml</strong>, which is part of <strong class="source-inline">index.cshtml.cs</strong>, is shown in the<a id="_idIndexMarker1011"/> following code:</p>
			<pre class="source-code">public class IndexModel : PageModel</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    public IndexModel(ILogger&lt;IndexModel&gt; logger)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public List&lt;SelectListItem&gt; WeekDay { get; set; }</pre>
			<pre class="source-code">    public void OnGet()</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        this.WeekDay = new List&lt;SelectListItem&gt;();</pre>
			<pre class="source-code">        this.WeekDay.Add(new SelectListItem</pre>
			<pre class="source-code">                              {</pre>
			<pre class="source-code">                                  Value = 'Monday',</pre>
			<pre class="source-code">                                  Text =  'Monday'</pre>
			<pre class="source-code">                              });</pre>
			<pre class="source-code">        this.WeekDay.Add(new SelectListItem</pre>
			<pre class="source-code">                              {</pre>
			<pre class="source-code">                                  Value = 'Tuesday',</pre>
			<pre class="source-code">                                  Text =  'Tuesday'</pre>
			<pre class="source-code">                              });                                  </pre>
			<pre class="source-code">                              </pre>
			<pre class="source-code">    <a id="_idTextAnchor1265"/>}</pre>
			<pre class="source-code">}    </pre>
			<p>Here, you can see t<a id="_idTextAnchor1266"/>hat we are populating additional data that was used on the Razor page via the <strong class="source-inline">OnGet</strong> method, which is also known as a <strong class="source-inline">PageModel</strong> handler and can be used for the initialization of the Razor page. Like <strong class="source-inline">OnGet</strong>, we can add an <strong class="source-inline">OnPost</strong> handler that <a id="_idIndexMarker1012"/>can be used to submit data back from the Razor page to <strong class="source-inline">PageModel</strong> and further the process.</p>
			<p>The <strong class="source-inline">OnPost</strong> method <a id="_idIndexMarker1013"/>will automatically bind all the properties in the <strong class="source-inline">PageModel</strong> class if they meet the following two conditions:</p>
			<ul>
				<li>The property is annotated with the <strong class="source-inline">BindProperty</strong> attribute.</li>
				<li>The Razor page has an HTML control with the same name as the property.</li>
			</ul>
			<p>So, for example, if we wanted to bind the value of the <strong class="source-inline">select</strong> control in the preceding code, we need to first add a property to the <strong class="source-inline">PageModel</strong> class, as shown in the following code:</p>
			<pre class="source-code">[BindProperty]</pre>
			<pre class="source-code">public string WeekDaySelected { get; set; }</pre>
			<p>Then, use the property name for the <strong class="source-inline">select</strong> control, as shown here, and Razor Pages will automatically bind the selected value to this property:</p>
			<pre class="source-code">&lt;select asp-for='WeekDaySelected' asp-items='Model.WeekDay'&gt;&lt;/select&gt;</pre>
			<p>We can use an asynchronous naming convention for the <strong class="source-inline">OnGet</strong> and <strong class="source-inline">OnPost</strong> methods so that they can be named as <strong class="source-inline">OnGetAsync/OnPostAsync</strong> if we are using asynchronous programming.</p>
			<p>Razor Pages also supports calling methods based on the verb. The patt<a id="_idTextAnchor1267"/>ern for the method name should follow the <strong class="source-inline">OnPost[handler]/OnPost[handler]Async</strong> convention, where <strong class="source-inline">[handl<a id="_idTextAnchor1268"/>er]</strong> is the value set on the <strong class="source-inline">asp-page-handler</strong> attribute of any tag helper.</p>
			<p>For example, the following code will call the <strong class="source-inline">OnPostDelete/OnPostDeleteAsync</strong> method from the corresponding <strong class="source-inline">PageModel</strong> class:</p>
			<pre class="source-code">&lt;input type='submit' asp-page-handler='Delete' val<a id="_idTextAnchor1269"/>ue='Delete' /&gt;s</pre>
			<p>For the services <a id="_idIndexMarker1014"/>configuration part, Razor Pages can be configured using the <strong class="source-inline">AddRazorPages</strong> method in the <strong class="source-inline">Program</strong> class by adding the service to the <a id="_idIndexMarker1015"/>ASP.NET Core <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) container. Furthermore, <strong class="source-inline">MapRazorPages</strong> middleware needs to be injected for the Razor pages endpoint in the <strong class="source-inline">Program</strong> class, as shown in the <a id="_idIndexMarker1016"/>following code. This is done so that all the Razor pages can be requested using the name of the page:</p>
			<pre class="source-code">app.MapRa<a id="_idTextAnchor1270"/>zorPages();</pre>
			<p>This completes a simple Razor page application setup; we saw another sample in <a href="B18507_09_Epub.xhtml#_idTextAnchor860"><em class="italic">Chapter 9</em></a>, <em class="italic">Working with Data in .NET 6</em>, that used Razor Pages to retrieve data from a database <a id="_idIndexMarker1017"/>using <strong class="bold">Entity Framework Core</strong> (<strong class="bold">EF Core</strong>).</p>
			<p>Razor Pages is the easiest form of developing web applications in ASP.NET Core; however, for a more structured form of developing web applications that can handle complex features, we can go with ASP.NET Core MVC. Let's explore developing web apps using ASP.NET Co<a id="_idTextAnchor1271"/><a id="_idTextAnchor1272"/>re MVC in the next section.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor1273"/>Exploring the ASP.NET Core MVC website</h2>
			<p>As the <a id="_idIndexMarker1018"/>name suggests, ASP.NET Core MVC is <a id="_idIndexMarker1019"/>based on the MVC pattern discussed in <a href="B18507_10_Epub.xhtml#_idTextAnchor1040"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating an ASP.NET Core 6 Web API</em>, and is a<a id="_idTextAnchor1274"/> framework in ASP.NET Core to build web applications. We saw in <a href="B18507_10_Epub.xhtml#_idTextAnchor1040"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating an ASP.NET Core 6 Web API</em>, that the ASP.NET Core Web API also uses the MVC pattern; however, A<a id="_idTextAnchor1275"/>SP.NET Core MVC also supports views to display data. The underlying design pattern is the same, where we have a model to hold data, a controller to transfer the data, and views to render and display the data.</p>
			<p>ASP.NET Core MVC supports all the features that were discussed in <a href="B18507_10_Epub.xhtml#_idTextAnchor1040"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating an ASP.NET Core 6 Web API</em>, such as routing, DI, model binding, and model validation, and uses the same bootstrapping technique of using the <strong class="source-inline">Program</strong> class. Like the Web API, .NET 6 application services and middlewares are configured in the <strong class="source-inline">Program</strong> class.</p>
			<p>One of the key differences with MVC is the additional loading of views for which, instead of <strong class="source-inline">AddControllers</strong>, we need to use <strong class="source-inline">AddControllersWithViews</strong> in the <strong class="source-inline">Program</strong> class. An example is sh<a id="_idTextAnchor1276"/>own in the following figure:</p>
			<div>
				<div id="_idContainer151" class="IMG---Figure">
					<img src="image/Figure_11.3_B18507.jpg" alt="Figure 11.3 – MVC request life cycle&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – MVC request life cycle</p>
			<p><strong class="source-inline">AddControllersWithViews</strong> primarily takes care of loading the view<a id="_idTextAnchor1277"/>s and handling the data <a id="_idIndexMarker1020"/>sent by the controller, but <a id="_idIndexMarker1021"/>most importantly, it takes care of config<a id="_idTextAnchor1278"/>uring the Razor engine service that is used to process the Razor syntax in views and generate dynamic HTML.</p>
			<p>Controller actions in ASP.NET Core MVC need to be routed based on the action name passed in the URL, so on the routing part, instead of calling <strong class="source-inline">MapController</strong>, we configure <strong class="source-inline">MapControllerRoute</strong> and pass a pattern to it. So, the default routing configuration in the <strong class="source-inline">UseEndpoints</strong> middleware looks as in the following code snippet:</p>
			<pre class="source-code">app.UseEndpoints(endpoints =&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">endpoints.MapControllerRoute(</pre>
			<pre class="source-code">name: 'default',</pre>
			<pre class="source-code">pattern: '{controller=Products}/{action=Index}/{id?}');</pre>
			<pre class="source-code">});</pre>
			<p>Here, in the pattern, we are telling the middleware that the first part of the URL should be a <strong class="source-inline">controller</strong> name, followed by the action name and an optional <strong class="source-inline">id</strong> parameter. If nothing is passed in the URL, the default route is the <strong class="source-inline">Index</strong> action method of <strong class="source-inline">ProductsController</strong>. So, primarily, this is the convention-based routing we discussed in <a href="B18507_10_Epub.xhtml#_idTextAnchor1040"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating an ASP.NET Core 6 Web API</em>.</p>
			<p>Just like <a id="_idIndexMarker1022"/>Razor Pages, views in <a id="_idIndexMarker1023"/>ASP.NET Core MVC applications su<a id="_idTextAnchor1279"/>pport the Razor syntax and allow strongly typed views; that is, a view can be bound to a model for typ<a id="_idTextAnchor1280"/>e checking, and model properties can be associated with HTML controls with compile-time IntelliSense support.</p>
			<p>Since ASP.NET Core MVC gives more structure to the application, we will be using ASP.NET Core MVC for our presentation layer development, and it is discussed in detail while implementing the presentati<a id="_idTextAnchor1281"/>on layer in subsequent sections.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There is always a common question on which technology to choose for frontend development. The following link has some recommendations around this topic: <a href="https://docs.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/choose-between-traditional-web-and-single-page-apps">https://docs.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/choose-between-traditional-web-and-single-page-apps</a>. All the pros and cons should be evaluated before choosing the frontend technology as there are no one-size-<a id="_idTextAnchor1282"/>fits-all requirements.</p>
			<p>With this foundation, let's move on to the next section, where we will start integrating the backend APIs developed up until <a id="_idTextAnchor1283"/><a id="_idTextAnchor1284"/>now with our presentation layer.</p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor1285"/>Integrating APIs with the service layer</h1>
			<p>In this <a id="_idIndexMarker1024"/>section, we will be developing the <strong class="source-inline">Packt.Ecommerce.Web</strong> ASP.N<a id="_idTextAnchor1286"/>ET Core MVC application, which <a id="_idIndexMarker1025"/>is created by adding the <strong class="source-inline">ASP.NET Core web application(Model-View-Contro<a id="_idTextAnchor1287"/>ller)</strong> template. As we have already developed various APIs needed for the presentation layer, we will first build a wrapper class that will be used to communicate with these APIs.</p>
			<p>This is a single wrapper <a id="_idIndexMarker1026"/>class that will be used to communicate with various APIs, so let's create the contract for this class. For simplicity, we<a id="_idIndexMarker1027"/> will limit the requirements to the most important workflow in our e-commerce application, and that will be as follows:</p>
			<ul>
				<li>The landing page retrieves all products in the system and allows users to search/filter the products.</li>
				<li>View the details of the products, add them to the cart, and be able to add more products to the cart.</li>
				<li>Complete the order and see the invoice.</li>
			</ul>
			<p>To follow a more structured approach, we will segregate various classes and interfaces into separate folders. Let's see how in the following steps:</p>
			<ol>
				<li>To start with, let's add a <strong class="source-inline">Contracts</strong> folde<a id="_idTextAnchor1288"/>r to the <strong class="source-inline">Packt.Ecommerce.Web</strong> p<a id="_idTextAnchor1289"/>roject and add an interface with the name <strong class="source-inline">IECommerceService</strong>. This interface will have the following methods:<p class="source-code">// Method to retrieve all products and filter.</p><p class="source-code">Task&lt;IEnumerable&lt;ProductListViewModel&gt;&gt; GetProductsAsync(string filterCriteria = null);</p><p class="source-code">// Method to get details of specific product.</p><p class="source-code">Task&lt;ProductDetailsViewModel&gt; GetProductByIdAsync(string productId, string productName);</p><p class="source-code">// Method to create and order, this method is primarily used to create a cart which is nothing but an order with order status as 'Cart'.</p><p class="source-code">Task&lt;OrderDetailsViewModel&gt; CreateOrUpdateOrder(OrderDetailsViewModel order);</p><p class="source-code">// Method to retrieve order by ID, also used to retrieve cart/order before checkout.</p><p class="source-code">Task&lt;OrderDetailsViewModel&gt; GetOrderByIdAsync(string orderId);</p><p class="source-code">        Task&lt;InvoiceDetailsViewModel&gt; GetInvoiceByIdAsync(string invoiceId);</p><p class="source-code">// Method to submit cart and create invoice.</p><p class="source-code">Task&lt;InvoiceDetailsViewModel&gt; SubmitOrder(OrderDetailsViewModel order);</p><p class="source-code">// Method to retrieve invoice details by Id.</p><p class="source-code">Task&lt;InvoiceDetailsViewModel&gt; GetInvoiceByIdAsync(string invoiceId);</p></li>
				<li>Now, let's<a id="_idIndexMarker1028"/> add a folder called <strong class="source-inline">Services</strong> and add a class called <strong class="source-inline">EcommerceService</strong>. This class will inherit <strong class="source-inline">IECommerceService<a id="_idTextAnchor1290"/></strong> and implement all the methods.</li>
				<li>As we <a id="_idIndexMarker1029"/>need to call various APIs, we need to make use of<a id="_idIndexMarker1030"/> the <strong class="bold">HttpClient factory</strong>, as mentioned in <a href="B18507_10_Epub.xhtml#_idTextAnchor1040"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating an ASP.NET Core 6 Web API</em>. All the API URLs are maintained in the application settings, so we will also populate <strong class="source-inline">Packt.Ecommerce.Common.Options.ApplicationSettings</strong> using the <strong class="source-inline">options</strong> pattern.</li>
			</ol>
			<p>The <strong class="source-inline">Program<a id="_idTextAnchor1291"/></strong> class will have the following services configured for our MVC application:</p>
			<ul>
				<li><strong class="source-inline">AddControllersWithViews</strong>: This will inject the necessa<a id="_idTextAnchor1292"/>ry services for ASP.NET Core MVC to use controllers and views.</li>
				<li><strong class="source-inline">ApplicationSettings</strong>: This will configure the <strong class="source-inline">ApplicationSettings</strong> class using the <strong class="source-inline">IOptions</strong> pattern with the following code:<p class="source-code">builder.Services.Configure&lt;ApplicationSettings&gt;(this.Configuration.GetSection('ApplicationSettings'));</p></li>
				<li><strong class="source-inline">AddHttpClient</strong>: This will inject <strong class="source-inline">System.Net.Http.IHttpClientFactory</strong> and related classes that will allow us to create an <strong class="source-inline">HttpClient</strong> object. Additionally, we will configure the retry policy and circuit break policy, as discussed in <a href="B18507_10_Epub.xhtml#_idTextAnchor1040"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating an ASP.NET Core 6 Web API</em>.</li>
				<li>Mapping <strong class="source-inline">EcommerceService</strong> to <strong class="source-inline">IECommerceService</strong> using the .NET Core DI container.</li>
			</ul>
			<ol>
				<li value="4">Configure <a id="_idIndexMarker1031"/>the app insights using the following <a id="_idIndexMarker1032"/>code:<p class="source-code">string appinsightsInstrumentationKey = this.Configuration.GetValue&lt;string&gt;('AppSettings:InstrumentationKey');</p><p class="source-code">if (!string.IsNullOrWhiteSpace(appinsightsInstrumentationKey))</p><p class="source-code">            {</p><p class="source-code">                builder.Services.AddLogging(logging =&gt;</p><p class="source-code">                {                                                       logging.AddApplicationInsights(</p><p class="source-code">                  appinsightsInstrumentationKey);</p><p class="source-code">                });                </p><p class="source-code">                   builder.Services</p><p class="source-code">                   .AddApplicationInsightsTelemetry </p><p class="source-code">                   (appinsightsIns<a id="_idTextAnchor1293"/>trumentationKey);</p><p class="source-code">            }</p></li>
			</ol>
			<p>Moving o<a id="_idTextAnchor1294"/>n to the middleware, we will be injecting the following middleware using the <strong class="source-inline">Program</strong> class, apart from the default routing middleware:</p>
			<ul>
				<li><strong class="source-inline">UseStatusCodePagesWithReExecute</strong>:<a id="_idTextAnchor1295"/> This middleware is used to redirect to a<a id="_idIndexMarker1033"/> custom page other than for the <strong class="source-inline">500</strong> error code. We will add a method in <strong class="source-inline">ProductController</strong> in the next section that will be executed and loads the relevant view based on the error code. This middleware takes a string as an input <a id="_idIndexMarker1034"/>parameter, which is nothing more than the route that should be executed in the case of an error, and to pass an error code, it allows a placeholder of <strong class="source-inline">{0}</strong>. So, the middleware configuration would look as follows:<p class="source-code">app.UseStatusCodePagesWithReExecute('/Products/Error/{0}');</p></li>
				<li><strong class="bold">Error handling</strong>: As for<a id="_idIndexMarker1035"/> the presentation<a id="_idIndexMarker1036"/> la<a id="_idTextAnchor1296"/>yer, unlike with the API, we need to redirect users to a custom page that, in the case of runtime failures, has relevant information, such as a user-friendly failure message and a relevant logging ID that can be used to retrieve the actual failure at a later stage. However, in the case of a development environment, we can show the complete error along with the stack. So, we will configure two middlewares as shown in the following code:<p class="source-code">{</p><p class="source-code">if (env.IsDevelopment())</p><p class="source-code">    app.UseDeveloperExceptionPage();</p><p class="source-code">}</p><p class="source-code">else</p><p class="source-code">{</p><p class="source-code">    app.UseExceptionHandler('/Products/Error/500');</p><p class="source-code">}</p></li>
			</ul>
			<p>Here, we can see that for the development environment, we are using the <strong class="source-inline">UseDeveloperExceptionPage</strong> middleware, which will load the full exception stack trace, whereas, for non-development environments, we are using the <strong class="source-inline">UseExceptionHandler</strong> middleware, wh<a id="_idTextAnchor1297"/>ich takes the path of the error action method that needs to be executed. Additionally, here, we don't need our custom error handling middleware, as the ASP.NET Core middleware takes care of logging detailed errors to the logging provider, which is Application Insights in our case.</p>
			<ul>
				<li><strong class="source-inline">UseStaticFiles</strong>: To <a id="_idIndexMarker1037"/>allow various static f<a id="_idTextAnchor1298"/>iles, such as CSS, JavaScript, images, and any other static files, we don't need to go <a id="_idIndexMarker1038"/>through the entire request pipeline, and that is where this middleware comes into play, which allows serving static files and supports short-circuiting the rest of the pipeline for static files.</li>
			</ul>
			<p>Coming back to <a id="_idIndexMarker1039"/>the <strong class="source-inline">EcommerceService</strong> class, let's first define the local variables and the constructor of this class, which will inject the <strong class="source-inline">HTTPClient</strong> factory and <strong class="source-inline">ApplicationSettings</strong> using the following code:</p>
			<pre class="source-code">private readonly HttpClient httpClient;</pre>
			<pre class="source-code">private readonly ApplicationSettings applicationSettings;</pre>
			<pre class="source-code">public ECommerceService(IHttpClientFactory httpClientFactory, IOptions&lt;ApplicationSettings&gt; applicationSettings)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">NotNullValidator.ThrowIfNull(applicationSettings, nameof(applicationSettings));</pre>
			<pre class="source-code">IHttpClientFactory httpclientFactory = httpClientFactory;</pre>
			<pre class="source-code">this.httpClient = httpclientFactory.CreateClient();</pre>
			<pre class="source-code">this.applicationSettings <a id="_idTextAnchor1299"/>= applicationSettings.Value;</pre>
			<pre class="source-code">}</pre>
			<p>Now, to implement me<a id="_idTextAnchor1300"/>thods as per our <strong class="source-inline">IECommerceService</strong> interface, we will use the following steps for the Get APIs:</p>
			<div>
				<div id="_idContainer152" class="IMG---Figure">
					<img src="image/Figure_11.4_B18507.jpg" alt="Figure 11.4 – Get call to API&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4 – Get call to API</p>
			<p>Based on<a id="_idIndexMarker1040"/> the <a id="_idIndexMarker1041"/>steps in the preceding figure, the implementation of <strong class="source-inline">GetProductsAsync</strong>, which is primarily used to retrieve products for the landing page and apply any filters while doing a product search, will look as shown in the following code:</p>
			<pre class="source-code">public async Task&lt;IEnumerable&lt;ProductListViewModel&gt;&gt; GetProductsAsync(string filterCriteria = null)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    IEnumerable&lt;ProductListViewModel&gt; products = new List&lt;ProductListViewModel&gt;();</pre>
			<pre class="source-code">    using var productRequest = new </pre>
			<pre class="source-code">      HttpRequestMessage(HttpMethod.Get, </pre>
			<pre class="source-code">        $'{this.applicationSettings.ProductsApiEndpoint}</pre>
			<pre class="source-code">        ?filterCriteria={filterCriteria}');</pre>
			<pre class="source-code">    var productResponse = await this.httpClient.SendAsync(</pre>
			<pre class="source-code">      productRequest).ConfigureAwait(false);</pre>
			<pre class="source-code">    if (!productResponse.IsSuccessStatusCode)</pre>
			<pre class="source-code">    {        await this.ThrowServiceToServiceErrors(</pre>
			<pre class="source-code">               productResponse).ConfigureAwait(false);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    if (productResponse.StatusCode != </pre>
			<pre class="source-code">      System.Net.HttpStatusCode.NoContent)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        products = await productResponse.Content</pre>
			<pre class="source-code">          .ReadFromJsonAsync&lt;Ienumerable</pre>
			<pre class="source-code">           &lt;ProductListViewModel&gt;&gt;().Config<a id="_idTextAnchor1301"/>ureAwait(false);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    return products;</pre>
			<pre class="source-code">}</pre>
			<p><a id="_idTextAnchor1302"/>For the <strong class="source-inline">POST</strong>/<strong class="source-inline">PUT</strong> APIs, we<a id="_idIndexMarker1042"/> will have similar steps with slight <a id="_idIndexMarker1043"/>modifications, as shown in the following figure:</p>
			<div>
				<div id="_idContainer153" class="IMG---Figure">
					<img src="image/Figure_11.5_B18507.jpg" alt="Figure 11.5 – Post call to API&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.5 – Post call to API</p>
			<p>Based on <a id="_idIndexMarker1044"/>this, the st<a id="_idTextAnchor1303"/>rategy implementation of <strong class="source-inline">CreateOrUpdateOrder</strong>, which is primarily used to create the shopping cart, will look as shown in the<a id="_idIndexMarker1045"/> following code:</p>
			<pre class="source-code">public async Task&lt;OrderDetailsViewModel&gt; CreateOrUpdateOrder(OrderDetailsViewModel order)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    NotNullValidator.ThrowIfNull(order, nameof(order));</pre>
			<pre class="source-code">    using var orderRequest = new </pre>
			<pre class="source-code">      StringContent(JsonSerializer.Serialize(order), </pre>
			<pre class="source-code">      Encoding.UTF8, ContentType);</pre>
			<pre class="source-code">    var orderResponse = await this.httpClient.PostAsync(new </pre>
			<pre class="source-code">      Uri($'{this.applicationSettings.OrdersApiEndpoint}'), </pre>
			<pre class="source-code">      orderRequest).ConfigureAwait(false);</pre>
			<pre class="source-code">    if (!orderResponse.IsSuccessStatusCode)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        await this.ThrowServiceToServiceErrors(</pre>
			<pre class="source-code">          orderResponse).ConfigureAwait(false);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    var createdOrder = await orderResponse.Content</pre>
			<pre class="source-code">      .ReadFromJsonAsync&lt;OrderDetailsViewModel&gt;()</pre>
			<pre class="source-code">      .ConfigureAw<a id="_idTextAnchor1304"/>ait(false);</pre>
			<pre class="source-code">    return createdOrder;</pre>
			<pre class="source-code">}</pre>
			<p>Similarly, we<a id="_idIndexMarker1046"/> will implement <strong class="source-inline">GetProductByIdAsync</strong>, <strong class="source-inline">GetOrder<a id="_idTextAnchor1305"/>ByIdAsync</strong>, <strong class="source-inline">GetInvoiceByIdAsync</strong>, and <strong class="source-inline">SubmitOrder</strong> using <a id="_idIndexMarker1047"/>one of the preceding strategies and using the relevant API endpoints.</p>
			<p>Now, let's create the controllers and action methods that will<a id="_idTextAnchor1306"/><a id="_idTextAnchor1307"/> talk to <strong class="source-inline">EcommerceService</strong> and load the relevant views.</p>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor1308"/>Creating the controller and actions</h1>
			<p>We have already <a id="_idIndexMarker1048"/>seen that routing takes c<a id="_idTextAnchor1309"/>are of mapping the request URI to an action method in a control<a id="_idTextAnchor1310"/>ler, so let's further understand how the action methods then<a id="_idIndexMarker1049"/> load the respective views. As you will have noticed, all the views in the ASP.NET Core MVC project are part of the <strong class="source-inline">Views</strong> folder, and when the action method execution is completed, it simply looks for <strong class="source-inline">Views/&lt;ControllerName&gt;/&lt;Action&gt;.cshtml</strong>.</p>
			<p>For example, an action method mapping to the <strong class="source-inline">Products/Index</strong> route will load the <strong class="source-inline">Views/Products/Index.cshtml</strong> view. This is handled by calling the <strong class="source-inline">Microsoft.AspNetCore.Mvc.Controller.View</strong> method at the end of every action method.</p>
			<p>There are additional overloads and helpe<a id="_idTextAnchor1311"/>r methods that can override this behavior and route to a dif<a id="_idTextAnchor1312"/>ferent view as needed. Before we talk about these helper methods, just like the Web API, each action method in the MVC controller can also return <strong class="source-inline">IActionResult</strong>, which means we can make use of helper methods to redirect to a view. In ASP.NET Core MVC, every controller is inherited by a base class, <strong class="source-inline">Microsoft.AspNetCore.Mvc.Controller</strong>, which comes with a few helper methods, and loading <a id="_idIndexMarker1050"/>a view via an action method is handled by the following helper methods in<a id="_idIndexMarker1051"/> the <strong class="source-inline">Microsoft.AspNetCore.Mvc.Controller</strong> class:</p>
			<ul>
				<li><strong class="source-inline">View</strong>: This method has <a id="_idIndexMarker1052"/>multiple overloads and primarily loads the view from the folder under <strong class="source-inline">Views</strong> based on the controller name. For example, calling this method in <strong class="source-inline">ProductsController</strong> can load any <strong class="source-inline">.cshtml</strong> file from the <strong class="source-inline">Views/Products</strong> folder. Additionally, it can take the name of the view, which can be loaded if required, and supports passing an object that can be retrieved in views by strongly typing the view.</li>
				<li><strong class="source-inline">RedirectToAction</strong>: Although<a id="_idIndexMarker1053"/> the <strong class="source-inline">View</strong> method handles most scenarios, there would be scenarios where we need to call another action method within the same controller or another controller, which is where <strong class="source-inline">RedirectToAction</strong> helps. This method comes with various overloads and allows us to specify the name of the action method, controller method, and object that the action method can receive as route values.</li>
			</ul>
			<p>In short, to load the views and pass data from controllers, we will be passing respective models to the <strong class="source-inline">View</strong> method and, as required, we will use <strong class="source-inline">RedirectToAction</strong> whenever ther<a id="_idTextAnchor1313"/>e is a need to call another action method.</p>
			<p>Now, the ques<a id="_idTextAnchor1314"/>tion is how to handle data retrieval (<strong class="source-inline">GET</strong> calls) versus data submission (<strong class="source-inline">POST</strong> calls), and in ASP.NET Core MVC, all the action methods support annotating with HTTP verbs using the <strong class="source-inline">HttpGet</strong> and <strong class="source-inline">HttpPost</strong> attributes. The following are a few rules that can be used to annotate methods:</p>
			<ul>
				<li>If we want to retrieve data, then the action method is annotated using <strong class="source-inline">HttpGet</strong>.</li>
				<li>If we want to submit data to an action method, it should be annotated using <strong class="source-inline">HttpPost</strong> with the relevant object as the input parameter to that action method.</li>
			</ul>
			<p>Typically, methods that need to send data from a controller to a view should be annotated with <strong class="source-inline">[HttpGet]</strong>, and methods that need to receive data from a view for further submission to the database should be annotated using <strong class="source-inline">[HttpPost]</strong>.</p>
			<p>Now, let's move on to adding the required controllers and implementing them. When we add <strong class="source-inline">Packt.Ecommerce.Web</strong>, it creates a <strong class="source-inline">Controllers</strong> folder with <strong class="source-inline">HomeController</strong> created by default, which we need to delete. Then we need to add the three controllers by right-clicking on the <strong class="source-inline">Controllers</strong> folder, then selecting <strong class="bold">Add</strong> | <strong class="bold">Controller</strong> | <strong class="bold">MVC Controller</strong> | <strong class="bold">Empty</strong>, and naming them <strong class="source-inline">ProductsController</strong>, <strong class="source-inline">CartController</strong>, and <strong class="source-inline">OrdersController</strong>.</p>
			<p>All these <a id="_idIndexMarker1054"/>controllers <a id="_idIndexMarker1055"/>will have the following two common properties, one for logging and one for calling methods of <strong class="source-inline">EcommerceService</strong>. They are further initialized using constructor injection as follows:</p>
			<pre class="source-code">private readonly ILogger&lt;ProductsController&gt; logger;</pre>
			<pre class="source-code">private readonly IECommerceService eCommerceService;</pre>
			<p>Let's now discuss what is defined in each of these controllers:</p>
			<ul>
				<li><strong class="source-inline">ProductsController</strong>: This controller will contain the <strong class="source-inline">public async Task&lt;IActionResult&gt; Index(string searchString, string category)</strong> action method to load the default view for listing all the products, which further supports filtering. There will be another method, <strong class="source-inline">public async Task&lt;IActionResult&gt; De<a id="_idTextAnchor1315"/>tails(string productId, string productName)</strong>, that<a id="_idTextAnchor1316"/> takes the ID and name of the product and loads the details of the specified product. As both these methods are used for retrieving, they will be annotated using <strong class="source-inline">[HttpGet]</strong>. Additionally, this controller will have the <strong class="source-inline">Error</strong> method, as discussed earlier. Since it can receive an error code as an input parameter from the <strong class="source-inline">UseStatusCodePagesWithReExecute</strong> middleware, we will have simple logic to load the views accordingly:<p class="source-code">[Route('/Products/Error/{code:int}')]</p><p class="source-code">public IActionResult Error(int code)</p><p class="source-code">{</p><p class="source-code">    if (code == 404)</p><p class="source-code">    {</p><p class="source-code">        return </p><p class="source-code">          this.View('~/Views/Shared/NotFound.cshtml');</p><p class="source-code">    }</p><p class="source-code">    else</p><p class="source-code">    {</p><p class="source-code">        return </p><p class="source-code">         this.View('~/Views/Shared/Error.cshtml', new </p><p class="source-code">         ErrorViewModel { CorrelationId = </p><p class="source-code">         Activity.Current?.RootId ?? </p><p class="source-code">         this.HttpContext.TraceIdentifier });</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li><strong class="source-inline">CartController</strong>: This controller contains the <strong class="source-inline">public async Task&lt;IActionResult&gt; Index(ProductListViewModel product)</strong> action method to add a product to the cart, where we will create an order with the <a id="_idIndexMarker1056"/>order status set to <strong class="source-inline">'Cart'</strong>, as this needs to receive <a id="_idIndexMarker1057"/>data and further pass it to the API, which will be annotated with <strong class="source-inline">[HttpPost]</strong>. For simplicity, this is left anonymous but can be restricted for the logged-in users. Once the order is created, thi<a id="_idTextAnchor1317"/>s method will make use of the <strong class="source-inline">RedirectToAction</strong> helper method and redirects to the <strong class="source-inline">public async Task&lt;IActionResult&gt; I<a id="_idTextAnchor1318"/>ndex(string orderId)</strong> action method within this controller, which further loads the cart with all the products and the checkout form. This method can also be used to directly navigate to the shopping cart.</li>
				<li><strong class="source-inline">OrdersController</strong>: This is the last controller in the flow, which contains the <strong class="source-inline">public async Task&lt;IActionResult&gt; Create(OrderDetailsViewModel order)</strong> action method to submit the order after filling in the payment details. This method updates the status of the order to <strong class="source-inline">Submitted</strong>, then creates an invoice for the order, and finally, redirects to another action method, <strong class="source-inline">public async Task&lt;IActionResult&gt; Index(string invoiceId)</strong>, which loads the final invoice of <a id="_idIndexMarker1058"/>the <a id="_idIndexMarker1059"/>order and completes the transaction.</li>
			</ul>
			<p>The following diagram represents the flow between vari<a id="_idTextAnchor1319"/>ous methods across controllers to complete the shopping workflow:<a id="_idTextAnchor1320"/></p>
			<div>
				<div id="_idContainer154" class="IMG---Figure">
					<img src="image/Figure_11.6_B18507.jpg" alt="Figure 11.6 – Flow between controller action methods&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.6 – <a id="_idTextAnchor1321"/>Flow between controller action methods<a id="_idTextAnchor1322"/><a id="_idTextAnchor1323"/></p>
			<p>With this knowledge, let's design the views in the next section.</p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor1324"/>Creating a UI using ASP.NET Core MVC</h1>
			<p>Up until now, we <a id="_idIndexMarker1060"/>have defi<a id="_idTextAnchor1325"/>ned a <a id="_idIndexMarker1061"/>service to communicate w<a id="_idTextAnchor1326"/>ith backend APIs and further defined controllers that will pass the data to views using models. Now, let's build various views that will render the data and present it to users.</p>
			<p>To begin <a id="_idIndexMarker1062"/>with, let's see the various components<a id="_idIndexMarker1063"/> that are involved in rendering the views:</p>
			<ul>
				<li>The <strong class="source-inline">Views</strong> folder: All views are part of this folder, with each controller-specific view segregated by a subfolder, and finally, each action method is represented by a <strong class="source-inline">.cshtml</strong> file.</li>
			</ul>
			<p>To add a view, we can right-click on the action method and click <strong class="bold">Add View</strong>, which will automatically create a folder (if it isn't already present) with the name of the controller and add the view. Additionally, while doing this, we can specify the model that the view would be bound to.</p>
			<ul>
				<li>The <strong class="source-inline">Layout</strong> pa<a id="_idTextAnchor1327"/>ge: This is a c<a id="_idTextAnchor1328"/>ommon requirement in a web application where we have a common section across the application, such as a header with a menu or left navigation. To have a modular structure for our pages and to avoid any repetition, ASP.Net Core MVC comes with a layout page that is typically named <strong class="source-inline">_Layout.cshtml</strong> and is part of the <strong class="source-inline">Views/Shared</strong> folder. This page can be used as a parent page for all the views in our MVC project. A typical layout page looks like the one shown in the following code:<p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html lang='en'&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">    &lt;meta charset='utf-8'&gt;</p><p class="source-code">    &lt;meta name='viewport' content='width=device-width, </p><p class="source-code">     initial-scale=1'&gt;</p><p class="source-code">    &lt;meta http-equiv='x-ua-compatible' </p><p class="source-code">     content='ie=edge'&gt;</p><p class="source-code">    &lt;title&gt;Ecommerce Packt&lt;/title&gt;</p><p class="source-code">&lt;/head&gt;</p><p class="source-code">&lt;body class='hold-transition sidebar-mini layout-top-nav'&gt;    </p><p class="source-code">        &lt;!-- Navbar --&gt;        </p><p class="source-code">        &lt;!-- Main content --&gt;        </p><p class="source-code">         @RenderBody()</p><p class="source-code">&lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
			</ul>
			<p>Here, you<a id="_idIndexMarker1064"/> can see that it allows <a id="_idIndexMarker1065"/>us to define the skeleton layout of the application, and then finally, there is a Razor method called <strong class="source-inline">@RenderBody()</strong>, which actually loads the child view. To specify a layout page in any view, we can use the following syntax, which adds <strong class="source-inline">_Layout.cshtml</strong> as a parent page to the v<a id="_idTextAnchor1329"/>iew:</p>
			<p class="source-code">@{</p>
			<p class="source-code">    Layout = '~/Views/Shared/__Layout.cshtml';</p>
			<p class="source-code">}</p>
			<p>However, there is no need to repeat this code in all the views, and that's where <strong class="source-inline">_ViewStart.cshtml</strong> comes in handy. Let's see how it helps in reusing some of the code across views:</p>
			<ul>
				<li><strong class="source-inline">_ViewStart.cshtml</strong>: This is a generic view that is located directly under the <strong class="source-inline">Views</strong> folder and is used by the Razor engine to execute any code that needs to be executed before the code in the view. So, typically, this is used to define the layout page and so, the preceding code can be added to this file so that it gets applied across the application.</li>
				<li><strong class="source-inline">_ViewImports.cshtml</strong>: This is another page that can be used to import any common directives or namespaces across the application. Just like <strong class="source-inline">_ViewStart</strong>, this is also located directly under the root folder; however, both <strong class="source-inline">_ViewStart</strong> and <strong class="source-inline">_ViewImport</strong> can be in one (or more than one) folder and they are executed hierarchically starting from the one in the root views folder to the lower-level one in any subfolders. To enable client-side telemetry using Application Insights, we inject <strong class="source-inline">JavaScriptSnippet</strong> as shown in the following code. We learned about injecting dependent services into views in <a href="B18507_05_Epub.xhtml#_idTextAnchor445"><em class="italic">Chapter 5</em></a>, <em class="italic">Dependency Injection in .NET 6</em>. In the following code, <strong class="source-inline">JavaScriptSnippet</strong> is injected into the view:<p class="source-code">    @inject Microsoft.ApplicationInsights.AspNetCore.JavaScriptSnippet JavaScriptSnippet</p></li>
				<li><strong class="source-inline">wwwroot</strong>: This<a id="_idIndexMarker1066"/> is the root folder of the application, and all the static resources, such as JavaScript, CSS, and any image files, are placed here. This can<a id="_idIndexMarker1067"/> further hold an<a id="_idTextAnchor1330"/>y HTML plugins that we want to use in our application. As we have already configured the <strong class="source-inline">Use<a id="_idTextAnchor1331"/>StaticFiles</strong> middleware in our application, content from the folder can be directly served without any processing. The default template of ASP.NET Core MVC comes with a segregation of folders based on their type; for example, all JavaScript files are placed inside a <strong class="source-inline">js</strong> folder, CSS files are placed in a <strong class="source-inline">css</strong> folder, and so on. We will stick to that folder structure for our application.<p class="callout-heading">Note</p><p class="callout">The process of automa<a id="_idTextAnchor1332"/>tically generating views by right-clicking on the action method and using built-in templates is<a id="_idIndexMarker1068"/> known as <strong class="bold">scaffolding</strong> and can be used if are you new to the Razor syntax. However, creating a view using scaffolding or manually placing it inside <a id="_idTextAnchor1333"/><a id="_idTextAnchor1334"/>the respective folder and strongly typing it results in the same behavior.</p></li>
			</ul>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor1335"/>Setting up AdminLTE, the layout page, and views</h2>
			<p>An important<a id="_idIndexMarker1069"/> thing for <a id="_idTextAnchor1336"/>getting the same look and feel across an application is to choose<a id="_idTextAnchor1337"/> the right styling framework. Doing that not only<a id="_idTextAnchor1338"/> gives a consistent layout but also simplifies the responsive design, which helps in rendering the pages correctly in various resolutions. The ASP.NET Core MVC project template that we are using for <strong class="source-inline">Packt.Ecommerce.Web</strong> comes out of the box with Bootstrap as its styling framework. We will further extend this to a theme known as <strong class="source-inline">AdminLTE</strong>, which comes with some interesting layouts <a id="_idIndexMarker1070"/>and dashboards that can be plugged into our presentation layer.</p>
			<p>Let's perform <a id="_idIndexMarker1071"/>the following steps to integrate <strong class="source-inline">AdminLTE</strong> into our application:</p>
			<ol>
				<li value="1">Download the most recent version of <strong class="source-inline">AdminLTE</strong> from here: <a href="https://github.com/ColorlibHQ/AdminLTE/releases">https://github.com/ColorlibHQ/AdminLTE/releases</a>.</li>
				<li>Extract the ZIP file downloaded in the previous step and navigate to <strong class="source-inline">AdminLTE-3.0.5\dist\css</strong>. Copy <strong class="source-inline">adminlte.min.css</strong> and paste it inside the <strong class="source-inline">wwwroot/css</strong> folder of <strong class="source-inline">Packt.Ecommerce.Web</strong>.</li>
				<li>Navigate to <strong class="source-inline">AdminLTE-3.0.5\dist\js</strong>. Copy <strong class="source-inline">adminlte.min.js</strong> and paste it inside the <strong class="source-inline">wwwroot/js</strong> folder of <strong class="source-inline">Packt.Ecommerce.Web</strong>.</li>
				<li>Navigate to <strong class="source-inline">AdminLTE-3.0.5\dist\img</strong>. Copy the required images and paste them inside the <strong class="source-inline">wwwroot/img</strong> folder of <strong class="source-inline">Packt.Ecommerce.Web</strong>.</li>
				<li>Copy the <strong class="source-inline">AdminLTE-3.0.5\plugins</strong> folder and paste it inside t<a id="_idTextAnchor1339"/>he <strong class="source-inline">wwwroot</strong> folder of <strong class="source-inline">Packt.Ecommerce.Web</strong>.</li>
			</ol>
			<p>More information <a id="_idIndexMarker1072"/>about <strong class="source-inline">Adm<a id="_idTextAnchor1340"/>inLTE</strong> can be found at <a href="https://adminlte.io/docs/2.4/installation">https://adminlte.io/do<span id="_idTextAnchor1341"/>cs/2.4/i<span id="_idTextAnchor1342"/>nstallation</a>.</p>
			<p>Now, navigate<a id="_idIndexMarker1073"/> to the <strong class="source-inline">Views/_Layout.cshtml</strong> page and remove all the existing code and replace it with the code from <strong class="source-inline">Packt.Ecommerce.Web\Views\Shared\_Layout.cshtml</strong>. On a high level, the layout is divided into the following:</p>
			<ul>
				<li>A header with navigation to the home page on the left side</li>
				<li>A search box in the header and a dropdown with search categories in the center</li>
				<li>The shopping cart in the header on the right side</li>
				<li>A breadcrumb trail to display the navigation</li>
				<li>A section to render the child view using <strong class="source-inline">@RenderBody()</strong></li>
			</ul>
			<p>A couple of other<a id="_idIndexMarker1074"/> key things that are needed to complete the integration of the <strong class="source-inline">AdminLTE</strong> template are as follows:</p>
			<ul>
				<li>Add the following styles defined in the <strong class="source-inline">&lt;head&gt;</strong> tag:<p class="source-code">&lt;link rel='stylesheet' href='~/plugins/fontawesome-free/css/all.min.css'&gt;</p><p class="source-code">&lt;link rel='stylesheet' href='~/css/adminlte.min.css'&gt;</p></li>
				<li>Add the following JavaScript files just before the end of the <strong class="source-inline">&lt;body&gt;</strong> tag:<p class="source-code">&lt;!-- REQUIRED SCRIPTS (Order shouldn't matter)--&gt;</p><p class="source-code">&lt;!-- jQuery --&gt;</p><p class="source-code">&lt;script src='~/plugins/jquery/jquery.min.js'&gt;&lt;/script&gt;</p><p class="source-code">&lt;!-- Bootstrap 4 --&gt;</p><p class="source-code">&lt;script src='~/plugins/bootstrap/js/bootstrap.bundle.min.js'&gt;&lt;/script&gt;</p><p class="source-code"><a id="_idTextAnchor1343"/>&lt;!-- AdminLTE App --&gt;</p><p class="source-code">&lt;script src='~/js/adminlte.min.js'&gt;&lt;/script&gt;</p></li>
			</ul>
			<p>With this, we h<a id="_idTextAnchor1344"/>ave the <strong class="source-inline">AdminLTE</strong> theme integrated into our application. To<a id="_idTextAnchor1345"/> render the JavaScript required to enable the client telemetry using Application Insights, add the following code inside the <strong class="source-inline">head</strong> tag of <strong class="source-inline">_Layout.cshtml</strong>:</p>
			<pre class="source-code">    @Html.Raw(JavaScriptSnippet.FullScript)</pre>
			<p>The previous code injects the JavaScript required to send telemetry data from views along with the instrumentation key. Unlike the server side or the client side, the instrumentation key is exposed. Anyone can see the instrumentation key from the browser developer tools. But, this is how client-side telemetry is set up. At this point, the risk of this is that unwanted data can be pushed by a malicious user or attacker as the instrumentation key has write-only access. If you wish to make the client-side telemetry more <a id="_idIndexMarker1075"/>secure, you can expose a secure REST API from your service and log the telemetry events from there. You will learn more about Application Insights features in <a href="B18507_14_Epub.xhtml#_idTextAnchor1674"><em class="italic">Chapter 14</em></a>, <em class="italic">Health and Diagnostics</em>.</p>
			<p>Now, the application layout is ready. Let's now move on to defining various views in the application.</p>
			<h3>Creating the Products/Index view</h3>
			<p>This <a id="_idIndexMarker1076"/>view will be used to list all the <a id="_idIndexMarker1077"/>products available on our e-commerce application and is strongly typed with the <strong class="source-inline">IEnumerable&lt;Packt.Ecommerce.DTO.Models.ProductListViewModel&gt;</strong> model. It uses th<a id="_idTextAnchor1346"/>e <strong class="source-inline">Index</strong> action method of <strong class="source-inline">ProductsController</strong> to retrieve data.</p>
			<p>In this view, we will use a simple Razor <strong class="source-inline">@foreach (var item in Model)</strong> loop and for each product, we will display an image of the product, its name<a id="_idTextAnchor1347"/>, and its price. A sample of this view looks as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer155" class="IMG---Figure">
					<img src="image/Figure_11.7_B18507.jpg" alt="Figure 11.7 – Products view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.7 – Products view</p>
			<p>Here, you can see that there is a search bar and a category dropdown coming from the layout page. Clicking<a id="_idIndexMarker1078"/> on the <a id="_idIndexMarker1079"/>product image will navigate to the <strong class="source-inline">Products/Details</strong> view. To support this navigation, we will make use of <strong class="source-inline">AnchorTagHelper</strong> and pass the product ID and name to the <strong class="source-inline">Details</strong> action method of <strong class="source-inline">ProductsController</strong> to further load the details of th<a id="_idTextAnchor1348"/>e product in the <strong class="source-inline">Products/Details</strong> view.</p>
			<h3>Creating the Products/Details view</h3>
			<p>This <a id="_idIndexMarker1080"/>view will load the details of the <a id="_idIndexMarker1081"/>product based on the product ID and the name passed from the <strong class="source-inline">Products/Index</strong> view. We will be using a sample page from <strong class="source-inline">AdminLTE</strong> as shown here: <a href="https://adminlte.io/themes/dev/AdminLTE/pages/examples/e_commerce.html">https://adminlte.io/themes/dev/AdminLTE/pages/examples/e_commerce.html</a>.</p>
			<p>This page will be strongly typed with <strong class="source-inline">Packt.Ecommerce.DTO.Models.ProductDetailsViewModel</strong> and will display all th<a id="_idTextAnchor1349"/>e details of the product. A sample of this page is shown in the following screenshot:</p>
			<div>
				<div id="_idContainer156" class="IMG---Figure">
					<img src="image/Figure_11.8_B18507.jpg" alt="Figure 11.8 – Product details view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.8 – Product details view</p>
			<p>As you can see, <a id="_idTextAnchor1350"/>there<a id="_idIndexMarker1082"/> is an <strong class="bold">Add to Cart</strong> button here; clicking on it will create the cart for the user and add the item to that cart. Since the cart in our case is nothing but an order, with the status of the order set to <strong class="source-inline">'Cart'</strong>, this will call the <strong class="source-inline">Index</strong> action method of <strong class="source-inline">CartController</strong> to create the cart.</p>
			<p>To pass data <a id="_idIndexMarker1083"/>back to the action method, we will take the help of <strong class="source-inline">FormTagHelper</strong>, which allows us to wrap the page in an HTML form and specify the action and controller that the page can be submitted to using the following code:</p>
			<pre class="source-code">&lt;form asp-action='Index' asp-controller='Cart'&gt;</pre>
			<p>With this code, once the <strong class="bold">Add to Cart</strong> button is clicked, which is of the <strong class="source-inline">Submit</strong> type, the page gets submitted to the <strong class="source-inline">Index</strong> action method of <strong class="source-inline">CartController</strong> to further save it to the database. However, we still need to pass the product details back to the <strong class="source-inline">Index</strong> action method and, for that, we will take the help of <strong class="source-inline">InputTagHelper</strong> and create hidden fields for all the values that need to be passed back to the action method.</p>
			<p>The most important thing here is that the name of the hidden variable should match the name of the <a id="_idIndexMarker1084"/>property in the model, so we will be adding the following code inside the form to pass the<a id="_idIndexMarker1085"/> product values back to the controller:</p>
			<pre class="source-code">&lt;input asp-for='Id' type='hidden'&gt;</pre>
			<pre class="source-code">&lt;input asp-for='Name' type='hidden'&gt;</pre>
			<pre class="source-code">&lt;<a id="_idTextAnchor1351"/>input asp-for='Price' type='hidden'&gt;</pre>
			<pre class="source-code">&lt;input asp-for='ImageUrls[0]' type='hidden'&gt;</pre>
			<p>ASP.NET Core MVC's model binding system reads these values and creates the product object needed for the <strong class="source-inline">Index</strong> method of <strong class="source-inline">CartController</strong>, which further calls the backend system to create the order.</p>
			<h3>Creating the Cart/Index view</h3>
			<p>This view<a id="_idIndexMarker1086"/> will<a id="_idIndexMarker1087"/> <a id="_idTextAnchor1352"/>load the cart details and will have a checkout form to fill in all the details and complete the order. Here, we can navigate back to the home page to add more products or complete the order.</p>
			<p>This view is strongly typed <a id="_idTextAnchor1353"/>with <strong class="source-inline">Packt.Ecommerce.DTO.Models.OrderDetailsViewModel</strong> and loads data using the <strong class="source-inline">Index</strong> action method of <strong class="source-inline">OrdersController</strong>. Here, we are using the Bootstrap checkout form example from <a href="https://getbootstrap.com/docs/4.5/examples/checkout/">https://getbootstrap.com/docs/4.5/examples/checkout/</a>.</p>
			<p>This form makes<a id="_idIndexMarker1088"/> use of model validations and HTML attributes to perform validation on the required fields, and we are taking the help of ASP.NET Core MVC tag helpers and a few HTML helpers to render the form. A sample property with model validations would be as shown in the following code:</p>
			<pre class="source-code">public class AddressViewModel</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">        [Required(ErrorMessage = 'Address is required')]</pre>
			<pre class="source-code">        public string Address1 { get; set; }      </pre>
			<pre class="source-code">        [Required(ErrorMessage = 'City is required')]</pre>
			<pre class="source-code">        public string City { get; set; }</pre>
			<pre class="source-code">        [Required(ErrorMessage = 'Country is required')]</pre>
			<pre class="source-code">        public string Country { get; set; }</pre>
			<pre class="source-code">}</pre>
			<p>This model is used in <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/data/Packt.Ecommerce.DTO.Models/OrderDetailsViewModel.cs">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/data/Packt.Ecommerce.DTO.Models/Orde<span id="_idTextAnchor1354"/>rDetailsViewModel.cs</a> and triggers necessary <a id="_idIndexMarker1089"/>validations while placing an order.</p>
			<p>As this form also needs to be submitted, the entire form is wrapped in <strong class="source-inline">FormTagHelper</strong>, as shown in the following code:</p>
			<pre class="source-code">&lt;form asp-action='Create' asp-controller='Orders'&gt;</pre>
			<p>To show these validations on the UI, add the following scripts to <strong class="source-inline">_layout.cshtml</strong> just after all the other scripts we added earlier:</p>
			<pre class="source-code">&lt;script src='~/lib/jquery-validation/dist/jquery.validate.min.js'&gt;&lt;/script&gt;</pre>
			<pre class="source-code">&lt;script src='~/lib/jquery-validation-unobtrusive/jquery.validate.unobtrusive.min.js'&gt;&lt;/script&gt;</pre>
			<p>To display an<a id="_idIndexMarker1090"/> error message, we can make use of a validation message tag helper, as shown in the following code snippet. On the server side, this can be further evaluated using <strong class="source-inline">ModelState.IsValid</strong>:</p>
			<pre class="source-code">&lt;input asp-for='ShippingAddress.Address1' class='form-control' placeholder='1234 Main St'/&gt;</pre>
			<pre class="source-code">&lt;span asp-validation-for='ShippingAddress.Address1' cla<a id="_idTextAnchor1355"/>ss='text-danger'&gt;&lt;/span&gt;</pre>
			<p>A sample of this page would be as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer157" class="IMG---Figure">
					<img src="image/Figure_11.9_B18507.jpg" alt="Figure 11.9 – Cart and checkout page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.9 – Cart and checkout page</p>
			<p>We will use <strong class="source-inline">InputTagHelper</strong> as hidden fields and textboxes to pass any additional in<a id="_idTextAnchor1356"/>formation<a id="_idIndexMarker1091"/> back to the action method. The good thing about textboxes is if the <strong class="source-inline">id</strong> attribute of the <a id="_idIndexMarker1092"/>textbox matches the property name, that data is automatically passed back to the action method and ASP.NET Core MVC's model binding system will take care of mapping it to the required object, which, in this case, is of the <strong class="source-inline">Packt.Ecommerce.DTO.Models.OrderDetailsViewModel</strong> type, which finally submits the order, generates invoices, and redirects to the <strong class="source-inline">Orders/Index</strong> action method.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In the preceding screenshot, although we have a checkout form that includes payment information in production applications, we would be integrating with a third-party payment gateway and, usually, this entire form sits on t<a href="https://razorpay.com/docs/payment-gateway/server-integration/dot-net/">he payment gateway side of the application for <span id="_idIndexMarker1093"/>various security reas</a>ons. <a href="https://stripe.com/docs/api">https://stripe.com/docs/api</a> and <a href="https://razorpay.com/docs/payment-gateway/server-integration/dot-net/">https://razorpay.com/docs/payment-gateway/server-integration/dot-net/</a> are a couple of such third-party providers that help in payment gateway integration.</p>
			<h3>Creating the Orders/Index view</h3>
			<p>Final<a id="_idTextAnchor1357"/>ly, we <a id="_idIndexMarker1094"/>will have the view to <a id="_idIndexMarker1095"/>see the invoice of the order, which is a simple read-only view that displays invoice information sent from the <strong class="source-inline">Ind<a id="_idTextAnchor1358"/>ex</strong> action method of <strong class="source-inline">OrdersController</strong>. A sample of this page is shown in the following screenshot:</p>
			<div>
				<div id="_idContainer158" class="IMG---Figure">
					<img src="image/Figure_11.10_B18507.jpg" alt="Figure 11.10 – Final invoice&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.10 – Final invoice</p>
			<p>This completes the integration of various views and, as you have seen, we have limited the views to the most important flow in <a id="_idTextAnchor1359"/><a id="_idTextAnchor1360"/>the e-commerce application. However, you can further add more features using the same principles.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor1361"/>Understanding Blazor</h1>
			<p>B<a id="_idTextAnchor1362"/>lazor is a<a id="_idIndexMarker1096"/> new framework available from .NET Core 3.1 onward to develop the frontend layer of the application. It's one of the alternatives to MVC and Razor Pages and the application model is very much close to SPA; however, instead of JavaScript, we can write the logic in C# and Razor syntax.</p>
			<p>All the code that is written in Blazor is placed in something called a <strong class="bold">Razor component</strong>, which <a id="_idIndexMarker1097"/>allows you to write the HTML as well as the C# parts of the code to build any web page. A Razor component comes with an extension of <strong class="source-inline">.Razor</strong> and is used to represent the application; be it the entire web page or a small dialog popup, everything is created as a component in Blazor applications. A <a id="_idIndexMarker1098"/>typical Razor component looks like the one in the following code snippet:</p>
			<pre class="source-code">@page '/counter'</pre>
			<pre class="source-code">&lt;h1&gt;Counter&lt;/h1&gt;</pre>
			<pre class="source-code">&lt;p&gt;Current count: @currentCount&lt;/p&gt;</pre>
			<pre class="source-code">&lt;button class='btn btn-primary' @onclick='IncrementCount'&gt;Click me&lt;/button&gt;</pre>
			<pre class="source-code">@code {</pre>
			<pre class="source-code">    private int currentCount = 0;</pre>
			<pre class="source-code">    private void IncrementCount()</pre>
			<pre class="source-code">    {        currentCount++;    }</pre>
			<pre class="source-code">}</pre>
			<p>In this code, we are creating a page that increments a counter on the click of a button, and the logic for the click event is handled in the C# code, which update<a id="_idTextAnchor1363"/>s the value in HTML. This page can be accessed using the <strong class="source-inline">/counter</strong> relative URL.</p>
			<p>The major difference between Blazor and other MVC/Razor Pages is that unlike the request-response model, where every request is sent to the server and HTML is sent back to the browser, Blazor packages all the components (just like SPA) and loads them on the client-side. When the application is requested for the first time, any subsequent calls to the server are to retrieve/submit any API data or to update the DOM. Blazor supports the follow<a id="_idTextAnchor1364"/>ing two hosting models:</p>
			<ul>
				<li><strong class="bold">Blazor WebAssembly</strong> (<strong class="bold">WASM</strong>): WASM <a id="_idIndexMarker1099"/>is low-level instructions that can be run on <a id="_idIndexMarker1100"/>modern browsers, which further helps to run code written in high-level languages such as C# on a browser without any additional plugins. The Blazor WASM hosting model makes use of the open web standards given by WASM and runs the C# code of any Blazor WASM application in a sandbox environment on a browser. At a high level, all the Blazor components are compiled into .NET assemblies and are downloaded to the browser, and WASM loads the .NET Core runtime and loads all the assemblies. It further uses JavaScript interop to refresh the DOM; the o<a id="_idTextAnchor1365"/>nly calls to the <a id="_idIndexMarker1101"/>server would be any backend APIs. The architecture is shown in the following figure:</li>
			</ul>
			<div>
				<div id="_idContainer159" class="IMG---Figure">
					<img src="image/Figure_11.11_B18507.jpg" alt="Figure 11.11 – Blazor WASM hosting&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.11 – Blaz<a id="_idTextAnchor1366"/>or WASM hosting</p>
			<ul>
				<li><strong class="bold">Blazor Server</strong>: In <a id="_idIndexMarker1102"/>the Blazor Server hosting model, the Blazor application is hosted on a web server where the compilation happens, and then the client makes use of SignalR to receive the updates from the server. To keep the connection alive, Blazor creates a JavaScript file called <strong class="source-inline">blazor.server.js</strong> and uses SignalR to receive all the DOM updates, and this further means that every user interac<a id="_idTextAnchor1367"/>tion will have a server call (although very light). The architecture is shown in the following figure:</li>
			</ul>
			<div>
				<div id="_idContainer160" class="IMG---Figure">
					<img src="image/Figure_11.12_B18507.jpg" alt="Figure 11.12 – Blazor Server hosting&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.12 – Blazor Server hosting</p>
			<p>.NET 6 comes with<a id="_idIndexMarker1103"/> full tooling support for both hosting models, with their own project templates, and has its pros and cons, which are further explained <a id="_idTextAnchor1368"/>here: <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-6.0</a>.</p>
			<p>Let's now create a <a id="_idIndexMarker1104"/>frontend application as per the following steps using a Blazor Server application, which allows us to add/modify product details for our e-commerce application:</p>
			<ol>
				<li value="1">Add a new Blazor Server application called <strong class="source-inline">Packt.Ecommerce.Blazorweb</strong> to the enterprise solution and add the <strong class="source-inline">Products.razor</strong>, <strong class="source-inline">AddProduct.Razor</strong>, and <strong class="source-inline">EditProduct.razor</strong> Razor components to the <strong class="source-inline">Pages</strong> folder.</li>
				<li>This project contains the <strong class="source-inline">Program</strong> class, which is exactly like any other ASP.NET Core application with a few additional Blazor <a id="_idTextAnchor1369"/>services. <strong class="source-inline">_Host.cshtml</strong> is the root of the application and an initial call to the application is received by this page and is responded to with HTML. This page further references the <strong class="source-inline">blazor.server.js</strong> script file for the SignalR connection. Another important component is the <strong class="source-inline">App.Razor</strong> component, which takes care of routing based on the URL. In Blazor, any component that needs to be mapped to a specific URL will have the <strong class="source-inline">@page</strong> directive at the beginning of the component, which specifies the relative URL of the application. <strong class="source-inline">App.Razor</strong> intercepts the URLs and routes them to the specified component. All Razor components are part of a <strong class="source-inline">Pages</strong> folder, and the <strong class="source-inline">Data</strong> folder comes with a sample model and a service that is used in the <strong class="source-inline">FetchData.razor</strong> component.</li>
				<li>Let's add <a id="_idIndexMarker1105"/>the following code to <strong class="source-inline">NavMenu.razor</strong> to add the <strong class="source-inline">Products</strong> navigation to the left menu. At this stage, if you run the application, you should be able to see the left menu with the <strong class="source-inline">Products</strong> navigation; however, it will not navigate to any page:<p class="source-code">&lt;li class='nav-item px-3'&gt;</p><p class="source-code">&lt;NavLink class='nav-link' href='prod<a id="_idTextAnchor1370"/>ucts'&gt;</p><p class="source-code">  &lt;span class='oi oi-list-rich' aria-</p><p class="source-code">   hidden='true'&gt;&lt;/span&gt; Products</p><p class="source-code">&lt;/NavLink&gt;</p><p class="source-code">&lt;/li&gt;</p></li>
				<li>As we are going to retrieve data from the API, we need to inject <strong class="source-inline">HTTPClient</strong> into our <strong class="source-inline">Program</strong> class, just as how it's done in ASP.NET Core applications. So, add the following code to the <strong class="source-inline">Program</strong> class:<p class="source-code">builder.Services.AddHttpClient("Products", client =&gt;</p><p class="source-code">{</p><p class="source-code">    client.BaseAddress = new Uri(builder.Configuration["ApplicationSettings:ProductsApiEndpoint"]);</p><p class="source-code">});</p></li>
				<li>Add the following setting of <strong class="source-inline">ApplicationSettings:ProductsApiEndpoint</strong> to <strong class="source-inline">appsettings.json</strong>:<p class="source-code">'ApplicationSettings': {</p><p class="source-code">    'ProductsApiEndpoint': </p><p class="source-code">    'https://localhost:7256/api/products/'</p><p class="source-code">  },</p></li>
				<li>Since we are going to bind the <strong class="source-inline">products</strong> data, let's add <strong class="source-inline">Packt.Ecommerce.DTO.Models</strong> as a project reference to <strong class="source-inline">Packt.Ecommerce.Blazorweb</strong>. In the <strong class="source-inline">Pages</strong> folder, add the following code to the <strong class="source-inline">Products.razor</strong> page inside the <strong class="source-inline">@code</strong> block in which we are creating a <strong class="source-inline">HttpClient</strong> object using <strong class="source-inline">IHttpClientFactory</strong>, which will be injected<a id="_idIndexMarker1106"/> in the next step, and retrieving the <strong class="source-inline">products</strong> data in the <strong class="source-inline">OnInitializedAsync</strong> method:<p class="source-code">private List&lt;ProductListViewModel&gt; products;</p><p class="source-code">protected override async Task OnInitializedAsync()</p><p class="source-code">    {</p><p class="source-code">        var client = Factory.CreateClient('Products');</p><p class="source-code">        var result = await </p><p class="source-code">          client.GetAsync('').ConfigureAwait(false);</p><p class="source-code">        result.EnsureSuccessStatusCode();</p><p class="source-code">        products = new List&lt;ProductListViewModel&gt;();</p><p class="source-code">        products = await </p><p class="source-code">          result.Content.ReadFr<a id="_idTextAnchor1371"/>omJsonAsync</p><p class="source-code">          &lt;List&lt;ProductListViewModel&gt;&gt;()</p><p class="source-code">          .ConfigureAwait(false);</p><p class="source-code">    }</p></li>
				<li>Next, add the following code at the beginning of the <strong class="source-inline">Products.Razor</strong> page (outside the <strong class="source-inline">@code</strong> block). Here, we set the relative route for this component via the <strong class="source-inline">@page</strong> directive to <strong class="source-inline">/products</strong>. Next, we inject <strong class="source-inline">IHttpClientFactory</strong> and the other required namespaces, then add the HTML part<a id="_idIndexMarker1107"/> that renders the list of products. As you can see, it's a mixture of HTML and Razor syntax:<p class="source-code">@page '/products'</p><p class="source-code">@inject IHttpClientFactory Factory</p><p class="source-code">@using System.Net.Http.Json;@using Packt.Ecommerce.DTO.Models;</p><p class="source-code">&lt;h1&gt;Products&lt;/h1&gt;</p><p class="source-code">&lt;div&gt;    &lt;a class='btn btn-info' href='addproduct'&gt;&lt;i class='oi oi-plus'&gt;&lt;/i&gt; Add Product&lt;/a&gt; &lt;/div&gt;</p><p class="source-code">@if (products == null)</p><p class="source-code">{ &lt;p&gt;&lt;em&gt;Loading...&lt;/em&gt;&lt;/p&gt; }</p><p class="source-code">else { &lt;table class='table'&gt;&lt;thead&gt;&lt;tr&gt;</p><p class="source-code">                &lt;th&gt;Id&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;</p><p class="source-code">                &lt;th&gt;Price&lt;/th&gt;&lt;th&gt;Quantity&lt;/th&gt;</p><p class="source-code">                &lt;th&gt;ImageUrls&lt;/th&gt;&lt;th&gt;&lt;/th&gt;</p><p class="source-code">            &lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;</p><p class="source-code">            @foreach (var product in products)</p><p class="source-code">            {&lt;tr&gt;</p><p class="source-code">                   &lt;td&gt;@product.Id&lt;/td&gt;</p><p class="source-code">                    &lt;td&gt;@product.Name&lt;/td&gt;</p><p class="source-code">                    &lt;td&gt;@product.Price&lt;/td&gt;</p><p class="source-code">                    &lt;td&gt;@product.Quantity&lt;/td&gt;</p><p class="source-code">                    &lt;td&gt;&lt;img </p><p class="source-code">                         src='@product.ImageUrls[0]' </p><p class="source-code">                         class='product-image w-10 </p><p class="source-code">                         col-3' alt='Product' /&gt;&lt;/td&gt;</p><p class="source-code">                    &lt;td&gt;&lt;a class='btn btn-info' </p><p class="source-code">                          href='editproduct/</p><p class="source-code">                          @product.Id/@product.Name'&gt;</p><p class="source-code">                          &lt;i class='oi oi-pencil'&gt;</p><p class="source-code"><a id="_idTextAnchor1372"/>                          &lt;/i&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;</p><p class="source-code">            }</p><p class="source-code">        &lt;/tbody&gt;&lt;/table&gt;<a id="_idTextAnchor1373"/> }</p></li>
			</ol>
			<p>At this <a id="_idIndexMarker1108"/>point, if you run the application, you should see the output shown in the following screenshot:</p>
			<div>
				<div id="_idContainer161" class="IMG---Figure">
					<img src="image/Figure_11.13_B18507.jpg" alt="Figure 11.13 – Product list Blazor UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.13 – Product list Blazor UI</p>
			<ol>
				<li value="8">Next, let's create the <strong class="source-inline">Add/Edit</strong> pages in which we will make use of Blazor forms. Some of the important tooling/components that are available for forms are the following.</li>
			</ol>
			<p>A Blazor form is created using an out-of-the-box template in Blazor known as <strong class="source-inline">EditForm</strong>, and it can be bound directly to any C# object using a model property. A typical <strong class="source-inline">EditForm</strong> looks as in the following code snippet. Here, we are <a id="_idIndexMarker1109"/>defining to call the <strong class="source-inline">OnSubmit</strong> method when the form is submitted. Let's add this to <strong class="source-inline">AddProduct.razor</strong>:</p>
			<p class="source-code">&lt;EditForm Model='@product' OnSubmit='@OnSubmit'&gt;</p>
			<p class="source-code">&lt;/EditForm&gt;</p>
			<p>Here, <strong class="source-inline">product</strong> is the object of the model that we want to use, which in our case is <strong class="source-inline">Packt.Ecommerce.DTO.Models.ProductDetailsViewModel</strong>. To bind data to any control, we can use a mix of HTML and Razor syntax, as shown in the following code. Here, we are binding the <strong class="source-inline">Name</strong> property of the product object to a textbox and, similarly, the <strong class="source-inline">Category</strong> property to <a id="_idTextAnchor1374"/>the dropdown. Once you enter any value in the textbox or select a value in the dropdown, it is automatically available in these properties to pass it back to any backend API or database. Let's add all the required properties to the HTML element in a similar manner:</p>
			<p class="source-code">&lt;InputText id='category' @bind-Value='product.Name'&gt;&lt;/InputText&gt;</p>
			<p class="source-code">&lt;InputSelect @bind-Value='product.Category'&gt;</p>
			<p class="source-code">&lt;option selected disabled value='-1'&gt; Choose Category&lt;/option&gt;</p>
			<p class="source-code">&lt;option value='Clothing'&gt;Clothing&lt;/option&gt;</p>
			<p class="source-code">&lt;option value='Books'&gt;Books&lt;/option&gt;</p>
			<p class="source-code">&lt;/InputSelect&gt;</p>
			<p>Blazor forms support data validation using data annotations, so any model that we want to bind to the UI can have data annotations, and Blazor applies those validations out of the box to the controls that the property is bound to. To apply validations, we add the <strong class="source-inline">DataAnnotationsValidator</strong> component and can use the <strong class="source-inline">ValidationSummary</strong> component to show a summary of all the validation failures. You can find more details at <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/forms-validation?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/blazor/forms-validation?view=aspnetcore-6.0</a>. We can further use the <strong class="source-inline">ValidationMessage</strong> component at the control level, as shown in<a id="_idIndexMarker1110"/> the following code snippet:</p>
			<p class="source-code">&lt;DataAnnotationsValidator /&gt;</p>
			<p class="source-code">&lt;ValidationSummary /&gt;</p>
			<p class="source-code">&lt;InputNumber id='quantity' @bind-Value='product.Quantity'&gt;&lt;/InputNumber&gt;</p>
			<p class="source-code">&lt;ValidationMessage For='@(() =&gt; product.Quantity)' /&gt;</p>
			<ol>
				<li value="9">In the <strong class="source-inline">code</strong> component, add an object of <strong class="source-inline">ProductDetailsViewModel</strong> and name it as the product, that is, as defined in the <strong class="source-inline">Model</strong> attribute of <strong class="source-inline">EditForm</strong>, and further implement the <strong class="source-inline">OnSub<a id="_idTextAnchor1375"/>mit</strong> method.</li>
			</ol>
			<p>The entire code for <strong class="source-inline">AddProduct.Razor</strong> and <strong class="source-inline">EditProduct.<a id="_idTextAnchor1376"/>Razor</strong> can be found in the GitHub repository, and once we run the application, we can see the following page:</p>
			<div>
				<div id="_idContainer162" class="IMG---Figure">
					<img src="image/Figure_11.14_B18507.jpg" alt="Figure 11.14 – The Add Product Blazor UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.14 – The Add Product Bl<a id="_idTextAnchor1377"/>azor UI</p>
			<p>This is a basic<a id="_idIndexMarker1111"/> sample for building the frontend us<a id="_idTextAnchor1378"/>ing Blazor that performs list, create, and update operations. However, there are many concepts in Bla<a id="_idTextAnchor1379"/><a id="_idTextAnchor1380"/>zor that can be further explored at <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-6.0</a>.</p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor1381"/>Summary</h1>
			<p>In this chapter, we understood various aspects of the presentation layer and UI design. Along with this, we also learned various skills in developing the presentation layer using ASP.NET Core MVC and Razor Pages, and then, finally, we implemented the presentation layer for our enterprise application using ASP.NET Core MVC and Blazor.</p>
			<p>With these skills, you should be able to build the presentation layer using ASP.NET Core MVC, Razor Pages, and Blazor, and integrate it with the backend API.</p>
			<p>In the next<a id="_idTextAnchor1382"/><a id="_idTextAnchor1383"/> chapter, we will see how to integrate authentication in our system across various layers of the application.</p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor1384"/>Questions</h1>
			<ol>
				<li value="1">Which one of the following is a recommended page to define the left-side navigation that needs to appear throughout the web application?</li>
			</ol>
			<p>a. <strong class="source-inline">_ViewStart.cshtml</strong></p>
			<p>b. <strong class="source-inline">_ViewImports.cshtml</strong></p>
			<p>c. <strong class="source-inline">_Layout.cshtml</strong></p>
			<p>d. <strong class="source-inline">Error.cshtml</strong></p>
			<p><strong class="bold">Answer: c</strong></p>
			<ol>
				<li value="2">Which of the following pages can be used to configure the <strong class="source-inline">Layout</strong> page for the entire application?</li>
			</ol>
			<p>a. <strong class="source-inline">_ViewStart.cshtml</strong></p>
			<p>b. <strong class="source-inline">_ViewImports.cshtml</strong></p>
			<p>c. <strong class="source-inline">_Layout.cshtml</strong></p>
			<p>d. <strong class="source-inline">Error.cshtml</strong></p>
			<p><strong class="bold">Answer: a</strong></p>
			<ol>
				<li value="3">Which of the following special characters is used to write Razor syntax in a <strong class="source-inline">.cshtml</strong> page?</li>
			</ol>
			<p>a. <strong class="source-inline">@</strong></p>
			<p>b. <strong class="source-inline">#</strong></p>
			<p>c. <strong class="source-inline">&lt;% %&gt;</strong></p>
			<p>d. None of the above</p>
			<p><strong class="bold">Answer: a</strong></p>
			<ol>
				<li value="4">Which method will be called on a button click in the following tag helper code in a Razor page application?<p class="source-code">&lt;input type='submit' asp-page<a id="_idTextAnchor1385"/><a id="_idTextAnchor1386"/>-handler='Delete' value='Delete' /&gt;</p></li>
			</ol>
			<p>a. <strong class="source-inline">OnGet() </strong></p>
			<p>b. <strong class="source-inline">onDelete()</strong></p>
			<p>c. <strong class="source-inline">OnPostDelete()</strong></p>
			<p>d. <strong class="source-inline">OnDeleteAsync()</strong></p>
			<p><strong class="bold">Answer: c</strong></p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor1387"/>Further reading</h1>
			<ul>
				<li><a href="https://www.packtpub.com/web-development/html5-and-css3-building-responsive-websites">https://www.packtpub.com/web-development/html5-and-css3-building-responsive-websites</a></li>
				<li><a href="https://www.packtpub.com/product/bootstrap-for-asp-net-mvc-second-edition/9781785889479">https://www.packtpub.com/product/bootstrap-for-asp-net-mvc-second-edition/9781785889479</a></li>
				<li><a href="https://developer.mozilla.org/en-US/docs/WebAssembly">https://developer.mozilla.org/en-US/docs/WebAssembly</a></li>
				<li><a href="https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-6.0</a></li>
				<li><a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/views/partial?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/mvc/views/partial?view=aspnetcore-6.0</a></li>
				<li><a href="https://developer.mozilla.org/en-US/docs/Learn/Accessibility">https://developer.mozilla.org/en-US/docs/Learn/Accessibility</a></li>
			</ul>
		</div>
	</body></html>