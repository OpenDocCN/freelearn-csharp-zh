<html><head></head><body>
  <div id="_idContainer474" class="Basic-Text-Frame">
    <h1 class="chapterNumber">9</h1>
    <h1 id="_idParaDest-115" class="chapterTitle">Implementing Game AI for Building Enemies</h1>
    <p class="normal">What is a game if not a great challenge to the player, who needs to use their character’s abilities to tackle different scenarios? Each game imposes different kinds of obstacles on the player, and the main one in our game is the enemies. Creating challenging and believable enemies can be complex; they need to behave like real characters and be smart enough so as not to be easy to kill, but also easy enough that they are not impossible to kill. We are going to use basic but sufficient AI techniques to make an AI capable of <a id="_idIndexMarker469"/>sensing its surroundings and, based on that information, make decisions on what to do, using <strong class="keyWord">FSMs</strong> or <strong class="keyWord">Finite State Machines</strong>, along with <a id="_idIndexMarker470"/>other techniques. Those decisions will be executed using <strong class="keyWord">intelligent pathfinding</strong>.</p>
    <p class="normal">In this chapter, we will examine the following AI concepts: </p>
    <ul>
      <li class="bulletList">Gathering information with sensors</li>
      <li class="bulletList">Making decisions with FSMs</li>
      <li class="bulletList">Executing FSM actions</li>
    </ul>
    <p class="normal">By the end of the chapter, you will have a fully functional enemy capable of detecting the player and attacking them, so let’s start by seeing first how to make the sensor systems.</p>
    <h1 id="_idParaDest-116" class="heading-1">Gathering information with sensors</h1>
    <p class="normal">An AI works by first taking in information about its surroundings. Then, that data is analyzed in order to choose an action, and finally, the chosen action is executed. As you can see, we cannot do anything without information, so let’s start with that part.</p>
    <p class="normal">There are <a id="_idIndexMarker471"/>several sources of information our AI can use, such as data about itself (life and bullets) or maybe some game state (winning condition or remaining enemies), which can easily be found with the code we’ve seen so far. One important source of information, however, is also the AI senses. According to the needs of our game, we might need different senses such as sight and hearing, but in our case, sight will be enough, so let’s learn how to code that.</p>
    <p class="normal">In this section, we will examine the following sensor concepts:</p>
    <ul>
      <li class="bulletList">Creating three-filter sensors with C#</li>
      <li class="bulletList">Creating three-filter sensors with Visual Scripting</li>
      <li class="bulletList">Debugging with gizmos</li>
    </ul>
    <p class="normal">Let’s start by seeing how to create a sensor with the three-filters approach.</p>
    <h2 id="_idParaDest-117" class="heading-2">Creating three-filter sensors with C#</h2>
    <p class="normal">The common way to code senses is through a three-filters approach to discard enemies out <a id="_idIndexMarker472"/>of sight. The first filter <a id="_idIndexMarker473"/>is a distance filter, which will discard <a id="_idIndexMarker474"/>enemies too far away to be seen, then the second filter would be the angle check, which will check enemies inside our viewing cone, and finally, the third filter is a raycast check, which will discard enemies that are being occluded by obstacles such as walls. </p>
    <div class="note">
      <p class="normal">Before starting, a word of advice: we will be using vector mathematics here, and covering those topics in-depth is outside the scope of this book. If you don’t understand something, feel free to just search online for the code in the screenshots.</p>
    </div>
    <p class="normal">Let’s code sensors in the following way:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create an empty <code class="inlineCode">GameObject</code> called <code class="inlineCode">AI</code> as a child of the <strong class="screenText">Enemy</strong> Prefab. You need to first open the Prefab to modify its children (double-click the Prefab). Remember to set the transform of this <code class="inlineCode">GameObject</code> to <strong class="screenText">Position</strong> <strong class="screenText">0,1.75,0</strong>, <strong class="screenText">Rotation</strong> <strong class="screenText">0,0,0</strong>, and <strong class="screenText">Scale</strong> <strong class="screenText">1,1,1</strong> so it will be aligned to the enemy’s eyes. This is done this way for the future sight sensors we will do. Consider your enemy prefab might have a different height for the eyes. While we can certainly just put all AI scripts directly in the <strong class="screenText">Enemy </strong>Prefab root <code class="inlineCode">GameObject</code>, we did this just for separation and organization:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.1: AI scripts container</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Create <a id="_idIndexMarker475"/>a script called <code class="inlineCode">Sight</code> and add it to the <code class="inlineCode">AI</code> child object.</li>
      <li class="numberedList">Create <a id="_idIndexMarker476"/>two fields of the <code class="inlineCode">float</code> type called <code class="inlineCode">distance</code> and <code class="inlineCode">angle</code>, and another two of the <code class="inlineCode">LayerMask</code> type <a id="_idIndexMarker477"/>called <code class="inlineCode">obstaclesLayers</code> and <code class="inlineCode">objectsLayers</code>. <code class="inlineCode">distance</code> will be used as the vision distance, <code class="inlineCode">angle</code> will determine the amplitude of the view cone, <code class="inlineCode">obstacleLayers</code> will be used by our obstacle check to determine which objects are considered obstacles, and <code class="inlineCode">objectsLayers</code> will be used to determine what types of objects we want the <code class="inlineCode">Sight</code> component to detect. 
    <p class="normal">We just want the sight to see enemies; we are not interested in objects such as walls or power-ups. <code class="inlineCode">LayerMask</code> is a property type that allows us to select one or more layers to use inside code, so we will be filtering objects by layer. In a moment, you will see how we use it:</p>
    <figure class="mediaobject"><img src="../Images/B8585_09_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.2: Fields to parametrize our sight check</p>
</li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">In <code class="inlineCode">Update</code>, call <code class="inlineCode">Physics.OverlapSphere</code> as in the <em class="italic">Figure 9.3</em>. </li>
    </ol>
    <p class="normal">This function <a id="_idIndexMarker478"/>creates an imaginary sphere in the place <a id="_idIndexMarker479"/>specified by the first parameter (in our case, our position) and with a radius specified in the second parameter (the distance property) to detect objects with the layers specified in the third parameter (<code class="inlineCode">ObjectsLayers</code>). It will return an array with all the colliders found inside the sphere; these <a id="_idIndexMarker480"/>functions use physics to carry out the check, so the objects must have at least one collider.</p>
    <p class="normal">This is the method we will be using to find all enemies inside our view distance, and we will be further filtering them in the next steps. Note that we are passing our position to the first parameter, which is not actually the position of the enemy but the position of the <code class="inlineCode">AI</code> child object, given our script is located there. This highlights the importance of the position of the AI object.</p>
    <div class="note">
      <p class="normal">Another way of accomplishing the first check is to just check the distance from the objects we want to see to the player, or if looking for other kinds of objects, to a <code class="inlineCode">Manager</code> component containing a list of them. However, the method we chose is more versatile and can be used for any kind of object. </p>
      <p class="normal">Also, you might want to check the <code class="inlineCode">Physics.OverlapSphereNonAlloc</code> version of this function, which does the same but is more performant by not allocating an array to return the results.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Iterate over the array of objects returned by the function using a <code class="inlineCode">for</code> loop:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.3: Getting all GameObjects at a certain distance</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">To detect whether the object falls inside the vision cone, we need to calculate <a id="_idIndexMarker481"/>the angle between our <a id="_idIndexMarker482"/>viewing direction and the <a id="_idIndexMarker483"/>direction from ourselves towards the object itself. If the angle between those two directions is less than our cone angle, we consider that the object falls inside our vision. We will do that in the following steps:
    <p class="normal">Start calculating the direction toward the object, which can be done by normalizing the difference between the object’s position and ours, like in <em class="italic">Figure 9.4</em>. You might notice we used <code class="inlineCode">bounds.center</code> instead of <code class="inlineCode">transform.position</code>; this way, we check the direction to the center of the object instead of its pivot. Remember that the player’s pivot is in the ground and the ray check might collide against it before the player:</p>
    <figure class="mediaobject"><img src="../Images/B8585_09_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.4: Calculating direction from our position toward the collider</p>
</li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">We can use the <code class="inlineCode">Vector3.Angle</code> function to calculate the angle between two directions. In our case, we can calculate the angle between the direction toward <a id="_idIndexMarker484"/>the enemy and our forward vector to see the angle:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.5: Calculating the angle between two directions</p>
    <div class="note">
      <p class="normal">If you want, you can instead use <code class="inlineCode">Vector3.Dot</code>, which will execute a dot product, a mathematics function to calculate the length of a vector projected to another (search online for more info). <code class="inlineCode">Vector3.Angle</code> actually uses that one, but converts the result of the dot product into an angle, which needs to use trigonometry, and that can be time expensive to calculate. But our <code class="inlineCode">Vector3.Angle</code> approach is simpler and faster to code, and given that we don’t require many sensors because we won’t have many enemies, optimizing the sensor using dot products is not necessary now, but consider that for games with larger scale.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Now <a id="_idIndexMarker485"/>check whether the calculated <a id="_idIndexMarker486"/>angle is less than the one specified in the <code class="inlineCode">angle</code> field. Note that if we set an angle of <code class="inlineCode">90</code>, it will actually be <code class="inlineCode">180</code>, because if the <code class="inlineCode">Vector3.Angle</code> function returns, as an example, <code class="inlineCode">30</code>, it could be <code class="inlineCode">30</code> to the left or to the right. If our angle says <code class="inlineCode">90</code>, it could be both <code class="inlineCode">90</code> to the left and to the right, so it will detect objects in a 180-degree arc.</li>
      <li class="numberedList">Use the <code class="inlineCode">Physics.Linecast</code> function to create an imaginary line between the first and the second parameter (our position and the collider position) to detect objects with the layers specified in the third parameter (the obstacle layers) and return <code class="inlineCode">boolean</code> indicating whether that ray hit something or not.
    <p class="normal">The idea is to use the line to detect whether there are any obstacles between ourselves and the detected collider, and if there is no obstacle, this means that we have a direct line of sight toward the object. Observe how we <a id="_idIndexMarker487"/>use the <code class="inlineCode">!</code> or <code class="inlineCode">not</code> operator in <em class="italic">Figure 9.6</em> to check if <code class="inlineCode">Physics.Linecast</code> didn’t detect <a id="_idIndexMarker488"/>any objects. Again, note <a id="_idIndexMarker489"/>that this function depends on the obstacle objects having colliders, which in our case, we have (walls, floor, and so on):</p>
    <figure class="mediaobject"><img src="../Images/B8585_09_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.6: Using a Linecast to check obstacles between the sensor and the target object</p>
</li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">If the object passes the three checks, that means that this is the object we are currently seeing, so we can save it inside a field of the <code class="inlineCode">Collider</code> type called <code class="inlineCode">detectedObject</code>, to save that information for later usage by the rest of the <code class="inlineCode">AI</code> scripts. 
    <p class="normal">Consider using <code class="inlineCode">break</code> to stop the <code class="inlineCode">for</code> loop that is iterating the colliders to prevent wasting resources by checking the other objects, and to set <code class="inlineCode">detectedObject</code> to <code class="inlineCode">null</code> before <code class="inlineCode">for</code> to clear the result from the previous frame. So if in this frame, we don’t detect anything, it will keep the <code class="inlineCode">null</code> value so we notice that there is nothing in the sensor:</p>
</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.7: Full sensor script</p>
    <div class="note">
      <p class="normal">In our case, we are using the sensor just to look for the player, the only object the sensor is in charge of looking for, but if you want to make the sensor more advanced, you can just keep a list of detected objects, placing inside it every object that passes the three tests instead of just the first one. In our case, it’s not necessary given we have only one player in the game.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">In <a id="_idIndexMarker490"/>the editor, configure the sensor at your will. In this case, we will set <code class="inlineCode">ObjectsLayer</code> to <code class="inlineCode">Player</code> so our sensor will focus its search on objects with that <a id="_idIndexMarker491"/>layer, and <code class="inlineCode">obstaclesLayer</code> to <code class="inlineCode">Default</code>, the layer <a id="_idIndexMarker492"/>we used for walls and floors. Remember the <code class="inlineCode">Sight</code> script is in the <code class="inlineCode">AI</code> GameObject, which is a child of the <code class="inlineCode">Enemy</code> prefab:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.8: Sensor settings</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">To test this, just place an enemy with a movement speed of 0 in front of the player, select its <code class="inlineCode">AI</code> child object and then play the game to see how the property is set in the Inspector. Also, try putting an obstacle between the two and check that the property says <strong class="screenText">None</strong> (<code class="inlineCode">null</code>). If you don’t get the expected result, double-check your script, its configuration, and whether the player has the <code class="inlineCode">Player</code> layer, and the obstacles have the <code class="inlineCode">Default</code> layer. Also, you might need to raise the <code class="inlineCode">AI</code> object a little bit to prevent the ray from starting below the ground and hitting it.</li>
    </ol>
    <p class="normal">Given the size of the script, let’s dedicate an entire section to the Visual Scripting version, given it also introduces some new Visual Scripting concepts needed here.</p>
    <h2 id="_idParaDest-118" class="heading-2">Creating Three-Filters sensors with Visual Scripting</h2>
    <p class="normal">Regarding <a id="_idIndexMarker493"/>the Visual Scripting version, let’s <a id="_idIndexMarker494"/>check it part by <a id="_idIndexMarker495"/>part, starting <a id="_idIndexMarker496"/>with the <strong class="keyWord">Overlap Sphere</strong>:</p>
    <figure class="mediaobject"><img src="../Images/B8585_09_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.9: Overlap Sphere in Visual Scripting</p>
    <p class="normal">So far, we just called <strong class="screenText">Overlap Sphere</strong> after setting the <code class="inlineCode">sensedObject</code> variable to <code class="inlineCode">null</code>. Something to consider is how the <code class="inlineCode">sensedObject</code> variable in the <strong class="screenText">Variables</strong> component in the Inspector doesn’t have a type (a <strong class="screenText">Null</strong> type is no type in Visual Scripting). This can’t be possible in C#—all variables must have a type—and while we could set the <code class="inlineCode">sensedObject</code> variable to the proper type (<strong class="screenText">Collider</strong>), we will keep the variable type to be set later via a script. Even if we set the type now, Visual Scripting tends to forget the type if no value is set, and we cannot set it until we detect something.</p>
    <p class="normal">Don’t worry about that for the moment; when we set the variable through our script it will acquire the proper type. Actually, all variables in Visual Scripting can switch types at runtime <a id="_idIndexMarker497"/>according to what we set <a id="_idIndexMarker498"/>them to, given how the <strong class="screenText">Variables</strong> component works. I don’t recommend doing that, though: try to <a id="_idIndexMarker499"/>stick with the intended variable type.</p>
    <div class="note">
      <p class="normal">We just said that all variables in C# must have a type, but that’s not entirely true. There are ways to create dynamically-typed variables, but it’s not a good practice that I’d recommend using unless no other option is present.</p>
    </div>
    <p class="normal">Another thing to observe is how we set the <code class="inlineCode">sensedObject</code> variable to <code class="inlineCode">null</code> at the beginning using the <strong class="screenText">Null </strong>node, which effectively represents the <code class="inlineCode">null</code> value.</p>
    <p class="normal">Now, let’s explore the <code class="inlineCode">Foreach</code> part:</p>
    <figure class="mediaobject"><img src="../Images/B8585_09_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.10: Iterating collections in Visual Scripting</p>
    <p class="normal">We can see that one of the output pins of <strong class="screenText">Overlap Sphere</strong> is a little list, which essentially represents the collider array returned by <strong class="screenText">Overlap Sphere</strong>. We connect that pin to the <strong class="screenText">For Each Loop</strong> node, which as you might imagine iterates over the elements of the provided collection (array, list, dictionary, etc.). The <strong class="screenText">Body</strong> pin represents the nodes to execute in each iteration of the loop, and the <strong class="screenText">Item</strong> output pin represents the item currently being iterated—in our case, one of the colliders detected in <strong class="screenText">Overlap Sphere</strong>. Finally, we save that item in a <strong class="screenText">Flow</strong> <code class="inlineCode">potentialDetection</code> variable, <strong class="screenText">Flow</strong> variables being the equivalent to local variables in C# functions. </p>
    <p class="normal">The idea here is that, given the size of the <a id="_idIndexMarker500"/>graph and the number of times <a id="_idIndexMarker501"/>we will be needing to query <a id="_idIndexMarker502"/>the currently iterated item, we don’t want the line connecting the output <strong class="screenText">Item</strong> pin to the other nodes to cross the entire graph. Instead, we save that item in the <strong class="screenText">Flow</strong> variable to reference it later, essentially naming that value to be referenced later in the graph, which you will see in the next parts of it.</p>
    <p class="normal">Now let’s explore the <strong class="screenText">Angle</strong> check:</p>
    <figure class="mediaobject"><img src="../Images/B8585_09_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.11: Angle check in Visual Scripting</p>
    <p class="normal">Here, you can see a direct translation of what we did in C# to detect the angle, so it should be pretty self-explanatory. The only thing here is given the proximity of the <strong class="screenText">Item</strong> output pin to the <strong class="screenText">Get Position</strong> node where we query its position, we directly connected the node, but <a id="_idIndexMarker503"/>we will use the <code class="inlineCode">potentialDetection</code> flow variable later.</p>
    <p class="normal">Now, let’s <a id="_idIndexMarker504"/>explore <a id="_idIndexMarker505"/>the <strong class="screenText">Linecast</strong> part:</p>
    <figure class="mediaobject"><img src="../Images/B8585_09_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.12: Linecast check in Visual Scripting</p>
    <p class="normal">Again, essentially the same as we did before in C#. The only thing to highlight here is the fact we used the <strong class="screenText">Flow</strong> variable <code class="inlineCode">potentialDetection</code> to again get the position of the current item being iterated, instead of connecting the <strong class="screenText">Get Position</strong> node all the way to the <strong class="screenText">Foreach</strong> <strong class="screenText">Item</strong> output pin. </p>
    <p class="normal">Now, let’s explore the final part:</p>
    <figure class="mediaobject"><img src="../Images/B8585_09_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.13: Setting the sensedObject</p>
    <p class="normal">Again, pretty <a id="_idIndexMarker506"/>much self-explanatory; if the <strong class="screenText">Linecast</strong> returns <code class="inlineCode">false</code>, we set the <code class="inlineCode">potentialDetection</code> variable (the currently iterated item) as the <code class="inlineCode">sensedObject</code> variable (the one that will be accessed by other scripts <a id="_idIndexMarker507"/>later to query which is <a id="_idIndexMarker508"/>the object our AI can see right now). Something to consider here is the usage of the <strong class="screenText">Break Loop</strong> node, which is the equivalent to the C# <code class="inlineCode">break</code> keyword; essentially, we are stopping the<strong class="screenText"> Foreach</strong> loop we are currently in.</p>
    <p class="normal">Now, even if we have our sensor working, sometimes checking whether it’s working or configured properly requires some visual aids we can create using gizmos.</p>
    <h2 id="_idParaDest-119" class="heading-2">Debugging with gizmos</h2>
    <p class="normal">As we create our AI, we will start to detect certain errors in edge cases, usually related to misconfigurations. You may think that the player falls within the sight range of the enemy <a id="_idIndexMarker509"/>but maybe you cannot <a id="_idIndexMarker510"/>see that the line of sight is occluded by an object, especially as the enemies move constantly. A good way to debug those scenarios is through editor-only visual <a id="_idIndexMarker511"/>aids known as <code class="inlineCode">Gizmos</code>, which allow you to visualize invisible data such as the sight distance or the <code class="inlineCode">Linecasts</code> executed to detect obstacles.</p>
    <p class="normal">Let’s start seeing how to create <code class="inlineCode">Gizmos</code> drawing a sphere representing the sight distance by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">In the <code class="inlineCode">Sight</code> script, create an <a id="_idIndexMarker512"/>event function called <code class="inlineCode">OnDrawGizmos</code>. This event is only executed in the editor (not in builds) and is the place Unity asks us to draw <code class="inlineCode">Gizmos</code>.</li>
      <li class="numberedList">Use the <code class="inlineCode">Gizmos.DrawWireSphere</code> function, passing our position as the first parameter and the distance as the second parameter to draw a sphere in our position with the radius of our distance. You can check how the size of the <code class="inlineCode">Gizmo</code> changes as you change the distance field:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.14: Sphere Gizmo</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Optionally, you can change the color of the gizmo, setting <code class="inlineCode">Gizmos.color</code> prior <a id="_idIndexMarker513"/>to calling the <a id="_idIndexMarker514"/>drawing functions:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.15: Gizmos drawing code</p>
    <div class="note">
      <p class="normal">Now you are drawing <code class="inlineCode">Gizmos</code> constantly, and if you have lots of enemies, they can pollute the scene view with too many <code class="inlineCode">Gizmos</code>. In that case, try the <code class="inlineCode">OnDrawGizmosSelected</code> event function instead, which draws <code class="inlineCode">Gizmos</code> only if the object is selected.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">We can <a id="_idIndexMarker515"/>draw the <a id="_idIndexMarker516"/>lines representing the cone using <code class="inlineCode">Gizmos.DrawRay</code>, which receives the origin of the line to draw and the direction of the line, which can be multiplied by a certain value to specify the length of the line, as in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.16: Drawing rotated lines</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">In the screenshot, we used <code class="inlineCode">Quaternion.Euler</code> to generate a quaternion based on the angles we want to rotate. A quaternion is a mathematical construct to represent rotations; please search for this term for more info on it. If you multiply this quaternion by a direction, we will get the rotated direction. We are taking our forward vector and rotating it according to the angle field to generate our cone vision lines. </li>
    </ol>
    <p class="numberedList">Also, we multiply this direction by the sight distance to draw the line as far as our sight can see; you will see how the line matches the end of the sphere this way:</p>
    <figure class="mediaobject"><img src="../Images/B8585_09_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.17: Vision angle lines</p>
    <p class="normal">We can <a id="_idIndexMarker517"/>also draw the Linecasts, which <a id="_idIndexMarker518"/>check the obstacles, but as those depend on the current situation of the game, such as the objects that pass the first two checks and their positions, we can use <code class="inlineCode">Debug.DrawLine</code> instead, which can be executed in the <code class="inlineCode">Update</code> method. This version of <code class="inlineCode">DrawLine</code> is designed to be used in runtime only. The <code class="inlineCode">Gizmos</code> we saw also execute in the editor. Let’s try them the following way:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">First, let’s debug the scenario where <code class="inlineCode">Linecast</code> didn’t detect any obstacles, so we need to draw a line between our sensor and the object. We can call <code class="inlineCode">Debug.DrawLine</code> in the <code class="inlineCode">if</code> statement that calls <code class="inlineCode">Linecast</code>, as in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.18: Drawing a line in Update</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">In <a id="_idIndexMarker519"/>the next screenshot, you <a id="_idIndexMarker520"/>can see <code class="inlineCode">DrawLine</code> in action:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.19: Line toward the detected Object</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">We also want to draw a line in red when the sight is occluded by an object. In this case, we need to know where the <code class="inlineCode">Linecast</code> hit, so we can use an overload <a id="_idIndexMarker521"/>of the <a id="_idIndexMarker522"/>function, which provides an <code class="inlineCode">out</code> parameter that gives us more information about what the line collided with, such as the position of the hit and the normal and the collided object, as in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.20: Getting information about Linecast</p>
    <div class="note">
      <p class="normal">Note that <code class="inlineCode">Linecast</code> doesn’t always collide with the nearest obstacle but with the first object it detects in the line, which can vary in order. If you need to detect the nearest obstacle, look for the <code class="inlineCode">Physics.Raycast</code> version of the function.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">We can use that information to draw the line from our position to the hit point in <code class="inlineCode">else</code> of the <code class="inlineCode">if</code> sentence when the line collides with something:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.21: Drawing a line if we have an obstacle</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">In <a id="_idIndexMarker523"/>the next screenshot, you <a id="_idIndexMarker524"/>can see the results:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.22: Line when an obstacle occludes vision</p>
    <p class="normal">Regarding <a id="_idIndexMarker525"/>the Visual Scripting <a id="_idIndexMarker526"/>version, the first part will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B8585_09_23.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.23: Drawing Gizmos with Visual Scripting</p>
    <p class="normal">Then, the <a id="_idIndexMarker527"/>angle lines would <a id="_idIndexMarker528"/>look like this:</p>
    <figure class="mediaobject"><img src="../Images/B8585_09_24.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.24: Drawing Angle lines of sight in Visual Scripting</p>
    <p class="normal">Note <a id="_idIndexMarker529"/>that, here, we are <a id="_idIndexMarker530"/>showing just one, but the other is essentially the same but multiplying the angle by -1. Finally, the red lines towards the detected object and obstacles will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B8585_09_25.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.25: Drawing lines towards obstacles or detected objects in Visual Scripting</p>
    <p class="normal">Note that, to accomplish this last one, we needed to change the previous <strong class="screenText">Linecast</strong> node <a id="_idIndexMarker531"/>for the version that returns <strong class="screenText">Raycast Hit</strong> info at the end.</p>
    <p class="normal">With all <a id="_idIndexMarker532"/>of that, in this section, we created the sensors system that will give sight to our AI and plenty of info about what to do next. Now that we have our sensors completed, let’s use the information provided by them to make decisions with FSMs.</p>
    <h1 id="_idParaDest-120" class="heading-1">Making decisions with FSMs</h1>
    <p class="normal">We explored the <a id="_idIndexMarker533"/>concept of <strong class="keyWord">Finite State Machines</strong> (<strong class="keyWord">FSMs</strong>) in the past when we used them in the <code class="inlineCode">Animator</code> component. We learned that an FSM is a collection of states, each one representing <a id="_idIndexMarker534"/>an action that an object can be executing at a time, and a set of transitions that dictates how the states are switched. This concept is not only used in animation but in a myriad of programming scenarios, and one of the common ones is AI. We can just replace the animations with AI code in the states and we have an AI FSM. </p>
    <p class="normal">In this section, we will examine the following AI FSM concepts: </p>
    <ul>
      <li class="bulletList">Creating the FSM in C#</li>
      <li class="bulletList">Creating transitions</li>
      <li class="bulletList">Creating the FSM in Visual Scripting</li>
    </ul>
    <p class="normal">Let’s start by creating our FSM skeleton.</p>
    <h2 id="_idParaDest-121" class="heading-2">Creating the FSM in C#</h2>
    <p class="normal">To create <a id="_idIndexMarker535"/>our own FSM, we need to recap <a id="_idIndexMarker536"/>some basic concepts. Remember that an FSM can have a state for each possible action it can execute and that only one can be executed at a time.</p>
    <p class="normal">In terms of AI, for example, we can be patrolling, attacking, fleeing, and so on. Also, remember that there are transitions between states that determine conditions to be met to change from one state to another, and in terms of AI, this can be the user being near the enemy to start attacking or life being low to start fleeing. In the next figure, you can find a simple reminder example of the two possible states of a door: </p>
    <figure class="mediaobject"><img src="../Images/B8585_09_26.png" alt="State diagram - Wikipedia"/></figure>
    <p class="packt_figref">Figure 9.26: FSM example</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">There are several ways to implement FSMs for AI; you can even use the <code class="inlineCode">Animator</code> component if you want to or download some FSM system from the Asset Store. In our case, we are going to take the simplest approach possible, a single <a id="_idIndexMarker537"/>script with a set of <code class="inlineCode">If</code> sentences, which can be basic but is still a good start to understanding the concept. Let’s <a id="_idIndexMarker538"/>implement it by doing the following:</li>
      <li class="numberedList">Create a script called <code class="inlineCode">EnemyFSM</code> in the <code class="inlineCode">AI</code> child object of the enemy.</li>
      <li class="numberedList">Create an <code class="inlineCode">enum</code> called <code class="inlineCode">EnemyState</code> with the <code class="inlineCode">GoToBase</code>, <code class="inlineCode">AttackBase</code>, <code class="inlineCode">ChasePlayer</code>, and <code class="inlineCode">AttackPlayer</code> values. We are going to have those states in our AI.</li>
      <li class="numberedList">Create a field of the <code class="inlineCode">EnemyState</code> type called <code class="inlineCode">currentState</code>, which will hold the current state of our enemy: </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_27.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.27: EnemyFSM state definition</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Create three functions named after the states we defined.</li>
      <li class="numberedList">Call those functions in <code class="inlineCode">Update</code> depending on the current state:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_28.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.28: If-based FSM</p>
    <div class="note">
      <p class="normal">Yes, you can totally use a switch here, but I just prefer the regular <code class="inlineCode">if</code> syntax for this example.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Test <a id="_idIndexMarker539"/>in the editor how changing <a id="_idIndexMarker540"/>the <code class="inlineCode">currentState</code> field will change which state is active, seeing the messages being printed in the console:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_29.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.29: State testing</p>
    <p class="normal">As you can see, it is a pretty simple but totally functional approach. In the future, you could <a id="_idIndexMarker541"/>face having to code enemies with many <a id="_idIndexMarker542"/>more states, and this approach will start to scale badly. In such a case, you could use any FSM plugin of the Asset Store you prefer to have more powerful and scalable tools, or even consider advanced techniques like Behavior Trees, but that’s outside the scope of this book. Now let’s continue with this FSM, creating its transitions.</p>
    <h2 id="_idParaDest-122" class="heading-2">Creating transitions</h2>
    <p class="normal">If you remember the transitions created in the <code class="inlineCode">Animator Controller</code>, those were basically a <a id="_idIndexMarker543"/>collection of conditions that are checked if the state the transition belongs to is active. In our FSM approach, this translates simply as <code class="inlineCode">If</code> sentences that detect conditions inside the states. Let’s create the transitions between our proposed states as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add a field of the <code class="inlineCode">Sight</code> type called <code class="inlineCode">sightSensor</code> in our FSM script, and drag the AI <code class="inlineCode">GameObject</code> to that field to connect it to the <code class="inlineCode">Sight</code> component there. As the FSM component is in the same object as <code class="inlineCode">Sight</code>, we can also use <code class="inlineCode">GetComponent</code> instead, but in advanced AIs, you might have different sensors that detect different objects, so I prefer to prepare my script for that scenario. You should pick the approach you like the most.</li>
      <li class="numberedList">In the <code class="inlineCode">GoToBase</code> function, check whether the detected object of the <code class="inlineCode">Sight</code> component is not <code class="inlineCode">null</code>, meaning that something is inside our line of vision. If our AI is going toward the base but detects an object in the way, we must switch to the <code class="inlineCode">Chase</code> state to pursue the player, so we change the state, as in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"> <img src="../Images/B8585_09_30.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.30: Creating transitions</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Also, we <a id="_idIndexMarker544"/>must change to <code class="inlineCode">AttackBase</code> if we are near enough to the object that must be damaged to decrease the base life. We can create a field of the <code class="inlineCode">Transform</code> type called <code class="inlineCode">baseTransform</code> and drag the player’s base life object we created previously there so we can check the distance. Remember to add a float field called <code class="inlineCode">baseAttackDistance</code> to make that distance configurable:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_31.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.31: GoToBase transitions</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">In the case of <code class="inlineCode">ChasePlayer</code>, we need to check whether the player is out of sight <a id="_idIndexMarker545"/>to switch back to the <code class="inlineCode">GoToBase</code> state or whether we are near enough to the player to start attacking it. We will need another distance field called <code class="inlineCode">PlayerAttackDistance</code>, which determines the distance to attack the player, and we might want different attack distances for those two targets. Consider an early return in the transition to prevent getting <code class="inlineCode">null</code> reference exceptions if we try to access the position of the sensor detected object when there are not any:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_32.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.32: ChasePlayer transitions</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">For <code class="inlineCode">AttackPlayer</code>, we need to check whether the player is out of sight to get <a id="_idIndexMarker546"/>back to <code class="inlineCode">GoToBase</code> or whether it is far enough to go back to chasing it. You will notice how we multiplied <code class="inlineCode">playerAttackDistance</code> to make the stop-attacking distance a little bit greater than the start-attacking distance; this will prevent switching back and forth rapidly between attacking and chasing when the player is near that distance. </li>
    </ol>
    <p class="numberedList">You can make it configurable instead of hardcoding <code class="inlineCode">1.1</code>:</p>
    <figure class="mediaobject"><img src="../Images/B8585_09_33.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.33: AttackPlayer transitions</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">In our case, <code class="inlineCode">AttackBase</code> won’t have any transition. Once the enemy is near enough <a id="_idIndexMarker547"/>to the base to attack it, it will stay like that, even if the player starts shooting at it. Its only objective once there is to destroy the base.</li>
      <li class="numberedList">Remember you can use <code class="inlineCode">Gizmos</code> to draw the distances:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_34.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.34: FSM Gizmos</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Test the script by selecting the AI Object prior to clicking play and then move the player around, checking how the states change in the inspector. You <a id="_idIndexMarker548"/>can also keep the original <code class="inlineCode">print</code> messages in each state to see them changing in the console. Remember to set the attack distances and the references to the objects. In the screenshot, you can see the settings we use:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_35.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.35: Enemy FSM settings</p>
    <p class="normal">A little problem that we will have now is that the spawned enemies won’t have the needed references to make the distance calculations to the player’s base transform. You will notice that if you try to apply the changes on the enemy of the scene to the Prefab (<strong class="screenText">Overrides -&gt; Apply All</strong>), the <strong class="screenText">Base Transform</strong> variable will say <code class="inlineCode">None</code>. Remember that Prefabs cannot contain references to objects in the scene, which complicates our work here. One alternative would be to create <code class="inlineCode">BaseManager</code>, a Singleton that holds the reference to the damage position, so our <code class="inlineCode">EnemyFSM</code> can access it. Another one could be to make use of functions such as <code class="inlineCode">GameObject.Find</code> to find our object.</p>
    <p class="normal">In this case, we will see the latter. Even though it can be less performant than the <code class="inlineCode">Manager</code> version, I want to show you how to use it to expand your Unity toolset. In this case, just set the <code class="inlineCode">baseTransform</code> field in <code class="inlineCode">Awake</code> to the return of <code class="inlineCode">GameObject</code>.<code class="inlineCode">Find</code>, using <code class="inlineCode">BaseDamagePoint</code> as the first parameter, which will look for an object with the same name, as in the following screenshot. </p>
    <p class="normal">You will see that now our wave-spawned enemies will change states:</p>
    <figure class="mediaobject"><img src="../Images/B8585_09_36.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.36: Searching for an object in the scene by name</p>
    <p class="normal">Now that <a id="_idIndexMarker549"/>our FSM states are coded and execute transitions properly, let’s see how to do the same in Visual Scripting. Feel free to skip the following section if you are only interested in the C# version.</p>
    <h2 id="_idParaDest-123" class="heading-2">Creating the FSM in Visual Scripting</h2>
    <p class="normal">So far, most scripts in Visual Scripting were almost a mirror of the C# version with some differences <a id="_idIndexMarker550"/>in some nodes. While regarding state machines we could do the same, instead, we are going to use the <strong class="screenText"><a id="_idIndexMarker551"/></strong><strong class="screenText">State Machine</strong> system of Visual Scripting. The concept is the same, you have states and can switch them, but how the states are organized and when the transitions trigger is managed visually, in a similar way as the Animator system does. So, let’s see how we can use the system by creating our first <code class="inlineCode">State Machine Graph</code> and some <code class="inlineCode">states</code>. Follow these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add the <strong class="screenText">State Machine</strong> component to our enemy. Remember it is called <strong class="screenText">State Machine</strong> and not <strong class="screenText">Script Machine</strong>, the latter being the component for regular Visual Scripts.</li>
      <li class="numberedList">Click the <strong class="screenText">New</strong> button in the component and select a place to save the <code class="inlineCode">fixed</code> asset in a similar way to what we have done so far for regular Visual Scripts. In my case, I called it <code class="inlineCode">EnemyFSM</code>.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B8585_09_37.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.37: Creating a Visual State Machine</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Double-click <strong class="screenText">State Machine Graph</strong> to edit it as usual.</li>
      <li class="numberedList">Right-click <a id="_idIndexMarker552"/>in any <a id="_idIndexMarker553"/>empty area of the <strong class="screenText">Graph</strong> editor and select <strong class="screenText">Create Script State</strong> in order to create a new state:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_38.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.38: Creating our first Visual State Machine State</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Repeat <em class="italic">step 4</em> until you end up having 4 states:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_39.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.39: Visual states</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Select <a id="_idIndexMarker554"/>any of them <a id="_idIndexMarker555"/>and in the <strong class="screenText">Info</strong> panel on the left, fill the <strong class="screenText">Title</strong> field (the first one) with the name of any of the states we created before (<code class="inlineCode">GoToBase</code>, <code class="inlineCode">AttackBase</code>, <code class="inlineCode">ChasePlayer</code>, and <code class="inlineCode">AttackPlayer</code>). If you don’t see the <strong class="screenText">Info</strong> panel, click the button with the <strong class="screenText">i</strong> in the middle to display it:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_40.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.40: Renaming a Visual State</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Repeat that for the rest of the state nodes until you have each node named after each state created in the <em class="italic">Creating the FSM in C#</em> section of this chapter:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_41.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.41: All needed states</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">You can <a id="_idIndexMarker556"/>see one <a id="_idIndexMarker557"/>of the states has a green bar at the top, which represents which node is supposed to be the first one. I renamed that initial state <code class="inlineCode">GoToBase</code> as that’s the one I prefer to be first. If you don’t have that one as the starting one, right-click the node that currently has the green bar in your state machine, select <strong class="screenText">Toggle Start</strong> to remove the green bar from it, and then repeat for the node that you want to be the first one (<code class="inlineCode">GoToBase</code> in our scenario), adding the green bar to that one.</li>
    </ol>
    <div class="note">
      <p class="normal">Something to consider is that you can have more than one start state in Visual Scripting, meaning you can have multiple states running at the same time and transitioning. If possible, I recommend avoiding having more than one state active at a time to make things simple.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="9">Double-click <code class="inlineCode">GoToBase</code> to enter the edit mode for these states. Connect a <strong class="screenText">String</strong> node to the <strong class="screenText">print</strong> <strong class="screenText">Message</strong> input pin in the <strong class="screenText">OnUpdate</strong> event node to print a message saying <code class="inlineCode">GoToBase</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_42.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.42: Our first state machine logic</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="10">In the <a id="_idIndexMarker558"/>top bar, click the <strong class="screenText">EnemyFSM</strong> label at the left of <strong class="screenText">GoToBase</strong> in order to return to the <a id="_idIndexMarker559"/>whole State Machine view. If you don’t see it, click any text label at the right of the third button (the one that looks like <em class="italic">&lt;x&gt;</em>):</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_43.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.43: Returning to the State Machine editor mode</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="11">Feel free to delete the other event nodes if you are not planning to use them.</li>
      <li class="numberedList">Repeat <em class="italic">steps 9-11</em> for each state until all of them print their names.</li>
    </ol>
    <p class="normal">With this, we have created the nodes representing the possible states of our AI. In the next section, we will be adding logic for them to something meaningful, but before that, we need <a id="_idIndexMarker560"/>to create the transitions <a id="_idIndexMarker561"/>between the states and the conditions that need to be met to trigger them by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create variables in the <strong class="screenText">Variables</strong> component of the enemy called <code class="inlineCode">baseTransform</code>, <code class="inlineCode">baseAttackDistance</code>, and <code class="inlineCode">playerAttackDistance</code> as we are going to need them to do the transitions. </li>
      <li class="numberedList">Don’t set any type to <code class="inlineCode">baseTransform</code> as we will fill it later via code, but regarding <code class="inlineCode">baseAttackDistance</code>, make it using the <strong class="screenText">Float</strong> type and put a value of <code class="inlineCode">2</code>, and finally for <code class="inlineCode">playerAttackDistance</code>, also use <strong class="screenText">Float</strong> and a value of <code class="inlineCode">3</code>. Feel free to change those values if you prefer:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_44.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.44: Variables needed for our transitions</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Right-click the <code class="inlineCode">GoToBase</code> node and select the <strong class="screenText">Make Transition</strong> option, and then click the <code class="inlineCode">ChasePlayer</code> node. This will create a transition between the two states:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_45.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.45: A transition between two states</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Repeat <em class="italic">step 3</em> for <a id="_idIndexMarker562"/>each <a id="_idIndexMarker563"/>transition we created in the C# version. The <code class="inlineCode">State Machine Graph</code> will need to look like the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_46.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.46: All the needed transitions</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Double-click <a id="_idIndexMarker564"/>the yellow shape in the middle of the transition between <strong class="screenText">GoToBase</strong> and <strong class="screenText">ChasePlayer</strong> to enter the <strong class="screenText">Transition</strong> mode. Here, you will be able to specify the <a id="_idIndexMarker565"/>condition that will trigger that transition (instead of using an <code class="inlineCode">If</code> node during the state logic). Remember you have two yellow shapes, one for each transition direction, so check you are double-clicking the correct one based on the white arrows connecting them.</li>
      <li class="numberedList">Modify the graph in order to check if the <code class="inlineCode">sensedObject</code> variable is not <code class="inlineCode">null</code>. It should look like this:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_47.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.47: Adding a transition condition</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">The <a id="_idIndexMarker566"/>transition <a id="_idIndexMarker567"/>between <strong class="screenText">GoToBase</strong> and <strong class="screenText">AttackBase</strong> should look like this:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_48.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.48: GoToBase to AttackBase transition condition</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Now, <strong class="screenText">ChasePlayer</strong> to <strong class="screenText">GoToBase</strong> should <a id="_idIndexMarker568"/>be <a id="_idIndexMarker569"/>as follows:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_49.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.49: ChasePlayer to GoToBase transition condition</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="9">For <a id="_idIndexMarker570"/>the <strong class="screenText">ChasePlayer</strong> to <strong class="screenText">AttackPlayer</strong> transition, do as in <em class="italic">Figure 9.50</em>. This is essentially <a id="_idIndexMarker571"/>the same as <strong class="screenText">GoToBase</strong> and <strong class="screenText">AttackBase</strong>, a distance check, but with different targets:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_50.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.50: ChasePlayer to AttackPlayer transition condition</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="10">For <a id="_idIndexMarker572"/>the <strong class="screenText">AttackPlayer</strong> to <strong class="screenText">ChasePlayer</strong> transition, do as in <em class="italic">Figure 9.51</em>. This is another distance <a id="_idIndexMarker573"/>check but is now checking if the distance is greater and multiplying the distance by <code class="inlineCode">1.1</code> (to prevent transition jittering as we explained in the C# version):</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_51.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.51: AttackPlayer to ChasePlayer transition condition</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="11">Finally, for <strong class="screenText">AttackPlayer</strong> to <strong class="screenText">GoToBase</strong> this <a id="_idIndexMarker574"/>is the <a id="_idIndexMarker575"/>expected graph:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_52.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.52: AttackPlayer to GoToBase transition condition</p>
    <p class="normal">A little <a id="_idIndexMarker576"/>detail we need to tackle <a id="_idIndexMarker577"/>before moving on is the fact that we still don’t have any value set in the <code class="inlineCode">baseTransform</code> variable. The idea is to fill it via code as we did in the C# version. But something to consider here is that we cannot add an <code class="inlineCode">Awake</code> event node to the whole state machine, but just to the states. </p>
    <p class="normal">In this scenario, we could use the <strong class="screenText">OnEnterState</strong> event, which is an exclusive event node for state machines. It will execute as soon as the state becomes active, which is useful for state initializations. We could add the logic to initialize the <code class="inlineCode">baseTransform</code> variable in the <strong class="screenText">OnEnterState</strong> event node of the <strong class="screenText">GoToBase</strong> state, given it is the first state we execute. </p>
    <p class="normal">This way, <strong class="screenText">GoToBase</strong> logic will look as in <em class="italic">Figure 9.53</em>. Remember to double-click the state node to edit it:</p>
    <figure class="mediaobject"><img src="../Images/B18585_09_53.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.53: GoToBase initialization logic</p>
    <p class="normal">Notice <a id="_idIndexMarker578"/>how, here, we set the <a id="_idIndexMarker579"/>result of the <strong class="screenText">Find </strong>node into the variable only on the <strong class="screenText">Null</strong> pin of <strong class="screenText">Null Check</strong>. What <strong class="screenText">Null Check</strong> does is check if our <strong class="screenText">baseTransform</strong> variable is set, going through the <code class="inlineCode">Not Null</code> pin if it is, and <code class="inlineCode">Null</code> if it isn’t. This way we avoid executing <strong class="screenText">GameObject.Find</strong> every time we enter the <strong class="screenText">GoToBase</strong> state, but only the first time. Also, note that in this case, we will be executing the <strong class="screenText">Set Variable</strong> node not only when the object initializes, but also each time <strong class="screenText">GoToBase</strong> becomes the current state. If, in any case, that results in unexpected behavior, other options could be to create a new initial state that initializes everything and then transitions to the rest of the states, or maybe do a classic Visual Script graph that initializes those variables in the <strong class="screenText">On Start</strong> event node. </p>
    <p class="normal">With all this, we learned how to create a decision-making system for our AI through FSMs. It will make decisions based on the info gathered via sensors and other systems. Now that <a id="_idIndexMarker580"/>our FSM states <a id="_idIndexMarker581"/>are coded and transition properly, let’s make them do something.</p>
    <h1 id="_idParaDest-124" class="heading-1">Executing FSM actions</h1>
    <p class="normal">Now we need to complete the last step—make the FSM do something interesting. Here, we can do <a id="_idIndexMarker582"/>a lot of things such as shoot the base or the player and move the enemy toward its target (the base or the player). We will be handling movement with the Unity Pathfinding system called <code class="inlineCode">NavMesh</code>, a tool that allows our AI to calculate and traverse paths between two points while avoiding obstacles, which needs some preparation to work properly.</p>
    <p class="normal">In this section, we will examine the following FSM action concepts: </p>
    <ul>
      <li class="bulletList">Calculating our scene’s NavMesh</li>
      <li class="bulletList">Using Pathfinding</li>
      <li class="bulletList">Adding final details</li>
    </ul>
    <p class="normal">Let’s start by preparing our scene for movement with Pathfinding.</p>
    <h2 id="_idParaDest-125" class="heading-2">Calculating our scene’s NavMesh</h2>
    <p class="normal">Pathfinding algorithms rely on simplified versions of the scene. Analyzing the full geometry <a id="_idIndexMarker583"/>of a complex scene is almost impossible to do in real time. There are several ways to represent Pathfinding information extracted from a scene, such as Graphs and <code class="inlineCode">NavMesh</code> geometries. Unity uses the latter—a simplified mesh similar to a 3D model that spans all areas that Unity determines are walkable. In the next screenshot, you can find an example of <code class="inlineCode">NavMesh</code> generated in a scene, that is, the light blue geometry:</p>
    <figure class="mediaobject"><img src="../Images/B18585_09_54.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.54: NavMesh of walkable areas in the scene</p>
    <p class="normal">Generating <code class="inlineCode">NavMesh</code> can take from seconds to minutes depending on the size of the scene. That’s why Unity’s Pathfinding system calculates the <code class="inlineCode">NavMesh</code> once in the editor, so when we distribute our game, the user will use the pre-generated <code class="inlineCode">NavMesh</code>. Just like Lightmapping, <code class="inlineCode">NavMesh</code> is baked into a file for later usage. Like Lightmapping, the main caveat here is that <code class="inlineCode">NavMesh</code> objects cannot change during runtime. If you destroy or move a floor tile, the AI will still walk over that area. The <code class="inlineCode">NavMesh</code> on top of that didn’t notice the <a id="_idIndexMarker584"/>floor isn’t there anymore, so you are not able to move or modify those objects in any way. Luckily, in our case, we won’t suffer any modification of the scene during runtime, but note that there are components such as <code class="inlineCode">NavMeshObstacle</code> that can help us in those scenarios.</p>
    <p class="normal">To generate <code class="inlineCode">NavMesh</code> for our scene, do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Select any walkable object and the obstacles on top of it, such as floors, walls, and other obstacles, and mark them as <strong class="screenText">Static</strong>. You might remember that the <strong class="screenText">Static</strong> checkbox also affects Lightmapping, so if you want an Object not to be part of Lightmapping but to contribute to the <code class="inlineCode">NavMesh</code> generation, you can click the arrow at the left of the static check and select <strong class="screenText">Navigation Static</strong> only. Try to limit <code class="inlineCode">Navigation Static</code> GameObjects to only the ones that the enemies will actually traverse to increase <code class="inlineCode">NavMesh</code> generation speed. Making the terrain navigable, in our case, will increase the generation time a lot and we will never play in that area.</li>
      <li class="numberedList">Open the <code class="inlineCode">NavMesh</code> panel in <strong class="screenText">Window | AI | Navigation</strong>.</li>
      <li class="numberedList">Select <a id="_idIndexMarker585"/>the <strong class="screenText">Bake</strong> tab, click on the <strong class="screenText">Bake</strong> button at the bottom of the window, and check the generated <code class="inlineCode">NavMesh</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_55.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.55: Generating a NavMesh</p>
    <p class="normal">And that’s pretty much everything you need to do. Of course, there are lots of settings you can fiddle around with, such as <strong class="screenText">Max Slope</strong>, which indicates the maximum angle of slopes the AI will be able to climb, or <strong class="screenText">Step Height</strong>, which will determine whether the AI can climb stairs, connecting the floors between the steps in <code class="inlineCode">NavMesh</code>, but as we have a plain and <a id="_idIndexMarker586"/>simple scene, the default settings will suffice. </p>
    <p class="normal">Now, let’s make our AI move around <code class="inlineCode">NavMesh</code>. </p>
    <h2 id="_idParaDest-126" class="heading-2">Using Pathfinding</h2>
    <p class="normal">For making an AI object that moves with <code class="inlineCode">NavMesh</code>, Unity provides the <code class="inlineCode">NavMeshAgent</code> component, which will make our AI stick to <code class="inlineCode">NavMesh</code>, preventing the object from going outside it. It will <a id="_idIndexMarker587"/>not only calculate the path to a specified destination automatically but also will move the object through the path with the use of Steering behavior algorithms that mimic the way a human would move through the path, slowing down on corners and turning with interpolations instead of instantaneously. Also, this component is capable of evading other <code class="inlineCode">NavMeshAgent GameObjects </code>running in the scene, preventing all of the enemies from collapsing in the same position.</p>
    <p class="normal">Let’s use this powerful component by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Select the <strong class="screenText">Enemy</strong> Prefab and add the <code class="inlineCode">NavMeshAgent</code> component to it. Add it to the root object, the one called <code class="inlineCode">Enemy</code>, not the AI child—we want the whole object to move. You will see a cylinder around the object representing the area the object will occupy in <code class="inlineCode">NavMesh</code>. Note that this isn’t a collider, so it won’t be used for physical collisions:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_56.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.56: The NavMeshAgent component</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Remove the <code class="inlineCode">ForwardMovement</code> component; from now on, we will drive the movement of our enemy with <code class="inlineCode">NavMeshAgent</code>.</li>
      <li class="numberedList">In the <code class="inlineCode">Awake</code> event function of the <code class="inlineCode">EnemyFSM</code> script, use the <code class="inlineCode">GetComponentInParent</code> function to cache the reference of <code class="inlineCode">NavMeshAgent</code>. This will work similarly to <code class="inlineCode">GetComponent</code>—it will look for a component in our <code class="inlineCode">GameObject</code>, but if the component is not there, this version will try to look for that <a id="_idIndexMarker588"/>component in all parents. Remember to add the <code class="inlineCode">using UnityEngine.AI</code> line to use the <code class="inlineCode">NavMeshAgent</code> class in this script:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_57.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.57: Caching a parent component reference</p>
    <div class="note">
      <p class="normal">As you can imagine, there is also the <code class="inlineCode">GetComponentInChildren</code> method, which searches components in <code class="inlineCode">GameObject</code> first and then in all its children if necessary.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">In the <code class="inlineCode">GoToBase</code> state function, call the <code class="inlineCode">SetDestination</code> function of the <code class="inlineCode">NavMeshAgent</code> reference, passing the position of the base object as the target:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_58.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.58: Setting a destination for our AI</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Save the script and test this with a few enemies in the scene or with the enemies spawned by the waves. You will see the problem where the enemies will never stop going toward the target position, entering inside the object, if necessary, even if the current state of their FSMs changes when they are near enough. That’s because we never tell <code class="inlineCode">NavMeshAgent</code> to stop, which we can do by setting the <code class="inlineCode">isStopped</code> field of the agent to <code class="inlineCode">true</code>. 
    <p class="numberedList">You might <a id="_idIndexMarker589"/>want to tweak the base attack distance to make the enemy stop a little bit closer or further away:</p>
    <figure class="mediaobject"><img src="../Images/B18585_09_59.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.59: Stopping agent movement</p>
</li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">We can do the same for <code class="inlineCode">ChasePlayer</code> and <code class="inlineCode">AttackPlayer</code>. In <code class="inlineCode">ChasePlayer</code>, we can set the destination of the agent to the player’s position, and in <code class="inlineCode">AttackPlayer</code>, we can stop the movement. In this scenario, Attack Player can go back again to <code class="inlineCode">GoToBase</code> or <code class="inlineCode">ChasePlayer</code>, so you need to set the <code class="inlineCode">isStopped</code> agent field to <code class="inlineCode">false</code> in those states or before doing the transition. We will pick the former, as that version will cover other states that also stop the agent without extra code. We will start with the <code class="inlineCode">GoToBase</code> state:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_60.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.60: Reactivating the agent</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Then, continue <a id="_idIndexMarker590"/>with <code class="inlineCode">ChasePlayer</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_61.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.61: Reactivating the agent and chasing the player</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">And finally, continue with <code class="inlineCode">AttackPlayer</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_62.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.62: Stopping the movement</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="9">You can tweak the <strong class="screenText">Acceleration</strong>, <strong class="screenText">Speed</strong>, and <strong class="screenText">Angular Speed</strong> properties of <code class="inlineCode">NavMeshAgent</code> to control how fast the enemy will move. Also, remember to apply the changes to the Prefab for the spawned enemies to be affected.</li>
      <li class="numberedList">Regarding the <a id="_idIndexMarker591"/>Visual Scripting versions, <code class="inlineCode">GoToBase</code><strong class="screenText"> </strong>will look like the following screenshot: </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_63.png" alt=""/></figure>
    <figure class="mediaobject">Figure 9.63: Making our agent move</figure>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="11">We deleted the <strong class="screenText">OnUpdate</strong> event node printing a message as we don’t need it anymore. Also, we called the <strong class="screenText">Set Destination</strong> node after setting the variable if <code class="inlineCode">if</code> was <code class="inlineCode">null</code>, and also when the variable wasn’t <code class="inlineCode">null</code> (<strong class="screenText">Not Null </strong>pin of <strong class="screenText">Null</strong> Check). Note that all of this happens in the <strong class="screenText">On Enter State</strong> event, so we just need to do it once. We do it every frame in the C# version for simplicity but that’s actually not necessary, so we will take advantage of the <strong class="screenText">OnEnterState</strong> event. We can emulate that behavior in the C# version if we want, executing these actions at the moment we change the state (inside the <code class="inlineCode">If</code> statements that check the transition conditions), instead of using the <strong class="screenText">Update</strong> function. Finally, notice how we needed to use the <strong class="screenText">GetParent</strong> node in order to access the <code class="inlineCode">NavMeshAgent</code> component in the enemy’s root object? This is needed because we are currently in the <strong class="screenText">AI</strong> child object instead.</li>
      <li class="numberedList">Now, the <strong class="screenText">AttackBase</strong> state <a id="_idIndexMarker592"/>will look like this:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_64.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.64: Making our agent stop</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="13">The <strong class="screenText">ChasePlayer</strong> state will look like this:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_65.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.65: ChasePlayer logic</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="14">And <a id="_idIndexMarker593"/>finally, <strong class="screenText">AttackPlayer</strong> like this:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_66.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.66: AttackPlayer logic</p>
    <p class="normal">Now that we have movement in our enemy, let’s finish the final details of our AI.</p>
    <h1 id="_idParaDest-127" class="heading-1">Adding the final details</h1>
    <p class="normal">We have two things missing here: the enemy is not shooting any bullets, and it doesn’t have <a id="_idIndexMarker594"/>animations. Let’s start with fixing the shooting by doing the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add a <code class="inlineCode">bulletPrefab</code> field of the <code class="inlineCode">GameObject</code> type to our <code class="inlineCode">EnemyFSM</code> script and a <code class="inlineCode">float</code> field called <code class="inlineCode">fireRate</code>.</li>
      <li class="numberedList">Create a function called <code class="inlineCode">Shoot</code> and call it inside <code class="inlineCode">AttackBase</code> and <code class="inlineCode">AttackPlayer</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_67.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.67: Shooting function calls</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">In the <code class="inlineCode">Shoot</code> function, put similar code as that used in the <code class="inlineCode">PlayerShooting</code> script to shoot bullets at a specific fire rate, as in <em class="italic">Figure 9.68</em>. Remember to set the <strong class="screenText">Enemy</strong> layer in your <strong class="screenText">Enemy</strong> Prefab, if you didn’t before, to prevent the bullet from damaging the enemy itself. You might also want to raise the AI GameObject position a little bit to shoot bullets from a position other than the ground or, better, add a <code class="inlineCode">shootPoint</code> transform field and create an empty object in the enemy to use as a spawn position. If you do that, consider <a id="_idIndexMarker595"/>making the empty object not be rotated so the enemy rotation affects the direction of the bullet properly: </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_68.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.68: Shoot function code</p>
    <div class="note">
      <p class="normal">Here, you find some duplicated shooting behavior between <code class="inlineCode">PlayerShooting</code> and <code class="inlineCode">EnemyFSM</code>. You can fix that by creating a <strong class="screenText">Weapon</strong> behavior with a function called <code class="inlineCode">Shoot</code> that instantiates bullets and takes into account the fire rate and call it inside both components to re-utilize it.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">When the agent is stopped, not only does the movement stop but also the rotation. If the player moves while the enemy is being attacked, we still need the <a id="_idIndexMarker596"/>enemy to face the player to shoot bullets in its direction. We can create a <code class="inlineCode">LookTo</code> function that receives the target position to look at and call it in <code class="inlineCode">AttackPlayer</code> and <code class="inlineCode">AttackBase</code>, passing the target to shoot at:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_69.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.69: LookTo function calls</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Complete the <code class="inlineCode">LookTo</code> function by calculating the direction of our parent to the target position. We access our parent with <code class="inlineCode">transform.parent</code> because, remember, we are the child AI object—the object that will move is our parent. Then, we set the <code class="inlineCode">Y</code> component of the direction to <code class="inlineCode">0</code> to prevent the direction from pointing upward or downward—we don’t want our enemy to rotate vertically. Finally, we set the forward vector of our parent to that direction <a id="_idIndexMarker597"/>so it will face the target position immediately. You can replace that with interpolation through quaternions to have a smoother rotation if you want to, but let’s keep things as simple as possible for now:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_70.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.70: Looking toward a target</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Regarding the Visual Scripting version, <strong class="screenText">AttackBase</strong> actions look like this:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_09_71.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.71: AttackBase state</p>
    <p class="normal">In this state, we have some things to highlight. First, we are using the <strong class="screenText">LookAt </strong>node in the <strong class="screenText">OnEnterState </strong>event node after the <strong class="screenText">SetStopped</strong> node. As you might imagine, this does the <a id="_idIndexMarker598"/>same as we did with math in C#. We specify a target to look at (our base transform) and then we specify that the <strong class="screenText">World Up</strong> parameter is a vector pointing upwards <code class="inlineCode">0</code>,<code class="inlineCode">1</code>,<code class="inlineCode">0</code>. This will make our object look at the base but maintain its up vector pointing to the sky, meaning our object will not look at the floor if the target is lower than him. We can use this exact function in C# if we want to (<code class="inlineCode">transform.LookAt</code>); the idea was just to show you all the options. Also note that we execute <code class="inlineCode">LookAt</code> only when the state becomes active—as the base doesn’t move, we don’t need to constantly update our orientation.</p>
    <p class="normal">The second thing to highlight is that we used coroutines to shoot, the same idea we used in the <code class="inlineCode">Enemy Spawner</code> to constantly spawn enemies. Essentially, we make an infinite loop between<strong class="screenText"> Wait For Seconds</strong> and <strong class="screenText">Instantiate</strong>. We took this approach here because it was convenient given it takes fewer nodes in Visual Scripting. </p>
    <p class="normal">Remember to select the <strong class="screenText">OnEnterState</strong> node and check the <strong class="screenText">Coroutine</strong> checkbox as we did before. Also, we need <a id="_idIndexMarker599"/>a new Float type variable called <code class="inlineCode">fireRate</code> in the Enemy’s AI child object:</p>
    <figure class="mediaobject"><img src="../Images/B18585_09_72.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.72: Coroutines</p>
    <p class="normal">Then, <strong class="screenText">AttackPlayer</strong> will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B18585_09_73.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.73: AttackPlayer state</p>
    <p class="normal">Essentially it is the same as <strong class="screenText">AttackBase</strong>, but that looks towards the <code class="inlineCode">sensedObject</code> instead <a id="_idIndexMarker600"/>toward the player’s base, and we also made the <strong class="screenText">LookAt</strong> node part of the infinite loop, to correct the enemy’s heading before shooting to target the player.</p>
    <p class="normal">With that, we have finished all AI behaviors. Of course, these scripts/graphs are big enough to deserve some rework and splitting in the future, but with this, we have prototyped our AI, and we can test it until we are happy with it, and then we can improve this code.</p>
    <h1 id="_idParaDest-128" class="heading-1">Summary</h1>
    <p class="normal">I’m pretty sure AI is not what you imagined; you are not creating Skynet here, but we have accomplished a simple but interesting AI to challenge our players, which we can iterate and tweak to tailor to our game’s expected behavior. We saw how to gather our surrounding information through sensors to make decisions on what action to execute using FSMs and using different Unity systems such as Pathfinding to make the AI execute those actions. We used those systems to diagram a State Machine capable of detecting the player, running to them, and attacking them, and if the player is not there, just going to the base to accomplish its task to destroy it.</p>
    <p class="normal">In the next chapter, we are going to start <em class="italic">Part 3</em> of this book, where we will learn about different Unity systems to improve the graphics and audio aspects of our game, starting by seeing how we can create materials to modify the aspect of our objects and create Shaders with Shader Graph.</p>
  </div>
</body></html>