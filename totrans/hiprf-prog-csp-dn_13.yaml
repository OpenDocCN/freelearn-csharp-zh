- en: '*Chapter 11*: Benchmarking Relational Data Access Frameworks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data is extensively used in all aspects of our daily lives. In today's world
    of big data, the volumes of data being collected and stored for all kinds of analysis
    are phenomenal. When working with data, performance can slow down exponentially
    as the size of your data grows. Depending upon how much data you have to process,
    the time factor is often critical.
  prefs: []
  type: TYPE_NORMAL
- en: In a professional development environment, computer programmers don't always
    have access to the database server. Database server access is usually restricted
    for use by database developers and database administrators. With that in mind,
    this chapter is about benchmarking what code performs a database insert, update,
    read, and delete in the shortest possible time. In the *Further reading* section,
    there are links to documentation on database server performance that will help
    you to further improve the performance that you gain from working through this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be benchmarking three different ways of manipulating
    SQL Server database data. We will be performing a side-by-side comparison of Entity
    Framework, ADO.NET, and Dapper. After running the benchmarks for each of these
    data access and object mappers, you will be able to make an educated judgment
    call on the best form of data access and object mapping for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Benchmarking data insertion methods**: In this section, we write the benchmarks
    for inserting data with ADO.NET, Entity Framework Core, and Dapper.NET with and
    without using stored procedures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Benchmarking data selection methods**: In this section, we write the benchmarks
    for selecting data with ADO.NET, Entity Framework Core, and Dapper.NET with and
    without using stored procedures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Benchmarking data editing methods**: In this section, we write the benchmarks
    for applying updates to data with ADO.NET, Entity Framework Core, and Dapper.NET
    with and without using stored procedures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Benchmarking data deletion methods**: In this section, we write the benchmarks
    for deleting data with ADO.NET, Entity Framework Core, and Dapper.NET with and
    without using stored procedures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The benchmarking results and their analysis**: In this section, we run the
    benchmarks that we wrote in the previous sections. We then analyze the results
    of our benchmark results to conclude the best way to perform various efficient
    data access and manipulation tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After working through this chapter, you will have the skills needed to access
    and manipulate data with ADO.NET, Entity Framework, and Dapper.NET. You'll also
    be able to form your own judgment on which method of data access to use for your
    own projects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This chapter mainly involves you following along with writing a lot of code
    in preparation for running our data access benchmark methods in the last section.
    If you don't want to bother writing the code and just want to see the results,
    then jump to the last section of this chapter on the benchmarking results and
    their analysis. You can then jump to the areas of this chapter that are of most
    interest to you in helping you form your own opinions on the best data access
    methods for your needs. The source code is also available on GitHub to study for
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To master the skills presented in this chapter, it will be useful to have access
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server 2019 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server Management Student 2019 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The book''s source code: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH10](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH10)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking data insertion methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be following on from the work we did in [*Chapter 10*](B16617_10_Final_SB_Epub.xhtml#_idTextAnchor189),
    *Setting Up Our Database Project*, by writing methods that will benchmark the
    performance of insert methods using ADO.NET, Entity Framework Core, and Dapper.NET.
    So, if you have not read [*Chapter 10*](B16617_10_Final_SB_Epub.xhtml#_idTextAnchor189)*,*
    or looked at the source code, now would be a good time to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benchmarks written in this chapter will be run and the results will be
    analyzed in the last section. To save space due to chapter and page constraints,
    I will be leaving out references to `using` statements. Therefore, you will need
    to use Visual Studio''s quick tips for adding missing `using` statements. Follow
    these steps to write our insertion method benchmarks:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `BenchmarkDotNet` NuGet package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `BenchmarkTests` class and modify it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have set our class up to execute benchmarks and summarize them in the order
    that they are declared, as well as diagnosing the memory usage and providing a
    performance ranking of the benchmarking methods. Then, we provided `GlobalSetup`,
    which is run before the benchmarks. This is to provide our benchmarks with data
    to select, update, and delete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `InsertProductADN` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method obtains the connection string from the secrets file and creates
    a new `AdoDotNetData` instance by passing the connection string into its constructor.
    It then calls the `ExecuteNonQuery` method, passing into the method a raw SQL
    insert method. Once the query is run, the instance is disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `InsertProductADNSP` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method obtains the connection string from the secrets file and passes the
    string into the constructor of the `AdoDotNetData` class. It then creates a new
    `SqlCommandModel` that builds the properties for a stored procedure insert operation
    on the products table. It then calls the `ExecuteNonQuery` method, passing in
    the model that will be used to generate and execute the stored procedure call.
    The `AdoDotNetData` class is then disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `InsertProductEF` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `InsertProductEF` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method obtains the connection string from the secrets file and passes it
    into the constructor of the `EntityFrameworkCoreData` class. It then creates a
    new product and adds that product to the `Products` collection. The changes are
    then saved, and the `EntityFrameworkCoreData` class is disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `InsertProductEFSP` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method obtains the connection string from the secrets file and creates
    a new instance of the `EntityFrameworkCoreData` class. It then builds up the properties
    needed for the stored procedure insert via `SqlCommandModel`. Then, it executes
    the `ExecuteNonQuerySP` model, passing in the model that executes the insert stored
    procedure, and then disposes of the `EntityFrameworkCoreData` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `InsertProductDDN` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method obtains the connection string from the secrets file, creates a new
    instance of the `DapperDotNet` class, and executes a raw SQL insert statement
    by calling the `ExecuteNonQuery` method. It then disposes of the `DapperDotNet`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `InsertProductDDNSP` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the secrets file and creates a new
    `DapperDotNet` class. It then builds the `SqlCommandModel` properties required
    to execute the product insert stored procedure. Then, it calls the `ExecuteNonQuery`
    procedure, passing in the model that will execute the stored procedure. It then
    disposes of the `DapperDotNet` class.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our look at insert benchmarking methods. Now, we will start writing
    our selection benchmarking methods.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking data selection methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will be writing our benchmarking methods that will test
    the performance of various data selection methods. These benchmarks will be run
    and analyzed in the last section of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ReadScalarProductADN` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method obtains the connection from the `secrets` file, creates a new `AdoDotNetData`
    class, and executes the `ExecuteScalar` method, passing in a raw SQL statement
    that returns a string. It then disposes of the `AdoDotNet` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ReadScalarADNSP` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method obtains the connection string from the secrets file and creates
    a new instance of the `AdoDotNetData` class. It then builds `SqlCommandModel`
    up that contains the necessary properties to execute the scalar stored procedure.
    Then, it calls the `ExecuteScalar` method, passing in the model that executes
    the stored procedure, and returns the product name. It then disposes of the `AdoDotNetData`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ReadFilteredProductADN` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the secrets file and creates a new
    instance of the `AdoDotNetData` class. It then executes the `ExecuteReader` method,
    which takes a raw SQL statement and returns an enumerator of the `Product` type,
    and then disposes of the `AdoDotNetData` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ReadFilteredProductADNSP` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the secrets file and creates a new
    instance of the `AdoDotNetData` class. It then builds up `SqlCommandModel` that
    contains the properties that are required to execute the read stored procedure.
    Then, it executes the `ExecuteReader` method, which returns an enumerator, and
    then disposes of the `AdoDotNetData` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ReadScalarProductEF` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the secrets file and creates a new
    instance of the `EntityFrameworkCore` method. It then gets the first item in the
    `Product` collection that matches the filter and assigns `ProductName`. Then,
    it disposes of the `EntityFrameworkCore` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `ReadScalarProductEFSP`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the secrets file and then creates
    a new instance of the `EntityFrameworkCoreData` class. Then, it calls the `ExecuteScalarSP`
    method, passing in the name of the filter, returning the first `ProductName` that
    matches the filter, and then disposes of the `EntityFrameworkCoreData` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ReadFilteredProductsEF` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the secrets file and then creates
    an instance of the `EntityFrameworkCoreData` class. It then filters the products
    and returns an enumerator of products. Then, the method disposes of the `EntityFrameworkCoreData`
    class and the enumerator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ReadFilteredProductsEFSP` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the secret from the secrets file and creates a new instance
    of the `EntityFrameworkCoreData` class. It then calls the `ExecuteReaderSP` method,
    which executes a stored procedure that returns an enumerator of the `Products`
    type. Then, the method disposes of the `EntityFrameworkCoreData` class and the
    enumerator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ReadScalarProductDDN` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the secrets file and creates a new
    instance of the `DapperDotNet` class. It then executes the `ExecuteScalar` method,
    passing in a raw SQL statement that returns the top `ProductName` that matches
    the filter. Then, it disposes of the `DapperDotNet` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ReadScalarProductDDNSP` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the secrets file and creates a new
    instance of the `DapperDotNet` class. Then, the method builds `SqlCommandModel`
    that contains the properties necessary to execute a stored procedure. It then
    calls the `ExecuteScalarSP` method, passing in the model. The `ProductName` of
    the first matching product is returned. The method then disposes of the `DapperDotNet`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ReadFilteredProductsDDN` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the `secrets` file and then creates
    a new instance of the `DapperDotNet` class. It then calls the `ExecuteReader`
    method, passing in a raw SQL statement. An enumerator of the `Product` type is
    returned. `DapperDotNet` and the enumerator are then disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ReadFilteredProductsDDNSP` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the secrets file and then creates
    an instance of the `DapperDotNet` class. It then builds up a `SqlCommandModel`
    that has the properties needed to execute a stored procedure. It then calls `ExcuteReaderSP`,
    passing in the model that returns an enumerator of the `Product` type.
  prefs: []
  type: TYPE_NORMAL
- en: We have now finished writing our selection benchmarks. Now, we'll move on to
    writing our update benchmarks.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking data editing methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will be writing our benchmarks that test the performance
    of various update statements. These benchmarks will be run and analyzed in the
    final section of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `UpdateProductADN` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method obtains the `connection` string from the `secrets` file and then
    creates a new instance of the `AdoDotNetData` class. It then calls the `ExecuteNonQuery`
    product, passing in a raw SQL statement, then returns the number of records affected
    and disposes of the `AdoDotNetData` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `UpdateProductADNSP` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the secrets file and creates a new
    instance of the `AdoDotNetData` class. `SqlCommandModel` is then built up with
    the properties needed to execute the update stored procedure. `ExecuteNonQuery`
    is then called with the model being passed in, and the stored procedure that performs
    the update is executed. The `AdoDotNetData` class is then disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `UpdateProductEF` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the secrets file and creates a new
    instance of the `EntityFrameworkCoreData` class. It then declares and assigns
    a queryable collection of products. This collection is then iterated with the
    name of each product updated. The `UpdateRange` method is then called on the `Products`
    collection, and the updated collection is passed in. The modifications are then
    saved, and the `EntityFrameworkCoreData` class is disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `UpdateProductEFSP` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the `secrets` file and creates an
    instance of the `EntityFrameworkCoreData` class. It then builds up the `SqlCommandModel`
    that contains the properties needed to generate the call to the update stored
    procedure. The method then calls the `ExecuteNonQuerySP` procedure, which executes
    the stored procedure, passing in the model, and then disposes of the `EntityFrameworkCoreData`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `UpdateProductDDN` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the secrets file and creates a new
    instance of the `DapperDotNet` class. It then calls the `ExecuteNonQuery` method,
    passing in a raw SQL update statement. The number of records affected is returned,
    and the `DapperDotNet` class is disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `UpdateProductDDNSP` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the secrets file and creates a new
    instance of the `DapperDotNet` class. It then builds an `SQLCommandModel` in preparation
    for executing a stored procedure. It calls the `ExecuteNonQuery` method, passing
    in the model. The stored procedure is executed, and the method disposes of the
    `DapperDotNet` class.
  prefs: []
  type: TYPE_NORMAL
- en: This is the end of our look at the update benchmarks. Now for our final set
    of benchmark methods. In the next section, we will write our deletion benchmarks.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking data deletion methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we write our benchmarks for measuring the performance of our
    deletion methods. These benchmarks will be run and analyzed in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `DeleteProductADN` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the secrets file. It then creates
    an instance of the `AdoDotNetData` class. Then, the method calls the `ExecuteNonQuery`
    method, passing into it a raw SQL delete statement. It then disposes of the `AdoDotNetData`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `DeleteProductADNSP` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the secrets file, and then it creates
    an instance of the `AdoDotNetData` class. `SqlCommandModel` is built up with the
    properties required for the delete stored procedure execution. The model is then
    passed into the `ExecuteNonQuery` model, which executes the stored procedure,
    and the `AdoDotNetData` class is then disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `DeleteProductEF` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the secrets file and then creates
    an instance of the `EntityFrameworkCoreData` class. A queryable collection of
    products is then returned, matching the deletion criteria. This collection is
    then passed into the `RemoveRange` method of the `Products` collection, and the
    modification is saved with those items removed from the database. The method then
    disposes of the `EntityFrameworkCoreData` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `DeleteProductEFSP` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the secrets file and creates an
    instance of the `EntityFrameworkCoreData` class. It then builds up a `SqlCommandModel`
    that contains the properties of the deletion stored procedure. The `ExecuteNonQuerySP`
    method is called with the model that is passed in, the deletion stored procedure
    is executed, and the `EntityFrameworkCoreData` class is disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `DeleteProductDDN` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the secrets file and creates an
    instance of the `DapperDotNet` class. It then calls the `ExecuteNonQuery` method,
    passing into that method a raw SQL delete statement. The deletion is carried out
    and the number of records affected is returned. The `DapperDotNet` class is then
    disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `DeleteProductDDNSP` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the connection string from the secrets file and creates an
    instance of the `DapperDotNet` class. It then builds up the `SqlCommandModel`,
    containing stored procedure properties. This model is then passed into the `ExecuteNonQuery`
    method, which executes the stored procedure, and the `DapperDotNet` class is disposed
    of.
  prefs: []
  type: TYPE_NORMAL
- en: 'That was the last of our benchmarking methods. There is just one more job to
    do before we are able to run our benchmarks. Update the `Program` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `Main` method executes the `BenchmarkTests` class. You can now do a release
    build to run the benchmarks. The program will take a while to execute, so you
    will need to be patient. In the next section, we will analyze the results of our
    various benchmarks to find out the most performant ways of performing inserts,
    selections, updates, and deletions.
  prefs: []
  type: TYPE_NORMAL
- en: The benchmarking results and their analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we analyze the results, it is worth noting some big data statistics from
    2020\. Google gets more than 40,000 queries per second. This equates to 3,456,000,000
    queries per day. There are 65,000,000,000 WhatsApp business app messages sent
    per day. In the course of 24 hours, there are 1,440 minutes, which is 86,400 seconds,
    which is 86,400,000 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our benchmark summary report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Data access benchmark summary'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_11_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – Data access benchmark summary
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss the insert statements first. The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`InsertProductDDNSP` = 1.841 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InsertProductADNSP` = 1.894 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InsertProductDDN` = 2.058 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InsertProductADN` = 2.092 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InsertProductEF` = 2.196 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InsertProductEFSP` = 396.509 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the summary, we can see that the best-performing insert statement is the
    Dapper.NET stored procedure insert, taking approximately 1.841 ms to execute,
    followed by `InsertProductADNSP`, which takes approximately 1.894 ms to execute.
    By far the worst performer is the `InsertProductEFSP` method, which takes 396.509
    ms to execute. As we can see from these methods, even though we have six different
    ways of inserting data, they all perform at different speeds. When performance
    is a serious issue, your best option is to use Dapper.NET stored procedure execution
    or ADO.NET stored procedure execution when inserting data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now look at scalar operations, starting with an ordered list of method
    performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReadScalarProductDDN` = 1.403 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadScalarProductADN` = 1.407 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadScalarProductADNSP` = 1.433 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadScalarProductDDNSP` = 1.514 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadScalarProductEFSP` = 53.235 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadScalarProductEF` = 396.509 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at these results, the Dapper.NET raw SQL execution takes approximately
    1.403 ms, followed by the ADO.NET raw SQL execution at 1.407 ms. Both the Entity
    Framework Core methods perform much more slowly. So, when performance matters,
    you are best off using Dapper.NET or ADO.NET raw SQL queries to obtain scalar
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next are the filtered list queries. Here is an ordered list of the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReadFilteredProductsADNSP` = 1.078 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadFilteredProductsADN` = 1.084 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadFilteredProductsEFSP` = 1.187 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadFilteredProductsEF` = 1.305 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadFilteredProductsDDNSP` = 1.529 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadFilteredProductsDDN` = 199.910 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see from these results, ADO.NET raw SQL and stored procedure access
    perform the best at 1.078 ms and 1.084 ms, respectively. Surprisingly, this time
    it is Dapper.NET that performs the worst when it comes to raw SQL and stored procedure
    access. So, when performance matters for performing queries that return multiple
    records, you are best off using ADO.NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we turn our attention to performing updates. Here is an ordered list of
    our results:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UpdateProductADNSP` = 1.562 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpdateProductEFSP` = 1.964 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpdateProductDDNSP` = 1.891 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpdateProductDDN` = 2.297 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpdateProductADN` = 3.583 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpdateProductEF` = 5,304.279 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From these results, **the clear winner is the ADO.NET stored procedure access
    at** **1.562 ms**. The worst performer is the Entity Framework Core update method.
    When performance matters, use ADO.NET stored procedures to update database records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll look at our deletion benchmarks. Here is an ordered list of
    our results:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DeleteProductADNSP` = 1.760 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeleteProductDDNSP` = 1.863 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeleteProductEFSP` = 2.012 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeleteProductDDN` = 2.522 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeleteProductADN` = 6.263 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeleteProductEF` = 386.716 ms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be seen that the worst performer is the Entity Framework Core method,
    taking about 386.716 ms to execute. On the other hand, the best performer is the
    ADO.NET stored procedure method, which takes only 1.760 ms, with the Dapper.NET
    stored procedure next, taking 1.863 ms. So, when performance matters, your best
    deletion strategy is to use ADO.NET stored procedures.
  prefs: []
  type: TYPE_NORMAL
- en: What can we summarize from these results?
  prefs: []
  type: TYPE_NORMAL
- en: Dapper.NET and ADO.NET come out on top when performing insert, read, update,
    and delete operations. The performance varies between raw SQL and stored procedure
    execution. When performance is critical, it would seem that the best strategy
    is rather than choosing just one framework and using only that one for all your
    data operations, to use a hybrid approach.
  prefs: []
  type: TYPE_NORMAL
- en: With a hybrid approach to data access, you will use a combination of data access
    frameworks. From each framework, you will decide on the best performer and use
    that for your data operation. In the case of our benchmarks, we would use two
    frameworks. The frameworks chosen are ADO.NET and Dapper.NET. This way, we could
    find the best performance possible for each type of data operation.
  prefs: []
  type: TYPE_NORMAL
- en: But given that these times only have millisecond differences, why does such
    performance matter?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, remember at the beginning of this section how we mentioned the big data
    statistics for 2020? The following table shows the performance of these methods
    when put into the context of big data search queries and app message storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 10.1 – Big data operation durations if SQL Server were used to store
    and read data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_10.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10.1 – Big data operation durations if SQL Server were used to store and
    read data
  prefs: []
  type: TYPE_NORMAL
- en: These benchmarks were run on an HP laptop with an Intel Core i5-6300U CPU 2.40
    GHz (Skylake) processor. This is one CPU with four logical cores and two physical
    cores. I have 8 GB of RAM and a 256 GB SSD.
  prefs: []
  type: TYPE_NORMAL
- en: If the SQL Server on my laptop were used and I had the space available (which
    I don't) to store the WhatsApp business app message data, depending upon which
    method I used to insert the data, it would take between 1,385.01157 and 298,299.595
    processing days on my laptop. If my laptop were used to retrieve Google search
    results from my SQL Server, then it would take between 43.12 and 7,996.4 processing
    days to retrieve those results.
  prefs: []
  type: TYPE_NORMAL
- en: This real-life application of the benchmarks to actual big data volumes based
    on the big data statistics of 2020 shows the importance of computer infrastructure
    and the type of investment that would be needed to make these searches and message
    sending and receiving instantaneous. It was important to have peak performance
    when working with such large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Tweaking large datasets through code can only go so far. That is why server
    computers have many more processors and disks, along with more memory, than your
    normal day-to-day workstations and home computers.
  prefs: []
  type: TYPE_NORMAL
- en: The key thing to take away from this chapter is that whenever you are deciding
    on a way forward to maximize performance, experiment and benchmark. Along with
    that, take the time to choose your physical infrastructure carefully.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to bear in mind when using a cloud host is the cost per data execution
    and cost per hour when running virtual machines. Then, there is the cost of data
    throughput and data storage saving and retrieval. With figures of apps such as
    Google and WhatsApp being in the billions, if you were to be that successful,
    could you imagine the running costs involved? That is why performance in today's
    competitive market is also so important. The quicker a piece of code executes
    in the cloud, the cheaper the price. The longer a piece of code takes to run,
    the more expensive it becomes.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, if you have an Azure function that performs your data operations
    that are located in the West US region on the Consumption tier using a memory
    size of 128 with an execution time of 1.078 ms and 65,000,000,000 executions per
    month, then your bill for the month would be US$13,133.54\. But if your execution
    time was 396.509 ms, then your bill for the month would be US$64,539.57\. So,
    doing the same code action can mean a difference of 64,539.57 – 12,133.54 = US$52,406.03
    per month on cloud expenditure operations. I am sure you would not want to spend
    that much money on such outgoings, and that does not even include the cost of
    the SQL Server instances!
  prefs: []
  type: TYPE_NORMAL
- en: That concludes this rather long chapter, and so we will now summarize what we
    have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to perform inserts, selections, updates, and
    deletes in SQL Server. We learned how to perform these operations in different
    ways using pure ADO.NET, Entity Framework Core, and Dapper.NET. The different
    data operations were performed using raw SQL and stored procedures.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the performance of each of these data access methods of the different
    data access frameworks, in this chapter, we benchmarked their runtime performance
    using `BenchmarkDotNet`. We saw that both Dapper.NET and ADO.NET performed better
    than Entity Framework Core in most cases and that even with these two frameworks,
    the performance varied considerably.
  prefs: []
  type: TYPE_NORMAL
- en: We concluded that rather than just adopting a single data access technology,
    in some situations where performance really matters, it could be beneficial to
    employ a hybrid approach to data access. With a hybrid approach, you use the best
    framework and method within that framework for the data access task in question.
    That way, you maximize your overall performance. This can also be critical in
    terms of keeping your infrastructure expenses down, especially when the infrastructure
    you are employing is a third-party cloud provider with your monthly bill being
    in the thousands of dollars.
  prefs: []
  type: TYPE_NORMAL
- en: But apart from computer code performance enhancements, we also studied big data
    volumes and calculated the number of processing days it would take to perform
    query and data insert operations when the volumes involved are in the billions.
    So, apart from code performance, we also came to understand that it is necessary
    to choose the right kind of infrastructure, which also comes at a price when using
    cloud services.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Whatever you are doing, whenever performance is a critical business requirement,
    you are strongly advised to experiment and provide your own benchmarks. Based
    on your results, you can then choose your own methods of data access that you
    feel are most beneficial for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at improving the performance of SQL
    Server and Cosmos DB. But before we do, have a go at the following questions to
    see how well you have retained the information contained in this chapter. Also,
    there are very useful articles in the *Further reading* section that expand upon
    what has been covered in this chapter. This chapter purely focused on identifying
    the best data access methods in code using three different frameworks. But in
    the *Further reading* section, you will find topics that are specific to improving
    database performance that are well worth reading about.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which data access method was fastest when inserting data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which data access method was fastest when selecting a scalar value?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which data access method was fastest when selecting multiple records?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which data access method was fastest when updating data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which data access method was fastest when deleting data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should you use one framework for all data access operations and why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Dapper vs Entity Framework vs ADO.NET Performance Benchmarking*: [https://www.exceptionnotfound.net/dapper-vs-entity-framework-vs-ado-net-performance-benchmarking/](https://www.exceptionnotfound.net/dapper-vs-entity-framework-vs-ado-net-performance-benchmarking/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Dapper tutorial: [https://dapper-tutorial.net/dapper](https://dapper-tutorial.net/dapper'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '*ADO.NET Tutorial for Beginners and Professionals*: [https://dotnettutorials.net/course/ado-net-tutorial-for-beginners-and-professionals/](https://dotnettutorials.net/course/ado-net-tutorial-for-beginners-and-professionals/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '*SQL Server Database Performance Tuning*: [https://www.brentozar.com/sql/sql-server-performance-tuning/](https://www.brentozar.com/sql/sql-server-performance-tuning/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Book – *High Performance SQL Server: Consistent Response for Mission-Critical
    Applications* by Benjamin Nevarez: [https://amzn.to/3gnUbe7](https://amzn.to/3gnUbe7'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '*Performance tips for Azure Cosmos DB and .NET*: [https://docs.microsoft.com/azure/cosmos-db/performance-tips-dotnet-sdk-v3-sql](https://docs.microsoft.com/azure/cosmos-db/performance-tips-dotnet-sdk-v3-sql'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '*A technique for building high-performance databases with EF Core*: [https://www.thereformedprogrammer.net/a-technique-for-building-high-performance-databases-with-ef-core/](https://www.thereformedprogrammer.net/a-technique-for-building-high-performance-databases-with-ef-core/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '*How to improve SQL Server query performance in .NET*: [https://www.red-gate.com/products/dotnet-development/ants-performance-profiler/resources/how-to-improve-sql-server-query-performance-in-net](https://www.red-gate.com/products/dotnet-development/ants-performance-profiler/resources/how-to-improve-sql-server-query-performance-in-net)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using Dapper and SQLKata in .NET Core for High-Performance Application*: [https://medium.com/geekculture/using-dapper-and-sqlkata-in-net-core-for-high-performance-application-716d5fd43210](https://medium.com/geekculture/using-dapper-and-sqlkata-in-net-core-for-high-performance-application-716d5fd43210'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '*What are the best databases for a small .NET application?*: [https://www.slant.co/topics/274/~best-databases-for-a-small-net-application](https://www.slant.co/topics/274/~best-databases-for-a-small-net-application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: Point to Remember
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reading about performance in a book is all very good. But you should always
    do your own experimentation and benchmarking if performance is very important
    to you. Different hardware architecture and different programming styles will
    yield very different results, and this point is well worth remembering. Network
    usage, security software, and data volumes, along with file input and output,
    can all have an effect on the performance of your application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
