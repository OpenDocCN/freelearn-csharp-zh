- en: Answers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章
- en: A software architect needs to be aware of any technology that can help them
    solve problems faster and ensure they can create better quality software.
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件架构师需要了解任何可以帮助他们更快解决问题的技术，并确保他们能够创建更高品质的软件。
- en: Azure helps software architects by providing scalable cloud infrastructure,
    diverse development tools, and services for building, deploying, and managing
    enterprise applications efficiently, with strong support for security and compliance.
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure 通过提供可伸缩的云基础设施、多样化的开发工具和服务，帮助软件架构师高效地构建、部署和管理企业应用程序，同时提供强大的安全性和合规性支持。
- en: The best software development process model depends on the kind of project,
    team, and budget you have. As a software architect, you need to consider all these
    variables and understand different process models so that you can fit the environment’s
    needs.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最佳的软件开发流程模型取决于您拥有的项目类型、团队和预算。作为软件架构师，您需要考虑所有这些变量，并理解不同的流程模型，以便能够满足环境的需要。
- en: A software architect pays attention to any user or system requirement that can
    influence performance, security, usability, system architecture, structure, organization,
    and so on.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件架构师会关注任何可能影响性能、安全性、可用性、系统架构、结构、组织等方面的用户或系统需求。
- en: A software architect should verify both functional and non-functional requirements,
    with a special focus on system architecture, performance, scalability, security,
    maintainability, and compatibility in the requirements specification.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件架构师应验证功能性和非功能性需求，特别关注需求规范中的系统架构、性能、可伸缩性、安全性、可维护性和兼容性。
- en: Design thinking and design sprint help a software architect to understand user
    needs deeply and rapidly prototyping solutions, ensuring the requirements gathered
    align closely with user expectations and project goals.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计思维和设计冲刺帮助软件架构师深入理解用户需求，并快速原型设计解决方案，确保收集到的需求与用户期望和项目目标紧密一致。
- en: User stories are good when we want to define functional requirements. They can
    be written quickly and commonly deliver not only the feature required but also
    the acceptance criteria for the solution.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们想要定义功能需求时，用户故事是好的。它们可以快速编写，通常不仅提供所需的功能，还提供解决方案的验收标准。
- en: Effective techniques for developing high-performance software include optimizing
    code, using efficient algorithms, leveraging parallel processing, and implementing
    effective memory management.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发高性能软件的有效技术包括优化代码、使用高效算法、利用并行处理和实施有效的内存管理。
- en: To check that the implementation is correct, a software architect compares it
    with models and prototypes that have already been designed and validated.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检查实现是否正确，软件架构师将其与已设计和验证的模型和原型进行比较。
- en: Chapter 2
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章
- en: Vertically and horizontally.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 纵向和横向。
- en: Yes, you can deploy automatically to an already-defined web app or create a
    new one directly using Visual Studio.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，您可以通过 Visual Studio 自动部署到已定义的 Web 应用程序，或者直接创建一个新的。
- en: To take advantage of available hardware resources by minimizing the time they
    remain idle.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过最小化它们闲置的时间来利用可用的硬件资源。
- en: Code behavior is deterministic, so it is easy to debug. The execution flow mimics
    the flow of sequential code, which means it is easier to design and understand.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码行为是确定的，因此易于调试。执行流程模仿顺序代码的流程，这意味着它更容易设计和理解。
- en: Because the right order minimizes the number of gestures that are needed to
    fill in a form.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为正确的顺序可以最小化填写表格所需的手势数量。
- en: Because it allows for the manipulation of path files in a way that is independent
    of the operating system.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为它允许以独立于操作系统的方式操作路径文件。
- en: It can be used with several .NET Core versions, as well as with several versions
    of the classic .NET Framework.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它可以与多个 .NET Core 版本以及多个版本的经典 .NET 框架一起使用。
- en: Console, .NET Core, .NET (5+), and .NET Standard class libraries; ASP.NET Core,
    test projects, microservices, and much more.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台、.NET Core、.NET (5+) 和 .NET Standard 类库；ASP.NET Core、测试项目、微服务以及更多。
- en: Chapter 3
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章
- en: No, it is available for several platforms.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，它适用于多个平台。
- en: Automatic, manual, and load test plans.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动、手动和负载测试计划。
- en: Yes, they can – through Azure DevOps feeds.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，他们可以通过 Azure DevOps 源来做到。
- en: To manage requirements and organize the whole development process.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了管理需求和组织整个开发过程。
- en: Epic work items represent higher-level system subparts that are made up of several
    features.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 史诗级工作项代表由多个功能组成的更高级别的系统子部分。
- en: A parent-child relationship.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种父子关系。
- en: They can organize projects using the same concept we have in Azure DevOps.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们可以使用我们在 Azure DevOps 中拥有的相同概念来组织项目。
- en: Both options are great tools for running agile projects. The best option depends
    on your team’s experience.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两种选项都是运行敏捷项目的优秀工具。最佳选项取决于你团队的经验。
- en: Chapter 4
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章
- en: Maintainability gives you the opportunity to deliver the software you designed
    quickly. It also allows you to fix bugs easily.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可维护性为你提供了快速交付你设计的软件的机会。它还允许你轻松修复错误。
- en: Cyclomatic complexity is a measure of code complexity based on the control flow
    graph. It detects the number of nodes a method has. The higher the number, the
    worse the effect.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 圈复杂度是基于控制流图的代码复杂度度量，它检测方法中的节点数量。数字越高，影响越差。
- en: A version control system will guarantee the integrity of your source code, giving
    you the opportunity to analyze the history of each modification that you’ve made.
    It offers the possibility of branching your code development, then merging different
    branches, and much more.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 版本控制系统将保证你的源代码的完整性，为你提供分析每个修改历史的机会。它提供了分支代码开发、合并不同分支以及更多可能性的可能性。
- en: A garbage collector is a system in .NET Core, .NET (5+), and .NET Framework
    that monitors your application and detects objects that you aren’t using anymore.
    It disposes of these objects to free up memory.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾回收器是 .NET Core、.NET (5+) 和 .NET Framework 中的一种系统，它监视你的应用程序并检测你不再使用的对象。它销毁这些对象以释放内存。
- en: The `IDisposable` interface is important firstly because it is a good pattern
    for deterministic cleanup. Secondly, it is required in classes that instantiate
    objects that need to be disposed of by the programmer, since the garbage collector
    cannot dispose of them.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IDisposable` 接口之所以重要，首先是因为它是一个确定清理的好模式。其次，它是在实例化需要由程序员销毁的对象的类中必需的，因为垃圾回收器无法销毁它们。'
- en: .NET 8 encapsulates some key design patterns in some of its libraries, such
    as dependency injection and the Builder pattern, in a way that can guarantee safer,
    more reliable code.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET 8 以一种可以保证更安全、更可靠的代码的方式，在其某些库中封装了一些关键设计模式，例如依赖注入和构建器模式。
- en: Well-written code is code that any person skilled in that programming language
    can handle, modify, and evolve.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写良好的代码是任何熟练掌握该编程语言的人都可以处理、修改和演化的代码。
- en: Roslyn is the .NET compiler that’s used for code analysis inside Visual Studio.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Roslyn 是用于在 Visual Studio 内部进行代码分析的 .NET 编译器。
- en: Code analysis is a practice that considers the way code is written to detect
    bad practices before compilation.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码分析是一种考虑代码编写方式的实践，旨在在编译前检测不良做法。
- en: Code analysis can find problems that happen even with apparently good software,
    such as memory leaks and bad programming practices.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码分析可以发现即使在表面上看起来很好的软件中也会出现的问题，例如内存泄漏和不良编程实践。
- en: Roslyn is an engine that provides an API that enables analyzers to inspect your
    code for style, quality, maintainability, design, and other issues. This is done
    during design time, so you can check the mistakes before compiling your code.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Roslyn 是一个提供 API 的引擎，该 API 使分析器能够检查你的代码的风格、质量、可维护性、设计和其他问题。这是在设计时间完成的，因此你可以在编译代码之前检查错误。
- en: Visual Studio extensions are tools that have been programmed to run inside Visual
    Studio. These tools can help you out in some cases where the Visual Studio IDE
    doesn’t have the appropriate feature for you to use.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 扩展是在 Visual Studio 内部运行的编程工具。这些工具在某些情况下可以帮助你，因为 Visual Studio
    IDE 没有为你提供相应的功能。
- en: '`SonarLint` and the `SonarAnalyzer.CSharp` NuGet package.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SonarLint` 和 `SonarAnalyzer.CSharp` NuGet 包。'
- en: Chapter 5
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章
- en: Copy-and-paste is an inadequate form of code reuse, since it leads to duplicated
    code, making maintenance and updates more difficult. In fact, there is no safe
    way to discover all duplicates, and then it is very difficult to modify all of
    them.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制粘贴是一种不充分的代码重用形式，因为它会导致代码重复，使维护和更新更加困难。实际上，没有安全的方法可以发现所有重复项，然后修改它们就非常困难。
- en: The best approaches for code reuse are creating libraries, using generics, object-oriented
    inheritance, and more.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码重用的最佳方法包括创建库、使用泛型、面向对象继承等。
- en: Yes. You can find components that have already been created in the libraries
    you’ve created before, and then you increase these libraries by creating new components
    that can be reused in the future.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的。你可以在你之前创建的库中找到已经创建的组件，然后通过创建可以在未来重用的新组件来增加这些库。
- en: .NET Standard is a specification that allows compatibility across different
    .NET frameworks, from .NET Framework to Unity. .NET Core is one .NET implementation
    of .NET and is open source.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET标准是一个允许在不同.NET框架之间实现兼容性的规范，从.NET框架到Unity。.NET Core是.NET的一种实现，并且是开源的。
- en: By creating a .NET Standard library, you will be able to use it in different
    .NET implementations, such as .NET Core, .NET, .NET Framework, and Xamarin.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建.NET标准库，你将能够在不同的.NET实现中使用它，例如.NET Core、.NET、.NET框架和Xamarin。
- en: You can enable code reuse using object-oriented principles (e.g., inheritance,
    encapsulation, abstraction, and polymorphism).
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用面向对象的原则（例如，继承、封装、抽象和多态）来启用代码重用。
- en: Generics is a sophisticated implementation that simplifies how objects with
    the same characteristics are treated, by defining a placeholder that will be replaced
    with the specific type at compile time.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型是一种复杂的实现，通过定义一个占位符来简化具有相同特性的对象的处理，该占位符将在编译时被具体类型替换。
- en: 'The answer to this question is well explained by Immo Landwerth on the .NET
    blog: [https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/).
    The basic answer is that .NET versions 5 and above need to be thought of as the
    foundation for sharing code moving forward.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个问题的答案在.NET博客上由Immo Landwerth进行了很好的解释：[https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/)。基本的回答是，.NET版本5及以上需要被视为未来共享代码的基础。
- en: The challenges related to refactoring include ensuring that changes don’t introduce
    bugs, maintaining the functionality and performance of code, and improving readability
    and maintainability without altering the external behavior of software components.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与重构相关的挑战包括确保更改不会引入错误，维护代码的功能和性能，以及在不改变软件组件的外部行为的情况下提高可读性和可维护性。
- en: Chapter 6
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: Design patterns are good solutions to common problems in software development.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计模式是解决软件开发中常见问题的良好解决方案。
- en: While design patterns give you code implementation for typical problems we face
    in development, design principles help you select the best options when it comes
    to implementing the software architecture.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然设计模式为你提供了我们在开发中遇到的典型问题的代码实现，但设计原则有助于你在实现软件架构时选择最佳选项。
- en: The Builder pattern will help you generate sophisticated objects without the
    need to define them in the class you are going to use them in.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建造者模式将帮助你生成复杂的对象，而无需在你要使用它们的类中定义它们。
- en: The Factory pattern is useful in situations where you have multiple kinds of
    objects from the same abstraction, and you don’t know which of them needs to be
    created at compile time.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工厂模式在存在多种来自同一抽象的物体，并且不知道在编译时需要创建哪一个的情况下非常有用。
- en: The Singleton pattern is useful when you need a class that has only one instance
    during the software’s execution.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单例模式在软件执行期间需要只有一个实例的类时非常有用。
- en: The Proxy pattern is used when you need to provide an object that controls access
    to another object.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理模式在需要提供一个控制对另一个对象访问的对象时使用。
- en: The Command pattern is used when you need to execute a command that will affect
    the behavior of an object.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令模式在需要执行将影响对象行为的命令时使用。
- en: The Publisher/Subscriber pattern is useful when you need to provide information
    about an object to a group of other objects.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布/订阅模式在需要向一组其他对象提供有关对象的信息时非常有用。
- en: The DI pattern is useful if you want to implement the Inversion of Control principle.
    Instead of creating instances of the objects that the component depends on, you
    just need to define their dependencies, declare their interfaces, and enable the
    reception of the objects by injection. Typically, you can do this by using the
    constructor of the class to receive the objects, tagging some class properties
    to receive the objects, or defining an interface with a method to inject all the
    necessary components.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖注入模式如果想要实现控制反转原则非常有用。你不需要创建组件所依赖的对象的实例，只需定义它们的依赖关系，声明它们的接口，并启用通过注入接收对象的功能。通常，你可以通过使用类的构造函数接收对象，标记一些类属性以接收对象，或者定义一个带有注入所有必要组件的方法的接口来实现这一点。
- en: Chapter 7
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: Changes in the language used by experts and changes in the meaning of words.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 专家使用的语言的变化以及词语含义的变化。
- en: Context mapping is the main tool used to coordinate the development of a separate
    bounded context, helping to define and manage interactions between different contexts.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上下文映射是协调单独边界上下文开发的主要工具，有助于定义和管理不同上下文之间的交互。
- en: No; the whole communication passes through the entity, that is, the aggregate
    root.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不；整个通信都通过实体进行，即聚合根。
- en: There is a single aggregate root in a part-subpart hierarchy to ensure the consistency
    of and enforce rules across all elements of the aggregate, acting as the main
    entry point for external interactions.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在部分-子部分层次结构中有一个单一的聚合根，以确保聚合中所有元素的一致性并强制执行规则，作为外部交互的主要入口点。
- en: Just one, since repositories are aggregate-centric.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有一个，因为存储库是聚合中心化的。
- en: The application layer manipulates repository interfaces. Repository implementations
    are registered in the dependency injection engine.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用层操作存储库接口。存储库实现注册在依赖注入引擎中。
- en: To coordinate operations on several aggregates in single transactions.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了协调单个事务中多个聚合的操作。
- en: The specifications for updates and queries are usually quite different, especially
    in simple **CRUD** systems. The reason for its strongest form is mainly the optimization
    of query response times.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新和查询的规范通常相当不同，尤其是在简单的 **CRUD** 系统中。其最强形式的原因主要是查询响应时间的优化。
- en: Dependency injection.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖注入。
- en: No; a serious impact analysis must be performed so that we can adopt it.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不；必须进行严重的影响分析，以便我们可以采用它。
- en: Chapter 8
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章
- en: DevOps is the approach of delivering value to the end user continuously. To
    do this with success, continuous integration, continuous delivery, and continuous
    feedback must be undertaken.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DevOps 是一种持续向最终用户提供价值的做法。为了成功实现这一点，必须进行持续集成、持续交付和持续反馈。
- en: '**Continuous integration** (**CI**) allows you to check the quality of the
    software you are delivering every single time you commit a change. You can implement
    this by turning on this feature in Azure DevOps.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**持续集成** (**CI**) 允许你在每次提交更改时检查你交付的软件的质量。你可以在 Azure DevOps 中通过启用此功能来实现这一点。'
- en: '**Continuous delivery** (**CD**) allows you to deploy a solution once you are
    sure that all the quality checks have passed the tests you designed. Azure DevOps
    helps you with that by providing you with relevant tools.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**持续交付** (**CD**) 允许你在确信所有质量检查都通过了你设计的测试后部署解决方案。Azure DevOps 通过提供相关工具来帮助你实现这一点。'
- en: Yes, you can have DevOps separately and then enable **CI** later. You can also
    have CI enabled without **CD** enabled. Your team and process need to be ready
    and attentive for this to happen.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，你可以单独拥有 DevOps，然后稍后启用 **CI**。你还可以在 **CD** 未启用的情况下启用 CI。你的团队和流程需要准备好并关注这一点才能实现。
- en: You might confuse **CI** with a CD process, which could cause damage to your
    production environment. In the worst-case scenario, for example, a feature that
    is not ready might be deployed, causing disruptions at inconvenient times for
    your customers, or you could even suffer a bad collateral effect due to an incorrect
    fix.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会将 **CI** 与 CD 流程混淆，这可能会对你的生产环境造成损害。在最坏的情况下，例如，一个尚未准备好的功能可能会被部署，导致在客户不便的时间造成中断，或者你甚至可能因为错误的修复而遭受不良的副作用。
- en: A multi-stage environment protects production from bad releases when fully automated
    build and deployment pipelines are in place.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当完全自动化的构建和部署管道到位时，多阶段环境可以保护生产环境免受不良发布的影响。
- en: Automated tests anticipate bugs and bad behaviors in preview scenarios.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动化测试可以预测预览场景中的错误和不良行为。
- en: Pull requests allow code reviews before commits are made in the master branch.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拉取请求允许在主分支提交之前进行代码审查。
- en: No; pull requests can help you in any development approach where you have Git
    as your source control.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不；拉取请求可以帮助你在任何具有 Git 作为源代码控制的发展方法中。
- en: Continuous feedback is the adoption of tools in the DevOps life cycle that enable
    fast feedback when it comes to performance, usability, and other aspects of the
    application you are developing.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 持续反馈是采用 DevOps 生命周期中的工具，以便在性能、可用性以及你正在开发的应用程序的其它方面快速获得反馈。
- en: The build pipeline will let you run tasks to build and test your application,
    while the release pipeline will give you the opportunity to define how the application
    will be deployed in each scenario.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建管道将允许你运行任务来构建和测试你的应用程序，而发布管道将为你提供定义应用程序在每个场景中如何部署的机会。
- en: Application Insights is a helpful tool for monitoring the health of the system
    you’ve deployed, which makes it a fantastic continuous feedback tool.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Application Insights 是一个有助于监控已部署系统健康状况的有用工具，这使得它成为一个出色的持续反馈工具。
- en: Test and Feedback is a tool that allows stakeholders to analyze the software
    you are developing and enables a connection with Azure DevOps to open tasks and
    even bugs.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试和反馈是一个允许利益相关者分析你正在开发的软件的工具，并允许与 Azure DevOps 连接以打开任务甚至错误。
- en: The main goal of service design thinking is to enhance user experience and satisfaction
    by optimizing the service’s usability, efficiency, and effectiveness in meeting
    user needs.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务设计思维的主要目标是通过对服务在满足用户需求方面的可用性、效率和效果进行优化，从而提升用户体验和满意度。
- en: Azure DevOps is a tool that can automate the whole application life cycle when
    it comes to software development. However, many software architects tend to also
    use GitHub to do so, and Microsoft has developed the platform a lot in the last
    few years.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure DevOps 是一个在软件开发中可以自动化整个应用程序生命周期的工具。然而，许多软件架构师倾向于同时使用 GitHub 来实现这一点，而且微软在过去几年中对该平台进行了大量开发。
- en: Chapter 9
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: Because most of the tests must be repeated after any software change occurs.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为大多数测试在软件发生任何更改后都必须重新进行。
- en: Because the probability of the same error occurring in a unit test and its associated
    application code is very low.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为在单元测试及其相关应用程序代码中发生相同错误的概率非常低。
- en: '`[Theory]` is used when the test method defines several tests, while `[Fact]`
    is used when the test method defines just one test.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当测试方法定义了多个测试时使用 `[理论]`，而当测试方法只定义了一个测试时使用 `[事实]`。
- en: Assert.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言。
- en: '`Setup`, `Returns`, and `ReturnsAsync`.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Setup`、`Returns` 和 `ReturnsAsync`。'
- en: Yes, with `ReturnAsync`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，使用 `ReturnAsync`。
- en: No; it depends on the complexity of the user interface and how often it changes.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不；这取决于用户界面的复杂性和其变更的频率。
- en: The ASP.NET Core pipeline isn’t executed, but inputs are passed directly to
    controllers.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core 管道不会执行，但输入会直接传递到控制器。
- en: Usage of the `Microsoft.AspNetCore.Mvc.Testing` NuGet package.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Microsoft.AspNetCore.Mvc.Testing` NuGet 包。
- en: Usage of the `AngleSharp` NuGet package.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `AngleSharp` NuGet 包。
- en: Chapter 10
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: IaaS is a good option when you are migrating from an on-premises solution or
    if you have an infrastructure team.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你从本地解决方案迁移或拥有基础设施团队时，IaaS 是一个好选项。
- en: PaaS is the best option for fast and safe software delivery in systems where
    the team is focused on software development.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PaaS 是在团队专注于软件开发时，快速和安全交付软件的最佳选项。
- en: If the solution you intend to deliver is provided by a well-known player, such
    as a SaaS, you should consider using it.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你打算交付的解决方案由知名玩家提供，例如 SaaS，你应该考虑使用它。
- en: Serverless is an option when you are building a new system if you don’t have
    people who specialize in infrastructure and you don’t want to worry about it for
    scaling.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你构建一个新系统，且没有专门从事基础设施的人员，或者你不想担心其扩展性时，无服务器架构是一个选项。
- en: Azure SQL Database can be up in minutes, and you will have all the power of
    Microsoft SQL Server afterward. Moreover, Microsoft will handle the database server
    infrastructure.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure SQL 数据库可以在几分钟内启动，之后你将拥有 Microsoft SQL Server 的全部功能。此外，Microsoft 将处理数据库服务器基础设施。
- en: Azure provides a set of services called Azure Cognitive Services. These services
    provide solutions for vision, speech, language, search, and knowledge.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure 提供了一套称为 Azure 认知服务的服务。这些服务提供视觉、语音、语言、搜索和知识方面的解决方案。
- en: In a hybrid scenario, you have the flexibility to decide on the best solution
    for each part of your system, while respecting the solution’s development path
    in the future.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在混合场景中，你有灵活性来决定系统每个部分的最佳解决方案，同时尊重未来解决方案的开发路径。
- en: Chapter 11
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: The modularity of code and deployment modularity.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码模块化和部署模块化。
- en: No. Other important advantages include handling the development team and the
    whole **CI**/**CD** cycle well, and the possibility of mixing heterogeneous technologies
    easily and effectively.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不。其他重要优势包括很好地处理开发团队和整个 **CI**/**CD** 循环，以及轻松有效地混合异构技术的可能性。
- en: A library that helps us implement resilient communication.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个帮助我们实现弹性通信的库。
- en: Once you’ve installed Docker on your development machine, you can develop, debug,
    and deploy Dockerized .NET applications. You can also add Docker images to Service
    Fabric applications that are handled with Visual Studio.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你在开发机器上安装了 Docker，你就可以开发、调试和部署 Docker 化的 .NET 应用程序。你还可以将 Docker 镜像添加到由 Visual
    Studio 处理的 Service Fabric 应用程序中。
- en: 'Orchestrators are software that manages microservices and nodes in microservice
    clusters. Azure supports two relevant orchestrators: Azure Kubernetes Service
    and Azure Service Fabric.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Orchestrators 是管理微服务和微服务集群中节点的软件。Azure 支持两个相关的 Orchestrators：Azure Kubernetes
    Service 和 Azure Service Fabric。
- en: Because it decouples the actors that take place in a communication.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为它解耦了通信中发生的参与者。
- en: A message broker. It takes care of service-to-service communication and events.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个消息代理。它负责服务之间的通信和事件。
- en: The same message can be received several times because the sender doesn’t receive
    confirmation of reception before its time-out period, so the sender resends the
    message again. Therefore, the effect of receiving a single message once or several
    times must be the same.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于发送者在超时之前没有收到接收确认，因此可能会多次接收到相同的信息。因此，接收一条信息一次或多次的效果必须相同。
- en: Chapter 12
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章
- en: Redis is a distributed in-memory storage based on key-value pairs and supports
    distributed queuing. Its most well-known usage is for distributed caching, but
    it can be used as an alternative to relational databases, since it is able to
    persist data to disk.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Redis 是一种基于键值对的分布式内存存储，支持分布式排队。它最著名的用途是分布式缓存，但它可以用作关系数据库的替代品，因为它能够将数据持久化到磁盘。
- en: Yes, they are. Most of this chapter’s sections are dedicated to explaining why.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，它们是这样的。本章的大部分内容都是致力于解释为什么。
- en: Write operations.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写操作。
- en: The main weaknesses of NoSQL databases are their consistency and transactions,
    while their main advantage is performance, especially when it comes to handling
    distributed writes.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NoSQL 数据库的主要弱点是它们的一致性和事务，而它们的主要优势是性能，尤其是在处理分布式写入时。
- en: Eventual, Consistency Prefix, Session, Bounded Staleness, and Strong.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终一致性、一致性前缀、会话、有界不一致性和强一致性。
- en: No, they are not efficient in a distributed environment. GUID-based strings
    perform better, since their uniqueness is automatic and doesn’t require synchronization
    operations.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，它们在分布式环境中效率不高。基于 GUID 的字符串表现更好，因为它们的唯一性是自动的，不需要同步操作。
- en: '`OwnsMany` and `OwnsOne`.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OwnsMany` 和 `OwnsOne`。'
- en: Yes, they can. Once you use `SelectMany`, indices can be used to search for
    nested objects.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，它们可以。一旦你使用了 `SelectMany`，索引就可以用来搜索嵌套对象。
- en: Chapter 13
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章
- en: With the help of database-dependent providers.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过数据库依赖提供者。
- en: Either by calling them `Id` or by decorating them with the `Key` attribute.
    This can also be done with a fluent configuration approach.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要么通过将它们命名为 `Id`，要么通过使用 `Key` 属性来装饰它们。这也可以通过流畅配置方法来完成。
- en: With the `MaxLength` and `MinLength` attributes, or with their equivalent fluent
    configuration methods.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `MaxLength` 和 `MinLength` 属性，或者使用它们的等效流畅配置方法。
- en: With something similar to `builder.Entity<Package>().HasIndex(m => m.Name);`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似于 `builder.Entity<Package>().HasIndex(m => m.Name);`。
- en: 'With something similar to the following:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似以下内容：
- en: '[PRE0]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With `Add-Migration` and `Update-Database` in the package-manager console, or
    with `dotnet ef migrations` `add` and `dotnet` `ef` `database` `update` in the
    operating system console.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包管理器控制台中的 `Add-Migration` 和 `Update-Database`，或者在操作系统控制台中的 `dotnet ef migrations
    add` 和 `dotnet ef database update`。
- en: No, but you can forcefully include them with the `Include` `LINQ` clause or
    by using the `UseLazyLoadingProxies` option when configuring your `DbContext`.
    With Include, related entities are loaded together with the main entities, while
    with `UseLazyLoadingProxies`, related entities are lazy-loaded; that is, they
    are loaded as soon as they are required.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，但你可以通过使用 `Include` `LINQ` 子句或配置你的 `DbContext` 时使用 `UseLazyLoadingProxies`
    选项强制包含它们。使用 Include 时，相关实体与主实体一起加载，而使用 `UseLazyLoadingProxies` 时，相关实体是延迟加载的；也就是说，它们在需要时才加载。
- en: Yes, it is, thanks to the `Select LINQ` clause.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，它是，多亏了 `Select LINQ` 子句。
- en: By calling `context.Database.Migrate()`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `context.Database.Migrate()`。
- en: Chapter 14
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 14 章
- en: Because using queues are the only way to avoid time-consuming blocking calls.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为使用队列是避免耗时阻塞调用的唯一方法。
- en: With the `import` declaration.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `import` 声明。
- en: With the standard `Duration` message.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准的 `Duration` 消息。
- en: Version compatibility and interoperability while maintaining good performance.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 版本兼容性和互操作性，同时保持良好的性能。
- en: Better horizontal scalability, and support for the Publisher/Subscriber pattern.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更好的水平可伸缩性，以及支持发布/订阅模式。
- en: For two reasons. The operation is very fast, and the insertion in the first
    queue of a communication path must necessarily be a blocking operation. At least
    one blocking operation is always necessary to store the message in some permanent
    storage (usually a queue), so it can be recovered if the ongoing processing might
    fail for some reason.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有两个原因。操作非常快，并且在通信路径的第一个队列中的插入必须是必要的阻塞操作。至少需要一个阻塞操作来将消息存储在某种永久存储（通常是队列）中，以便在持续处理可能因某些原因失败时可以恢复。
- en: 'With the following XML code:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下XML代码：
- en: '[PRE1]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Where `Protos\file1.proto` and `Protos\file2.proto` must be replaced with the
    actual paths to the `ProtoBuf` files within our project. Moreover, the `GrpcServices`
    attribute must be set to `"Server"` or `"Client"`, depending on whether the `proto`
    file describes a server or not.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`Protos\file1.proto`和`Protos\file2.proto`必须替换为我们项目中`ProtoBuf`文件的实际路径。此外，`GrpcServices`属性必须设置为`"Server"`或`"Client"`，具体取决于`proto`文件是否描述了一个服务器。
- en: With `channel.BasicPublish(…)`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`channel.BasicPublish(…)`。
- en: With `channel.WaitForConfirmsOrDie(timeout)`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`channel.WaitForConfirmsOrDie(timeout)`。
- en: Chapter 15
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章
- en: No, since this would violate the principle that a service reaction to a request
    must depend on the request itself, and not on other messages/requests that had
    previously been exchanged with the client.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，因为这会违反服务对请求的反应必须依赖于请求本身，而不是之前与客户端交换的其他消息/请求的原则。
- en: No, implementing a service with a custom communication protocol is generally
    not good practice because it compromises interoperability, increases development
    and maintenance complexity, and isolates the service from widely used standards
    and tools. Standard protocols such as HTTP/REST, `gRPC`, and others are preferred
    for their broad support, ease of integration, and community backing.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，使用自定义通信协议实现服务通常不是好的实践，因为这会损害互操作性，增加开发和维护的复杂性，并将服务孤立于广泛使用的标准和工具。标准协议如HTTP/REST、`gRPC`等因其广泛的支持、易于集成和社区支持而更受欢迎。
- en: Yes, it can. The primary action of a POST must be creation, but deletion can
    be performed as a side effect. The HTTP verb to use is determined by the virtual
    table named in the URL (in our case, a POST, since the operation is an addition),
    but other operations can be performed on other virtual tables that are not mentioned
    in the URL as side effects.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，它可以。POST的主要操作必须是创建，但删除可以作为副作用执行。要使用的HTTP动词由URL中命名的虚拟表确定（在我们的例子中是一个POST，因为操作是添加），但可以在URL中未提及的其他虚拟表上执行其他操作。
- en: Three; they are `Base64` encoding of the header, `Base64` encoding of the body,
    and the signature.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个；它们是头部的基础64编码、正文的基础64编码和签名。
- en: From the request body.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从请求体中。
- en: The `ApiController` attribute sets up some default behaviors that help in the
    implementation of REST services.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ApiController`属性设置了一些默认行为，有助于实现REST服务。'
- en: The `ProducesResponseType` attribute.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProducesResponseType`属性。'
- en: When using API controllers, they are declared with the `Route` and `Http<verb>`
    attributes. When using a minimal API, they are declared in the first argument
    of `MapGet`, `MapPost`, `…` `Map{Http verb}`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用API控制器时，它们通过`Route`和`Http<verb>`属性进行声明。当使用最小API时，它们在`MapGet`、`MapPost`、…
    `Map{Http verb}`的第一个参数中进行声明。
- en: By adding something like `builder.Services.AddHttpClient<MyProxy>()` in the
    dependency injection part of the host configuration.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在宿主配置的依赖注入部分添加类似`builder.Services.AddHttpClient<MyProxy>()`的内容。
- en: Chapter 16
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章
- en: Azure Functions is an Azure PaaS component that allows you to implement FaaS
    solutions.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure Functions是Azure PaaS组件，允许您实现FaaS解决方案。
- en: 'You can program Azure Functions in different languages, such as C#, F#, PHP,
    Python, and Node.js. You can also create functions using the Azure portal and
    Visual Studio Code. Additional stacks can be used by using custom handlers: [https://docs.microsoft.com/en-au/azure/azure-functions/functions-custom-handlers](https://docs.microsoft.com/en-au/azure/azure-functions/functions-custom-handlers).'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用不同的语言编写Azure Functions，例如C#、F#、PHP、Python和Node.js。您还可以使用Azure门户和Visual
    Studio Code创建函数。可以通过使用自定义处理程序来使用其他堆栈：[https://docs.microsoft.com/en-au/azure/azure-functions/functions-custom-handlers](https://docs.microsoft.com/en-au/azure/azure-functions/functions-custom-handlers)。
- en: There are two plan options in Azure Functions. The first plan is the Consumption
    Plan, where you are charged according to the amount you use. The second plan is
    the App Service Plan, where you share your App Service resources with the function’s
    needs.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure Functions中有两种计划选项。第一种计划是消费计划，您将根据使用的量付费。第二种计划是App Service计划，您将与函数的需求共享App
    Service资源。
- en: The process of deploying functions in Visual Studio is the same as in web app
    deployment.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中部署函数的过程与Web应用程序部署相同。
- en: There are lots of ways we can trigger Azure Functions, such as using Blob Storage,
    Cosmos DB, Event Grid, Event Hubs, HTTP, Microsoft Graph Events, Queue Storage,
    Service Bus, Timer, and Webhooks.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以以多种方式触发Azure Functions，例如使用Blob存储、Cosmos DB、Event Grid、Event Hubs、HTTP、Microsoft
    Graph Events、队列存储、Service Bus、定时器和Webhooks。
- en: Azure Functions v1 needs the .NET Framework Engine, whereas v2 needs .NET Core
    2.2, and v3 needs .NET Core 3.1 and .NET 5-6\. v4 is the current version for .NET
    6, 7, and 8.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure Functions v1需要.NET Framework引擎，而v2需要.NET Core 2.2，v3需要.NET Core 3.1和.NET
    5-6。v4是.NET 6、7和8的当前版本。
- en: The execution of every Azure function can be monitored by Application Insights.
    Here, you can check the time it took to process, resource usage, errors, and exceptions
    that happened in each function call.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个Azure函数的执行都可以通过Application Insights进行监控。在这里，您可以检查处理所需的时间、资源使用情况、每个函数调用中发生的错误和异常。
- en: They are functions that will let us write stateful workflows, managing the state
    behind the scenes.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们是让我们能够编写有状态工作流、管理幕后状态的函数。
- en: Chapter 17
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章
- en: Typical middleware modules scaffolded by Visual Studio in an ASP.NET Core project
    include a developer exception page, request routing, static file serving, HTTPS
    redirection, authentication, and authorization.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio在ASP.NET Core项目中典型地构建的中间件模块包括开发者异常页面、请求路由、静态文件服务、HTTPS重定向、身份验证和授权。
- en: No.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不。
- en: False. Several tag helpers can be invoked on the same tag.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误。可以在同一个标签上调用多个标签助手。
- en: '`ModelState.IsValid`.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ModelState.IsValid`.'
- en: '`@RenderBody()`.'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@RenderBody()`.'
- en: 'We can use `@RenderSection("Scripts", required: false)`.'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们可以使用 `@RenderSection("Scripts", required: false)`.'
- en: We can use `return View("viewname", ViewModel)`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `return View("viewname", ViewModel)`.
- en: Three providers are included in ASP.NET Core, but they must be configured. If
    different providers are needed, they must be implemented by the developers and
    added to the providers list.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core包含三个提供程序，但它们必须进行配置。如果需要不同的提供程序，它们必须由开发人员实现并添加到提供程序列表中。
- en: No, `ViewModels` are not the only way for controllers to communicate with views
    in ASP.NET Core. Controllers can also use `ViewData`, `ViewData`, and `TempData`
    to pass data to views.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，`ViewModels`不是控制器与ASP.NET Core中的视图通信的唯一方式。控制器还可以使用`ViewData`、`ViewData`和`TempData`将数据传递给视图。
- en: Chapter 18
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章
- en: API gateways work as interfaces for API microservices, while frontends take
    care of building web pages’ HTML.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API网关作为API微服务的接口，而前端负责构建网页的HTML。
- en: Robust web servers optimize the whole request/response handling and ensure the
    needed level of security.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强大的Web服务器优化整个请求/响应处理，并确保所需的安全级别。
- en: Because they have an impact on performance that is usually unacceptable for
    high-traffic microservices.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为它们对性能有影响，通常对于高流量的微服务来说是不可接受的。
- en: When transactions are quite fast and the probability of collision between transactions
    is low.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当事务非常快且事务之间碰撞的概率很低时。
- en: A better decoupling of the aggregates and commands methods.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 聚合和命令方法的更好解耦。
- en: Chapter 19
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第19章
- en: 'It is a W3C standard: the assembly of a virtual machine running in W3C-compliant
    browsers.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个W3C标准：在符合W3C标准的浏览器中运行的虚拟机的组装。
- en: A web UI where dynamic HTML is created in the browser itself.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Web UI，其中动态HTML在浏览器本身中创建。
- en: Selecting a page based on the current browser URL.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据当前浏览器URL选择页面。
- en: A Blazor component with routes attached to it. For this reason, the Blazor router
    can select it.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个附加了路由的Blazor组件。因此，Blazor路由器可以选中它。
- en: Defining the .NET namespace of a Blazor component class.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义Blazor组件类的.NET命名空间。
- en: A local service that takes care of storing and handling all form-related information,
    such as validation errors and changes in HTML inputs.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个本地服务，负责存储和处理所有与表单相关的信息，例如验证错误和HTML输入的变化。
- en: Either `OnInitialized` or `OnInitializedAsync`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要么是`OnInitialized`要么是`OnInitializedAsync`。
- en: Callbacks and services.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回调和服务。
- en: Blazor’s way to interact with JavaScript.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Blazor与JavaScript交互的方式。
- en: Getting a reference to a component or HTML element instance.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取组件或HTML元素实例的引用。
- en: Chapter 20
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第20章
- en: Services are needed to dispatch communication to pods, since a pod has no stable
    IP address.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要服务来将通信调度到Pods，因为Pod没有稳定的IP地址。
- en: Kubernetes offers higher-level entities called Ingresses that are built on top
    of services, empowering clusters with all the advanced capabilities offered by
    a web server, such as routing HTTP/HTTPS URLs from outside the cluster to internal
    service URLs inside the cluster.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes提供了更高层次的实体，称为Ingress，它建立在服务之上，赋予集群所有由Web服务器提供的先进功能，例如将集群外部的HTTP/HTTPS
    URL路由到集群内部的内部服务URL。
- en: Helm charts are a way to organize the templating and installation of complex
    Kubernetes applications that contain several `.yaml` files.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Helm图表是一种组织复杂Kubernetes应用程序模板化和安装的方式，这些应用程序包含多个`.yaml`文件。
- en: Yes, with the `---` separator.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，使用`---`分隔符。
- en: Kubernetes detects container faults through liveness and readiness probes that
    check the health and availability of containers, ensuring they run as expected.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes通过检查容器的健康和可用性来检测容器故障，这些检查是通过存活和就绪探针完成的，确保它们按预期运行。
- en: Because Pods, having no stable location, can’t rely on the storage of the node
    where they are currently running.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为Pods没有稳定的地点，不能依赖于它们当前运行节点的存储。
- en: '`StatefulSet` is assumed to have state and achieve write/update parallelism
    through sharding, while `ReplicaSet` has no state, so as it is indistinguishable,
    it can achieve parallelism by splitting the load.'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StatefulSet`假定具有状态并通过分片实现写/更新并行性，而`ReplicaSet`没有状态，因此无法区分，可以通过分割负载来实现并行性。'
- en: Chapter 21
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第21章
- en: It is because it doesn’t support TCP/IP communications.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是因为它不支持TCP/IP通信。
- en: Visual Studio’s recommended tool to debug Kubernetes applications.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio推荐的工具用于调试Kubernetes应用程序。
- en: No, it works with any Kubernetes cluster that has been configured as the default
    cluster in the local Kubectl installation.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，它与任何已配置为本地Kubectl安装中默认集群的Kubernetes集群兼容。
- en: With something like `minikube` `image` `load` `grpcmicroservice:latest`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用类似`minikube` `image` `load` `grpcmicroservice:latest`这样的命令。
- en: It is enough to start Minikube, and Minikube’s start procedure will do it for
    you.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需启动Minikube，Minikube的启动过程就会为您完成。
- en: Learn more on Discord
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多信息
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的Discord社区——在那里您可以分享反馈、向作者提问以及了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
- en: '![](img/QR_Code175081751210902046.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code175081751210902046.png)'
