<html><head></head><body>
  <div id="_idContainer063">
   <h1 class="chapter-number" id="_idParaDest-77">
    <a id="_idTextAnchor078">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     5
    </span>
   </h1>
   <h1 id="_idParaDest-78">
    <a id="_idTextAnchor079">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Working with Data and Persistence
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     Every application, at some point, will consume data, whether through services or even in a data source, such as a SQL Server database or MySQL.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     Interacting with the database is an important feature, and ASP.NET Core 9 offers mechanisms such as Entity Framework Core and easily integrates with other database interface providers, such as Dapper, a library optimized for abstracting data access in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      simple way.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     In this chapter, we’re going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.7.1">
      Connecting to a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.8.1">
       SQL database
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.9.1">
      Understanding SQL, NoSQL, ORM, and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.10.1">
       Micro ORM
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.11.1">
      Working with Entity Framework core
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.12.1">
       and Dapper
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.13.1">
     We will explore communication between web applications and databases using technologies such as Entity Framework and Dapper, in addition to understanding important concepts such as the use of ORM and different data
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.14.1">
      persistence models.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-79">
    <a id="_idTextAnchor080">
    </a>
    <span class="koboSpan" id="kobo.15.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.16.1">
     This chapter has some prerequisites in order to get the most out of it.
    </span>
    <span class="koboSpan" id="kobo.16.2">
     Therefore, you will need to install Docker and Azure
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.17.1">
      Data Studio.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.18.1">
     All source code and examples for this chapter can be found in the GitHub repository
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.19.1">
      at
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter05">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.20.1">
       https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter05
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.21.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-80">
    <a id="_idTextAnchor081">
    </a>
    <span class="koboSpan" id="kobo.22.1">
     Docker installation
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.23.1">
     We will use Docker
    </span>
    <a id="_idIndexMarker290">
    </a>
    <span class="koboSpan" id="kobo.24.1">
     as the basis for running a SQL database server.
    </span>
    <span class="koboSpan" id="kobo.24.2">
     Using Docker will avoid the problems associated with installing databases on different operating systems as it is a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.25.1">
      portable option.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.26.1">
     To install Docker, follow the instructions for your
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.27.1">
      operating system.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.28.1">
     Windows
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.29.1">
     Run
    </span>
    <a id="_idIndexMarker291">
    </a>
    <span class="koboSpan" id="kobo.30.1">
     the following
    </span>
    <a id="_idIndexMarker292">
    </a>
    <span class="koboSpan" id="kobo.31.1">
     command as an administrator on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.32.1">
      the terminal:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.33.1">
winget install -e --id Docker.DockerDesktop</span></pre>
   <h3>
    <span class="koboSpan" id="kobo.34.1">
     Mac
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.35.1">
     Access
    </span>
    <a id="_idIndexMarker293">
    </a>
    <span class="koboSpan" id="kobo.36.1">
     the following link
    </span>
    <a id="_idIndexMarker294">
    </a>
    <span class="koboSpan" id="kobo.37.1">
     and follow the tutorial for installation
    </span>
    <a id="_idIndexMarker295">
    </a>
    <span class="koboSpan" id="kobo.38.1">
     according to your
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.39.1">
      processor:
     </span>
    </span>
    <a href="https://docs.docker.com/desktop/install/mac-install/#install-and-run-docker-desktop-on-mac">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.40.1">
       https://docs.docker.com/desktop/install/mac-install/#install-and-run-docker-desktop-on-mac
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.41.1">
      .
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.42.1">
     Linux
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.43.1">
     Docker
    </span>
    <a id="_idIndexMarker296">
    </a>
    <span class="koboSpan" id="kobo.44.1">
     supports
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.45.1">
      Ubuntu
     </span>
    </strong>
    <span class="koboSpan" id="kobo.46.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.47.1">
      Debian
     </span>
    </strong>
    <span class="koboSpan" id="kobo.48.1">
     , and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.49.1">
      Fedora
     </span>
    </strong>
    <span class="koboSpan" id="kobo.50.1">
     .
    </span>
    <span class="koboSpan" id="kobo.50.2">
     Use
    </span>
    <a id="_idIndexMarker297">
    </a>
    <span class="koboSpan" id="kobo.51.1">
     the instructions
    </span>
    <a id="_idIndexMarker298">
    </a>
    <span class="koboSpan" id="kobo.52.1">
     according to
    </span>
    <a id="_idIndexMarker299">
    </a>
    <span class="koboSpan" id="kobo.53.1">
     your
    </span>
    <a id="_idIndexMarker300">
    </a>
    <span class="koboSpan" id="kobo.54.1">
     platform
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.55.1">
      at
     </span>
    </span>
    <a href="https://docs.docker.com/desktop/install/linux-install/">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.56.1">
       https://docs.docker.com/desktop/install/linux-install/
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.57.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-81">
    <a id="_idTextAnchor082">
    </a>
    <span class="koboSpan" id="kobo.58.1">
     Azure Data Studio
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.59.1">
     Azure Data Studio is
    </span>
    <a id="_idIndexMarker301">
    </a>
    <span class="koboSpan" id="kobo.60.1">
     a specialized database editor and will be used to perform database operations, such as table creation, inclusion, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.61.1">
      record querying.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.62.1">
     Its installation is simple, and it
    </span>
    <a id="_idIndexMarker302">
    </a>
    <span class="koboSpan" id="kobo.63.1">
     supports different operating
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.64.1">
      systems:
     </span>
    </span>
    <a href="https://learn.microsoft.com/en-us/azure-data-studio/download-azure-data-studio?tabs=win-install%2Cwin-user-install%2Credhat-install%2Cwindows-uninstall%2Credhat-uninstall#download-azure-data-studio">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.65.1">
       https://learn.microsoft.com/en-us/azure-data-studio/download-azure-data-studio?tabs=win-install%2Cwin-user-install%2Credhat-install%2Cwindows-uninstall%2Credhat-uninstall#download-azure-data-studio
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.66.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-82">
    <a id="_idTextAnchor083">
    </a>
    <span class="koboSpan" id="kobo.67.1">
     Connecting to a SQL database
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.68.1">
     In each chapter, we have learned about
    </span>
    <a id="_idIndexMarker303">
    </a>
    <span class="koboSpan" id="kobo.69.1">
     different aspects involving ASP.NET Core 9 and how this platform provides a large number of resources for the development of the most diverse types of applications.
    </span>
    <span class="koboSpan" id="kobo.69.2">
     Each application has a purpose, which is to process data that generates information for users.
    </span>
    <span class="koboSpan" id="kobo.69.3">
     However, at some point, your application will end up interacting with a data
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.70.1">
      persistence model.
     </span>
    </span>
   </p>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.71.1">
      Data persistence
     </span>
    </strong>
    <span class="koboSpan" id="kobo.72.1">
     occurs
    </span>
    <a id="_idIndexMarker304">
    </a>
    <span class="koboSpan" id="kobo.73.1">
     in several ways, but in general, it is the serialization of information allocated in memory to the disk, which can be in the form of files, and commonly takes place using a data persistence platform, such as a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.74.1">
      Database Management System
     </span>
    </strong>
    <span class="koboSpan" id="kobo.75.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.76.1">
      DBMS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.77.1">
     ) or
    </span>
    <a id="_idIndexMarker305">
    </a>
    <span class="koboSpan" id="kobo.78.1">
     non-relational data.
    </span>
    <span class="koboSpan" id="kobo.78.2">
     We will discuss these two persistence models in more
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.79.1">
      depth soon.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.80.1">
     Most applications use a persistence model based on databases such as SQL Server, Oracle, and MySQL.
    </span>
    <span class="koboSpan" id="kobo.80.2">
     Each DBMS has models of administration, typing, and organization of resources; however, they share the same purpose of persisting data in a tabular format and
    </span>
    <a id="_idIndexMarker306">
    </a>
    <span class="koboSpan" id="kobo.81.1">
     use
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.82.1">
      Structured Query Language
     </span>
    </strong>
    <span class="koboSpan" id="kobo.83.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.84.1">
      SQL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.85.1">
     ) to manipulate and manage all
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.86.1">
      persisted data.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.87.1">
     ASP.NET Core 9 can communicate with different types of DBMS, but we will focus on the SQL
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.88.1">
      Server database.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.89.1">
     For an application to connect to a database, the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.90.1">
      are necessary:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.91.1">
      A database driver (a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.92.1">
       NuGet package)
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.93.1">
      A
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.94.1">
       connection string
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.95.1">
      Access to the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.96.1">
       desired resource
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.97.1">
     With this model, we
    </span>
    <a id="_idIndexMarker307">
    </a>
    <span class="koboSpan" id="kobo.98.1">
     can connect to any database that has a NuGet package ported to the .NET platform, such as the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.99.1">
      System.Data.SqlClient
     </span>
    </strong>
    <span class="koboSpan" id="kobo.100.1">
     package for SQL databases, allowing applications to easily implement a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.101.1">
      persistence model.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.102.1">
     Now that we know the principles related to the interaction between applications and data persistence, let’s learn how the ASP.NET Core 9 platform communicates with a SQL
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.103.1">
      Server database.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-83">
    <a id="_idTextAnchor084">
    </a>
    <span class="koboSpan" id="kobo.104.1">
     Preparing SQL Server
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.105.1">
     In current versions
    </span>
    <a id="_idIndexMarker308">
    </a>
    <span class="koboSpan" id="kobo.106.1">
     of the .NET platform, they work mainly with the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.107.1">
      dependency injection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.108.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.109.1">
      DI
     </span>
    </strong>
    <span class="koboSpan" id="kobo.110.1">
     ) design pattern, which allows
    </span>
    <a id="_idIndexMarker309">
    </a>
    <span class="koboSpan" id="kobo.111.1">
     the use of a technique
    </span>
    <a id="_idIndexMarker310">
    </a>
    <span class="koboSpan" id="kobo.112.1">
     called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.113.1">
      inversion of control
     </span>
    </strong>
    <span class="koboSpan" id="kobo.114.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.115.1">
      IoC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.116.1">
     ), causing classes and their dependencies to be managed by the .NET
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.117.1">
      dependency container.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.118.1">
     DI in .NET
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.119.1">
     The DI pattern design’s main objective is to abstract the management of class instances and their respective dependencies.
    </span>
    <span class="koboSpan" id="kobo.119.2">
     It is a common practice in most high-performance solutions.
    </span>
    <span class="koboSpan" id="kobo.119.3">
     If you want to learn more about
    </span>
    <a id="_idIndexMarker311">
    </a>
    <span class="koboSpan" id="kobo.120.1">
     DI,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.121.1">
      visit
     </span>
    </span>
    <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-9.0">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.122.1">
       https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-9.0
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.123.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.124.1">
     Through DI, we can register a class to control the connection to the database.
    </span>
    <span class="koboSpan" id="kobo.124.2">
     We will work with this approach in the topic where we will learn about using the Entity Framework in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.125.1">
      Working with EF Core and
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.126.1">
       Dapper
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.127.1">
      section.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.128.1">
     For now, it is important to understand the fundamentals of communicating between an application and the database.
    </span>
    <span class="koboSpan" id="kobo.128.2">
     We will use SQL Server as the DBMS and for this, you must consult the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.129.1">
      Technical requirements
     </span>
    </em>
    <span class="koboSpan" id="kobo.130.1">
     section and install the Docker Engine.
    </span>
    <span class="koboSpan" id="kobo.130.2">
     How Docker works is beyond the scope of this book.
    </span>
    <span class="koboSpan" id="kobo.130.3">
     However, its use will allow you to continue with the examples described in this chapter without any
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.131.1">
      compatibility problems.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.132.1">
     Let’s start configuring
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.133.1">
      the database:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.134.1">
      The first step is to run a Docker container to run SQL Server.
     </span>
     <span class="koboSpan" id="kobo.134.2">
      We will use the following command to start an instance of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.135.1">
       SQL Server:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.136.1">docker run -d -e "ACCEPT_EULA=Y" -e "MSSQL_SA_PASSWORD=Password123" -p 1433:1433 mcr.microsoft.com/mssql/server:2019-latest</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.137.1">
       Let’s review the
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.138.1">
        preceding command:
       </span>
      </span>
     </p>
     <ul>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.139.1">
         docker run
        </span>
       </strong>
       <span class="koboSpan" id="kobo.140.1">
        : This uses the Docker Engine to run
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.141.1">
         a container.
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.142.1">
         -d
        </span>
       </strong>
       <span class="koboSpan" id="kobo.143.1">
        : This parameter is used to execute the command in
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.144.1">
         the background.
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.145.1">
         -e
        </span>
       </strong>
       <span class="koboSpan" id="kobo.146.1">
        : These are definitions of environment variables, used when starting the container.
       </span>
       <span class="koboSpan" id="kobo.146.2">
        In this case, the
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.147.1">
         ACCEPT_EULA
        </span>
       </strong>
       <span class="koboSpan" id="kobo.148.1">
        variable is configured to agree with Microsoft’s terms and the
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.149.1">
         MSSQL_SA_PASSWORD
        </span>
       </strong>
       <span class="koboSpan" id="kobo.150.1">
        parameter is where a password is defined for the SA user, the default SQL
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.151.1">
         user administrator.
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.152.1">
         -p
        </span>
       </strong>
       <span class="koboSpan" id="kobo.153.1">
        : This defines the port of the host machine that will be used to communicate with port 1433 of the container.
       </span>
       <span class="koboSpan" id="kobo.153.2">
        In this scenario, we’re defining the host and container ports as the
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.154.1">
         same, 1433.
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.155.1">
         mcr.microsoft.com/mssql/server:2019-latest
        </span>
       </strong>
       <span class="koboSpan" id="kobo.156.1">
        : This is the type and version of the Docker image that will
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.157.1">
         be run.
        </span>
       </span>
      </li>
     </ul>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.158.1">
       Docker does all
      </span>
      <a id="_idIndexMarker312">
      </a>
      <span class="koboSpan" id="kobo.159.1">
       the magic of downloading the SQL Server image onto your machine and running it in a virtualized way.
      </span>
      <span class="koboSpan" id="kobo.159.2">
       The preceding command will return a hash code indicating that the image
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.160.1">
        is running.
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.161.1">
      Now, run the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.162.1">
       following command:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.163.1">docker ps</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.164.1">
      The running image will be listed as shown in
     </span>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.165.1">
        Figure 5
       </span>
      </em>
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.166.1">
       .1
      </span>
     </em>
     <span class="koboSpan" id="kobo.167.1">
      , and the number of images listed may be different if you already
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.168.1">
       use Docker.
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer053">
     <span class="koboSpan" id="kobo.169.1">
      <img alt="Figure 5.1 – Docker image running" src="image/B21788_05_1.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.170.1">
     Figure 5.1 – Docker image running
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.171.1">
     Learn more about Docker
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.172.1">
     To learn more about Docker, take a look at the
    </span>
    <a id="_idIndexMarker313">
    </a>
    <span class="koboSpan" id="kobo.173.1">
     following official
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.174.1">
      documentation:
     </span>
    </span>
    <a href="https://docs.docker.com/">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.175.1">
       https://docs.docker.com/
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.176.1">
      .
     </span>
    </span>
   </p>
   <ol>
    <li value="4">
     <span class="koboSpan" id="kobo.177.1">
      Now that we have the image
     </span>
     <a id="_idIndexMarker314">
     </a>
     <span class="koboSpan" id="kobo.178.1">
      running, open
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.179.1">
       Azure Data Studio
      </span>
     </strong>
     <span class="koboSpan" id="kobo.180.1">
      , installed as described in the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.181.1">
       Technical requirements
      </span>
     </em>
     <span class="koboSpan" id="kobo.182.1">
      section, and click the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.183.1">
       Create a connection
      </span>
     </strong>
     <span class="koboSpan" id="kobo.184.1">
      button, as highlighted in
     </span>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.185.1">
        Figure 5
       </span>
      </em>
     </span>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.186.1">
        .2
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.187.1">
       :
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer054">
     <span class="koboSpan" id="kobo.188.1">
      <img alt="Figure 5.2 – Creating a connection to the database" src="image/B21788_05_2.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.189.1">
     Figure 5.2 – Creating a connection to the database
    </span>
   </p>
   <ol>
    <li value="5">
     <span class="koboSpan" id="kobo.190.1">
      Fill in the fields
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.191.1">
       as follows:
      </span>
     </span>
     <ul>
      <li>
       <span class="No-Break">
        <strong class="bold">
         <span class="koboSpan" id="kobo.192.1">
          Server
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.193.1">
         :
        </span>
       </span>
       <span class="No-Break">
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.194.1">
          localhost,1433
         </span>
        </strong>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.195.1">
         Authentication type
        </span>
       </strong>
       <span class="koboSpan" id="kobo.196.1">
        :
       </span>
       <span class="No-Break">
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.197.1">
          SQL Login
         </span>
        </strong>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.198.1">
         User
        </span>
       </strong>
       <span class="No-Break">
        <strong class="bold">
         <span class="koboSpan" id="kobo.199.1">
          name
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.200.1">
         :
        </span>
       </span>
       <span class="No-Break">
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.201.1">
          sa
         </span>
        </strong>
       </span>
      </li>
      <li>
       <span class="No-Break">
        <strong class="bold">
         <span class="koboSpan" id="kobo.202.1">
          Password
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.203.1">
         :
        </span>
       </span>
       <span class="No-Break">
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.204.1">
          Password123
         </span>
        </strong>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <span class="koboSpan" id="kobo.205.1">
      Keep the
     </span>
     <a id="_idIndexMarker315">
     </a>
     <span class="koboSpan" id="kobo.206.1">
      other parameters as they are, then click
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.207.1">
       Connect
      </span>
     </strong>
     <span class="koboSpan" id="kobo.208.1">
      .
     </span>
     <span class="koboSpan" id="kobo.208.2">
      In some cases, a popup will be displayed informing you about the use of certificates.
     </span>
     <span class="koboSpan" id="kobo.208.3">
      Just click the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.209.1">
       Enable Trust server certificate
      </span>
     </strong>
     <span class="koboSpan" id="kobo.210.1">
      button.
     </span>
     <span class="koboSpan" id="kobo.210.2">
      This certificate is automatically created by Azure Data Studio, so
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.211.1">
       don’t worry.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.212.1">
      After making the connection, you will have access to the server, which only has the standard databases.
     </span>
     <span class="koboSpan" id="kobo.212.2">
      Click on the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.213.1">
       New Query
      </span>
     </strong>
     <span class="koboSpan" id="kobo.214.1">
      option and you will see a new tab, as shown in
     </span>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.215.1">
        Figure 5
       </span>
      </em>
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.216.1">
       .3
      </span>
     </em>
     <span class="koboSpan" id="kobo.217.1">
      , that we will use to create a database and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.218.1">
       a table.
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer055">
     <span class="koboSpan" id="kobo.219.1">
      <img alt="Figure 5.3 – New Query tab" src="image/B21788_05_3.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.220.1">
     Figure 5.3 – New Query tab
    </span>
   </p>
   <ol>
    <li value="8">
     <span class="koboSpan" id="kobo.221.1">
      Now, in the book GitHub repository, in the
     </span>
     <a href="B21788_05.xhtml#_idTextAnchor078">
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.222.1">
         Chapter 5
        </span>
       </em>
      </span>
     </a>
     <span class="koboSpan" id="kobo.223.1">
      folder, copy the code from the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.224.1">
       InitialDb.sql
      </span>
     </strong>
     <span class="koboSpan" id="kobo.225.1">
      file and paste it into the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.226.1">
       New Query
      </span>
     </strong>
     <span class="koboSpan" id="kobo.227.1">
      tab, created previously, in Azure
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.228.1">
       Data Studio.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.229.1">
      Then click the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.230.1">
       Run
      </span>
     </strong>
     <span class="koboSpan" id="kobo.231.1">
      button.
     </span>
     <span class="koboSpan" id="kobo.231.2">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.232.1">
       DbStore
      </span>
     </strong>
     <span class="koboSpan" id="kobo.233.1">
      database and the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.234.1">
       Product
      </span>
     </strong>
     <span class="koboSpan" id="kobo.235.1">
      table will be created, and
     </span>
     <a id="_idIndexMarker316">
     </a>
     <span class="koboSpan" id="kobo.236.1">
      some products will be inserted as an example
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.237.1">
       of data.
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.238.1">
     Now that we have prepared the SQL database, it’s time to create a simple console application, make the connection, and list the data from the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.239.1">
      product table.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-84">
    <a id="_idTextAnchor085">
    </a>
    <span class="koboSpan" id="kobo.240.1">
     Using the SQL client
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.241.1">
     As mentioned
    </span>
    <a id="_idIndexMarker317">
    </a>
    <span class="koboSpan" id="kobo.242.1">
     previously, the .NET platform has more modern ways of establishing a connection to the database and we will talk more about this subject in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.243.1">
      ORM and Micro ORM
     </span>
    </em>
    <span class="koboSpan" id="kobo.244.1">
     section.
    </span>
    <span class="koboSpan" id="kobo.244.2">
     However, it is important that you understand the fundamentals of communication between an application and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.245.1">
      a database.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.246.1">
     To do this, we will create a console application and add the necessary NuGet package to connect to the previously prepared
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.247.1">
      SQL Server.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.248.1">
     Then, we’ll open the terminal in a folder of your choice and execute the following commands
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.249.1">
      in sequence:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.250.1">
dotnet new console -n MyFirstDbConnection
cd MyFirstDbConnection
dotnet add package System.Data.SqlClient
code.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.251.1">
     With the project ready, we will need to carry out the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.252.1">
      following steps:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.253.1">
      Create a connection to the database.
     </span>
     <span class="koboSpan" id="kobo.253.2">
      We will use the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.254.1">
        SqlConnection
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.255.1">
       class.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.256.1">
      Open
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.257.1">
       the connection.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.258.1">
      Create a SQL command that will be executed.
     </span>
     <span class="koboSpan" id="kobo.258.2">
      We will use the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.259.1">
        SqlCommand
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.260.1">
       class.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.261.1">
      Read data
     </span>
     <a id="_idIndexMarker318">
     </a>
     <span class="koboSpan" id="kobo.262.1">
      based on the SQL command.
     </span>
     <span class="koboSpan" id="kobo.262.2">
      We will use the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.263.1">
        SQLDataReader
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.264.1">
       class.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.265.1">
      Display the data on
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.266.1">
       the screen.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.267.1">
      Close
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.268.1">
       the connection.
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.269.1">
     In just six steps, we will be able to interact with a data source.
    </span>
    <span class="koboSpan" id="kobo.269.2">
     The code in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.270.1">
      Program.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.271.1">
     file must be identical to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.272.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.273.1">
using System.Data.SqlClient;
SqlConnection sql = new SqlConnection("Server=localhost,
  1433;Database=DbStore; user id=sa;
  password=Password123");
try
{
    sql.Open();
    Console.WriteLine("Connection Opened");
    SqlCommand cmd = new SqlCommand(
      "select * from Product", sql);
    SqlDataReader reader = cmd.ExecuteReader();
    while (reader.Read())
    {
        Console.WriteLine($"{reader[0]} - {reader[1]}
          - {reader[2]:C2}");
    }
}
catch (Exception ex)
{
    Console.WriteLine(ex.Message);
}
finally
{
    sql.Close();
    Console.WriteLine("Connection Closed");
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.274.1">
     Let’s discuss the
    </span>
    <a id="_idIndexMarker319">
    </a>
    <span class="koboSpan" id="kobo.275.1">
     most important details of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.276.1">
      this implementation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.277.1">
     The first step was to create the database connection class,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.278.1">
      SqlConnection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.279.1">
     , which receives a connection string as a parameter in the constructor.
    </span>
    <span class="koboSpan" id="kobo.279.2">
     The connection string can be understood as the address of the database server.
    </span>
    <span class="koboSpan" id="kobo.279.3">
     In this case, this address is made up of three basic properties:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.280.1">
      Server
     </span>
    </strong>
    <span class="koboSpan" id="kobo.281.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.282.1">
      user id
     </span>
    </strong>
    <span class="koboSpan" id="kobo.283.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.284.1">
      password
     </span>
    </strong>
    <span class="koboSpan" id="kobo.285.1">
     .
    </span>
    <span class="koboSpan" id="kobo.285.2">
     The default connection port is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.286.1">
      1433
     </span>
    </strong>
    <span class="koboSpan" id="kobo.287.1">
     , which can be omitted, but you must explicitly define it if the connection port is different.
    </span>
    <span class="koboSpan" id="kobo.287.2">
     These are the same parameters used previously to connect to the database through Azure Data Studio through
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.288.1">
      the UI.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.289.1">
     The connection string offers
    </span>
    <a id="_idIndexMarker320">
    </a>
    <span class="koboSpan" id="kobo.290.1">
     several other types of parameters to determine how the connection will be made.
    </span>
    <span class="koboSpan" id="kobo.290.2">
     The version we are currently using is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.291.1">
      the simplest.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.292.1">
     Connection String
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.293.1">
     As mentioned, the
    </span>
    <a id="_idIndexMarker321">
    </a>
    <span class="koboSpan" id="kobo.294.1">
     connection string is made up of different parameters, including sensitive data such as username and password.
    </span>
    <span class="koboSpan" id="kobo.294.2">
     For this reason, it is good practice to keep connection string management out of the source code, to prevent vulnerabilities and to prevent sensitive data from being available in the application’s version control.
    </span>
    <span class="koboSpan" id="kobo.294.3">
     We will learn secure credential management approaches in
    </span>
    <a href="B21788_09.xhtml#_idTextAnchor146">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.295.1">
        Chapter 9
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.296.1">
     .
    </span>
    <span class="koboSpan" id="kobo.296.2">
     More details about
    </span>
    <a id="_idIndexMarker322">
    </a>
    <span class="koboSpan" id="kobo.297.1">
     connection strings can be found in this great
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.298.1">
      reference:
     </span>
    </span>
    <a href="https://www.connectionstrings.com/sql-server/">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.299.1">
       https://www.connectionstrings.com/sql-server/
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.300.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.301.1">
     After creating the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.302.1">
      SqlConnection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.303.1">
     object, it is time to open the connection using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.304.1">
      sql.Open()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.305.1">
     code.
    </span>
    <span class="koboSpan" id="kobo.305.2">
     Next, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.306.1">
      SqlCommand
     </span>
    </strong>
    <span class="koboSpan" id="kobo.307.1">
     class is created, where the constructor receives an SQL string and also the database
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.308.1">
      connection object.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.309.1">
     The SQL code used performs a simple query on the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.310.1">
      Product
     </span>
    </strong>
    <span class="koboSpan" id="kobo.311.1">
     table, obtaining all available rows
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.312.1">
      and columns.
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.313.1">
      SqlCommand
     </span>
    </strong>
    <span class="koboSpan" id="kobo.314.1">
     has different methods, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.315.1">
      ExecuteNonQuery
     </span>
    </strong>
    <span class="koboSpan" id="kobo.316.1">
     , that are generally used to execute commands that change the database, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.317.1">
      Insert
     </span>
    </strong>
    <span class="koboSpan" id="kobo.318.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.319.1">
      Delete
     </span>
    </strong>
    <span class="koboSpan" id="kobo.320.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.321.1">
      Update
     </span>
    </strong>
    <span class="koboSpan" id="kobo.322.1">
     , or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.323.1">
      ExecuteReader
     </span>
    </strong>
    <span class="koboSpan" id="kobo.324.1">
     , which is being used in this example to obtain data from the Product table.
    </span>
    <span class="koboSpan" id="kobo.324.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.325.1">
      ExecuteReader
     </span>
    </strong>
    <span class="koboSpan" id="kobo.326.1">
     method returns an object of type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.327.1">
      SqlDataReader
     </span>
    </strong>
    <span class="koboSpan" id="kobo.328.1">
     , which abstracts the rows and columns into an object, where it is possible to perform interactions and access
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.329.1">
      table information.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.330.1">
     All this abstraction work is done by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.331.1">
      System.Data.SqlClient
     </span>
    </strong>
    <span class="koboSpan" id="kobo.332.1">
     library, which has access to the SQL Server database connection driver and provides several classes for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.333.1">
      manipulating data.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.334.1">
     After obtaining the data by executing the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.335.1">
      ExecuteReader
     </span>
    </strong>
    <span class="koboSpan" id="kobo.336.1">
     method, we finally iterate on the returned object by displaying the data obtained from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.337.1">
      the database.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.338.1">
     All code is protected by a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.339.1">
      try..catch..finally
     </span>
    </strong>
    <span class="koboSpan" id="kobo.340.1">
     block to guarantee error handling and, above all, to close the connection at the end
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.341.1">
      of use.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.342.1">
     We can analyze the result of listing the database records in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.343.1">
       Figure 5
      </span>
     </em>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.344.1">
       .4
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.345.1">
      :
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer056">
     <span class="koboSpan" id="kobo.346.1">
      <img alt="Figure 5.4 – Displaying records in the Product table" src="image/B21788_05_4.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.347.1">
     Figure 5.4 – Displaying records in the Product table
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.348.1">
     Despite being a
    </span>
    <a id="_idIndexMarker323">
    </a>
    <span class="koboSpan" id="kobo.349.1">
     simple application, we learned important concepts and fundamentals related to interactions between applications and databases.
    </span>
    <span class="koboSpan" id="kobo.349.2">
     We use SQL Server as a base, but the lessons learned apply to other data sources, such as MySQL or Oracle, varying, of course, the connection, command, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.350.1">
      reading objects.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.351.1">
     Furthermore, we prepared the basis of the environment for the remainder of the chapter, where we will explore other concepts, starting with the differences between relational and non-relational databases, in addition to understanding what ORM and Micro
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.352.1">
      ORMs are.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-85">
    <a id="_idTextAnchor086">
    </a>
    <span class="koboSpan" id="kobo.353.1">
     Understanding SQL, NoSQL, ORM, and Micro ORM
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.354.1">
     With the emergence of different application structures and needs, different ways of managing data have also been developed.
    </span>
    <span class="koboSpan" id="kobo.354.2">
     Choosing the right database and interaction methods has a significant impact on application performance, scalability,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.355.1">
      and maintainability.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.356.1">
     Likewise, with the increase in systems complexity, new technologies for manipulating data obtained through DBMSs have also emerged, such
    </span>
    <a id="_idIndexMarker324">
    </a>
    <span class="koboSpan" id="kobo.357.1">
     as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.358.1">
      Object-relational mapping
     </span>
    </strong>
    <span class="koboSpan" id="kobo.359.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.360.1">
      ORM
     </span>
    </strong>
    <span class="koboSpan" id="kobo.361.1">
     ) and
    </span>
    <a id="_idIndexMarker325">
    </a>
    <span class="koboSpan" id="kobo.362.1">
     micro ORM.
    </span>
    <span class="koboSpan" id="kobo.362.2">
     Each of the technologies has benefits for certain contexts, and it is important to know them correctly as there are no
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.363.1">
      silver bullets.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-86">
    <a id="_idTextAnchor087">
    </a>
    <span class="koboSpan" id="kobo.364.1">
     SQL versus NoSQL
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.365.1">
     The complexity of applications and
    </span>
    <a id="_idIndexMarker326">
    </a>
    <span class="koboSpan" id="kobo.366.1">
     different data management needs have led to
    </span>
    <a id="_idIndexMarker327">
    </a>
    <span class="koboSpan" id="kobo.367.1">
     several challenges for companies, such as having suitable performance for managing large amounts of data, which leads to maintainability and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.368.1">
      scalability challenges.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.369.1">
     Along with these variables, keeping the servers running perfectly is expensive.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.370.1">
      Relational Database Management System
     </span>
    </strong>
    <span class="koboSpan" id="kobo.371.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.372.1">
      RDBMS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.373.1">
     ) were
    </span>
    <a id="_idIndexMarker328">
    </a>
    <span class="koboSpan" id="kobo.374.1">
     the main means of tracking organizations’ information, and their approach in a relational model that prioritizes the integrity and relationship between information has defined how development teams handle data manipulation
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.375.1">
      for years.
     </span>
    </span>
   </p>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.376.1">
      Relational databases
     </span>
    </strong>
    <span class="koboSpan" id="kobo.377.1">
     have
    </span>
    <a id="_idIndexMarker329">
    </a>
    <span class="koboSpan" id="kobo.378.1">
     tables that represent a type of information.
    </span>
    <span class="koboSpan" id="kobo.378.2">
     This information is distributed in columns, representing the characteristics of a piece of data.
    </span>
    <span class="koboSpan" id="kobo.378.3">
     Complete data is determined in a row of a table.
    </span>
    <span class="koboSpan" id="kobo.378.4">
     Tables can have relationships with other tables, associating different data to compose information.
    </span>
    <span class="koboSpan" id="kobo.378.5">
     That’s why they are called relational models.
    </span>
    <span class="koboSpan" id="kobo.378.6">
     The example in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.379.1">
       Figure 5
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.380.1">
      .5
     </span>
    </em>
    <span class="koboSpan" id="kobo.381.1">
     shows some tables and their relationships, representing a data abstraction from a bank
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.382.1">
      account application:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer057">
     <span class="koboSpan" id="kobo.383.1">
      <img alt="Figure 5.5 – Basic bank account data model" src="image/B21788_05_5.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.384.1">
     Figure 5.5 – Basic bank account data model
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.385.1">
     In the figure, you can see that a customer has an account that has transactions.
    </span>
    <span class="koboSpan" id="kobo.385.2">
     This is a basic representation of this context.
    </span>
    <span class="koboSpan" id="kobo.385.3">
     But in large contexts, this relational structure model leads to different challenges for companies and follows the application development model based on how data should
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.386.1">
      be persisted.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.387.1">
     Relational databases
    </span>
    <a id="_idIndexMarker330">
    </a>
    <span class="koboSpan" id="kobo.388.1">
     provide flexibility; however, basing applications on the data
    </span>
    <a id="_idIndexMarker331">
    </a>
    <span class="koboSpan" id="kobo.389.1">
     model shown in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.390.1">
       Figure 5
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.391.1">
      .5
     </span>
    </em>
    <span class="koboSpan" id="kobo.392.1">
     leads to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.393.1">
      several challenges.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.394.1">
     Modern systems need to have flexibility and elasticity, and in some cases must be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.395.1">
      technology agnostic.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.396.1">
     With the emergence of the cloud, the possibility of having elastic resources also emerged.
    </span>
    <span class="koboSpan" id="kobo.396.2">
     However, maintaining a cluster of data and synchronizing and managing it is not an easy or cheap task, even in cloud environments.
    </span>
    <span class="koboSpan" id="kobo.396.3">
     Nowadays, through
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.397.1">
      Platform as a Service
     </span>
    </strong>
    <span class="koboSpan" id="kobo.398.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.399.1">
      PaaS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.400.1">
     ), such
    </span>
    <a id="_idIndexMarker332">
    </a>
    <span class="koboSpan" id="kobo.401.1">
     activities are abstracted by cloud providers; however, they come at
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.402.1">
      a cost.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.403.1">
     With the evolution of technology, other types of persistence models and different opportunities for applications and companies have emerged.
    </span>
    <span class="koboSpan" id="kobo.403.2">
     One of the big terms generally misunderstood in the technical community a few years ago was the term
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.404.1">
      NoSQL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.405.1">
     , which means
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.406.1">
      non-relational database
     </span>
    </strong>
    <span class="koboSpan" id="kobo.407.1">
     or
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.408.1">
       not-only SQL
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.409.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.410.1">
     This persistence model has a different approach to the traditional relational model.
    </span>
    <span class="koboSpan" id="kobo.410.2">
     NoSQL databases have a more flexible data structure that does not have many restrictions about how data will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.411.1">
      be persisted.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.412.1">
     For many years, NoSQL
    </span>
    <a id="_idIndexMarker333">
    </a>
    <span class="koboSpan" id="kobo.413.1">
     was seen as the new persistence model for DBMSs, causing
    </span>
    <a id="_idIndexMarker334">
    </a>
    <span class="koboSpan" id="kobo.414.1">
     companies to try to migrate to this model without fully understanding the fundamentals and using relational database approaches in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.415.1">
      NoSQL structures.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.416.1">
     This way of interacting with a different source of data persistence had several benefits, including making developers, engineers, and companies change their perspective on application development, but focused on the business instead of how the data should
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.417.1">
      be persisted.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.418.1">
     In
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.419.1">
       Figure 5
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.420.1">
      .6
     </span>
    </em>
    <span class="koboSpan" id="kobo.421.1">
     , we can see most of the differences between relational databases and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.422.1">
      NoSQL databases.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer058">
     <span class="koboSpan" id="kobo.423.1">
      <img alt="Figure 5.6 – Biggest differences in relational databases and NoSQL" src="image/B21788_05_6.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.424.1">
     Figure 5.6 – Biggest differences in relational databases and NoSQL
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.425.1">
     The NoSQL
    </span>
    <a id="_idIndexMarker335">
    </a>
    <span class="koboSpan" id="kobo.426.1">
     approach offers different types of data persistence that bring several benefits to applications.
    </span>
    <span class="koboSpan" id="kobo.426.2">
     The most common are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.427.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.428.1">
      Key-value stores (
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.429.1">
       Redis, Memcached)
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.430.1">
      Document databases (
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.431.1">
       MongoDB, Couchbase)
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.432.1">
      Column-family databases (
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.433.1">
       Cassandra, HBase)
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.434.1">
      Graph databases (
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.435.1">
       Neo4j, OrientDB)
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.436.1">
     Likewise, the data manipulation model for NoSQL is different from relational databases, and query methods vary depending on the NoSQL database type and may not be as standardized
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.437.1">
      as SQL.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.438.1">
     Furthermore, it is important to understand that NoSQL databases often prioritize scalability, performance for specific query patterns, and flexibility to handle evolving
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.439.1">
      data structures.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.440.1">
     But when should we use
    </span>
    <a id="_idIndexMarker336">
    </a>
    <span class="koboSpan" id="kobo.441.1">
     one approach
    </span>
    <a id="_idIndexMarker337">
    </a>
    <span class="koboSpan" id="kobo.442.1">
     over
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.443.1">
      the other?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.444.1">
     Let’s analyze the
    </span>
    <a id="_idIndexMarker338">
    </a>
    <span class="koboSpan" id="kobo.445.1">
     following table to understand the differences between
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.446.1">
      persistence approaches:
     </span>
    </span>
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-2">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.447.1">
           Feature
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.448.1">
           RDBMS
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.449.1">
           NoSQL
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.450.1">
          Structure
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.451.1">
         Rigid,
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.452.1">
          predefined schemas
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.453.1">
         Flexible, adaptable, schemas can be schema-less or
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.454.1">
          defined on-the-fly
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.455.1">
          Scalability
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.456.1">
         Usually scales vertically (increase
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.457.1">
          hardware power)
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.458.1">
         Often designed for horizontal scaling (adding
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.459.1">
          more servers)
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.460.1">
          Consistency
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.461.1">
         Strong
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.462.1">
          ACID guarantees
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.463.1">
         Eventual consistency is common for
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.464.1">
          faster writes
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.465.1">
          Querying
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.466.1">
         Powerful, expressive
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.467.1">
          SQL queries
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.468.1">
         Varies by database type, potentially less powerful than SQL for
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.469.1">
          complex relationships
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break" lang="en-US" xml:lang="en-US">
         <span class="koboSpan" id="kobo.470.1">
          Use cases
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.471.1">
         Data with rigid schemas, complex relationships, strong
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.472.1">
          consistency needs
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.473.1">
         High-volume
        </span>
        <a id="_idIndexMarker339">
        </a>
        <span class="koboSpan" id="kobo.474.1">
         data, rapidly changing data models, high performance, specific query patterns,
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.475.1">
          distributed systems
         </span>
        </span>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.476.1">
     Table 5.1 – Comparison between data persistence models
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.477.1">
     As shown in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.478.1">
      Table 5.1
     </span>
    </em>
    <span class="koboSpan" id="kobo.479.1">
     , RDBMSs
    </span>
    <a id="_idIndexMarker340">
    </a>
    <span class="koboSpan" id="kobo.480.1">
     excel in predictable and structured data models, where data
    </span>
    <a id="_idIndexMarker341">
    </a>
    <span class="koboSpan" id="kobo.481.1">
     accuracy and relationships are key.
    </span>
    <span class="koboSpan" id="kobo.481.2">
     NoSQL stands out in scenarios where flexibility, massive scalability, and high performance for specific needs take priority.
    </span>
    <span class="koboSpan" id="kobo.481.3">
     Both are excellent proposals for different types of applications, with their varied applicability, such as an application persisting data in SQL Server and using Redis to manage the cache of some information, avoiding constant access to the database.
    </span>
    <span class="koboSpan" id="kobo.481.4">
     Both approaches are used for the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.482.1">
      same application.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.483.1">
     Fortunately, ASP.NET Core 9 allows us to work with different types of data models because it is extensible and dynamic.
    </span>
    <span class="koboSpan" id="kobo.483.2">
     Let’s delve a little deeper into two important concepts for manipulating data in relational databases, which are ORMs and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.484.1">
      Micro ORMs.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-87">
    <a id="_idTextAnchor088">
    </a>
    <span class="koboSpan" id="kobo.485.1">
     ORM and Micro ORM
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.486.1">
     ORM is a
    </span>
    <a id="_idIndexMarker342">
    </a>
    <span class="koboSpan" id="kobo.487.1">
     technique that acts as a bridge between the world of
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.488.1">
      object-oriented programming
     </span>
    </strong>
    <span class="koboSpan" id="kobo.489.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.490.1">
      OOP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.491.1">
     ) and
    </span>
    <a id="_idIndexMarker343">
    </a>
    <span class="koboSpan" id="kobo.492.1">
     the relational world of databases.
    </span>
    <span class="koboSpan" id="kobo.492.2">
     OOP models data as objects with properties and behaviors, while databases work with tables, rows,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.493.1">
      and columns.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.494.1">
     As we learned at the beginning of the chapter, we use objects such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.495.1">
      SqlConnection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.496.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.497.1">
      SqlCommand
     </span>
    </strong>
    <span class="koboSpan" id="kobo.498.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.499.1">
      SqlDatReader
     </span>
    </strong>
    <span class="koboSpan" id="kobo.500.1">
     to read data in SQL Server.
    </span>
    <span class="koboSpan" id="kobo.500.2">
     This is a simple approach, but as businesses become more complex, it can be a big problem to work with obtaining and mapping data to apply the required business rules in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.501.1">
      the application.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.502.1">
     In the example of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.503.1">
      Products
     </span>
    </strong>
    <span class="koboSpan" id="kobo.504.1">
     table, we implemented in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.505.1">
      Using the SQL Client
     </span>
    </em>
    <span class="koboSpan" id="kobo.506.1">
     section, a SQL query was used to obtain all existing records.
    </span>
    <span class="koboSpan" id="kobo.506.2">
     In real, large-scale applications, it is impractical for any interaction by users to be necessary to obtain all records from a table.
    </span>
    <span class="koboSpan" id="kobo.506.3">
     This could cause serious performance problems in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.507.1">
      the application.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.508.1">
     It is necessary to insert, delete, and update data, and even customize searches through filters, meaning that a SQL command is written for each situation.
    </span>
    <span class="koboSpan" id="kobo.508.2">
     Furthermore, for data to be processed efficiently, it is necessary to abstract what persistence is and what the business domain is.
    </span>
    <span class="koboSpan" id="kobo.508.3">
     In C#, we can work with the concept
    </span>
    <a id="_idIndexMarker344">
    </a>
    <span class="koboSpan" id="kobo.509.1">
     of
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.510.1">
      object orientation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.511.1">
     at a high level and, in this context, ORM emerges as a powerful technique that allows us to focus on the business, in addition to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.512.1">
      other flexibilities.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.513.1">
     The implementation of an ORM on the .NET platform is called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.514.1">
      Entity Framework
     </span>
    </strong>
    <span class="koboSpan" id="kobo.515.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.516.1">
      EF
     </span>
    </strong>
    <span class="koboSpan" id="kobo.517.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.517.2">
     EF
    </span>
    <a id="_idIndexMarker345">
    </a>
    <span class="koboSpan" id="kobo.518.1">
     provides all the high-level mechanisms for manipulating and translating data either from objects to databases or from databases to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.519.1">
      C# objects.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.520.1">
     With EF, we don’t need to worry about
    </span>
    <a id="_idIndexMarker346">
    </a>
    <span class="koboSpan" id="kobo.521.1">
     writing SQL queries for the various operations in a database.
    </span>
    <span class="koboSpan" id="kobo.521.2">
     EF also has other features, such as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.522.1">
      migrations
     </span>
    </strong>
    <span class="koboSpan" id="kobo.523.1">
     , which allow you to update the database according to the developed code model, providing a great solution for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.524.1">
      database versioning.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.525.1">
     To better understand how
    </span>
    <a id="_idIndexMarker347">
    </a>
    <span class="koboSpan" id="kobo.526.1">
     ORM works, look at
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.527.1">
       Figure 5
      </span>
     </em>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.528.1">
       .7
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.529.1">
      :
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer059">
     <span class="koboSpan" id="kobo.530.1">
      <img alt="Figure 5.7 – Simple data model of a banking system" src="image/B21788_05_7.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.531.1">
     Figure 5.7 – Simple data model of a banking system
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.532.1">
     We know that it is
    </span>
    <a id="_idIndexMarker348">
    </a>
    <span class="koboSpan" id="kobo.533.1">
     possible to obtain data in a C# application, as we learned previously.
    </span>
    <span class="koboSpan" id="kobo.533.2">
     To translate the data objects shown in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.534.1">
       Figure 5
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.535.1">
      .7
     </span>
    </em>
    <span class="koboSpan" id="kobo.536.1">
     , it would be necessary to create three C# classes:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.537.1">
      Customer.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.538.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.539.1">
      Account.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.540.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.541.1">
      Movement.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.542.1">
     .
    </span>
    <span class="koboSpan" id="kobo.542.2">
     However, for each of the classes, it would be necessary to write different SQL queries to perform any operations on the database.
    </span>
    <span class="koboSpan" id="kobo.542.3">
     Furthermore, for each business need, it would be necessary to map the data to C# classes and vice versa to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.543.1">
      persist data.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.544.1">
     This means that to obtain customer data, such as their accounts and transactions, it would be necessary to carry out at least three database queries, interact with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.545.1">
      SqlDataReader
     </span>
    </strong>
    <span class="koboSpan" id="kobo.546.1">
     objects, and create the respective C# objects.
    </span>
    <span class="koboSpan" id="kobo.546.2">
     Although it is not a very complex job, as the software becomes more complex, with various changes, this model
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.547.1">
      becomes problematic.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.548.1">
     Imagine changing the name of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.549.1">
      Description
     </span>
    </strong>
    <span class="koboSpan" id="kobo.550.1">
     column in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.551.1">
      Movement
     </span>
    </strong>
    <span class="koboSpan" id="kobo.552.1">
     table to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.553.1">
      Event
     </span>
    </strong>
    <span class="koboSpan" id="kobo.554.1">
     .
    </span>
    <span class="koboSpan" id="kobo.554.2">
     It would even be necessary to change all the SQL queries created in C#, in addition to the mappings.
    </span>
    <span class="koboSpan" id="kobo.554.3">
     When it comes to more complex data models, maintenance difficulties and possible problems
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.555.1">
      grow exponentially.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.556.1">
     When working
    </span>
    <a id="_idIndexMarker349">
    </a>
    <span class="koboSpan" id="kobo.557.1">
     with an ORM, this entire task is abstracted and less complicated.
    </span>
    <span class="koboSpan" id="kobo.557.2">
     Fortunately, EF provides a great solution for this scenario, requiring
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.558.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.559.1">
       Connection string
      </span>
     </strong>
     <span class="koboSpan" id="kobo.560.1">
      : Database
     </span>
     <a id="_idIndexMarker350">
     </a>
     <span class="koboSpan" id="kobo.561.1">
      address and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.562.1">
       access credentials
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.563.1">
       DbContext object
      </span>
     </strong>
     <span class="koboSpan" id="kobo.564.1">
      : Orchestrator
     </span>
     <a id="_idIndexMarker351">
     </a>
     <span class="koboSpan" id="kobo.565.1">
      of the connection to the database and management of objects
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.566.1">
       and mappings
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.567.1">
       DbSet
      </span>
     </strong>
     <span class="koboSpan" id="kobo.568.1">
      : Domain
     </span>
     <a id="_idIndexMarker352">
     </a>
     <span class="koboSpan" id="kobo.569.1">
      objects that will be mapped to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.570.1">
       database objects
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.571.1">
     EF Core manages all the communication with the database, mapping, and migrations, allowing developers to focus on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.572.1">
      the business.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.573.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.574.1">
      DbContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.575.1">
     class for the example in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.576.1">
       Figure 5
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.577.1">
      .7
     </span>
    </em>
    <span class="koboSpan" id="kobo.578.1">
     would look
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.579.1">
      like this:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.580.1">
public class BankingDbContext : DbContext
  {
    public BankingDbContext (DbContextOptions
      &lt; BankingDbContext &gt; options)
      : base(options)
    {
    }
    public DbSet&lt;Customer&gt; Customers { get; set; }
    public DbSet&lt;Account&gt; Accounts { get; set; }
    public DbSet&lt;Movement&gt; Movements { get; set; }
  }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.581.1">
     We will implement this class in more detail in the next section.
    </span>
    <span class="koboSpan" id="kobo.581.2">
     At this point, it is important to understand that all the tables that will be managed by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.582.1">
      DbContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.583.1">
     are properties of the class
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.584.1">
      BankingDbContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.585.1">
     with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.586.1">
      type
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.587.1">
       DbSet
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.588.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.589.1">
     The mapping
    </span>
    <a id="_idIndexMarker353">
    </a>
    <span class="koboSpan" id="kobo.590.1">
     of database objects is generally done by conventions, where EntityFramework Core compares the property names and types against the table column names and types in the database, but can be easily customized using specialized attributes
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.591.1">
      or classes.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.592.1">
     Conventions in EF Core
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.593.1">
     To learn more about
    </span>
    <a id="_idIndexMarker354">
    </a>
    <span class="koboSpan" id="kobo.594.1">
     conventions,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.595.1">
      visit
     </span>
    </span>
    <a href="https://learn.microsoft.com/en-us/ef/core/modeling/#built-in-conventions">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.596.1">
       https://learn.microsoft.com/en-us/ef/core/modeling/#built-in-conventions
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.597.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.598.1">
     With mapping database conventions, we can obtain all the customers in the database through the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.599.1">
      BankingDbContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.600.1">
     class,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.601.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.602.1">
public async Task&lt;ICollection&lt;Account&gt;&gt;
  GetAllAccountsAsync()
{
     return await _context.Accounts.ToListAsync();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.603.1">
     As you can see in the previous code, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.604.1">
      GetAllAccountsAsync
     </span>
    </strong>
    <span class="koboSpan" id="kobo.605.1">
     method searches for all the accounts in the database.
    </span>
    <span class="koboSpan" id="kobo.605.2">
     The EF Core
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.606.1">
      ToListAsync
     </span>
    </strong>
    <span class="koboSpan" id="kobo.607.1">
     method will query the database asynchronously, returning a list of
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.608.1">
       Account
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.609.1">
      objects.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.610.1">
     The preceding code shows a simple and powerful approach using ORM, without needing to manage the connection or write SQL commands, as they are generated by EF, in addition to there being no need to map database objects into classes.
    </span>
    <span class="koboSpan" id="kobo.610.2">
     All these functionalities are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.611.1">
      already abstracted.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.612.1">
     In this way, ORMs
    </span>
    <a id="_idIndexMarker355">
    </a>
    <span class="koboSpan" id="kobo.613.1">
     provide
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.614.1">
      several benefits:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.615.1">
       Reduced boilerplate code
      </span>
     </em>
     <span class="koboSpan" id="kobo.616.1">
      : ORMs automatically generate much of the repetitive SQL code (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.617.1">
       SELECT
      </span>
     </strong>
     <span class="koboSpan" id="kobo.618.1">
      ,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.619.1">
       INSERT
      </span>
     </strong>
     <span class="koboSpan" id="kobo.620.1">
      ,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.621.1">
       UPDATE
      </span>
     </strong>
     <span class="koboSpan" id="kobo.622.1">
      ), allowing developers to focus on application logic, not data
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.623.1">
       access code.
      </span>
     </span>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.624.1">
       Enhanced productivity
      </span>
     </em>
     <span class="koboSpan" id="kobo.625.1">
      : Working with objects is often more intuitive for developers who are used to OOP principles, speeding
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.626.1">
       up development.
      </span>
     </span>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.627.1">
       Increased maintainability
      </span>
     </em>
     <span class="koboSpan" id="kobo.628.1">
      : ORMs provide a certain level of abstraction between your application code and the specific database, making it easier to switch database
     </span>
     <a id="_idIndexMarker356">
     </a>
     <span class="koboSpan" id="kobo.629.1">
      providers or refactor your data model with less impact on
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.630.1">
       your codebase.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.631.1">
     However, ORM technologies have
    </span>
    <a id="_idIndexMarker357">
    </a>
    <span class="koboSpan" id="kobo.632.1">
     pros and cons
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.633.1">
      to consider:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.634.1">
       Performance overhead
      </span>
     </em>
     <span class="koboSpan" id="kobo.635.1">
      : In some cases, the SQL queries generated by an ORM might not be the most efficient.
     </span>
     <span class="koboSpan" id="kobo.635.2">
      Experienced developers can often write more performant SQL
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.636.1">
       by hand.
      </span>
     </span>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.637.1">
       Potential abstraction issues
      </span>
     </em>
     <span class="koboSpan" id="kobo.638.1">
      : ORMs
     </span>
     <a id="_idIndexMarker358">
     </a>
     <span class="koboSpan" id="kobo.639.1">
      can hide some of the underlying database concepts, which can be beneficial, but might make optimization or troubleshooting more challenging for those unfamiliar with
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.640.1">
       database fundamentals.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.641.1">
     EF Core
    </span>
    <a id="_idIndexMarker359">
    </a>
    <span class="koboSpan" id="kobo.642.1">
     is in version 8 and, over the years, it has been improved, with different features added.
    </span>
    <span class="koboSpan" id="kobo.642.2">
     However, we still recommend using the best technology offered to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.643.1">
      us wisely.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.644.1">
     Although ORM technologies are becoming increasingly modern, there is still a concern about performance, especially when you have a complex data model, with several levels of relationships between objects.
    </span>
    <span class="koboSpan" id="kobo.644.2">
     ORMs are often not capable of generating extremely performant queries, and, in some cases, it is necessary to use other resources, such as the Micro ORM approach learned at the beginning of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.645.1">
      the chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.646.1">
     In this context of facilitating work between the application and database objects, the concept of Micro
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.647.1">
      ORM emerged.
     </span>
    </span>
   </p>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.648.1">
      Micro ORMs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.649.1">
     are
    </span>
    <a id="_idIndexMarker360">
    </a>
    <span class="koboSpan" id="kobo.650.1">
     conceptually very similar to the ORM model.
    </span>
    <span class="koboSpan" id="kobo.650.2">
     However, micro ORMs abstracts the database mapping objects into C# classes but prioritize performance.
    </span>
    <span class="koboSpan" id="kobo.650.3">
     In some cases, they even provide some automatic generation
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.651.1">
      of queries.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.652.1">
     Some differences
    </span>
    <a id="_idIndexMarker361">
    </a>
    <span class="koboSpan" id="kobo.653.1">
     between
    </span>
    <a id="_idIndexMarker362">
    </a>
    <span class="koboSpan" id="kobo.654.1">
     Micro ORM and ORM are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.655.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.656.1">
       Footprint
      </span>
     </em>
     <span class="koboSpan" id="kobo.657.1">
      : Micro ORMs have a much smaller code base and fewer dependencies, resulting in significantly
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.658.1">
       less overhead.
      </span>
     </span>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.659.1">
       Complexity
      </span>
     </em>
     <span class="koboSpan" id="kobo.660.1">
      : Micro ORMs offer a basic set of features for mapping and executing queries, leaving behind many of the complexities found in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.661.1">
       traditional ORMs.
      </span>
     </span>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.662.1">
       Control
      </span>
     </em>
     <span class="koboSpan" id="kobo.663.1">
      : With less abstraction, developers have more direct control over the SQL queries
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.664.1">
       being executed.
      </span>
     </span>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.665.1">
       Features
      </span>
     </em>
     <span class="koboSpan" id="kobo.666.1">
      : Micro ORMs typically lack these features often found in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.667.1">
       larger ORMs:
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.668.1">
        Extensive object
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.669.1">
         relationship management
        </span>
       </span>
      </li>
      <li>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.670.1">
         Change tracking
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.671.1">
        Automatic
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.672.1">
         schema migrations
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.673.1">
        Identity maps (entity tracking to prevent
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.674.1">
         duplicate payloads)
        </span>
       </span>
      </li>
     </ul>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.675.1">
     There are some Micro ORM technologies commonly used by the .NET community, the most famous of which is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.676.1">
      called Dapper.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.677.1">
     Dapper is open source
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.678.1">
     The Dapper library
    </span>
    <a id="_idIndexMarker363">
    </a>
    <span class="koboSpan" id="kobo.679.1">
     is open source and is constantly being updated.
    </span>
    <span class="koboSpan" id="kobo.679.2">
     There is a comparison between different ORM engines, including EF Core, on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.680.1">
      GitHub:
     </span>
    </span>
    <a href="https://github.com/DapperLib/Dapper">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.681.1">
       https://github.com/DapperLib/Dapper
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.682.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.683.1">
     Using a Micro ORM does not preclude using an ORM.
    </span>
    <span class="koboSpan" id="kobo.683.2">
     They can coexist in an application, depending on the need and context.
    </span>
    <span class="koboSpan" id="kobo.683.3">
     It is important to keep in mind that this approach allows us to bring greater quality to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.684.1">
      our applications.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.685.1">
     In the next section, we will cover, in a practical way, the use of EF Core and Dapper based on the previously mentioned
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.686.1">
      bank
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.687.1">
       account
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.688.1">
      concept.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.689.1">
     Now that we understand what an ORM and a Micro ORM are, the time has come to implement solutions using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.690.1">
      these approaches.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-88">
    <a id="_idTextAnchor089">
    </a>
    <span class="koboSpan" id="kobo.691.1">
     Working with EF Core and Dapper
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.692.1">
     ORM and Micro ORM are widely techniques used in modern applications due to their various benefits.
    </span>
    <span class="koboSpan" id="kobo.692.2">
     As we have learned, ASP.NET Core 9 has several options for working with data models from different technologies.
    </span>
    <span class="koboSpan" id="kobo.692.3">
     We will learn how to use EF Core as an ORM, and we will also use Dapper as a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.693.1">
      Micro ORM.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-89">
    <a id="_idTextAnchor090">
    </a>
    <span class="koboSpan" id="kobo.694.1">
     EF Core
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.695.1">
     Based on the example of the
    </span>
    <a id="_idIndexMarker364">
    </a>
    <span class="koboSpan" id="kobo.696.1">
     bank account data model, we have tables
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.697.1">
      Customer
     </span>
    </em>
    <span class="koboSpan" id="kobo.698.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.699.1">
      Account
     </span>
    </em>
    <span class="koboSpan" id="kobo.700.1">
     , and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.701.1">
      Movement
     </span>
    </em>
    <span class="koboSpan" id="kobo.702.1">
     , we will create a project to connect to the SQL database we configured at the beginning of the chapter, which is running in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.703.1">
      Docker container.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.704.1">
     The complete solution code will therefore be available in the GitHub repository mentioned in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.705.1">
      Technical
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.706.1">
       requirements
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.707.1">
      section.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.708.1">
     For this project, we will use a Minimal API project and, to do this, open the terminal in administrator mode and execute the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.709.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.710.1">
dotnet new webapi -n WorkingWithOrm
cd WorkingWithOrm</span></pre>
   <p>
    <span class="koboSpan" id="kobo.711.1">
     Now, we need to add the EF Core libraries that will be necessary for the application to connect to the SQL server database.
    </span>
    <span class="koboSpan" id="kobo.711.2">
     Additionally, we will need to install an EF CLI tool.
    </span>
    <span class="koboSpan" id="kobo.711.3">
     This tool will be used to apply some updates to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.712.1">
      the database.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.713.1">
     Run the following commands in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.714.1">
      the terminal:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.715.1">
dotnet tool install –global dotnet-ef
dotnet add package Microsoft.EntityFrameworkCore
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Microsoft.EntityFrameworkCore.Design</span></pre>
   <p>
    <span class="koboSpan" id="kobo.716.1">
     The first command installs the EF CLI tool, and the following commands are the EF libraries that will be used to connect the application to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.717.1">
      the database.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.718.1">
     EF Core database providers
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.719.1">
     EF Core has the
    </span>
    <a id="_idIndexMarker365">
    </a>
    <span class="koboSpan" id="kobo.720.1">
     ability to work with different databases; it is not restricted to SQL Server.
    </span>
    <span class="koboSpan" id="kobo.720.2">
     More details about the available providers can be found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.721.1">
      at
     </span>
    </span>
    <a href="https://learn.microsoft.com/en-us/ef/core/providers/?tabs=dotnet-core-cli">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.722.1">
       https://learn.microsoft.com/en-us/ef/core/providers/?tabs=dotnet-core-cli
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.723.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.724.1">
     The project is now
    </span>
    <a id="_idIndexMarker366">
    </a>
    <span class="koboSpan" id="kobo.725.1">
     ready to be configured, and we will perform the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.726.1">
      following steps:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.727.1">
      Configure the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.728.1">
       connection string.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.729.1">
      Create
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.730.1">
       model classes.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.731.1">
      Create a class that inherits
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.732.1">
       from
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.733.1">
        DbContext
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.734.1">
       .
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.735.1">
      Configure the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.736.1">
       DbContext
      </span>
     </strong>
     <span class="koboSpan" id="kobo.737.1">
      created in the ASP.NET Core 9
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.738.1">
       DI container.
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.739.1">
       Add migrations.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.740.1">
      Update
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.741.1">
       the database.
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.742.1">
     As you perform these steps, you will notice some differences from implementing communication with the database in the traditional approach using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.743.1">
      SqlConnection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.744.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.745.1">
      SqlCommand
     </span>
    </strong>
    <span class="koboSpan" id="kobo.746.1">
     ,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.747.1">
      and
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.748.1">
       SqlDataReader
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.749.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.750.1">
     Open the project in Visual Studio Code with the following command in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.751.1">
      the terminal:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.752.1">
code .</span></pre>
   <p>
    <span class="koboSpan" id="kobo.753.1">
     The complete project has the structure shown in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.754.1">
       Figure 5
      </span>
     </em>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.755.1">
       .8
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.756.1">
      :
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer060">
     <span class="koboSpan" id="kobo.757.1">
      <img alt="Figure 5.8 – Banking project project structure" src="image/B21788_05_8.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.758.1">
     Figure 5.8 – Banking project project structure
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.759.1">
     To configure the
    </span>
    <a id="_idIndexMarker367">
    </a>
    <span class="koboSpan" id="kobo.760.1">
     connection string, we will use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.761.1">
      appsettings.json
     </span>
    </strong>
    <span class="koboSpan" id="kobo.762.1">
     .
    </span>
    <span class="koboSpan" id="kobo.762.2">
     It is important to mention that information containing user credentials should not be available directly in a code repository.
    </span>
    <span class="koboSpan" id="kobo.762.3">
     The best practice is to use secrets or even a configuration server such
    </span>
    <a id="_idIndexMarker368">
    </a>
    <span class="koboSpan" id="kobo.763.1">
     as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.764.1">
      Azure App Configurator
     </span>
    </strong>
    <span class="koboSpan" id="kobo.765.1">
     to manage this information.
    </span>
    <span class="koboSpan" id="kobo.765.2">
     We’ll talk more about good security practices in
    </span>
    <a href="B21788_06.xhtml#_idTextAnchor093">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.766.1">
        Chapter 6
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.767.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.768.1">
     For teaching purposes, we will add the connection string to the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.769.1">
       appsettings.json
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.770.1">
      file:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.771.1">
{
   "Logging": {
     "LogLevel": {
       "Default": "Information",
       "Microsoft.AspNetCore": "Warning"
     }
   },
   "AllowedHosts": "*",
   </span><strong class="bold"><span class="koboSpan" id="kobo.772.1">"ConnectionStrings": {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.773.1">    "BankingDbContext": "Server=localhost;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.774.1">      Database=dbBanking;User Id=sa;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.775.1">      Password=Password123;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.776.1">      TrustServerCertificate=True"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.777.1">   }</span></strong><span class="koboSpan" id="kobo.778.1">
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.779.1">
     We are using the
    </span>
    <a id="_idIndexMarker369">
    </a>
    <span class="koboSpan" id="kobo.780.1">
     same connection string as the database server running through Docker, with an additional default,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.781.1">
      Database=dbBanking
     </span>
    </strong>
    <span class="koboSpan" id="kobo.782.1">
     , which will be used for this application.
    </span>
    <span class="koboSpan" id="kobo.782.2">
     The JSON
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.783.1">
      ConnectionStrings
     </span>
    </strong>
    <span class="koboSpan" id="kobo.784.1">
     object is an ASP.NET Core 9 convention, with each property of this object representing a different
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.785.1">
      connection string.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.786.1">
     EF Core does all the work of managing the connection and mapping database entities into C# objects, as well as generating SQL commands.
    </span>
    <span class="koboSpan" id="kobo.786.2">
     For this to be possible, there is a base object that we must use to map the domain classes.
    </span>
    <span class="koboSpan" id="kobo.786.3">
     This base object is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.787.1">
      called
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.788.1">
       DbContext
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.789.1">
      .
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.790.1">
      DBContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.791.1">
     implements
    </span>
    <a id="_idIndexMarker370">
    </a>
    <span class="koboSpan" id="kobo.792.1">
     the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.793.1">
      Unit of Work
     </span>
    </strong>
    <span class="koboSpan" id="kobo.794.1">
     design pattern, managing all states of the objects manipulated in memory and persisting changes
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.795.1">
      when necessary.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.796.1">
     Unit of Work pattern
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.797.1">
     The Unit of Work design pattern
    </span>
    <a id="_idIndexMarker371">
    </a>
    <span class="koboSpan" id="kobo.798.1">
     is used in different contexts, favoring the separation of responsibilities, such as separating all the business rules of an application from the responsibility of communicating with and manipulating data in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.799.1">
      a database.
     </span>
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.800.1">
     Learn more about the
    </span>
    <a id="_idIndexMarker372">
    </a>
    <span class="koboSpan" id="kobo.801.1">
     Unit of Work pattern
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.802.1">
      at
     </span>
    </span>
    <a href="https://learn.microsoft.com/en-us/archive/msdn-magazine/2009/june/the-unit-of-work-pattern-and-persistence-ignorance">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.803.1">
       https://learn.microsoft.com/en-us/archive/msdn-magazine/2009/june/the-unit-of-work-pattern-and-persistence-ignorance
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.804.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.805.1">
     According to the
    </span>
    <a id="_idIndexMarker373">
    </a>
    <span class="koboSpan" id="kobo.806.1">
     project structure shown in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.807.1">
       Figure 5
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.808.1">
      .8
     </span>
    </em>
    <span class="koboSpan" id="kobo.809.1">
     , we will create a class called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.810.1">
      BankingDbContext.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.811.1">
     that will have the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.812.1">
      following code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.813.1">
namespace WorkingWithOrm.Context;
using Microsoft.EntityFrameworkCore;
using WorkingWithOrm.Model;
public class BankingDbContext : </span><strong class="bold"><span class="koboSpan" id="kobo.814.1">DbContext</span></strong><span class="koboSpan" id="kobo.815.1">
{
    public BankingDbContext(</span><strong class="bold"><span class="koboSpan" id="kobo.816.1">DbContextOptions</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.817.1">      &lt;BankingDbContext&gt; options</span></strong><span class="koboSpan" id="kobo.818.1">) : base(options)
    {
    }
</span><strong class="bold"><span class="koboSpan" id="kobo.819.1">    public DbSet&lt;Account&gt; Accounts { get; set; }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.820.1">    public DbSet&lt;Customer&gt; Customers { get; set; }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.821.1">    public DbSet&lt;Movement&gt; Movements { get; set; }</span></strong><span class="koboSpan" id="kobo.822.1">
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.823.1">
     For the
    </span>
    <a id="_idIndexMarker374">
    </a>
    <span class="koboSpan" id="kobo.824.1">
     application we are creating, the class is quite simple.
    </span>
    <span class="koboSpan" id="kobo.824.2">
     Let’s explore the most important points of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.825.1">
      this code:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.826.1">
       DbContext
      </span>
     </strong>
     <span class="koboSpan" id="kobo.827.1">
      : The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.828.1">
       BankingDbContext
      </span>
     </strong>
     <span class="koboSpan" id="kobo.829.1">
      class inherits from the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.830.1">
       DbContext
      </span>
     </strong>
     <span class="koboSpan" id="kobo.831.1">
      superclass, which has the necessary abstractions for communication between the application and the database, state management, mapping, and the generation of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.832.1">
       SQL commands.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.833.1">
       BankingDbContext
      </span>
     </strong>
     <span class="koboSpan" id="kobo.834.1">
      constructor: The class constructor receives, as a parameter, the generic
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.835.1">
       DbContextOptions&lt;BankingDbContext&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.836.1">
      class, which allows us to pre-define configurations that will be used in the DI container to create an instance of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.837.1">
       DbContext
      </span>
     </strong>
     <span class="koboSpan" id="kobo.838.1">
      object.
     </span>
     <span class="koboSpan" id="kobo.838.2">
      The constructor can also receive a connection string; however, it is good practice to use the C#
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.839.1">
       options pattern.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.840.1">
       DbSet
      </span>
     </strong>
     <span class="koboSpan" id="kobo.841.1">
      : Each property of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.842.1">
       DbSet
      </span>
     </strong>
     <span class="koboSpan" id="kobo.843.1">
      type represents a table in the database, and it is these properties that provide information to EF Core to transform data from tables into objects and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.844.1">
       vice versa.
      </span>
     </span>
    </li>
   </ul>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.845.1">
     C# options pattern
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.846.1">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.847.1">
      options pattern
     </span>
    </strong>
    <span class="koboSpan" id="kobo.848.1">
     is
    </span>
    <a id="_idIndexMarker375">
    </a>
    <span class="koboSpan" id="kobo.849.1">
     widely used in the .NET platform with the aim of providing strongly typed access to groups of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.850.1">
      related settings.
     </span>
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.851.1">
     Learn more about the
    </span>
    <a id="_idIndexMarker376">
    </a>
    <span class="koboSpan" id="kobo.852.1">
     options pattern
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.853.1">
      at
     </span>
    </span>
    <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-9.0#the-options-pattern">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.854.1">
       https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-9.0#the-options-pattern
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.855.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.856.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.857.1">
      BankingDbContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.858.1">
     class is now complete and provides everything needed to interact with the SQL database.
    </span>
    <span class="koboSpan" id="kobo.858.2">
     The mapping model used, in this case, is based on the EF Core convention, which infers the name of the table and columns from the name of the class and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.859.1">
      its properties.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.860.1">
     Let’s look at the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.861.1">
       Account.cs
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.862.1">
      class:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.863.1">
public class Account
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Balance { get; set; }
    public int </span><strong class="bold"><span class="koboSpan" id="kobo.864.1">CustomerId</span></strong><span class="koboSpan" id="kobo.865.1"> { get; set; }
    public virtual </span><strong class="bold"><span class="koboSpan" id="kobo.866.1">Customer</span></strong><span class="koboSpan" id="kobo.867.1">? </span><span class="koboSpan" id="kobo.867.2">Customer { get; set; }
    public virtual </span><strong class="bold"><span class="koboSpan" id="kobo.868.1">ICollection&lt;Movement&gt;</span></strong><span class="koboSpan" id="kobo.869.1">? </span><span class="koboSpan" id="kobo.869.2">Movements
      { get; set; }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.870.1">
     Based on this class and the
    </span>
    <a id="_idIndexMarker377">
    </a>
    <span class="koboSpan" id="kobo.871.1">
     EF Core convention, it is expected that there will be a table named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.872.1">
      Account
     </span>
    </strong>
    <span class="koboSpan" id="kobo.873.1">
     and columns called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.874.1">
      Id
     </span>
    </strong>
    <span class="koboSpan" id="kobo.875.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.876.1">
      Name
     </span>
    </strong>
    <span class="koboSpan" id="kobo.877.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.878.1">
      Balance
     </span>
    </strong>
    <span class="koboSpan" id="kobo.879.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.880.1">
      CustomerId
     </span>
    </strong>
    <span class="koboSpan" id="kobo.881.1">
     in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.882.1">
      the database.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.883.1">
     But there is, in addition, a property called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.884.1">
      Customer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.885.1">
     and a collection of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.886.1">
      Movement
     </span>
    </strong>
    <span class="koboSpan" id="kobo.887.1">
     objects.
    </span>
    <span class="koboSpan" id="kobo.887.2">
     Due to the existence of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.888.1">
      CustomerId
     </span>
    </strong>
    <span class="koboSpan" id="kobo.889.1">
     property, EF infers that there is a relationship with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.890.1">
      Customer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.891.1">
     table, which has a foreign key (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.892.1">
      &lt;TableName&gt;+Id
     </span>
    </strong>
    <span class="koboSpan" id="kobo.893.1">
     ) in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.894.1">
      Account
     </span>
    </strong>
    <span class="koboSpan" id="kobo.895.1">
     table.
    </span>
    <span class="koboSpan" id="kobo.895.2">
     Likewise, because there is a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.896.1">
      Movement
     </span>
    </strong>
    <span class="koboSpan" id="kobo.897.1">
     collection, EF infers that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.898.1">
      Account
     </span>
    </strong>
    <span class="koboSpan" id="kobo.899.1">
     class may have one or more
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.900.1">
      Movements
     </span>
    </strong>
    <span class="koboSpan" id="kobo.901.1">
     in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.902.1">
       Movement
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.903.1">
      table.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.904.1">
     However, if it is necessary to follow different naming standards from database to database, the names of tables, columns, primary keys, and so on can be mapped directly into the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.905.1">
      DbContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.906.1">
     class using the fluent API.
    </span>
    <span class="koboSpan" id="kobo.906.2">
     This can be done using data annotation in the domain classes, or even by implementing a specific mapping class for each entity using the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.907.1">
       IEntityTypeConfiguration&lt;TEntity&gt;
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.908.1">
      interface.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.909.1">
     The following code example represents a custom or manual mapping of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.910.1">
      Customer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.911.1">
     class to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.912.1">
      tbl_customer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.913.1">
     table.
    </span>
    <span class="koboSpan" id="kobo.913.2">
     In order to customize the mapping of classes in database entities, it is necessary to override the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.914.1">
      OnModelCreating
     </span>
    </strong>
    <span class="koboSpan" id="kobo.915.1">
     method, inherited from the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.916.1">
       DbContext
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.917.1">
      class:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.918.1">
override protected void OnModelCreating(
  ModelBuilder modelBuilder)
  {
    modelBuilder.Entity&lt;Customer&gt;(obj =&gt; {
      obj.ToTable("tbl_customer");
      obj.HasKey(c =&gt; c.Id).HasName
        ("pk_customer_id");
      obj.Property(c =&gt; c.Name).HasColumnName
        ("customer_name").HasMaxLength(100).IsRequired();
      obj.HasMany(c =&gt; c.Accounts)
        .WithOne(a =&gt; a.Customer)
        .HasForeignKey(a =&gt; a.CustomerId);
    });
  }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.919.1">
     As you can see in the code, it is possible to define all the attributes required for the correct mapping
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.920.1">
      of entities.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.921.1">
     With the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.922.1">
      BankingDbContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.923.1">
     class finalized, we must configure it in the DI container and configure the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.924.1">
      connection string.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.925.1">
     We will add the following line
    </span>
    <a id="_idIndexMarker378">
    </a>
    <span class="koboSpan" id="kobo.926.1">
     to the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.927.1">
       Program.cs
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.928.1">
      file:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.929.1">
// Code omitted for readability
</span><strong class="bold"><span class="koboSpan" id="kobo.930.1">builder.Services.AddDbContext&lt;BankingDbContext&gt;(options =&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.931.1">  options.UseSqlServer(builder.Configuration</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.932.1">    .GetConnectionString("BankingDbContext")));</span></strong><span class="koboSpan" id="kobo.933.1">
var app = builder.Build();
// Code omitted for readability</span></pre>
   <p>
    <span class="koboSpan" id="kobo.934.1">
     We use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.935.1">
      AddDbContext&lt;BankingDbContext&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.936.1">
     extension method to configure the connection string that will be used for the connection.
    </span>
    <span class="koboSpan" id="kobo.936.2">
     Note that we are using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.937.1">
      options
     </span>
    </strong>
    <span class="koboSpan" id="kobo.938.1">
     property, which is expected in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.939.1">
      DbContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.940.1">
     constructor, and through the use of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.941.1">
      UseSqlServer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.942.1">
     extension method, we are recovering the connection string that we configured in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.943.1">
       appsettings.json
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.944.1">
      file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.945.1">
     The application is practically ready to communicate with the database; however, it will still be necessary to add migrations and update
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.946.1">
      the database.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.947.1">
     Open the terminal in the project directory and run the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.948.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.949.1">
dotnet ef migrations add InitialDatabase</span></pre>
   <p>
    <span class="koboSpan" id="kobo.950.1">
     This command uses the EF CLI tool that we installed previously, adding migrations with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.951.1">
      name
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.952.1">
       InitialDatabase
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.953.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.954.1">
     The objective of
    </span>
    <a id="_idIndexMarker379">
    </a>
    <span class="koboSpan" id="kobo.955.1">
     migrations is to allow the application and the database to remain synchronized in the objects that are used.
    </span>
    <span class="koboSpan" id="kobo.955.2">
     In real applications, changes to the database, such as creating new tables or adding or removing columns, can happen constantly.
    </span>
    <span class="koboSpan" id="kobo.955.3">
     These changes impact both the database in question and the application that consumes the objects in this database.
    </span>
    <span class="koboSpan" id="kobo.955.4">
     When adding a migration, such as in the preceding command, we are taking a picture of the domain model that the application uses, and EF Core generates the scripts that will be applied to the database to keep it up
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.956.1">
      to date.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.957.1">
     Migrations create a set of classes in the project.
    </span>
    <span class="koboSpan" id="kobo.957.2">
     These classes must not be changed manually.
    </span>
    <span class="koboSpan" id="kobo.957.3">
     As we can see in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.958.1">
       Figure 5
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.959.1">
      .9
     </span>
    </em>
    <span class="koboSpan" id="kobo.960.1">
     , three files were added to the application’s
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.961.1">
       Migrations
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.962.1">
      folder:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer061">
     <span class="koboSpan" id="kobo.963.1">
      <img alt="Figure 5.9 – Initial database migration files" src="image/B21788_05_9.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.964.1">
     Figure 5.9 – Initial database migration files
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.965.1">
     When observing a snippet of code extracted from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.966.1">
      InitialDatabase.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.967.1">
     suffix file, we observe that they are resource creation scripts in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.968.1">
      the database:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.969.1">
…
protected override void Up(MigrationBuilder
  migrationBuilder)
  {
    migrationBuilder.CreateTable(
      name: "Customers",
      columns: table =&gt; new
      {
          Id = table.Column&lt;int&gt;(type: "int",
            nullable: false)
            .Annotation("SqlServer:Identity", "1, 1"),
          Name = table.Column&lt;string&gt;(
            type: "nvarchar(max)", nullable: false)
        },
        constraints: table =&gt;
        {
          table.PrimaryKey("PK_Customers", x =&gt; x.Id);
        });
…</span></pre>
   <p>
    <span class="koboSpan" id="kobo.970.1">
     With each change in your application’s domain model, a new migration must be added.
    </span>
    <span class="koboSpan" id="kobo.970.2">
     This way, you will maintain a history of changes, and this will facilitate the maintenance and evolution of the database and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.971.1">
      the application.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.972.1">
     Now, you will need to update the
    </span>
    <a id="_idIndexMarker380">
    </a>
    <span class="koboSpan" id="kobo.973.1">
     database.
    </span>
    <span class="koboSpan" id="kobo.973.2">
     So far, we have not run any SQL scripts on SQL Server, much less created the database.
    </span>
    <span class="koboSpan" id="kobo.973.3">
     Instead of opening Azure Data Studio to perform this task, we will use the EF Core CLI tool to update the database according to the version mapped in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.974.1">
      the application.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.975.1">
     To do this, run the following command in the terminal, in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.976.1">
      project directory:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.977.1">
dotnet ef database update</span></pre>
   <p>
    <span class="koboSpan" id="kobo.978.1">
     The CLI tool will
    </span>
    <a id="_idIndexMarker381">
    </a>
    <span class="koboSpan" id="kobo.979.1">
     connect to SQL Server and execute scripts to create the database and tables mapped in the application.
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.980.1">
       Figure 5
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.981.1">
      .10
     </span>
    </em>
    <span class="koboSpan" id="kobo.982.1">
     displays the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.983.1">
      created objects:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer062">
     <span class="koboSpan" id="kobo.984.1">
      <img alt="Figure 5.10 – Objects created in the database using the EF CLI tool" src="image/B21788_05_10.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.985.1">
     Figure 5.10 – Objects created in the database using the EF CLI tool
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.986.1">
     All communication with the database has been properly configured.
    </span>
    <span class="koboSpan" id="kobo.986.2">
     The time has come to add the APIs to interact with the database.
    </span>
    <span class="koboSpan" id="kobo.986.3">
     Therefore, create the following routes in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.987.1">
       Program.cs
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.988.1">
      file:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.989.1">
app.MapGet("/customers", async (CancellationToken
  cancellationToken, </span><strong class="bold"><span class="koboSpan" id="kobo.990.1">BankingDbContext dbContext</span></strong><span class="koboSpan" id="kobo.991.1">) =&gt;
  {
    var customers = await </span><strong class="bold"><span class="koboSpan" id="kobo.992.1">dbContext.Customers</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.993.1">      .ToListAsync(</span></strong><span class="koboSpan" id="kobo.994.1">cancellationToken</span><strong class="bold"><span class="koboSpan" id="kobo.995.1">);</span></strong><span class="koboSpan" id="kobo.996.1">
    return Results.Ok(customers);
        });
    app.MapGet("/customers/{id}", async (int id,
      BankingDbContext dbContext,
      CancellationToken cancellationToken) =&gt;
      {
        var customer = await dbContext.Customers
          .FindAsync(id, cancellationToken);
        return Results.Ok(customer);
      });
      app.MapPost("/customers", async (
        [FromBody]Customer customer,
        BankingDbContext dbContext,
        CancellationToken cancellationToken) =&gt;
        {
          </span><strong class="bold"><span class="koboSpan" id="kobo.997.1">await dbContext.Customers.AddAsync(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.998.1">            customer, </span></strong><span class="koboSpan" id="kobo.999.1">cancellationToken</span><strong class="bold"><span class="koboSpan" id="kobo.1000.1">);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1001.1">          await dbContext</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1002.1">            .SaveChangesAsync(</span></strong><span class="koboSpan" id="kobo.1003.1">cancellationToken</span><strong class="bold"><span class="koboSpan" id="kobo.1004.1">);</span></strong><span class="koboSpan" id="kobo.1005.1">
          return Results.Created();
        });</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1006.1">
     The above routes perform operations on the Customer table.
    </span>
    <span class="koboSpan" id="kobo.1006.2">
     Notice the first Get method.
    </span>
    <span class="koboSpan" id="kobo.1006.3">
     This method receives as a parameter an instance of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1007.1">
      BankingDbContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1008.1">
     object that is automatically resolved through the .NET Core dependency injection
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1009.1">
      DI context.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1010.1">
     Then, using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1011.1">
      dbContext.Customers.ToListAsync(cancellationToken)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1012.1">
     code, all existing customers in the database are retrieved.
    </span>
    <span class="koboSpan" id="kobo.1012.2">
     We only use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1013.1">
      Customers
     </span>
    </strong>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1014.1">
      DbContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1015.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1016.1">
      DbSet
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1017.1">
     , and EF Core takes care of creating the SQL query to select the records.
    </span>
    <span class="koboSpan" id="kobo.1017.2">
     There is no need to open connections, create commands, or even map manually.
    </span>
    <span class="koboSpan" id="kobo.1017.3">
     Everything is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1018.1">
      done transparently.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1019.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1020.1">
      Post
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1021.1">
     method
    </span>
    <a id="_idIndexMarker382">
    </a>
    <span class="koboSpan" id="kobo.1022.1">
     performs the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1023.1">
      following operations:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1024.1">
       dbContext.Customers.AddAsync
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1025.1">
      : The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1026.1">
       Customer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1027.1">
      object is passed as a parameter in the request body.
     </span>
     <span class="koboSpan" id="kobo.1027.2">
      This is then added to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1028.1">
       DbSet
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1029.1">
      in the same way as we would add an item to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1030.1">
       a list.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1031.1">
       dbContext.SaveChangesAsync
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1032.1">
      : When executing this method,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1033.1">
       dbContext
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1034.1">
      updates the database.
     </span>
     <span class="koboSpan" id="kobo.1034.2">
      This means that if there were other operations on the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1035.1">
       DbSets
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1036.1">
      , such as removal, updates, or additions, this information would only be updated in the
     </span>
     <a id="_idIndexMarker383">
     </a>
     <span class="koboSpan" id="kobo.1037.1">
      database after executing the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1038.1">
       SaveChanges
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1039.1">
      or
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1040.1">
        SaveChangesAsync
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1041.1">
       methods.
      </span>
     </span>
    </li>
   </ul>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.1042.1">
     Asynchronous processing and cancellation token
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.1043.1">
     Asynchronous processing is a
    </span>
    <a id="_idIndexMarker384">
    </a>
    <span class="koboSpan" id="kobo.1044.1">
     fundamental aspect of modern web application development.
    </span>
    <span class="koboSpan" id="kobo.1044.2">
     In ASP.NET Core 9, asynchronous methods allow the server to handle more requests simultaneously by not blocking threads during operations such as database queries, file access, or consuming HTTP resources.
    </span>
    <span class="koboSpan" id="kobo.1044.3">
     This approach allows the application to scale and respond quickly under load.
    </span>
    <span class="koboSpan" id="kobo.1044.4">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1045.1">
      async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1046.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1047.1">
      await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1048.1">
     keywords make it possible to write asynchronous code that is easy to maintain and read, and the .NET platform abstracts the complexity of managing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1049.1">
      asynchronous mechanisms.
     </span>
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.1050.1">
     In conjunction with asynchronous methods, it is a good practice to use cancellation tokens, which allow applications to properly handle the cancellation of requests, making applications more responsive and resilient.
    </span>
    <span class="koboSpan" id="kobo.1050.2">
     The
    </span>
    <a id="_idIndexMarker385">
    </a>
    <span class="koboSpan" id="kobo.1051.1">
     cancellation token associated with an asynchronous method propagates a cancellation signal throughout all of the application’s asynchronous operations, allowing them to terminate early and free up resources.
    </span>
    <span class="koboSpan" id="kobo.1051.2">
     ASP.NET Core 9 and C# simplify asynchronous programming and the use of cancellation tokens, providing a robust framework that ensures applications remain responsive even under
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1052.1">
      varying loads.
     </span>
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.1053.1">
     For more information about
    </span>
    <a id="_idIndexMarker386">
    </a>
    <span class="koboSpan" id="kobo.1054.1">
     asynchronous programming
    </span>
    <a id="_idIndexMarker387">
    </a>
    <span class="koboSpan" id="kobo.1055.1">
     and token cancellation, visit
    </span>
    <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/">
     <span class="koboSpan" id="kobo.1056.1">
      https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1057.1">
      and
     </span>
    </span>
    <a href="https://learn.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1058.1">
       https://learn.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1059.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1060.1">
     With this, we can run the application to interact with the database in a simple way, making it possible to perform any operations using
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.1061.1">
      Language Integrated Query
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1062.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.1063.1">
      LINQ
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1064.1">
     ), such as advanced
    </span>
    <a id="_idIndexMarker388">
    </a>
    <span class="koboSpan" id="kobo.1065.1">
     filters or obtaining records ordered by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1066.1">
      specific columns.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1067.1">
     The use of an ORM provides several benefits for high-level applications and, likewise, several challenges when we delegate the management of data management complexity to the ORM.
    </span>
    <span class="koboSpan" id="kobo.1067.2">
     This makes them slow, since, despite several innovations and improvements, in many cases, they are not the best choice when it comes
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1068.1">
      to performance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1069.1">
     In this case, Micro ORMs are great options; they have similar performance to traditional approaches and mapping capabilities like ORMs.
    </span>
    <span class="koboSpan" id="kobo.1069.2">
     Therefore, let’s explore how Dapper can be used to add more features to the database
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1070.1">
      communication model.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-90">
    <a id="_idTextAnchor091">
    </a>
    <span class="koboSpan" id="kobo.1071.1">
     Dapper
    </span>
   </h2>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.1072.1">
      Dapper
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1073.1">
     is a
    </span>
    <a id="_idIndexMarker389">
    </a>
    <span class="koboSpan" id="kobo.1074.1">
     Micro ORM that gives us the ability to interact with the database in a performative way while mapping database entities into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1075.1">
      C# objects.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1076.1">
     It is a simple-to-use yet powerful library.
    </span>
    <span class="koboSpan" id="kobo.1076.2">
     Its mapping model is interesting and flexible, allowing you to create different types of query result projections quickly
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1077.1">
      and effectively.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1078.1">
     Dapper and EF Core are not mutually exclusive technologies, and using both approaches in a project can provide
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1079.1">
      great benefits.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1080.1">
     Let’s add the Dapper library to the project created previously by executing the following command in the terminal, in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1081.1">
      application directory:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.1082.1">
dotnet add package Dapper</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1083.1">
     All the prerequisites required to work with Dapper have already been implemented in the project, the main one being the connection string that we configured in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1084.1">
       appsettings.json
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1085.1">
      file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1086.1">
     Let’s change the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1087.1">
      Program.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1088.1">
     file to add two new routes that use Dapper to perform a query where we can
    </span>
    <a id="_idIndexMarker390">
    </a>
    <span class="koboSpan" id="kobo.1089.1">
     obtain all the customers in the database and query a customer
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1090.1">
      by
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1091.1">
       Id
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1092.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1093.1">builder.Services.AddScoped(_ =&gt; new SqlConnection(builder</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1094.1">  .Configuration.GetConnectionString("BankingDbContext")));</span></strong><span class="koboSpan" id="kobo.1095.1">
var app = builder.Build();
// Codes omitted for readability
app.MapGet("GetAllCustomersUsingDapper", async(SqlConnection connection) =&gt;
{
  </span><strong class="bold"><span class="koboSpan" id="kobo.1096.1">var customers = await connection.QueryAsync&lt;Customer&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1097.1">    ("SELECT Id, Name FROM Customers ORDER BY Name");</span></strong><span class="koboSpan" id="kobo.1098.1">
  return Results.Ok(customers);
});
app.MapGet("GetCustomerByIdUsingDapper",
  async(int id, SqlConnection connection) =&gt;
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.1099.1">var customer = await connection</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1100.1">      .QueryFirstOrDefaultAsync&lt;Customer&gt;("SELECT Id,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1101.1">      Name FROM Customers WHERE Id = @Id", new {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1102.1">        Id = id });</span></strong><span class="koboSpan" id="kobo.1103.1">
    if (customer is null) return Results.NotFound();
    return Results.Ok(customer);
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1104.1">
     Let’s
    </span>
    <a id="_idIndexMarker391">
    </a>
    <span class="koboSpan" id="kobo.1105.1">
     explore the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1106.1">
      preceding code:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.1107.1">
      In C# and ASP.NET Core 9, the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1108.1">
       _ =&gt; new
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1109.1">
      syntax is known as discarded lambda and is used when there is no need to use the input parameter of the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1110.1">
       lambda expression.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1111.1">
       SqlConnection
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1112.1">
      : We are adding the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1113.1">
       SqlConnection
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1114.1">
      object to the DI container using the same connection string used by the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1115.1">
       DbContext
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1116.1">
      .
     </span>
     <span class="koboSpan" id="kobo.1116.2">
      We are using the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1117.1">
       AddScoped
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1118.1">
      method, which means that each time the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1119.1">
       SqlConnection
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1120.1">
      object is used during a request, it will
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1121.1">
       be reused.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1122.1">
       QueryAsync
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1123.1">
      : We are getting all the customers from the database using a simple SQL query.
     </span>
     <span class="koboSpan" id="kobo.1123.2">
      The desired columns have been added to the SQL command, along with an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1124.1">
       ORDER BY NAME
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1125.1">
      statement.
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1126.1">
       QueryAsync
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1127.1">
      is a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1128.1">
       SqlConnection
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1129.1">
      extension method and, when it obtains the result, it will automatically map the data to C# objects based on the names of the properties
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1130.1">
       and columns.
      </span>
     </span>
    </li>
   </ul>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.1131.1">
     Get all the data from the database
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.1132.1">
     Generally, it is not recommended to fetch all the records from a database in a single query as there may be thousands or millions of records in the database tables, which can cause performance problems.
    </span>
    <span class="koboSpan" id="kobo.1132.2">
     Keep in mind that the example proposed here is intended to facilitate understanding of the concept and should not be used in production applications.
    </span>
    <span class="koboSpan" id="kobo.1132.3">
     The recommended solution is to use pagination.
    </span>
    <span class="koboSpan" id="kobo.1132.4">
     Pagination involves breaking data into small, manageable chunks.
    </span>
    <span class="koboSpan" id="kobo.1132.5">
     To learn more, the following page contains implementation
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1133.1">
      examples:
     </span>
    </span>
    <a href="https://learn.microsoft.com/en-us/ef/core/querying/pagination">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1134.1">
       https://learn.microsoft.com/en-us/ef/core/querying/pagination
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1135.1">
      .
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1136.1">
       QueryFirstOrDefaultAsync
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1137.1">
      : In the same way as the previous method, a query is made in the database and if the record is found, it will be returned and mapped to a Customer object.
     </span>
     <span class="koboSpan" id="kobo.1137.2">
      If the record is not found, then it returns the value
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1138.1">
       Null
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1139.1">
      .
     </span>
     <span class="koboSpan" id="kobo.1139.2">
      The important point
     </span>
     <a id="_idIndexMarker392">
     </a>
     <span class="koboSpan" id="kobo.1140.1">
      in the SQL query is the use of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1141.1">
       @Id
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1142.1">
      parameter.
     </span>
     <span class="koboSpan" id="kobo.1142.2">
      Dapper methods can substitute named parameters in the string.
     </span>
     <span class="koboSpan" id="kobo.1142.3">
      So, after defining the SQL command with the parameters, we must define an object that contains the named properties of the same parameters as the parameters defined in the SQL command.
     </span>
     <span class="koboSpan" id="kobo.1142.4">
      In the code example above, the defined parameter is named
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1143.1">
       @Id
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1144.1">
      , which requires that the object passed as a parameter has a property named Id, like the snippet
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1145.1">
       new {Id = id}
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1146.1">
      .
     </span>
     <span class="koboSpan" id="kobo.1146.2">
      Using an object allows us to define more than one parameter
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1147.1">
       if necessary.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.1148.1">
     The use of
    </span>
    <a id="_idIndexMarker393">
    </a>
    <span class="koboSpan" id="kobo.1149.1">
     SQL commands, in this case, allows us to create more performant queries for different purposes.
    </span>
    <span class="koboSpan" id="kobo.1149.2">
     Likewise, Dapper can be used to add, change, and remove records in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1150.1">
      the database.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1151.1">
     In this case, we do not need to manage the SQL connections that are controlled by the DI container, and we benefit from the ORM’s automatic
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1152.1">
      mapping approach.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.1153.1">
     Dapper SqlBuilder
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.1154.1">
     Dapper also has an extension that makes it easier to write SQL commands in the format needed by the Micro ORM called Dapper SQL Builder.
    </span>
    <span class="koboSpan" id="kobo.1154.2">
     It is a very useful extension, even when it is necessary to manipulate
    </span>
    <a id="_idIndexMarker394">
    </a>
    <span class="koboSpan" id="kobo.1155.1">
     SQL strings according to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1156.1">
      some conditions.
     </span>
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.1157.1">
     You can find out more about the
    </span>
    <a id="_idIndexMarker395">
    </a>
    <span class="koboSpan" id="kobo.1158.1">
     Dapper SQL Builder extension by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1159.1">
      visiting
     </span>
    </span>
    <a href="https://github.com/DapperLib/Dapper/tree/main/Dapper.SqlBuilder">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1160.1">
       https://github.com/DapperLib/Dapper/tree/main/Dapper.SqlBuilder
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1161.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1162.1">
     As we have seen, both ORM and Micro ORM are great allies in the communication model with the database and can be used together, providing different benefits in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1163.1">
      different contexts.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1164.1">
     This flexibility of ASP.NET Core 9 allows us to create different types of applications, from the simplest to the most complex, and interact with databases using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1165.1">
      best practices.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-91">
    <a id="_idTextAnchor092">
    </a>
    <span class="koboSpan" id="kobo.1166.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1167.1">
     In this chapter, we learned about data persistence in ASP.NET Core 9, exploring how applications interact with databases to store and manage critical information.
    </span>
    <span class="koboSpan" id="kobo.1167.2">
     You’ve compared the strengths of relational (SQL) and non-relational (NoSQL) databases, allowing you to choose the right fit for your project.
    </span>
    <span class="koboSpan" id="kobo.1167.3">
     Additionally, you’ve seen how ORMs such as EF Core simplify development by mapping objects to database records, and you’ve learned about the benefits of Micro ORMs such as Dapper for fine-grained control over performance-critical
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1168.1">
      database operations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1169.1">
     We’ll take another step toward developing high-quality applications by learning about security best practices in
    </span>
    <a href="B21788_06.xhtml#_idTextAnchor093">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1170.1">
        Chapter 6
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.1171.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1171.2">
     We’ll explore essential best practices and strategies for defending your applications against vulnerabilities.
    </span>
    <span class="koboSpan" id="kobo.1171.3">
     You’ll learn how to ensure user data protection, authentication security, and overall application integrity – vital foundations for building robust, reliable
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1172.1">
      web applications.
     </span>
    </span>
   </p>
  </div>
 </body></html>