<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-173"><a id="_idTextAnchor184"/>12</h1>
<h1 id="_idParaDest-174"><a id="_idTextAnchor185"/>Securing Microservices with Bearer Tokens</h1>
<p>Security is one of the most important and tedious aspects of any application. We need to ensure that our application is built using secure code and always pursue the most effective ways to reduce intrusions and loopholes in our systems. Despite this, however, security also comes at the cost of usability, and we should always seek to find a balance between the two.</p>
<p>Basic application security begins with a login system. We should be able to allow a user to register themselves in a system and store some identifying information accordingly. When the user returns and wishes to access certain parts of the application, we will query the database and verify the identity of the user through their identifying information and decide to grant or restrict access accordingly.</p>
<p>In modern applications, we find it increasingly difficult to maintain a data store as an authority on all our users, while accounting for all the possible channels through which they may access our application. We have been exploring using microservices architecture, which takes our security considerations to a new level, where we now have multiple parts of an application that we need to secure for different users who are accessing from several devices.</p>
<p>In this chapter, we will explore the major considerations to be made in securing our microservices application and the best configurations and technologies to use.</p>
<p>After reading this chapter, we will have done the following:</p>
<ul>
<li>Understand bearer token security</li>
<li>Learn how to implement bearer token security in an ASP.NET Core API</li>
<li>Learn how to use an identity provider to secure our microservices</li>
</ul>
<h1 id="_idParaDest-175"><a id="_idTextAnchor186"/>Technical requirements</h1>
<p>The code references used in this chapter can be found in the project repository that is hosted on GitHub here: <a href="https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch12">https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch12</a>.</p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor187"/>Bearer tokens for securing communications</h1>
<p>Bearer tokens are a fairly recent solution to a number of security, authentication, and authorization challenges that we have faced when developing modern applications. We have gone from working with standard<a id="_idIndexMarker577"/> desktop and web applications to catering to various internet-capable devices that have similar security needs. Before we start exploring what these modern security needs are, let us review some of the challenges that we have faced with web applications over the years.</p>
<p>When securing web <a id="_idIndexMarker578"/>applications, we face several challenges:</p>
<ul>
<li>We need a way to collect user information.</li>
<li>We need a way to store user information.</li>
<li>We need a way to validate <a id="_idIndexMarker579"/>user information. This is called <em class="italic">authentication</em>.</li>
<li>We need a way to track the user’s authenticated state in between requests.</li>
<li>We need a way to track what <a id="_idIndexMarker580"/>the user is allowed to do in our system. This is called <em class="italic">authorization</em>.</li>
<li>We need to cater to various channels or device types through which a user might access the web application.</li>
</ul>
<p>In a typical web application, most of these factors can be implemented through form authentication, where we ask for uniquely identifying information and check our database for a match.</p>
<p>When a match is found, we instantiate a temporary storage mechanism that will identify the user as authenticated in our system. This temporary storage construct can come in the form of the following:</p>
<ul>
<li><strong class="bold">Sessions</strong>: A way to store information in a variable that can be used across a website. Unlike typical variables that lose their value with each request, a session retains <a id="_idTextAnchor188"/>its value for a certain period until it either expires or is destroyed. Session variables are typically stored on the server, and one or many session variables are <a id="_idIndexMarker581"/>created each time a user authenticates successfully. Session variables can store information such as a username, role, and so on. With too many users logging in simultaneously, using session variables can lead to memory issues on a less powerful server.</li>
<li><strong class="bold">Cookies</strong>: An alternative to sessions, where a small file is created and stored on the user’s device. It serves a similar purpose for storing information between requests, as well as tracking a user’s authenticated state. Each time a request is sent from the user’s device, this <a id="_idIndexMarker582"/>cook<a id="_idTextAnchor189"/>ie is sent, and the server web application uses this information to be informed of whether actions can be taken and if so, which ones. Cookies are sometimes preferred to sessions given that they reduce the load on the server and place more responsibility on the user’s device.</li>
</ul>
<p>Both options work <a id="_idIndexMarker583"/>fantastically when we are sure that we will be dealing with a web application that maintains a <em class="italic">state</em>. A state means that we retain user information in between requests and remember who is logged in and their basic information for the period that they are using the website – but what h<a id="_idTextAnchor190"/>appens when you need to authenticate against APIs? An API, by nature, does not maintain a state. It does not attempt to retain the knowledge of the users accessing it since APIs are designed for sporadic access from any channel at any point. For this reason, we implement bearer tokens.</p>
<p>A bearer token is an encoded string that contains information about a user who is attempting to communicate with our API. It helps us facilitate stateless communication and facilitate general user authentication and authorization scenarios.</p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor191"/>Understanding bearer tokens</h2>
<p>A <em class="italic">bearer token</em> or <strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>) is a construct <a id="_idIndexMarker584"/>that is widely <a id="_idIndexMarker585"/>used in <em class="italic">authentication</em> and <em class="italic">authorization</em> scenarios for <em class="italic">stateless</em> APIs. Bearer tokens are based on an open industry standard of authentication that has made it easy for us to share authenticated user information between a server and a client. When an API is accessed, a temporary state is created for the duration of the request-response cycle. This means that when the request is received, we can determine the originating source of the request and can decode additional header information as needed. Once a response is returned, we no longer have a record of the request, where it came from, or who made it.</p>
<p>Bearer tokens are issued <a id="_idIndexMarker586"/>after a successful authentication request. We receive a request to our authentication API endpoint and use the information to check our databases, as previously described. Once a user is verified, we compile several data points, such as the <a id="_idIndexMarker587"/>following:</p>
<ul>
<li><strong class="bold">Subject</strong>: Usually a unique identifier for the user, such as the user ID from the originating database.</li>
<li><strong class="bold">Issuer</strong>: Usually a name that is associated with the service that has generated the token for issuance.</li>
<li><strong class="bold">Audience</strong>: Usually a name that is associated with the client application that will be consuming the token.</li>
<li><strong class="bold">Username</strong>: The user’s unique system name, usually used for login.</li>
<li><strong class="bold">Email address</strong>: The user’s email address.</li>
<li><strong class="bold">Role</strong>: The user’s system role that determines what they are authorized to do.</li>
<li><strong class="bold">Claims</strong>: Various bits of information about the user that can be used to aid in authorization or information display in the client application. This can include the user’s name, gender, and even the path to their profile picture.</li>
<li><strong class="bold">Expiry Date</strong>: Tokens should always have a moderate expiry date relative to their generation. When this expires, the user will need to reauthenticate, so we don’t want it to only be valid for a short period, but it should also not last forever.</li>
</ul>
<p>Ultimately, a login flow between a client application and an API is as follows:</p>
<ol>
<li>A user will use a client application to log in</li>
<li>The client application forwards the information collected from the login form to the login API endpoint for verification</li>
<li>The API returns an encoded string, or token, that contains the most relevant bits of information about the user</li>
<li>The client application stores this encoded string and uses it for subsequent API communications</li>
</ol>
<p>Based on this kind of flow, the client application will use information from the token to display information about the user on the UI, such as the username or other information that may have been included such as the first name and last name. While there are recommended bits of<a id="_idIndexMarker588"/> information that you should include in a token, there is no set standard on what should be included. We do, however, avoid including sensitive information, such as a password.</p>
<p>Bearer tokens are encoded but not encrypted. This means that they are self-contained blocks of information that contain all the information that we have mentioned earlier but are not human-readable at first sight. The encoding compresses the strings, usually as a <em class="italic">base64</em> representation, and this is the format used for transportation between the client and the server, as well as for storage. Token strings are not meant to be secure since it is easy to decode the string and see the information therein, and once again, that is why we do not include sensitive and incriminating data in the token. This token string comprises three sections. Each section is separated by a full stop (<em class="italic">.</em>) and the general format is <em class="italic">aaaa.bbbb.cccc</em>. Each section represents the following:</p>
<ul>
<li><strong class="bold">Header</strong>: The <em class="italic">a</em> section of the token, which contains information about the type of token and the signing algorithm that was used for the encoding, such as HMAC SHA-256 and RSA.</li>
<li><strong class="bold">Payload</strong>: The <em class="italic">b</em> section of the token string, which contains user information in the form of claims. We will discuss claims in a bit more detail later in this chapter.</li>
<li><strong class="bold">Signature</strong>: The <em class="italic">c</em> section of the token, which contains a string representation of the encoded header, the encoded payload, and the secret key that was used for the encoding. This signature is used to verify that the token has not been tampered with since its generation.</li>
</ul>
<p>Most development frameworks include tools and libraries that can decrypt bearer tokens during the runtime of the application. Since bearer tokens are based on an open standard, support for decoding tokens is widely available. This allows us to write generic and consistent code to handle tokens being issued by an API. Each API implementation can include different tokens relative to the exact needs of the application, but there are certain standards that we can<a id="_idIndexMarker589"/> always count on.</p>
<p>During development, however, we might want to test a token to see the contents that we can expect to be present in a more human-readable form. For this reason, we turn to third-party tools that decode and show us the contents of a token and allow us to reference different bits of information as needed.</p>
<p>Tools such as <strong class="bold">jwt.io</strong> provide us<a id="_idIndexMarker590"/> with the ability to simply paste in a token and view the information in a more human-readable format. As stated, there are three sections in each token string and we can view each of the sections in plaintext using this website or a similar tool. The payload section of the token, when decoded, will yield the information displayed in <em class="italic">Figure 12.1</em>. It shows a sample bearer token and its contents on <a href="http://www.jwt.io">www.jwt.io</a>.</p>
<div><div><img alt="Figure 12.1 – We see the encoded string and the plaintext translation of its contents to the right" src="img/Figure_12.1_B19100.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – We see the encoded string and the plaintext translation of its contents to the right</p>
<p>All the information that is placed into a bearer token represents a key-value pair. Each key-value pair represents a unit of information about the user or the token itself, and the keys are really short names for the previously mentioned claims that are usually present in a token:</p>
<ul>
<li><strong class="bold">iss</strong>: Represents the <strong class="bold">issuer</strong> value.</li>
<li><strong class="bold">sub</strong>: Represents the <strong class="bold">subject</strong> value.</li>
<li><strong class="bold">aud</strong>: Represents the <strong class="bold">audience</strong> value.</li>
<li><strong class="bold">nonce</strong>: Represents a unique value that should always change with each token to prevent replay attacks. This value is always new, and this ensures that no two tokens that are issued to the <a id="_idIndexMarker591"/>same user are the same. This can sometimes be called a <strong class="bold">jti</strong> claim.</li>
<li><strong class="bold">exp</strong>: Represents the expiration date of the token. The value is in the form of a UNIX epoch, which is a numerical representation of a moment in time.</li>
<li><strong class="bold">iat</strong>: Represents the date and time of issuance.</li>
</ul>
<p>Now that we have<a id="_idIndexMarker592"/> explored why we need bearer tokens and how they are used, let us review how we can implement token security in our ASP.NET Core API application.</p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor192"/>Implementing bearer token security</h1>
<p>ASP.NET Core offers native authentication and authorization support through its <code>Identity Core</code> library. This library has direct integration with Entity Framework and allows us to create standard user management tables in the target database. We can also further specify the<a id="_idIndexMarker593"/> authentication methods that we prefer and define policies that define authorization rules throughout that application.</p>
<p>This robust library has built-in support for the following:</p>
<ul>
<li><strong class="bold">User registration</strong>: The user manager library has functions that make user creation and management easy. It has functions that cover most of the common user management operations.</li>
<li><strong class="bold">Login, session, and cookie management</strong>: The sign-in manager library has functions that can manage user authentication and session management scenarios.</li>
<li><strong class="bold">Two-factor authentication</strong>: Identity Core allows us to implement multi-factor authentication natively with email or SMS. This can be easily extended.</li>
<li><code>Identity Core</code> makes it easy to integrate this feature into your application.</li>
</ul>
<p>Securing an API using bearer tokens ensures that each API call is required to have a valid token in the header section of the request. An HTTP header allows for additional information to be provided with an HTTP request or response.</p>
<p>In our case of securing an <a id="_idIndexMarker594"/>API, we enforce that each request must have an authorization header that contains the bearer token. Our API will assess the incoming request headers, retrieve the token, and validate it against the predefined configurations. If the token doesn’t meet the standards or is expired, an <code>HTTP 401 Unauthorized</code> response will be returned. If the token meets the requirements, then the request will be fulfilled. This built-in mechanism makes it easy and maintainable to support wide-scale and robust authentication and authorization rules in our application.</p>
<p>Now that we have an idea of the <code>Identity Core</code> library and how it is natively supported in ASP.NET Core applications, we can explore the necessary package and configurations needed to secure an API using bearer tokens.</p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor193"/>Securing API with bearer tokens</h2>
<p>We can begin by<a id="_idIndexMarker595"/> installing the following packages using the NuGet package manager:</p>
<pre class="source-code">
Install-Package Microsoft.AspNetCore.Authentication
  .JwtBearer</pre>
<p>The first package supports direct integration between Entity Framework and <code>Identity Core</code>. The second package contains extended methods that allow us to implement token generation and validation rules in our API configuration.</p>
<p>Next, we need to define constant values that will inform the token generation and validation activities in the API. We can place these constants in <code>appsettings.json</code> and they will look as follows:</p>
<pre class="source-code">
  "Jwt": {
    "Issuer": "HealthCare.Appointments.API",
    "Audience": " HealthCare.Appointments.Client",
    "DurationInHours": 8
    "Key": "ASecretEncodedStringHere-Minimum16Charatcters"
  }</pre>
<p>We have already discussed what the issuer and audience values help to enforce. We can also state a value for the proposed lifetime of the token that is generated. This value should always be relative to the API’s capabilities and operations, as well as your risk tolerance. The longer a token remains valid, the longer we provide a potential attacker with a window into our system. At the same time, if the period is too short, then the client will need to<a id="_idIndexMarker596"/> reauthenticate too often. We should always seek to strike a balance.</p>
<p>Our key value here is demonstrative in its value, but we use this signing key as an encryption key when generating the token. The key should always be kept secret, so we may use application secrets or a more secure key store to store this value.</p>
<p>Now that we have the application constants, we can proceed to specify the global authentication settings in our <code>Program.cs</code> file:</p>
<pre class="source-code">
builder.Services.AddAuthentication(options =&gt;
{
    options.DefaultAuthenticateScheme =
        JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme =
        JwtBearerDefaults.AuthenticationScheme;
}).AddJwtBearer(o =&gt;
{
    o.TokenValidationParameters = new
        TokenValidationParameters
    {
        ValidateIssuer = true,
        ValidateAudience = true,
        ValidateLifetime = true,
        ValidateIssuerSigningKey = true,
        ValidIssuer = builder.Configuration["Jwt:Issuer"],
        ValidAudience = builder.Configuration
            ["Jwt:Audience"],
        IssuerSigningKey = new SymmetricSecurityKey
        (Encoding.UTF8.GetBytes(builder.Configuration["Jwt:
            Key"]))
    };
});</pre>
<p>Here, we are adding<a id="_idIndexMarker597"/> configurations to the application that will declare to the API application that it should enforce a particular type of authentication scheme. Given that Identity Core has support for several authentication schemes, we need to specify the ones that we intend to enforce and by extension, the type of challenge scheme that we require. The challenge scheme refers to the authentication requirements that the application will need. Here, we specify <code>JwtBearerDefaults.AuthenticationScheme</code> for both the challenge and authentication schemes. This <code>JwtBearerDefaults</code> class contains generally available and used JWT constants. In this case, <code>AuthenticationScheme</code> will render the value bearer, which is a keyword.</p>
<p>After we are done defining the authentication scheme, we go on to set configurations that will enforce certain rules that will govern how a bearer token is validated. By using <code>true</code> for <code>ValidateIssuer</code>, <code>ValidateAdience</code>, and <code>ValidateLifetime</code>, we are enforcing that the matching values in an incoming token must match the values that we set in the <code>appsettings.json</code> configuration constants. You can be flexible with the validation rules based on how strictly you want to check the bearer token contents against your system. The fewer validations in place, the higher the chances of someone using fake tokens to gain access to the system.</p>
<p>We will also need to ensure that our API knows that we intend to support authorization, so we need to add this line as well:</p>
<pre class="source-code">
builder.Services.AddAuthorization();</pre>
<p>Then, we also need to include our middleware with the following two lines, in this order:</p>
<pre class="source-code">
app.UseAuthentication();
app.UseAuthorization();</pre>
<p>Now that we have taken care of the preliminary configurations, we need to include our default identity user tables in our database. We first change the inheritance of our database context from <code>DbContext</code> to <code>IdentityDbContext</code>:</p>
<pre class="source-code">
public class AppointmentsDbContext : IdentityDbContext</pre>
<p>We will also add <a id="_idIndexMarker598"/>code to generate a sample user in the database context. When we perform the next migration, then this user will be added to the table and we can use it to test authentication:</p>
<pre class="source-code">
protected override void OnModelCreating(ModelBuilder
    builder)
        {
            base.OnModelCreating(builder);
            var hasher = new PasswordHasher&lt;ApiUser&gt;();
            builder.Entity&lt;ApiUser&gt;().HasData(new ApiUser
            {
                Id = "408aa945-3d84-4421-8342-
                    7269ec64d949",
                Email = "admin@localhost.com",
                NormalizedEmail = "ADMIN@LOCALHOST.COM",
                NormalizedUserName = "ADMIN@LOCALHOST.COM",
                UserName = "admin@localhost.com",
                PasswordHash = hasher.HashPassword(null,
                    "P@ssword1"),
                EmailConfirmed = true
            });
        }</pre>
<p>After these changes, the next migration that we perform will generate user tables that will be created when the <code>update-database</code> command is executed. These new tables will, by default, be prefixed with <code>AspNet</code>.</p>
<p>We also need to register the <code>Identity Core</code> services in our application and connect it to the database context as follows:</p>
<pre class="source-code">
builder.Services.AddIdentityCore&lt;IdentityUser&gt;()
    .AddRoles&lt;IdentityRole&gt;()
    .AddEntityFrameworkStores&lt;AppointmentsDbContext&gt;();</pre>
<p>Here, we register <a id="_idIndexMarker599"/>our identity-related services in our applications, specify that we are using the default user type called <code>IdentityUser</code>, the default role type called <code>IdentityRole</code>, and the data store associated with <code>AppointmentsDbContext</code>.</p>
<p>Now that we have specified what is required for the integration of <code>Identity Core</code> and JWT authentication, we can look to implement a login endpoint that will verify the user’s credentials and generate a token with the minimum identifying information accordingly. We will investigate this in the next section.</p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor194"/>Generating and issuing bearer tokens</h2>
<p>ASP.NET Core has support for <a id="_idIndexMarker600"/>generating, issuing, and validating bearer tokens. To do this, we need to implement logic in our authentication flow that will generate a token<a id="_idIndexMarker601"/> with the authenticated user’s information, and then return it to the requesting client in the body of the response. Let us<a id="_idIndexMarker602"/> first define a <code>Id</code> value and the token and wrap them both in their own <code>AuthResponseDto</code>:</p>
<pre class="source-code">
public class AuthResponseDto
{
   public string UserId { get; set; }
   public string Token { get; set; }
}</pre>
<p>We will also have a DTO that will accept login information. We can call this <code>LoginDto</code>:</p>
<pre class="source-code">
public class LoginDto
    {
        [Required]
        [EmailAddress]
        public string Email { get; set; }
        [Required]
        [StringLength(15, ErrorMessage = "Your Password is
            limited to {2} to {1} characters",
                MinimumLength = 6)]
        public string Password { get; set; }
    }</pre>
<p>Our DTO will enforce <a id="_idIndexMarker603"/>validation rules on the data being submitted. Here, our users <a id="_idIndexMarker604"/>can authenticate using their email address and a password, and invalid attempts that violate the validation rules will be rejected with a <code>400BadRequest</code> HTTP code.</p>
<p>Our authentication controller will implement a login action that will accept this DTO as a parameter:</p>
<pre class="source-code">
[Route("api/[controller]")]
[ApiController]
public class AccountController : ControllerBase
{
    private readonly IAuthManager _authManager;
    public AccountController(IAuthManager authManager)
    {
        _authManager = authManager;
    }
    // Other Actions here
    [HttpPost]
    [Route("login")]
    public async Task&lt;IActionResult&gt; Login([FromBody]
        LoginDTO loginDto)
    {
        var authResponse = _authManager.Login(loginDto);
        if (authResponse == null)
        {
            return Unauthorized();
        }
        return Ok(authResponse);
    }
}</pre>
<p>We inject an <code>IAuthmanager</code> service<a id="_idIndexMarker605"/> into the controller, where we have abstracted <a id="_idIndexMarker606"/>the bulk of the user validation and token generation logic. This service contract is as follows:</p>
<pre class="source-code">
public interface IAuthManager
{
   // Other methods
   Task&lt;AuthResponseDto&gt; Login(LoginDto loginDto);
}</pre>
<p>In the implementation of <code>AuthManager</code>, we use the <code>UserManager</code> service, which is provided by <code>Identity Core</code>, to verify the username and password combination that is submitted. Upon verification, we will generate and return an <code>AuthResponseDto</code> object containing <a id="_idIndexMarker607"/>the token and user’s ID. Our implementations will look<a id="_idIndexMarker608"/> like the following code block:</p>
<pre class="source-code">
public class AuthManager : IAuthManager
{
    private readonly UserManager&lt;IdentityUser&gt;
        _userManager;
    private readonly IConfiguration _configuration;
    private IdentityUser _user;
    public AuthManager(UserManager&lt;IdentityUser&gt;
        userManager, IConfiguration configuration)
    {
        this._userManager = userManager;
        this._configuration = configuration;
    }
    // Other Methods
    public async Task&lt;AuthResponseDto&gt; Login(LoginDto
        loginDto)
    {
        var user = await _userManager.FindByEmailAsync
            (loginDto.Email);
        var isValidUser = await _userManager
            .CheckPasswordAsync(_user, loginDto.Password);
        if(user == null || isValidUser == false)
        {
            return null;
        }
        var token = await GenerateToken();
        return new AuthResponseDto
        {
            Token = token,
            UserId = _user.Id
        };
    }</pre>
<p>We inject both <code>UserManager</code> and <code>IConfiguration</code> into our <code>AuthManager</code>. In our login method, we attempt to retrieve the user based on the email address that was provided in <code>LoginDto</code>. If we<a id="_idIndexMarker609"/> then attempt to validate that the correct password was <a id="_idIndexMarker610"/>provided. If there is no user, or the password was incorrect, we return a null value, which the login action will use to indicate that no user was found and will return a <code>401 Unauthorized</code> HTTP response.</p>
<p>If we can validate the user, then we generate a token and then return our <code>AuthResponseDto</code> object with the token and the user’s <code>Id</code> value. The method to generate the token is also in <code>AuthManager</code> and it looks like this:</p>
<pre class="source-code">
private async Task&lt;string&gt; GenerateToken()
{
        var securitykey = new SymmetricSecurityKey
            (Encoding.UTF8.GetBytes(_configuration["
               Jwt:Key"]));
        var credentials = new SigningCredentials
            (securitykey, SecurityAlgorithms.HmacSha256);
        var roles = await _userManager.GetRolesAsync
            (_user);
        var roleClaims = roles.Select(x =&gt; new
            Claim(ClaimTypes.Role, x)).ToList();
        var userClaims = await _userManager.GetClaimsAsync
           (_user);
        var claims = new List&lt;Claim&gt;
        {
            new Claim(JwtRegisteredClaimNames.Sub,
                _user.Email),
            new Claim(JwtRegisteredClaimNames.Jti,
                Guid.NewGuid().ToString()),
            new Claim(JwtRegisteredClaimNames.Email,
                _user.Email),
            new Claim("uid", _user.Id),
        }
        .Union(userClaims).Union(roleClaims);
        var token = new JwtSecurityToken(
            issuer: _configuration[" Jwt:Issuer"],
            audience: _configuration[" Jwt:Audience"],
            claims: claims,
            expires: DateTime.Now.AddMinutes
                (Convert.ToInt32(_configuration["
                    Jwt:DurationInMinutes"])),
            signingCredentials: credentials
            );
        return new JwtSecurityTokenHandler()
            .WriteToken(token);
    }
}</pre>
<p>In this method, we start by retrieving our security key from <code>appsettings.json</code> through the <code>IConfiguration</code> service. We then encode and encrypt this key. We also compile the standard <a id="_idIndexMarker611"/>claims that should generally be included in a token, and we can include other claim<a id="_idIndexMarker612"/> values, whether from the user’s claims in the database or custom claims that we deem necessary.</p>
<p>We finally compile all the claims and other key values such as these:</p>
<ul>
<li><code>SigningCredentials</code> with the value of the encrypted key</li>
<li><em class="italic">Issuer</em> and <em class="italic">Audience</em> as defined in <code>appsettings.json</code></li>
<li>The jti claim, which is a unique identifier, or <em class="italic">nonce</em> for the token.</li>
<li>The expiration date and time of the token, relative to the time limit from the configuration</li>
</ul>
<p>The result is a string full of encoded characters that is returned to our <code>Login</code> method, and this is then returned to the controller with <code>AuthResponseDto</code>.</p>
<p>In order for our <code>AuthManager</code> to be useable in our controller, we need to register the interface and implementation in our <code>Program.cs</code> file using this line:</p>
<pre class="source-code">
builder.Services.AddScoped&lt;IAuthManager, AuthManager&gt;();</pre>
<p>With these configurations in place, we can protect our controllers and actions with a simple <code>[Authorize]</code> attribute. This attribute will be placed directly above the implementation of our class or the action <a id="_idIndexMarker613"/>method. Our API will automatically assess each incoming request for <a id="_idIndexMarker614"/>an authorization header value and automatically reject requests that have no token or violate the rules that were stipulated in <code>TokenValidationParameters</code>.</p>
<p>Now, when we use<a id="_idIndexMarker615"/> a tool such as <strong class="bold">Swagger UI</strong> or <strong class="bold">Postman</strong>, to test our login endpoint using the test <a id="_idIndexMarker616"/>user that we seeded, we will receive a token response that looks like this:</p>
<pre class="console">
{
  "userId": "408aa945-3d84-4421-8342-7269ec64d949",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJz
  dWIiOiJhZG1pbkBsb2NhbGhvc3QuY29tIiwianRpIjoiZWU5ZjI4OD
  ItMWFkZC00ZTZkLThlZjktY2Q1ZjFlOWM3ZjMzIiwiZW1haWwiOiJhZ
  G1pbkBsb2NhbGhvc3QuY29tIiwidWlkIjoiNDA4YWE5NDUtM2Q4NC00
  NDIxLTgzNDItNzI2OWVjNjRkOTQ5IiwiZXhwIjoxNjY5ODI4MzMwLCJ
  pc3MiOiJIb3RlbExpc3RpbmdBUEkiLCJhdWQiOiJIb3RlbExpc3Rpbm
  dBUElDbGllbnQifQ.yuYUIFKPTyKKUpsVQhbS4NinGLSF5_XXPEBtAEf
  jO5E"
}</pre>
<p>Implementing token authentication in an API is easy enough, but we are not only accounting for one API in our application. We have several APIs that need to be secured and preferably, one token should be accepted across all the services. If we continue down this path, we may end up making these configurations per service and then needing extra code to have all the other services acknowledge a token that might be issued by any other service.</p>
<p>We need a more global solution and more suitably, a central authority of security and token generation and management for all the services in our microservices application. This is where we begin to explore separating the token management responsibilities from each API and placing them in one that<a id="_idIndexMarker617"/> implements <strong class="bold">IdentityServer</strong>, which is <strong class="bold">OpenID Connect</strong> and the <strong class="bold">OAuth 2.0</strong> framework for ASP.NET Core. We will investigate implementing <strong class="bold">IdentityServer</strong> in the next section.</p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor195"/>Using IdentityServer4 to secure microservices</h1>
<p>A key feature in any modern <a id="_idIndexMarker618"/>application or suite of applications is the concept of <strong class="bold">single-sign-on</strong> (<strong class="bold">SSO</strong>). This feature allows us to provide our credentials once and retain an authenticated user state<a id="_idIndexMarker619"/> across several applications within the suite. This is a feature that can be observed in Google or Microsoft Online products, to name a few.</p>
<p>This concept will come in<a id="_idIndexMarker620"/> handy when securing a microservices application. As we can see, it is not feasible to implement token-issuing logic in many APIs across an application and then attempt to coordinate access to all the APIs when it was granted to one. We also run the risk of requiring a user to reauthenticate each time they attempt to access a feature that requires another API to complete, and this will not make for a good user experience.</p>
<p>With these considerations in mind, we need to use a central authority that can allow us to implement more global token issuing and validation rules given all the security considerations of our services. In ASP.NET Core, the best candidate for such services is <strong class="bold">IdentityServer</strong>.</p>
<p><code>Identity Core</code> and allows developers to support <strong class="bold">OpenID Connect</strong> and <strong class="bold">OAuth2.0</strong> standards in their<a id="_idIndexMarker621"/> web application security implementation. It is compliant with industry standards and contains out-of-the-box support for token-based authentication, SSO, and API access control in your applications. While it is a commercial product, a community edition is available for use by small organizations or personal projects.</p>
<p>The recommended implementation style of <strong class="bold">IdentityServer</strong> would have us do the following:</p>
<ol>
<li value="1">Create a new microservice for authentication</li>
<li>Create a new database just for our authentication-related tables (optional)</li>
<li>Configure scopes to be included in the token information</li>
<li>Configure our services <a id="_idIndexMarker622"/>to know which scopes are allowed to access them</li>
</ol>
<p><em class="italic">Figure 12.2</em> shows the<a id="_idIndexMarker623"/> IdentityServer authentication flow:</p>
<div><div><img alt="Figure 12.2 – This depicts how IdentityServer sits between a client and service and handles the flow of authentication and token exchange﻿" src="img/Figure_12.2_B19100.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – This depicts how IdentityServer sits between a client and service and handles the flow of authentication and token exchange</p>
<p>Now, let us explore creating a new service and configuring it to be our central authority for authentication and authorization in<a id="_idTextAnchor196"/> our microservices application.</p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor197"/>Configuring IdentityServer</h2>
<p>Duende offers us<a id="_idIndexMarker624"/> some quick-start ASP.NET Core project templates that are easy to create in our solution. These quick-start templates bootstrap the minimum requirements needed to bootstrap IdentityServer functionality in an ASP.NET Core project. The general steps involved in setting up an IdentityServer service are as follows:</p>
<ul>
<li>Add Duende IdentityServer support to a standard ASP.ENT Core project</li>
<li>Add data storage support, preferably using Entity Framework configurations</li>
<li>Add support for ASP.NET <code>Identity Core</code></li>
<li>Configure token issuing for client applications</li>
<li>Secure client applications with IdentityServer</li>
</ul>
<p>To get started, we need to use the .NET CLI and run the following command:</p>
<pre class="console">
dotnet new --install Duende.IdentityServer.Templates</pre>
<p>That command will now <a id="_idIndexMarker625"/>give us access to new project templates prefixed with <code>Duende.IdentityServer</code>. <em class="italic">Figure 12.3</em> depicts what we can expect to see in Visual Studio once these templates are installed.</p>
<p><em class="italic">Figure 12.3</em> shows the Duende IdentityServer project templates:</p>
<div><div><img alt="Figure 12.3 – We get a variety of project templates that help us to speed up the IdentityServer implementation process" src="img/Figure_12.3_B19100.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – We get a variety of project templates that help us to speed up the IdentityServer implementation process</p>
<p>Using our healthcare microservices application, let us start by adding a new <code>HealthCare.Auth</code>. Now, we have a preconfigured IdentityServer project with several moving parts. We need to understand what the major components are and have an appreciation of how we can manipulate them for our needs. Let us conduct a high-level review <a id="_idIndexMarker626"/>of the file and folder structure that we get out of the box:</p>
<ul>
<li><code>Wwwroot</code>: A standard folder that is shipped with ASP.NET Core web application templates. It stores static assets such as JavaScript and CSS files that are used in the website.</li>
<li><code>Migrations</code>: Stores preset migrations that will be used to populate the data store with supporting tables. This is handy, as it removes the need for us to create the databases.</li>
<li><code>Pages</code>: Stores default Razor pages that are used to support the UI requirements of user authentication operations. Out of the box, we get login, register, grant, and user data management pages.</li>
<li><code>appsettings.json</code>: The standard file that contains logging and database connection configurations. We can change this connection string to reflect our requirements better.</li>
<li><code>buildschema.bat</code>: Contains Entity Framework commands using .NET command-line commands (<code>dotnet ef</code>) that will run migration scripts that have been included in the <code>Migrations</code> folder. We will use these commands to create our databases.</li>
<li><code>Config.cs</code>: This static class serves as a configuration authority. It is used to outline <code>IdentityResources</code>, <code>Scopes</code>, and <code>Clients</code>:<ul><li><code>IdentityResources</code>: Map to scopes that grant access to identity-related information. The <code>OpenId</code> method supports the expected <em class="italic">subject</em> (or <em class="italic">sub</em>-claim) value and the <code>Profile</code> method supports additional claim information such as <code>given_name</code> and <code>family_name</code>. We can also extend the default offerings and include additional details such as the user’s <em class="italic">roles</em>.</li><li><code>Scopes</code>: Can be used to<a id="_idIndexMarker627"/> outline permissions that can be included in the token when it is issued.</li><li><code>Clients</code>: Third-party clients that we expect to use IdentityServer as a token-issuing authority.</li></ul></li>
<li><code>HostingExtension.cs</code>: Contains service and middleware registration extension methods. These methods are then called in the <code>Program.cs</code> file during startup.</li>
<li><code>Program.cs</code>: Primary program execution file in an ASP.NET Core application.</li>
<li><code>SeedData.cs</code>: Contains default methods that will ensure that data migrations and seeding operations are carried out at application startup.</li>
</ul>
<p>IdentityServer uses two database contexts, a configuration store context and an operational store context. As a result, two database contexts are created in the <code>HostingExtension.cs</code> file. The <code>IdentityServer</code> libraries are registered using the following code:</p>
<pre class="source-code">
var isBuilder = builder.Services
                .AddIdentityServer(options =&gt;
                {
                    options.Events.RaiseErrorEvents = true;
                    options.Events.RaiseInformationEvents =
                        true;
                    options.Events.RaiseFailureEvents =
                        true;
                    options.Events.RaiseSuccessEvents =
                        true;
                     options.EmitStaticAudienceClaim =
                        true;
                })
                .AddTestUsers(TestUsers.Users)
                .AddConfigurationStore(options =&gt;
                {
                    options.ConfigureDbContext = b =&gt;
                        b.UseSqlite(connectionString,
                        dbOpts =&gt; dbOpts.MigrationsAssembly
                        (typeof(Program).Assembly
                         .FullName));
                })       .AddOperationalStore(options =&gt;
                {
                    options.ConfigureDbContext = b =&gt;
                        b.UseSqlite(connectionString,
                        dbOpts =&gt; dbOpts.MigrationsAssembly
                        (typeof(Program).Assembly.FullName
                        ));
                     options.EnableTokenCleanup = true;
                    options.RemoveConsumedTokens = true;
                });</pre>
<p>We are adding <code>TestUsers</code> to the<a id="_idIndexMarker628"/> configuration and then adding <code>ConfigurationStoreDbContext</code> and <code>OperationalStoreDbContext</code>. Other settings also govern how alerts and tokens are handled. The defaults are generally solid, but you may modify them based on your specific needs.</p>
<p>The default connection string and Entity Framework Core libraries give us support for an SQLite database. This can be changed to whatever the desired data store may be, but we will continue with SQLite for the purpose of this exercise. Let us proceed to generate the database and the tables, and we need the following commands:</p>
<pre class="source-code">
Update-Database -context PersistedGrantDbContext
Update-Database -context ConfigurationDbContext</pre>
<p>With these two commands, we <a id="_idIndexMarker629"/>will see our database scaffolded with all the supporting tables. At this point, they are all empty and we may want to populate them with some default values based on our application. Let us start by configuring the <code>IdentityResources</code> that we intend to support in our tokens. We can modify the <code>IdentityResources</code> method as follows:</p>
<pre class="source-code">
public static IEnumerable&lt;IdentityResource&gt;
    IdentityResources =&gt;
            new IdentityResource[]
            {
            new IdentityResources.OpenId(),
            new IdentityResources.Profile(),
            new IdentityResource("roles", "User role(s)",
                new List&lt;string&gt; { "role" })
            };</pre>
<p>We have added the list of roles to the resources list. Based on the claims that are being accounted for, we need to ensure that our users will contain all their expected data, as well as the list of claims that they are expected to have. Bear in mind that claims are the information that a client application will have via the token since it is the only way a client can track which user is online and what they can do.</p>
<p>Now, we can refine the list of scopes that are supported by modifying the <code>ApiScopes</code> method as follows:</p>
<pre class="source-code">
public static Ienumerable&lt;ApiScope&gt; ApiScopes =&gt;
            new ApiScope[]
            {
                new ApiScope("healthcareApiUser",
                    "HealthCare API User"),
                new ApiScope("healthcareApiClient",
                    "HealthCare API Client "),
            };</pre>
<p>Here, we are supporting two types of authentication scopes. These scopes will be used to support authentication for two different scenarios: client and user. Client authentication represents an unsupervised attempt to gain access to a resource, usually by another program or API. Client authentication means that a user will authenticate using credentials.</p>
<p>This brings us to the next configuration, which is for the clients. The term client is used a bit loosely since any entity that attempts to gain authorization from IdentityServer is seen as a client. The word <a id="_idIndexMarker630"/>client can also refer to a program that is attempting to gain authorization, such as a daemon or background service. Another scenario is when a user attempts to carry out an operation that requires them to authenticate against IdentityServer. We add support for our clients as follows:</p>
<pre class="source-code">
public static IEnumerable&lt;Client&gt; Clients =&gt;
            new Client[]
            {
            // m2m client credentials flow client
            new Client
            {
                ClientId = "m2m.client",
                ClientName = "Client Credentials Client",
                AllowedGrantTypes = GrantTypes
                    .ClientCredentials,
                ClientSecrets = { new Secret("511536EF-
                   F270-4058-80CA-1C89C192F69A ".Sha256())
                       },
                AllowedScopes = { "healthcareApiClient" }
            },
            // interactive client using code flow + pkce
            new Client
            {
                ClientId = "interactive",
                ClientSecrets = { new Secret("49C1A7E1-
                  0C79-4A89-A3D6-A37998FB86B0".Sha256()) },
                AllowedGrantTypes = GrantTypes.Code,
                RedirectUris = {
                    "https://localhost:5001/signin-oidc" },
                FrontChannelLogoutUri =
                    "https://localhost:5001/signout-oidc",
                PostLogoutRedirectUris = {
                   "https://localhost:5001/signout-
                      callback-oidc" },
                AllowOfflineAccess = true,
                AllowedScopes = { "openid", "profile",
                    "healthcareApiUser", "roles" }
            },
            };</pre>
<p>Now, we have defined the <code>ClientId</code> and <code>ClientSecret</code> values for our clients. By defining several clients, we can support the applications that we expect to support at a more granular level, and we can define specific <code>AllowedScopes</code> and <code>AllowedGrantTypes</code> values. In this example, we have defined a client for an API, which can represent a microservice in our application that might need to authenticate with the authentication service. This type of authentication generally occurs without user interaction. We also define<a id="_idIndexMarker631"/> a web client, which could be a user-facing application. This presents the unique challenge where we configure sign-in and sign-out URLs to redirect our users during the authentication or logout flow. We also go on to state which scopes will be accessible via the generated token. We have added the <code>roles</code> value to the list of <code>AllowedScopes</code> since we want that information to be included when a user authenticates.</p>
<p>Now that we have our configuration values outlined, let us add a command-line argument for seeding to the <code>launchSettings.json</code> file in the <code>Properties</code> folder. The file’s contents will now look as follows:</p>
<pre class="source-code">
"profiles": {
    "SelfHost": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "applicationUrl": "https://localhost:5001",
      "commandLineArgs": "/seed"
    }</pre>
<p>If we run this application after making this adjustment, the <code>if (args.Contains("/seed"))</code> statement will evaluate to <code>true</code> in <code>Program.cs</code> and this will trigger the database seeding activity as outlined in the <code>SeedData.cs</code> file. After the first run, you may remove the <code>"commandLineArgs": "/seed"</code> section from the <code>launchSettings.json</code> file. Running it again will launch a browser application with a page similar to what is depicted in <em class="italic">Figure 12.4</em>. This is the home landing page and shows that our IdentityServer is up and running.</p>
<p><em class="italic">Figure 12.4</em> shows the<a id="_idIndexMarker632"/> Duende IdentityServer landing page:</p>
<div><div><img alt="Figure 12.4 – This landing page shows us that our IdentityServer application is in a running state" src="img/Figure_12.4_B19100.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – This landing page shows us that our IdentityServer application is in a running state</p>
<p>You can find the <code>TestUsers.cs</code> file in the <code>Pages</code> folder. We will use <code>alice</code> as both the username and password for a quick test. You may proceed to use the credentials that have been provided in your instance of that file. We can then proceed to test a login operation using one of the test users that was added to the context by default, and we will be required to authenticate when attempting to access most of these links.</p>
<p>The most important link to discuss is the one that leads to the discovery document. Most OAuth2.0 and OpenID Connect service providers have a concept of a discovery document, which outlines the built-in routes in the API, supported claims and token types, and other key bits of information that make it easier for us to know and access these intricate bits of information from IdentityServer. Some of the key information available is as follows:</p>
<pre class="source-code">
{
    "issuer": "https://localhost:5001",
    "jwks_uri": "
        https://localhost:5001/.well-known/openid-
        configuration/jwks",
    "authorization_endpoint": "
        https://localhost:5001/
        connect/authorize",
    "token_endpoint": "
        https://localhost:5001/connect/
        token",
    "userinfo_endpoint": "
        https://localhost:5001/connect/
        userinfo",
    "end_session_endpoint": "
        https://localhost:5001/connect
        /endsession",
    "check_session_iframe": "
        https://localhost:5001/connect
        /checksession",
    "revocation_endpoint": "
        https://localhost:5001/connect
       /revocation",
    "introspection_endpoint": "
        https://localhost:5001/
        connect/introspect",
    "device_authorization_endpoint": "
        https://localhost:5001/connect/deviceauthorization",
    "backchannel_authentication_endpoint":
        "https://localhost:5001/connect/ciba",
   ...
    "scopes_supported": [
        "openid",
        "profile",
        "roles",
        "healthcareApiUser",
        "healthcareApiClient",
        "offline_access"
    ],
...
}</pre>
<p>We have a clear outline of the various endpoints that are now available to us for the different commonly access operations.</p>
<p>Next, we can test our <code>HealthCare.Auth</code> application and validate that we can retrieve a valid<a id="_idIndexMarker633"/> token. Let us attempt to retrieve a token using our machine client credentials. We will use an API testing tool called <em class="italic">Postman</em> to send the request. <em class="italic">Figure 12.5</em> shows the user interface in Postman and the information that needs to be added accordingly.</p>
<div><div><img alt="Figure 12.5 – Here, we add the client ID, client secret, and token URL values in Postman in order to retrieve a bearer token" src="img/Figure_12.5_B19100.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Here, we add the client ID, client secret, and token URL values in Postman in order to retrieve a bearer token</p>
<p>Once we have added the required values, we proceed to click on the <strong class="bold">Get New Access Token</strong> button. This will send a request to our IdentityServer, which will validate the request and return a <a id="_idIndexMarker634"/>token if the information is found in the database.</p>
<p>Our token response automatically includes some additional information such as the type of token, the expiry timestamp, and the scope that is included. Our token is generated with several data points by default. Since IdentityServer follows the <em class="italic">OAuth</em> and <em class="italic">OpenID Connect</em> standards, we can be sure that we do not need to include basic claims such as <strong class="bold">sub</strong>, <strong class="bold">exp</strong>, <strong class="bold">jti</strong>, and <strong class="bold">iss</strong>, to name a few.</p>
<p>The values that get included are the scope and client ID. These are determined by the configurations that we have per client and the information that is presented by the authenticating user. In this example, we are accommodating APIs that only authenticated users should be able to access.</p>
<p><em class="italic">Figure 12.6</em> shows the payload of the token:</p>
<div><div><img alt="Figure 12.6 – Our token automatically contains some claims that we would have entered manually if it was generated without IdentityServer" src="img/Figure_12.6_B19100.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Our token automatically contains some claims that we would have entered manually if it was generated without IdentityServer</p>
<p>Let us save our bearer <a id="_idIndexMarker635"/>token value that was returned, as we will use it in our next section. Now let us review the changes that are necessary to protect an API using IdentityServer.</p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor198"/>Securing an API using IdentityServer</h2>
<p>We now have the peculiar <a id="_idIndexMarker636"/>challenge of implementing the best possible security solution across our microservices application. We have several services that need to be secured and based on the architecture pattern you have implemented, you might also have a gateway that is routing traffic:</p>
<ul>
<li><strong class="bold">Securing each service</strong>: Securing each service seems simple enough, but we must bear in mind that each service has different requirements and might need to be seen as a different client for each request. This can lead to a maintenance nightmare when trying to maintain all the scopes and clients, relative to each service. We then need to navigate how services will communicate as well since a token will be needed for service-to-service calls. One service’s claims and scopes might not be sufficient for<a id="_idIndexMarker637"/> this communication. This might lead to a user having to authenticate several times when accessing different features that rely on different services.</li>
<li><strong class="bold">Secured API gateway</strong>: Securing our API gateway makes the most sense. If we implement a gateway that all apps will communicate with, we allow the gateway to orchestrate the authentication flow for the client and then manage the token to be shared between service calls. This support can be implemented in a custom-written API gateway and is supported by most if not all third-party gateway service providers. This is especially useful when combined with the <em class="italic">Backend For Frontend</em> pattern.</li>
</ul>
<p>We have already seen how we can add JWT bearer protection to our API using functionality from the <code>Identity Core</code> library. We can leverage some of these configurations and override the native functionality with support for IdentityServer. Let us explore how we can secure our <code>Patients</code> API using IdentityServer. We start by adding the <code>Microsoft.AspNetCore.Authentication.JwtBearer</code> library using the NuGet package manager:</p>
<pre class="source-code">
Install-Package Microsoft.AspNetCore.Authentication
  .JwtBearer</pre>
<p>We then modify the <code>Program.cs</code> file and add the following configuration:</p>
<pre class="source-code">
builder.Services.AddAuthentication(JwtBearerDefaults
     .AuthenticationScheme)
            .AddJwtBearer(options =&gt;
            {
                // base-address of your identityserver
                options.Authority =
                    "https://localhost:5001/";
                // audience is optional, make sure you read
                   the following paragraphs
                // to understand your options
                options.TokenValidationParameters
                    .ValidateAudience = false;
                // it's recommended to check the type
                header to avoid "JWT confusion" attacks
                options.TokenValidationParameters
                    .ValidTypes = new[] { "at+jwt" };
            });</pre>
<p>We will also need to register the authentication middleware in our application with the following line. We should <a id="_idIndexMarker638"/>ensure that we place this registration above the authorization middleware:</p>
<pre class="source-code">
app.UseAuthentication();
app.UseAuthorization();</pre>
<p>This configuration will dictate to our service that we are now to refer them to the URL in the <em class="italic">Authority</em> option, for authentication instructions. We can now protect our API by implementing a global authorization policy. This will ensure that no endpoint can be accessed without a valid bearer token that has been issued by our IdentityServer:</p>
<pre class="source-code">
builder.Services.AddAuthorization(options =&gt;
{
    options.AddPolicy("RequireAuth", policy =&gt;
    {
        policy.RequireAuthenticatedUser();
    });
});</pre>
<p>We modify the controller’s middleware as follows:</p>
<pre class="source-code">
app.MapControllers().RequireAuthorization("RequireAuth");</pre>
<p>Now, any attempt to interact with our <code>Patients</code> API endpoint will return a <code>401Unauthorized</code> HTTP response. The API is now expecting us to provide the bearer token in the authorization header value. In <em class="italic">Figure 12.7</em>, we see how we can make authorized API calls to our <code>Patients</code> API endpoints using the bearer token that was retrieved in the previous <a id="_idIndexMarker639"/>section from our machine client credentials authentication.</p>
<p><em class="italic">Figure 12.7</em> shows the authorized API request:</p>
<div><div><img alt="Figure 12.7 – Our bearer token is included in the request to our protected service and we can comfortably access endpoints" src="img/Figure_12.7_B19100.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Our bearer token is included in the request to our protected service and we can comfortably access endpoints</p>
<p>Now, we need to configure our API to force authentication and rely on the <em class="italic">HealthCare.Auth</em> service accordingly. If we reuse our appointments API, we can make a few modifications to the <code>Program.cs</code> file and introduce reliance on our authentication service.</p>
<p>We begin by modifying the <code>builder.Services.AddAuthenctication()</code> registration as<a id="_idIndexMarker640"/> follows:</p>
<pre class="source-code">
builder.Services.AddAuthentication(JwtBearerDefaults
    .AuthenticationScheme)
   .AddJwtBearer("Bearer", opt =&gt;
   {
       opt.RequireHttpsMetadata = false;</pre>
<p>Now that we have secured our API directly, we can explore how we can manage this new security requirement in our API gateway. Recall that we have implemented aggregation methods and we will expect client applications to access the endpoints through the gateway.</p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor199"/>Securing the Ocelot API gateway with IdentityServer</h2>
<p>Now, when we access an <a id="_idIndexMarker641"/>API endpoint that is protected via IdentityServer, we need to retrofit our gateway service to support authentication <a id="_idIndexMarker642"/>and forwarding of the credentials to the target API. We start by adding the <code>Microsoft.AspNetCore.Authentication.JwtBearer</code> library using the NuGet package manager:</p>
<pre class="source-code">
Install-Package Microsoft.AspNetCore.Authentication
  .JwtBearer</pre>
<p>We then modify the <code>ocelot.json</code> file with an <code>AuthenticationOptions</code> section. Now, our <code>GET</code> method for the <code>Patients</code> API is as follows:</p>
<pre class="source-code">
{
  "DownstreamPathTemplate": "/api/Patients",
  ...
  "AuthenticationOptions": {
        "AuthenticationProviderKey":
            "IdentityServerApiKey",
        "AllowedScopes": []
      },
…
},</pre>
<p>Now, we modify our <code>Program.cs</code> file and register our authentication service to use JWT bearer <a id="_idIndexMarker643"/>authentication, similar to what we did on <a id="_idIndexMarker644"/>the service itself:</p>
<pre class="source-code">
builder.Services
    .AddAuthentication()
    .AddJwtBearer(authenticationProviderKey, x =&gt;
    {
        x.Authority = "https://localhost:5001";
        x.TokenValidationParameters = new
            TokenValidationParameters
        {
            ValidateAudience = false
        };
    });</pre>
<p>Now, we have secured our gateway using IdentityServer. This, once again, might be a better security solution for our suite of microservices that will be accessed through the gateway, and it can help us to centralize access to our services.</p>
<p>Now that we have explored API security at length, let us summarize the concepts that we have explored.</p>
<p>With this simple change, we no longer need to concern our appointments API with the inclusion of authentication tables in its database, or complex JWT bearer compilation logic. We simply point the service to our <code>Authority</code>, which is the authentication service, and include the <code>Audience</code> value so that it can identify itself to the authentication service.</p>
<p>With this configuration, a user will need to provide a token such as the one we retrieved to make any calls to our <a id="_idIndexMarker645"/>API. Any other token or lack thereof will be met with a <em class="italic">401 Unauthorized</em> HTTP response.</p>
<p>Configuring IdentityServer is not the most difficult task, but it can become complex when attempting to account for several scenarios, configurations, and clients. Several considerations can be made <a id="_idIndexMarker646"/>along the way, and we will discuss them next.</p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor200"/>Additional API security considerations</h2>
<p>We have configured an<a id="_idIndexMarker647"/> authentication service to secure our microservices application. Several scenarios can govern how each service is protected by this central authority and they all have their pros and cons.</p>
<p>What we also need to consider is that we want the entire responsibility of hosting and maintaining our own <em class="italic">OAuth</em> service. There are third-party services such as <strong class="bold">Auth0</strong>, <strong class="bold">Azure Active Directory</strong>, and <strong class="bold">Okta</strong>, to name a few. They all <a id="_idIndexMarker648"/>provide a hosted service that will abstract our<a id="_idIndexMarker649"/> need to stage and maintain our services, and we can simply subscribe to their services and secure our application with a few configurations.</p>
<p>This option takes advantage of <strong class="bold">Software-as-a-Service</strong> (<strong class="bold">SaaS</strong>) offerings that greatly reduce our infrastructure needs and increase the reliability, stability, and future-proofing of our application’s security.</p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor201"/>Summary</h1>
<p>In this chapter, we have reviewed the current industry standard for API security. Using bearer tokens, we can support authorized API access attempts without maintaining state or sessions.</p>
<p>In a service-oriented architecture, a client app can come in several forms, whether a web application, a mobile application, or even a smart television. We cannot account for the type of device in use and our API does not keep track of the applications connecting to it. For this reason, when a user logs in and is verified against our user information data stores, we select the most important bit of information and compile them into a token.</p>
<p>This token is called a bearer token and is an encoded string that should contain enough information about a user that our API can determine the user with whom the token is associated and their privileges in our system.</p>
<p>Ultimately, attempting to secure each API using this method can lead to a lot of disconnection and complexity, so we introduce a centralized authentication management platform such as IdentityServer. This central authority will secure all the APIs using common configurations, and issue tokens based on those global configurations. Now, we can use these tokens once and access several services without needing to re-authenticate.</p>
<p>Security should never be neglected in any application and when it is well implemented, we can strike a balance between security and usability in our application.</p>
<p>Now that we have explored security for our microservices application, we will review how we can leverage <em class="italic">containers</em> to deploy our microservices application in the next chapter.</p>
</div>
</body></html>