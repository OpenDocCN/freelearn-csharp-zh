<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-99"><a id="_idTextAnchor098"/>6</h1>
<h1 id="_idParaDest-100"><a id="_idTextAnchor099"/>Tracing Your Code</h1>
<p>In the previous chapters, we talked about instrumentation libraries and learned how to use auto-collected telemetry to monitor and debug distributed systems. Auto-instrumentations, when available, provide necessary and reasonable coverage for network calls, but you may want to trace additional logical operations, I/Os, sockets, or other calls that don’t have shared instrumentation available.</p>
<p>This chapter provides an in-depth guide to manual tracing using the <code>System.Diagnostics</code> primitives or the OpenTelemetry API and explains the mechanism behind auto-instrumentation. We will cover the <code>Activity</code> properties and how to populate them and show you how to record events. We’ll then learn how to use links to represent complex relationships between spans. Finally, we’ll cover the testing aspects of instrumentation.</p>
<p>You’ll learn how to do the following:</p>
<ul>
<li>Create activities using the .NET API or with the OpenTelemetry API shim</li>
<li>Use ambient context propagation with <code>Activity.Current</code> and understand its limitations</li>
<li>Use <code>ActivityEvent</code> and understand when to use logs instead</li>
<li>Represent complex relationships between traces with links</li>
<li>Validate your instrumentations</li>
</ul>
<p>By the end of this chapter, you should be able to cover your application needs with manual tracing.</p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor100"/>Technical requirements</h1>
<p>The code for this chapter can be found in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter6">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter6</a>.</p>
<p>We’ll need the following tools for it:</p>
<ul>
<li>NET SDK 7.0 or newer</li>
<li>Visual Studio or Visual Studio Code with C# development setup is recommended, but any text editor will work</li>
<li>Docker</li>
</ul>
<p>If you want to explore traces from sample applications in Jaeger, you can run it with the following command:</p>
<pre class="console">
$ docker run -d --name jaeger -p 6831:6831/udp -p
  16686:16686 jaegertracing/all-in-one:latest</pre>
<h1 id="_idParaDest-102"><a id="_idTextAnchor101"/>Tracing with System.Diagnostics or the OpenTelemetry API shim</h1>
<p>As we saw in the previous<a id="_idIndexMarker345"/> chapters, distributed tracing in .NET<a id="_idIndexMarker346"/> relies on primitives in the <code>System.Diagnostics</code> namespace: <code>Activity</code> and <code>ActivitySource</code>. They’re used by HTTP Client and ASP.NET Core instrumentations.</p>
<p>The terminology used by .NET and OpenTelemetry is different: <code>Activity</code> represents the OpenTelemetry span, <code>ActivitySource</code> maps to the tracer, and tags map to attributes.</p>
<p>The <code>OpenTelemetry.Api</code> NuGet package also provides <code>TelemetrySpan</code>, <code>Tracer</code>, and several more auxiliary classes in the <code>OpenTelemetry.Trace</code> namespace. These APIs are a <strong class="bold">shim</strong> over .NET tracing APIs – a thin wrapper that does not provide any additional functionality on top of .NET tracing APIs.</p>
<p>You are probably wondering which one you should use. The rule of thumb is to use .NET APIs unless you want to stick to OpenTelemetry terminology. Shim<a id="_idIndexMarker347"/> is just an additional layer, which brings<a id="_idIndexMarker348"/> a small performance overhead.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>Tracing with System.Diagnostics</h2>
<p>Let’s say we want to instrument<a id="_idIndexMarker349"/> an operation – for example, a method that processes a work item. It might break down into smaller, potentially auto-instrumented operations such as HTTP requests. In this case, spans describing individual requests won’t show us the overall duration and result of processing, so we need to create a new logical <code>Activity</code> to describe it.</p>
<p>Activities<a id="_idIndexMarker350"/> should be created from <code>ActivitySource</code>, which notifies OpenTelemetry and other potential listeners about them. Using this approach, we can instrument our work processing operation with the following code:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Worker.cs</p>
<pre class="source-code">
private static readonly ActivitySource Source =
  new ("Worker");
...
using var activity = Source.StartActivity("DoWork");
activity?.SetTag("work_item.id", workItemId);
try
{
  await DoWorkImpl(workItemId);
}
catch (Exception ex)
{
  activity?.SetStatus(ActivityStatusCode.Error,
    ex.Message);
  throw;
}</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/Worker.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/Worker.cs</a></p>
<p>In this example, the actual processing happens in the <code>DoWorkImpl</code> method. We created a new activity before calling into this method and implicitly ended it. If the method throws an exception, we set the status of the activity to <code>Error</code> while providing an exception message in the description. The activity is disposed of (and ended) when control leaves the scope, but we could also call the <code>Activity.Stop</code> method to stop it explicitly.</p>
<p>We created <code>ActivitySource</code> as a static singleton here since we’re assuming we need it for the application’s lifetime. If you decide to make it an instance variable and tie its lifetime to some long-living client or service in your application, make sure to dispose of it.</p>
<p>The only thing we configured<a id="_idIndexMarker351"/> in this example is the <code>Activity</code> name – we passed <code>DoWork</code> to the <code>ActivitySource.StartActivity</code> method.</p>
<p class="callout-heading">Note</p>
<p class="callout">The activity returned by <code>ActivitySource.StartActivity</code> is nullable. It can be null if there are no listeners for this source, or if the listener sampled out this activity in a specific way by returning <code>ActivitySamplingResult.None</code>.</p>
<p>We’ll learn more about APIs in a moment, but first, let’s learn how to export generated activities.</p>
<h3>Exporting activities with OpenTelemetry</h3>
<p>So far, we have<a id="_idIndexMarker352"/> used the <code>OpenTelemetry.Extensions.Hosting</code> NuGet package<a id="_idIndexMarker353"/> to configure OpenTelemetry in ASP.NET Core applications. Here, we’re going to use plain OpenTelemetry SDK configuration, which still looks quite similar to what we saw in <a href="B19423_05.xhtml#_idTextAnchor083"><em class="italic">Chapter 5</em></a>, <em class="italic">Configuration and </em><em class="italic">Control Plane</em>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Program.cs</p>
<pre class="source-code">
using var provider = Sdk.CreateTracerProviderBuilder()
  .ConfigureResource(b =&gt; b.AddService("activity-sample"))
<strong class="bold">  .AddSource("Worker")</strong>
  .AddJaegerExporter()
  .AddConsoleExporter()
  .Build()!;</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/Program.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/Program.cs</a></p>
<p>In this example, we’re building the <code>TracerProvider</code> instance by setting the service name to <code>activity-sample</code> and enabling <code>ActivitySource</code> with <code>Worker</code> – the one we used to create the activity in the previous example. We are also using the console exporter along with Jaeger – spans will be exported to both.</p>
<p>OpenTelemetry needs<a id="_idIndexMarker354"/> explicit configuration<a id="_idIndexMarker355"/> to listen to <code>ActivitySource</code>, but you can enable a group of them with wildcards, as we saw in <a href="B19423_03.xhtml#_idTextAnchor052"><em class="italic">Chapter 3</em></a>,<em class="italic"> The .NET </em><em class="italic">Observability Ecosystem</em>.</p>
<p>Let’s run these examples using the following command:</p>
<pre class="console">
tracing-with-net$ dotnet run open-telemetry –scenario basic</pre>
<p>We should see <code>Activity</code> exported to the console:</p>
<pre class="source-code">
<strong class="bold">Activity.TraceId:         9c45e1b454e28bf1edbba296c3315c51</strong>
<strong class="bold">Activity.SpanId:          bcd47a4fc7d92063</strong>
<strong class="bold">Activity.TraceFlags:         Recorded</strong>
<strong class="bold">Activity.ActivitySourceName: Worker</strong>
<strong class="bold">Activity.DisplayName:        </strong><strong class="bold">DoWork</strong>
<strong class="bold">Activity.Kind:               Internal</strong>
<strong class="bold">Activity.StartTime:          2022-12-07T23:10:49.1998081Z</strong>
<strong class="bold">Activity.Duration:           00:00:00.1163745</strong>
<strong class="bold">Resource associated with Activity:</strong>
<strong class="bold">    service.name: activity-sample</strong></pre>
<p>When we configure OpenTelemetry to listen to the <code>Worker</code> source, it leverages the <code>System.Diagnostics.ActivityListener</code> primitive. If you use OpenTelemetry, you probably<a id="_idIndexMarker356"/> won’t need to use the listener<a id="_idIndexMarker357"/> directly, but you may still find it useful for testing purposes or when debugging instrumentation issues. Let’s see how it works.</p>
<h3>Listening to activities with ActivityListener</h3>
<p><code>ActivityListener</code> allows us to subscribe<a id="_idIndexMarker358"/> to any <code>ActivitySource</code> instance using its name and get notifications when activities created by one of the enabled sources start or end. The following example shows how to write a listener:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Program.cs</p>
<pre class="source-code">
ActivitySource.AddActivityListener(new ActivityListener()
{
  ActivityStopped = PrintActivity
  ShouldListenTo = source =&gt; source.Name == "Worker",
  Sample = (ref ActivityCreationOptions&lt;ActivityContext&gt; _)
    =&gt; ActivitySamplingResult.AllDataAndRecorded
});</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/Program.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/Program.cs</a></p>
<p>Here, we’re subscribing to <code>ActivitySource</code> with <code>Worker</code> and specifying that we sample in all activities. When <code>Activity</code> ends, we call our <code>PrintActivity</code> method. We could also provide the <code>ActivityStarted</code> callback when needed.</p>
<p>So, let’s go ahead and run this sample with this command:</p>
<pre class="console">
tracing-with-net$ dotnet run activity-listener</pre>
<p>You should<a id="_idIndexMarker359"/> see something like this:</p>
<pre class="source-code">
<strong class="bold">DoWork: Id = 00-7720a4aca8472f92c36079b0bee3afd9-</strong>
<strong class="bold">0d0c62b5cfb15876-01, Duration=110.3466, Status = Unset</strong></pre>
<p>Now that you know how OpenTelemetry and <code>ActivitySource</code> work together, it’s time to explore other tracing APIs.</p>
<h3>Starting activities</h3>
<p>The <code>ActivitySource</code> class<a id="_idIndexMarker360"/> defines<a id="_idIndexMarker361"/> several <code>CreateActivity</code> and <code>StartActivity</code> method<a id="_idIndexMarker362"/> overloads.</p>
<p>Calling into <code>StartActivity</code> is equivalent to calling <code>CreateActivity</code> and then starting it later with the <code>Activity.Start</code> method:</p>
<pre class="source-code">
Source.CreateActivity("foo", ActivityKind.Client)?.Start()</pre>
<p>The <code>Start</code> methods generate a new span ID, capture the start time, and populate the ambient context via the <code>Activity.Current</code> property. <code>Activity</code> can’t be used until it’s started. So, in most cases, the <code>StartActivity</code> method is the easiest choice and <code>CreateActivity</code> might only be useful if you want to construct an activity instance but start it later.</p>
<p class="callout-heading">Note</p>
<p class="callout">Sampling callback happens during activity creation, so you must pass all properties that affect the sampling decision to the <code>StartActivity</code> or <code>CreateActivity</code> method.</p>
<p>Here are the start time properties:</p>
<ul>
<li><code>Internal</code>, indicating local or logical operation. <code>Client</code> and <code>Server</code> spans describe the client and server side of synchronous remote calls such as HTTP requests. Similarly, the <code>Producer</code> and <code>Consumer</code> spans describe corresponding sides of asynchronous operations, such as asynchronous messaging.</li>
</ul>
<p>Observability backends rely on span kinds for visualizations such as service maps and semi-automated performance analysis.</p>
<ul>
<li><code>ActivityContext</code> struct. This is usually based on the W3C Trace Context standard for HTTP and might be different for other protocols. <code>ActivityContext</code> contains the trace ID, span ID, trace flags, and trace state.</li>
</ul>
<p>Another option is to pass the <code>traceparent</code> value in W3C Trace Context format to the <code>StartActivity</code> method as a string. You can set <code>tracestate</code> later after the activity starts, but then, of course, you won’t be able to use it to make sampling decisions.</p>
<p>If the parent context is not provided, <code>Activity.Current</code> is used.</p>
<ul>
<li><code>Activity</code> starts and should affect sampling decisions. If you don’t use attributes to make head-based sampling decisions, it’s best not to populate them and minimize the performance overhead for sampled-out activities.</li>
<li><strong class="bold">Links</strong>: Links can correlate different traces<a id="_idIndexMarker366"/> and represent relationships between spans other than parent-child ones. We’ll learn more about them later in this chapter.</li>
<li><code>Activity</code> starts.</li>
</ul>
<p><code>Activity</code> also supports custom trace context formats – for example, legacy hierarchical ones.</p>
<p>After <code>Activity</code> starts, we can always add more attributes, change the start and end times, update the sampling decision, set <code>tracestate</code>, and record events.</p>
<p>Before adding new events or attribute, make sure to check the <code>IsAllDataRequested</code> flag, which specifies whether the activity has been sampled. We can use it to minimize the performance impact of the instrumentation by guarding any expensive operations:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">StartSamples.cs</p>
<pre class="source-code">
if (activity?.IsAllDataRequested == true)
    activity?.SetTag("foo", GetValue());</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/StartSamples.cs</p>
<p>The <code>Activity</code> and <code>ActivitySource</code> APIs are the foundation<a id="_idIndexMarker368"/> for any instrumentation. We’ll cover additional APIs allowing to populate events and links later in this chapter and see more examples throughout the rest of this book. For now, let’s take a quick look at how we can use the OpenTelemetry API shim.</p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor103"/>Tracing with the OpenTelemetry API shim</h2>
<p>The OpenTelemetry API shim<a id="_idIndexMarker369"/> does not provide any additional features on top of .NET APIs; it only aligns terminology with OpenTelemetry. If you use OpenTelemetry in other languages, then it might be more appealing to you. If you decide to go down this path, keep in mind that the behavior of <code>Tracer</code> and <code>Span</code> matches <code>ActivitySource</code> and <code>Activity</code>. For example, this means that you still have to enable each tracer when configuring OpenTelemetry.</p>
<p>Let’s repeat our processing instrumentation using the <code>Tracer</code> and <code>TelemetrySpan</code> classes:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Worker.cs</p>
<pre class="source-code">
private static readonly Tracer Tracer = TracerProvider
  .Default.GetTracer("Worker");
...
using var workSpan = Tracer.StartActiveSpan("DoWork"));
  workSpan.SetAttribute("work_item.id", workItemId);
  try
  {
    await DoWorkImpl(workItemId);
  }
  catch (Exception ex)
  {
    workSpan.SetStatus(Status.Error.WithDescription(
      ex.Message));
    throw;
  }
}</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-shim/Worker.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-shim/Worker.cs</a></p>
<p>The overall flow is the same: we create<a id="_idIndexMarker370"/> an instance of <code>Tracer</code> instead of <code>ActivitySource</code>, then use it to create a span. Adding attributes and setting the status is done similarly to the <code>ActivitySource</code> example.</p>
<p>If we were to look under the hood of <code>Tracer</code> and <code>TelemetrySpan</code>, we’d see that they fully rely on <code>ActivitySource</code> and <code>Activity</code>. As a result, enabling this instrumentation and enriching and customizing it is the same as enabling an <code>ActivitySource</code>-based one – it’s done by using the <code>AddSource</code> method on <code>TracerProviderBuilder</code> (the source name matches the tracer name).</p>
<p>Even though the APIs look similar, there are a few important differences:</p>
<ul>
<li>Spans are not nullable. You always get an instance of a span, even if there is no listener to the underlying <code>ActivitySource</code> (but then it’s an optimized, inoperative instance).</li>
<li>All operations on spans are internally guarded with the <code>TelemetrySpan.IsRecording</code> flag, which is equivalent to the <code>activity?.IsAllDataRequested == true</code> check. However, it could still be useful to guard expensive operations to calculate attribute values and other span properties behind the <code>IsRecording</code> flag.</li>
<li>Spans are not active (that is, current) by default. While you can’t start an activity without making it current, that’s not the case for <code>TelemetrySpan</code>. You probably noticed that we used the <code>Tracer.StartActiveSpan</code> method for the <code>DoWork</code> span, which populates <code>Activity.Current</code>.</li>
</ul>
<p>If we were to use the <code>Tracer.StartSpan</code> method, we’d get a started activity, but <code>Activity.Current</code> would not point to it. To make it current, we could call into the <code>Tracer.WithSpan</code> method.</p>
<p>If we run the previous OpenTelemetry API example with the <code>tracing-with-otel-api$ dotnet run</code> command, we’ll see the same trace<a id="_idIndexMarker371"/> as before with plain .NET tracing APIs.</p>
<p>Now, let’s see how we can create hierarchies of activities and enrich them using ambient context.</p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor104"/>Using ambient context</h1>
<p>In complex applications, we usually have multiple layers<a id="_idIndexMarker372"/> of spans in each trace. These spans are emitted by different libraries that are not aware of each other. Still, they are correlated because of the ambient context propagated in the <code>Activity.Current</code> property.</p>
<p>Let’s create two layers of activities – we’ll make processing more resilient by retrying failed operations and instrumenting tries and the logical <code>DoWork</code> operation:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Worker.cs</p>
<pre class="source-code">
public static async Task DoWork(int workItemId) {
  using var workActivity = Source.StartActivity();
  workActivity?.AddTag("work_item.id",  workItemId);
  await DoWithRetry(async tryCount =&gt; {
    using var tryActivity = Source.StartActivity("Try");
    try
    {
      await DoWorkImpl(work.Id, tryCount);
      tryActivity?.SetTag("try_count", tryCount);
    }
    catch (Exception ex)
    {
      tryActivity?.RecordException(ex);
      tryActivity?.SetStatus(ActivityStatusCode.Error);
      throw;
    }
  }
}</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/Worker.cs</p>
<p>In this example, we have <code>workActivity</code>, which describes the logical<a id="_idIndexMarker373"/> operation, and <code>tryActivity</code>, which describes a try. Let’s run it with the following command:</p>
<pre class="console">
tracing-with-net$ dotnet run open-telemetry –scenario with-
retries</pre>
<p>Check out the trace in Jaeger at <code>http://localhost:16686</code>. You should see something similar to the trace shown in <em class="italic">Figure 6</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 6.1 – Work item processing" src="img/B19423_06_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Work item processing</p>
<p>Here, we can see that there were two attempts<a id="_idIndexMarker374"/> to process a work item – the first one failed with an exception and then the operation succeeded after the second try. By looking at this trace, it’s clear why the <code>DoWork</code> operation took this much time – it was spent between tries.</p>
<p>Note that we didn’t do anything special to correlate <code>workActivity</code> and <code>tryActivity</code>. This happened because <code>workActivity</code> was current when <code>tryActivity</code> started – since we didn’t provide any parent, it defaulted to the <code>Activity.Current</code> instance.</p>
<p>To troubleshoot instrumentation issues, we can always check the parent of <code>Activity</code> on the started activity by looking at its properties. <code>Activity.Parent</code> represents an implicit parent. When we start an activity, we can also provide <code>traceparent</code> as a string or a parent <code>ActivityContext</code> explicitly – in these cases, the <code>Parent</code> property will be null. You can find some examples of this at <a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/StartSamples.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/tracing-with-net/StartSamples.cs</a> and we’ll see more examples of context propagation in <a href="B19423_10.xhtml#_idTextAnchor161"><em class="italic">Chapter 10</em></a>, Tracing <em class="italic">Network Calls</em>. <code>Activity.ParentId</code> is the equivalent of the <code>traceparent</code> header and <code>Activity.ParentSpanId</code> represents the <code>span-id</code> portion of it. These properties are populated if <code>Activity</code> has any parent at all.</p>
<p>Getting back to our example, what happens if all the tries fail? Should we set an error on the <code>DoWork</code> activity? Well, we can do this inside the <code>DoWithRetry</code> method with <code>Activity.Current?.SetStatus(ActivityStatusCode.Error)</code>. We can use the current activity here because we control when and how the <code>DoWithRetry</code> method is called.</p>
<p>As a rule of thumb, avoid adding attributes, events, or setting a status on <code>Activity.Current</code> unless you know for sure it’s the right one. With suppression, filtering, or some new activities created in between, <code>Current</code> can point to some other activity. So, make sure to pass instances of activities within your instrumentations explicitly.</p>
<p>If you want to enrich an auto-collected <code>Activity</code>, accessing the <code>Current</code> property in one of the enrichment callbacks provided when enabling instrumentation should be safe.</p>
<p>Some instrumentations may also provide access to the created <code>Activity</code>. For example, ASP.NET Core does so with the <code>IHttpActivityFeature</code> interface. It’s also possible to walk up the activity tree using the <code>Parent</code> property to find the one you want to enrich. </p>
<p><code>Activity.Current</code> works on top of <code>AsyncLocal</code>, so the .NET runtime propagates it through asynchronous calls. This does not work with background<a id="_idIndexMarker375"/> processing or manual manipulations with threads, but you can always pass activities explicitly and set the <code>Activity.Current</code> value manually as needed.</p>
<p>Now, we know how to create hierarchies of activities and use attributes to describe our scenarios. But sometimes, we need something more lightweight, such as events – let’s take a closer look at them.</p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/>Recording events</h1>
<p>Spans<a id="_idIndexMarker376"/> describe operations<a id="_idIndexMarker377"/> that have a duration and a result, but sometimes, creating a span could be too verbose and expensive – for example, for busy socket-level communication. Common use cases for events include recording exceptions or individual messages in gRPC streaming calls.</p>
<p>To represent something that happened at a certain point in time, we should use events or logs. In OpenTelemetry, the difference between logs and events is semantical – it’s the same data structure with the same over-the-wire format but different attributes. For example, logs have mandatory severity, which does not apply to events. Events, on the other hand, have mandatory names.</p>
<p>They are also different in terms of their API and implementation (at least with .NET 7.0 and prior versions). In this section, we will explore Activity’s events API; we will look at logs in <a href="B19423_08.xhtml#_idTextAnchor131"><em class="italic">Chapter 8</em></a>, <em class="italic">Writing Structured and </em><em class="italic">Correlated Logs</em>.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>When to use events</h2>
<p>To create an activity event, we need an instance<a id="_idIndexMarker378"/> of an activity, which is not the case, for example, at startup time.</p>
<p>Activity events depend on sampling – we can add them to a sampled-out <code>Activity</code>, but in general, they’ll be dropped along with it.</p>
<p>An event’s lifetime is tightly coupled with the <code>Activity</code> instance, so it’ll stay in memory until it’s garbage-collected. There is no limit regarding how many events you can have on the .NET side, but OpenTelemetry exporters limit the number of exported events. It is set to 128 by default and can be controlled with the <code>OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT</code> environment variable.</p>
<p class="callout-heading">Note</p>
<p class="callout">Activity events should be used to express operations that don’t deserve a span, don’t have a duration or are too short, and have a predictable outcome. Events must happen in the scope of some <code>Activity</code> and should only be exported if <code>Activity</code> is sampled in. There should also be a reasonable number of them under a single <code>Activity</code> instance. Given these limitations, logs are usually a better choice, as long as your observability backend supports them.</p>
<p>Now that we know these limitations, we’re finally ready to play with events.</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/>The ActivityEvent API</h2>
<p>An event<a id="_idIndexMarker379"/> is represented with the <code>ActivityEvent</code> class. To create one, we must provide<a id="_idIndexMarker380"/> an event name, and can optionally specify a timestamp (that defaults to the time the event was constructed), as well as a collection of attributes.</p>
<p>The event’s name is a low-cardinality string that implies the event’s structure: events with the same name are expected to describe occurrences of the same thing and should use the same set of attributes.</p>
<p>Let’s enrich HTTP client instrumentation with events. Imagine that we have read a long stream over HTTP and want to control content buffering.</p>
<p>To achieve this, we can pass the <code>HttpCompletionOption.ResponseHeadersRead</code> flag to the <code>HttpClient.SendAsync</code> method. The HTTP client will then return a response before reading the response body. It’s useful to know the point in time when we got the response so that we know how long it took to read a response.</p>
<p>The following example demonstrates this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Worker.cs</p>
<pre class="source-code">
public static async Task DoWork(int workItemId) {
  using var work = Source.StartActivity();
  try
  {
    work?.AddTag("work_item.id", workItemId);
    var res = await Client.GetAsync(
      "https://www.bing.com/search?q=tracing",
      HttpCompletionOption.ResponseHeadersRead);
    res.EnsureSuccessStatusCode();
    <strong class="bold">work?.AddEvent(</strong>
<strong class="bold">      new ActivityEvent("received_response_headers"));</strong>
    ...
  }
  catch (Exception ex)
  {
    work?.SetStatus(ActivityStatusCode.Error,
      ex.Message);
  }
}</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/events/Worker.cs</p>
<p>In this example, we start <code>Activity</code> to track overall logical request processing through the HTTP client pipeline and then record the <code>response_headers</code> event. This event does not have any attributes – its sole purpose is to record the timestamp when we got a response from the server.</p>
<p>Let’s add more events! Assuming<a id="_idIndexMarker381"/> we use throttling or circuit-breaking<a id="_idIndexMarker382"/> in our HTTP pipeline, we won’t have any physical HTTP requests and no spans reported by auto-instrumentation. Events can provide observability into it.</p>
<p>We’ll implement client-side throttling using the <code>RateLimiter</code> class, which is available in .NET 7 and included in the <code>System.Threading.RateLimiting</code> NuGet package. We’ll do so in the <code>DelegatingHandler</code> class, as shown in this example:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">RateLimitingHandler.cs</p>
<pre class="source-code">
private readonly TokenBucketRateLimiter _rateLimiter =
  new (Options);
protected override async Task&lt;HttpResponseMessage&gt;
  SendAsync(HttpRequestMessage req, CancellationToken ct)
{
  using var lease = _rateLimiter.AttemptAcquire();
  if (lease.IsAcquired)
    return await base.SendAsync(req, ct);
  return Throttle(lease);
}</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/events/RateLimitingHandler.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/events/RateLimitingHandler.cs</a></p>
<p>Here, we are trying to acquire a lease<a id="_idIndexMarker383"/> from the rate limiter. If it’s successfully<a id="_idIndexMarker384"/> acquired, we call into the <code>base.SendAsync</code> method, letting this request process further. Otherwise, we must throttle the request, as demonstrated in the following code snippet:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">RateLimitingHandler.cs</p>
<pre class="source-code">
private HttpResponseMessage Throttle(RateLimitLease lease)
{
  var res = new HttpResponseMessage(
    HttpStatusCode.TooManyRequests);
  if (lease.TryGetMetadata(MetadataName.RetryAfter,
    out var retryAfter))
  {
    var work = Activity.Current;
<strong class="bold">    if (work?.IsAllDataRequested == true)</strong>
<strong class="bold">    {</strong>
<strong class="bold">      var tags = new ActivityTagsCollection();</strong>
<strong class="bold">      </strong><strong class="bold">tags.Add("exception.type", "rate_is_limited");</strong>
<strong class="bold">      tags.Add("retry_after_ms",</strong>
<strong class="bold">        retryAfter.TotalMilliseconds);</strong>
<strong class="bold">      work?.AddEvent(new ActivityEvent("exception",</strong>
<strong class="bold">        tags: tags));</strong>
<strong class="bold">    }</strong>
    res.Headers.Add("Retry-After",
      ((int)retryAfter.TotalSeconds).ToString());
  }
  return res;
}</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/events/RateLimitingHandler.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/events/RateLimitingHandler.cs</a></p>
<p>In the <code>Throttle</code> method, we emit the <code>exception</code> event and provide<a id="_idIndexMarker385"/> a message alongside the <code>retry_after</code> attribute. We got a value of this attribute<a id="_idIndexMarker386"/> from the rate limiter; it provides a hint regarding when it will make sense to retry this request.</p>
<p>The example in the <code>events</code> folder demonstrates a full rate-limiting solution – it configures the rate limiter to allow one request every 5 seconds but sends two requests in parallel so that the first one comes through and the second one is throttled.</p>
<p>Go ahead and run the sample with <code>events$ dotnet run</code> and then switch to Jaeger to see two traces from the <code>events-sample</code> service.</p>
<p>One trace has two spans and represents a successful operation, as shown in <em class="italic">Figure 6</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 6.2 – A trace with logical and physical HTTP spans and the response_headers event" src="img/B19423_06_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – A trace with logical and physical HTTP spans and the response_headers event</p>
<p>Here, we can see that the time to first byte was around 110 milliseconds. Then, we got the <code>response_headers</code> event; the rest of the logical <code>DoWork</code> operation was spent on reading stream contents.</p>
<p>The other trace has just one span and represents a failed operation; it’s shown in <em class="italic">Figure 6</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 6.3 – A trace with a logical call and the rate_is_limited exception event" src="img/B19423_06_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – A trace with a logical call and the rate_is_limited exception event</p>
<p>Here, we can see a logical <code>DoWork</code> span, which ended with an error. If we expand the attributes, we’ll see a status description stating <code>Response status code does not indicate success: 429 (Too Many Requests)</code>. This could give us an idea of what happened, even if we didn’t have an event. There is no physical HTTP span here and it could be confusing and unclear where the response came from.</p>
<p>With the <code>rate_is_limited</code> event, we<a id="_idIndexMarker387"/> can populate<a id="_idIndexMarker388"/> additional attributes such as <code>retry_after_ms</code>, but most importantly, we can easily understand the root cause of the problem and find the place in our code where the event is sent from.</p>
<h3>Recording exceptions</h3>
<p>In the previous example, we created<a id="_idIndexMarker389"/> an event that represents an error, which is a special event defined in OpenTelemetry. It has <code>exception</code> as its name and the <code>exception.type</code>, <code>exception.message</code>, and <code>exception.stacktrace</code> attributes. Either <code>type</code> or <code>message</code> is required.</p>
<p>If we had an exception object, we could have used a <code>RecordException</code> extension method declared in the <code>OpenTelemetry.Trace.ActivityExtensions</code> class. We could record exceptions using <code>activity?.RecordException(ex)</code> and then pass custom tag collection to add to the event.</p>
<p>This method calls into the <code>Activity.AddEvent</code> method under the hood, filling in all the exception attributes, including the stack trace. Since stack traces can be huge, it’s a good idea to record them for unhandled exceptions and only once.</p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Correlating spans with links</h1>
<p>So far, we have talked about parent-child relationships<a id="_idIndexMarker390"/> between spans. They cover request-response<a id="_idIndexMarker391"/> scenarios well and allow us to describe distributed call stacks as a tree, where each span has at most one parent and as many children as needed.</p>
<p>But what if our scenarios are more complicated? For example, how do we express receiving temperature data from multiple sensors and aggregating it on the backend, as shown in <em class="italic">Figure 6</em><em class="italic">.4</em>?</p>
<div><div><img alt="Figure 6.4 – Batch processing" src="img/B19423_06_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Batch processing</p>
<p>In this example, sensors send data to the aggregator in the scope of different traces. The aggregator must start a third one – it shouldn’t continue one of the sensor’s traces.</p>
<p>We can use links to connect <code>trace3</code> to both <code>trace1</code> and <code>trace2</code>, allowing us to correlate all of them. Links don’t specify exact relationships between spans, but in the scope of this example, we can think about them as multiple parents for a single span.</p>
<p>Links are mostly used in messaging scenarios where messages are sent and received in batches to optimize network usage, or could be also processed together.</p>
<p>Links have two properties: a linked trace context and a collection of attributes. Currently, they can only be provided to the <code>StartActivity</code> method and may be used to make sampling decisions. This is an OpenTelemetry specification limitation<a id="_idIndexMarker392"/> that might<a id="_idIndexMarker393"/> be removed in the future.</p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor109"/>Using links</h2>
<p>Let’s see how we can use links<a id="_idIndexMarker394"/> to instrument batch processing scenarios with an in-memory queue. With background processing, we can’t rely on <code>Activity.Current</code> to flow from the enqueue operation to processing. So, we’ll pass <code>ActivityContext</code> along with the work item through the queue.</p>
<p>But first, we need to create an <code>Activity</code> for the enqueue operation so that we have some context to capture and pass around:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Producer.cs</p>
<pre class="source-code">
public void Enqueue(int id)
{
  using var enqueue = Source
    .StartActivity(ActivityKind.Producer)?
    .SetTag("work_item.id", id);
  _queue.Enqueue(new WorkItem(id, enqueue?.Context));
}</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/links/Producer.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/links/Producer.cs</a></p>
<p>While it’s important to instrument publish calls for remote queues, it’s not essential in this example. We only did it here to have some valid <code>ActivityContext</code> captured. If we had any other activity, we could use its context instead.</p>
<p>Now, we’re ready to instrument the work item processor:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">BatchProcessor.cs</p>
<pre class="source-code">
async Task ProcessBatch(List&lt;WorkItem&gt; items)
{
<strong class="bold">  using var activity = Source.StartActivity(</strong>
<strong class="bold">      ActivityKind.Consumer,</strong>
<strong class="bold">      links: items</strong>
<strong class="bold">        .Select(i =&gt; new ActivityLink(i.Context)));</strong>
  activity?.SetTag("work_items.id",
       items.Select(i =&gt; i.Id).ToArray());
  ...
}</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/links/BatchProcessor.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/links/BatchProcessor.cs</a></p>
<p>Here, we iterated over work<a id="_idIndexMarker395"/> items and created an <code>ActivityLink</code> for each of them by using the trace context passed alongside the <code>WorkItem</code> instance.</p>
<p>Then, we added the <code>work_item.id</code> attribute with an array containing all received IDs to the <code>BatchProcessing</code> activity. Ideally, we’d put attributes on the links themselves via the <code>ActivityLink</code> constructor, but I’m not aware of any observability backend that supports it now. As an alternative, we can also create an event for each work item and populate attributes on them.</p>
<p>Let’s run the sample with <code>links$ dotnet run</code>. It will enqueue three work items and then process them all in one batch. In Jaeger, we should see four independent traces – one for each enqueue operation and one for batch processing. An example of the latter is shown in <em class="italic">Figure 6</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 6.5 – Processing span with links" src="img/B19423_06_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Processing span with links</p>
<p>We can see that it has three<a id="_idIndexMarker396"/> references (links in Jaeger terminology), which we can click on and land on the corresponding <code>Enqueue</code> operation, as shown in <em class="italic">Figure 6</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 6.6 – Enqueue span" src="img/B19423_06_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Enqueue span</p>
<p>In Jaeger, it’s not possible to navigate from the <code>Enqueue</code> span to the <code>ProcessBatch</code> span. But some of the observability backends support navigation in both directions. For example, <em class="italic">Figure 6</em><em class="italic">.7</em> shows the <code>Enqueue</code> operation linked to processing in Azure Monitor:</p>
<div><div><img alt="Figure 6.7 – Two linked traces visualized in Azure Monitor " src="img/B19423_06_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Two linked traces visualized in Azure Monitor</p>
<p>Note that there are two different<a id="_idIndexMarker397"/> operations IDs (trace IDs) that have been correlated using a link. We’ll see more examples of links in messaging scenarios in <a href="B19423_11.xhtml#_idTextAnchor174"><em class="italic">Chapter 11</em></a>, <em class="italic">Instrumenting Messaging Scenarios</em>. For now, let’s learn how to test our instrumentations.</p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor110"/>Testing your instrumentation</h1>
<p>The idea of testing logs<a id="_idIndexMarker398"/> might look wild – logs are not intended to stay in one place or retain a specific structure. It’s not the case for traces.</p>
<p>Instrumentation directly affects your ability to evaluate production health and usage. Testing auto-instrumentation could be limited to basic happy case validation – we only need to check that it’s enabled and emits some data in the right format. This would help us detect potential problems with dependency updates. Manual instrumentation needs more attention.</p>
<p>Let’s see how we can test any instrumentation in ASP.NET Core applications. We’re going to rely on the integration testing capabilities provided by the <code>Microsoft.AspNetCore.Mvc.Testing</code> NuGet package. You can find more details about it in the ASP.NET Core<a id="_idIndexMarker399"/> testing documentation available at https://learn.microsoft.com/aspnet/core/test/integration-tests. It allows us to modify the ASP.NET Core application’s configuration for test purposes. In this section, we’ll use it to change the OpenTelemetry pipeline and intercept activities.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>Intercepting activities</h2>
<p>There are a few different<a id="_idIndexMarker400"/> ways to intercept activities; let’s list them:</p>
<ul>
<li>We can add a span processor, similar to how we enriched activities in <a href="B19423_05.xhtml#_idTextAnchor083"><em class="italic">Chapter 5</em></a>, <em class="italic">Configuration and Control Plane</em>. Since processors run synchronously, we can validate the <code>Activity</code> attributes against the ambient context – for example, <code>Baggage.Current</code>. We can also check (when needed) that attributes are provided at start time in the <code>OnStart</code> callback.</li>
<li>We can implement a test exporter. The downside of this approach is that we’ll only see completed activities. Also, exporters run asynchronously and there will be no ambient context to validate against.</li>
<li>We can write a custom <code>ActivityListener</code> implementation. This approach would not allow us to test the customization and configurations we’ve done with OpenTelemetry. We won’t even be able to validate whether OpenTelemetry is configured to listen to specific <code>ActivitySource</code> instances or check whether sampling works as expected.</li>
</ul>
<p>So, <code>ActivityListener</code> could be a great choice for unit testing, and the processor gives the most flexibility in terms of integration testing, which we’re going to focus on here. Let’s see how we<a id="_idIndexMarker401"/> can inject a processor into the OpenTelemetry pipeline in tests.</p>
<p>The <code>OpenTelemetry.Extensions.Hosting</code> NuGet package allows us to customize the pipeline with the <code>ConfigureOpenTelemetryTracerProvider</code> extension method. It’s called after the OpenTelemetry pipeline is configured, right before the <code>TracerProvider</code> instance is built. If you are using vanilla OpenTelemetry, you will have to implement a callback for tests to alter the pipeline.</p>
<p>Here’s an example of adding a test processor:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">TestFactory.cs</p>
<pre class="source-code">
public class TestFactory : WebApplicationFactory&lt;Program&gt;
{
  public readonly <code>TestActivityProcessor</code> Processor = new ();
  protected override void ConfigureWebHost(
    IWebHostBuilder b)
  {
    b.ConfigureServices(s =&gt; {
      s.ConfigureOpenTelemetryTracerProvider(
        (_, traceProviderBuilder) =&gt;
          traceProviderBuilder.AddProcessor(Processor));
      ...
    });
  }
}</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/testing/app.tests/TestFactory.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/testing/app.tests/TestFactory.cs</a></p>
<p>The <code>TestFactory</code> class allows us to set up an ASP.NET Core application for testing, which we’re doing in the <code>ConfigureWebHost</code> method. There, we call into the <code>ConfigureOpenTelemetryTracerProvider</code> method, where we change the OpenTelemetry pipeline and inject<a id="_idIndexMarker402"/> our test processor. Here’s the minimalistic processor implementation:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">TestActivityProcessor.cs</p>
<pre class="source-code">
public class TestActivityProcessor :BaseProcessor&lt;Activity&gt;
{
  ConcurrentQueue&lt;Activity&gt; _processed = new ();
  public override void OnEnd(Activity activity) =&gt;
    _processed.Enqueue(activity);
  ...
}</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/testing/app.tests/TestActivityProcessor.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/testing/app.tests/TestActivityProcessor.cs</a></p>
<p>We’re almost ready to write some tests, but there is another challenge – how do we filter activities related to a specific test?</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>Filtering relevant activities</h2>
<p>When we run tests<a id="_idIndexMarker403"/> in parallel, we effectively register multiple OpenTelemetry pipelines that listen to the same <code>ActivitySource</code> instances. With unit tests covering our instrumentations, we can control this better, but in the case of integration tests, <code>ActivitySource</code> and its listeners are de facto static and global – if we run tests in parallel, we’ll see activities from all of them in the processor. We need to filter relevant activities that belong to our test, which we can do using distributed tracing.</p>
<p>We’ll start a new activity for each test and propagate the context to the service under test. Then, we can filter processed activities based on their trace IDs. This approach is implemented in <code>TracingTests</code> (<a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/testing/app.tests/TracingTests.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/testing/app.tests/TracingTests.cs</a>).</p>
<h3>Validation</h3>
<p>Once we can filter all the activities<a id="_idIndexMarker404"/> related to this test execution, we’re ready to do some checks on them. It’s useful to check all the properties you rely upon in your monitoring and debugging tasks. For example, the following code validates a few properties of ASP.NET Core’s <code>Activity</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">TracingTests.cs</p>
<pre class="source-code">
Assert.Equal("/document/foo",
  httpIn.GetTagItem("http.target"));
Assert.Equal(404, httpIn.GetTagItem("http.status_code"));
Assert.Equal(ActivityStatusCode.Unset, httpIn.Status);
Assert.Empty(httpIn.Events);</pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/testing/app.tests/TracingTests.cs">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter6/testing/app.tests/TracingTests.cs</a></p>
<p>Now, you’re ready to write and test your instrumentations! You may also find it useful to use distributed tracing for your general integration testing needs – relying on it to validate intended test behavior and investigate flaky tests or unstable service behavior. You could also use traces as one of the inputs to validate service behavior.</p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/>Summary</h1>
<p>In this chapter, we explored manual distributed tracing instrumentation using .NET diagnostics primitives. <code>Activity</code> and <code>ActivitySource</code> are the default ways to instrument your code – create, start, end, and enrich activities with attributes and events. You can achieve the same functionality with <code>Tracer</code> and <code>TelemetrySpan</code>, from the OpenTelemetry API package. They provide a thin wrapper over .NET diagnostics APIs while using OpenTelemetry terminology.</p>
<p>We also looked into the ambient context propagation with <code>Activity.Current</code> and how it makes multiple instrumentation layers work together. Then, we learned about events and their limitations and used links to correlate different traces.</p>
<p>Finally, we covered testing – since instrumentation can be critical for monitoring, we should validate it as any other feature. We learned how to reliably do this in ASP.NET Core applications.</p>
<p>With this, you should be able to write rich tracing instrumentations and troubleshoot and validate custom tracing code. To achieve better observability, we can combine multiple signals with minimal duplication, so in the next chapter, we’re going to look at manual metrics instrumentation and see how it can work along with tracing.</p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor114"/>Questions</h1>
<ol>
<li>Let’s say you started <code>Activity</code> using <code>ActivitySource</code>. How do you configure OpenTelemetry to listen to it? How does it work?</li>
<li>When should you use <code>Activity</code> events? What are the alternatives?</li>
<li>What do we need links for? How can we use them?</li>
</ol>
</div>
</body></html>