- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extending the Adventure Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B18347_07.xhtml#_idTextAnchor130), we added polish to the game
    by applying some simple VFX using post-processing effects (mainly Bloom) with
    the Universal RP, Shader Graph for a custom 2D shader to make specific parts of
    a sprite glow, 2D lights to highlight the player, and the Trail Renderer component
    for a quick VFX win on our bullet sprite.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved away from the player to give some much-needed attention to the
    enemy NPCs in the game by creating configurable enemies using a ScriptableObject
    architecture and introducing changing behaviors based on the state pattern as
    implemented via a simple FSM.
  prefs: []
  type: TYPE_NORMAL
- en: With the base functionality in place for the playable character and enemies
    with behaviors (mostly) set up, we can now move on to spawning enemies that attack
    the player and vice versa with a reusable health and damage system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Health and inflicting damage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the player and enemy to use health
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enemy wave spawner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to spawn enemies with simple health
    and damage systems – that will also be applicable for the player or any damageable
    objects in the game!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along in this chapter with the same artwork created for the project
    in the book, download the assets from the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)'
  prefs: []
  type: TYPE_NORMAL
- en: To follow along with your own artwork, you’ll need to create similar artwork
    using Adobe Photoshop, or a graphics program that can export layered Photoshop
    PSD/PSB files (e.g., Gimp, MediBang Paint, Krita, and Affinity Photo).
  prefs: []
  type: TYPE_NORMAL
- en: Health and inflicting damage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point in our project, we have implemented much of what we specified
    in our GDD ([*Chapter 4*](B18347_04.xhtml#_idTextAnchor079), *Table 4.1*) for
    our player character and enemies, but an essential system is still missing – health
    and damage.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming sections, we’ll not only tackle adding health to the player and
    enemies with a reusable component but also finish the enemy’s attack behavior
    for inflicting damage on the player. The player can already fire a weapon that
    shoots a projectile, so we’ll add to the `Bullet` object we previously made in
    [*Chapter 6*](B18347_06.xhtml#_idTextAnchor116), so that it can inflict damage,
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Health system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll develop a `HealthSystem` component to create a reusable component for
    `Player`, enemy, and other objects (e.g., in the environment – think a destructible
    crate). This health system will track health, take damage and/or heal, and can
    be added to any object. The remainder of the setup will include creating Interfaces
    that tie the system together and make the whole thing operate in an abstract way
    (i.e., reusable, extensible, maintainable).
  prefs: []
  type: TYPE_NORMAL
- en: Like before, to clearly understand how we’ll create the health system, we’ll
    utilize a UML diagram based on the concepts we just described in the preceding
    paragraph. We can always refer back to this diagram at any point if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Health system class diagram](img/B18347_08_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Health system class diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s dive into it! Create a new script in the `Assets/Scripts` folder
    and name it `HealthSystem`. This, being central to the UML diagram, will be the
    largest class we’ll be creating for the health system because, well, it *is* the
    health system! Since it will consist of the most code we’ll be writing in this
    section, we’ll break it up by first just declaring the member variables and a
    Unity message event, then proceed to flesh it out as we build up the system’s
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Task list (IDE)
  prefs: []
  type: TYPE_NORMAL
- en: You’ve undoubtedly seen **// UNDONE:** in the preceding code and may have wondered
    what that’s all about. Well, we can use some tokens in our comments that our IDE
    will pick up, and it will generate a task list based on them! This feature helps
    us locate incomplete tasks and highlight things that need attention. Additionally,
    you can create your own custom tokens, which can be super useful for your specific
    needs (but you’ll need to check your specific IDE for support).
  prefs: []
  type: TYPE_NORMAL
- en: 'Common tokens include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**//** **TODO:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**//** **UNDONE:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**//** **HACK:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may be able to infer from the code we have so far – and if you’ve read
    the code comments – `HealthSystem` functions through collisions with other objects
    in the scene, such as projectiles from enemies or healing pickups. The other objects
    can either damage or heal the object with the `HealthSystem` component on it,
    and that will depend on the interface the object inherits from (from the UML diagram:
    `IDamage` and `IHeal`). Even the ground as an object can potentially damage the
    player if, let’s say, the player’s velocity is above a certain threshold when
    colliding.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the breakdown for the code added so far, plus the required additions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable declarations will enable the core function of `HealthSystem`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_healthMax` will specify the maximum health value for the object (i.e., the
    object we’re giving health by adding the `HealthSystem` component).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_healthCurrent` will specify the current health of the object. As the object
    is either damaged or healed, this value will decrease or increase respectively.
    When the object is created in the scene, we should set the current health to the
    `_healthMax` value, which we’ll do now by adding the `Awake()` Unity message event
    as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note here that the max health value (`_healthMax` is the serialized stored value)
    will be saved within the `Object with Health` Prefab, but imagine that you could
    also use a ScriptableObject, database, cloud-obtained (JSON) data, or even Unity’s
    own **Remote Config** (as part of **Unity Gaming Services**) so that we can change
    the max health value dynamically (and, with some of these methods, at any time
    without being dependent on distributing a new build of the game).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional reading | Unity Gaming Services
  prefs: []
  type: TYPE_NORMAL
- en: 'Remote Config: [https://unity.com/products/remote-config](https://unity.com/products/remote-config)'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnTriggerEnter2D()` is where the magic happens! Collisions with other objects
    drive the health system, so we’ll use this Unity message event to handle the interactions
    when triggered from the physics system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s add both damage and healing methods first, and then we’ll add the evaluations
    that call these methods next:'
  prefs: []
  type: TYPE_NORMAL
- en: Note | Physical interactions
  prefs: []
  type: TYPE_NORMAL
- en: To have the objects physically respond to each other when colliding, use a **Collider**
    instance on the object that does not have **IsTrigger** enabled and respond to
    the collision using the **OnCollisionEnter2D()** Unity message event. For an object
    to not have a physical response when colliding, use a **Collider** instance with
    the **IsTrigger** field enabled and respond to the collision using the **OnTriggerEnter2D()**
    Unity message event.
  prefs: []
  type: TYPE_NORMAL
- en: '`HandleDamageCollision()`, as the name implies, handles when we collide with
    another object that can damage us. We’ll pass in the collision parameter from
    when `OnTriggerEnter2D()` is called and, a future addition, the object that caused
    the damage (which is the object inheriting from the `IDamage` interface).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the following method to the `HealthSystem` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Okay, yes, we’ve added another unfinished method to be called here that we’ll
    again add to later: `TakeDamage()`. We’re keeping the approach simple, taking
    one baby step at a time to build out the health system. The simple UML diagram
    may set an expectation that this will be easy. Well, it is – provided we tackle
    the implementation one step at a time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our future selves will again tackle implementing the `TakeDamage()` method in
    the coming *Taking damage – IDamage interface* section when we also add the required
    `IDamage` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HandleHealCollision()` is similar to the method for handling damage. We’ll
    add one for handling object healing. However, we’ll omit to pass in the `collision`
    object as a parameter this time; we’ll handle things a bit differently for healing
    compared to taking damage (as you’ll see in the coming *Healing – IHeal* *interface*
    section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the following method to the `HealthSystem` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Okay, we’re piling on the *undone* methods to implement here, right?! Just like
    for `TakeDamage()`, we’ll have a method called for healing and changing the health
    value of the affected object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And that’s the core of the `HealthSystem` class laid out. Let’s go ahead and
    add the required interfaces that our new health system classes inherit from and
    make things actually function!
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces required!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s still more work to do before we add a `HealthSystem` component to any
    of our GameObjects, so let’s sort out and evaluate these damage and heal collisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part we’ll need interfaces for is the evaluation of the object that
    collides with the object that has health (e.g., a `Player` or enemy object with
    the `HealthSystem` component added). We’ll determine whether the colliding object
    can damage or heal – we’re replacing this first `UNDONE` token in our task list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: From the UML diagram, we can see the object we want to evaluate is either inherited
    from `IDamage` or `IHeal`. Using interfaces to inherit from ensures that the required
    members exist in our classes that provide the intended functionality (i.e., the
    class must satisfy the “contract” of the interface).
  prefs: []
  type: TYPE_NORMAL
- en: Standard naming conventions dictate that when naming an interface, it should
    begin with the letter “*I*,” which offers us an opportunity to be a bit clever,
    or even memorable, in our naming and bring more readability to our codebase. So,
    for an object that can damage another object, we’ll name the interface `IDamage`
    – as in *I damage [an object]*. In the *Healing – IHeal interface* section, we’ll
    add additional interfaces for `IHaveHealth` and `IHeal` – see what we did there.
    Not that I’m being terribly clever here because *IDamage*, *IDamageable*, and
    *ITakeDamage* are pretty common interface names for game code for the same naming
    reasoning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s update the `OnTriggerEnter2D()` method with the following `if` statements
    that include the interfaces (that we’ll create just after this step):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s have a look at the following two evaluations and how they’ll provide
    the desired functionality for our health system:'
  prefs: []
  type: TYPE_NORMAL
- en: '`collision.TryGetComponent<IDamage>()`: If you haven’t realized by now, I’m
    a fan of the *try get component pattern* – we can fail gracefully if the component
    doesn’t exist on the object we’re testing. And if it does exist, we conveniently
    have an `out` parameter that returns the component. Simples!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimization note
  prefs: []
  type: TYPE_NORMAL
- en: When using the **TryGetComponent** method, the method does not allocate memory
    on the heap when it doesn’t find a component. When it does find a component, it
    allocates memory only for the return value, not the component itself. This can
    be very beneficial for improving performance and reducing garbage collection,
    unlike the **GetComponent** methods, which can generate garbage and allocate more
    memory – both negatively impacting performance. By utilizing **TryGetComponent**
    instead, you can avoid unnecessary memory allocations and keep your game running
    smooth as butter.
  prefs: []
  type: TYPE_NORMAL
- en: So, what’s occurring here is, if the object we collided with has a component
    that inherits from `IDamage` on it, as in, *I damage this object*, then return
    the component and pass it into `HandleDamageCollision()` as a parameter along
    with the collision object itself. Peeking ahead a bit and referring back to the
    UML diagram, we can see that we’ll be implementing a `ProjectileDamage` component
    (e.g., on `Bullet`) that inherits from `IDamage`.
  prefs: []
  type: TYPE_NORMAL
- en: '`collision.TryGetComponent<IHeal>()`: Ditto here. If the component we collided
    with has a component that inherits from `IHeal` on it, as in, *I heal this object*,
    then return the component and pass it into `HandleHealCollision()`. Again, peeking
    back at the UML diagram, we can see that we’ll be implementing a `PickupHeal`
    component (e.g., on a Water Diamond) that inherits from `IHeal`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currently, if the object collided does neither damage nor heal, then we simply
    ignore the collision (of course, when colliding with anything, the obvious choice
    here is to do a camera shake!).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an implementation of the interface, we need to actually create
    them. These interfaces aren’t going to write themselves, so let’s start with `IDamage`.
  prefs: []
  type: TYPE_NORMAL
- en: Taking damage – IDamage interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve already seen the UML diagram (*Figure 8**.1*) and the `HandleDamageCollision()`
    code, where the `IDamage` interface is implemented but hasn’t been defined yet.
    I lied above, too: they can write themselves (at least partially) if we use the
    IDE’s refactoring tools – in `OnTriggerEnter2D()`, `IDamage` will have a red squiggly
    underline. Right-clicking on the word (or clicking anywhere on it and pressing
    *Alt + Enter* or *Ctrl + .* depending on your IDE) and selecting **Generate interface
    ‘IDamage’ in a new file** will generate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you decided not to use refactoring tools (why not?), create a new C# script
    in the `Assets/Scripts/Interfaces` folder and name it `IDamage`. Even if you did
    use the refactoring tools, you’ll likely still need to move the generated script
    into the `Assets/Scripts/Interfaces` folder to keep things tidy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we’ll need a field for specifying the value for how much the object inheriting
    from `IDamage` will damage the object with health, so add a `DamageAmount` variable
    declaration like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Remember, all members of an interface are public, so there is no need to add
    the accessor. We’ll set the property to be a getter only, though; we’ll only want
    the value to be read by other classes (no modification outside of the class inheriting
    the interface – all nice and hidden, how we like it).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our `IDamage` interface. We can use it for making projectiles
    and, well, just about any other object that hurt the player, by subtracting health
    when a collision occurs between the object and `HealthSystem`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s fix up the `HandleDamageCollision()` method now back in our `HealthSystem`
    class by removing the `// UNDONE:` token comment and using `DamageAmount` for
    the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets us up nicely to have our IDE’s refactoring tools generate the `TakeDamage()`
    method for us, so let’s continue by doing just that. You know the drill: red squiggly
    line, etc., etc., then select **Generate** **method ‘TakeDamage.’**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And here we are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'I’m so sorry, more *undone* comments! Please don’t fret; with this very temporary
    instruction, we’ll fix up the code straight away. Fill in the method with the
    following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is update the current health value for the amount of damage
    received by subtracting `amount` from `_healthCurrent`. We’re getting some help
    from the `Mathf.Max()` function here so that the current health value will never
    dip below zero (keeping things positive).
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Mathf.Max()**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Max.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Max.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s uncomment our placeholder for the `HealthChanged()` method. Go ahead
    and create an empty method block for it, but completing this method will be a
    job for our future selves when we actually have some objects set up to enact the
    health change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We’ll call this method anytime the health value has changed so we can evaluate
    the current health of the object and *do stuff* accordingly – such as notify other
    classes about the health value of the object changing or die/destroy if health
    reaches zero.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s get an object set up now that will inflict damage on the player.
  prefs: []
  type: TYPE_NORMAL
- en: ProjectileDamage component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script called `ProjectileDamage` in the `Assets/Scripts` folder
    – this is a component we’ll add to our `Bullet` Prefab. To ensure this component
    will cause damage to our health system, it will implement the `IDamage` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The public `DamageAmount int` variable is required to be declared to satisfy
    the `IDamage` interface contract – it’s also necessary for the health system to
    obtain the value for the amount of damage this projectile causes! `DamageAmount`
    is a public property because all interface members are public and cannot contain
    fields. Because C# properties are not serialized by Unity, to assign a value in
    the `Bullet` Prefab), we’ll encapsulate a private `_damageAmount` variable and
    decorate it with the `[SerializeField]` attribute. If you haven’t already guessed,
    this is the structure we’ll continue with throughout the remainder of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’ve finished saving the script, open up the `Bullet` Prefab in `ProjectileDamage`
    to the root GameObject, as seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Bullet Prefab ProjectileDamage component](img/B18347_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Bullet Prefab ProjectileDamage component
  prefs: []
  type: TYPE_NORMAL
- en: When we declared `_damageAmount` in the preceding code, we set a default value
    of `5`, which you can already see as the assigned value in the **Inspector** window.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, we can damage stuff now; great! But that’s not really fair if objects
    such as our player cannot also have a chance to heal.
  prefs: []
  type: TYPE_NORMAL
- en: Healing – IHeal interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve taken care of the left side of the UML diagram (*Figure 8**.1*) for our
    health system, so now, similar to `IDamage`, we need to define the `IHeal` interface
    to take care of the right side. We’ll also create a component to add to objects
    that can apply healing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the `OnTriggerEnter2D()` method now, let’s repeat the steps performed
    for creating the `IDamage` interface but for `IHeal`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `IHeal` interface script (have your IDE generate it) in the `Assets/Scripts/Interfaces`
    folder and add the `HealAmount` variable for, you guessed it, specifying the amount
    of healing power:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the placeholder `HandlHealCollision()` method, specifying the `HealAmount`
    value from the interface as the parameter when calling `ApplyHealing()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, create the `ApplyHealing()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first thing we do is update the current health value for the amount of healing
    received by adding `amount` to `_healthCurrent`. Just like when we took damage,
    we’re getting some help from a `Mathf` function here again, but it’s `Mathf.Min()`
    this time, so that the current health value will never exceed the object’s maximum
    health value (no cheating).
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Mathf.Min**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Min.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Mathf.Min.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: And, like with damage, we’ll create a healing component that will add health
    when a collision occurs.
  prefs: []
  type: TYPE_NORMAL
- en: PickupHeal component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new script called `PickupHeal` in the `Assets/Scripts` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Same as with the `ProjectileDamage` script, we can see that we’ve inherited
    from `IHeal` (to ensure healing with our health system) and implemented the `IHeal`
    interface by defining `HealAmount`. We’ve also encapsulated `HealAmount` by declaring
    a private `_healAmount` variable serialized so we can set the value in the `10`
    is also assigned here).
  prefs: []
  type: TYPE_NORMAL
- en: Note on code architecture
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself needing many different types for damage or heal components,
    you can create a new base class for each that implements the interface, so you
    aren’t repeating yourself with the event and method to invoke. The current implementation
    suits our current needs, so you can also leave off here, or challenge yourself
    to create both a **DamageBase** and **HealBase** abstract class that **ProjectileDamage**
    and **PickupHeal** inherit from, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '`PickupHeal` is a component we’ll add to… hmmm… what object will we add it
    to? Let’s consult our GDD ([*Chapter 4*](B18347_04.xhtml#_idTextAnchor079), *Table
    4.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **What is a buff mechanic for the player in the** **adventure game?** | The
    player will be able to collect energy shards (water diamonds) scattered throughout
    the environment that, when a certain quantity has been collected, will give a
    power-up state to all of the weapons (increasing damage dealt). |'
  prefs: []
  type: TYPE_TB
- en: Table 8.1 – Adding a buff to the GDD
  prefs: []
  type: TYPE_NORMAL
- en: 'Sounds great. Well, actually, I think we can do better. Let’s revise; after
    all, the GDD is a living document:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **What is a buff mechanic for the player in the** **adventure game?** | Players
    can gather energy shards (water diamonds) as they explore the game world. The
    player can later use the collected energy to power up weapons (increase damage
    dealt) or heal the player, offering more strategic options for the player while
    navigating the game’s challenges. |'
  prefs: []
  type: TYPE_TB
- en: Table 8.2 – Revising the buff in the GDD
  prefs: []
  type: TYPE_NORMAL
- en: Better! Allowing players to choose between using energy shards to power up weapons
    or to heal themselves creates a risk-versus-reward strategy in the game. To make
    the mechanic meaningful to the player, a game designer must consider the approach
    carefully, especially if the choice is only sometimes clear!
  prefs: []
  type: TYPE_NORMAL
- en: For now, let’s just create an object that will heal the player when picked up.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a water diamond pickup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s use the water diamond from the artwork provided at the following link:
    [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch8/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch8/Art-Assets).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Water diamond artwork](img/B18347_08_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Water diamond artwork
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our water diamond pickup Prefab based on the water diamond artwork,
    and as a refresher, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the artwork to the `Assets/Sprites/Pickups` folder. (I love how this
    water diamond art came out, by the way; nice job, Nica!)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Project** window, select the water diamond sprite and, in the **Inspector**
    window, use **Sprite Editor** to set the provided normal map as the secondary
    texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the water diamond sprite into the `Water Diamond (Heal)` (remember, you
    can easily parent a GameObject in the **Hierarchy** window by right-clicking on
    it and selecting **Create** **Empty Parent**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `CapsuleCollider2D` instance to the parent object to enable physics (precisely,
    collision detection).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the **Edit Collider** button to enable resizing of the collider around the
    diamond shape, as seen in the following figure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Water diamond healing Prefab](img/B18347_08_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Water diamond healing Prefab
  prefs: []
  type: TYPE_NORMAL
- en: Add the `PickupHeal` component to the Prefab root (also seen in *Figure 8**.4*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, drag the parent object from the `Assets/Prefabs` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For a quick hack to bump up the visuals, you can cheat a bit (as indie game
    devs, it’s all about cheating to save time anywhere we can) and reuse the material
    we created in [*Chapter 7*](B18347_07.xhtml#_idTextAnchor130), for the bullet.
    Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Materials` folder, duplicate the `Bullet 1` material and rename
    it `Water` `Diamond 1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the water diamond sprite to the `MainTex` channel but leave the `bullet1_emission`
    map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign this new material to the **Sprite Renderer Material** field on the **Water
    Diamond 1** Prefab’s graphic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust the HDR color and intensity for desired visuals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our pickup Prefab is looking good. Yay!
  prefs: []
  type: TYPE_NORMAL
- en: We need to add one last bit of functionality for this Prefab to be a pickup
    for the player. It has to disappear once “collected,” and we can do that by revisiting
    an existing reusable component we previously made – along with a new one.
  prefs: []
  type: TYPE_NORMAL
- en: Composition for pickup behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As previously introduced, being able to bring multiple objects together to achieve
    a desired behavior or functionality is a form of **composition**. To state another
    way, we’ll combine two or more reusable components, each responsible for a specific
    aspect of an object’s behavior or appearance. This will allow us to create a new
    behavior directly in the editor without introducing new code – this is especially
    valuable for designers on your team where experimentation can generate new ideas
    independently.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by adding the `TriggeredEvent` component to the root `gameObject`
    of the `OnTriggered` event that fires when the player collides with the pickup
    object. We want to destroy the pickup, but there isn’t a built-in way to do that.
    However, it’s easily solved.
  prefs: []
  type: TYPE_NORMAL
- en: Destroyer component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To destroy the pickup, all we need is an additional component serving as a
    single-purpose but reusable component. This component will be added to the existing
    composition for the pickup behavior. To clarify, we need to destroy the pickup
    object by calling the `TriggeredEvent.OnTriggered` event. So, first, make a new
    script named `Destroyer` in the `Assets/Scripts` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Simple. A public method that can be called that destroys the object – `DestroyMe()`.
    I’ve added the option for setting a delay before destroying the object – yes,
    I’m confident this is a typical enough use case, it literally only took seconds
    to add, and I’ll defend that I’m not violating the YAGNI principle!
  prefs: []
  type: TYPE_NORMAL
- en: YAGNI | “You ain’t gonna need it”
  prefs: []
  type: TYPE_NORMAL
- en: This principle states that a programmer should only add functionality if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Another one I like is **DRY** (**don’t repeat yourself**), which is simply directed
    at reducing repetition (a basic example would be if you find yourself writing
    the same code more than once, extract it to a method or abstraction).
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and add `Destroyer` to the root of the `Water Diamond (Heal)` Prefab
    so we can wire things up in the **Inspector** window:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the execution state dropdown to **Runtime Only**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Destroyer` component to the object field (using its title area).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the function selection dropdown, select **Destroyer** | **DestroyMe( )**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I’d leave `0` for this pickup, but for other behavior, you may want to adjust
    (see, you have that option!). And, yes, although `Destroy()` has a second parameter
    to delay destroying the object, the `Destroyer` class serves as a general example
    for introducing an execution delay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Assign DestroyMe to OnTriggered (UnityEvent)](img/B18347_08_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Assign DestroyMe to OnTriggered (UnityEvent)
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so let’s talk about what objects can affect the health of other objects
    – right now, it’s like the Wild West out there, with everything able to damage
    everything else. We can’t have any of that going on, so let’s put on a mask to
    start getting everyone to behave properly – a LayerMask, that is.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling what damages/heals what
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem we have to solve here is finding a simple way to specify what objects
    can damage other objects – this is essential for reinforcing the game’s design.
    We’ve solved this problem before by using a **tag** and also a **LayerMask**.
    My preference, generally, is to use tags only when comparing a single type of
    object in code and using a LayerMask for sorting out several different types of
    objects, with the added bonus of a LayerMask being designer friendly since the
    assignment is made in the **Inspector** window.
  prefs: []
  type: TYPE_NORMAL
- en: What damages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The time to evaluate the objects is at the time of the collision, so we will
    update the *handle collision* methods in `HealthSystem` accordingly. But first,
    we need to define the `LayerMask` variables in the right places, starting with
    damage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `DamageMask` declaration to the `IDamage` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the following variables so we can use `DamageMask` and satisfy the
    existing contract we have in `ProjectileDamage` for the interface implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here is the encapsulation pattern again (told you!) for the `_damageMask` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now revise the `HandleDamageCollision()` method in `HealthSystem` to
    implement the mask check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This `if` statement should look a bit familiar; it’s the same *is this object’s
    layer in the LayerMask?* evaluation we used for our `Bullet` back in [*Chapter
    6*](B18347_06.xhtml#_idTextAnchor116). So, if the `ProjectileDamage.DamageMask`
    includes the object with health’s layer, only then will `TakeDamage()` be called.
  prefs: []
  type: TYPE_NORMAL
- en: Damage bad. Heal good. Let’s do the same for what can heal.
  prefs: []
  type: TYPE_NORMAL
- en: What heals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’re going to repeat what we did for what damages, so add the `LayerMask`
    variable `HealMask` to the `IHeal` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the updated `IHeal` interface contract in `PickupHeal` – encapsulating
    the `_healMask` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As an exception to repeating what we did in the `HandleDamageCollision()` method,
    let’s not repeat ourselves here by also adding the layer mask check code to `HealthSystem.HandleHealCollision()`;
    instead, let’s extract the layer mask evaluation to a method, and we’ll give it
    a nice, easy-to-understand name: `IsLayerInLayerMask()` (using `Is` to start the
    name with makes it obvious this will return a bool `true` or `false` value, no?):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Utility methods (C#)
  prefs: []
  type: TYPE_NORMAL
- en: You’ll likely need this **IsLayerInLayerMask()** check in other classes, so
    consider creating a new static class for utility methods such as this one that
    can be used from anywhere in the code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, for action on specific types, consider adding an **extension** **method**:
    [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update `HandleHealCollision()` and use our new utility LayerMask check
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Better readability for the win! Don’t forget to return to the `HandleDamageCollision()`
    method to refactor the LayerMask evaluation to use the new `IsLayerInLayerMask()`
    method too!
  prefs: []
  type: TYPE_NORMAL
- en: Optimization note | Physics 2D
  prefs: []
  type: TYPE_NORMAL
- en: We can also control the physics interactions between objects by specifying what
    collisions are processed by their layer using the physics Layer Collision Matrix
    (**Edit** | **Project Settings** | **Physics 2D**, select the **Layer Collision**
    **Matrix** tab).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we created our health system that any object in the game can
    use for receiving damage and healing – it also provides a method for handling
    the final death/destruction of the object. You learned how to use interfaces to
    tie everything together in an extensible way by not relying on concrete class
    references.
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t added our new `HealthSystem` to any of our game’s objects yet. Let’s
    do that in the next section, starting with the player.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the player and enemy to use health
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not only `Player` and enemy objects but any object can be set up to use `HealthSystem`.
    It’s barely an inconvenience; in fact, the object simply needs to implement the
    `IHaveHealth` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning the object with health – IHaveHealth interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back in the health system UML diagram (*Figure 8**.1*), we see at the bottom
    that the object having health will implement the `IHaveHealth` interface (again,
    some meaningful naming here). Create a new file named `IHaveHealth` in the `Assets/Scripts/Interfaces`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We don’t yet have a class for the `Player` object, only `PlayerController`.
    We don’t want to add health to something named `controller` because it wouldn’t
    make sense considering the single-responsibility principle – and the controller’s
    only concern is movement. Let’s fix that now by creating a script named `Player`
    in the `Assets/Scripts` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure it implements `IHaveHealth`. You can use the IDE’s refactoring tools
    again here. `IHaveHealth` should have the ever-so-helpful red squiggly underline
    – so, use the IDE refactoring to *implement interface* on it, and you will get
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Until we decide what actions to perform for these methods, we’ll leave it as
    is for now. You will get a reminder in the `throw` indicates an exception has
    occurred while the program is running – in this case, `NotImplementedException:
    The method or operation is` `not implemented`.'
  prefs: []
  type: TYPE_NORMAL
- en: Caution when using throw
  prefs: []
  type: TYPE_NORMAL
- en: 'Be warned, however: throwing these exceptions will cause program execution
    in the calling method to stop – meaning any statements that follow **HealthChanged()**
    will not be executed! If unsure, replace the **throw** statements with something
    such as **Debug.LogError("Player.HealthChanged() has not** **been implemented!");**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Do exactly the same for `Enemy`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Enemy` script in the `Assets/Scripts` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `IHaveHealth` to the class declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `IHaveHealth` interface methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last step is to add the components to their respective objects: adding
    `Player` to the `Player` Prefab and `Enemy` to both enemy Prefabs. Of course,
    they also both get `HealthSystem` added, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Player and Enemy Prefabs with health](img/B18347_08_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Player and Enemy Prefabs with health
  prefs: []
  type: TYPE_NORMAL
- en: Initial values for max health are just initial values for testing. Playtesting
    will determine what values they’ll eventually land on, depending on difficulty
    and balanced gameplay. You got this!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have objects with health, we have one final part of our `HealthSystem`
    in need of completion – processing.
  prefs: []
  type: TYPE_NORMAL
- en: Process changes to health
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To finish up our fully functioning `HealthSystem`, we just need to process
    the changes to health for our objects that, yeah, have health. Back in our `HealthSystem`
    class, add the variable that will hold the reference to the object with health
    and get the object reference in `Awake()` using a `GetComponent()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As our future selves now, we’ll revisit the `HealthChanged()` method and squash
    those final lingering `UNDONE` token comments! We’ll use a null check (`if` statement)
    to ensure we have a sibling component on this GameObject that implements the `IHaveHealth`
    interface. We’ll give ourselves a warning in the console if we don’t (and use
    a `return` statement as a sort of cancellation not to execute any code that follows),
    and proceed to process the health change otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With that, our health system is complete! It allows the addition of health to
    any object and gives the ability for any object to cause damage or heal without
    any concrete class references! Interfaces for the win!
  prefs: []
  type: TYPE_NORMAL
- en: 'We covered much territory creating the health system and wrote lots of code
    back and forth in several classes, so don’t forget that you can always refer to
    the completed project code for this chapter on the book’s GitHub repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping with our composition pattern, let’s quickly look at how we can set up
    the ability to easily add different behaviors (i.e., components) when interactions
    with `HealthSystem` occur.
  prefs: []
  type: TYPE_NORMAL
- en: Adding behavior with UnityEvent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve used `UnityEvent` before, for the `TriggeredEvent` component back in [*Chapter
    4*](B18347_04.xhtml#_idTextAnchor079). It’s flexible, in that listeners can be
    registered by code or assigned in the **Inspector** window (you already know I’m
    a fan of this one), so it will be a perfect use case for our needs here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only a few additions are required to add a `UnityEvent` instance that will
    be invoked when we handle the collisions for `IDamage` and `IHeal`. Let’s start
    by adding a method declaration to the interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the differences in the declarations, we’ll change things up
    just a bit with each implementation. `DoDamage()` will pass two parameters for
    collision and whether the object is affected by the collision (as in, did it just
    collide or was it affected by the damage?). We can use this bool to alter things
    such as the visual effect (e.g., small versus a sizeable varying particle effect),
    where `DoHeal()` will just pass in the object that is being healed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s implement the changes to the interfaces, starting with damage in
    the `ProjectileDamage` class. Add the `UnityEvent` and `DoDamage()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the specifics of the implementation coded in the preceding snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnDamageEvent`: Declare as a `UnityEvent` instance with two parameters. `Collider2D`
    takes the collision object that can be used to get the intersection position between
    the objects. And the `isAffected` value indicates whether or not the damage was
    applied as a result of the collision - this is from the layer mask evaluation,
    as we’ll see in a minute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take notice that we won’t use the `event` keyword here because it is a `UnityEvent`
    instance – it’s not a delegate type but a serializable class. Otherwise, always
    use the `event` keyword for your events to enforce the event pattern, where only
    the implementing class should invoke!
  prefs: []
  type: TYPE_NORMAL
- en: '`DoDamage()`: This is the public method called from `HandleDamageCollision()`
    when the interaction occurs, and its sole responsibility is to invoke the `UnityEvent`
    instance (passing the parameters).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And now do the same for `PickupHeal` – implement the changes with the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the explanation for these code changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnHealEvent`: Declared as a `UnityEvent` instance with one parameter. The
    `GameObject` instance is just the object that is affected by the healing. The
    usage could simply be getting the object’s transform position for instantiating
    an object or particle effect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoHeal()`: Just like the damage method, this is a public method called from
    `HandleHealCollision()` when the interaction occurs and is also solely responsible
    for invoking the `UnityEvent` instance (passing the parameter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final step is to add the public `Do` calls to the `HealthSystem.OnTriggerEnter2D()`
    method. Update `HandleDamageCollision()` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We introduced a local bool variable, `isAffected`, to get the `IsLayerInLayerMask()`
    result – we can then use the variable in place of calling `IsLayerInLayerMask()`
    multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: We can then just call `DoDamage()` and only call `TakeDamage()` if the object
    is affected by the damaging object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, update `HandleHealCollision()` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Unlike with damage, we don’t care about the impact of the damaging object having
    an effect or not. We’ll process healing if it’s in `HealMask`. We just need to
    call the public `DoHeal()` – passing in the object being healed – and we’re done!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an event exposed on the `ProjectileDamage` and `PickupHeal`
    components, let’s refactor an earlier composition for destroying the water diamond
    pickup. Hence, we have an example of its usage.
  prefs: []
  type: TYPE_NORMAL
- en: Re-composition for Destroyer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With `PickupHeal` now having a `UnityEvent` instance triggered when the collision
    occurs, we can improve the composition for destroying the water diamond object
    when it’s collected. We previously used the `TriggeredEvent` component, but now
    we need to assign the `Destroyer.DestroyMe()` function to the `OnHealEvent` function
    selection drop-down menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Revising Destroyer](img/B18347_08_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Revising Destroyer
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring to *Figure 8**.7*, let’s walk through this change:'
  prefs: []
  type: TYPE_NORMAL
- en: (*A*) – Click the little `OnHealEvent` tab to add a new listener to the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (*B*) – Drag the `Destroyer` component to the object field (using its title
    area).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the function selection drop-down menu, select **Destroyer |** **DestroyMe(
    )**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: (*C*) – Right-click on the `TriggeredEvent` title area to bring up the context
    menu and select **Remove Component**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You end up with an **Inspector** window that looks like the right-most image
    – you are done. Easy-peasy.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we don’t need to worry about `IsTriggeredByPlayer` from the `TriggeredEvent`
    component anymore since `DoHeal()` will only be called if the `HealMask` check
    is satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have created a fully implemented health system, and that’s
    a game changer (yes, bad pun). Again, you learned the power of interfaces and
    how we can quickly add functionality to existing systems. We also practiced composition
    by refactoring some reusable components to explore a different approach to destroying
    the heal pickup object.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let’s put the health system through its paces by having
    a bunch of pesky enemies to contend with as we introduce a wave spawner.
  prefs: []
  type: TYPE_NORMAL
- en: Enemy wave spawner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **wave spawner** may sound scary, but it’s just a straightforward script.
    We need to instantiate a new enemy from a given position and on a fixed (or random)
    time interval. We’ll also ensure things don’t get out of hand by limiting the
    number of enemies spawned.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, with that in mind, let’s have a look at our new `EnemySpawner` script –
    create it in the `Assets/Scripts` folder – and see whether you can point out where
    the few requirements I just stated have been implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break this class down – a lot of this should be looking very familiar
    by now:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare a variable for the enemy Prefab that will be spawned – we use the `Enemy`
    type here instead of `GameObject` because when we reference `_enemyPrefab` later,
    we’ll be referencing the `Enemy` class directly and won’t need to do `GetComponent()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare a variable for `_spawnInterval`, which will be the delay before spawning
    the next enemy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare a variable for `_maxSpawned`, which will be the total number of enemies
    onscreen – from this spawner – at the same time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare a variable for `_objectCount`, which keeps track of how many enemies
    are currently spawned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `Start()` method – here we’ll simply use `InvokeRepeating()` to repeatedly
    call `SpawnEnemy()` at the specified spawn interval (`_spawnInterval`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `SpawnEnemy()` method – we first check to see whether we’ve already
    instantiated our `_maxSpawned` amount of enemies, and, if not, `Instantiate()`
    a new `Enemy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a new (implicit declaration using `var`) local `enemy` variable –
    returned from the `Instantiate()` call – so that we can call `Init()` and pass
    in a callback parameter (as a pseudo constructor). This is in place of what would
    usually be the C# constructor (objects created with the `new` keyword, which,
    if you remember, we cannot do with `MonoBehaviour`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment the number of spawned objects with `_objectCount++`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the `DestroyedCallback()` method passed into the `Enemy.Init()` call
    so that, when the enemy object is destroyed, the currently spawned enemy count
    can be decreased – resulting in the spawner instantiating another enemy to maintain
    the `_maxSpawned` count.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t forget about object pooling!
  prefs: []
  type: TYPE_NORMAL
- en: Note that if we have waves and waves of many enemies, we do want to optimize
    this by introducing object pooling. Refer back to [*Chapter 6*](B18347_06.xhtml#_idTextAnchor116).
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll have to tie `DestroyedCallback` to the `Enemy` class because it’s passed
    to the instantiated enemy object via the `enemy.Init()` call. Let’s add everything
    to support that now; it’s not much, so open the `Enemy` script and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here we have a `UnityAction` instance that we’ll use to invoke the callback
    when the enemy object is destroyed – you’ve seen all this before.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just need to actually destroy the enemy object, and we do that when the
    object dies, as dictated by the `IhaveHealth`-interface-implemented `Died()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'A note about `DestroyedCallback` and why we don’t have to *unregister from
    the event* when enemy is destroyed: the responsibility is being flipped here since
    `EnemySpawner` is not holding a reference to the instantiated enemy object. You
    only need to unregister (or `RemoveListener`) from events that can become invalid
    references.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s set up a Prefab we can reuse as a preconfigured enemy spawner.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the enemy spawner Prefab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go ahead and, in your current open scene in Unity, create a new empty GameObject
    in the `EnemyB Spawner 1` – we can have different Prefabs for different enemy
    spawning behaviors. Make sure to place it right at ground level in your environment
    because the spawner’s transform position will be used as the enemy instantiation
    point. Add the `EnemySpawner` component to the `EnemyB``Spawner 1` object and
    drag in the `EnemyB` Prefab from the `Assets/Prefabs` folder to the **Enemy Prefab**
    field, as seen in *Figure 8**.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Enemy spawner setup](img/B18347_08_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Enemy spawner setup
  prefs: []
  type: TYPE_NORMAL
- en: Finish up by dragging the `EnemyB Spawner 1` object in the `Assets/Prefabs`
    folder. Yay!
  prefs: []
  type: TYPE_NORMAL
- en: If you playtest the enemy wave spawner now, they’ll just spawn on top of one
    another, be disorganized, and not go anywhere – in other words, not acting like
    robots at all. Let’s integrate spawning with the patrolling behavior to keep things
    orderly.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating spawning with patrol behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you haven’t picked up on it already, because we’ve paid attention to the
    project’s code structure and followed good programming practices from the beginning,
    maintaining and extending the code to add new functionality has been simple and
    straightforward. Integrating our new wave spawner to work with the existing patrol
    behavior will also be quick work. We’ll just need to add a few things to set it
    up.
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first, let’s see if the instantiated `Enemy B` Prefab has a patrol
    behavior and, if so, `SetWaypoints()`. To do that, let’s modify the `SpawnEnemy()`
    method in the `EnemySpawner` class. Here you can see we’re again using `TryGetComponent()`
    to fail gracefully if the component doesn’t exist on the enemy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `PatrolWaypoints` class, add the following `SetWaypoints()` method (or,
    again, use the IDE’s refactoring tools to generate it) to allow setting the left
    and right waypoint private variables externally (encapsulation at work):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And, don’t forget: we’ll need to add a `SetWaypoints()` method declaration
    to our `IBehaviorPatrolWaypoints` interface so that it’s accessible from the reference
    in the `EnemySpawner` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Seriously, that’s it – three simple additions get the patrolling behavior all
    wired up to our enemy spawner. You’ll just have to add two empty GameObjects to
    the scene for the patrolling path of this enemy spawner, one for left and one
    for right, and assign them in the **Inspector** window, as seen in the enemy spawner
    setup from *Figure 8**.8*.
  prefs: []
  type: TYPE_NORMAL
- en: However, you’ll notice we have a problem (you playtested, right?). Enemies won’t
    be able to pass each other as they patrol between the waypoints – a simple problem
    to solve by removing their physics interactions with each other. First, we’ll
    need a layer to set the enemy objects to… how about `Enemy`?
  prefs: []
  type: TYPE_NORMAL
- en: Using the **Layers** drop-down menu in the top-right corner of the **Editor**
    window, select **Edit Layers…**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Add an enemy layer](img/B18347_08_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – Add an enemy layer
  prefs: []
  type: TYPE_NORMAL
- en: Under the `Enemy` to add it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can control the physics interactions between enemy objects by specifying
    what collisions are processed by their layer. Using the `Enemy` layer (uncheck
    **Enemy/Enemy**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Physics 2D layer collision matrix](img/B18347_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Physics 2D layer collision matrix
  prefs: []
  type: TYPE_NORMAL
- en: When you playtest the enemy wave spawner in the scene now, the spawned enemies
    will patrol past one another. Awesome!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we created a wave spawner to instantiate new enemies on a fixed
    time interval and integrated it with the existing patrol behavior. We finished
    up by resolving physics interactions between enemy objects to allow them to pass
    each other while patrolling.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the implementation of a health system that any object
    in the game can use to receive damage, heal, and handle the final death/destruction
    of the object. This system was designed using interfaces to tie everything together
    in an extensible way without relying on concrete class references – the flexibility
    of interfaces allowed for the quick addition of new functionality to our existing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: We continued by creating a wave spawner that instantiates new enemies on a fixed
    time interval and integrates with the existing patrol behavior. This allows for
    adding in more complex enemy behavior, which adds new challenges to the game.
    Additionally, we discussed how to disable physics interactions between objects,
    which allowed patrolling enemies to pass each other in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we further explored composition by refactoring some of our reusable
    components to explore a different approach to destroying the heal pickup object.
    Through examples such as this, the importance of good programming practices and
    the use of interfaces to build flexible and extensible systems was highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll complete the adventure game by creating a simple
    quest system for collecting key objects for solving the entryway puzzle. We will
    also introduce a new event system for keeping our code loosely coupled.
  prefs: []
  type: TYPE_NORMAL
