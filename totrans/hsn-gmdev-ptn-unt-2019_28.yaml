- en: The Anti-Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we have reviewed best practices in software architecture
    by implementing various types of patterns. But what you might be asking yourself
    is if those patterns are so beneficial, why doesn't everyone use them? Or why
    do we still regularly see bug-ridden games coming out?
  prefs: []
  type: TYPE_NORMAL
- en: If current-day programmers have easy access to a wealth of information about
    software development best practices, it's reasonable to assume that there should
    be no reasons why we still have issues delivering stable video games and applications
    within reasonable deadlines. But in this chapter, we are going to explore why,
    in the software development industry, even extraordinarily competent and talented
    teams end up producing messy code and are unable to deliver a stable product.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we explored patterns that are designed to be beneficial
    and bring about positive results. But now, we are going to study their evil twins,
    in the form of Anti-Patterns. These destructive patterns are subtle; they don't
    always lurk in your code, but instead hurt you by causing fear, uncertainty, and
    doubt at every level of your organization. And that's why they are so difficult
    to recognize, as we are going to see in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We will be reviewing a list of common anti-patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The anti-patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are probably over one hundred anti-patterns currently documented by experts
    in every field of software development. We won't be able to review them all in
    this chapter, but I have made a short list of those I found that are related to
    the misapplication of design patterns, either directly or indirectly. But I have
    also listed those that I've personally experienced in my career.
  prefs: []
  type: TYPE_NORMAL
- en: The academic research on the subject of anti-patterns is not thoroughly documented
    compared to established design patterns, so there are a lot of discrepancies in
    the naming of specific anti-patterns. As a result, a lot of the following material
    is my interpretation of prevalent anti-patterns and not official definitions.
    So, let's now dive into the subject matter and review some of the most relevant
    anti-patterns that I have experienced, and that I recommend to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: False mastery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"If people knew how hard I worked to get my mastery, it wouldn''t seem so wonderful
    at all."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Michelangelo'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is it?** Programmers have access to a wealth of information, tools,
    and libraries that allow them to develop anything they want with ease. As a consequence,
    these advantages are making a lot of junior developers believe that they are masters
    of their craft when they are merely copying and pasting the work of others.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is it wrong?** Nothing obstructs your ability to learn more than believing
    that you already know everything. This dangerous mindset blinds you to your deficiencies
    and makes you unable to process feedback. As a result, you will never progress,
    and you will end up being a mediocre programmer for the rest of your career, even
    if you hold titles such as senior or technical director.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the root cause?** The leading cause of this premature disillusionment
    of mastery over your craft is that tools such as the Unity engine simplify the
    process of making games to the point that almost anyone can do it. But this means
    few understand what is happening under the hood of the engine in terms of the
    tools or programming language they are using.'
  prefs: []
  type: TYPE_NORMAL
- en: So, by example, just because you can write a program in C# doesn't make you
    a C# expert, but knowing the intricacies of the language's libraries will make
    you into one.
  prefs: []
  type: TYPE_NORMAL
- en: '**How to avoid this?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of professional habits that will help you avoid falling
    into the trap of this Anti-Pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn, learn, and never stop learning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid hunting for titles such as senior, tech lead or CTO, and instead focus
    on gaining true mastery over your craft.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time you use a new tool, library, and language, research as much as possible
    about its origins, as well as its intricacies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Humble yourself every day. Accept that you don't know everything and that it
    will take you several decades to become a true senior programmer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teach, write a blog, and answer technical questions on forums. In other words,
    transfer the knowledge you know as well as absorbing new information. This approach
    will help you validate and structure your learning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Job titles given out in a start-up are not equivalent to those given in a large
    corporation. So don''t be surprised when transitioning out from a small indie
    to a AAA studio that you end up back in a more junior role. The reason is simple:
    it''s harder to gain seniority in a bigger team because you are competing with
    more programmers for better positions.'
  prefs: []
  type: TYPE_NORMAL
- en: Fear of complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Have no fear of perfection – you''ll never reach it."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Salvador Dali'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is it?**'
  prefs: []
  type: TYPE_NORMAL
- en: I personally have been the victim of this anti-pattern for years. It's the result
    of an overzealous belief that simplicity is always the best approach to code and,
    hence, you should avoid any solution that might look slightly more complex as
    the path of least resistance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is it bad?**'
  prefs: []
  type: TYPE_NORMAL
- en: An irrational fear of complexity can prevent you from using sophisticated and
    advanced design patterns or algorithms to resolve issues. Thus, you reduce the
    potential for growth and limit your learning opportunities. Ultimately, it can
    prevent you from reaching maturity and seniority.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the root cause?**'
  prefs: []
  type: TYPE_NORMAL
- en: An earnest belief that the simplest solution is the best path to resolve any
    technical problem. But usually, it is an excuse to avoid doing research and leaving
    your comfort zone.
  prefs: []
  type: TYPE_NORMAL
- en: '**How to avoid?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some questions that you should ask yourself every time you have to
    decide between an easy or complex solution to a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Am I currently feeling engaged in resolving a technical challenge or am I just
    trying to get things done?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Am I afraid of looking stupid by suggesting a more advanced solution to a problem
    because I don't understand it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the simple solution I'm implementing scale with the overall architecture
    of the current code base overtime or does it just patch the problem?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, in summary, always ask yourself this simple question when deciding between
    an easy or a complex solution to a problem: Are you choosing the most accessible
    approach because it''s the right thing to do, or because you''re just lazy and
    can''t be bothered to adopt an advanced method that would require greater effort.'
  prefs: []
  type: TYPE_NORMAL
- en: You often hear programmers say that complexity causes more bugs. This is true
    but, to be more precise, it is unmanaged and misunderstood complexity that results
    in more bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Too many managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"We don''t have as many managers as we should, but we would rather have too
    few than too many."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Larry Page'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is it?**'
  prefs: []
  type: TYPE_NORMAL
- en: Managers are great; they offer a unique interface to a pool of complex sub-systems.
    Because video games are an extensive collection of systems that are constantly
    interacting with one another, having managers as interfaces can be very helpful
    in reducing dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is it wrong?**'
  prefs: []
  type: TYPE_NORMAL
- en: If every class is a manager, you end up with managers being dependent on other
    managers. In other words, managers become sub-systems of other managers until
    you find yourself in the same situation that you were trying to avoid, a spaghetti
    of dependencies. Another negative point is that managers are often implemented
    as singletons, which means that you have global dependencies spread throughout
    your code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a code example that showcases a possible software architecture
    that''s too dependent on Manager classes. If you see something similar in your
    source code, you might need to refactor your architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**What is the root cause?**'
  prefs: []
  type: TYPE_NORMAL
- en: The root cause is usually inexperienced or lazy programmers who don't consider
    the overall architecture of their code base but instead focus on instant results.
  prefs: []
  type: TYPE_NORMAL
- en: '**How to avoid this?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a list of good habits that might help you avoid this anti-pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Every time you are about to use a specific pattern, always consider using an
    alternative that might be more suitable. In other words, avoid defaulting to the
    easiest solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep track of your architecture and the patterns that you are using. Raise a
    flag if you see too many classes with Manager in their title.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are having issues implementing unit tests for your core systems, it's
    a good indication that there's something wrong in your architecture and it might
    be related to having too many singletons or classes that act like global Managers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New patterns, or permutations of established ones, are appearing regularly.
    It's good practice to keep an eye out for them by reading new books on the subject
    matter.
  prefs: []
  type: TYPE_NORMAL
- en: Ravioli code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Organic architecture seeks superior sense of use and a finer sense of comfort,
    expressed in organic simplicity."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Frank Lloyd Wright'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is it?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ravioli code** is the result of overzealous encapsulation and an architecture
    that''s divided into too many individual classes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is it wrong?**'
  prefs: []
  type: TYPE_NORMAL
- en: Most programmers have heard the term *Spaghetti code* during their career. It's
    often used to describe unstructured and messy code that's usually produced by
    junior programmers. But Ravioli code can be considered to be the opposite; it's
    often the result of overly designed code made by programmers who have a lot of
    experience but lack the desire to make their work readable to others.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, navigating and maintaining a code base suffering from those Anti-Patterns
    can become difficult.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the root cause?**'
  prefs: []
  type: TYPE_NORMAL
- en: A religious and dogmatic approach to programming and design patterns can make
    you write code that looks accurate but unreadable to others.
  prefs: []
  type: TYPE_NORMAL
- en: '**How to avoid this?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s some tips that might help you avoid this anti-pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Be willing to sacrifice accuracy for readability when necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always consider that design patterns do give you structure, but often at the
    sacrifice of readability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write code for an audience, and remember that those who might read it might
    not have the same skillset as you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most professional programmers don't consciously use design patterns, often because
    they don't understand them or don't know how to implement them correctly. So,
    to be a great programmer, you have to be more aware than others of all the patterns
    that are available and how to use them properly.
  prefs: []
  type: TYPE_NORMAL
- en: Poltergeist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Indeed, it is better to postpone, lest either we complete too little by hurrying,
    or wander too long in completing it."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Tertullian'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is it?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Poltergeist** objects are usually the result of code that was implemented
    to solve a temporary architecture issue, but that remained in the code base longer
    than it should have.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is it wrong?**'
  prefs: []
  type: TYPE_NORMAL
- en: The density of code that you have to maintain often relates to the frequency
    of bugs you might have to fix every time you make a change. Another side-effect
    of having ghost classes haunting your code base is that it can provoke fear of
    making changes because of what might happen from unknown objects that pop up at
    the wrong moment.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the root cause?**'
  prefs: []
  type: TYPE_NORMAL
- en: Poltergeist objects and classes, which can be called **ghosts**, are the result
    of good intentions going bad. Often, their classes were implemented to solve a
    temporary architectural issue, but the programmer never had the chance to complete
    their design, and thus you end up with objects in memory that are present, but
    their reason for being is not apparent.
  prefs: []
  type: TYPE_NORMAL
- en: '**How to avoid this?** Here are some tips that might help you avoid this anti-pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't use design patterns that you don't fully understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedule weekly code-base reviews and remove deprecated code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use source-control branching strategies to manage the refactoring of significant
    components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add TODO comments in your code and ask your team to review them and take action
    regularly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the documentation before implementing a new architecture so that your
    team can review your plan and give you feedback before you make changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being a minimalist is a good mindset for a programmer. Code can be complicated,
    but it should never be bloated with things that are useless. Focus always on what
    is essential and remove what is not.
  prefs: []
  type: TYPE_NORMAL
- en: Premature optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Perfection is attained by slow degrees; it requires the hand of time."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Voltaire'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is it?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Premature optimization** is the act of optimizing and perfecting your code
    before it''s needed and, as a result, wasting precious production time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is it wrong?**'
  prefs: []
  type: TYPE_NORMAL
- en: Investing more time than needed on optimization is one of the worst ways to
    waste your time and that of your employer. Most devices are getting faster every
    year, and, thus, programmers are less required to optimize their code to run faster
    on limited hardware.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the root cause?**'
  prefs: []
  type: TYPE_NORMAL
- en: A lack of experience is usually the root cause.
  prefs: []
  type: TYPE_NORMAL
- en: '**How to avoid this?**'
  prefs: []
  type: TYPE_NORMAL
- en: Always profile your code before optimizing it. For those who might not know,
    **profiling** is the act of using diagnostic tools that help you analyze the performance
    of your system. Often, you will discover that the performance bottlenecks in your
    code are limited to specific areas in your source code, so by focusing on those,
    you can gain speed without having to refactor your entire code base.
  prefs: []
  type: TYPE_NORMAL
- en: Like a good mechanic, a programmer should have a toolbox filled with tools that
    can help them work faster and better.
  prefs: []
  type: TYPE_NORMAL
- en: Vendor lock-in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"It''s not a faith in technology. It''s faith in people."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Steve Jobs'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is it?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vendor lock-in** happens when you start integrating third-party components,
    plugins, frameworks, or libraries in your code base, but become dependent on them
    to make your code function properly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is it wrong?**'
  prefs: []
  type: TYPE_NORMAL
- en: In the context of a Unity project, being dependent on third-party libraries
    can limit your ability to upgrade to a new version of Unity because you might
    need to wait for patches from the vendor in order to avoid going backward.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the root cause?** Buying Plug and Play components and libraries from
    third-party vendors saves a lot of production time, so it''s very tempting to
    use them to a point where you become too dependent on them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How to avoid this?** You should research a vendor before buying their products
    and integrating them into your code base. For example, if they are not updating
    their support forums, it might be an indication that they are not planning to
    release updates shortly, and this might limit your capacity to get immediate support
    if required.'
  prefs: []
  type: TYPE_NORMAL
- en: As a Unity developer, you should always check the Unity Asset store before writing
    anything because there's probably someone who has already done what you want to
    do, but in a better way.
  prefs: []
  type: TYPE_NORMAL
- en: Management by numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is it?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Managing by numbers** is the tendency to take management decisions based
    heavily on statistics that are generated by tools, such as Excel spreadsheets
    or reports, rather than on an accurate analysis of what is going on in a project.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is it wrong?**'
  prefs: []
  type: TYPE_NORMAL
- en: Numbers expressed in productivity reports often don't mirror the quality or
    the potential of a team. They can hide issues that are provoked by dynamic human
    interactions, instead of exposing them. This focus on numbers can blind project
    managers during critical decision-making processes. In other words, can you define
    the level of productivity of a programmer by the amount of bugs they fix in a
    week? The answer is *no*, because the complexity of a particular bug is not a
    constant. You can't evaluate a programmer who fixes five simple bugs in a week
    the same way as another programmer who resolves a single but very complex one
    in the same period.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the root cause?**'
  prefs: []
  type: TYPE_NORMAL
- en: Numbers are easy to explain and justify, especially when communicating with
    higher management that doesn't have the technical expertise to evaluate a project
    beyond very general indicators. This approach can result in an organization that
    spends its time focusing on figures instead of actual results.
  prefs: []
  type: TYPE_NORMAL
- en: '**How to avoid this?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Senior programmers should challenge project managers who are using general
    statistics and numbers to evaluate the progress of a project by offering more
    concrete indicators of quality and improvement. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: Update versus downtime of services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rate of bugs found and fixed over time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Probably the most critical thing you can do to guarantee yourself a long career
    in the tech industry after you hit 40 is to go back to school and get a diploma
    or certification in management. This type of education will permit you to transition
    into a long-term leadership role, which companies will probably encourage you
    to consider after you have attained several decades of experience.
  prefs: []
  type: TYPE_NORMAL
- en: The technical interview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"I choose a lazy person to do a hard job. Because a lazy person will find an
    easy way to do it."'
  prefs: []
  type: TYPE_NORMAL
- en: -Bill Gates
  prefs: []
  type: TYPE_NORMAL
- en: '**What is it?**'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a technical interview in the hiring process of a programmer might
    not sound like an anti-pattern in itself, but I'm proposing that it is, and one
    that has side-effects in the quality of source code produced by a team. For those
    who have never experienced a programmer technical interview, it involves a series
    of tests that are given to the candidate to validate their skills and knowledge.
    The exams may include writing answers about programming on a whiteboard, a piece
    of paper, or in an online test environment. I consider the technical interview
    an industry-wide anti-pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is it wrong?** The core issue of the technical interview process is that
    you can only test for what you already know. Thus, you will end up recruiting
    candidates who are mirror images of yourself. As a result, you will end up building
    a team that lacks a range of different skills. This approach is valid if your
    only goal is to have a very specialized team, but this is a rare case. Most companies
    need to have employees with varied skillsets to balance out any weaknesses in
    the organization.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if your subject of focus of your technical interview revolves around
    data structures because this is your strength as the interviewer, then you might
    end up eliminating candidates who are weaker in that area but stronger in other areas,
    such as design patterns. But because you are evaluating only on what you consider
    to be important, based on your technical bias, you might miss out on hiring candidates
    who could bring new skills to your team.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the root cause?** The main reason why the hiring process of programmers
    is so inconsistent throughout our industry is that few people understand what
    programmers do and how to evaluate them as candidates. So, hiring managers prefer
    to judge applicants by their final technical test scores, thereby reducing the
    value of a candidate to a single number.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also some types of interviewer behavior patterns or processes that
    may also be part of the root cause:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Riddler**: A riddler is an interviewer who wants to test the skills of
    a candidate by asking questions in the form of clever puzzles. This approach often
    ends up confusing most candidates and turning the interview process into a stressful
    game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Hot Seat**: The infamous hot seat interview type is similar to a police
    interrogation with the goal of isolating a candidate''s weaknesses and strengths
    with a rapid succession of questions. Often, one interviewer will take the role
    of the *bad cop* by being more aggressive in their questioning, while another
    plays the *good cop* to assist the candidate if they take too long to answer some
    questions. This approach ends up burning out the candidate or forcing them to
    answer in a way that they think is what the interviewers want to hear. This is
    not a suitable method to learn about the potential of a candidate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Whiteboard**: The whiteboard interview consists of having the candidate
    answer technical questions by writing their answer on a whiteboard. There''s a
    particular issue with this method of evaluating candidates; most programmers never
    write code on paper or whiteboards during their career, so when forced to do so
    during a stressful situation such as an interview will result in a lot of false
    negatives about their actual skill level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How to avoid this?** Almost everyone agrees that hiring good programmers
    is a costly and challenging process, but this means that you need to be more creative
    in the way you approach technical interviews, so you don''t end up rejecting excellent
    candidates for ones who are just clones of who you already have in your team.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some tips that can help you avoid this anti-pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Try to see what is unique and valuable in a candidate. Get a candidate who can
    teach you and your team something new.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't probe for weaknesses. Instead, try to understand a candidate's strengths
    and see whether they balance with their potential weaknesses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always take into consideration the fact that there's a variety of skills that
    a programmer might have in the industry, depending on their specialization. For
    example, the average web developer might not be as strong at math as a 3D programmer,
    but they might be better at normalizing databases or designing client-server applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a candidate fails to answer a technical question, ask yourself whether
    this is because they don't understand it, might not have the skills to do so,
    or might be too nervous because of the examination process. In other words, the
    context of the interview is important, not just the final score, when evaluating
    the actual skill level of an applicant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if you are a very experienced professional programmer, you should never
    underestimate the potential difficulty of a modern-day technical interview process.
    Your years of experience might be a disadvantage because interviewers usually
    want to evaluate whether you still know your computer science basics. In other
    words, you might have to answer questions about subjects that you might not have
    reviewed since university. So it's a good idea to dust off those old school books
    and study the basics before going into an interview.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have arrived at the end of our journey. Throughout this book, we explored
    various design patterns, each with their unique abilities. The most important
    takeaway from this book is that before you start writing a single line of code,
    you should always verify whether there's a pattern that matches the design intention
    of a system before building it. This approach avoids reinventing the wheel and
    offers you a consistent methodology to programming that will help you throughout
    your career.
  prefs: []
  type: TYPE_NORMAL
- en: But this chapter also exposes that what looks like a valid design or management
    decision can quickly go wrong without awareness of the motivations and potential
    consequences behind it. In other words, as programmers, we need to be mindful
    of the potential implications of our decisions, at every level, or we can fall
    victim to Anti-Patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our final exercise, I'm making you a list of daily habits that will ensure
    a long and prosperous career as a programmer in the game industry. However, a
    failure to enhance your skills gradually will almost guarantee that you will end
    up getting stuck in mediocrity and possibly irrelevance. Trust me; it happened
    to me until, one day, I decided to change my habits and focus again on gaining
    true mastery over my craft.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some good habits to form:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn at least one new programming language per year.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check your skills regularly by taking practice-interview programming exams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attain a new technical certification every year, such as the PMP, CCNA, and
    CEH.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a list of all your weaknesses as a programmer and work on them every day.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to attend at least one technology-related meet-up event or conference per
    week.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join technical professional organizations, such as ACM and IEEE, and use the
    resources on offer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep yourself up to date in terms of what's happening by reading tech and game
    industry news every day.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take courses on subjects from other fields that might be related to yours, including
    management, UI design, and animation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make yourself a list of blogs and YouTube channels that are related to technology
    and programming. Read at least one blog post and watch a video per day.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attend a coding bootcamp or subscribe to at least one training program per month.
    Don't forget to complete them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read at least two books about programming or related fields per year.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open a GitHub account and contribute to at least one open source project, even
    if it's just a couple of lines of code. Get used to the process and the community.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn meditation; it's a stressful job; knowing how to stay calm under pressure
    will help you maintain your mental health and avoid burning out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our final exercise, I would recommend that you make a list of your favorite
    patterns and ask yourself why you like them. Is it because they're easy to implement,
    or because they resolve actual architectural issues in your code? In other words,
    make sure that you don't use a specific pattern for the wrong reasons, never be
    lazy, and always be conscious with your choices when writing code.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Organizations**:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ACM*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.acm.org](https://www.acm.org)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*IEEE*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.ieee.org](https://www.ieee.org)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Blogs**:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Coding Horror*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://blog.codinghorror.com](https://blog.codinghorror.com)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Joel on Software*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.joelonsoftware.com](https://www.joelonsoftware.com)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Scott Hanselman Blog*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.hanselman.com/blog/](https://www.hanselman.com/blog/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*The Crazy Programmer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.thecrazyprogrammer.com](https://www.thecrazyprogrammer.com)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**YouTube**:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Computerphile*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/user/Computerphile](https://www.youtube.com/user/Computerphile)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Success in Tech*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/channel/UC-vYrOAmtrx9sBzJAf3x_xw](https://www.youtube.com/channel/UC-vYrOAmtrx9sBzJAf3x_xw)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*TED*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/user/TEDtalksDirector](https://www.youtube.com/user/TEDtalksDirector)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*TechLead*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/channel/UC4xKdmAXFh4ACyhpiQ_3qBw](https://www.youtube.com/channel/UC4xKdmAXFh4ACyhpiQ_3qBw)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Tech news**:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Slashdot*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://slashdot.org](https://slashdot.org)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Wired*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.wired.com](https://www.wired.com)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Gamasutra*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.gamasutra.com](http://www.gamasutra.com)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: GamesIndustry.biz
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.gamesindustry.biz](https://www.gamesindustry.biz)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Online courses**:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Udemy*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.udemy.com](https://www.udemy.com)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Lynda*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.lynda.com](https://www.lynda.com)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Pluralsight*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.pluralsight.com](https://www.pluralsight.com)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: MasterClass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.masterclass.com](https://www.masterclass.com)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Books**:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anti-patterns: Managing Software Organizations and People*, by Colin J. Neill,
    Philip A. Laplante, and Joanna F. DeFranco [https://www.crcpress.com/Antipatterns-Managing-Software-Organizations-and-People-Second-Edition/Neill-Laplante-DeFranco/p/book/9781439861868](https://www.crcpress.com/Antipatterns-Managing-Software-Organizations-and-People-Second-Edition/Neill-Laplante-DeFranco/p/book/9781439861868)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
