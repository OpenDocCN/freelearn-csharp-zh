- en: '*Chapter 9*: Working with Concurrent Collections in .NET'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will dive deeper into some of the `System.Collections.Concurrent`
    namespace. These specialized collections help to preserve data integrity when
    using concurrency and parallelism in your C# code. Each section of this chapter
    will provide practical examples of how to use a specific concurrent collection
    provided by .NET.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen some basic use of parallel data structures in .NET. We have already
    covered the basics of each of the concurrent collections in the *Introduction
    to concurrency* section of [*Chapter 2*](B18552_02_ePub.xhtml#_idTextAnchor034).
    So, we will quickly jump into the examples of their use in this chapter and learn
    more about their application and inner workings.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `BlockingCollection`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ConcurrentBag`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ConcurrentDictionary`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ConcurrentQueue`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ConcurrentStack`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a deeper understanding of how these
    collections protect your shared data from being mishandled while multithreading.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples in this chapter, the following software is
    recommended for Windows developers:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 version 17.0 or later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET 6.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To complete any WinForms or WPF samples, you will need to install the .NET desktop
    development workload for Visual Studio. These projects will run only on Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these are recommended, if you have .NET 6 installed, you can use your
    preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later,
    JetBrains Rider, or Visual Studio Code will work just as well.
  prefs: []
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started by learning more about `BlockingCollection<T>` and walk through
    a sample project that leverages the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Using BlockingCollection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`BlockingCollection<T>` is one of the most useful concurrent collections. As
    we saw in [*Chapter 7*](B18552_07_ePub.xhtml#_idTextAnchor120), `BlockingCollection<T>`
    was created to be an implementation of the **producer/consumer pattern** for .NET.
    Let’s review some of the specifics of this collection before creating a different
    kind of sample project.'
  prefs: []
  type: TYPE_NORMAL
- en: BlockingCollection details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the major draws of `BlockingCollection<T>` for developers working with
    parallel code implementations is that it can be swapped to replace `List<T>` without
    too many additional modifications. You can use the `Add()` method for both. The
    difference with `BlockingCollection<T>` is that calling `Add()` to add an item
    will block the current thread if another read or write operation is in process.
    If you want to specify a timeout period on the operation, you can use `TryAdd()`.
    The `TryAdd()` method optionally supports both timeouts and cancellation tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing items from `BlockingCollection<T>` with `Take()` has an equivalent
    `TryTake()`, which allows timed operations and cancellation. The `Take()` and
    `TryTake()` methods will take and remove the first remaining item that was added
    to the collection. This is because the default underlying collection type within
    `BlockingCollection<T>` is `ConcurrentQueue<T>`. Alternatively, you can specify
    that the collection uses `ConcurrentStack<T>`, `ConcurrentBag<T>`, or any collection
    that implements the `IProducerConsumerCollection<T>` interface. Here’s an example
    of `BlockingCollection<T>` being initialized to use `ConcurrentStack<T>`, with
    its capacity limited to `100` items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If your application needs to iterate over the items in `BlockingCollection<T>`,
    the `GetConsumingEnumerable()` method can be used in a `for` or `foreach` loop.
    However, keep in mind that this iteration over the collection is also removing
    items, and it will complete the collection if the enumeration continues until
    the collection is empty. This is the *consuming* part of the `GetConsumingEnumerable()`
    method name.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to use multiple `BlockingCollection<T>` classes of the same type,
    you can add to or take from them as one by adding them to an array. An array of
    `BlockingCollection<T>` makes the `TryAddToAny()` and `TryTakeFromAny()` methods
    available. These methods will succeed if any of the collections in the array are
    in the proper state to accept or provide objects to the calling code. Microsoft
    Docs has an example of how to use an array of `BlockingCollection<T>` in a pipeline:
    https://docs.microsoft.com/dotnet/standard/collections/thread-safe/how-to-use-arrays-of-blockingcollections.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the details needed to understand `BlockingCollection<T>`,
    let’s dive into a sample project.
  prefs: []
  type: TYPE_NORMAL
- en: Using BlockingCollection with Parallel.ForEach and PLINQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already covered an example that implements the producer/consumer pattern
    in [*Chapter 7*](B18552_07_ePub.xhtml#_idTextAnchor120), so let’s try something
    a little different in this section. We are going to create a WPF application that
    loads the contents of a book from a 1.5 MB text file and searches for words that
    start with a particular letter:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This sample uses a .NET Standard NuGet package created from a Microsoft extension
    sample that was originally built on .NET Framework 4.0\. The extension is called
    `ParallelExtensionsExtras`, and the original source is available on GitHub: https://github.com/dotnet/samples/tree/main/csharp/parallel/ParallelExtensionsExtras.
    The extension method that we will be using from the package makes `Parallel.ForEach`
    operations and PLINQ queries run more efficiently with concurrent collections.
    To read more about the extensions, you can check out this post on the *.NET Parallel
    Programming* blog: https://devblogs.microsoft.com/pfxteam/parallelextensionsextras-tour-4-blockingcollectionextensions/.'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new WPF application in Visual Studio. Name the project `ParallelExtras.BlockingCollection`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the NuGet Package Manager page, search for and add the latest stable version
    of the **ParallelExtensionsExtras.NetFxStandard** package to your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The ParallelExtensionsExtras.NetFxStandard NuGet package ](img/Figure_9.1_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – The ParallelExtensionsExtras.NetFxStandard NuGet package
  prefs: []
  type: TYPE_NORMAL
- en: We are going to read text from the book *Ulysses* by James Joyce. This book
    is public domain in the United States and most countries around the world. It
    can be downloaded in UTF-8 plain text format from `ulysses.txt`, and place it
    in the main folder with your other project files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, right-click `ulysses.txt` and select **Properties**. In the
    **Properties** window, update the **Copy to Output Directory** property to **Copy
    if newer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `Grid.RowDefinitions` and `Grid.Columndefinitions` to the `Grid` control,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `ComboBox` and `Button` inside the `Grid` definition following the `Grid.ColumnDefinitions`
    element. These controls will be in the first row of `Grid`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ComboBox` will contain nine different letters from which to choose. You can
    add as many of these as you like. `Button` contains a `Click` event handler that
    we will add to `MainWindow.xaml.cs` soon.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add `ListView` named `WordsListView` to the second row of `Grid`.
    It will span both of the columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open `MainWIndow.xaml.cs`. The first thing we will do here is to create
    a method named `LoadBookLinesFromFile()`, which reads each line of text from `ulysses.txt`
    into `BlockingCollection<string>`. There is only a single thread reading from
    the file, so using the `Add()` method instead of `TryAdd()` is best:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember, it is important to call `lines.CompleteAdding()` before the end of
    the method. Otherwise, subsequent queries of this collection will hang and continue
    waiting for more items to be added to the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a method named `GetWords()` that takes the lines from the text
    file and uses a `BlockingCollection<string>`. In this method, we’re parsing multiple
    lines simultaneously with a `Parallel.ForEach` loop. The `GetConsumingPartitioner()`
    extension method, which tells the `Parallel.ForEach` loop that `BlockingCollection`
    will be doing its own blocking, so the loop does not need to do any. This makes
    the whole process more efficient:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `TrimSuffix()` method will remove specific characters from the end of a
    word; in this case, we’re passing the apostrophe character to be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are unfamiliar with regular expressions, you can read about how to use
    them with .NET on Microsoft Docs: [https://docs.microsoft.com/dotnet/standard/base-types/regular-expressions](https://docs.microsoft.com/dotnet/standard/base-types/regular-expressions).
    They are an extremely efficient way to parse text.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a method named `GetWordsByLetter()` to call the other methods
    we just created. Once `BlockingCollection<string>` containing all the words from
    the book has been fetched, this method will use PLINQ and `GetConsumingPartitioner()`
    to find all words that start with the uppercase or lowercase versions of the selected
    letter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we’ll add the `Button_Click` event to kick off the loading, parsing,
    and querying of the book’s text. Don’t forget to mark the event handler as `async`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `GetComboBoxValue()` helper method will take the object from `LettersComboBox.SelectedValue`
    and find `string` with the selected letter within.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `using` declarations are required in `MainWindow.xaml.cs` to
    compile and run the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the project, select a letter, and click **Load Words**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Displaying words that begin with T from ulysses.txt ](img/Figure_9.2_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Displaying words that begin with T from ulysses.txt
  prefs: []
  type: TYPE_NORMAL
- en: The whole process runs very quickly considering the book contains over 275,000
    total words. Try adding some sorting to the PLINQ query and see how the performance
    is impacted.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue by learning about `ConcurrentBag<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Using ConcurrentBag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ConcurrentBag<T>` is an unordered collection of objects that can be safely
    added, peeked at, or removed concurrently. Keep in mind that, as with all of the
    concurrent collections, the methods exposed by `ConcurrentBag<T>` are thread-safe,
    but any extension methods are not guaranteed to be safe. Always implement your
    own synchronization when leveraging them. To review a list of safe methods, you
    can review this Microsoft Docs page: https://docs.microsoft.com/dotnet/api/system.collections.concurrent.concurrentbag-1#methods.'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a sample application that simulates working with a pool
    of objects. This scenario can be useful if you have some processing that leverages
    a stateful object that is memory-intensive. You want to minimize the number of
    objects created but cannot reuse one until the previous iteration has finished
    using it and returned it to the pool.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we will use a mocked-up PDF processing class that is assumed
    to be memory-intensive. In reality, document-processing libraries can be quite
    heavy, and they often rely on document states in each instance. The console application
    will iterate in parallel 15 times to create these fake PDF objects and append
    some text to each of them. Each time through the loop, we will output the text
    contents and the current count of PDF processors in the pool. If the current count
    remains low, then the application is working as intended:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new .NET console application in Visual Studio named `ConcurrentBag.PdfProcessor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class to represent the mocked-up PDF data. Name the class `ImposterPdfData`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are storing the plain text and an ASCII-encoded version of the text that
    we will pretend is PDF format. This avoids implementing any third-party libraries
    in our sample application. If you have any PDF libraries with which you are familiar,
    you are welcome to adapt this sample to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a new class named `PdfParser`. This class will be the one that is
    taken from and returned to `ConcurrentBag<PdfParser>`. We will create the host
    for that collection in an upcoming step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This stateful class holds an instance of an `ImposterPdfData` object and can
    return the data as a string or the ASCII-encoded byte array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a method to `PdfParser` named `AppendString`. This method will add some
    additional text to `ImposterPdfData` on a new line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a class named `PdfWorkerPool`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Be sure to also add a `using System.Collections.Concurrent;` statement to `PdfWorkerPool.cs`.
    The pool stores `ConcurrentBag<PdfParser>` named `_workerPool`. When `PdfWorkerPool`
    is initialized, it adds a new instance to `_workerPool`. The `Get` method will
    return an existing instance from the pool with `TryTake` if one exists. If the
    pool is empty, a new instance is created and returned to the caller. The `Return`
    method adds `PdfParser` back to the pool when the consumer is finished. We will
    use the `WorkerCount` property to track the number of objects in the pool at any
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, replace the contents of `Program.cs` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After creating a new `PdfWorkerPool`, we’re using a `Parallel.For` loop to iterate
    15 times. Each time through the loop, we get `PdfParser`, set the text, append
    `DateTime.UtcNow`, and write the contents to the console, along with the current
    count of parsers in the pool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application and examine the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Running the PdfProcessor console application ](img/Figure_9.3_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Running the PdfProcessor console application
  prefs: []
  type: TYPE_NORMAL
- en: In my case, the parser count got to a maximum number of seven. If you tweak
    the `Task.Delay` intervals or remove them entirely, you are likely to see the
    count never exceed one. This kind of pool can be configured to be very efficient.
  prefs: []
  type: TYPE_NORMAL
- en: This application is an example where we do not care which instance of the collection
    is returned, so `ConcurrentBag<T>` is a perfect choice. In the next section, we
    will create a drug lookup example using `ConcurrentDictionary<TKey, TValue>`.
  prefs: []
  type: TYPE_NORMAL
- en: Using ConcurrentDictionary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create a WinForms application to load United States
    `ConcurrentDictionary`, we can perform fast lookups with a `product.txt` file
    and moved about half of the records to a `product2.txt` file, duplicating the
    header row in the second file. You can get these files in the GitHub repository
    for the chapter at [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/FdaNdcDrugLookup](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/FdaNdcDrugLookup):'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new WinForms project in Visual Studio targeting .NET 6\.
    Name the project `FdaNdcDrugLookup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the WinForm designer for `Form1.cs`. Lay out two `TextBox` controls, two
    `Button` controls, and `Label`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The layout of Form1.cs ](img/Figure_9.4_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – The layout of Form1.cs
  prefs: []
  type: TYPE_NORMAL
- en: The `btnLoad` and `txtNdc`. The `btnLookup`, `txtDrugName` and **ReadOnly**
    – **True**.
  prefs: []
  type: TYPE_NORMAL
- en: Next, add the `product.txt` and `product2.txt` files to your project by right-clicking
    the project in **Solution Explorer** and choosing **Add** | **Existing Item**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Properties** panel, change **Copy to Output Directory** to **Copy if
    newer** for both of the text files we just added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class to the project named `Drug` and add the following implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will contain the data for each record loaded from the NDC drug files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a class to the project named `DrugService` and begin with the following
    implementation. To start, we only have `private` `ConcurrentDictionary<string,
    Drug>`. We will add a method to load the data in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add a public method to `DrugService` named `LoadData`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we are loading data from the provided `fileName` to `StreamReader`,
    adding the column headers to `DataTable`, populating its rows from the file, and
    then iterating over the rows and columns of `DataTable` to create `Drug` objects.
    Each `Drug` object is added to `ConcurrentDictionary` with a call to `TryAdd`,
    using the `Ndc` property as the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a `GetDrugByNdc` method to `DrugService` to complete the class. This
    method will return `Drug` for the provided `ndcCode`, if found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the code for `Form1.cs` and add a private variable for the `DrugService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the designer for `Form1.cs` and double-click the `btnLoad_Click` event
    handler. Add the following implementation. Note that we made the `async` event
    handler to allow us to use the `await` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To load the two text files, we are creating two tasks to run in parallel before
    using `Task.WhenAll` to await them both. Then, we can safely enable the `btnLookup`
    button and disable the `btnLoad` button to prevent a second load.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, switch back to the designer view for `Form1.cs` and double-click the
    `btnLookup_Click` event handler. Add the following implementation to that handler
    to find a drug name based on the NDC code entered in the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the application and click the `70518-1120` NDC code. Click **Lookup
    Drug**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Looking up the drug Prednisone by its NDC code ](img/Figure_9.5_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Looking up the drug Prednisone by its NDC code
  prefs: []
  type: TYPE_NORMAL
- en: 'Try some other NDC codes and see how quickly each record loads. Here are a
    few random NDC codes taken from each file. If they all succeed, you know that
    both files loaded successfully in parallel: **0002-0800**, **0002-4112**, **43063-825**,
    and **51662-1544**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s it! You now have your own quick-and-dirty drug lookup application. Try
    replacing the drug name `TextBox` with `DataGrid` on your own to display an entire
    `Drug` record.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will work with customer orders in `ConcurrentQueue<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Using ConcurrentQueue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create a sample project that is a simplified version
    of a realistic scenario. We are going to create an order queuing system using
    `ConcurrentQueue<T>`. This application will be a console application that enqueues
    orders for two customers in parallel. We will create five orders for each customer,
    and to mix up the order of the queue, each customer queuing process will use a
    different `Task.Delay` between calls to `Enqueue`. The final output should show
    a mix of orders dequeued for the first customer and the second customer. Remember
    that `ConcurrentQueue<T>` employs **first in, first out** (**FIFO**) logic:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by opening Visual Studio and creating a .NET console application
    named `ConcurrentOrderQueue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class to the project named `Order`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a new class named `OrderService` containing a private `ConcurrentQueue<Order>`
    named `_orderQueue`. This class is where we will enqueue and dequeue orders for
    our two customers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s start with the implementation of `DequeueOrders`. In this method, we
    will use a `while` loop to call `TryDequeue` until the collection is empty, adding
    each order to `List<Order>` to be returned to the caller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will create public and private `EnqueueOrders` methods. The public
    parameterless method will call the private method twice, once for each `customerId`.
    The two calls will be made in parallel, followed by a `Task.WhenAll` call to await
    them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The private `EnqueueOrders` method iterates five times to create and `Enqueue`
    orders for the given `customerId`. This is also used to vary `ItemName`, `ItemQty`,
    and the duration of `Task.Delay`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, open `Program.cs` and add the following code to enqueue and dequeue
    the orders, and output the resulting list to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program and view the list of orders in the output. How does yours match
    up?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Viewing the output of the order queue ](img/Figure_9.6_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Viewing the output of the order queue
  prefs: []
  type: TYPE_NORMAL
- en: Try varying the delay factor or changing `customerId` for one or both customers
    in the `EnqueueOrders` method to see how the order of the output changes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the final section of the chapter, we will perform a quick experiment
    with the `ConcurrentStack<T>` collection.
  prefs: []
  type: TYPE_NORMAL
- en: Using ConcurrentStack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to experiment with `BlockingCollection<T>` and
    `ConcurrentStack<T>`. In the first example in this chapter, we used `BlockingCollection<T>`
    to read the words that started with a specific letter from the book *Ulysses*.
    We are going to make a copy of that project and change the code that reads the
    lines of text to use `ConcurrentStack<T>` inside `BlockingCollection<T>`. This
    will make the lines output in reverse order because a stack uses **last in, first
    out** (**LIFO**) logic. Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Make a copy of the **ParallelExtras.BlockingCollection** project from this chapter
    or modify the existing project if you prefer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `MainWindow.xaml.cs` and modify the `LoadBookLinesFromFile` method to
    pass a new `ConcurrentStack<string>` to the constructor of `BlockingCollection<string>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that the preceding method was truncated to emphasize the modified code.
    View the complete method on GitHub: [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ParallelExtras.ConcurrentStack](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ParallelExtras.ConcurrentStack).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you run the application and search for the same letter as before
    (in our case, `T`), you will see a different set of words at the beginning of
    the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Searching for words that start with T in Ulysses ](img/Figure_9.7_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Searching for words that start with T in Ulysses
  prefs: []
  type: TYPE_NORMAL
- en: If you scroll to the bottom of the list, you should see the words from the beginning
    of the book. Note that the list is not completely reversed because we didn’t use
    `ConcurrentStack<string>` when parsing the words from each line. You can try this
    on your own as another experiment.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our tour of the .NET concurrent collections. Let’s wrap up by
    summarizing what we have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved into five of the collections in the `System.Collections.Concurrent`
    namespace. We created five sample applications in the chapter to get some hands-on
    experience with each of the concurrent collection types available in .NET 6\.
    Through a mix of WPF, WinForms, and .NET console application projects, we examined
    some real-world methods of leveraging these collections in your own applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the rich set of tools provided by Visual
    Studio for multithreaded development and debugging. We will also discuss some
    techniques for analyzing and improving the performance of parallel .NET code.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which concurrent collection can implement different types of collections under
    the covers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the default internal collection type implemented by the collection in
    question 1?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which collection type is frequently used as an implementation of the producer/consumer
    pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which concurrent collection contains key/value pairs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method is used to add values to `ConcurrentQueue<T>`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which methods are used to add and get items in `ConcurrentDictionary`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are extension methods used with the concurrent collections thread-safe?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
