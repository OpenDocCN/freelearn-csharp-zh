<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer218">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 class="chapterTitle" id="_idParaDest-216"><span class="koboSpan" id="kobo.2.1">Applying a Microservice Architecture to Your Enterprise Application</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">This chapter is dedicated to describing highly scalable architectures based on small modules called microservices. </span><span class="koboSpan" id="kobo.3.2">The microservice architecture allows for fine-grained scaling operations where every single module can be scaled as required without affecting the remainder of the system. </span><span class="koboSpan" id="kobo.3.3">Moreover, they allow for better </span><strong class="keyWord"><span class="koboSpan" id="kobo.4.1">Continuous Integration/Continuous Deployment</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.6.1">CI/CD</span></strong><span class="koboSpan" id="kobo.7.1">) by permitting every system subpart to evolve and be deployed</span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.8.1"> independently of the others.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.9.1">In this chapter, we will cover the following topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">What are microservices?</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">When do microservices help?</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">How does .NET deal with microservices?</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Which tools are needed to manage microservices?</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.14.1">By the end of this chapter, you will have learned how to implement a single microservice in .NET. </span><em class="chapterRef"><span class="koboSpan" id="kobo.15.1">Chapter 20</span></em><span class="koboSpan" id="kobo.16.1">, </span><em class="italic"><span class="koboSpan" id="kobo.17.1">Kubernetes</span></em><span class="koboSpan" id="kobo.18.1">, also explains how to deploy, debug, and manage a whole microservices-based application. </span><em class="chapterRef"><span class="koboSpan" id="kobo.19.1">Chapter 14</span></em><span class="koboSpan" id="kobo.20.1">, </span><em class="italic"><span class="koboSpan" id="kobo.21.1">Implementing Microservices with .NET</span></em><span class="koboSpan" id="kobo.22.1">, and </span><em class="chapterRef"><span class="koboSpan" id="kobo.23.1">Chapter 18</span></em><span class="koboSpan" id="kobo.24.1">, </span><em class="italic"><span class="koboSpan" id="kobo.25.1">Implementing Frontend Microservices with ASP.NET Core,</span></em><span class="koboSpan" id="kobo.26.1"> are step-by-step guides to the practical implementation of microservices with .NET.</span></p>
<h1 class="heading-1" id="_idParaDest-217"><span class="koboSpan" id="kobo.27.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.28.1">The code for this chapter is available at </span><a href="https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E"><span class="url"><span class="koboSpan" id="kobo.29.1">https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E</span></span></a><span class="koboSpan" id="kobo.30.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.31.1">In this chapter, you will require the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.32.1">Visual Studio 2022 free Community Edition or better with all the database tools installed.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.33.1">A free Azure account. </span><span class="koboSpan" id="kobo.33.2">The </span><em class="italic"><span class="koboSpan" id="kobo.34.1">Creating an Azure account</span></em><span class="koboSpan" id="kobo.35.1"> section in </span><em class="chapterRef"><span class="koboSpan" id="kobo.36.1">Chapter 1</span></em><span class="koboSpan" id="kobo.37.1">, </span><em class="italic"><span class="koboSpan" id="kobo.38.1">Understanding the Importance of Software Architecture</span></em><span class="koboSpan" id="kobo.39.1">, explains how to create one.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.40.1">Docker Desktop for Windows</span></strong><span class="koboSpan" id="kobo.41.1"> if you want to debug Docker containerized microservices in Visual Studio (</span><a href="https://www.docker.com/products/docker-desktop"><span class="url"><span class="koboSpan" id="kobo.42.1">https://www.docker.com/products/docker-desktop</span></span></a><span class="koboSpan" id="kobo.43.1">).</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.44.1">In turn, </span><strong class="keyWord"><span class="koboSpan" id="kobo.45.1">Docker Desktop for Windows</span></strong><span class="koboSpan" id="kobo.46.1"> requires at least Windows 10 with either </span><strong class="keyWord"><span class="koboSpan" id="kobo.47.1">Windows Subsystem for Linux </span></strong><span class="koboSpan" id="kobo.48.1">(</span><strong class="keyWord"><span class="koboSpan" id="kobo.49.1">WSL</span></strong><span class="koboSpan" id="kobo.50.1">) or </span><strong class="keyWord"><span class="koboSpan" id="kobo.51.1">Windows Containers</span></strong><span class="koboSpan" id="kobo.52.1"> installed.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.53.1">WSL</span></strong><span class="koboSpan" id="kobo.54.1"> enables Docker containers to run on a Linux virtual machine and can be installed as follows (see also </span><a href="https://learn.microsoft.com/en-us/windows/wsl/install"><span class="url"><span class="koboSpan" id="kobo.55.1">https://learn.microsoft.com/en-us/windows/wsl/install</span></span></a><span class="koboSpan" id="kobo.56.1">):</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.57.1">Type </span><code class="inlineCode"><span class="koboSpan" id="kobo.58.1">powershell</span></code><span class="koboSpan" id="kobo.59.1"> in the Windows 10/11 search bar.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.60.1">When </span><strong class="screenText"><span class="koboSpan" id="kobo.61.1">Windows PowerShell</span></strong><span class="koboSpan" id="kobo.62.1"> is proposed as a search result, click on </span><strong class="screenText"><span class="koboSpan" id="kobo.63.1">Run as an administrator</span></strong><span class="koboSpan" id="kobo.64.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.65.1">In the Windows PowerShell administrative console that appears, run the command </span><code class="inlineCode"><span class="koboSpan" id="kobo.66.1">wsl --install</span></code><span class="koboSpan" id="kobo.67.1">.</span></li>
</ol>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.68.1">Windows Containers</span></strong><span class="koboSpan" id="kobo.69.1"> enable Docker containers to run directly on Windows, but they require at least the Windows Professional edition. </span><span class="koboSpan" id="kobo.69.2">They can be installed as follows:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.70.1">Type </span><code class="inlineCode"><span class="koboSpan" id="kobo.71.1">Windows features</span></code><span class="koboSpan" id="kobo.72.1"> in the Windows 10/11 search bar.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.73.1">The search results will propose running the panel to enable/disable Windows features.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.74.1">Click on it, and in the window that opens, select </span><strong class="screenText"><span class="koboSpan" id="kobo.75.1">Containers</span></strong><span class="koboSpan" id="kobo.76.1">.</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-218"><span class="koboSpan" id="kobo.77.1">What are microservices?</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.78.1">Microservices are essentially</span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.79.1"> small, independent units that make up a larger software application, each with its specific role and functionality. </span><span class="koboSpan" id="kobo.79.2">Splitting a software application into independent microservices allows each module that makes up a solution to be scaled independently from the others to achieve the maximum throughput with minimal cost. </span><span class="koboSpan" id="kobo.79.3">In fact, scaling whole systems instead of their current bottlenecks inevitably results in a remarkable waste of resources, so fine-grained control of subsystem scaling has a considerable impact on the system’s overall cost.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.80.1">However, microservices</span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.81.1"> are more than scalable components – they are software building blocks that can be developed, maintained, and deployed independently of each other. </span><span class="koboSpan" id="kobo.81.2">Splitting development and maintenance among modules that can be independently developed, maintained, and deployed improves the overall system’s CI/CD cycle (CI/CD was described in detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.82.1">Chapter 8</span></em><span class="koboSpan" id="kobo.83.1">, </span><em class="italic"><span class="koboSpan" id="kobo.84.1">Understanding DevOps Principles and CI/CD</span></em><span class="koboSpan" id="kobo.85.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.86.1">The CI/CD improvement</span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.87.1"> is due to microservice </span><em class="italic"><span class="koboSpan" id="kobo.88.1">independence</span></em><span class="koboSpan" id="kobo.89.1"> because it enables the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.90.1">Scaling and distributing microservices on different types of hardware.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.91.1">Since each microservice is deployed independently from the others, there can’t be binary compatibility or database structure compatibility constraints. </span><span class="koboSpan" id="kobo.91.2">Therefore, there is no need to align the versions of the different microservices that compose the system. </span><span class="koboSpan" id="kobo.91.3">This means that each of them can evolve as needed without being constrained by the others.
    </span><p class="normal"><span class="koboSpan" id="kobo.92.1">However, attention must be paid to the choice of communication protocols and messages and to their versions, which must be supported by all involved microservices. </span><span class="koboSpan" id="kobo.92.2">Protocols that are widely supported and that facilitate backward compatibility with previous versions of messages should be preferred.</span></p></li>
</ul>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.93.1">Assigning their development to completely separate smaller teams, thus simplifying job organization and reducing all the inevitable coordination inefficiencies that arise when handling large teams.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.94.1">Implementing each microservice with more adequate technologies and in a more adequate environment since each microservice is an independent deployment unit. </span><span class="koboSpan" id="kobo.94.2">This means choosing tools that best fit your requirements and an environment that minimizes development efforts and/or maximizes performance.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.95.1">Since each microservice can be implemented with different technologies, programming languages, tools, and operating systems, enterprises can use all available human resources by matching environments with developers’ competencies. </span><span class="koboSpan" id="kobo.95.2">For instance, all available Java and .NET developers can cooperate in the same application, thus exploiting all available resources.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.96.1">Legacy subsystems can be embedded in independent microservices, thus enabling them to cooperate with newer subsystems. </span><span class="koboSpan" id="kobo.96.2">This way, companies may reduce the time to market new system versions. </span><span class="koboSpan" id="kobo.96.3">Moreover, in this way, legacy systems can evolve slowly toward more modern systems with an acceptable impact on costs</span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.97.1"> and the organization.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.98.1">The next subsection explains how the concept of microservices was conceived. </span><span class="koboSpan" id="kobo.98.2">Then, we will continue this introductory section</span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.99.1"> by exploring basic microservice design principles and analyzing why microservices are often designed as Docker containers.</span></p>
<h2 class="heading-2" id="_idParaDest-219"><span class="koboSpan" id="kobo.100.1">Microservices and the evolution of the concept of modules</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.101.1">For a better understanding of the advantages</span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.102.1"> of microservices, as well as their design techniques, we must keep the two-fold nature of software modularity and software modules in mind:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.103.1">Code modularity</span></strong><span class="koboSpan" id="kobo.104.1"> refers to code organization that makes</span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.105.1"> it easy for us to modify a chunk of code without affecting the remainder of the application. </span><span class="koboSpan" id="kobo.105.2">It is usually enforced with object-oriented design, where modules can be identified with classes.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.106.1">Deployment modularity</span></strong><span class="koboSpan" id="kobo.107.1"> depends on what your deployment</span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.108.1"> units are and which properties they have. </span><span class="koboSpan" id="kobo.108.2">The simplest deployment units are executable files and libraries. </span><span class="koboSpan" id="kobo.108.3">Thus, for instance, </span><strong class="keyWord"><span class="koboSpan" id="kobo.109.1">dynamic link libraries</span></strong><span class="koboSpan" id="kobo.110.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.111.1">DLLs</span></strong><span class="koboSpan" id="kobo.112.1">) are, for sure, more modular than static libraries since</span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.113.1"> they must not be linked with the main executable before being deployed.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.114.1">While the fundamental concepts of code modularity have reached stasis, the concept of deployment modularity is still evolving, and microservices are currently state-of-the-art along this evolution path.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.115.1">As a short review of the main milestones on the path that led to microservices, we can say that, first, monolithic executables were broken into static libraries. </span><span class="koboSpan" id="kobo.115.2">Later on, DLLs replaced static libraries.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.116.1">A great change took place when .NET (and other analogous frameworks, such as Java) improved the modularity of executables and libraries. </span><span class="koboSpan" id="kobo.116.2">In fact, with .NET, they can be deployed on different hardware and different operating systems since they are deployed in an intermediary language that is compiled when the library is executed for the first time. </span><span class="koboSpan" id="kobo.116.3">Moreover, they overcome some versioning issues of previous DLLs since any executable can bring with it a DLL with a version that differs from the version of the same DLL that is installed on the operating system.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.117.1">However, .NET can’t accept two referenced DLLs – let’s say, </span><em class="italic"><span class="koboSpan" id="kobo.118.1">A</span></em><span class="koboSpan" id="kobo.119.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.120.1">B</span></em><span class="koboSpan" id="kobo.121.1"> – using two different versions of a common dependency – let’s say, </span><em class="italic"><span class="koboSpan" id="kobo.122.1">C</span></em><span class="koboSpan" id="kobo.123.1">. </span><span class="koboSpan" id="kobo.123.2">For instance, suppose there is a newer version of </span><em class="italic"><span class="koboSpan" id="kobo.124.1">A</span></em><span class="koboSpan" id="kobo.125.1"> with many new features we would like to use that, in turn, relies on a newer version of </span><em class="italic"><span class="koboSpan" id="kobo.126.1">C</span></em><span class="koboSpan" id="kobo.127.1"> that is not supported by </span><em class="italic"><span class="koboSpan" id="kobo.128.1">B</span></em><span class="koboSpan" id="kobo.129.1">. </span><span class="koboSpan" id="kobo.129.2">In this situation, we should renounce the newer version of </span><em class="italic"><span class="koboSpan" id="kobo.130.1">A</span></em><span class="koboSpan" id="kobo.131.1"> because of the incompatibility of </span><em class="italic"><span class="koboSpan" id="kobo.132.1">C</span></em><span class="koboSpan" id="kobo.133.1"> with </span><em class="italic"><span class="koboSpan" id="kobo.134.1">B</span></em><span class="koboSpan" id="kobo.135.1">. </span><span class="koboSpan" id="kobo.135.2">This difficulty has led to two important changes:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.136.1">Packages: The development world moved</span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.137.1"> from using single DLLs and/or single files as deployment units to using </span><span class="Emphasis"><span class="koboSpan" id="kobo.138.1">packages</span></span><span class="koboSpan" id="kobo.139.1"> composed of both DLLs and metadata as deployment units. </span><span class="koboSpan" id="kobo.139.2">Packages are handled by </span><em class="italic"><span class="koboSpan" id="kobo.140.1">package management systems</span></em><span class="koboSpan" id="kobo.141.1"> such as NuGet and npm, which use package metadata to automatically check version compatibility with the help of semantic versioning.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.142.1">Service-Oriented Architecture</span></strong><span class="koboSpan" id="kobo.143.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.144.1">SOA</span></strong><span class="koboSpan" id="kobo.145.1">): Deployment units started being implemented as SOAP-based</span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.146.1"> web services and later transition to REST web services. </span><span class="koboSpan" id="kobo.146.2">This solves the version compatibility problem since each web service runs in a different process and can use the most adequate version of each library with no risk of causing incompatibilities with other web services. </span><span class="koboSpan" id="kobo.146.3">Moreover, the interface that is exposed by each web service is platform-agnostic; that is, web services can connect with applications using any framework and run on any operating system since web service protocols are based on universally accepted standards. </span><span class="koboSpan" id="kobo.146.4">SOAs and protocols will be discussed in more detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.147.1">Chapter 15</span></em><span class="koboSpan" id="kobo.148.1">, </span><em class="italic"><span class="koboSpan" id="kobo.149.1">Applying Service-Oriented Architectures with .NET.</span></em></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.150.1">Microservices are an evolution</span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.151.1"> of SOA and add more features and more constraints that improve the scalability and the modularity of services to improve the overall CI/CD cycle. </span><span class="koboSpan" id="kobo.151.2">It’s sometimes said that microservices are SOA done well. </span><span class="koboSpan" id="kobo.151.3">Moreover, as we will see in the next section, microservices are strictly tied with the DDD methodology described in </span><em class="chapterRef"><span class="koboSpan" id="kobo.152.1">Chapter 7</span></em><span class="koboSpan" id="kobo.153.1">, </span><em class="italic"><span class="koboSpan" id="kobo.154.1">Understanding the Different Domains in Software Solutions</span></em><span class="koboSpan" id="kobo.155.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.156.1">To sum things up, the microservice</span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.157.1"> architecture is an SOA that maximizes independence and fine-grained scaling. </span><span class="koboSpan" id="kobo.157.2">Now that we’ve clarified all the advantages of microservice independence and fine-grained scaling, as well as the very nature of independence, we are in a position to look at microservice design principles.</span></p>
<h2 class="heading-2" id="_idParaDest-220"><span class="koboSpan" id="kobo.158.1">Microservice design principles</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.159.1">In this section, you will learn about</span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.160.1"> the microservices’ basic design principles. </span><span class="koboSpan" id="kobo.160.2">These principles are the basis for designing each microservice’s code and architecture, and for designing the whole application architecture.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.161.1">Let’s start with principles that arise from the independence constraint. </span><span class="koboSpan" id="kobo.161.2">We will discuss them each in a separate subsection.</span></p>
<h3 class="heading-3" id="_idParaDest-221"><span class="koboSpan" id="kobo.162.1">The independence of design choices</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.163.1">A fundamental design</span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.164.1"> principle is the </span><em class="italic"><span class="koboSpan" id="kobo.165.1">independence of design choices</span></em><span class="koboSpan" id="kobo.166.1">, which can be stated as follows:</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.167.1">The design of each microservice must not depend on the design choices that were made in the implementation of other microservices.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.168.1">This principle enables the full independence of each microservice CI/CD cycle and leaves us with more technological choices on how to implement each microservice. </span><span class="koboSpan" id="kobo.168.2">This way, we can choose the best available technology to implement each microservice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.169.1">Another consequence of this principle is that different microservices can’t connect to the same shared storage (database or filesystem) since sharing the same storage also means sharing all the design choices that determine the structure of the storage subsystem (database table design, database engine, and so on). </span><span class="koboSpan" id="kobo.169.2">Thus, either a microservice has its own data storage, or it has no storage at all and communicates with other microservices that take care of handling storage.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.170.1">Dedicated data storage can be implemented either by physically including the database service within the boundary of the microservice or with an external database that the microservice has exclusive access to. </span><span class="koboSpan" id="kobo.170.2">Both are acceptable design choices. </span><span class="koboSpan" id="kobo.170.3">However, external databases are usually adopted because, for performance reasons, database engines are better run on dedicated hardware and with OS and hardware features that are optimized for their storage functionalities.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.171.1">Usually, the </span><em class="italic"><span class="koboSpan" id="kobo.172.1">independence of design choices</span></em><span class="koboSpan" id="kobo.173.1"> is interpreted in a lighter form by distinguishing between logical and physical microservices. </span><span class="koboSpan" id="kobo.173.2">More specifically, logical microservices are the result of splitting the application into logical independent modules. </span><span class="koboSpan" id="kobo.173.3">If the application is designed with a </span><strong class="keyWord"><span class="koboSpan" id="kobo.174.1">domain-driven design</span></strong><span class="koboSpan" id="kobo.175.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.176.1">DDD</span></strong><span class="koboSpan" id="kobo.177.1">) methodology, logical microservices correspond to DDD-bounded contexts, which we discussed in detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.178.1">Chapter 7</span></em><span class="koboSpan" id="kobo.179.1">, </span><em class="italic"><span class="koboSpan" id="kobo.180.1">Understanding the Different Domains in Software Solutions</span></em><span class="koboSpan" id="kobo.181.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.182.1">In turn, each logical microservice may be split into various physical microservices that use the same data storage but that are load-balanced independently to achieve a better load balance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.183.1">For instance, in the book case study, travel payments</span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.184.1"> are handled by the Payments Bounded Context described in the </span><span class="Emphasis"><span class="koboSpan" id="kobo.185.1">Understanding the domains of the WWTravelClub application</span></span><span class="koboSpan" id="kobo.186.1"> section of </span><em class="chapterRef"><span class="koboSpan" id="kobo.187.1">Chapter 21</span></em><span class="koboSpan" id="kobo.188.1">, </span><em class="italic"><span class="koboSpan" id="kobo.189.1">Case Study</span></em><span class="koboSpan" id="kobo.190.1">, which gives rise to a unique logical microservice. </span><span class="koboSpan" id="kobo.190.2">However, its practical implementation requires two main submodules:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.191.1">A customer credit card verification and authorization module, which takes care of all credit card verifications</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.192.1">A user credits management module, which handles credits that the user already purchased, card information already loaded in the platform, and new credit card info loading</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.193.1">Since the process of credit card verification and authorization might be very time-consuming, it is convenient to implement the two submodules above as independent physical microservices, so they can be load-balanced separately.</span></p>
<h3 class="heading-3" id="_idParaDest-222"><span class="koboSpan" id="kobo.194.1">Independence from the deployment environment</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.195.1">During load-balancing, microservices </span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.196.1">can be moved from very busy hardware nodes to more idle nodes. </span><span class="koboSpan" id="kobo.196.2">However, dependencies of each microservice on other software/files of the destination hardware nodes constrain the possible destination nodes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.197.1">Therefore, the more we reduce microservice dependencies, the more we have the freedom to move them from busy nodes to idle nodes, achieve a better load balance, and exploit the available hardware nodes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.198.1">This is the reason microservices are often containerized and use Docker. </span><span class="koboSpan" id="kobo.198.2">Containers will be discussed in more detail in the </span><em class="italic"><span class="koboSpan" id="kobo.199.1">Containers and Docker</span></em><span class="koboSpan" id="kobo.200.1"> subsection of this chapter, but basically, containerization is a technique that allows each microservice to bring its dependencies with it so that it can run anywhere. </span><span class="koboSpan" id="kobo.200.2">However, this is not a must because, in some applications, one might verify that all dependencies requirements of all microservices can be easily satisfied by all available nodes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.201.1">As we explore how microservices </span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.202.1">operate within their containerized environments, another key architectural principle comes into play – the concept of loose coupling.</span></p>
<h3 class="heading-3" id="_idParaDest-223"><span class="koboSpan" id="kobo.203.1">Loose coupling</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.204.1">Each microservice must be loosely coupled</span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.205.1"> with all the other microservices. </span><span class="koboSpan" id="kobo.205.2">This principle has a two-fold nature. </span><span class="koboSpan" id="kobo.205.3">On the one hand, this means that, according to object-oriented programming principles, the interface that’s exposed by each microservice must not be too specific but as general as possible. </span><span class="koboSpan" id="kobo.205.4">However, it also means that communications among microservices must be minimized in order to reduce communication costs since microservices don’t share the same address space and run on different hardware nodes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.206.1">For instance, suppose we are implementing a distributed web video game with a microservice architecture. </span><span class="koboSpan" id="kobo.206.2">Each microservice might take care of different functionalities, like collisions, visibility, user input handling, and so on. </span><span class="koboSpan" id="kobo.206.3">Some modules, like the collision and visibility modules, must know the whole game state, such as places where the user avatars are, the state of each avatar, and also the state of each reactive object that is in the game (such as obstacles, bullets shot by avatars, and so on). </span><span class="koboSpan" id="kobo.206.4">Therefore, either all the modules with a hard dependency on the whole game state are collapsed into a unique microservice or we must find an efficient way to share the overall game state between them with just a few message exchanges.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.207.1">Both options have advantages and disadvantages and are actually adopted by real-world video games. </span><span class="koboSpan" id="kobo.207.2">Fewer messages might cause temporary incongruences, but melting too many modules into a unique microservice might impact the overall game performance so that the game might appear too “slow” to the users.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.208.1">This concept of minimal inter-service communication naturally leads us to another consideration: the avoidance</span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.209.1"> of chained requests/responses in a microservice architecture</span></p>
<h3 class="heading-3" id="_idParaDest-224"><span class="koboSpan" id="kobo.210.1">No chained requests/responses</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.211.1">When a request reaches</span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.212.1"> a microservice, it must not cause a recursive chain of nested requests/responses to other microservices since a similar chain would result in an unacceptable response time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.213.1">For instance, suppose that microservice A issues a request to microservice B and then waits for B to answer, and B does the same with C, and C does the same with D, and so on. </span><span class="koboSpan" id="kobo.213.2">As a result, A remains blocked waiting for its answer for the whole time the request propagates first to B, then to C, and then to D, and then the answer propagates back from D to C, then from C to B, and finally reaches A. </span><span class="koboSpan" id="kobo.213.3">That is, four request propagation times sum to the other four answer propagation times to get the overall A wait time. </span><span class="koboSpan" id="kobo.213.4">This way, the time a user waits to get an answer from the application might easily become unacceptable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.214.1">Chained requests/responses can be avoided if the private data models of all the microservices synchronize with push events each time they change. </span><span class="koboSpan" id="kobo.214.2">In other words, as soon as the data that is handled by a microservice changes, those changes are sent to all the microservices that may need them to serve their requests. </span><span class="koboSpan" id="kobo.214.3">This way, each microservice has all the data it needs to serve all its incoming requests in its private data storage, with no need to ask other microservices for the data that it lacks.</span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.215.1">Figure 11.1</span></em><span class="koboSpan" id="kobo.216.1"> shows how updates are sent to all interested microservices as soon as they are produced and how each microservice combines all received updates in a local database. </span><span class="koboSpan" id="kobo.216.2">This way, each query microservice has all the data it needs to answer queries in its local database.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.217.1"><img alt="Diagram  Description automatically generated" src="../Images/B19820_11_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.218.1">Figure 11.1: Push events</span></p>
<p class="normal"><span class="koboSpan" id="kobo.219.1">In conclusion, every microservice must contain all the data it needs to serve incoming requests and ensure fast responses. </span><span class="koboSpan" id="kobo.219.2">To keep their data models up to date and ready for incoming requests, microservices must communicate their data changes as soon as they take place. </span><span class="koboSpan" id="kobo.219.3">These data changes</span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.220.1"> should be communicated through asynchronous messages since synchronous nested messages cause unacceptable performance because they block all the threads involved in the call tree until a result is returned.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.221.1">It is worth pointing out that the </span><em class="italic"><span class="koboSpan" id="kobo.222.1">independence of design choices</span></em><span class="koboSpan" id="kobo.223.1"> principle is substantially the bounded context principle of DDD, which we discussed in detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.224.1">Chapter 7</span></em><span class="koboSpan" id="kobo.225.1">, </span><em class="italic"><span class="koboSpan" id="kobo.226.1">Understanding the Different Domains in Software Solutions</span></em><span class="koboSpan" id="kobo.227.1">. </span><span class="koboSpan" id="kobo.227.2">In this chapter, we have seen that, often, a full DDD approach is useful for the </span><em class="italic"><span class="koboSpan" id="kobo.228.1">update</span></em><span class="koboSpan" id="kobo.229.1"> subsystem of each microservice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.230.1">It’s not trivial that, in general, all systems that have been developed according to the bounded context principle are better implemented with a microservice architecture. </span><span class="koboSpan" id="kobo.230.2">In fact, once a system has been decomposed into several completely independent and loosely coupled parts, it is very likely that these different parts will need to be scaled independently because of different traffic and different resource requirements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.231.1">At the preceding constraints, we must also add some best practices for building a reusable SOA. </span><span class="koboSpan" id="kobo.231.2">More details on these best practices will be given in </span><em class="chapterRef"><span class="koboSpan" id="kobo.232.1">Chapter 15</span></em><span class="koboSpan" id="kobo.233.1">, </span><em class="italic"><span class="koboSpan" id="kobo.234.1">Applying Service-Oriented Architectures with .NET</span></em><span class="koboSpan" id="kobo.235.1">, but nowadays, most SOA best practices are automatically enforced by tools and frameworks that are used to implement web services.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.236.1">Fine-grained scaling is a key aspect</span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.237.1"> of microservices architecture, involving several critical software and infrastructure requirements:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.238.1">First of all, microservices must be small enough to isolate well-defined functionalities.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.239.1">We also need a complex infrastructure that takes care of automatically instantiating microservices and allocating</span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.240.1"> instances on various hardware computational resources, commonly called </span><strong class="keyWord"><span class="koboSpan" id="kobo.241.1">nodes</span></strong><span class="koboSpan" id="kobo.242.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.243.1">The same infrastructure must take care of scaling microservices and load-balancing them on the available nodes.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.244.1">These kinds of structures will be introduced in the </span><em class="italic"><span class="koboSpan" id="kobo.245.1">Which tools are needed to manage microservices?</span></em><span class="koboSpan" id="kobo.246.1"> section of this chapter, and discussed in detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.247.1">Chapter 20</span></em><span class="koboSpan" id="kobo.248.1">, </span><em class="italic"><span class="koboSpan" id="kobo.249.1">Kubernetes</span></em><span class="koboSpan" id="kobo.250.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.251.1">Moreover, fine-grained scaling</span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.252.1"> of distributed microservices that communicate through asynchronous communication requires each microservice to be resilient. </span><span class="koboSpan" id="kobo.252.2">In fact, communication that’s directed to a specific microservice instance may fail due to a hardware fault or for the simple reason that the target instance was killed or moved to another node during a load-balancing operation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.253.1">Temporary failures can be overcome with exponential retries. </span><span class="koboSpan" id="kobo.253.2">This is where we retry the same operation after each failure with a delay that increases exponentially until a maximum number of attempts is reached. </span><span class="koboSpan" id="kobo.253.3">For instance, first, we would retry after 10 milliseconds, and if this retry operation results in a failure, a new attempt is made after 20 milliseconds, then after 40 milliseconds, and so on.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.254.1">On the other hand, long-term failures often cause an explosion of retry operations that may saturate all system resources in a way that is similar to a denial-of-service attack. </span><span class="koboSpan" id="kobo.254.2">Therefore, usually, exponential retries are used together with a </span><em class="italic"><span class="koboSpan" id="kobo.255.1">circuit break strategy</span></em><span class="koboSpan" id="kobo.256.1">: after a given number of failures, a long-term failure is assumed, and access to the resource is prevented for a given time by returning an immediate failure without attempting the communication operation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.257.1">It is also fundamental that the congestion of some subsystems, due to either failure or a request peak, does not propagate to other system parts in order to prevent overall system congestion. </span><em class="italic"><span class="koboSpan" id="kobo.258.1">Bulkhead isolation</span></em><span class="koboSpan" id="kobo.259.1"> prevents congestion propagation in the following ways:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.260.1">Only a maximum number of similar simultaneous outbound requests are allowed; let’s say, 10. </span><span class="koboSpan" id="kobo.260.2">This is similar to putting an upper bound on thread creation.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.261.1">Requests exceeding the previous bound are queued.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.262.1">If the maximum queue length is reached, any further requests result in exceptions being thrown to abort them.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.263.1">The practical .NET implementation of exponential retries, circuit break, and bulkhead isolation is described in the </span><em class="italic"><span class="koboSpan" id="kobo.264.1">Resilient task execution subsection</span></em><span class="koboSpan" id="kobo.265.1"> of this chapter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.266.1">Retry policies may make it so that the same message is received and processed several times because the sender has received no confirmation that the message has been received, or simply because it has timed out the operation while the receiver actually received the message. </span><span class="koboSpan" id="kobo.266.2">The only possible solution to this problem is designing all messages so that they’re idempotent – that is, designing messages in such a way that processing the same message several times has the same effect as processing it once.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.267.1">Updating a database</span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.268.1"> table field to a value, for instance, is an idempotent operation since repeating it once or twice has exactly the same effect. </span><span class="koboSpan" id="kobo.268.2">However, incrementing a decimal field is not an idempotent operation. </span><span class="koboSpan" id="kobo.268.3">Microservice designers should make an effort to design the overall application with as many idempotent messages as possible.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.269.1">An idempotent message is also a message that, if processed twice, doesn’t cause malfunctions. </span><span class="koboSpan" id="kobo.269.2">For instance, a message that modifies the price of travel is idempotent because if we process it another time, we just set again the price to the same price as before. </span><span class="koboSpan" id="kobo.269.3">However, a message whose purpose is to add a new travel booking is not idempotent since if we process it twice, we add two travel bookings instead of one.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.270.1">The remaining non-idempotent messages must be transformed into idempotent in the following way or with other similar techniques:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.271.1">Attach both a time and some identifier that uniquely identifies each message.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.272.1">Store all the messages that have been received in a dictionary that’s been indexed by the unique identifier attached to the message mentioned in the previous point.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.273.1">Reject old messages.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.274.1">When a message that may be a duplicate is received, verify whether it’s contained in the dictionary. </span><span class="koboSpan" id="kobo.274.2">If it is, then it has already been processed, so reject it.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.275.1">Since old messages are rejected, they can be periodically removed from the dictionary to prevent it from growing exponentially.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.276.1">In </span><em class="chapterRef"><span class="koboSpan" id="kobo.277.1">Chapter 14</span></em><span class="koboSpan" id="kobo.278.1">, </span><em class="italic"><span class="koboSpan" id="kobo.279.1">Implementing Microservices with .NET</span></em><span class="koboSpan" id="kobo.280.1">, we will use this technique in practice and discuss communication and coordination problems in more detail.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.281.1">It is worth pointing out that some message brokers, such as Azure Service Bus, offer facilities for implementing the technique described previously. </span><span class="koboSpan" id="kobo.281.2">However, the receiver must always be able to recognize duplicate messages since, due to time-outs in the reception of acknowledgments, messages</span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.282.1"> might be resent. </span><span class="koboSpan" id="kobo.282.2">Azure Service Bus is discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.283.1">.NET communication facilities</span></em><span class="koboSpan" id="kobo.284.1"> subsection.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.285.1">In the next subsection, we will talk about microservice containerization based on Docker.</span></p>
<h2 class="heading-2" id="_idParaDest-225"><span class="koboSpan" id="kobo.286.1">Containers and Docker</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.287.1">We’ve already discussed the advantages</span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.288.1"> of having microservices</span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.289.1"> that don’t depend</span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.290.1"> on the environment where they run; microservices can be moved from busy nodes to idle nodes without constraints, thus achieving a better load balance and, consequently, better usage of the available hardware.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.291.1">However, if we need to mix legacy software with newer modules, the ability to mix several development stacks in order to use the best stack for each module implementation, and so on, we are faced with the problem that the various microservices have different hardware/software prerequisites. </span><span class="koboSpan" id="kobo.291.2">In these cases, the independence of each microservice from the hosting environment can be restored by deploying each microservice with all its dependencies on a private virtual machine.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.292.1">However, starting a virtual machine with its private copy of the operating system takes a lot of time, and microservices must be started and stopped quickly to reduce load-balancing and fault recovery costs. </span><span class="koboSpan" id="kobo.292.2">In fact, new microservices may be started either to replace faulty ones or because they were moved from one hardware node to another to perform load-balancing. </span><span class="koboSpan" id="kobo.292.3">Moreover, adding a whole copy of the operating system to each microservice instance would be an excessive overhead.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.293.1">Luckily, microservices can rely on a lighter form of technology: containers. </span><span class="koboSpan" id="kobo.293.2">Containers provide a lightweight, efficient form of virtualization. </span><span class="koboSpan" id="kobo.293.3">Unlike traditional virtual machines that virtualize an entire machine, including the operating system, containers virtualize at the OS filesystem level, sitting on top of the host OS kernel. </span><span class="koboSpan" id="kobo.293.4">They use the operating system of the hosting machine (kernel, DLLs, and drivers) and use the OS’s native features to isolate processes and resources, creating an isolated environment for the images they run.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.294.1">As a consequence, containers are tied to a specific OS, but they don’t suffer the overhead of copying and starting a whole OS in each container instance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.295.1">On each host machine, containers are handled by a runtime that takes care of creating them from </span><em class="italic"><span class="koboSpan" id="kobo.296.1">images</span></em><span class="koboSpan" id="kobo.297.1"> and creating an isolated environment for each of them. </span><span class="koboSpan" id="kobo.297.2">The most popular container image format is Docker, which is a </span><em class="italic"><span class="koboSpan" id="kobo.298.1">de facto</span></em><span class="koboSpan" id="kobo.299.1"> standard for container images.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.300.1">Images contain files needed</span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.301.1"> to create each container</span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.302.1"> and specify which container</span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.303.1"> resources, such as communication ports, to expose outside of the container. </span><span class="koboSpan" id="kobo.303.2">However, they need not explicitly contain all involved files since they can be layered. </span><span class="koboSpan" id="kobo.303.3">This way, each image is built by adding new files and configuration information on top of another existing image that is referenced from inside the newly defined image.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.304.1">For instance, if you want to deploy a .NET application as a Docker image, it is enough to just add your software and files to your Docker image and then reference an already existing .NET Docker image.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.305.1">To allow for easy image referencing, images are grouped into registries that may be either public or private. </span><span class="koboSpan" id="kobo.305.2">They are similar to NuGet</span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.306.1"> or npm registries. </span><span class="koboSpan" id="kobo.306.2">Docker offers a public registry (</span><a href="https://hub.docker.com/_/registry"><span class="url"><span class="koboSpan" id="kobo.307.1">https://hub.docker.com/_/registry</span></span></a><span class="koboSpan" id="kobo.308.1">) where you can find most of the public images you may need to reference in your own images. </span><span class="koboSpan" id="kobo.308.2">However, each company can define private registries. </span><span class="koboSpan" id="kobo.308.3">For instance, Microsoft offers Azure Container Registry, where you can define your private</span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.309.1"> container registry service: </span><a href="https://azure.microsoft.com/en-us/services/container-registry/"><span class="url"><span class="koboSpan" id="kobo.310.1">https://azure.microsoft.com/en-us/services/container-registry/</span></span></a><span class="koboSpan" id="kobo.311.1">. </span><span class="koboSpan" id="kobo.311.2">There, you can also find most of the .NET-related images you might need to reference in your code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.312.1">Before instantiating each container, the Docker runtime must solve all the recursive references. </span><span class="koboSpan" id="kobo.312.2">This cumbersome job is not performed each time a new container is created since the Docker runtime has a cache where it stores the fully assembled images that correspond to each input image and that it has already processed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.313.1">Since each application is usually composed of several modules</span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.314.1"> to be run in different containers, a tool called </span><strong class="keyWord"><span class="koboSpan" id="kobo.315.1">Docker Compose</span></strong><span class="koboSpan" id="kobo.316.1"> also allows </span><code class="inlineCode"><span class="koboSpan" id="kobo.317.1">.yml</span></code><span class="koboSpan" id="kobo.318.1"> files, known as </span><strong class="keyWord"><span class="koboSpan" id="kobo.319.1">composition files</span></strong><span class="koboSpan" id="kobo.320.1">, that specify the following</span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.321.1"> information:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.322.1">Which images to deploy.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.323.1">How the internal resources that are exposed by each image must be mapped to the physical resources of the host machine. </span><span class="koboSpan" id="kobo.323.2">For instance, how communication ports that are exposed by Docker images must be mapped to the ports of the physical machine.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.324.1">We will analyze Docker images and </span><code class="inlineCode"><span class="koboSpan" id="kobo.325.1">.yml</span></code><span class="koboSpan" id="kobo.326.1"> files in the </span><em class="italic"><span class="koboSpan" id="kobo.327.1">How does .NET deal with microservices?</span></em><span class="koboSpan" id="kobo.328.1"> section of this chapter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.329.1">The Docker runtime handles images and containers on a single machine, but usually, containerized microservices are deployed and load-balanced on clusters that are composed of several</span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.330.1"> machines. </span><span class="koboSpan" id="kobo.330.2">Clusters are handled by pieces of software called </span><strong class="keyWord"><span class="koboSpan" id="kobo.331.1">orchestrators</span></strong><span class="koboSpan" id="kobo.332.1">. </span><span class="koboSpan" id="kobo.332.2">Orchestrators will be introduced in the </span><em class="italic"><span class="koboSpan" id="kobo.333.1">Which tools are needed to manage microservices?</span></em><span class="koboSpan" id="kobo.334.1"> section of this chapter, and described in detail in </span><em class="italic"><span class="koboSpan" id="kobo.335.1">Chapter 20,</span></em> <em class="italic"><span class="koboSpan" id="kobo.336.1">Kubernetes</span></em><span class="koboSpan" id="kobo.337.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.338.1">Now that we understand </span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.339.1">what microservices are, what problems</span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.340.1"> they can solve, and their</span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.341.1"> basic design principles, we are ready to analyze when and how to use them in our system architecture. </span><span class="koboSpan" id="kobo.341.2">The next section analyzes when we should use them.</span></p>
<h1 class="heading-1" id="_idParaDest-226"><span class="koboSpan" id="kobo.342.1">When do microservices help?</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.343.1">The answer to this question requires</span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.344.1"> us to understand the roles microservices play in modern software architectures. </span><span class="koboSpan" id="kobo.344.2">We will look at this in the following two subsections:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.345.1">Layered architectures and microservices</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.346.1">When is it worth considering microservice architectures?</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.347.1">Let’s start with a detailed look at layered architectures and microservices.</span></p>
<h2 class="heading-2" id="_idParaDest-227"><span class="koboSpan" id="kobo.348.1">Layered architectures and microservices</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.349.1">As discussed in </span><em class="italic"><span class="koboSpan" id="kobo.350.1">Chapter 7, Understanding the Different Domains in Software Solutions</span></em><span class="koboSpan" id="kobo.351.1">, enterprise systems are usually</span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.352.1"> organized in logical independent layers. </span><span class="koboSpan" id="kobo.352.2">The outermost</span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.353.1"> layer is the one that interacts</span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.354.1"> with the user and is called the presentation layer (in the onion architecture, the outermost layer also contains drivers and test suites), while the last layer (the innermost layer in the onion architecture) takes care of application permanent</span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.355.1"> data handling and is called the data layer (the domain layer in the onion architecture). </span><span class="koboSpan" id="kobo.355.2">Requests originate in the presentation layer and pass through all the layers until they reach the data layer (and then come back, traversing all the layers in reverse until they reach the outermost layer again).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.356.1">In the case of classical layered architecture (the onion architecture is quite different, as discussed in </span><em class="italic"><span class="koboSpan" id="kobo.357.1">Chapter 7</span></em><span class="koboSpan" id="kobo.358.1">, </span><em class="italic"><span class="koboSpan" id="kobo.359.1">Understanding the Different Domains in Software Solutions</span></em><span class="koboSpan" id="kobo.360.1">), each layer takes data from the previous layer, processes it, and passes it to the next layer. </span><span class="koboSpan" id="kobo.360.2">Then, it receives the results from its next layer and sends them back to its previous layer. </span><span class="koboSpan" id="kobo.360.3">Also, thrown exceptions can’t jump layers – each layer must take care of intercepting all the exceptions and either </span><em class="italic"><span class="koboSpan" id="kobo.361.1">solve them</span></em><span class="koboSpan" id="kobo.362.1"> somehow or transform them into other exceptions that are expressed in the language of its previous layer. </span><span class="koboSpan" id="kobo.362.2">The layered architecture ensures the complete independence of the functionalities of each layer from the functionalities of all the other layers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.363.1">For instance, we can change the </span><strong class="keyWord"><span class="koboSpan" id="kobo.364.1">Object-Relational Mapping</span></strong><span class="koboSpan" id="kobo.365.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.366.1">ORM</span></strong><span class="koboSpan" id="kobo.367.1">) software that interfaces the database without</span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.368.1"> affecting all the layers that are above the data layer (ORM software is discussed in </span><em class="chapterRef"><span class="koboSpan" id="kobo.369.1">Chapter 13</span></em><span class="koboSpan" id="kobo.370.1">, </span><em class="italic"><span class="koboSpan" id="kobo.371.1">Interacting with Data in C# – Entity Framework Core</span></em><span class="koboSpan" id="kobo.372.1">). </span><span class="koboSpan" id="kobo.372.2">In the same way, we can completely change the user interface (that is, the presentation layer) without affecting the remainder of the system.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.373.1">Moreover, each layer implements a different kind of system specification. </span><span class="koboSpan" id="kobo.373.2">The data layer takes care of what the system </span><em class="italic"><span class="koboSpan" id="kobo.374.1">must remember</span></em><span class="koboSpan" id="kobo.375.1">, the presentation layer takes care of the system-user interaction protocol, and all the layers that are in the middle implement the domain rules, which specify how data must be processed (for instance, how an employee paycheck must be computed). </span><span class="koboSpan" id="kobo.375.2">Typically, the data</span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.376.1"> and presentation layers are separated</span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.377.1"> by just one domain rule layer, called the business or application layer.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.378.1"><img alt="Diagram  Description automatically generated" src="../Images/B19820_11_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.379.1">Figure 11.2: Layers of classic architectures</span></p>
<p class="normal"><span class="koboSpan" id="kobo.380.1">Each layer </span><em class="italic"><span class="koboSpan" id="kobo.381.1">speaks</span></em><span class="koboSpan" id="kobo.382.1"> a different language: the data layer</span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.383.1"> speaks the language of relation</span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.384.1"> among entities, the business layer speaks the language of domain experts, and the presentation layer speaks the language of users. </span><span class="koboSpan" id="kobo.384.2">So, when data and exceptions pass from one layer to another, they must be translated into the language of the destination layer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.385.1">That being said, how do microservices fit into a layered architecture? </span><span class="koboSpan" id="kobo.385.2">Are they adequate for the functionalities of all the layers or just some layers? </span><span class="koboSpan" id="kobo.385.3">Can a single microservice span several layers?</span></p>
<p class="normal"><span class="koboSpan" id="kobo.386.1">The last question is the easiest to answer: yes! </span><span class="koboSpan" id="kobo.386.2">In fact, we’ve already stated that microservices should store the data they need within their logical boundaries. </span><span class="koboSpan" id="kobo.386.3">Therefore, there are microservices that span the business and data layers, for sure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.387.1">However, since we said that each logical microservice can be implemented with several physical microservices for pure load-balancing reasons, one microservice might take care of encapsulating data used by another microservice that might remain confined in the data layer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.388.1">Moreover, we said also that while each microservice must have its exclusive storage, it can use also external storage engines. </span><span class="koboSpan" id="kobo.388.2">This is shown in the diagram below:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.389.1"><img alt="" role="presentation" src="../Images/B19820_11_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.390.1">Figure 11.3: External or internal storage</span></p>
<p class="normal"><span class="koboSpan" id="kobo.391.1">It is worth pointing out that the storage</span><a id="_idIndexMarker800"/><span class="koboSpan" id="kobo.392.1"> engine itself can be implemented</span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.393.1"> as a set of physical microservices that are associated with no logical microservice since they may be considered part of the infrastructure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.394.1">This is the case, for instance, for storage engines based on the distributed Redis in-memory cache, where we use microservice facilities offered by the infrastructure to implement scalable one-master/many-read-only replicas, or sophisticated many-master/many-read-only replicas distributed in memory storage. </span><span class="koboSpan" id="kobo.394.2">Redis and Redis Cloud services are described in the </span><em class="italic"><span class="koboSpan" id="kobo.395.1">Redis</span></em><span class="koboSpan" id="kobo.396.1"> section </span><em class="italic"><span class="koboSpan" id="kobo.397.1">of </span></em><em class="chapterRef"><span class="koboSpan" id="kobo.398.1">Chapter 12</span></em><span class="koboSpan" id="kobo.399.1">, </span><em class="italic"><span class="koboSpan" id="kobo.400.1">Choosing Your Data Storage in the Cloud</span></em><span class="koboSpan" id="kobo.401.1">, while many-master/many-read-only replicas architectures are described in </span><em class="chapterRef"><span class="koboSpan" id="kobo.402.1">Chapter 20</span></em><span class="koboSpan" id="kobo.403.1">, </span><em class="italic"><span class="koboSpan" id="kobo.404.1">Kubernetes</span></em><span class="koboSpan" id="kobo.405.1">. </span><span class="koboSpan" id="kobo.405.2">The diagram below shows how microservice-based many-master/many-read-only replicas storage engines work.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.406.1"><img alt="" role="presentation" src="../Images/B19820_11_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.407.1">Figure 11.4: Many-master/many-read-only replicas storage engine</span></p>
<p class="normal"><span class="koboSpan" id="kobo.408.1">Each master has its associated read-only replicas. </span><span class="koboSpan" id="kobo.408.2">Storage updates can be passed just to masters that replicate their data to all their associated read-only replicas.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.409.1">Each master takes care of a portion of the storage space, for instance, all products whose name starts with “A,” and so on. </span><span class="koboSpan" id="kobo.409.2">In this way, the load is balanced between all masters.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.410.1">Thus, we may have business</span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.411.1"> layer microservices, data layer </span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.412.1">microservices, and microservices that span both layers. </span><span class="koboSpan" id="kobo.412.2">So, what about the presentation layer?</span></p>
<h3 class="heading-3" id="_idParaDest-228"><span class="koboSpan" id="kobo.413.1">The presentation layer</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.414.1">This layer can also fit into a microservice</span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.415.1"> architecture if it is implemented</span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.416.1"> on the server side – that is, if the whole graphic that interacts with the user is built on the server side and not in the user client machine (mobile device, desktop, etc.).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.417.1">When there are microservices that interact directly with the user, we speak of server-side implementation of the presentation layer since the HTML and/or all elements of the user interface are created by the frontend, which sends the response to the user.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.418.1">These kinds of microservices</span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.419.1"> are called frontend microservices, while microservices</span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.420.1"> that do back-office work without interacting</span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.421.1"> with the </span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.422.1">user are called worker microservices. </span><span class="koboSpan" id="kobo.422.2">The diagram below summarizes the frontend/worker organization.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.423.1"><img alt="" role="presentation" src="../Images/B19820_11_05.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.424.1">Figure 11.5: Frontend and worker microservices</span></p>
<p class="normal"><span class="koboSpan" id="kobo.425.1">When, instead, the HTML and/or all elements of the user interface are generated on the user machine, we speak of client-side implementation of the presentation layer. </span><span class="koboSpan" id="kobo.425.2">The so-called single-page applications and mobile applications run the presentation</span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.426.1"> layer on the client</span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.427.1"> machine and interact with the application through communication interfaces exposed by dedicated microservices. </span><span class="koboSpan" id="kobo.427.2">These dedicated microservices</span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.428.1"> are completely analogous to the frontend microservices depicted in </span><em class="italic"><span class="koboSpan" id="kobo.429.1">Figure 11.5</span></em><span class="koboSpan" id="kobo.430.1"> and are called </span><em class="italic"><span class="koboSpan" id="kobo.431.1">API gateways,</span></em><span class="koboSpan" id="kobo.432.1"> to underline their role of exposing a public API for connecting client devices with the whole microservices infrastructure. </span><span class="koboSpan" id="kobo.432.2">Also, API gateways interact with worker microservices in a way that is completely analogous to frontend microservices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.433.1">Single-page applications and mobile/desktop client applications are discussed in </span><em class="chapterRef"><span class="koboSpan" id="kobo.434.1">Chapter 19</span></em><span class="koboSpan" id="kobo.435.1">, </span><em class="italic"><span class="koboSpan" id="kobo.436.1">Client Frameworks: Blazor</span></em><span class="koboSpan" id="kobo.437.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.438.1">In a microservice architecture, when the presentation layer is a website, it can be implemented with a set of several microservices. </span><span class="koboSpan" id="kobo.438.2">However, if it requires heavy web servers and/or heavy frameworks, containerizing them may not be convenient. </span><span class="koboSpan" id="kobo.438.3">This decision must also consider the loss of performance that happens when containerizing the web server and the possible need for hardware firewalls between the web server and the remainder of the system.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.439.1">ASP.NET Core is a lightweight</span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.440.1"> framework that runs on the Kestrel</span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.441.1"> web server, so it can be containerized efficiently and used as is in the worker microservices. </span><span class="koboSpan" id="kobo.441.2">The usage of ASP:NET Core in the implementation of worker microservices is described in great detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.442.1">Chapter 14</span></em><span class="koboSpan" id="kobo.443.1">, </span><em class="italic"><span class="koboSpan" id="kobo.444.1">Implementing Microservices with .NET</span></em><span class="koboSpan" id="kobo.445.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.446.1">Instead, frontend and/or high-traffic websites have more compelling security and load-balancing requirements that can be satisfied just with fully-featured web servers. </span><span class="koboSpan" id="kobo.446.2">Accordingly, architectures based on microservices usually offer specialized components that take care of interfacing with the outside world. </span><span class="koboSpan" id="kobo.446.3">For instance, in </span><em class="chapterRef"><span class="koboSpan" id="kobo.447.1">Chapter 20</span></em><span class="koboSpan" id="kobo.448.1">, </span><em class="italic"><span class="koboSpan" id="kobo.449.1">Kubernetes</span></em><span class="koboSpan" id="kobo.450.1">, we will see that</span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.451.1"> in microservices-dedicated infrastructures like </span><strong class="keyWord"><span class="koboSpan" id="kobo.452.1">Kubernetes</span></strong><span class="koboSpan" id="kobo.453.1"> clusters, this role is played by so-called </span><strong class="keyWord"><span class="koboSpan" id="kobo.454.1">ingresses</span></strong><span class="koboSpan" id="kobo.455.1">. </span><span class="koboSpan" id="kobo.455.2">These are fully-featured</span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.456.1"> web servers interfaced with the microservices infrastructure. </span><span class="koboSpan" id="kobo.456.2">Thanks to the integration with the microservices infrastructure, the whole web server traffic is automatically routed to the interested microservices. </span><span class="koboSpan" id="kobo.456.3">More details on this will be given in </span><em class="chapterRef"><span class="koboSpan" id="kobo.457.1">Chapter 20</span></em><span class="koboSpan" id="kobo.458.1">, </span><em class="italic"><span class="koboSpan" id="kobo.459.1">Kubernetes</span></em><span class="koboSpan" id="kobo.460.1">. </span><span class="koboSpan" id="kobo.460.2">The diagram below shows the role of Ingresses.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.461.1"><img alt="" role="presentation" src="../Images/B19820_11_06.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.462.1">Figure 11.6: Ingresses based on load-balanced web servers</span></p>
<p class="normal"><span class="koboSpan" id="kobo.463.1">Monolithic websites can be easily broken into load-balanced smaller subsites without microservice-specific technologies, but a microservice architecture can bring all the advantages of microservices into the construction of a single HTML page. </span><span class="koboSpan" id="kobo.463.2">More specifically, different microservices may take care of different areas of each HTML page. </span><span class="koboSpan" id="kobo.463.3">Microservices that cooperate in the construction of the HTML of application pages, and, in general, in the construction of any kind of user interface, are named micro-frontends.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.464.1">When the HTML is created on the server side, the various micro-frontends create HTML chunks that are combined either on the server side or directly in the browser.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.465.1">When, instead, the HTML is created directly on the client, each micro-frontend provides a different chunk of code to the client. </span><span class="koboSpan" id="kobo.465.2">These code chunks are run on the client machine, and each of them takes care of different pages/page areas. </span><span class="koboSpan" id="kobo.465.3">We will speak more of this kind of micro-frontend in </span><em class="chapterRef"><span class="koboSpan" id="kobo.466.1">Chapter 18</span></em><span class="koboSpan" id="kobo.467.1">, </span><em class="italic"><span class="koboSpan" id="kobo.468.1">Implementing Frontend Microservices with ASP.NET Core</span></em><span class="koboSpan" id="kobo.469.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.470.1">Now that we’ve clarified</span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.471.1"> which parts of a system</span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.472.1"> can benefit from the adoption of microservices, we are ready to state the rules when it comes to deciding how they’re adopted.</span></p>
<h2 class="heading-2" id="_idParaDest-229"><span class="koboSpan" id="kobo.473.1">When is it worth considering microservice architectures?</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.474.1">Microservices can improve the implementation of both the business and data layers, but their adoption</span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.475.1"> has some costs:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.476.1">Allocating instances to nodes and scaling them has a cost in terms of cloud fees or internal infrastructures and licenses.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.477.1">Splitting a unique process into smaller communication processes increases communication costs and hardware needs, especially if the microservices are containerized.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.478.1">Designing and testing software for a microservice requires more time and increases engineering costs, both in time and complexity. </span><span class="koboSpan" id="kobo.478.2">In particular, making microservices resilient and ensuring that they adequately handle all possible failures, as well as verifying these features with integration tests, can increase the development time by more than one order of magnitude (that is, about 10 times).</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.479.1">So, when are microservices worth the cost of using them? </span><span class="koboSpan" id="kobo.479.2">Are there functionalities that must be implemented as microservices?</span></p>
<p class="normal"><span class="koboSpan" id="kobo.480.1">A rough answer to the second question is yes when the application is big enough in terms of traffic and/or software complexity. </span><span class="koboSpan" id="kobo.480.2">In fact, as an application grows in complexity and its traffic increases, it’s recommended that we pay the costs associated with scaling it since this allows for more scaling optimization and better handling when it comes to the development team. </span><span class="koboSpan" id="kobo.480.3">The costs we pay for these would soon exceed the cost of microservice adoption.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.481.1">Thus, if fine-grained scaling makes sense for our application, and if we can estimate the savings that fine-grained scaling and development give us, we can easily compute an overall application throughput limit that makes the adoption of microservices convenient.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.482.1">Microservice costs can also be justified by an increase in the market value of our products/services. </span><span class="koboSpan" id="kobo.482.2">Since the microservice architecture allows us to implement each microservice with a technology that has been optimized for its use, the quality that’s added to our software may justify all or part of the microservice costs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.483.1">However, scaling and technology optimizations are not the only parameters to consider. </span><span class="koboSpan" id="kobo.483.2">Sometimes, we are forced to adopt a microservice architecture without being able to perform a detailed cost analysis.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.484.1">If the size of the team that takes care of the CI/CD of the overall system grows too much, the organization and coordination of this big team cause difficulties and inefficiencies. </span><span class="koboSpan" id="kobo.484.2">In this type of situation, it is desirable to move to an architecture that breaks the whole CI/CD cycle into independent parts that can be taken care of by smaller teams.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.485.1">Moreover, since these development costs</span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.486.1"> are only justified by a high volume of requests, we probably have high traffic being processed by independent modules that have been developed by different teams. </span><span class="koboSpan" id="kobo.486.2">Therefore, scaling optimizations and the need to reduce interaction between development teams make the adoption of a microservice architecture very convenient.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.487.1">From this, we may conclude that if the system and the development team grow too much, it is necessary to split the development team into smaller teams, each working on an efficient bounded context subsystem. </span><span class="koboSpan" id="kobo.487.2">It is very likely that, in a similar situation, a microservice architecture is the only possible option.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.488.1">Another situation that forces the adoption of a microservice architecture is the integration of newer subparts with legacy subsystems based on different technologies, as containerized microservices are the only way to implement an efficient interaction between the legacy system and the new subparts in order to gradually replace the legacy subparts with newer ones. </span><span class="koboSpan" id="kobo.488.2">Similarly, if our team is composed of developers with experience in different development stacks, an architecture based on containerized microservices may become a </span><em class="italic"><span class="koboSpan" id="kobo.489.1">must</span></em><span class="koboSpan" id="kobo.490.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.491.1">In the next section, we will analyze the building blocks and tools that are available for the implementation of .NET-based microservices.</span></p>
<h1 class="heading-1" id="_idParaDest-230"><span class="koboSpan" id="kobo.492.1">How does .NET deal with microservices?</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.493.1">The new .NET, which evolved</span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.494.1"> from .NET Core, was conceived as a multi-platform framework that was light and fast enough to implement efficient microservices. </span><span class="koboSpan" id="kobo.494.2">In particular, ASP.NET Core is the ideal tool for implementing text REST and binary gRPC APIs to communicate with a microservice since it can run efficiently with lightweight web servers such as Kestrel and is itself light and modular.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.495.1">The whole .NET stack evolved with microservices as a strategic deployment platform in mind and has facilities and packages for building efficient and light HTTP and gRPC communication to ensure service resiliency and to handle long-running tasks. </span><span class="koboSpan" id="kobo.495.2">The following subsections describe some of the different tools or solutions that we can use to implement a .NET-based microservice</span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.496.1"> architecture.</span></p>
<h2 class="heading-2" id="_idParaDest-231"><span class="koboSpan" id="kobo.497.1">.NET communication facilities</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.498.1">Microservices need two kinds of communication channels.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.499.1">The first communication channel</span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.500.1"> receives external requests, either directly or through an API gateway. </span><span class="koboSpan" id="kobo.500.2">HTTP is the usual protocol for external communication due to available web service standards and tools. </span><span class="koboSpan" id="kobo.500.3">.NET’s main HTTP/gRPC communication facility is ASP.NET Core since it’s a lightweight HTTP/gRPC framework, which makes it ideal for implementing web APIs in small microservices. </span><span class="koboSpan" id="kobo.500.4">We will describe ASP.NET REST API apps in detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.501.1">Chapter 15</span></em><span class="koboSpan" id="kobo.502.1">, </span><em class="italic"><span class="koboSpan" id="kobo.503.1">Applying Service-Oriented Architectures with .NET</span></em><span class="koboSpan" id="kobo.504.1">, and we will describe gRPC services in </span><em class="chapterRef"><span class="koboSpan" id="kobo.505.1">Chapter 14</span></em><span class="koboSpan" id="kobo.506.1">, </span><em class="italic"><span class="koboSpan" id="kobo.507.1">Implementing Microservices with .NET</span></em><span class="koboSpan" id="kobo.508.1">. </span><span class="koboSpan" id="kobo.508.2">.NET also offers an efficient and modular HTTP client solution that is able to pool and reuse heavy connection objects. </span><span class="koboSpan" id="kobo.508.3">Also, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.509.1">HttpClient</span></code><span class="koboSpan" id="kobo.510.1"> class will be described in more detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.511.1">Chapter 15</span></em><span class="koboSpan" id="kobo.512.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.513.1">The second channel is a different type of communication channel to push updates to other microservices. </span><span class="koboSpan" id="kobo.513.2">In fact, we have already mentioned that intra-microservice communication cannot be triggered by an ongoing request since a complex tree of blocking calls to other microservices would increase request latency to an unacceptable level. </span><span class="koboSpan" id="kobo.513.3">As a consequence, updates must not be requested immediately before they’re used and should be pushed whenever state changes take place. </span><span class="koboSpan" id="kobo.513.4">Ideally, this kind of communication should be asynchronous to achieve acceptable performance. </span><span class="koboSpan" id="kobo.513.5">In fact, synchronous calls would block the sender while they are waiting for the result, thus increasing the idle time of each microservice. </span><span class="koboSpan" id="kobo.513.6">However, synchronous communication that just puts the request in a processing queue and then returns confirmation of the successful communication instead of the final result is acceptable if communication is fast enough (low communication latency and high bandwidth). </span><span class="koboSpan" id="kobo.513.7">A publisher/subscriber communication would be preferable since, in this case, the sender and receiver don’t need to know each other, thus increasing the microservices’ independence. </span><span class="koboSpan" id="kobo.513.8">In fact, all the receivers that are interested in a certain type of communication merely need to register to receive a specific </span><em class="italic"><span class="koboSpan" id="kobo.514.1">event</span></em><span class="koboSpan" id="kobo.515.1">, while senders just need to publish those events. </span><span class="koboSpan" id="kobo.515.2">All the wiring is performed by a service that takes care of queuing events and dispatching them to all the subscribers. </span><span class="koboSpan" id="kobo.515.3">The publisher/subscriber pattern was described in </span><em class="chapterRef"><span class="koboSpan" id="kobo.516.1">Chapter 6</span></em><span class="koboSpan" id="kobo.517.1">, </span><em class="italic"><span class="koboSpan" id="kobo.518.1">Design Patterns and .NET 8 Implementation</span></em><span class="koboSpan" id="kobo.519.1">, along with other useful patterns.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.520.1">While .NET doesn’t directly offer tools that may help in asynchronous communication or client/server tools that implement</span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.521.1"> publisher/subscriber communication, Azure offers a similar service with </span><em class="italic"><span class="koboSpan" id="kobo.522.1">Azure Service Bus</span></em><span class="koboSpan" id="kobo.523.1"> (</span><a href="https://docs.microsoft.com/en-us/azure/service-bus-messaging/"><span class="url"><span class="koboSpan" id="kobo.524.1">https://docs.microsoft.com/en-us/azure/service-bus-messaging/</span></span></a><span class="koboSpan" id="kobo.525.1">). </span><span class="koboSpan" id="kobo.525.2">Azure Service Bus handles both queued asynchronous communication through Azure Service Bus </span><em class="italic"><span class="koboSpan" id="kobo.526.1">queues</span></em><span class="koboSpan" id="kobo.527.1"> and publisher/subscriber communication through Azure Service Bus </span><em class="italic"><span class="koboSpan" id="kobo.528.1">topics</span></em><span class="koboSpan" id="kobo.529.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.530.1">Once you’ve configured the Azure Service Bus on the Azure portal, you can connect to it in order to send messages/events and receive messages/events through a client contained in </span><code class="inlineCode"><span class="koboSpan" id="kobo.531.1">Microsoft.Azure.ServiceBus</span></code><span class="koboSpan" id="kobo.532.1"> NuGet package.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.533.1">Azure Service Bus has two types</span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.534.1"> of communication: queue-based and topic-based. </span><span class="koboSpan" id="kobo.534.2">In queue-based communication, each message that’s placed in the queue by a sender is removed from the queue by the first receiver that pulls it from the queue. </span><span class="koboSpan" id="kobo.534.3">Topic-based communication, on the other hand, is an implementation of the publisher/subscriber pattern. </span><span class="koboSpan" id="kobo.534.4">Each topic has several subscriptions, and a different copy of each message sent to a topic can be pulled from each topic subscription.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.535.1">The design flow is as follows:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.536.1">Define an Azure Service Bus private namespace.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.537.1">Get the root connection strings that were created by the Azure portal and/or define new connection strings with fewer privileges.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.538.1">Define queues and/or topics where the sender will send their messages in binary format.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.539.1">For each topic, define names for all the required subscriptions.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.540.1">In the case of queue-based communication, the sender sends messages to a queue, and the receivers pull messages from the same queue. </span><span class="koboSpan" id="kobo.540.2">Each message is delivered to one receiver. </span><span class="koboSpan" id="kobo.540.3">That is, once a receiver gains access to the queue, it reads and removes one or more messages.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.541.1">In the case of topic-based communication, each sender sends messages to a topic while each receiver pulls messages from its private subscription associated with that topic.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.542.1">There are also other commercial </span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.543.1">and free open-source alternatives to Azure Service Bus, such as NServiceBus (</span><a href="https://particular.net/nservicebus"><span class="url"><span class="koboSpan" id="kobo.544.1">https://particular.net/nservicebus</span></span></a><span class="koboSpan" id="kobo.545.1">), MassTransit (</span><a href="https://masstransit-project.com/"><span class="url"><span class="koboSpan" id="kobo.546.1">https://masstransit-project.com/</span></span></a><span class="koboSpan" id="kobo.547.1">), and Brighter (</span><a href="https://www.goparamore.io/"><span class="url"><span class="koboSpan" id="kobo.548.1">https://www.goparamore.io/</span></span></a><span class="koboSpan" id="kobo.549.1">). </span><span class="koboSpan" id="kobo.549.2">They enhance existing</span><a id="_idIndexMarker827"/><span class="koboSpan" id="kobo.550.1"> brokers (like Azure Service Bus itself) with</span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.551.1"> higher-level functionalities.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.552.1">There is also a completely independent option that can be used on on-premises platforms: RabbitMQ. </span><span class="koboSpan" id="kobo.552.2">It is free and open source and can be installed locally, on a virtual machine, or in a Docker container. </span><span class="koboSpan" id="kobo.552.3">Then, you can connect with it through the client contained in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.553.1">RabbitMQ.Client</span></code><span class="koboSpan" id="kobo.554.1"> NuGet package.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.555.1">The functionalities of RabbitMQ</span><a id="_idIndexMarker829"/><span class="koboSpan" id="kobo.556.1"> are similar to the ones offered by Azure Service Bus, but you have to take care of more implementation details, like serialization, reliable messages, and error handling, while Azure Service Bus takes care of all the low-level operations and offers you a simpler interface. </span><span class="koboSpan" id="kobo.556.2">However, there are clients that build a more powerful abstraction on top of RabbitMQ, like, for instance, EasyNetQ. </span><span class="koboSpan" id="kobo.556.3">The publisher/subscriber-based communication pattern used by both Azure Service Bus and RabbitMQ was described in </span><em class="chapterRef"><span class="koboSpan" id="kobo.557.1">Chapter 6</span></em><span class="koboSpan" id="kobo.558.1">, </span><em class="italic"><span class="koboSpan" id="kobo.559.1">Design Patterns and .NET 8 Implementation</span></em><span class="koboSpan" id="kobo.560.1">. </span><span class="koboSpan" id="kobo.560.2">RabbitMQ will be described in more detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.561.1">Chapter 14</span></em><span class="koboSpan" id="kobo.562.1">, </span><em class="italic"><span class="koboSpan" id="kobo.563.1">Implementing Microservices with .NET</span></em><span class="koboSpan" id="kobo.564.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-232"><span class="koboSpan" id="kobo.565.1">Resilient task execution</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.566.1">Resilient communication</span><a id="_idIndexMarker830"/><span class="koboSpan" id="kobo.567.1"> and, in general, resilient task execution </span><a id="_idIndexMarker831"/><span class="koboSpan" id="kobo.568.1">can be implemented easily with the help of a .NET library called Polly, whose project is a member of the .NET Foundation. </span><span class="koboSpan" id="kobo.568.2">Polly is available through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.569.1">Polly</span></code><span class="koboSpan" id="kobo.570.1"> NuGet package.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.571.1">In Polly, you define policies and then execute tasks in the context of those policies, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.572.1">var</span></span><span class="koboSpan" id="kobo.573.1"> myPolicy = Policy
  .Handle&lt;HttpRequestException&gt;()
  .Or&lt;OperationCanceledException&gt;()
  .RetryAsync(</span><span class="hljs-number"><span class="koboSpan" id="kobo.574.1">3</span></span><span class="koboSpan" id="kobo.575.1">);
....
</span><span class="koboSpan" id="kobo.575.2">....
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.576.1">await</span></span><span class="koboSpan" id="kobo.577.1"> myPolicy.ExecuteAsync(()=&gt;{
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.578.1">//your code here</span></span><span class="koboSpan" id="kobo.579.1">
});
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.580.1">The first part of each policy specifies the exceptions that must be handled. </span><span class="koboSpan" id="kobo.580.2">Then, you specify what to do when one of those exceptions is captured. </span><span class="koboSpan" id="kobo.580.3">In the preceding code, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.581.1">Execute</span></code><span class="koboSpan" id="kobo.582.1"> method is retried up to three times if a failure is reported either by an </span><code class="inlineCode"><span class="koboSpan" id="kobo.583.1">HttpRequestException</span></code><span class="koboSpan" id="kobo.584.1"> exception or by an </span><code class="inlineCode"><span class="koboSpan" id="kobo.585.1">OperationCanceledException</span></code><span class="koboSpan" id="kobo.586.1"> exception.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.587.1">The following is the implementation of an exponential retry policy:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.588.1">var</span></span><span class="koboSpan" id="kobo.589.1"> retryPolicy= Policy
    ...
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.590.1">//Exceptions to handle here</span></span><span class="koboSpan" id="kobo.591.1">
    .WaitAndRetryAsync(</span><span class="hljs-number"><span class="koboSpan" id="kobo.592.1">6</span></span><span class="koboSpan" id="kobo.593.1">,
        retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(</span><span class="hljs-number"><span class="koboSpan" id="kobo.594.1">2</span></span><span class="koboSpan" id="kobo.595.1">,
            retryAttempt)));
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.596.1">The first argument of </span><code class="inlineCode"><span class="koboSpan" id="kobo.597.1">WaitAndRetryAsync</span></code><span class="koboSpan" id="kobo.598.1"> specifies that a maximum of six retries is performed in the event</span><a id="_idIndexMarker832"/><span class="koboSpan" id="kobo.599.1"> of failure. </span><span class="koboSpan" id="kobo.599.2">The lambda function passed as the second argument specifies how much time to wait before the next attempt. </span><span class="koboSpan" id="kobo.599.3">In this specific example, this time grows exponentially with the number of attempts by a power of 2 (2 seconds for the first retry, 4 seconds for the second retry, and so on).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.600.1">The following is a simple circuit breaker policy:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.601.1">var</span></span><span class="koboSpan" id="kobo.602.1"> breakerPolicy =Policy
    .Handle&lt;SomeExceptionType&gt;()
    .CircuitBreakerAsync (</span><span class="hljs-number"><span class="koboSpan" id="kobo.603.1">6</span></span><span class="koboSpan" id="kobo.604.1">, TimeSpan.FromMinutes(</span><span class="hljs-number"><span class="koboSpan" id="kobo.605.1">1</span></span><span class="koboSpan" id="kobo.606.1">));
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.607.1">After six failures, the task can’t be executed for one minute since an exception is returned.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.608.1">The following is the implementation of the Bulkhead Isolation policy (see the </span><em class="italic"><span class="koboSpan" id="kobo.609.1">Microservices design principles</span></em><span class="koboSpan" id="kobo.610.1"> section for more information):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.611.1">Policy
  .BulkheadAsync(</span><span class="hljs-number"><span class="koboSpan" id="kobo.612.1">10</span></span><span class="koboSpan" id="kobo.613.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.614.1">15</span></span><span class="koboSpan" id="kobo.615.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.616.1">A maximum of 10 parallel executions is allowed in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.617.1">Execute</span></code><span class="koboSpan" id="kobo.618.1"> method. </span><span class="koboSpan" id="kobo.618.2">Further tasks are inserted in an execution queue. </span><span class="koboSpan" id="kobo.618.3">This has a limit of 15 tasks. </span><span class="koboSpan" id="kobo.618.4">If the queue limit is exceeded, an exception is thrown.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.619.1">For the Bulkhead Isolation policy to work properly and, in general, for every strategy to work properly, task executions must be triggered through the same policy instance; otherwise, Polly is unable to count how many executions of a specific task are active.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.620.1">Policies can be combined with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.621.1">Wrap</span></code><span class="koboSpan" id="kobo.622.1"> method:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.623.1">var</span></span><span class="koboSpan" id="kobo.624.1"> combinedPolicy = Policy
  .Wrap(retryPolicy, breakerPolicy);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.625.1">Polly offers several more options, such as generic methods for tasks that return a specific type, timeout policies, task result caching, the ability to define custom policies, and so on. </span><span class="koboSpan" id="kobo.625.2">It is also possible to configure Polly as part of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.626.1">HttpClient</span></code><span class="koboSpan" id="kobo.627.1"> definition in the dependency injection section of any ASP.NET Core and .NET application. </span><span class="koboSpan" id="kobo.627.2">This way, it is quite immediate to define resilient clients.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.628.1">Polly’s official documentation can be found in its GitHub repository here: </span><a href="https://github.com/App-vNext/Polly"><span class="url"><span class="koboSpan" id="kobo.629.1">https://github.com/App-vNext/Polly</span></span></a><span class="koboSpan" id="kobo.630.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.631.1">The practical usage of Polly is explained in the </span><em class="italic"><span class="koboSpan" id="kobo.632.1">A worker microservice with ASP.NET Core</span></em><span class="koboSpan" id="kobo.633.1"> section of </span><em class="chapterRef"><span class="koboSpan" id="kobo.634.1">Chapter 21</span></em><span class="koboSpan" id="kobo.635.1">, </span><em class="italic"><span class="koboSpan" id="kobo.636.1">Case Study</span></em><span class="koboSpan" id="kobo.637.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.638.1">The resilience and robustness</span><a id="_idIndexMarker833"/><span class="koboSpan" id="kobo.639.1"> provided by tools like Polly are crucial components of microservice architecture, particularly when managing complex tasks and processes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.640.1">This brings us to another fundamental aspect of microservices: the implementation of generic hosts.</span></p>
<h2 class="heading-2" id="_idParaDest-233"><span class="koboSpan" id="kobo.641.1">Using generic hosts</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.642.1">Each microservice may need to run several</span><a id="_idIndexMarker834"/><span class="koboSpan" id="kobo.643.1"> independent threads, with each performing a different operation on requests received. </span><span class="koboSpan" id="kobo.643.2">Such threads need several resources, such as database connections, communication channels, specialized modules that perform complex operations, and so on. </span><span class="koboSpan" id="kobo.643.3">Moreover, all processing threads must be adequately initialized when the microservice is started and gracefully stopped when the microservice is stopped as a consequence of either load-balancing or errors.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.644.1">All of these needs led the .NET team to conceive and implement </span><em class="italic"><span class="koboSpan" id="kobo.645.1">hosted services</span></em><span class="koboSpan" id="kobo.646.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.647.1">hosts</span></em><span class="koboSpan" id="kobo.648.1">. </span><span class="koboSpan" id="kobo.648.2">A host creates</span><a id="_idIndexMarker835"/><span class="koboSpan" id="kobo.649.1"> an adequate environment for running several tasks, known as </span><strong class="keyWord"><span class="koboSpan" id="kobo.650.1">hosted services</span></strong><span class="koboSpan" id="kobo.651.1">, and provides them with resources, common settings, and a graceful start/stop.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.652.1">The concept of a web host was initially conceived to implement the ASP.NET Core web framework, but, with effect from .NET Core 2.1, the host concept was extended to all .NET applications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.653.1">At the time of writing this book, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.654.1">Host</span></code><span class="koboSpan" id="kobo.655.1"> is automatically created for you in any ASP.NET Core, Blazor, and Worker Service project. </span><span class="koboSpan" id="kobo.655.2">The simplest way to test .NET Host features is to select a </span><strong class="screenText"><span class="koboSpan" id="kobo.656.1">Service -&gt; Worker Service</span></strong><span class="koboSpan" id="kobo.657.1"> project.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.658.1"><img alt="" role="presentation" src="../Images/B19820_11_07.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.659.1">Figure 11.7: Creating a Worker Service project in Visual Studio</span></p>
<p class="normal"><span class="koboSpan" id="kobo.660.1">All features related to the concept</span><a id="_idIndexMarker836"/><span class="koboSpan" id="kobo.661.1"> of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.662.1">Host</span></code><span class="koboSpan" id="kobo.663.1"> are contained in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.664.1">Microsoft.Extensions.Hosting</span></code><span class="koboSpan" id="kobo.665.1"> NuGet package.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.666.1">Program.cs</span></code><span class="koboSpan" id="kobo.667.1"> contains some skeleton code for configuring the host with a fluent interface, starting with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.668.1">CreateDefaultBuilder</span></code><span class="koboSpan" id="kobo.669.1"> method of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.670.1">Host</span></code><span class="koboSpan" id="kobo.671.1"> class. </span><span class="koboSpan" id="kobo.671.2">The final step of this configuration is calling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.672.1">Build</span></code><span class="koboSpan" id="kobo.673.1"> method, which assembles the actual host with all the configuration information we provided:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.674.1">...
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.675.1">var</span></span><span class="koboSpan" id="kobo.676.1"> myHost=Host.CreateDefaultBuilder(args)
 .ConfigureServices(services =&gt;
    {
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.677.1">//some configuration</span></span><span class="koboSpan" id="kobo.678.1">
        ...
    </span><span class="koboSpan" id="kobo.678.2">})
    .Build();
...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.679.1">Host configuration includes</span><a id="_idIndexMarker837"/><span class="koboSpan" id="kobo.680.1"> defining the common resources, defining the default folder for files, loading the configuration parameters from several sources (JSON files, environment variables, and any arguments that are passed to the application), and declaring all the hosted services.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.681.1">It is worth pointing out that ASP.NET Core and Blazor projects use methods that perform pre-configuration of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.682.1">Host</span></code><span class="koboSpan" id="kobo.683.1">, including several of the tasks listed previously.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.684.1">Then, the host is started, which causes all the hosted services to be started:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.685.1">await</span></span><span class="koboSpan" id="kobo.686.1"> host.RunAsync();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.687.1">The program remains blocked on the preceding instruction until the host is shut down. </span><span class="koboSpan" id="kobo.687.2">The host is automatically shut down when the operating system kills the process. </span><span class="koboSpan" id="kobo.687.3">However, the host can also be shut down manually either by one of the hosted services or externally by calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.688.1">await host.StopAsync(timeout)</span></code><span class="koboSpan" id="kobo.689.1">. </span><span class="koboSpan" id="kobo.689.2">Here, </span><code class="inlineCode"><span class="koboSpan" id="kobo.690.1">timeout</span></code><span class="koboSpan" id="kobo.691.1"> is a time span defining the maximum time to wait for the hosted services to stop gracefully. </span><span class="koboSpan" id="kobo.691.2">After this time, all the hosted services are aborted if they haven’t been terminated. </span><span class="koboSpan" id="kobo.691.3">We will explain how a hosted service can shut down the host later on in this subsection.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.692.1">When the thread contains a </span><code class="inlineCode"><span class="koboSpan" id="kobo.693.1">host.RunAsync</span></code><span class="koboSpan" id="kobo.694.1"> is launched from within another thread instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.695.1">Program.cs</span></code><span class="koboSpan" id="kobo.696.1">. </span><span class="koboSpan" id="kobo.696.2">The fact that the host thread is being shut down can be signaled by a </span><code class="inlineCode"><span class="koboSpan" id="kobo.697.1">cancellationToken</span></code><span class="koboSpan" id="kobo.698.1"> passed to </span><code class="inlineCode"><span class="koboSpan" id="kobo.699.1">RunAsync</span></code><span class="koboSpan" id="kobo.700.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.701.1">await</span></span><span class="koboSpan" id="kobo.702.1"> host.RunAsync(cancellationToken)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.703.1">This way of shutting down is triggered as soon as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.704.1">cancellationToken</span></code><span class="koboSpan" id="kobo.705.1"> enters a canceled state by another thread.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.706.1">By default, the host has a 5-second timeout for shutting down; that is, it waits 5 seconds before exiting once a shutdown has been requested. </span><span class="koboSpan" id="kobo.706.2">This time can be changed within the </span><code class="inlineCode"><span class="koboSpan" id="kobo.707.1">ConfigureServices</span></code><span class="koboSpan" id="kobo.708.1"> method, which is used to declare </span><em class="italic"><span class="koboSpan" id="kobo.709.1">hosted services</span></em><span class="koboSpan" id="kobo.710.1"> and other resources:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.711.1">var</span></span><span class="koboSpan" id="kobo.712.1"> myHost = Host.CreateDefaultBuilder(args)
    .ConfigureServices(services =&gt;
    {
        services.Configure&lt;HostOptions&gt;(option =&gt;
        {
            option.ShutdownTimeout = System.TimeSpan.FromSeconds(</span><span class="hljs-number"><span class="koboSpan" id="kobo.713.1">10</span></span><span class="koboSpan" id="kobo.714.1">);
        });
        ....
        </span><span class="koboSpan" id="kobo.714.2">....
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.715.1">//further configuration</span></span><span class="koboSpan" id="kobo.716.1">
    })
    .Build();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.717.1">However, increasing the host</span><a id="_idIndexMarker838"/><span class="koboSpan" id="kobo.718.1"> timeout doesn’t increase the orchestrator timeout, so if the host waits too long, the whole microservice is killed by the orchestrator.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.719.1">If no cancellation token is explicitly passed to </span><code class="inlineCode"><span class="koboSpan" id="kobo.720.1">Run</span></code><span class="koboSpan" id="kobo.721.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.722.1">RunAsync</span></code><span class="koboSpan" id="kobo.723.1">, a cancellation token is automatically generated and is automatically signaled when the operating system informs the application it is going to kill it. </span><span class="koboSpan" id="kobo.723.2">This cancellation token is passed to all hosted services to give them the opportunity to stop gracefully.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.724.1">Hosted services are implementations of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.725.1">IHostedService</span></code><span class="koboSpan" id="kobo.726.1"> interface, whose only methods are </span><code class="inlineCode"><span class="koboSpan" id="kobo.727.1">StartAsync(cancellationToken)</span></code><span class="koboSpan" id="kobo.728.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.729.1">StopAsync(cancellationToken)</span></code><span class="koboSpan" id="kobo.730.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.731.1">Both methods are passed a </span><code class="inlineCode"><span class="koboSpan" id="kobo.732.1">cancellationToken</span></code><span class="koboSpan" id="kobo.733.1">. </span><span class="koboSpan" id="kobo.733.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.734.1">cancellationToken</span></code><span class="koboSpan" id="kobo.735.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.736.1">StartAsync</span></code><span class="koboSpan" id="kobo.737.1"> method signals that a shutdown was requested. </span><span class="koboSpan" id="kobo.737.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.738.1">StartAsync</span></code><span class="koboSpan" id="kobo.739.1"> method periodically checks this </span><code class="inlineCode"><span class="koboSpan" id="kobo.740.1">cancellationToken</span></code><span class="koboSpan" id="kobo.741.1"> while performing all operations needed to start the host, and if it is signaled, the host start process is aborted. </span><span class="koboSpan" id="kobo.741.2">On the other hand, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.742.1">cancellationToken</span></code><span class="koboSpan" id="kobo.743.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.744.1">StopAsync</span></code><span class="koboSpan" id="kobo.745.1"> method signals that the shutdown timeout expired.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.746.1">Hosted services can be declared in the same </span><code class="inlineCode"><span class="koboSpan" id="kobo.747.1">ConfigureServices</span></code><span class="koboSpan" id="kobo.748.1"> method that’s used to define host options, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.749.1">services.AddHostedService&lt;MyHostedService&gt;();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.750.1">Most declarations inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.751.1">ConfigureServices</span></code><span class="koboSpan" id="kobo.752.1"> require the addition of the following namespace:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.753.1">using</span></span><span class="koboSpan" id="kobo.754.1"> Microsoft.Extensions.DependencyInjection;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.755.1">Usually, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.756.1">IHostedService</span></code><span class="koboSpan" id="kobo.757.1"> interface</span><a id="_idIndexMarker839"/><span class="koboSpan" id="kobo.758.1"> isn’t implemented directly but can be inherited from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.759.1">BackgroundService</span></code><span class="koboSpan" id="kobo.760.1"> abstract class, which exposes the easier-to-implement </span><code class="inlineCode"><span class="koboSpan" id="kobo.761.1">ExecuteAsync(CancellationToken)</span></code><span class="koboSpan" id="kobo.762.1"> method, which is where we can place the whole logic of the service. </span><span class="koboSpan" id="kobo.762.2">A shutdown is signaled by passing </span><code class="inlineCode"><span class="koboSpan" id="kobo.763.1">cancellationToken</span></code><span class="koboSpan" id="kobo.764.1"> as an argument, which is easier to handle. </span><span class="koboSpan" id="kobo.764.2">We will look in more detail at an implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.765.1">IHostedService</span></code><span class="koboSpan" id="kobo.766.1"> in </span><em class="chapterRef"><span class="koboSpan" id="kobo.767.1">Chapter 14</span></em><span class="koboSpan" id="kobo.768.1">, </span><em class="italic"><span class="koboSpan" id="kobo.769.1">Implementing Microservices with .NET</span></em><span class="koboSpan" id="kobo.770.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.771.1">To allow a hosted service to shut down the whole host, we need to declare an </span><code class="inlineCode"><span class="koboSpan" id="kobo.772.1">IApplicationLifetime</span></code><span class="koboSpan" id="kobo.773.1"> interface as its constructor parameter:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.774.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.775.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.776.1">MyHostedService</span></span><span class="koboSpan" id="kobo.777.1">: </span><span class="hljs-title"><span class="koboSpan" id="kobo.778.1">BackgroundService</span></span><span class="koboSpan" id="kobo.779.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.780.1">private</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.781.1">readonly</span></span><span class="koboSpan" id="kobo.782.1"> IHostApplicationLifetime _applicationLifetime;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.783.1">public</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.784.1">MyHostedService</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.785.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.786.1">IHostApplicationLifetime applicationLifetime</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.787.1">)</span></span><span class="koboSpan" id="kobo.788.1">
    {
        _applicationLifetime=applicationLifetime;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.789.1">protected</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.790.1"> Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.791.1">ExecuteAsync</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.792.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.793.1">CancellationToken token</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.794.1">)</span></span><span class="koboSpan" id="kobo.795.1">
    {
        ...
        </span><span class="koboSpan" id="kobo.795.2">_applicationLifetime.StopApplication();
        ...
    </span><span class="koboSpan" id="kobo.795.3">}
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.796.1">When the hosted service is created, it is automatically passed an implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.797.1">IHostApplicationLifetime</span></code><span class="koboSpan" id="kobo.798.1">, whose </span><code class="inlineCode"><span class="koboSpan" id="kobo.799.1">StopApplication</span></code><span class="koboSpan" id="kobo.800.1"> method will trigger the host shutdown. </span><span class="koboSpan" id="kobo.800.2">This implementation is handled automatically, but we can also declare custom resources whose instances will be automatically passed to all the host service constructors that declare them as parameters. </span><span class="koboSpan" id="kobo.800.3">Therefore, say we define a constructor like this one:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.801.1">Public </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.802.1">MyClass</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.803.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.804.1">MyResource x, IResourceInterface1 y</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.805.1">)</span></span><span class="koboSpan" id="kobo.806.1">
{
    ...
</span><span class="koboSpan" id="kobo.806.2">}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.807.1">There are several ways to define the resources needed by the preceding constructor:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.808.1">services.AddTransient&lt;MyResource&gt;();
services.AddTransient&lt;IResourceInterface1, MyResource1&gt;();
services.AddSingleton&lt;MyResource&gt;();
services.AddSingleton&lt;IResourceInterface1, MyResource1&gt;();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.809.1">When we use </span><code class="inlineCode"><span class="koboSpan" id="kobo.810.1">AddTransient</span></code><span class="koboSpan" id="kobo.811.1">, a different instance is created and passed to all the constructors that require an instance of that type. </span><span class="koboSpan" id="kobo.811.2">On the other hand, with </span><code class="inlineCode"><span class="koboSpan" id="kobo.812.1">AddSingleton</span></code><span class="koboSpan" id="kobo.813.1">, a unique instance is created and passed to all the constructors that require the declared type. </span><span class="koboSpan" id="kobo.813.2">The overload with two generic types allows you to pass an interface and a type that implements that interface. </span><span class="koboSpan" id="kobo.813.3">This way, a constructor requires the interface and is decoupled from the specific implementation of that interface.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.814.1">If resource constructors contain parameters, they will be automatically instantiated with the types declared in </span><code class="inlineCode"><span class="koboSpan" id="kobo.815.1">ConfigureServices</span></code><span class="koboSpan" id="kobo.816.1"> in a recursive</span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.817.1"> fashion. </span><span class="koboSpan" id="kobo.817.2">This pattern of interaction, called </span><strong class="keyWord"><span class="koboSpan" id="kobo.818.1">dependency injection</span></strong><span class="koboSpan" id="kobo.819.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.820.1">DI</span></strong><span class="koboSpan" id="kobo.821.1">), has already been discussed in detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.822.1">Chapter 6</span></em><span class="koboSpan" id="kobo.823.1">, </span><em class="italic"><span class="koboSpan" id="kobo.824.1">Design Patterns and .NET 8 Implementation</span></em><span class="koboSpan" id="kobo.825.1">.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.826.1">IHostBuilder</span></code><span class="koboSpan" id="kobo.827.1"> also has a method</span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.828.1"> we can use to define the default folder – that is, the folder used to resolve all relative paths mentioned in all .NET methods:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.829.1">.UseContentRoot(</span><span class="hljs-string"><span class="koboSpan" id="kobo.830.1">"c:\\&lt;deault path&gt;"</span></span><span class="koboSpan" id="kobo.831.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.832.1">It also has methods that we can use to add logging targets:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.833.1">.ConfigureLogging((hostContext, configLogging) =&gt;
    {
        configLogging.AddConsole();
        configLogging.AddDebug();
    })
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.834.1">The previous example shows a console-based logging source, but we can also log in to Azure targets with adequate providers. </span><span class="koboSpan" id="kobo.834.2">The </span><em class="italic"><span class="koboSpan" id="kobo.835.1">Further reading</span></em><span class="koboSpan" id="kobo.836.1"> section contains links to some Azure logging providers that can work with microservices that have been deployed in Azure. </span><span class="koboSpan" id="kobo.836.2">Once you’ve configured logging, you can enable your hosted services and log custom messages by adding an </span><code class="inlineCode"><span class="koboSpan" id="kobo.837.1">ILogger&lt;T&gt;</span></code><span class="koboSpan" id="kobo.838.1"> parameter in their constructors. </span><code class="inlineCode"><span class="koboSpan" id="kobo.839.1">ILogger&lt;T&gt; </span></code><span class="koboSpan" id="kobo.840.1">has methods for logging messages with several severity levels: Trace, Debug (lowest), Information, Warning, Error, Critical, and None (highest). </span><span class="koboSpan" id="kobo.840.2">In turn, the application configuration specifies the minimum severity level needed to actually output log messages. </span><span class="koboSpan" id="kobo.840.3">All messages that pass the severity filter are simultaneously sent to all configured targets.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.841.1">The only purpose of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.842.1">T</span></code><span class="koboSpan" id="kobo.843.1"> is to classify the message through its full name.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.844.1">The developer can specify the minimum severity level in a configuration file. </span><span class="koboSpan" id="kobo.844.2">We may have different severity levels for each type of </span><code class="inlineCode"><span class="koboSpan" id="kobo.845.1">T</span></code><span class="koboSpan" id="kobo.846.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.847.1">For instance:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.848.1">{
  </span><span class="hljs-string"><span class="koboSpan" id="kobo.849.1">"Logging"</span></span><span class="koboSpan" id="kobo.850.1">: {
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.851.1">"LogLevel"</span></span><span class="koboSpan" id="kobo.852.1">: {
      </span><span class="hljs-string"><span class="koboSpan" id="kobo.853.1">"Default"</span></span><span class="koboSpan" id="kobo.854.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.855.1">"Information"</span></span><span class="koboSpan" id="kobo.856.1">,
      </span><span class="hljs-string"><span class="koboSpan" id="kobo.857.1">"Microsoft.AspNetCore"</span></span><span class="koboSpan" id="kobo.858.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.859.1">"Warning"</span></span><span class="koboSpan" id="kobo.860.1">
    }
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.861.1">In the above configuration file, the default severity</span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.862.1"> level is “</span><code class="inlineCode"><span class="koboSpan" id="kobo.863.1">Information</span></code><span class="koboSpan" id="kobo.864.1">”, but all types whose name starts with “</span><code class="inlineCode"><span class="koboSpan" id="kobo.865.1">Microsoft.AspNetCore</span></code><span class="koboSpan" id="kobo.866.1">” have a “</span><code class="inlineCode"><span class="koboSpan" id="kobo.867.1">Warning</span></code><span class="koboSpan" id="kobo.868.1">” severity level.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.869.1">Finally, </span><code class="inlineCode"><span class="koboSpan" id="kobo.870.1">IHostBuilder</span></code><span class="koboSpan" id="kobo.871.1"> has methods we can use to read configuration parameters from various sources:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.872.1">.ConfigureAppConfiguration(configHost =&gt;
    {
        configHost.AddJsonFile(</span><span class="hljs-string"><span class="koboSpan" id="kobo.873.1">"settings.json"</span></span><span class="koboSpan" id="kobo.874.1">, optional: </span><span class="hljs-literal"><span class="koboSpan" id="kobo.875.1">true</span></span><span class="koboSpan" id="kobo.876.1">);
        configHost.AddEnvironmentVariables(prefix: </span><span class="hljs-string"><span class="koboSpan" id="kobo.877.1">"PREFIX_"</span></span><span class="koboSpan" id="kobo.878.1">);
        configHost.AddCommandLine(args);
    })
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.879.1">The way parameters defined in configuration streams can be used from inside the application will be explained in more detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.880.1">Chapter 17</span></em><span class="koboSpan" id="kobo.881.1">, </span><em class="italic"><span class="koboSpan" id="kobo.882.1">Presenting ASP.NET Core</span></em><span class="koboSpan" id="kobo.883.1">, which is dedicated to ASP.NET.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.884.1">As we transition from the specificities of ASP.NET Core to the broader realm of application deployment and environment setup, an important tool comes into play – Visual Studio Docker support.</span></p>
<h2 class="heading-2" id="_idParaDest-234"><span class="koboSpan" id="kobo.885.1">Visual Studio support for Docker</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.886.1">Visual Studio offers support</span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.887.1"> for creating, debugging, and deploying</span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.888.1"> Docker images. </span><span class="koboSpan" id="kobo.888.2">Docker deployment requires us to install </span><em class="italic"><span class="koboSpan" id="kobo.889.1">Docker Desktop for Windows</span></em><span class="koboSpan" id="kobo.890.1"> on our development machine so that we can run Docker images. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.891.1">The download link can be found in the </span><em class="italic"><span class="koboSpan" id="kobo.892.1">Technical requirements</span></em><span class="koboSpan" id="kobo.893.1"> section at the beginning of this chapter. </span><span class="koboSpan" id="kobo.893.2">Before we start any development activity, we must ensure it is installed and running (you should see a Docker icon in the window notification bar when the Docker runtime is running).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.894.1">Docker support will be described with a simple ASP.NET Core MVC project. </span><span class="koboSpan" id="kobo.894.2">Let’s create one. </span><span class="koboSpan" id="kobo.894.3">To do so, follow these steps:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.895.1">Name the project </span><code class="inlineCode"><span class="koboSpan" id="kobo.896.1">MvcDockerTest</span></code><span class="koboSpan" id="kobo.897.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.898.1">For simplicity, disable authentication if it is not already disabled.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.899.1">You are given the option to add Docker support when you create the project, but please don’t check the </span><strong class="screenText"><span class="koboSpan" id="kobo.900.1">Docker support</span></strong><span class="koboSpan" id="kobo.901.1"> checkbox. </span><span class="koboSpan" id="kobo.901.2">You can test how Docker support can be added to any project after it has been created.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.902.1">Once you have your ASP.NET MVC application scaffolded and running, right-click on its project icon in </span><strong class="screenText"><span class="koboSpan" id="kobo.903.1">Solution Explorer</span></strong><span class="koboSpan" id="kobo.904.1">, select </span><strong class="screenText"><span class="koboSpan" id="kobo.905.1">Add</span></strong><span class="koboSpan" id="kobo.906.1">, and then select </span><strong class="screenText"><span class="koboSpan" id="kobo.907.1">Container Orchestrator Support | Docker Compose</span></strong><span class="koboSpan" id="kobo.908.1">. </span><span class="koboSpan" id="kobo.908.2">If you installed both </span><strong class="screenText"><span class="koboSpan" id="kobo.909.1">WSL</span></strong><span class="koboSpan" id="kobo.910.1"> and </span><strong class="screenText"><span class="koboSpan" id="kobo.911.1">Windows Containers</span></strong><span class="koboSpan" id="kobo.912.1">, a dialog for choosing between </span><strong class="screenText"><span class="koboSpan" id="kobo.913.1">Linux</span></strong><span class="koboSpan" id="kobo.914.1"> and </span><strong class="screenText"><span class="koboSpan" id="kobo.915.1">Windows</span></strong><span class="koboSpan" id="kobo.916.1"> will appear. </span><span class="koboSpan" id="kobo.916.2">Otherwise, </span><strong class="screenText"><span class="koboSpan" id="kobo.917.1">Linux</span></strong><strong class="keyWord"> </strong><span class="koboSpan" id="kobo.918.1">will be automatically chosen if you installed just </span><strong class="screenText"><span class="koboSpan" id="kobo.919.1">WSL</span></strong><span class="koboSpan" id="kobo.920.1">, and </span><strong class="screenText"><span class="koboSpan" id="kobo.921.1">Windows</span></strong><span class="koboSpan" id="kobo.922.1"> if you installed just </span><strong class="screenText"><span class="koboSpan" id="kobo.923.1">Windows Containers</span></strong><span class="koboSpan" id="kobo.924.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.925.1">If you installed </span><strong class="screenText"><span class="koboSpan" id="kobo.926.1">WSL</span></strong><strong class="keyWord"><span class="koboSpan" id="kobo.927.1">,</span></strong><span class="koboSpan" id="kobo.928.1"> please select </span><strong class="screenText"><span class="koboSpan" id="kobo.929.1">Linux</span></strong><span class="koboSpan" id="kobo.930.1">, since it is the default used by the Docker server when WSL is available.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.931.1">The advantage of enabling Docker Compose instead of just Docker is that you can manually configure how the image is run on the development machine, as well as how Docker image ports are mapped to external ports by editing the Docker Compose files that are added to the solution.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.932.1">If your Docker runtime has been installed properly and is running, you should be able to run the Docker image from Visual Studio. </span><span class="koboSpan" id="kobo.932.2">Please try it!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.933.1">Now that we have explored how to configure and run Docker images, let’s delve deeper into the structure and composition of these images. </span><span class="koboSpan" id="kobo.933.2">Understanding the Docker file created by Visual Studio is key to grasping how it orchestrates the creation and management of these images.</span></p>
<h3 class="heading-3" id="_idParaDest-235"><span class="koboSpan" id="kobo.934.1">Analyzing the Docker file</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.935.1">Let’s analyze the Docker file</span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.936.1"> that was created by Visual Studio. </span><span class="koboSpan" id="kobo.936.2">It is a sequence of image creation steps. </span><span class="koboSpan" id="kobo.936.3">Each step enriches an existing image with something else with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.937.1">From</span></code><span class="koboSpan" id="kobo.938.1"> instruction, which is a reference to an already existing image. </span><span class="koboSpan" id="kobo.938.2">The following is the first step:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.939.1">FROM mcr.microsoft.com/dotnet/aspnet:x.x AS </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.940.1">base</span></span><span class="koboSpan" id="kobo.941.1">
WORKDIR /app
EXPOSE </span><span class="hljs-number"><span class="koboSpan" id="kobo.942.1">80</span></span><span class="koboSpan" id="kobo.943.1">
EXPOSE </span><span class="hljs-number"><span class="koboSpan" id="kobo.944.1">443</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.945.1">The first step uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.946.1">mcr.microsoft.com/dotnet/aspnet:x.x</span></code><span class="koboSpan" id="kobo.947.1"> ASP.NET (Core) runtime that was published by Microsoft in the Docker public repository (where </span><code class="inlineCode"><span class="koboSpan" id="kobo.948.1">x.x</span></code><span class="koboSpan" id="kobo.949.1"> is the ASP.NET (Core) version that was selected in your project).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.950.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.951.1">WORKDIR</span></code><span class="koboSpan" id="kobo.952.1"> command creates the directory that follows the command within the image that is going to be created. </span><span class="koboSpan" id="kobo.952.2">The two </span><code class="inlineCode"><span class="koboSpan" id="kobo.953.1">EXPOSE</span></code><span class="koboSpan" id="kobo.954.1"> commands declare which ports will be exposed outside the image and mapped to ports of the actual hosting machine. </span><span class="koboSpan" id="kobo.954.2">Mapped ports are decided in the deployment stage either as command-line arguments of a Docker command or within a Docker Compose file. </span><span class="koboSpan" id="kobo.954.3">In our case, there are two ports: one for HTTP (80) and another for HTTPS (443).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.955.1">This intermediate image is cached by Docker, which doesn’t need to recompute since it doesn’t depend on the code we write but only on the selected version of the ASP.NET (Core) runtime.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.956.1">The second step produces a different image that will not be used to deploy. </span><span class="koboSpan" id="kobo.956.2">Instead, it will be used to create application-specific files that will be deployed:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.957.1">FROM mcr.microsoft.com/dotnet/core/sdk:x.x  AS build
WORKDIR /src
COPY [</span><span class="hljs-string"><span class="koboSpan" id="kobo.958.1">"MvcDockerTest/MvcDockerTest.csproj"</span></span><span class="koboSpan" id="kobo.959.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.960.1">"MvcDockerTest/"</span></span><span class="koboSpan" id="kobo.961.1">]
RUN dotnet restore MvcDockerTest/MvcDockerTest.csproj
COPY . </span><span class="koboSpan" id="kobo.961.2">.
</span><span class="koboSpan" id="kobo.961.3">WORKDIR /src/MvcDockerTest
RUN dotnet build MvcDockerTest.csproj -c Release -o /app/build
FROM build AS publish
RUN dotnet publish MvcDockerTest.csproj -c Release -o /app/publish
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.962.1">This step starts from the ASP.NET SDK image, which contains parts we don’t need to add for deployment; these are needed to process the project code. </span><span class="koboSpan" id="kobo.962.2">The new </span><code class="inlineCode"><span class="koboSpan" id="kobo.963.1">src</span></code><span class="koboSpan" id="kobo.964.1"> directory is created in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.965.1">build</span></code><span class="koboSpan" id="kobo.966.1"> image and made the current image directory. </span><span class="koboSpan" id="kobo.966.2">Then, the project file is copied into </span><code class="inlineCode"><span class="koboSpan" id="kobo.967.1">/src/MvcDockerTest</span></code><span class="koboSpan" id="kobo.968.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.969.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.970.1">RUN</span></code><span class="koboSpan" id="kobo.971.1"> command executes an operating system command on the image. </span><span class="koboSpan" id="kobo.971.2">In this case, it calls the </span><code class="inlineCode"><span class="koboSpan" id="kobo.972.1">dotnet</span></code><span class="koboSpan" id="kobo.973.1"> runtime, asking it to restore the NuGet packages that were referenced by the previously copied project file.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.974.1">Then, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.975.1">COPY..</span></code><span class="koboSpan" id="kobo.976.1"> command copies</span><a id="_idIndexMarker846"/><span class="koboSpan" id="kobo.977.1"> the whole project file tree into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.978.1">src</span></code><span class="koboSpan" id="kobo.979.1"> image directory. </span><span class="koboSpan" id="kobo.979.2">Finally, the project directory is made the current directory, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.980.1">dotnet</span></code><span class="koboSpan" id="kobo.981.1"> runtime is asked to build the project in release mode and copy all the output files into the new </span><code class="inlineCode"><span class="koboSpan" id="kobo.982.1">/app/build</span></code><span class="koboSpan" id="kobo.983.1"> directory. </span><span class="koboSpan" id="kobo.983.2">Finally, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.984.1">dotnet publish</span></code><span class="koboSpan" id="kobo.985.1"> task is executed in a new image called </span><code class="inlineCode"><span class="koboSpan" id="kobo.986.1">publish</span></code><span class="koboSpan" id="kobo.987.1">, outputting the published binaries into </span><code class="inlineCode"><span class="koboSpan" id="kobo.988.1">/app/publish</span></code><span class="koboSpan" id="kobo.989.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.990.1">The final step starts from the image that we created in the first step, which contains the ASP.NET (Core) runtime and adds all the files that were published in the previous step:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.991.1">FROM </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.992.1">base</span></span><span class="koboSpan" id="kobo.993.1"> AS final
WORKDIR /app
COPY --</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.994.1">from</span></span><span class="koboSpan" id="kobo.995.1">=publish /app/publish .
</span><span class="koboSpan" id="kobo.995.2">ENTRYPOINT [</span><span class="hljs-string"><span class="koboSpan" id="kobo.996.1">"dotnet"</span></span><span class="koboSpan" id="kobo.997.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.998.1">"MvcDockerTest.dll"</span></span><span class="koboSpan" id="kobo.999.1">]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1000.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1001.1">ENTRYPOINT</span></code><span class="koboSpan" id="kobo.1002.1"> command specifies the operating system command that’s needed to execute the image. </span><span class="koboSpan" id="kobo.1002.2">It accepts an array of strings. </span><span class="koboSpan" id="kobo.1002.3">In our case, it accepts the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1003.1">dotnet</span></code><span class="koboSpan" id="kobo.1004.1"> command and its first command-line argument – that is, the DLL we need to execute. </span><span class="koboSpan" id="kobo.1004.2">With that out of the way, let’s now publish our little project!</span></p>
<h3 class="heading-3" id="_idParaDest-236"><span class="koboSpan" id="kobo.1005.1">Publishing the project</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.1006.1">If we right-click on our project</span><a id="_idIndexMarker847"/><span class="koboSpan" id="kobo.1007.1"> and click </span><strong class="keyWord"><span class="koboSpan" id="kobo.1008.1">Publish</span></strong><span class="koboSpan" id="kobo.1009.1">, we are presented with several options:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1010.1">Publish the image to an existing or new web app (automatically created by Visual Studio)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1011.1">Publish to one of several Docker registries, including a private registry in Azure Container Registry that, if it doesn’t already exist, can be created from within Visual Studio</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1012.1">Docker Compose support allows you to run and publish a multi-container application and add further images, such as a containerized database that is available everywhere.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1013.1">The following Docker Compose file instructs the Docker server to run two containerized ASP.NET applications:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1014.1">version: </span><span class="hljs-string"><span class="koboSpan" id="kobo.1015.1">'3.4'</span></span><span class="koboSpan" id="kobo.1016.1">
services:
  mvcdockertest:
    image: ${DOCKER_REGISTRY-}mvcdockertest
    build:
      context: .
      </span><span class="koboSpan" id="kobo.1016.2">dockerfile: MvcDockerTest/Dockerfile
  mvcdockertest1:
    image: ${DOCKER_REGISTRY-}mvcdockertest1
    build:
      context: .
      </span><span class="koboSpan" id="kobo.1016.3">dockerfile: MvcDockerTest1/Dockerfile
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1017.1">You can add another ASP:NET Core MVC application</span><a id="_idIndexMarker848"/><span class="koboSpan" id="kobo.1018.1"> to our previous docker-compose file by just adding another ASP:NET Core MVC application named MvcDockerTest 1 to the solution and by enabling docker-compose on it. </span><span class="koboSpan" id="kobo.1018.2">However, you must pay attention to the fact that the newly created project folder is placed inside the same solution folder as MvcDockerTest.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1019.1">The preceding code references existing Docker files. </span><span class="koboSpan" id="kobo.1019.2">Any environment-dependent information is placed in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1020.1">docker-compose.override.yml</span></code><span class="koboSpan" id="kobo.1021.1"> file, which is merged with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1022.1">docker-compose.yml</span></code><span class="koboSpan" id="kobo.1023.1"> file when the application is launched from Visual Studio:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1024.1">version: </span><span class="hljs-string"><span class="koboSpan" id="kobo.1025.1">'3.4'</span></span><span class="koboSpan" id="kobo.1026.1">
services:
  mvcdockertest:
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ASPNETCORE_URLS=https:</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1027.1">//+:443;http://+:80</span></span><span class="koboSpan" id="kobo.1028.1">
    ports:
      - </span><span class="hljs-string"><span class="koboSpan" id="kobo.1029.1">"80"</span></span><span class="koboSpan" id="kobo.1030.1">
      - </span><span class="hljs-string"><span class="koboSpan" id="kobo.1031.1">"443"</span></span><span class="koboSpan" id="kobo.1032.1">
    volumes:
      -${APPDATA}/Microsoft/UserSecrets:/root/.microsoft/usersecrets:ro
      - ${APPDATA}/ASP.NET/Https:/root/.aspnet/https:ro
  mvcdockertest1:
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ASPNETCORE_URLS=https:</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1033.1">//+:443;http://+:80</span></span><span class="koboSpan" id="kobo.1034.1">
    ports:
      - </span><span class="hljs-string"><span class="koboSpan" id="kobo.1035.1">"80"</span></span><span class="koboSpan" id="kobo.1036.1">
      - </span><span class="hljs-string"><span class="koboSpan" id="kobo.1037.1">"443"</span></span><span class="koboSpan" id="kobo.1038.1">
    volumes:
      - ${APPDATA}/Microsoft/UserSecrets:/root/.microsoft/usersecrets:ro
      - ${APPDATA}/ASP.NET/Https:/root/.aspnet/https:ro
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1039.1">For each image, the file specifies some environment variables (which will be defined in the image when the application is launched), the port mappings, and some host files.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1040.1">The files in the host are directly mapped into the images. </span><span class="koboSpan" id="kobo.1040.2">Each declaration contains the path in the host, how the path is mapped in the image, and the desired access rights. </span><span class="koboSpan" id="kobo.1040.3">In our case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1041.1">volumes</span></code><span class="koboSpan" id="kobo.1042.1"> are used to map the machine key used for all encryption needs of the application and the self-signed HTTPS certificate that’s used by Visual Studio.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1043.1">When you launch the application in Visual Studio, just the browser window opens and shows the </span><strong class="screenText"><span class="koboSpan" id="kobo.1044.1">MvcDockerTest</span></strong><span class="koboSpan" id="kobo.1045.1"> application. </span><span class="koboSpan" id="kobo.1045.2">However, both applications are launched, so you just need to discover which port </span><strong class="screenText"><span class="koboSpan" id="kobo.1046.1">MvcDockerTest1</span></strong><span class="koboSpan" id="kobo.1047.1"> is running on and open another browser window. </span><span class="koboSpan" id="kobo.1047.2">You can discover the port by clicking on </span><strong class="screenText"><span class="koboSpan" id="kobo.1048.1">MvcDockerTest1</span></strong><span class="koboSpan" id="kobo.1049.1"> in the Containers tab in Visual Studio</span><a id="_idIndexMarker849"/><span class="koboSpan" id="kobo.1050.1"> and looking at its HTTPS </span><strong class="screenText"><span class="koboSpan" id="kobo.1051.1">Host Port</span></strong><span class="koboSpan" id="kobo.1052.1"> (</span><strong class="screenText"><span class="koboSpan" id="kobo.1053.1">60072</span></strong><span class="koboSpan" id="kobo.1054.1">), as shown in the figure below:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1055.1"><img alt="" role="presentation" src="../Images/B19820_11_08.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1056.1">Figure 11.8: Discovering the MvcDockerTest1 host port</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1057.1">Now, suppose we want to add a containerized SQL Server instance. </span><span class="koboSpan" id="kobo.1057.2">We would need something like the following instructions split between </span><code class="inlineCode"><span class="koboSpan" id="kobo.1058.1">docker-compose.yml</span></code><span class="koboSpan" id="kobo.1059.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1060.1">docker-compose.override.yml</span></code><span class="koboSpan" id="kobo.1061.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1062.1">sql.data:
  image: mcr.microsoft.com/mssql/server:</span><span class="hljs-number"><span class="koboSpan" id="kobo.1063.1">2022</span></span><span class="koboSpan" id="kobo.1064.1">-latest
  environment:
  - SA_PASSWORD=Pass@word
  - ACCEPT_EULA=Y
  - MSSQL_PID=Express
  ports:
  - </span><span class="hljs-string"><span class="koboSpan" id="kobo.1065.1">"5433:1433"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1066.1">Here, the preceding code specifies the properties of the SQL Server container, as well as the SQL Server configuration and installation parameters. </span><span class="koboSpan" id="kobo.1066.2">More specifically, the preceding code contains the following information:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1067.1">sql.data</span></code><span class="koboSpan" id="kobo.1068.1"> is the name that’s given to the container.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1069.1">image</span></code><span class="koboSpan" id="kobo.1070.1"> specifies where to take the image from. </span><span class="koboSpan" id="kobo.1070.2">In our case, the image is contained in a public Docker registry.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1071.1">environment</span></code><span class="koboSpan" id="kobo.1072.1"> specifies the environment</span><a id="_idIndexMarker850"/><span class="koboSpan" id="kobo.1073.1"> variables that are needed by SQL Server – that is, the administrator password, the acceptance of a SQL Server license, and the SQL Server edition.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1074.1">As usual, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1075.1">ports</span></code><span class="koboSpan" id="kobo.1076.1"> specify the port mappings.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1077.1">docker-compose.override.yml</span></code><span class="koboSpan" id="kobo.1078.1"> is used to run the images from within Visual Studio.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1079.1">If you need to specify parameters for either the production environment or the testing environment, you can add further </span><code class="inlineCode"><span class="koboSpan" id="kobo.1080.1">docker-compose-xxx.override.yml</span></code><span class="koboSpan" id="kobo.1081.1"> files, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1082.1">docker-compose-staging.override.yml</span></code><span class="koboSpan" id="kobo.1083.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1084.1">docker-compose-production.override.yml</span></code><span class="koboSpan" id="kobo.1085.1">, and then launch them manually in the target environment with something like the following code:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1086.1">docker-compose -f docker-compose.yml -f docker-compose-staging.override.yml up
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1087.1">Then, you can destroy all the containers with the following code:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1088.1">docker-compose -f docker-compose.yml -f docker-compose.staging.yml down
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1089.1">While </span><code class="inlineCode"><span class="koboSpan" id="kobo.1090.1">docker-compose</span></code><span class="koboSpan" id="kobo.1091.1"> has a limited capability when it comes to handling node clusters, it is mainly used in testing and development</span><a id="_idIndexMarker851"/><span class="koboSpan" id="kobo.1092.1"> environments. </span><span class="koboSpan" id="kobo.1092.2">For production environments, more sophisticated tools, called orchestrators, are needed. </span><span class="koboSpan" id="kobo.1092.3">A de facto standard for the production</span><a id="_idIndexMarker852"/><span class="koboSpan" id="kobo.1093.1"> environment is Kubernetes, which will be analyzed in detail in </span><em class="chapterRef"><span class="koboSpan" id="kobo.1094.1">Chapter 20</span></em><span class="koboSpan" id="kobo.1095.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1096.1">Kubernetes</span></em><span class="koboSpan" id="kobo.1097.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-237"><span class="koboSpan" id="kobo.1098.1">Azure and Visual Studio support for microservice orchestration</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1099.1">Visual Studio has extensions for debugging</span><a id="_idIndexMarker853"/><span class="koboSpan" id="kobo.1100.1"> a single microservice while </span><a id="_idIndexMarker854"/><span class="koboSpan" id="kobo.1101.1">it communicates with other</span><a id="_idIndexMarker855"/><span class="koboSpan" id="kobo.1102.1"> microservices deployed</span><a id="_idIndexMarker856"/><span class="koboSpan" id="kobo.1103.1"> in Kubernetes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1104.1">Also available are tools for testing and debugging several communicating microservices in the development machine and for deploying them automatically on Azure Kubernetes Service with just minimal configuration information.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1105.1">All Visual Studio tools for Kubernetes and the whole process of developing for Kubernetes with Visual Studio will be described in the practical example in </span><em class="chapterRef"><span class="koboSpan" id="kobo.1106.1">Chapter 22</span></em><span class="koboSpan" id="kobo.1107.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1108.1">Developing .NET Microservices for Kubernetes</span></em><span class="koboSpan" id="kobo.1109.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1110.1">Moving on from Visual Studio’s features for Kubernetes, let’s dive into the key tools offered, in general, by all microservices orchestrators like Kubernetes.</span></p>
<h1 class="heading-1" id="_idParaDest-238"><span class="koboSpan" id="kobo.1111.1">Which tools are needed to manage microservices?</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1112.1">Effectively handling microservices</span><a id="_idIndexMarker857"/><span class="koboSpan" id="kobo.1113.1"> in your CI/CD cycles requires both a private Docker image registry and a state-of-the-art microservice orchestrator that’s capable of doing the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1114.1">Allocating and load-balancing microservices on available hardware nodes</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1115.1">Monitoring the health state of services and replacing faulty services if hardware/software failures occur</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1116.1">Logging and presenting analytics</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1117.1">Allowing the designer to dynamically change requirements such as hardware nodes allocated to a cluster, the number of service instances, and so on</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1118.1">The following subsection describes the Azure facilities we can use to store Docker images. </span><span class="koboSpan" id="kobo.1118.2">The microservices orchestrators available in Azure are described in a dedicated chapter – namely, </span><em class="chapterRef"><span class="koboSpan" id="kobo.1119.1">Chapter 20</span></em><span class="koboSpan" id="kobo.1120.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1121.1">Kubernetes</span></em><span class="koboSpan" id="kobo.1122.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1123.1">Having learned about the essential functionalities offered by microservices orchestration, let’s now turn</span><a id="_idIndexMarker858"/><span class="koboSpan" id="kobo.1124.1"> our attention to how Azure facilitates these processes, starting with the setup of a private Docker registry.</span></p>
<h2 class="heading-2" id="_idParaDest-239"><span class="koboSpan" id="kobo.1125.1">Defining your private Docker registry in Azure</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1126.1">Defining your private Docker registry </span><a id="_idIndexMarker859"/><span class="koboSpan" id="kobo.1127.1">in Azure is easy. </span><span class="koboSpan" id="kobo.1127.2">Just type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1128.1">Container registries</span></code><span class="koboSpan" id="kobo.1129.1"> into the Azure</span><a id="_idIndexMarker860"/><span class="koboSpan" id="kobo.1130.1"> search bar and select </span><strong class="screenText"><span class="koboSpan" id="kobo.1131.1">Container registries</span></strong><span class="koboSpan" id="kobo.1132.1">. </span><span class="koboSpan" id="kobo.1132.2">On the page that appears, click on the </span><strong class="screenText"><span class="koboSpan" id="kobo.1133.1">Create</span></strong><span class="koboSpan" id="kobo.1134.1"> button.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1135.1">The following form will appear:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1136.1"><img alt="Graphical user interface, text, application  Description automatically generated" src="../Images/B19820_11_09.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1137.1">Figure 11.9: Creating an Azure private Docker registry</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1138.1">The name you select is used</span><a id="_idIndexMarker861"/><span class="koboSpan" id="kobo.1139.1"> to compose the overall</span><a id="_idIndexMarker862"/><span class="koboSpan" id="kobo.1140.1"> registry URI: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1141.1">&lt;name&gt;.azurecr.io</span></code><span class="koboSpan" id="kobo.1142.1">. </span><span class="koboSpan" id="kobo.1142.2">As usual, you can specify the subscription, resource group, and location. </span><span class="koboSpan" id="kobo.1142.3">The </span><strong class="screenText"><span class="koboSpan" id="kobo.1143.1">SKU</span></strong><span class="koboSpan" id="kobo.1144.1"> dropdown lets you choose from various levels of offerings that differ in terms of performance, available memory, and a few other auxiliary features.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1145.1">Whenever you mention image names in Docker commands or in a Visual Studio publish form, you must prefix them with the registry URI: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1146.1">&lt;name&gt;.azurecr.io/&lt;my imagename&gt;</span></code><span class="koboSpan" id="kobo.1147.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1148.1">If images are created with Visual Studio, then they can be published by following the instructions that appear once you publish the project. </span><span class="koboSpan" id="kobo.1148.2">Otherwise, you must use Docker commands to push them into your registry.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1149.1">The easiest way to use Docker</span><a id="_idIndexMarker863"/><span class="koboSpan" id="kobo.1150.1"> commands that interact</span><a id="_idIndexMarker864"/><span class="koboSpan" id="kobo.1151.1"> with the Azure registry is by installing the Azure CLI on your computer. </span><span class="koboSpan" id="kobo.1151.2">Download the installer from </span><a href="https://aka.ms/installazurecliwindows"><span class="url"><span class="koboSpan" id="kobo.1152.1">https://aka.ms/installazurecliwindows</span></span></a><span class="koboSpan" id="kobo.1153.1"> and execute it. </span><span class="koboSpan" id="kobo.1153.2">Once the Azure CLI has been installed, you can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1154.1">az</span></code><span class="koboSpan" id="kobo.1155.1"> command from Windows Command Prompt or PowerShell. </span><span class="koboSpan" id="kobo.1155.2">In order to connect with your Azure account, you must execute the following </span><code class="inlineCode"><span class="koboSpan" id="kobo.1156.1">login</span></code><span class="koboSpan" id="kobo.1157.1"> command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1158.1">az login
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1159.1">This command should start your default browser and should drive you through the manual login procedure.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1160.1">Once logged in to your Azure account, you can log in to your private registry by typing the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1161.1">az acr login --name {registryname}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1162.1">Now, let’s say you have a Docker image in another registry. </span><span class="koboSpan" id="kobo.1162.2">As a first step, let’s pull the image on your local computer:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1163.1">docker pull other.registry.io/samples/myimage
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1164.1">If there are several versions of the preceding image, the latest will be pulled since no version was specified. </span><span class="koboSpan" id="kobo.1164.2">The version of the image can be specified as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1165.1">docker pull other.registry.io/samples/myimage:version1.0
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1166.1">Using the following command, you should see </span><code class="inlineCode"><span class="koboSpan" id="kobo.1167.1">myimage</span></code><span class="koboSpan" id="kobo.1168.1"> within the list of local images:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1169.1">docker images
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1170.1">Then, tag the image with the path you want to assign in the Azure registry:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1171.1">docker tag myimage myregistry.azurecr.io/testpath/myimage
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1172.1">Both the name and destination tag may have versions (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1173.1">:&lt;version name&gt;</span></code><span class="koboSpan" id="kobo.1174.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1175.1">Finally, push it to your registry with the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1176.1">docker push myregistry.azurecr.io/testpath/myimage
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1177.1">In this case, you can specify a version; otherwise, the latest version is pushed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1178.1">By doing this, you can remove</span><a id="_idIndexMarker865"/><span class="koboSpan" id="kobo.1179.1"> the image from your local computer </span><a id="_idIndexMarker866"/><span class="koboSpan" id="kobo.1180.1">using the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1181.1">docker rmi myregistry.azurecr.io/testpath/myimage
</span></code></pre>
<h1 class="heading-1" id="_idParaDest-240"><span class="koboSpan" id="kobo.1182.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1183.1">In this chapter, we described what microservices are and how they have evolved from the concept of a module. </span><span class="koboSpan" id="kobo.1183.2">Then, we talked about the advantages of microservices and when it is worth using them, as well as general criteria for their design. </span><span class="koboSpan" id="kobo.1183.3">We also explained what Docker containers are and analyzed the strong connection between containers and microservice architectures.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1184.1">Then, we took on a more practical implementation by describing all the tools that are available in .NET so that we can implement microservice-based architectures. </span><span class="koboSpan" id="kobo.1184.2">We also described infrastructures that are needed by microservices and how Azure offers both container registries and container orchestrators.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1185.1">This chapter was just a general introduction to microservices. </span><span class="koboSpan" id="kobo.1185.2">Further chapters will discuss most of the subjects introduced here in more detail while showing practical implementation techniques and code examples.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1186.1">This ends the first part of the book dedicated to fundamentals. </span><span class="koboSpan" id="kobo.1186.2">The next chapter, </span><em class="italic"><span class="koboSpan" id="kobo.1187.1">Choosing Your Data Storage in the Cloud</span></em><span class="koboSpan" id="kobo.1188.1">, starts the second part of the book, which is dedicated to specific technologies.</span></p>
<h1 class="heading-1" id="_idParaDest-241"><span class="koboSpan" id="kobo.1189.1">Questions</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1190.1">What is the two-fold nature of the module concept?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1191.1">Is scaling optimization the only advantage of microservices? </span><span class="koboSpan" id="kobo.1191.2">If not, list some further advantages.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1192.1">What is Polly?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1193.1">What Docker support is offered by Visual Studio?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1194.1">What is an orchestrator, and what orchestrators are available on Azure?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1195.1">Why is publisher/subscriber-based communication so important in microservices?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1196.1">What is RabbitMQ?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1197.1">Why are idempotent messages so important?</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-242"><span class="koboSpan" id="kobo.1198.1">Further reading</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1199.1">The following are links to the official documentation for Azure Service Bus, RabbitMQ, and other event bus technologies:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1200.1">Azure Service Bus</span></strong><span class="koboSpan" id="kobo.1201.1">: </span><a href="https://docs.microsoft.com/en-us/azure/service-bus-messaging/"><span class="url"><span class="koboSpan" id="kobo.1202.1">https://docs.microsoft.com/en-us/azure/service-bus-messaging/</span></span></a></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1203.1">NServiceBus</span></strong><span class="koboSpan" id="kobo.1204.1">: </span><a href="https://particular.net/nservicebus"><span class="url"><span class="koboSpan" id="kobo.1205.1">https://particular.net/nservicebus</span></span></a></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1206.1">MassTransit</span></strong><span class="koboSpan" id="kobo.1207.1">: </span><a href="https://masstransit-project.com/"><span class="url"><span class="koboSpan" id="kobo.1208.1">https://masstransit-project.com/</span></span></a></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1209.1">Brighter</span></strong><span class="koboSpan" id="kobo.1210.1">: </span><a href="https://www.goparamore.io/"><span class="url"><span class="koboSpan" id="kobo.1211.1">https://www.goparamore.io/</span></span></a></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1212.1">RabbitMQ</span></strong><span class="koboSpan" id="kobo.1213.1">: </span><a href="https://www.rabbitmq.com/getstarted.html"><span class="url"><span class="koboSpan" id="kobo.1214.1">https://www.rabbitmq.com/getstarted.html</span></span></a></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1215.1">EasyNetQ</span></strong><span class="koboSpan" id="kobo.1216.1">: </span><a href="https://easynetq.com/"><span class="url"><span class="koboSpan" id="kobo.1217.1">https://easynetq.com/</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1218.1">The following are also links for Polly and Docker:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1219.1">The documentation for Polly, a tool for reliable communication/tasks, can be found here: </span><a href="https://github.com/App-vNext/Polly"><span class="url"><span class="koboSpan" id="kobo.1220.1">https://github.com/App-vNext/Polly</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1221.1">More information on Docker can be found on Docker’s official website: </span><a href="https://docs.docker.com/"><span class="url"><span class="koboSpan" id="kobo.1222.1">https://docs.docker.com/</span></span></a></li>
</ul>
</li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.1223.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1224.1">To join the Discord community for this book – where you can share feedback, ask questions to the authors, and learn about new releases – follow the QR code below:</span></p>
<p class="normal"><a href="https://packt.link/SoftwareArchitectureCSharp12Dotnet8"><span class="url"><span class="koboSpan" id="kobo.1225.1">https://packt.link/SoftwareArchitectureCSharp12Dotnet8</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.1226.1"><img alt="" role="presentation" src="../Images/QR_Code175081751210902046.png"/></span></p>
</div>
</body></html>