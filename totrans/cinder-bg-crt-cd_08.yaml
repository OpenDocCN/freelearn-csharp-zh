- en: Chapter 8. Adding Depth – Cinder 3D Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 深入学习 - Cinder 3D 基础
- en: This chapter will introduce you to the basic 3D aspects and practical methods
    as well as the 3D primitives that can be drawn with Cinder. We will start by making
    a transition from 2D coordinate system to 3D, and continue with basic problems
    and solutions that we are going to face in the 3D graphics programming world from
    now on. We will also add basic animation during the walkthrough to demonstrate
    the basic approach of adding movement to the otherwise static objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍Cinder中可以绘制的基本3D方面和实用方法，以及可以用Cinder绘制的3D原语。我们将从二维坐标系过渡到三维，并继续探讨我们在三维图形编程世界中将要面临的基本问题和解决方案。在演示过程中，我们还将添加基本动画，以展示向原本静态对象添加运动的基本方法。
- en: Introducing the 3D space
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍3D空间
- en: To use Cinder with 3D we need to understand a bit about 3D computer graphics.
    First thing that we need to know is that 3D graphics are created in a three-dimensional
    space that exists somewhere in the computer and is transformed into a two-dimensional
    image that can be displayed on our computer screens afterwards.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Cinder进行3D绘图，我们需要了解一些关于3D计算机图形学的基础知识。首先，我们需要知道的是，3D图形是在计算机中某个地方存在的三维空间中创建的，之后被转换成可以在我们的计算机屏幕上显示的二维图像。
- en: Usually there is a projection (frustrum) that has different properties which
    are similar to the properties of cameras we have in the real world. **Frustrum**
    takes care of rendering all the 3D objects that are visible in frustrum. It is
    responsible for creating the 2D image that we see on the screen.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有一个投影（视锥体）具有不同的属性，这些属性与我们在现实世界中拥有的相机的属性相似。**视锥体**负责渲染视锥体内可见的所有3D对象。它负责创建我们在屏幕上看到的2D图像。
- en: '![Introducing the 3D space](img/9564_08_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![介绍3D空间](img/9564_08_01.jpg)'
- en: As you can see in the preceding figure, all objects inside the frustrum are
    being rendered on the screen. Objects outside the view frustrum are being ignored.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，所有在视锥体内的对象都在屏幕上被渲染。视锥体外的对象被忽略。
- en: 'OpenGL (that is being used for drawing in Cinder) relies on the so called rendering
    pipeline to map the 3D coordinates of the objects to the 2D screen coordinates.
    Three kind of matrices are used for this process: the model, view, and projection
    matrices. The model matrix maps the 3D object''s local coordinates to the world
    (or global) space, the view matrix maps it to the camera space, and finally the
    projection matrix takes care of the mapping to the 2D screen space. Older versions
    of OpenGL combine the model and view matrices into one—the **modelview** matrix.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL（在Cinder中用于绘图）依赖于所谓的渲染管线来将对象的3D坐标映射到2D屏幕坐标。此过程使用了三种类型的矩阵：模型矩阵、视图矩阵和投影矩阵。模型矩阵将3D对象的局部坐标映射到世界（或全局）空间，视图矩阵将其映射到相机空间，最后投影矩阵负责将其映射到2D屏幕空间。较旧的OpenGL版本将模型和视图矩阵合并为一个——**模型视图**矩阵。
- en: In the previous chapters we used 2D coordinates (x and y coordinate axes) to
    place different kinds of objects and graphics on the screen. Now we will take
    advantage of the third dimension—the z axis.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了二维坐标（x和y坐标轴）来在屏幕上放置不同种类的对象和图形。现在我们将利用第三个维度——z轴。
- en: 'The coordinate system in Cinder starts from the top-left corner of the screen.
    Any object placed there has the coordinates 0, 0, 0 (these are values of x, y,
    and z respectively). The x axis extends to the right, y to the bottom, but z extends
    towards the viewer (us), as shown in the following figure:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder中的坐标系从屏幕的左上角开始。放置在那里的任何对象的坐标都是0, 0, 0（这些分别是x、y和z的值）。x轴向右延伸，y轴向下延伸，但z轴向观察者（我们）延伸，如图所示：
- en: '![Introducing the 3D space](img/9564_08_02.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![介绍3D空间](img/9564_08_02.jpg)'
- en: As you can see in the preceding figure, the coordinate system in Cinder is a
    bit different from the one in OpenGL. The built-in OpenGL drawing functions in
    Cinder takes care of the mapping.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，Cinder中的坐标系与OpenGL中的坐标系略有不同。Cinder内置的OpenGL绘图函数负责进行映射。
- en: Drawing in 3D
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D绘图
- en: Let's try to draw something by taking into account that there is a third dimension.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试考虑存在第三个维度来绘制一些东西。
- en: Create another project by using **TinderBox** and name it `Basic3D`. Open the
    project file (`xcode/Basic3D.xcodeproj` on Mac or `vc10\Basic3D.sln` on Windows).
    Open `Basic3DApp.cpp` in the editor and navigate to the `draw()` method implementation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Just after the `gl::clear()` method add the following line to draw a cube:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first parameter defines the position of the center of the cube, the second
    defines its size. Note that we use the `Vec3f()` variables to define position
    and size within three (x, y and z) dimensions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run the project. This will draw a solid cube at the top-left corner
    of the screen. We are able to see just one quarter of it because the center of
    the cube is the reference point. Let''s move it to the center of the screen by
    transforming the previous line as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we are positioning the cube in the middle of the screen no matter what the
    window's width or height is, because we pass half of the window's width (`getWindowWidth()/2`)
    and half of the window's height (`getWindowHeight()/2`) as values for the x and
    y coordinates of the cube's location. Compile and run the project to see the result.
    Play around with the size parameters to understand the logic behind it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'We may want to rotate the cube a bit. There is a built-in `rotate()` function
    that we can use. One of the things that we have to remember, though, is that we
    have to use it before drawing the object. So add the following line before `gl::drawCube()`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Compile and run the project. You should see a strange rotation animation around
    the y axis. The problem here is that the `rotate()` function rotates the whole
    3D world of our application including the object in it and it does so by taking
    into account the scene coordinates. As the center of the 3D world (the place where
    all axes cross and are zero) is in the top-left corner, all rotation is happening
    around this point.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing in 3D](img/9564_08_03.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'To change that we have to use the `translate()` function. It is used to move
    the scene (or canvas) before we `rotate()` or `drawCube()`. To make our cube rotate
    around the center of the screen, we have to perform the following steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Use the `translate()` function to translate the 3D world to the center of the
    screen.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `rotate()`function to rotate the 3D world.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the object (`drawCube()`).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `translate()`function to translate the scene back.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have to use the `translate()` function to translate the scene back to the
    location, because each time we call `translate()` values are added instead of
    being replaced. In code it should look similar to the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So now we get a smooth rotation of the cube around the y axis. The rotation
    angle around y axis is increased in each frame by 1 degree as we pass the `Vec3f::yAxis()*1`
    value to the `rotate()` function. Experiment with the rotation values to understand
    this a bit more.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: What if we want the cube to be in a constant rotated position? We have to remember
    that the `rotate()` function works similar to the translate function. It adds
    values to the rotation of the scene instead of replacing them. Instead of rotating
    the object back, we will use the `pushMatrices()` and `popMatrices()` functions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Rotation and translation are transformations. Every time you call `translate()`
    or `rotate()`, you are modifying the modelview matrix. If something is done, it
    is sometimes not so easy to undo it. Every time you transform something, changes
    are being made based on all previous transformations in the current state.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: So what is this state? Each state contains a copy of the current transformation
    matrices. By calling `pushModelView()` we enter a fresh state by making a copy
    of the current modelview matrix and storing it into the stack. We will make some
    crazy transformations now without worrying about how we will undo them. To go
    back, we call `popModelView()` that pops (or deletes) the current modelview matrix
    from the stack, and returns us to the state with the previous modelview matrix.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s try this out by adding the following code after the `gl::clear()`
    call:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Compile and run our program now, you should see something similar to the following
    screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing in 3D](img/9564_08_04.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: As we can see, before doing anything, we create a copy of the current state
    with `pushModelView()`. Then we do the same as before, translate our scene to
    the middle of the screen, rotate it (this time `35` degrees around x axis and
    `20` degrees around y axis), and finally draw the cube! To reset the stage to
    the state it was before, we have to use just one line of code, `popModelView()`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Understanding nested states
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to create nested states by using the previously discussed functions.
    By using two `pushModelView()` calls in a row, we are storing two different states.
    By calling one `popModelView()` afterwards, we pop just the last pushed modelview
    matrix.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change our `draw()` method implementation to the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note the use of `gl::pushModelView()` and `gl::popModelView()`. Compile and
    run the project, you should see a ring of smaller cubes surrounding the one we
    saw earlier.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try to move the `gl::rotate()` call before the `for` loop and after the
    `gl::translate()` call. Compile and run the project. You should see a bit of a
    different image than the one you saw earlier:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding nested states](img/9564_08_05.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: This is a simple demonstration of nested states. Try to experiment in the way
    we just did, by adding extra transformations and changing their order. Furthermore,
    OpenGL is not limited to just two levels of nested states. You could try to add
    orbiting objects around each of the small squares by adding more `pushModelView()`
    and `popModelView()` functions inside another `for` loop, for example.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Handling depth sorting
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at the 3D primitive drawing functions that are built into
    Cinder. There are not a lot of them but as Cinder is meant to be a bit more low
    level than other similar tools, you should continue to learn some OpenGL afterwards
    to get the most out of Cinder and drawing in 3D space.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with changing the single colored cube into something more colorful
    and adding some constant rotation to it as it was before. To do that, we will
    have to replace the `drawCube()` function call with `drawColorCube()`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you run and compile the application, you will see that the cube is drawn
    somehow strange. This is the effect of inappropriate depth sorting. A 3D model
    consists of vertices that are placed at different depths in the current projection.
    These vertices form faces that also have different depth information that is taken
    into account when transforming them into pixels at different depths. If these
    vertices are not sorted and drawn in appropriate order according to their depth
    information, we get an image where the faces and objects behind in the back of
    the scene are drawn in front and the opposite. To avoid this, we have to enable
    the depth read feature of the OpenGL. Add these lines of code in the `setup()`
    method implementation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After you compile and run the project, the cube should look just fine:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling depth sorting](img/9564_08_06.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: 'With that done, let''s add some rotation animation. To do this we will need
    to declare some variables that will take care of storing the rotation variables.
    Then we will need to assign initial values to them in the `setup()` method, change
    them in the `update()` method, and finally draw in the `draw()` method implementation.
    Let''s start with declaring the variables. Add these lines just after the `setup()`,
    `update()`, and `draw()` method declarations:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Instead of using one `float` variable for the current and increment rotation
    angle around each axis we are using the `Vec3f` datatype to be able to store the
    rotation values in one variable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to assign the initial values to these variables now. Go to the `setup()`
    method implementation and add the following lines:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With that done, go to the `update()` method implementation and add the following
    line:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will increment the rotation around all the three axis on each frame.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally we have to make use of the `currentRotation` variable while drawing.
    Change the parameter of the `gl::rotate()` function before the `gl::drawColorCube()`
    call to `currentRotation` as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now the rotation values will be increased and updated on each frame. Compile
    and run the project to see for yourself! You should get a nice rotation animation.
    Try to do the same with the location and size of the cube for better understanding
    of how this works.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Exploring other Cinder 3D primitives
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s try out the different 3D primitives that Cinder supplies it''s own
    functions for. We just tried to draw a different kind of cube, so let''s continue
    with something equally classic, a sphere. Replace the `gl::drawColorCube()` function
    call with the following line:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first parameter of this function defines the center of the sphere and the
    second defines the radius. There is a third (optional) parameter `int` that controls
    the number of segments the sphere is made of. The default value is 12, but you
    might want to change it to a higher value to increase the smoothness of the sphere.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run the project. You should see an image similar to the following
    screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring other Cinder 3D primitives](img/9564_08_07.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: 'The problem here is that it does not look quite 3D. As you might have already
    guessed, the problem is that there is no light. To add light to the scene, add
    the following lines in the `setup()` method implementation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These are OpenGL functions that are responsible for turning the light on. The
    first one enables light as such, the second is turning on the first light or `GL_LIGHT0`.
    There are ways of positioning and changing it's parameters, but we won't dig into
    this as it is outside the scope of this book.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run the project to see the sphere with lights turned on. You should
    get a result that is similar to the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring other Cinder 3D primitives](img/9564_08_08.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try to draw something else instead of a sphere. How about a cylinder?
    Replace the `drawSphere()` function call with the following line:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will draw an open-ended cylinder on the screen. The first parameter defines
    the width of the cylinder base, the second parameter defines the width of the
    cylinder top. The third parameter defines the cylinder height.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'After we compile and run the application, you will notice that the cylinder
    is not rotating around it''s center like the cube or sphere we drew before. That
    is because of the way it is drawn – from the bottom up instead of both – up and
    down. To change that, we can draw another cylinder, with a negative height or
    change the `translate()` values. For the sake of simplicity, let''s draw another
    cylinder. Replace the cylinder drawing code to this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can see the same cylinder but now it rotates around its center. Another
    thing that we might want to add are the closed ends of the cylinder. We have to
    use 2D shapes again to accomplish this task. Add the following lines of code directly
    after the `drawCylinder()` function calls:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'gl::drawSolidCircle(Vec2f(0,0), 50, 12);     Not too easy, right? There is no `drawSolidCircle()` function that would draw
    a circle based on 3D coordinates yet, but this is a kind of shorthand anyway so
    we don''t have to write pure OpenGL. What these lines of code do is that they
    move the scene or canvas in appropriate position and rotation relative to the
    already drawn cylinder to draw the top and the bottom of it.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the code a bit, so we see another thing that is possible with
    the `drawCylinder()` function that is drawing a cone or even a pyramid:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微修改一下代码，看看`drawCylinder()`函数还能绘制圆锥甚至金字塔：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Delete or comment out the `drawSolidCircle()` part and change the top values
    of the `drawCylinder()` functions to `0` and add a fourth value (and set it to
    `4` or more if you want to draw a cone) that represents the slice count of the
    cylinder.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 删除或注释掉`drawSolidCircle()`部分，并将`drawCylinder()`函数的顶部值改为`0`，并添加一个第四个值（如果你想绘制圆锥，可以将其设置为`4`或更多），这个值代表圆柱的切片数。
- en: 'After compiling and running the application, a pyramid is not quite what we
    see. Let''s call it a diamond to describe the shape more correctly. In the following
    screenshot you can see an image strip with the `gl::drawCylinder()` adjustments
    we just did:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行应用程序后，我们看到的是一个金字塔，而不是我们预期的。让我们称它为钻石，以更准确地描述形状。在下面的屏幕截图中，你可以看到我们刚刚对`gl::drawCylinder()`所做的调整的图像条：
- en: '![Exploring other Cinder 3D primitives](img/9564_08_09.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![探索其他Cinder 3D原语](img/9564_08_09.jpg)'
- en: 'Another basic shape worth introducing is the torus. Cinder has a built-in function
    for drawing this and this is how the function looks:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得介绍的基本形状是环面。Cinder内置了一个用于绘制环面的函数，函数看起来是这样的：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Add the preceding line of code after the cylinder drawing function calls. The
    first parameter defines the outer radius (the circle responsible for the base
    shape of the torus), the second defines the inner radius or the radius if the
    circle that is used for creating the volume of the torus.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在圆柱绘制函数调用之后添加前面的代码行。第一个参数定义了外半径（负责环面底部形状的圆），第二个参数定义了内半径或用于创建环面体积的圆的半径。
- en: 'To make things look even more straightedged, let''s add the third and fourth
    parameter that are responsible for the longitude and latitude segment count of
    the torus:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让东西看起来更加整齐，让我们添加第三个和第四个参数，它们负责环面的经度和纬度切片数：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we compile and run the application now, we should see an image similar to
    one of these:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在编译并运行应用程序，我们应该看到类似于以下图像的图像：
- en: '![Exploring other Cinder 3D primitives](img/9564_08_10.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![探索其他Cinder 3D原语](img/9564_08_10.jpg)'
- en: Summary
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: To sum up, in this chapter we introduced ourselves with the very basic 3D stuff
    that can be done with Cinder. We understood a bit about the concept of 3D space
    as well as how to draw and animate objects in this space. We learned to switch
    on the lightning and construct more complex shapes out of primitives.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中，我们通过Cinder可以做的非常基础的3D内容进行了自我介绍。我们了解了一些关于3D空间的概念，以及如何在空间中绘制和动画化对象。我们学习了如何打开灯光，并使用原语构建更复杂的形状。
- en: There is more, but to get the real graphics power out of Cinder, you have to
    learn some more of OpenGL and the **OpenGL Shading Language** (**GLSL**).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多，但要真正发挥Cinder的图形能力，你必须学习一些OpenGL和**OpenGL着色语言**（**GLSL**）的更多知识。
- en: In the next chapter, we will talk less about graphics but more about what is
    possible with Cinder in terms of audio.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更多地讨论Cinder在音频方面的可能性，而不是图形。
