- en: Singleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Singleton is the most infamous pattern in the industry, but ironically,
    it's very popular with Unity developers. In consequence, it has become somewhat
    the duct tape of programmers, overused as a quick fix instead of a cornerstone
    of a robust architecture. There are many ways to implement a Singleton, from the
    simple but unsafe to the complicated but robust; we will go with the latter, because
    if we need to implement an unpopular pattern, let's do it in a way that won't
    backfire on us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of the Singleton's pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the perfect Singleton in Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmers love to argue, sometimes to the point of paralysis, so it's important
    never to become religious about design patterns. Always remember that there's
    no perfect solution; every design decision you make will have trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a hands-on chapter; you will need to have a basic understanding of Unity
    and C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following specific Unity engine and C# language concept:'
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If unfamiliar with this concept, please review them before starting this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2YwBVEv](http://bit.ly/2YwBVEv)'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As its name implies, the Singleton pattern's main goal is to guarantee a singularity.
    This approach means if a class implements this pattern correctly, once initialized,
    it will have only one instance of itself in memory during runtime. This mechanism
    can be useful when you have a class that manages a system that needs to be globally
    accessible from a singular entry point.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see from the following diagram, the Singleton''s design is quite
    simple; unlike the Prototype pattern, a class implemented as a Singleton doesn''t
    make a copy of itself but only returns its current instance to a client that''s
    requesting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1c31bad-1e47-410b-9f00-f2c1c141a7d1.png)'
  prefs: []
  type: TYPE_IMG
- en: And if correctly implemented, a Singleton instance will even destroy any other
    instances of itself, just in case someone is trying to duplicate it. In other
    words, there can only be one. But we will see further in this chapter, implementing
    a solid Singleton in Unity is not as easy as it looks.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Singleton is a very controversial pattern; it's disliked by many because
    Unity developers frequently misuse it. If this contempt for this pattern is justified,
    I would say yes, but only to a certain degree. Instead of listing all the potential
    benefits and drawbacks of this pattern, I will present only one advantage and
    disadvantage; both are what I find to be the best arguments for or against the
    use of this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the benefit:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A singular point of entry**: The Singleton offers a singular but global access
    point to an instance of itself. This mechanism makes it easier to access dependencies
    that are exposed by a Singleton instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the drawback:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Obfuscation of dependencies**: Singletons are often used as *duct tape* to
    simplify access to complex interlocked dependencies. It''s an easy solution that
    prevents the weeding out of wrong architecture choices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, taking into account these two arguments, there's a simple question we must
    ask when deciding to use a Singleton; is it because it's needed and fits with
    our overall architecture, or are we using it because it's a quick solution to
    a complex problem? From our answer, we can determine whether we are smart or just
    lazy with our design choices.
  prefs: []
  type: TYPE_NORMAL
- en: When you are making design choices, it's important to always keep in mind whether
    your architecture is maintainable, scalable, and testable. If you can't individually
    test your modules, it's a good indication that your design has made your code
    base coupled and dependent on global dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Use case example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We must take into consideration that most games are made up of a collection
    of levels but each level includes a sequence of events during its lifespan, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading of previous save
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggering of introductory sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawning of environment and characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing runtime game states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggering the end scene sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save current player stats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trigger next level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be able to manage this, we will need a Game Manager that will be active throughout
    the entire life span of a scene. As an analogy, if we look at the classic pen-and-paper
    version of Dungeons and Dragons, there's usually a Game Master that moderates
    and overlooks the flow of the game so the players can have a consistent but structured
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: So, for our use case, we will need something similar but, of course, not as
    sophisticated as a human Game Master. The Singleton is a perfect pattern to implement
    a GM because it offers us a way to write a class as a singular but global entity
    that will accessible throughout the runtime of our game.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore two versions of an implementation of the Singleton
    pattern in Unity. The first example is unsafe but straightforward. The second
    is advanced but more robust, as indicated at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Simple approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by reviewing a simple way of implementing the Singleton in Unity.
    We have to keep in mind that we don''t have access to a constructor when we use
    `MonoBehaviours`, so we will need to control the initialization of any member
    variables in the `Awake()` magic function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we have only one member, and it''s static and public, which
    will make it easier for our clients to refer to it. In our `Awake()`, we pass
    our current `this` instance to the public static instance variable. This approach
    means our clients will have one constant and persistent access point to our `GameManager`,
    as seen in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks pretty simple. We need to refer to the static instance member of the
    `GameManager` class, and we can call at any point its public functions. But there''s
    one huge problem: this is not a Singleton for the reason that there''s no mechanism
    in place that avoids having two instances of this object in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We just implemented an interface to an instance of a global manager, but we
    are not protecting it from duplication in memory or preserving its integrity.
    Let''s see whether we can do better with the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, this is getting better. We are at least checking for `null` references
    before assigning the `_instance` static member, and avoiding potential duplicated
    instances of our `GameManager` by destroying them at the moment they *awake*.
  prefs: []
  type: TYPE_NORMAL
- en: This approach seems valid, but there's nothing that will guarantee consistency
    if you decide to have multiple classes implemented as Singletons. You might have
    one programmer writing a Singleton one way and another writing entirely differently.
    In the long run, this nullifies one of the fundamental benefits of design patterns;
    consistency in the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at a potential candidate for an advanced Singleton
    implementation that can become a pillar for our code base and offer us complete
    re-usability.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following class is an example of a complete Singleton implementation, but
    there''s a lot to unpack here, so we are going to try to focus on the following
    essential elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are introducing **Generics**, a compelling C# feature that
    permits us to defer the type of a class at runtime. When we say a class is generic,
    it means that it doesn't have a defined object type. This approach is advantageous
    because we can assign it a specific type when we initialize it. In other words,
    it can become anything we want, and this could solve a core issue we are having
    with Singletons, which is the consistency of implementation between our classes
    that are Singletons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s apply our generic Singleton class to a couple of Managers and see how
    we maintain uniformity in the way we write Singleton classes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, by inheriting the Singleton parent class, we have made our `GameManager`
    into a Singleton with one line of code (`Singleton<GameManager>`). This mechanism
    is possible because our parent class has all the core components of a Singleton.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is another example of a `Manager` class converted into a Singleton
    with one simple line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test our new Singletons with the following `Client` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have found a structured and reusable approach to the implementation
    of the Singleton pattern, we can safely integrate it into our code base while
    keeping in mind not to overuse it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we tackled one of the most controversial design patterns out
    there. But we found a way to implement with a consistent and reusable approach.
    Even if the debate around the Singleton's usefulness persists, we can see how
    it can be beneficial for Unity developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have completed the creational pattern section of the book, and now we have
    three core patterns in our toolkit, each with a specific function:'
  prefs: []
  type: TYPE_NORMAL
- en: The Prototype pattern offers us a way to create objects by copying them from
    a reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Abstract pattern enforces the localization of the creation process of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Singleton offers a way to implement a mechanism that guarantees one singular
    instance of an object in memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will transition out from Creational to Behavioral patterns.
    The first on our list is the Strategy pattern, a classic pattern that focuses
    on the dynamic selection of algorithms at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main issue with the Singleton pattern is that its instance is globally accessible
    and persistent, so if any component that has dependencies related to a Singleton
    object, it cannot be tested as an isolated unit. But in the real world, code bases
    are never perfect, and programmers often use Singletons.
  prefs: []
  type: TYPE_NORMAL
- en: So, you need to find a way to maintain proper unit testing best practices even
    when dealing with an architecture that is heavily dependent on global Singleton
    instances. So, as an exercise, I would recommend reading up on **test-driven development**
    (**TDD**) practices, especially core concepts such as **Stubs** and **Mocks**.
  prefs: []
  type: TYPE_NORMAL
- en: TDD is beyond the scope of this book, so please refer to the *Further reading*
    section for more information on the subject.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Test Driven Development: By Example* by Kent Beck[https://www.pearson.com/us/higher-education/program/Beck-Test-Driven-Development-By-Example/PGM206172.html](https://www.pearson.com/us/higher-education/program/Beck-Test-Driven-Development-By-Example/PGM206172.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Real World: Test-Driven Development* by Mauricio Aniche[https://www.goodreads.com/book/show/24400837-real-world-test-driven-development](https://www.goodreads.com/book/show/24400837-real-world-test-driven-development)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
