- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Implementing Game AI for Building Enemies
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现为建筑敌人而设计的游戏人工智能
- en: What is a game if not a great challenge to the player, who needs to use their
    character’s abilities to tackle different scenarios? Each game imposes different
    kinds of obstacles on the player, and the main one in our game is the enemies.
    Creating challenging and believable enemies can be complex; they need to behave
    like real characters and be smart enough so as not to be easy to kill, but also
    easy enough that they are not impossible to kill. We are going to use basic but
    sufficient AI techniques to make an AI capable of sensing its surroundings and,
    based on that information, make decisions on what to do, using **FSMs** or **Finite
    State Machines**, along with other techniques. Those decisions will be executed
    using **intelligent pathfinding**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏如果不是对玩家的一项巨大挑战，那它又是什么呢？玩家需要使用他们的角色能力来应对不同的场景。每个游戏都会对玩家施加不同类型的障碍，而我们游戏中的主要障碍是敌人。创建具有挑战性和可信度的敌人可能很复杂；它们需要表现得像真实人物，并且足够聪明，以便不会被轻易杀死，但同时也足够简单，以至于它们不是不可能被杀死的。我们将使用基本但足够的AI技术来制作一个能够感知其周围环境的人工智能，并根据这些信息做出决策，决定做什么，使用**FSMs**（有限状态机）或其他技术。这些决策将通过**智能路径查找**来执行。
- en: 'In this chapter, we will examine the following AI concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下人工智能概念：
- en: Gathering information with sensors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用传感器收集信息
- en: Making decisions with FSMs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FSMs做出决策
- en: Executing FSM actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行FSM动作
- en: By the end of the chapter, you will have a fully functional enemy capable of
    detecting the player and attacking them, so let’s start by seeing first how to
    make the sensor systems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将拥有一个能够检测玩家并攻击他们的完全功能性的敌人，所以让我们首先看看如何制作传感器系统。
- en: Gathering information with sensors
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用传感器收集信息
- en: An AI works by first taking in information about its surroundings. Then, that
    data is analyzed in order to choose an action, and finally, the chosen action
    is executed. As you can see, we cannot do anything without information, so let’s
    start with that part.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能通过首先获取其周围环境的信息来工作。然后，这些数据被分析以选择一个动作，最后执行所选动作。正如你所看到的，没有信息我们无法做任何事情，所以让我们从这部分开始。
- en: There are several sources of information our AI can use, such as data about
    itself (life and bullets) or maybe some game state (winning condition or remaining
    enemies), which can easily be found with the code we’ve seen so far. One important
    source of information, however, is also the AI senses. According to the needs
    of our game, we might need different senses such as sight and hearing, but in
    our case, sight will be enough, so let’s learn how to code that.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的人工智能可以使用多个信息来源，例如关于自身的数据（生命和子弹）或可能是某些游戏状态（胜利条件或剩余敌人），这些都可以通过我们迄今为止看到的代码轻松找到。然而，一个重要的信息来源也是人工智能的感知。根据我们游戏的需要，我们可能需要不同的感知，如视觉和听觉，但在这个案例中，视觉就足够了，所以让我们学习如何编写这部分代码。
- en: 'In this section, we will examine the following sensor concepts:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下传感器概念：
- en: Creating three-filter sensors with C#
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C#创建三过滤传感器
- en: Creating three-filter sensors with Visual Scripting
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视觉脚本创建三过滤传感器
- en: Debugging with gizmos
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用小工具进行调试
- en: Let’s start by seeing how to create a sensor with the three-filters approach.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何使用三过滤法创建一个传感器。
- en: Creating three-filter sensors with C#
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用C#创建三过滤传感器
- en: The common way to code senses is through a three-filters approach to discard
    enemies out of sight. The first filter is a distance filter, which will discard
    enemies too far away to be seen, then the second filter would be the angle check,
    which will check enemies inside our viewing cone, and finally, the third filter
    is a raycast check, which will discard enemies that are being occluded by obstacles
    such as walls.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 编写感知代码的常见方式是通过三过滤法来排除视线之外的敌人。第一个过滤器是距离过滤器，它会排除太远而看不见的敌人，然后第二个过滤器将是角度检查，它会检查我们视野锥体内的敌人，最后，第三个过滤器是射线投射检查，它会排除被墙壁等障碍物遮挡的敌人。
- en: 'Before starting, a word of advice: we will be using vector mathematics here,
    and covering those topics in-depth is outside the scope of this book. If you don’t
    understand something, feel free to just search online for the code in the screenshots.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，有一句话要提醒：在这里我们将使用矢量数学，而深入探讨这些主题超出了本书的范围。如果你不理解某些内容，请随时在网上搜索截图中的代码。
- en: 'Let’s code sensors in the following way:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以下面的方式编写传感器代码：
- en: 'Create an empty `GameObject` called `AI` as a child of the **Enemy** Prefab.
    You need to first open the Prefab to modify its children (double-click the Prefab).
    Remember to set the transform of this `GameObject` to **Position** **0,1.75,0**,
    **Rotation** **0,0,0**, and **Scale** **1,1,1** so it will be aligned to the enemy’s
    eyes. This is done this way for the future sight sensors we will do. Consider
    your enemy prefab might have a different height for the eyes. While we can certainly
    just put all AI scripts directly in the **Enemy** Prefab root `GameObject`, we
    did this just for separation and organization:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的`GameObject`，命名为`AI`，作为**敌人**预设的子对象。您需要首先打开预设以修改其子对象（双击预设）。请记住将此`GameObject`的变换设置为**位置**
    **0,1.75,0**，**旋转** **0,0,0**，和**缩放** **1,1,1**，以便它与敌人的眼睛对齐。这样做是为了未来我们将做的视线传感器。请考虑您的敌人预设的眼睛可能具有不同的高度。虽然我们当然可以直接将所有AI脚本直接放入**敌人**预设根`GameObject`中，但我们这样做只是为了分离和组织：
- en: '![](img/B8585_09_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B8585_09_01.png)'
- en: 'Figure 9.1: AI scripts container'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：AI脚本容器
- en: Create a script called `Sight` and add it to the `AI` child object.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Sight`的脚本并将其添加到`AI`子对象中。
- en: Create two fields of the `float` type called `distance` and `angle`, and another
    two of the `LayerMask` type called `obstaclesLayers` and `objectsLayers`. `distance`
    will be used as the vision distance, `angle` will determine the amplitude of the
    view cone, `obstacleLayers` will be used by our obstacle check to determine which
    objects are considered obstacles, and `objectsLayers` will be used to determine
    what types of objects we want the `Sight` component to detect.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个名为`distance`和`angle`的`float`类型字段，以及另外两个名为`obstaclesLayers`和`objectsLayers`的`LayerMask`类型字段。`distance`将用作视野距离，`angle`将确定视锥体的幅度，`obstacleLayers`将用于我们的障碍物检查以确定哪些对象被认为是障碍物，而`objectsLayers`将用于确定我们想要`Sight`组件检测的对象类型。
- en: 'We just want the sight to see enemies; we are not interested in objects such
    as walls or power-ups. `LayerMask` is a property type that allows us to select
    one or more layers to use inside code, so we will be filtering objects by layer.
    In a moment, you will see how we use it:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们只想让视线看到敌人；我们对墙壁或增益物品等对象不感兴趣。`LayerMask`是一种属性类型，允许我们在代码中选择一个或多个层来使用，因此我们将通过层过滤对象。稍后您将看到我们如何使用它：
- en: '![](img/B8585_09_02.png)'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B8585_09_02.png)'
- en: 'Figure 9.2: Fields to parametrize our sight check'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.2：用于参数化我们的视线检查的字段
- en: In `Update`, call `Physics.OverlapSphere` as in the *Figure 9.3*.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update`中，如*图9.3*所示调用`Physics.OverlapSphere`。
- en: This function creates an imaginary sphere in the place specified by the first
    parameter (in our case, our position) and with a radius specified in the second
    parameter (the distance property) to detect objects with the layers specified
    in the third parameter (`ObjectsLayers`). It will return an array with all the
    colliders found inside the sphere; these functions use physics to carry out the
    check, so the objects must have at least one collider.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在由第一个参数指定的地方（在我们的情况下，是我们的位置）创建一个想象中的球体，半径由第二个参数（距离属性）指定，以检测具有第三个参数指定的层（`ObjectsLayers`）的对象。它将返回一个包含在球体内所有找到的碰撞器的数组；这些函数使用物理来执行检查，因此对象必须至少有一个碰撞器。
- en: This is the method we will be using to find all enemies inside our view distance,
    and we will be further filtering them in the next steps. Note that we are passing
    our position to the first parameter, which is not actually the position of the
    enemy but the position of the `AI` child object, given our script is located there.
    This highlights the importance of the position of the AI object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将用于找到我们视野距离内的所有敌人的方法，我们将在下一步进一步过滤它们。请注意，我们将位置传递给第一个参数，这实际上不是敌人的位置，而是`AI`子对象的位置，因为我们的脚本位于那里。这突出了AI对象位置的重要性。
- en: Another way of accomplishing the first check is to just check the distance from
    the objects we want to see to the player, or if looking for other kinds of objects,
    to a `Manager` component containing a list of them. However, the method we chose
    is more versatile and can be used for any kind of object.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 完成第一次检查的另一种方法是检查我们想要看到的对象与玩家之间的距离，或者如果我们正在寻找其他类型的对象，则检查包含这些对象列表的`Manager`组件。然而，我们选择的方法更加灵活，可以用于任何类型的对象。
- en: Also, you might want to check the `Physics.OverlapSphereNonAlloc` version of
    this function, which does the same but is more performant by not allocating an
    array to return the results.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可能还想检查`Physics.OverlapSphereNonAlloc`此函数的版本，它执行相同的操作，但通过不分配返回结果的数组而更高效。
- en: 'Iterate over the array of objects returned by the function using a `for` loop:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`for`循环遍历函数返回的对象数组：
- en: '![](img/B8585_09_03.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B8585_09_03.png)'
- en: 'Figure 9.3: Getting all GameObjects at a certain distance'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：获取一定距离内的所有GameObject
- en: 'To detect whether the object falls inside the vision cone, we need to calculate
    the angle between our viewing direction and the direction from ourselves towards
    the object itself. If the angle between those two directions is less than our
    cone angle, we consider that the object falls inside our vision. We will do that
    in the following steps:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检测物体是否落在视野锥内，我们需要计算我们的观察方向与从我们自身指向物体本身的方位之间的角度。如果这两个方向之间的角度小于我们的锥形角度，我们认为物体在我们的视野内。我们将在以下步骤中这样做：
- en: 'Start calculating the direction toward the object, which can be done by normalizing
    the difference between the object’s position and ours, like in *Figure 9.4*. You
    might notice we used `bounds.center` instead of `transform.position`; this way,
    we check the direction to the center of the object instead of its pivot. Remember
    that the player’s pivot is in the ground and the ray check might collide against
    it before the player:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 开始计算指向物体的方向，这可以通过将物体位置与我们的位置之间的差异进行归一化来实现，就像在*图9.4*中所示。你可能注意到我们使用了`bounds.center`而不是`transform.position`；这样，我们检查的是指向物体中心的方位，而不是它的旋转点。记住，玩家的旋转点在地面，射线检查可能会在玩家之前与它碰撞：
- en: '![](img/B8585_09_04.png)'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B8585_09_04.png)'
- en: 'Figure 9.4: Calculating direction from our position toward the collider'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.4：从我们的位置计算指向碰撞体的方向
- en: 'We can use the `Vector3.Angle` function to calculate the angle between two
    directions. In our case, we can calculate the angle between the direction toward
    the enemy and our forward vector to see the angle:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`Vector3.Angle`函数来计算两个方向之间的角度。在我们的情况下，我们可以计算指向敌人的方向和我们的前进向量之间的角度来查看角度：
- en: '![](img/B8585_09_05.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B8585_09_05.png)'
- en: 'Figure 9.5: Calculating the angle between two directions'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：计算两个方向之间的角度
- en: If you want, you can instead use `Vector3.Dot`, which will execute a dot product,
    a mathematics function to calculate the length of a vector projected to another
    (search online for more info). `Vector3.Angle` actually uses that one, but converts
    the result of the dot product into an angle, which needs to use trigonometry,
    and that can be time expensive to calculate. But our `Vector3.Angle` approach
    is simpler and faster to code, and given that we don’t require many sensors because
    we won’t have many enemies, optimizing the sensor using dot products is not necessary
    now, but consider that for games with larger scale.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以使用`Vector3.Dot`，这将执行点积，这是一种数学函数，用于计算向量投影到另一个向量上的长度（在网上搜索更多信息）。`Vector3.Angle`实际上使用的是这个函数，但它将点积的结果转换为角度，这需要使用三角函数，并且可能计算起来很耗时。但我们的`Vector3.Angle`方法更简单，编码更快，而且鉴于我们不需要很多传感器，因为我们不会有太多敌人，使用点积优化传感器现在不是必要的，但考虑一下对于更大规模的游戏。
- en: Now check whether the calculated angle is less than the one specified in the
    `angle` field. Note that if we set an angle of `90`, it will actually be `180`,
    because if the `Vector3.Angle` function returns, as an example, `30`, it could
    be `30` to the left or to the right. If our angle says `90`, it could be both
    `90` to the left and to the right, so it will detect objects in a 180-degree arc.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在检查计算出的角度是否小于在`angle`字段中指定的角度。注意，如果我们设置角度为`90`，实际上将是`180`，因为如果`Vector3.Angle`函数返回，例如，`30`，它可能是向左或向右的`30`。如果我们的角度是`90`，它可能是向左和向右的`90`，所以它将检测到180度弧内的物体。
- en: Use the `Physics.Linecast` function to create an imaginary line between the
    first and the second parameter (our position and the collider position) to detect
    objects with the layers specified in the third parameter (the obstacle layers)
    and return `boolean` indicating whether that ray hit something or not.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Physics.Linecast`函数在第一个和第二个参数（我们的位置和碰撞体位置）之间创建一个假想线，以检测在第三个参数（障碍物层）中指定的层上的对象，并返回一个`boolean`值，指示该射线是否击中了某个物体。
- en: 'The idea is to use the line to detect whether there are any obstacles between
    ourselves and the detected collider, and if there is no obstacle, this means that
    we have a direct line of sight toward the object. Observe how we use the `!` or
    `not` operator in *Figure 9.6* to check if `Physics.Linecast` didn’t detect any
    objects. Again, note that this function depends on the obstacle objects having
    colliders, which in our case, we have (walls, floor, and so on):'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 理念是使用线来检测我们和检测到的碰撞体之间是否存在任何障碍物，如果没有障碍物，这意味着我们有一个直接视线通向该对象。观察我们如何在*图9.6*中使用`!`或`not`运算符来检查`Physics.Linecast`是否检测到任何对象。再次注意，这个函数依赖于具有碰撞体的障碍物对象，在我们的例子中，我们有（墙壁、地板等）：
- en: '![](img/B8585_09_06.png)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B8585_09_06.png)'
- en: 'Figure 9.6: Using a Linecast to check obstacles between the sensor and the
    target object'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.6：使用Linecast检查传感器和目标对象之间的障碍物
- en: If the object passes the three checks, that means that this is the object we
    are currently seeing, so we can save it inside a field of the `Collider` type
    called `detectedObject`, to save that information for later usage by the rest
    of the `AI` scripts.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果对象通过了三个检查，这意味着这是我们当前看到的对象，因此我们可以将其保存到名为`detectedObject`的`Collider`类型字段中，以便其他`AI`脚本稍后使用该信息。
- en: 'Consider using `break` to stop the `for` loop that is iterating the colliders
    to prevent wasting resources by checking the other objects, and to set `detectedObject`
    to `null` before `for` to clear the result from the previous frame. So if in this
    frame, we don’t detect anything, it will keep the `null` value so we notice that
    there is nothing in the sensor:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑使用`break`来停止迭代碰撞体的`for`循环，以防止通过检查其他对象而浪费资源，并在`for`之前将`detectedObject`设置为`null`以清除前一帧的结果。所以如果在这一帧中没有检测到任何东西，它将保持`null`值，这样我们就能注意到传感器中没有东西：
- en: '![](img/B8585_09_07.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B8585_09_07.png)'
- en: 'Figure 9.7: Full sensor script'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：完整的传感器脚本
- en: In our case, we are using the sensor just to look for the player, the only object
    the sensor is in charge of looking for, but if you want to make the sensor more
    advanced, you can just keep a list of detected objects, placing inside it every
    object that passes the three tests instead of just the first one. In our case,
    it’s not necessary given we have only one player in the game.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们只是使用传感器来寻找玩家，这是传感器负责寻找的唯一对象，但如果你想让传感器更高级，你只需保留一个检测到的对象列表，将每个通过三个测试的对象放入其中，而不是只放入第一个。在我们的例子中，这并不必要，因为我们游戏中只有一个玩家。
- en: 'In the editor, configure the sensor at your will. In this case, we will set
    `ObjectsLayer` to `Player` so our sensor will focus its search on objects with
    that layer, and `obstaclesLayer` to `Default`, the layer we used for walls and
    floors. Remember the `Sight` script is in the `AI` GameObject, which is a child
    of the `Enemy` prefab:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，根据您的意愿配置传感器。在这种情况下，我们将`ObjectsLayer`设置为`Player`，以便我们的传感器将搜索焦点放在具有该层的对象上，并将`obstaclesLayer`设置为`Default`，这是我们用于墙壁和地板的层。记住，`Sight`脚本位于`AI`GameObject中，它是`Enemy`预制件的子对象：
- en: '![](img/B8585_09_08.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B8585_09_08.png)'
- en: 'Figure 9.8: Sensor settings'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：传感器设置
- en: To test this, just place an enemy with a movement speed of 0 in front of the
    player, select its `AI` child object and then play the game to see how the property
    is set in the Inspector. Also, try putting an obstacle between the two and check
    that the property says **None** (`null`). If you don’t get the expected result,
    double-check your script, its configuration, and whether the player has the `Player`
    layer, and the obstacles have the `Default` layer. Also, you might need to raise
    the `AI` object a little bit to prevent the ray from starting below the ground
    and hitting it.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试这一点，只需在玩家前方放置一个移动速度为0的敌人，选择其`AI`子对象，然后玩游戏以查看属性在检查器中的设置情况。也可以尝试在两者之间放置一个障碍物，并检查属性是否显示**None**（`null`）。如果您没有得到预期的结果，请仔细检查您的脚本、其配置以及玩家是否具有`Player`层，障碍物是否具有`Default`层。此外，您可能需要将`AI`对象稍微抬高一点，以防止射线从地面开始并击中它。
- en: Given the size of the script, let’s dedicate an entire section to the Visual
    Scripting version, given it also introduces some new Visual Scripting concepts
    needed here.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到脚本的大小，我们为视觉脚本版本分配一个整个章节，因为它还引入了一些在这里需要的新视觉脚本概念。
- en: Creating Three-Filters sensors with Visual Scripting
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用视觉脚本创建三过滤传感器
- en: 'Regarding the Visual Scripting version, let’s check it part by part, starting
    with the **Overlap Sphere**:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，让我们逐部分检查，从**重叠球体**开始：
- en: '![](img/B8585_09_09.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B8585_09_09.png)'
- en: 'Figure 9.9: Overlap Sphere in Visual Scripting'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：视觉脚本中的重叠球体
- en: So far, we just called **Overlap Sphere** after setting the `sensedObject` variable
    to `null`. Something to consider is how the `sensedObject` variable in the **Variables**
    component in the Inspector doesn’t have a type (a **Null** type is no type in
    Visual Scripting). This can’t be possible in C#—all variables must have a type—and
    while we could set the `sensedObject` variable to the proper type (**Collider**),
    we will keep the variable type to be set later via a script. Even if we set the
    type now, Visual Scripting tends to forget the type if no value is set, and we
    cannot set it until we detect something.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是在将`sensedObject`变量设置为`null`后调用了**重叠球体**。需要考虑的是，检查器中**变量**组件中的`sensedObject`变量没有类型（在视觉脚本中，**Null**类型实际上没有类型）。这在C#中是不可能的——所有变量都必须有类型——虽然我们可以将`sensedObject`变量设置为正确的类型（**Collider**），但我们将会通过脚本稍后设置变量类型。即使我们现在设置类型，如果未设置值，视觉脚本往往会忘记类型，并且我们无法设置它，直到我们检测到某个东西。
- en: 'Don’t worry about that for the moment; when we set the variable through our
    script it will acquire the proper type. Actually, all variables in Visual Scripting
    can switch types at runtime according to what we set them to, given how the **Variables**
    component works. I don’t recommend doing that, though: try to stick with the intended
    variable type.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不必担心这个问题；当我们通过脚本设置变量时，它将获得正确的类型。实际上，在视觉脚本中，所有变量都可以在运行时根据我们设置的值切换类型，这取决于**变量**组件的工作方式。不过，我不建议这样做：尽量坚持使用预期的变量类型。
- en: We just said that all variables in C# must have a type, but that’s not entirely
    true. There are ways to create dynamically-typed variables, but it’s not a good
    practice that I’d recommend using unless no other option is present.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才说过，C#中的所有变量都必须有类型，但这并不完全正确。有方法可以创建动态类型的变量，但这不是一种我推荐使用的良好实践，除非没有其他选择。
- en: Another thing to observe is how we set the `sensedObject` variable to `null`
    at the beginning using the **Null** node, which effectively represents the `null`
    value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的事情是我们如何使用**Null**节点在开始时将`sensedObject`变量设置为`null`，这实际上代表了`null`值。
- en: 'Now, let’s explore the `Foreach` part:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索`Foreach`部分：
- en: '![](img/B8585_09_10.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B8585_09_10.png)'
- en: 'Figure 9.10: Iterating collections in Visual Scripting'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：视觉脚本中的集合迭代
- en: We can see that one of the output pins of **Overlap Sphere** is a little list,
    which essentially represents the collider array returned by **Overlap Sphere**.
    We connect that pin to the **For Each Loop** node, which as you might imagine
    iterates over the elements of the provided collection (array, list, dictionary,
    etc.). The **Body** pin represents the nodes to execute in each iteration of the
    loop, and the **Item** output pin represents the item currently being iterated—in
    our case, one of the colliders detected in **Overlap Sphere**. Finally, we save
    that item in a **Flow** `potentialDetection` variable, **Flow** variables being
    the equivalent to local variables in C# functions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到**重叠球体**的一个输出引脚是一个小列表，它本质上代表了由**重叠球体**返回的碰撞器数组。我们将该引脚连接到**For Each Loop**节点，正如你可能想象的那样，它遍历提供的集合（数组、列表、字典等）。**Body**引脚代表循环中要执行的节点，**Item**输出引脚代表当前正在迭代的项——在我们的案例中，是**重叠球体**检测到的碰撞器之一。最后，我们将该项保存在一个**Flow**
    `potentialDetection`变量中，**Flow**变量在C#函数中相当于局部变量。
- en: The idea here is that, given the size of the graph and the number of times we
    will be needing to query the currently iterated item, we don’t want the line connecting
    the output **Item** pin to the other nodes to cross the entire graph. Instead,
    we save that item in the **Flow** variable to reference it later, essentially
    naming that value to be referenced later in the graph, which you will see in the
    next parts of it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是，考虑到图的大小和我们查询当前迭代项的次数，我们不想让连接输出**Item**引脚到其他节点的线穿过整个图。相反，我们将该项保存在**Flow**变量中以供以后引用，本质上是在图中命名该值以供以后引用，你将在下一部分中看到这一点。
- en: 'Now let’s explore the **Angle** check:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探索**角度**检查：
- en: '![](img/B8585_09_11.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B8585_09_11.png)'
- en: 'Figure 9.11: Angle check in Visual Scripting'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：视觉脚本中的角度检查
- en: Here, you can see a direct translation of what we did in C# to detect the angle,
    so it should be pretty self-explanatory. The only thing here is given the proximity
    of the **Item** output pin to the **Get Position** node where we query its position,
    we directly connected the node, but we will use the `potentialDetection` flow
    variable later.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们将C#中检测角度的直接翻译，所以应该很容易理解。这里唯一需要注意的是，由于**Item**输出引脚与**Get Position**节点（我们查询其位置的节点）的邻近性，我们直接连接了该节点，但稍后我们将使用`potentialDetection`流变量。
- en: 'Now, let’s explore the **Linecast** part:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索**Linecast**部分：
- en: '![](img/B8585_09_12.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B8585_09_12.png)'
- en: 'Figure 9.12: Linecast check in Visual Scripting'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12：在视觉脚本中的Linecast检查
- en: Again, essentially the same as we did before in C#. The only thing to highlight
    here is the fact we used the **Flow** variable `potentialDetection` to again get
    the position of the current item being iterated, instead of connecting the **Get
    Position** node all the way to the **Foreach** **Item** output pin.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这与我们在C#中之前所做的是基本相同的。这里要强调的唯一一点是我们使用了**Flow**变量`potentialDetection`来再次获取当前迭代的项的位置，而不是将**Get
    Position**节点一直连接到**Foreach** **Item**输出引脚。
- en: 'Now, let’s explore the final part:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索最后一部分：
- en: '![](img/B8585_09_13.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B8585_09_13.png)'
- en: 'Figure 9.13: Setting the sensedObject'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13：设置sensedObject
- en: Again, pretty much self-explanatory; if the **Linecast** returns `false`, we
    set the `potentialDetection` variable (the currently iterated item) as the `sensedObject`
    variable (the one that will be accessed by other scripts later to query which
    is the object our AI can see right now). Something to consider here is the usage
    of the **Break Loop** node, which is the equivalent to the C# `break` keyword;
    essentially, we are stopping the **Foreach** loop we are currently in.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，相当直观；如果**Linecast**返回`false`，我们将`potentialDetection`变量（当前迭代的项）设置为`sensedObject`变量（稍后其他脚本将访问它以查询我们的AI现在可以看到哪个对象）。这里需要考虑的是**Break
    Loop**节点的使用，它是C#中`break`关键字的等效物；本质上，我们正在停止我们当前所在的**Foreach**循环。
- en: Now, even if we have our sensor working, sometimes checking whether it’s working
    or configured properly requires some visual aids we can create using gizmos.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使我们的传感器正在工作，有时检查它是否正常工作或正确配置也需要一些我们可以使用Gizmos创建的视觉辅助工具。
- en: Debugging with gizmos
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Gizmos进行调试
- en: As we create our AI, we will start to detect certain errors in edge cases, usually
    related to misconfigurations. You may think that the player falls within the sight
    range of the enemy but maybe you cannot see that the line of sight is occluded
    by an object, especially as the enemies move constantly. A good way to debug those
    scenarios is through editor-only visual aids known as `Gizmos`, which allow you
    to visualize invisible data such as the sight distance or the `Linecasts` executed
    to detect obstacles.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建我们的AI时，我们将开始检测边缘情况中的某些错误，通常与配置错误有关。你可能认为玩家在敌人的视距范围内，但你可能看不到视线被一个物体遮挡，尤其是在敌人不断移动的情况下。调试这些场景的一个好方法是使用仅编辑器可见的视觉辅助工具`Gizmos`，它允许你可视化不可见的数据，如视距或用于检测障碍物的`Linecasts`。
- en: 'Let’s start seeing how to create `Gizmos` drawing a sphere representing the
    sight distance by doing the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤来了解如何通过绘制表示视距的球体来创建`Gizmos`：
- en: In the `Sight` script, create an event function called `OnDrawGizmos`. This
    event is only executed in the editor (not in builds) and is the place Unity asks
    us to draw `Gizmos`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Sight`脚本中，创建一个名为`OnDrawGizmos`的事件函数。这个事件仅在编辑器中执行（不在构建中），并且是Unity要求我们绘制`Gizmos`的地方。
- en: 'Use the `Gizmos.DrawWireSphere` function, passing our position as the first
    parameter and the distance as the second parameter to draw a sphere in our position
    with the radius of our distance. You can check how the size of the `Gizmo` changes
    as you change the distance field:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Gizmos.DrawWireSphere`函数，将我们的位置作为第一个参数，将距离作为第二个参数来绘制一个球体，其半径等于我们的距离。你可以检查当你改变距离字段时`Gizmo`的大小如何变化：
- en: '![](img/B8585_09_14.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B8585_09_14.png)'
- en: 'Figure 9.14: Sphere Gizmo'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14：球体Gizmo
- en: 'Optionally, you can change the color of the gizmo, setting `Gizmos.color` prior
    to calling the drawing functions:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，你可以在调用绘图函数之前更改gizmo的颜色，设置`Gizmos.color`：
- en: '![](img/B8585_09_15.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B8585_09_15.png)'
- en: 'Figure 9.15: Gizmos drawing code'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15：Gizmos绘制代码
- en: Now you are drawing `Gizmos` constantly, and if you have lots of enemies, they
    can pollute the scene view with too many `Gizmos`. In that case, try the `OnDrawGizmosSelected`
    event function instead, which draws `Gizmos` only if the object is selected.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在不断地绘制`Gizmos`，如果你有很多敌人，它们可能会因为过多的`Gizmos`而污染场景视图。在这种情况下，尝试使用`OnDrawGizmosSelected`事件函数，它只在对象被选中时绘制`Gizmos`。
- en: 'We can draw the lines representing the cone using `Gizmos.DrawRay`, which receives
    the origin of the line to draw and the direction of the line, which can be multiplied
    by a certain value to specify the length of the line, as in the following screenshot:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`Gizmos.DrawRay`来绘制代表锥形的线条，它接收要绘制的线条的起点和方向，可以通过乘以一个特定的值来指定线条的长度，如下面的截图所示：
- en: '![](img/B8585_09_16.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B8585_09_16.png)'
- en: 'Figure 9.16: Drawing rotated lines'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16：绘制旋转的线条
- en: In the screenshot, we used `Quaternion.Euler` to generate a quaternion based
    on the angles we want to rotate. A quaternion is a mathematical construct to represent
    rotations; please search for this term for more info on it. If you multiply this
    quaternion by a direction, we will get the rotated direction. We are taking our
    forward vector and rotating it according to the angle field to generate our cone
    vision lines.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在截图中，我们使用了`Quaternion.Euler`根据我们想要旋转的角度生成四元数。四元数是一种数学结构，用于表示旋转；请搜索此术语以获取更多关于它的信息。如果我们用这个四元数乘以一个方向，我们将得到旋转后的方向。我们正在根据角度字段旋转我们的前向向量，以生成我们的锥形视野线。
- en: 'Also, we multiply this direction by the sight distance to draw the line as
    far as our sight can see; you will see how the line matches the end of the sphere
    this way:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将这个方向乘以视线距离来绘制线条，直到我们的视线所能看到的地方；你会看到线条如何与球体的末端匹配：
- en: '![](img/B8585_09_17.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B8585_09_17.png)'
- en: 'Figure 9.17: Vision angle lines'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17：视野角度线
- en: 'We can also draw the Linecasts, which check the obstacles, but as those depend
    on the current situation of the game, such as the objects that pass the first
    two checks and their positions, we can use `Debug.DrawLine` instead, which can
    be executed in the `Update` method. This version of `DrawLine` is designed to
    be used in runtime only. The `Gizmos` we saw also execute in the editor. Let’s
    try them the following way:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以绘制`Linecasts`，它们检查障碍物，但鉴于这些取决于游戏的当前情况，例如通过前两个检查的对象及其位置，我们可以使用`Debug.DrawLine`代替，它可以在`Update`方法中执行。这个版本的`DrawLine`是为运行时设计的。我们看到的`Gizmos`也在编辑器中执行。让我们以下面的方式尝试它们：
- en: 'First, let’s debug the scenario where `Linecast` didn’t detect any obstacles,
    so we need to draw a line between our sensor and the object. We can call `Debug.DrawLine`
    in the `if` statement that calls `Linecast`, as in the following screenshot:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们调试`Linecast`没有检测到任何障碍物的情况，因此我们需要在传感器和物体之间绘制一条线。我们可以在调用`Linecast`的`if`语句中调用`Debug.DrawLine`，如下面的截图所示：
- en: '![](img/B8585_09_18.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B8585_09_18.png)'
- en: 'Figure 9.18: Drawing a line in Update'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18：在Update中绘制线条
- en: 'In the next screenshot, you can see `DrawLine` in action:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个截图中，你可以看到`DrawLine`的实际应用：
- en: '![](img/B8585_09_19.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B8585_09_19.png)'
- en: 'Figure 9.19: Line toward the detected Object'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19：指向检测到的物体的线条
- en: 'We also want to draw a line in red when the sight is occluded by an object.
    In this case, we need to know where the `Linecast` hit, so we can use an overload
    of the function, which provides an `out` parameter that gives us more information
    about what the line collided with, such as the position of the hit and the normal
    and the collided object, as in the following screenshot:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当视线被物体遮挡时，我们也想用红色绘制一条线。在这种情况下，我们需要知道`Linecast`碰撞的位置，因此我们可以使用函数的重载，它提供了一个`out`参数，可以给我们更多关于线条碰撞的信息，例如碰撞位置、法线和碰撞物体，如下面的截图所示：
- en: '![](img/B8585_09_20.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B8585_09_20.png)'
- en: 'Figure 9.20: Getting information about Linecast'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20：获取Linecast的信息
- en: Note that `Linecast` doesn’t always collide with the nearest obstacle but with
    the first object it detects in the line, which can vary in order. If you need
    to detect the nearest obstacle, look for the `Physics.Raycast` version of the
    function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Linecast`并不总是与最近的障碍物碰撞，而是与它在直线上检测到的第一个对象碰撞，这可能会变化。如果你需要检测最近的障碍物，请查找`Physics.Raycast`函数的版本。
- en: 'We can use that information to draw the line from our position to the hit point
    in `else` of the `if` sentence when the line collides with something:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以利用这些信息在`else`分支中，当线条与物体碰撞时，从我们的位置绘制到碰撞点：
- en: '![](img/B8585_09_21.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B8585_09_21.png)'
- en: 'Figure 9.21: Drawing a line if we have an obstacle'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21：如果有障碍物则绘制线条
- en: 'In the next screenshot, you can see the results:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一张屏幕截图中，你可以看到结果：
- en: '![](img/B8585_09_22.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![img/B8585_09_22.png](img/B8585_09_22.png)'
- en: 'Figure 9.22: Line when an obstacle occludes vision'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22：当障碍物遮挡视线时的线条
- en: 'Regarding the Visual Scripting version, the first part will look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，第一部分将看起来像这样：
- en: '![](img/B8585_09_23.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![img/B8585_09_23.png](img/B8585_09_23.png)'
- en: 'Figure 9.23: Drawing Gizmos with Visual Scripting'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.23：在视觉脚本中绘制Gizmos
- en: 'Then, the angle lines would look like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，角度线将看起来像这样：
- en: '![](img/B8585_09_24.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![img/B8585_09_24.png](img/B8585_09_24.png)'
- en: 'Figure 9.24: Drawing Angle lines of sight in Visual Scripting'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24：在视觉脚本中绘制视线角度线
- en: 'Note that, here, we are showing just one, but the other is essentially the
    same but multiplying the angle by -1\. Finally, the red lines towards the detected
    object and obstacles will look like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里我们只展示了一个，但另一个本质上相同，只是将角度乘以-1。最后，指向检测到的对象和障碍物的红色线条将看起来像这样：
- en: '![](img/B8585_09_25.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![img/B8585_09_25.png](img/B8585_09_25.png)'
- en: 'Figure 9.25: Drawing lines towards obstacles or detected objects in Visual
    Scripting'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.25：在视觉脚本中绘制指向障碍物或检测到的对象的线条
- en: Note that, to accomplish this last one, we needed to change the previous **Linecast**
    node for the version that returns **Raycast Hit** info at the end.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了完成最后一点，我们需要将之前的**Linecast**节点更改为返回**Raycast Hit**信息的版本。
- en: With all of that, in this section, we created the sensors system that will give
    sight to our AI and plenty of info about what to do next. Now that we have our
    sensors completed, let’s use the information provided by them to make decisions
    with FSMs.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些的基础上，在本节中，我们创建了传感器系统，它将为我们的AI提供视力，并大量关于下一步要做什么的信息。现在我们的传感器已经完成，让我们利用它们提供的信息使用有限状态机（FSMs）来做出决策。
- en: Making decisions with FSMs
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FSMs做出决策
- en: We explored the concept of **Finite State Machines** (**FSMs**) in the past
    when we used them in the `Animator` component. We learned that an FSM is a collection
    of states, each one representing an action that an object can be executing at
    a time, and a set of transitions that dictates how the states are switched. This
    concept is not only used in animation but in a myriad of programming scenarios,
    and one of the common ones is AI. We can just replace the animations with AI code
    in the states and we have an AI FSM.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前使用`Animator`组件时探讨了**有限状态机（FSMs**）的概念。我们了解到，FSM是一组状态，每个状态代表一个对象在某一时刻可以执行的动作，以及一组转换，这些转换规定了状态如何切换。这个概念不仅用于动画，而且在无数的编程场景中都有应用，其中之一就是AI。我们只需在状态中用AI代码替换动画，我们就有了一个AI
    FSM。
- en: 'In this section, we will examine the following AI FSM concepts:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下AI FSM概念：
- en: Creating the FSM in C#
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C#中创建FSM
- en: Creating transitions
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建转换
- en: Creating the FSM in Visual Scripting
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视觉脚本中创建FSM
- en: Let’s start by creating our FSM skeleton.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建我们的FSM框架。
- en: Creating the FSM in C#
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在C#中创建FSM
- en: To create our own FSM, we need to recap some basic concepts. Remember that an
    FSM can have a state for each possible action it can execute and that only one
    can be executed at a time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们自己的FSM，我们需要回顾一些基本概念。记住，FSM可以为每个可能执行的动作有一个状态，并且一次只能执行一个。
- en: 'In terms of AI, for example, we can be patrolling, attacking, fleeing, and
    so on. Also, remember that there are transitions between states that determine
    conditions to be met to change from one state to another, and in terms of AI,
    this can be the user being near the enemy to start attacking or life being low
    to start fleeing. In the next figure, you can find a simple reminder example of
    the two possible states of a door:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在AI方面，例如，我们可以巡逻、攻击、逃跑等。还要记住，状态之间存在转换，这些转换决定了从一种状态转换到另一种状态所需满足的条件，在AI方面，这可能是用户靠近敌人开始攻击或生命值低开始逃跑。在下图中，你可以找到一个简单的门两种可能状态的提醒示例：
- en: '![State diagram - Wikipedia](img/B8585_09_26.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![State diagram - Wikipedia](img/B8585_09_26.png)'
- en: 'Figure 9.26: FSM example'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.26：FSM示例
- en: 'There are several ways to implement FSMs for AI; you can even use the `Animator`
    component if you want to or download some FSM system from the Asset Store. In
    our case, we are going to take the simplest approach possible, a single script
    with a set of `If` sentences, which can be basic but is still a good start to
    understanding the concept. Let’s implement it by doing the following:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有几种方法可以实现AI的FSMs；如果你愿意，甚至可以使用`Animator`组件，或者从资源商店下载一些FSM系统。在我们的情况下，我们将采取最简单的方法，即一个包含一系列`If`语句的单个脚本，这虽然简单，但仍然是理解概念的好开始。让我们通过以下步骤来实现它：
- en: Create a script called `EnemyFSM` in the `AI` child object of the enemy.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在敌人的`AI`子对象中创建一个名为`EnemyFSM`的脚本。
- en: Create an `enum` called `EnemyState` with the `GoToBase`, `AttackBase`, `ChasePlayer`,
    and `AttackPlayer` values. We are going to have those states in our AI.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`EnemyState`的`enum`，包含`GoToBase`、`AttackBase`、`ChasePlayer`和`AttackPlayer`值。我们将在我们的AI中拥有这些状态。
- en: 'Create a field of the `EnemyState` type called `currentState`, which will hold
    the current state of our enemy:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`currentState`的`EnemyState`类型字段，它将保存我们敌人的当前状态：
- en: '![](img/B8585_09_27.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B8585_09_27.png)'
- en: 'Figure 9.27: EnemyFSM state definition'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.27：EnemyFSM状态定义
- en: Create three functions named after the states we defined.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个以我们定义的状态命名的函数。
- en: 'Call those functions in `Update` depending on the current state:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据当前状态在`Update`中调用这些函数：
- en: '![](img/B8585_09_28.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B8585_09_28.png)'
- en: 'Figure 9.28: If-based FSM'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.28：基于If的有限状态机
- en: Yes, you can totally use a switch here, but I just prefer the regular `if` syntax
    for this example.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，您完全可以在这里使用switch，但我只是更喜欢这个示例中的常规`if`语法。
- en: 'Test in the editor how changing the `currentState` field will change which
    state is active, seeing the messages being printed in the console:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中测试如何更改`currentState`字段将更改哪个状态是活动的，查看控制台中的打印消息：
- en: '![](img/B8585_09_29.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B8585_09_29.png)'
- en: 'Figure 9.29: State testing'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.29：状态测试
- en: As you can see, it is a pretty simple but totally functional approach. In the
    future, you could face having to code enemies with many more states, and this
    approach will start to scale badly. In such a case, you could use any FSM plugin
    of the Asset Store you prefer to have more powerful and scalable tools, or even
    consider advanced techniques like Behavior Trees, but that’s outside the scope
    of this book. Now let’s continue with this FSM, creating its transitions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个相当简单但完全功能的方法。在未来，您可能会面临需要编写具有更多状态敌人的情况，这种方法将开始变得不适用。在这种情况下，您可以使用您喜欢的任何资产商店的有限状态机插件，以获得更强大和可扩展的工具，或者甚至考虑更高级的技术，如行为树，但这超出了本书的范围。现在让我们继续使用有限状态机，创建其转换。
- en: Creating transitions
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建转换
- en: 'If you remember the transitions created in the `Animator Controller`, those
    were basically a collection of conditions that are checked if the state the transition
    belongs to is active. In our FSM approach, this translates simply as `If` sentences
    that detect conditions inside the states. Let’s create the transitions between
    our proposed states as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得在`Animator Controller`中创建的转换，那些基本上是一组条件，如果转换所属的状态是活动的，则会检查这些条件。在我们的有限状态机方法中，这简单地转化为检测状态内条件的`If`语句。让我们按照以下方式创建我们建议状态之间的转换：
- en: Add a field of the `Sight` type called `sightSensor` in our FSM script, and
    drag the AI `GameObject` to that field to connect it to the `Sight` component
    there. As the FSM component is in the same object as `Sight`, we can also use
    `GetComponent` instead, but in advanced AIs, you might have different sensors
    that detect different objects, so I prefer to prepare my script for that scenario.
    You should pick the approach you like the most.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的有限状态机脚本中添加一个名为`sightSensor`的`Sight`类型字段，并将AI `GameObject`拖动到该字段以连接到那里的`Sight`组件。由于有限状态机组件与`Sight`组件位于同一对象中，我们也可以使用`GetComponent`，但在高级AI中，你可能有不同的传感器来检测不同的对象，所以我更喜欢为那种情况准备我的脚本。你应该选择你最喜欢的方法。
- en: 'In the `GoToBase` function, check whether the detected object of the `Sight`
    component is not `null`, meaning that something is inside our line of vision.
    If our AI is going toward the base but detects an object in the way, we must switch
    to the `Chase` state to pursue the player, so we change the state, as in the following
    screenshot:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GoToBase`函数中，检查`Sight`组件检测到的对象是否不为`null`，这意味着在我们的视线中有东西。如果我们的AI正在向基地移动但检测到障碍物中的对象，我们必须切换到`Chase`状态以追击玩家，因此我们改变状态，如下面的截图所示：
- en: '![](img/B8585_09_30.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B8585_09_30.png)'
- en: 'Figure 9.30: Creating transitions'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.30：创建转换
- en: 'Also, we must change to `AttackBase` if we are near enough to the object that
    must be damaged to decrease the base life. We can create a field of the `Transform`
    type called `baseTransform` and drag the player’s base life object we created
    previously there so we can check the distance. Remember to add a float field called
    `baseAttackDistance` to make that distance configurable:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，如果我们离必须损坏以减少基础生命值的目标足够近，我们必须切换到`AttackBase`。我们可以创建一个名为`baseTransform`的`Transform`类型字段，并将之前创建的玩家基础生命值对象拖动到那里，以便我们可以检查距离。记得添加一个名为`baseAttackDistance`的浮点字段，以便可以配置该距离：
- en: '![](img/B8585_09_31.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B8585_09_31.png)'
- en: 'Figure 9.31: GoToBase transitions'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.31：GoToBase转换
- en: 'In the case of `ChasePlayer`, we need to check whether the player is out of
    sight to switch back to the `GoToBase` state or whether we are near enough to
    the player to start attacking it. We will need another distance field called `PlayerAttackDistance`,
    which determines the distance to attack the player, and we might want different
    attack distances for those two targets. Consider an early return in the transition
    to prevent getting `null` reference exceptions if we try to access the position
    of the sensor detected object when there are not any:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ChasePlayer`的情况下，我们需要检查玩家是否在视线之外，以便切换回`GoToBase`状态，或者我们是否足够接近玩家以开始攻击它。我们需要另一个名为`PlayerAttackDistance`的距离字段，它决定了攻击玩家的距离，我们可能希望为这两个目标设置不同的攻击距离。考虑在转换中提前返回，以防止在没有任何传感器检测到的对象时尝试访问其位置时出现`null`引用异常：
- en: '![](img/B8585_09_32.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B8585_09_32.png)'
- en: 'Figure 9.32: ChasePlayer transitions'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.32：ChasePlayer状态转换
- en: For `AttackPlayer`, we need to check whether the player is out of sight to get
    back to `GoToBase` or whether it is far enough to go back to chasing it. You will
    notice how we multiplied `playerAttackDistance` to make the stop-attacking distance
    a little bit greater than the start-attacking distance; this will prevent switching
    back and forth rapidly between attacking and chasing when the player is near that
    distance.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`AttackPlayer`，我们需要检查玩家是否在视线之外以返回`GoToBase`，或者它是否足够远以返回追逐它。你会注意到我们是如何将`playerAttackDistance`相乘，使停止攻击的距离略大于开始攻击的距离；这将防止当玩家接近那个距离时在攻击和追逐之间快速切换。
- en: 'You can make it configurable instead of hardcoding `1.1`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其设置为可配置的，而不是硬编码`1.1`：
- en: '![](img/B8585_09_33.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B8585_09_33.png)'
- en: 'Figure 9.33: AttackPlayer transitions'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.33：AttackPlayer状态转换
- en: In our case, `AttackBase` won’t have any transition. Once the enemy is near
    enough to the base to attack it, it will stay like that, even if the player starts
    shooting at it. Its only objective once there is to destroy the base.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的案例中，`AttackBase`将不会有任何转换。一旦敌人足够接近基地以攻击它，它就会保持这种状态，即使玩家开始射击它。一旦到达那里，它的唯一目标就是摧毁基地。
- en: 'Remember you can use `Gizmos` to draw the distances:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住你可以使用`Gizmos`来绘制距离：
- en: '![](img/B8585_09_34.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B8585_09_34.png)'
- en: 'Figure 9.34: FSM Gizmos'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.34：FSM Gizmos
- en: 'Test the script by selecting the AI Object prior to clicking play and then
    move the player around, checking how the states change in the inspector. You can
    also keep the original `print` messages in each state to see them changing in
    the console. Remember to set the attack distances and the references to the objects.
    In the screenshot, you can see the settings we use:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在点击播放之前选择AI对象并移动玩家，以测试脚本，检查检查器中的状态如何变化。你还可以保留每个状态中的原始`print`消息，以在控制台中查看它们的变化。记住要设置攻击距离和对象的引用。在截图中，你可以看到我们使用的设置：
- en: '![](img/B8585_09_35.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B8585_09_35.png)'
- en: 'Figure 9.35: Enemy FSM settings'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.35：敌人FSM设置
- en: A little problem that we will have now is that the spawned enemies won’t have
    the needed references to make the distance calculations to the player’s base transform.
    You will notice that if you try to apply the changes on the enemy of the scene
    to the Prefab (**Overrides -> Apply All**), the **Base Transform** variable will
    say `None`. Remember that Prefabs cannot contain references to objects in the
    scene, which complicates our work here. One alternative would be to create `BaseManager`,
    a Singleton that holds the reference to the damage position, so our `EnemyFSM`
    can access it. Another one could be to make use of functions such as `GameObject.Find`
    to find our object.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在会遇到的一个小问题是，生成的敌人将不会有进行到玩家基地转换的距离计算所需的引用。你会注意到，如果你尝试将场景中敌人的更改应用到Prefab（**覆盖
    -> 应用全部**），则**基地转换**变量将显示为`None`。记住，Prefab不能包含对场景中对象的引用，这使我们的工作变得更加复杂。一个替代方案是创建`BaseManager`，一个单例，它持有对损坏位置的引用，这样我们的`EnemyFSM`就可以访问它。另一个方案可能是使用`GameObject.Find`等函数来查找我们的对象。
- en: In this case, we will see the latter. Even though it can be less performant
    than the `Manager` version, I want to show you how to use it to expand your Unity
    toolset. In this case, just set the `baseTransform` field in `Awake` to the return
    of `GameObject`.`Find`, using `BaseDamagePoint` as the first parameter, which
    will look for an object with the same name, as in the following screenshot.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将看到后者。尽管它可能比`Manager`版本性能略低，但我想要向你展示如何使用它来扩展你的Unity工具集。在这种情况下，只需在`Awake`中将`baseTransform`字段设置为`GameObject`.`Find`的返回值，使用`BaseDamagePoint`作为第一个参数，这将查找具有相同名称的对象，如下面的截图所示。
- en: 'You will see that now our wave-spawned enemies will change states:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到现在我们的波生成的敌人将改变状态：
- en: '![](img/B8585_09_36.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B8585_09_36.png)'
- en: 'Figure 9.36: Searching for an object in the scene by name'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.36：通过名称在场景中搜索对象
- en: Now that our FSM states are coded and execute transitions properly, let’s see
    how to do the same in Visual Scripting. Feel free to skip the following section
    if you are only interested in the C# version.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将FSM状态编码并正确执行了转换，让我们看看如何在视觉脚本中做到同样的事情。如果你只对C#版本感兴趣，可以自由跳过以下部分。
- en: Creating the FSM in Visual Scripting
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在视觉脚本中创建FSM
- en: 'So far, most scripts in Visual Scripting were almost a mirror of the C# version
    with some differences in some nodes. While regarding state machines we could do
    the same, instead, we are going to use the **State Machine** system of Visual
    Scripting. The concept is the same, you have states and can switch them, but how
    the states are organized and when the transitions trigger is managed visually,
    in a similar way as the Animator system does. So, let’s see how we can use the
    system by creating our first `State Machine Graph` and some `states`. Follow these
    steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在视觉脚本中的大多数脚本几乎与C#版本相同，只是在一些节点上有所不同。在考虑状态机时，我们可以做同样的事情，但相反，我们将使用视觉脚本的**状态机**系统。概念是相同的，你有状态并且可以切换它们，但状态的组织方式和转换何时触发是通过视觉管理的，这与Animator系统的方式相似。所以，让我们通过创建我们的第一个`状态机图`和一些`状态`来看看我们如何使用这个系统。按照以下步骤操作：
- en: Add the **State Machine** component to our enemy. Remember it is called **State
    Machine** and not **Script Machine**, the latter being the component for regular
    Visual Scripts.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**状态机**组件添加到我们的敌人上。请记住，它被称为**状态机**而不是**脚本机**，后者是常规视觉脚本的组件。
- en: Click the **New** button in the component and select a place to save the `fixed`
    asset in a similar way to what we have done so far for regular Visual Scripts.
    In my case, I called it `EnemyFSM`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件中点击**新**按钮，并选择一个位置保存`fixed`资产，方式与我们迄今为止为常规视觉脚本所做的方式相似。在我的情况下，我将其命名为`EnemyFSM`。
- en: '![](img/B8585_09_37.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B8585_09_37.png)'
- en: 'Figure 9.37: Creating a Visual State Machine'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.37：创建视觉状态机
- en: Double-click **State Machine Graph** to edit it as usual.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**状态机图**以通常方式编辑它。
- en: 'Right-click in any empty area of the **Graph** editor and select **Create Script
    State** in order to create a new state:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**图**编辑器的任何空白区域右键单击，然后选择**创建脚本状态**以创建一个新状态：
- en: '![](img/B18585_09_38.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_09_38.png)'
- en: 'Figure 9.38: Creating our first Visual State Machine State'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.38：创建我们的第一个视觉状态机状态
- en: 'Repeat *step 4* until you end up having 4 states:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤4*，直到你拥有4个状态：
- en: '![](img/B18585_09_39.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_09_39.png)'
- en: 'Figure 9.39: Visual states'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.39：视觉状态
- en: 'Select any of them and in the **Info** panel on the left, fill the **Title**
    field (the first one) with the name of any of the states we created before (`GoToBase`,
    `AttackBase`, `ChasePlayer`, and `AttackPlayer`). If you don’t see the **Info**
    panel, click the button with the **i** in the middle to display it:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择任何一个，然后在左侧的**信息**面板中，将**标题**字段（第一个）填写为我们之前创建的任何状态的名字（`GoToBase`、`AttackBase`、`ChasePlayer`和`AttackPlayer`）。如果你看不到**信息**面板，点击中间带有**i**的按钮以显示它：
- en: '![](img/B18585_09_40.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_09_40.png)'
- en: 'Figure 9.40: Renaming a Visual State'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.40：重命名视觉状态
- en: 'Repeat that for the rest of the state nodes until you have each node named
    after each state created in the *Creating the FSM in C#* section of this chapter:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复上述步骤，直到你为每个状态节点命名，每个节点都对应于本章“在C#中创建FSM”部分中创建的状态：
- en: '![](img/B18585_09_41.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_09_41.png)'
- en: 'Figure 9.41: All needed states'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.41：所有需要的状态
- en: You can see one of the states has a green bar at the top, which represents which
    node is supposed to be the first one. I renamed that initial state `GoToBase`
    as that’s the one I prefer to be first. If you don’t have that one as the starting
    one, right-click the node that currently has the green bar in your state machine,
    select **Toggle Start** to remove the green bar from it, and then repeat for the
    node that you want to be the first one (`GoToBase` in our scenario), adding the
    green bar to that one.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到其中一个状态顶部有一个绿色条，这代表哪个节点应该是第一个。我将那个初始状态重命名为`GoToBase`，因为这是我更喜欢作为第一个的状态。如果你没有将其作为起始状态，右键单击当前具有绿色条的状态机中的节点，选择**切换起始**以从它那里移除绿色条，然后对你想作为第一个的节点（在我们的场景中是`GoToBase`）重复此操作，将绿色条添加到该节点上。
- en: Something to consider is that you can have more than one start state in Visual
    Scripting, meaning you can have multiple states running at the same time and transitioning.
    If possible, I recommend avoiding having more than one state active at a time
    to make things simple.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的是，在视觉脚本中可以有一个以上的起始状态，这意味着您可以同时运行多个状态并转换。如果可能，我建议避免同时只有一个状态处于活动状态，以使事情变得简单。
- en: 'Double-click `GoToBase` to enter the edit mode for these states. Connect a
    **String** node to the **print** **Message** input pin in the **OnUpdate** event
    node to print a message saying `GoToBase`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`GoToBase`以进入这些状态的编辑模式。将一个**String**节点连接到**OnUpdate**事件节点中的**print** **Message**输入引脚，以打印一条消息说`GoToBase`：
- en: '![](img/B18585_09_42.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_42.png)'
- en: 'Figure 9.42: Our first state machine logic'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.42：我们的第一个状态机逻辑
- en: 'In the top bar, click the **EnemyFSM** label at the left of **GoToBase** in
    order to return to the whole State Machine view. If you don’t see it, click any
    text label at the right of the third button (the one that looks like *<x>*):'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部栏中，单击**GoToBase**左侧的**EnemyFSM**标签以返回到整个状态机视图。如果您看不到它，请单击第三个按钮（看起来像 *<x>*）右侧的任何文本标签：
- en: '![](img/B18585_09_43.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_43.png)'
- en: 'Figure 9.43: Returning to the State Machine editor mode'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.43：返回到状态机编辑模式
- en: Feel free to delete the other event nodes if you are not planning to use them.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您不打算使用其他事件节点，可以随意删除它们。
- en: Repeat *steps 9-11* for each state until all of them print their names.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个状态重复*步骤 9-11*，直到它们都打印出它们的名称。
- en: 'With this, we have created the nodes representing the possible states of our
    AI. In the next section, we will be adding logic for them to something meaningful,
    but before that, we need to create the transitions between the states and the
    conditions that need to be met to trigger them by doing the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经创建了表示我们AI可能状态的节点。在下一节中，我们将为它们添加逻辑，使其变得有意义，但在那之前，我们需要通过以下方式创建状态之间的转换和触发它们的条件：
- en: Create variables in the **Variables** component of the enemy called `baseTransform`,
    `baseAttackDistance`, and `playerAttackDistance` as we are going to need them
    to do the transitions.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在敌人的**变量**组件中创建变量`baseTransform`、`baseAttackDistance`和`playerAttackDistance`，因为我们将在执行转换时需要它们。
- en: 'Don’t set any type to `baseTransform` as we will fill it later via code, but
    regarding `baseAttackDistance`, make it using the **Float** type and put a value
    of `2`, and finally for `playerAttackDistance`, also use **Float** and a value
    of `3`. Feel free to change those values if you prefer:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要为`baseTransform`设置任何类型，因为我们将在稍后通过代码填充它，但关于`baseAttackDistance`，使用**Float**类型并设置值为`2`，最后对于`playerAttackDistance`，也使用**Float**并设置值为`3`。如果您愿意，可以更改这些值：
- en: '![](img/B18585_09_44.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_44.png)'
- en: 'Figure 9.44: Variables needed for our transitions'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.44：我们转换所需的变量
- en: 'Right-click the `GoToBase` node and select the **Make Transition** option,
    and then click the `ChasePlayer` node. This will create a transition between the
    two states:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`GoToBase`节点，选择**创建转换**选项，然后单击`ChasePlayer`节点。这将在这两个状态之间创建一个转换：
- en: '![](img/B18585_09_45.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_45.png)'
- en: 'Figure 9.45: A transition between two states'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.45：两个状态之间的转换
- en: 'Repeat *step 3* for each transition we created in the C# version. The `State
    Machine Graph` will need to look like the following screenshot:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对C#版本中创建的每个转换重复*步骤 3*。`状态机图形`需要看起来像以下截图：
- en: '![](img/B18585_09_46.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_46.png)'
- en: 'Figure 9.46: All the needed transitions'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.46：所有需要的转换
- en: Double-click the yellow shape in the middle of the transition between **GoToBase**
    and **ChasePlayer** to enter the **Transition** mode. Here, you will be able to
    specify the condition that will trigger that transition (instead of using an `If`
    node during the state logic). Remember you have two yellow shapes, one for each
    transition direction, so check you are double-clicking the correct one based on
    the white arrows connecting them.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**GoToBase**和**ChasePlayer**之间的转换中间的黄色形状以进入**转换**模式。在这里，您将能够指定将触发该转换的条件（而不是在状态逻辑中使用`If`节点）。请记住，您有两个黄色形状，每个方向一个，所以请确保您双击的是基于连接它们的白色箭头的正确形状。
- en: 'Modify the graph in order to check if the `sensedObject` variable is not `null`.
    It should look like this:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改图形以检查`sensedObject`变量是否不是`null`。它应该看起来像这样：
- en: '![](img/B18585_09_47.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_47.png)'
- en: 'Figure 9.47: Adding a transition condition'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.47：添加转换条件
- en: 'The transition between **GoToBase** and **AttackBase** should look like this:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GoToBase** 和 **AttackBase** 之间的转换应该看起来像这样：'
- en: '![](img/B18585_09_48.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_48.png)'
- en: 'Figure 9.48: GoToBase to AttackBase transition condition'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.48：从 **GoToBase** 到 **AttackBase** 的转换条件
- en: 'Now, **ChasePlayer** to **GoToBase** should be as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，**ChasePlayer** 到 **GoToBase** 应该如下所示：
- en: '![](img/B18585_09_49.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_49.png)'
- en: 'Figure 9.49: ChasePlayer to GoToBase transition condition'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.49：从 **ChasePlayer** 到 **GoToBase** 的转换条件
- en: 'For the **ChasePlayer** to **AttackPlayer** transition, do as in *Figure 9.50*.
    This is essentially the same as **GoToBase** and **AttackBase**, a distance check,
    but with different targets:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于从 **ChasePlayer** 到 **AttackPlayer** 的转换，按照 *图9.50* 所示操作。这本质上与 **GoToBase**
    和 **AttackBase** 相同，都是距离检查，但目标不同：
- en: '![](img/B18585_09_50.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_50.png)'
- en: 'Figure 9.50: ChasePlayer to AttackPlayer transition condition'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.50：从 **ChasePlayer** 到 **AttackPlayer** 的转换条件
- en: 'For the **AttackPlayer** to **ChasePlayer** transition, do as in *Figure 9.51*.
    This is another distance check but is now checking if the distance is greater
    and multiplying the distance by `1.1` (to prevent transition jittering as we explained
    in the C# version):'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于从 **AttackPlayer** 到 **ChasePlayer** 的转换，按照 *图9.51* 所示操作。这又是一个距离检查，但现在检查距离是否更大，并将距离乘以
    `1.1`（以防止像我们在 C# 版本中解释的那样转换抖动）：
- en: '![](img/B18585_09_51.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_51.png)'
- en: 'Figure 9.51: AttackPlayer to ChasePlayer transition condition'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.51：从 **AttackPlayer** 到 **ChasePlayer** 的转换条件
- en: 'Finally, for **AttackPlayer** to **GoToBase** this is the expected graph:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于从 **AttackPlayer** 到 **GoToBase** 的转换，这是预期的图形：
- en: '![](img/B18585_09_52.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_52.png)'
- en: 'Figure 9.52: AttackPlayer to GoToBase transition condition'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.52：从 **AttackPlayer** 到 **GoToBase** 的转换条件
- en: A little detail we need to tackle before moving on is the fact that we still
    don’t have any value set in the `baseTransform` variable. The idea is to fill
    it via code as we did in the C# version. But something to consider here is that
    we cannot add an `Awake` event node to the whole state machine, but just to the
    states.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要解决的一个小细节是我们仍然没有在 `baseTransform` 变量中设置任何值。想法是通过代码来填充它，就像我们在 C# 版本中所做的那样。但在这里需要考虑的是，我们无法将
    `Awake` 事件节点添加到整个状态机中，而只能添加到状态中。
- en: In this scenario, we could use the **OnEnterState** event, which is an exclusive
    event node for state machines. It will execute as soon as the state becomes active,
    which is useful for state initializations. We could add the logic to initialize
    the `baseTransform` variable in the **OnEnterState** event node of the **GoToBase**
    state, given it is the first state we execute.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以使用 **OnEnterState** 事件，这是一个状态机的专用事件节点。它将在状态变为活动状态时立即执行，这对于状态初始化很有用。我们可以在
    **GoToBase** 状态的 **OnEnterState** 事件节点中添加初始化 `baseTransform` 变量的逻辑，因为这是我们首先执行的状态。
- en: 'This way, **GoToBase** logic will look as in *Figure 9.53*. Remember to double-click
    the state node to edit it:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，**GoToBase** 逻辑将看起来像 *图9.53* 所示。记得双击状态节点来编辑它：
- en: '![](img/B18585_09_53.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_53.png)'
- en: 'Figure 9.53: GoToBase initialization logic'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.53：**GoToBase** 初始化逻辑
- en: Notice how, here, we set the result of the **Find** node into the variable only
    on the **Null** pin of **Null Check**. What **Null Check** does is check if our
    **baseTransform** variable is set, going through the `Not Null` pin if it is,
    and `Null` if it isn’t. This way we avoid executing **GameObject.Find** every
    time we enter the **GoToBase** state, but only the first time. Also, note that
    in this case, we will be executing the **Set Variable** node not only when the
    object initializes, but also each time **GoToBase** becomes the current state.
    If, in any case, that results in unexpected behavior, other options could be to
    create a new initial state that initializes everything and then transitions to
    the rest of the states, or maybe do a classic Visual Script graph that initializes
    those variables in the **On Start** event node.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里，我们仅在 **Null Check** 的 **Null** 插针上将 **Find** 节点的结果设置到变量中。**Null Check**
    的作用是检查我们的 **baseTransform** 变量是否已设置，如果是，则通过 `Not Null` 插针，如果不是，则通过 `Null` 插针。这样我们就可以避免每次进入
    **GoToBase** 状态时都执行 **GameObject.Find**，而只需第一次。此外，请注意，在这种情况下，我们不仅会在对象初始化时执行 **Set
    Variable** 节点，而且每次 **GoToBase** 成为当前状态时也会执行。如果这导致意外的行为，其他选项可以是创建一个新的初始状态，初始化所有内容，然后转换到其他状态，或者也许可以创建一个经典的
    Visual Script 图形，在 **On Start** 事件节点中初始化这些变量。
- en: With all this, we learned how to create a decision-making system for our AI
    through FSMs. It will make decisions based on the info gathered via sensors and
    other systems. Now that our FSM states are coded and transition properly, let’s
    make them do something.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一切，我们学习了如何通过有限状态机（FSM）为我们的AI创建决策系统。它将根据通过传感器和其他系统收集的信息做出决策。现在我们的FSM状态已经编码并且过渡正确，让我们让它们做一些事情。
- en: Executing FSM actions
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行有限状态机（FSM）动作
- en: Now we need to complete the last step—make the FSM do something interesting.
    Here, we can do a lot of things such as shoot the base or the player and move
    the enemy toward its target (the base or the player). We will be handling movement
    with the Unity Pathfinding system called `NavMesh`, a tool that allows our AI
    to calculate and traverse paths between two points while avoiding obstacles, which
    needs some preparation to work properly.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要完成最后一步——让FSM做一些有趣的事情。在这里，我们可以做很多事情，比如射击基地或玩家，并将敌人移动到其目标（基地或玩家）处。我们将使用Unity的寻路系统`NavMesh`来处理移动，这是一个允许我们的AI在两点之间计算和遍历路径，同时避开障碍的工具，这需要一些准备才能正常工作。
- en: 'In this section, we will examine the following FSM action concepts:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下有限状态机（FSM）动作概念：
- en: Calculating our scene’s NavMesh
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算场景的`NavMesh`
- en: Using Pathfinding
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用寻路功能
- en: Adding final details
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加最终细节
- en: Let’s start by preparing our scene for movement with Pathfinding.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用寻路功能来为移动场景做准备。
- en: Calculating our scene’s NavMesh
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算场景的`NavMesh`
- en: 'Pathfinding algorithms rely on simplified versions of the scene. Analyzing
    the full geometry of a complex scene is almost impossible to do in real time.
    There are several ways to represent Pathfinding information extracted from a scene,
    such as Graphs and `NavMesh` geometries. Unity uses the latter—a simplified mesh
    similar to a 3D model that spans all areas that Unity determines are walkable.
    In the next screenshot, you can find an example of `NavMesh` generated in a scene,
    that is, the light blue geometry:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 寻路算法依赖于场景的简化版本。分析复杂场景的完整几何形状在实时中几乎是不可能的。有几种方式可以表示从场景中提取的寻路信息，例如图和`NavMesh`几何形状。Unity使用后者——一个简化的网格，类似于3D模型，覆盖了Unity确定的所有可通行区域。在下一张截图，你可以找到一个场景中生成的`NavMesh`示例，即浅蓝色几何形状：
- en: '![](img/B18585_09_54.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_09_54.png)'
- en: 'Figure 9.54: NavMesh of walkable areas in the scene'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.54：场景中可通行区域的NavMesh
- en: Generating `NavMesh` can take from seconds to minutes depending on the size
    of the scene. That’s why Unity’s Pathfinding system calculates the `NavMesh` once
    in the editor, so when we distribute our game, the user will use the pre-generated
    `NavMesh`. Just like Lightmapping, `NavMesh` is baked into a file for later usage.
    Like Lightmapping, the main caveat here is that `NavMesh` objects cannot change
    during runtime. If you destroy or move a floor tile, the AI will still walk over
    that area. The `NavMesh` on top of that didn’t notice the floor isn’t there anymore,
    so you are not able to move or modify those objects in any way. Luckily, in our
    case, we won’t suffer any modification of the scene during runtime, but note that
    there are components such as `NavMeshObstacle` that can help us in those scenarios.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 生成`NavMesh`可能需要从几秒到几分钟，这取决于场景的大小。这就是为什么Unity的寻路系统在编辑器中只计算一次`NavMesh`，这样当我们分发我们的游戏时，用户将使用预先生成的`NavMesh`。就像光照贴图一样，`NavMesh`被烘焙到一个文件中供以后使用。就像光照贴图一样，这里的主要缺点是`NavMesh`对象在运行时不能改变。如果你销毁或移动一个地板砖，AI仍然会走过那个区域。`NavMesh`本身没有注意到地板已经不在了，所以你无法以任何方式移动或修改这些对象。幸运的是，在我们的情况下，我们不会在运行时遭受场景的任何修改，但请注意，有一些组件，如`NavMeshObstacle`，可以帮助我们在那些场景中。
- en: 'To generate `NavMesh` for our scene, do the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要为场景生成`NavMesh`，请执行以下操作：
- en: Select any walkable object and the obstacles on top of it, such as floors, walls,
    and other obstacles, and mark them as **Static**. You might remember that the
    **Static** checkbox also affects Lightmapping, so if you want an Object not to
    be part of Lightmapping but to contribute to the `NavMesh` generation, you can
    click the arrow at the left of the static check and select **Navigation Static**
    only. Try to limit `Navigation Static` GameObjects to only the ones that the enemies
    will actually traverse to increase `NavMesh` generation speed. Making the terrain
    navigable, in our case, will increase the generation time a lot and we will never
    play in that area.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择任何可通行物体及其上面的障碍物，例如地板、墙壁和其他障碍物，并将它们标记为**静态**。你可能记得**静态**复选框也会影响光照贴图，所以如果你想使一个物体不参与光照贴图但要对`NavMesh`生成做出贡献，你可以点击静态检查框左侧的箭头，并仅选择**导航静态**。尽量将`Navigation
    Static` GameObjects限制在敌人实际会穿越的物体上，以增加`NavMesh`生成速度。在我们的案例中，使地形可通行会增加生成时间很多，而且我们永远不会在那个区域玩游戏。
- en: Open the `NavMesh` panel in **Window | AI | Navigation**.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**窗口 | AI | 导航**中打开`NavMesh`面板。
- en: 'Select the **Bake** tab, click on the **Bake** button at the bottom of the
    window, and check the generated `NavMesh`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**烘焙**选项卡，点击窗口底部的**烘焙**按钮，并检查生成的`NavMesh`：
- en: '![](img/B18585_09_55.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_55.png)'
- en: 'Figure 9.55: Generating a NavMesh'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.55：生成NavMesh
- en: And that’s pretty much everything you need to do. Of course, there are lots
    of settings you can fiddle around with, such as **Max Slope**, which indicates
    the maximum angle of slopes the AI will be able to climb, or **Step Height**,
    which will determine whether the AI can climb stairs, connecting the floors between
    the steps in `NavMesh`, but as we have a plain and simple scene, the default settings
    will suffice.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是你需要做的所有事情。当然，还有很多设置你可以调整，例如**最大坡度**，它表示AI能够爬升的最大坡度角度，或者**步高**，它将决定AI是否能够爬楼梯，连接`NavMesh`中楼梯之间的楼层，但鉴于我们的场景简单，默认设置就足够了。
- en: Now, let’s make our AI move around `NavMesh`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们让我们的AI在`NavMesh`周围移动。
- en: Using Pathfinding
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用路径查找
- en: For making an AI object that moves with `NavMesh`, Unity provides the `NavMeshAgent`
    component, which will make our AI stick to `NavMesh`, preventing the object from
    going outside it. It will not only calculate the path to a specified destination
    automatically but also will move the object through the path with the use of Steering
    behavior algorithms that mimic the way a human would move through the path, slowing
    down on corners and turning with interpolations instead of instantaneously. Also,
    this component is capable of evading other `NavMeshAgent GameObjects` running
    in the scene, preventing all of the enemies from collapsing in the same position.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作一个使用`NavMesh`移动的AI对象，Unity提供了`NavMeshAgent`组件，这将使我们的AI粘附在`NavMesh`上，防止物体超出其范围。它不仅会自动计算到指定目的地的路径，还会使用模拟人类移动路径的方式，通过转向行为算法移动物体，在角落减速并使用插值转向，而不是瞬间转向。此外，此组件还能够避开场景中运行的其它`NavMeshAgent
    GameObjects`，防止所有敌人同时聚集在同一位置。
- en: 'Let’s use this powerful component by doing the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤使用这个强大的组件：
- en: 'Select the **Enemy** Prefab and add the `NavMeshAgent` component to it. Add
    it to the root object, the one called `Enemy`, not the AI child—we want the whole
    object to move. You will see a cylinder around the object representing the area
    the object will occupy in `NavMesh`. Note that this isn’t a collider, so it won’t
    be used for physical collisions:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**敌人**预设件，并将其`NavMeshAgent`组件添加到其中。将其添加到根对象，即名为`Enemy`的对象，而不是AI子对象——我们希望整个对象都能移动。你将看到围绕对象的一个圆柱体，表示该对象在`NavMesh`中将占用的区域。请注意，这并不是一个碰撞器，因此它不会被用于物理碰撞：
- en: '![](img/B18585_09_56.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_56.png)'
- en: 'Figure 9.56: The NavMeshAgent component'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.56：NavMeshAgent组件
- en: Remove the `ForwardMovement` component; from now on, we will drive the movement
    of our enemy with `NavMeshAgent`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除`ForwardMovement`组件；从现在起，我们将使用`NavMeshAgent`来驱动敌人的移动。
- en: 'In the `Awake` event function of the `EnemyFSM` script, use the `GetComponentInParent`
    function to cache the reference of `NavMeshAgent`. This will work similarly to
    `GetComponent`—it will look for a component in our `GameObject`, but if the component
    is not there, this version will try to look for that component in all parents.
    Remember to add the `using UnityEngine.AI` line to use the `NavMeshAgent` class
    in this script:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EnemyFSM`脚本的`Awake`事件函数中，使用`GetComponentInParent`函数来缓存`NavMeshAgent`的引用。这将与`GetComponent`类似工作——它将在我们的`GameObject`中查找组件，但如果组件不存在，这个版本将尝试在所有父组件中查找该组件。请记住添加`using
    UnityEngine.AI`行以在脚本中使用`NavMeshAgent`类：
- en: '![](img/B18585_09_57.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_57.png)'
- en: 'Figure 9.57: Caching a parent component reference'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.57：缓存父组件引用
- en: As you can imagine, there is also the `GetComponentInChildren` method, which
    searches components in `GameObject` first and then in all its children if necessary.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，也存在`GetComponentInChildren`方法，它首先在`GameObject`中搜索组件，如果需要，然后在所有子组件中搜索。
- en: 'In the `GoToBase` state function, call the `SetDestination` function of the
    `NavMeshAgent` reference, passing the position of the base object as the target:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GoToBase`状态函数中，调用`NavMeshAgent`引用的`SetDestination`函数，传入基地对象的当前位置作为目标：
- en: '![](img/B18585_09_58.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_58.png)'
- en: 'Figure 9.58: Setting a destination for our AI'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.58：为我们的AI设置目标
- en: Save the script and test this with a few enemies in the scene or with the enemies
    spawned by the waves. You will see the problem where the enemies will never stop
    going toward the target position, entering inside the object, if necessary, even
    if the current state of their FSMs changes when they are near enough. That’s because
    we never tell `NavMeshAgent` to stop, which we can do by setting the `isStopped`
    field of the agent to `true`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本，并在场景中的几个敌人或由波浪生成的敌人上测试此脚本。您将看到问题，即敌人永远不会停止向目标位置移动，如果需要，甚至当他们足够接近时，也会进入对象内部。这是因为我们从未告诉`NavMeshAgent`停止，我们可以通过将代理的`isStopped`字段设置为`true`来实现这一点。
- en: 'You might want to tweak the base attack distance to make the enemy stop a little
    bit closer or further away:'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可能想要调整基础攻击距离，使敌人停止得更近或更远：
- en: '![](img/B18585_09_59.png)'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18585_09_59.png)'
- en: 'Figure 9.59: Stopping agent movement'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.59：停止代理移动
- en: 'We can do the same for `ChasePlayer` and `AttackPlayer`. In `ChasePlayer`,
    we can set the destination of the agent to the player’s position, and in `AttackPlayer`,
    we can stop the movement. In this scenario, Attack Player can go back again to
    `GoToBase` or `ChasePlayer`, so you need to set the `isStopped` agent field to
    `false` in those states or before doing the transition. We will pick the former,
    as that version will cover other states that also stop the agent without extra
    code. We will start with the `GoToBase` state:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以对`ChasePlayer`和`AttackPlayer`做同样的操作。在`ChasePlayer`中，我们可以将代理的目标设置为玩家的位置，而在`AttackPlayer`中，我们可以停止移动。在这种情况下，攻击玩家可以再次回到`GoToBase`或`ChasePlayer`，因此您需要在这些状态中将`isStopped`代理字段设置为`false`或在进行转换之前。我们将选择前者，因为这个版本将涵盖其他不需要额外代码就停止代理的状态。我们将从`GoToBase`状态开始：
- en: '![](img/B18585_09_60.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_60.png)'
- en: 'Figure 9.60: Reactivating the agent'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.60：重新激活代理
- en: 'Then, continue with `ChasePlayer`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，继续使用`ChasePlayer`：
- en: '![](img/B18585_09_61.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_61.png)'
- en: 'Figure 9.61: Reactivating the agent and chasing the player'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.61：重新激活代理并追逐玩家
- en: 'And finally, continue with `AttackPlayer`:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，继续使用`AttackPlayer`：
- en: '![](img/B18585_09_62.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_62.png)'
- en: 'Figure 9.62: Stopping the movement'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.62：停止移动
- en: You can tweak the **Acceleration**, **Speed**, and **Angular Speed** properties
    of `NavMeshAgent` to control how fast the enemy will move. Also, remember to apply
    the changes to the Prefab for the spawned enemies to be affected.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以调整`NavMeshAgent`的**加速度**、**速度**和**角速度**属性来控制敌人移动的速度。同时，请记住将更改应用到生成的敌人的Prefab上，以便受到影响。
- en: 'Regarding the Visual Scripting versions, `GoToBase`will look like the following
    screenshot:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，`GoToBase`将看起来如下截图所示：
- en: '![](img/B18585_09_63.png)Figure 9.63: Making our agent move'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/B18585_09_63.png)图9.63：使我们的代理移动'
- en: We deleted the **OnUpdate** event node printing a message as we don’t need it
    anymore. Also, we called the **Set Destination** node after setting the variable
    if `if` was `null`, and also when the variable wasn’t `null` (**Not Null** pin
    of **Null** Check). Note that all of this happens in the **On Enter State** event,
    so we just need to do it once. We do it every frame in the C# version for simplicity
    but that’s actually not necessary, so we will take advantage of the **OnEnterState**
    event. We can emulate that behavior in the C# version if we want, executing these
    actions at the moment we change the state (inside the `If` statements that check
    the transition conditions), instead of using the **Update** function. Finally,
    notice how we needed to use the **GetParent** node in order to access the `NavMeshAgent`
    component in the enemy’s root object? This is needed because we are currently
    in the **AI** child object instead.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们删除了打印消息的 **OnUpdate** 事件节点，因为我们不再需要它了。此外，我们在设置变量 `if` 为 `null` 后以及变量不是 `null`（**Null**
    检查的 **Not Null** 插针）时调用了 **Set Destination** 节点。请注意，所有这些都在 **On Enter State**
    事件中发生，所以我们只需要做一次。在 C# 版本中，为了简单起见，我们每帧都这样做，但实际上这是不必要的，所以我们将利用 **OnEnterState**
    事件。如果我们想，我们可以在改变状态的时刻（在检查转换条件的 `If` 语句中）执行这些操作，而不是使用 **Update** 函数。最后，注意我们为什么需要使用
    **GetParent** 节点来访问敌人根对象中的 `NavMeshAgent` 组件？这是因为我们目前处于 **AI** 子对象中。
- en: 'Now, the **AttackBase** state will look like this:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，**AttackBase** 状态将如下所示：
- en: '![](img/B18585_09_64.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_64.png)'
- en: 'Figure 9.64: Making our agent stop'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.64：使我们的代理停止
- en: 'The **ChasePlayer** state will look like this:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ChasePlayer** 状态将如下所示：'
- en: '![](img/B18585_09_65.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_65.png)'
- en: 'Figure 9.65: ChasePlayer logic'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.65：ChasePlayer 逻辑
- en: 'And finally, **AttackPlayer** like this:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，**AttackPlayer** 如此：
- en: '![](img/B18585_09_66.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_66.png)'
- en: 'Figure 9.66: AttackPlayer logic'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.66：AttackPlayer 逻辑
- en: Now that we have movement in our enemy, let’s finish the final details of our
    AI.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在我们的敌人中实现了移动，让我们完成我们 AI 的最终细节。
- en: Adding the final details
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加最终细节
- en: 'We have two things missing here: the enemy is not shooting any bullets, and
    it doesn’t have animations. Let’s start with fixing the shooting by doing the
    following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们缺少两件事：敌人没有射击任何子弹，并且它没有动画。让我们从修复射击开始，按照以下步骤操作：
- en: Add a `bulletPrefab` field of the `GameObject` type to our `EnemyFSM` script
    and a `float` field called `fireRate`.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `EnemyFSM` 脚本中添加一个 `GameObject` 类型的 `bulletPrefab` 字段和一个名为 `fireRate` 的
    `float` 字段。
- en: 'Create a function called `Shoot` and call it inside `AttackBase` and `AttackPlayer`:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Shoot` 的函数，并在 `AttackBase` 和 `AttackPlayer` 中调用它：
- en: '![](img/B18585_09_67.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_67.png)'
- en: 'Figure 9.67: Shooting function calls'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.67：射击函数调用
- en: 'In the `Shoot` function, put similar code as that used in the `PlayerShooting`
    script to shoot bullets at a specific fire rate, as in *Figure 9.68*. Remember
    to set the **Enemy** layer in your **Enemy** Prefab, if you didn’t before, to
    prevent the bullet from damaging the enemy itself. You might also want to raise
    the AI GameObject position a little bit to shoot bullets from a position other
    than the ground or, better, add a `shootPoint` transform field and create an empty
    object in the enemy to use as a spawn position. If you do that, consider making
    the empty object not be rotated so the enemy rotation affects the direction of
    the bullet properly:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Shoot` 函数中，放入与 `PlayerShooting` 脚本中用于以特定射击速率射击子弹的类似代码，如 *图 9.68* 所示。记住，如果你的
    **Enemy** 预制件中还没有设置，请设置 **Enemy** 层，以防止子弹伤害到敌人本身。你可能还想稍微提高 AI GameObject 的位置，以便从地面或其他位置射击子弹，更好的方法是添加一个
    `shootPoint` 变换字段，并在敌人中创建一个空对象作为生成位置。如果你这样做，考虑使空对象不旋转，这样敌人的旋转就能正确地影响子弹的方向：
- en: '![](img/B18585_09_68.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_09_68.png)'
- en: 'Figure 9.68: Shoot function code'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.68：Shoot 函数代码
- en: Here, you find some duplicated shooting behavior between `PlayerShooting` and
    `EnemyFSM`. You can fix that by creating a **Weapon** behavior with a function
    called `Shoot` that instantiates bullets and takes into account the fire rate
    and call it inside both components to re-utilize it.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你会在 `PlayerShooting` 和 `EnemyFSM` 之间找到一些重复的射击行为。你可以通过创建一个名为 `Shoot` 的函数的
    **Weapon** 行为来修复它，该函数实例化子弹并考虑射击速率，并在两个组件内部调用它以重新利用它。
- en: 'When the agent is stopped, not only does the movement stop but also the rotation.
    If the player moves while the enemy is being attacked, we still need the enemy
    to face the player to shoot bullets in its direction. We can create a `LookTo`
    function that receives the target position to look at and call it in `AttackPlayer`
    and `AttackBase`, passing the target to shoot at:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当代理停止时，不仅移动停止，旋转也会停止。如果玩家在敌人被攻击时移动，我们仍然需要敌人面对玩家以射击子弹。我们可以创建一个`LookTo`函数，该函数接收要看的靶位并调用它，在`AttackPlayer`和`AttackBase`中调用它，并将射击的目标传递给它：
- en: '![](img/B18585_09_69.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_09_69.png)'
- en: 'Figure 9.69: LookTo function calls'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.69：LookTo函数调用
- en: 'Complete the `LookTo` function by calculating the direction of our parent to
    the target position. We access our parent with `transform.parent` because, remember,
    we are the child AI object—the object that will move is our parent. Then, we set
    the `Y` component of the direction to `0` to prevent the direction from pointing
    upward or downward—we don’t want our enemy to rotate vertically. Finally, we set
    the forward vector of our parent to that direction so it will face the target
    position immediately. You can replace that with interpolation through quaternions
    to have a smoother rotation if you want to, but let’s keep things as simple as
    possible for now:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过计算从父对象到靶位的方向来完成`LookTo`函数。我们通过`transform.parent`访问我们的父对象，因为，记得，我们是子AI对象——将要移动的是我们的父对象。然后，我们将方向的`Y`分量设置为`0`以防止方向向上或向下指——我们不希望我们的敌人垂直旋转。最后，我们将父对象的向前向量设置为该方向，这样它就会立即面对靶位。如果你想有一个更平滑的旋转，你可以用四元数插值来替换它，但现在让我们尽量保持简单：
- en: '![](img/B18585_09_70.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_09_70.png)'
- en: 'Figure 9.70: Looking toward a target'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.70：朝向目标看去
- en: 'Regarding the Visual Scripting version, **AttackBase** actions look like this:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，**AttackBase**动作看起来是这样的：
- en: '![](img/B18585_09_71.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_09_71.png)'
- en: 'Figure 9.71: AttackBase state'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.71：AttackBase状态
- en: In this state, we have some things to highlight. First, we are using the **LookAt**
    node in the **OnEnterState** event node after the **SetStopped** node. As you
    might imagine, this does the same as we did with math in C#. We specify a target
    to look at (our base transform) and then we specify that the **World Up** parameter
    is a vector pointing upwards `0`,`1`,`0`. This will make our object look at the
    base but maintain its up vector pointing to the sky, meaning our object will not
    look at the floor if the target is lower than him. We can use this exact function
    in C# if we want to (`transform.LookAt`); the idea was just to show you all the
    options. Also note that we execute `LookAt` only when the state becomes active—as
    the base doesn’t move, we don’t need to constantly update our orientation.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个状态下，有一些要点需要强调。首先，我们在**SetStopped**节点之后使用**OnEnterState**事件节点中的**LookAt**节点。正如你可能想象的那样，这与我们在C#中使用的数学方法做的是一样的。我们指定一个要看的靶位（我们的基地变换）然后我们指定**World
    Up**参数是一个向上指的向量`0`,`1`,`0`。这将使我们的对象看向基地，但保持其向上向量指向天空，这意味着如果目标低于我们，我们的对象不会看向地面。如果我们想在C#中使用这个函数（`transform.LookAt`），这个想法只是想展示所有选项。此外，请注意，我们只在状态变为活动状态时执行`LookAt`——因为基地不会移动，我们不需要不断更新我们的方向。
- en: The second thing to highlight is that we used coroutines to shoot, the same
    idea we used in the `Enemy Spawner` to constantly spawn enemies. Essentially,
    we make an infinite loop between **Wait For Seconds** and **Instantiate**. We
    took this approach here because it was convenient given it takes fewer nodes in
    Visual Scripting.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个需要强调的是，我们使用了协程来射击，这与我们在`Enemy Spawner`中不断生成敌人的相同思路。本质上，我们在**Wait For Seconds**和**Instantiate**之间创建了一个无限循环。我们采取这种方法是因为在视觉脚本中它更方便，因为它需要的节点更少。
- en: 'Remember to select the **OnEnterState** node and check the **Coroutine** checkbox
    as we did before. Also, we need a new Float type variable called `fireRate` in
    the Enemy’s AI child object:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 记得选择**OnEnterState**节点并检查**Coroutine**复选框，就像我们之前做的那样。此外，我们还需要在敌人的AI子对象中添加一个新的Float类型变量，名为`fireRate`：
- en: '![](img/B18585_09_72.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_09_72.png)'
- en: 'Figure 9.72: Coroutines'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.72：协程
- en: 'Then, **AttackPlayer** will look like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，**AttackPlayer**将看起来像这样：
- en: '![](img/B18585_09_73.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_09_73.png)'
- en: 'Figure 9.73: AttackPlayer state'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.73：AttackPlayer状态
- en: Essentially it is the same as **AttackBase**, but that looks towards the `sensedObject`
    instead toward the player’s base, and we also made the **LookAt** node part of
    the infinite loop, to correct the enemy’s heading before shooting to target the
    player.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上它与**AttackBase**相同，但它关注的是`sensedObject`而不是玩家的基地，我们还把**LookAt**节点作为无限循环的一部分，以便在射击前纠正敌人的航向，以便瞄准玩家。
- en: With that, we have finished all AI behaviors. Of course, these scripts/graphs
    are big enough to deserve some rework and splitting in the future, but with this,
    we have prototyped our AI, and we can test it until we are happy with it, and
    then we can improve this code.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了所有的AI行为。当然，这些脚本/图足够大，值得未来进行一些重构和拆分，但有了这个，我们已经原型化了我们的AI，我们可以测试它，直到我们对它满意，然后我们可以改进这段代码。
- en: Summary
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I’m pretty sure AI is not what you imagined; you are not creating Skynet here,
    but we have accomplished a simple but interesting AI to challenge our players,
    which we can iterate and tweak to tailor to our game’s expected behavior. We saw
    how to gather our surrounding information through sensors to make decisions on
    what action to execute using FSMs and using different Unity systems such as Pathfinding
    to make the AI execute those actions. We used those systems to diagram a State
    Machine capable of detecting the player, running to them, and attacking them,
    and if the player is not there, just going to the base to accomplish its task
    to destroy it.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我很确定AI不是你想象中的样子；你在这里不是在创建Skynet，但我们已经实现了一个简单但有趣的AI来挑战我们的玩家，我们可以迭代和调整它以适应我们游戏预期的行为。我们看到了如何通过传感器收集周围信息来做出决策，决定执行什么动作，我们使用了不同的Unity系统，如寻路系统，使AI执行这些动作。我们使用这些系统来绘制一个能够检测玩家、向他们跑去并攻击他们的状态机，如果玩家不在那里，就只需前往基地完成其任务，摧毁它。
- en: In the next chapter, we are going to start *Part 3* of this book, where we will
    learn about different Unity systems to improve the graphics and audio aspects
    of our game, starting by seeing how we can create materials to modify the aspect
    of our objects and create Shaders with Shader Graph.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始本书的**第三部分**，我们将学习不同的Unity系统来提升我们游戏中的图形和音频效果，首先我们会看到如何创建材质来修改我们物体的外观，以及如何使用Shader
    Graph创建着色器。
