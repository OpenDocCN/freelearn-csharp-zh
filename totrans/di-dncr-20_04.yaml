- en: Dependency Injection in ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](087ee78f-87f2-49ef-bfca-ae04dfa47880.xhtml), *Introducing Dependency
    Injection in .NET Core 2.0*, we were focusing on .NET Core exclusively, analyzing
    the possibilities the platform offers in relation to Dependency Injection and
    distinct ways to implement it. In this chapter, we'll continue analyzing DI, but,
    this time, focusing on the implementation of ASP.NET Core and the possibilities
    offered to the programmer at the time of configuring websites and other related
    functionality which spreads along the whole life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to start with the CLI (command-line tools) and see how to modify
    a console application and turn it into a web app, so you can better understand
    the concept of middleware and the way it's used in ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we will be ready to move onto an analysis of the default templates
    that Visual Studio 2017 offers for ASP.NET Core apps, and the specific features
    linked to DI in those initial models.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll see how to tune up our own services and how to use them via Dependency
    Injection in registration options, controllers, and views.
  prefs: []
  type: TYPE_NORMAL
- en: 'In all, we will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Building ASP .NET Core apps using command-line tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middleware architecture in ASP .NET Core.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the default templates offered by Visual Studio.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Features of DI in ASP.NET applications. Customized services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice the official documentation site uses the same code as the templates offered
    by Visual Studio 2017\. You can find it at [https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/start-mvc](https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/start-mvc).
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core from the command-line tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have installed .NET Core in our boxes and updated (if necessary) to
    version 2.0, we can start a very simple, but explanatory, website from scratch
    using command-line tools and see how we can move from that minimum .NET Core Console
    app to an ASP.NET Core app in a few steps.
  prefs: []
  type: TYPE_NORMAL
- en: This process will help you understand the profound changes in architecture that
    ASP.NET Core carries, and how some of the SOLID principles that we have seen are
    applied in a variety of ways to achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the first step should be to check out our installed version of .NET Core,
    which we can do in a command-line window (remember that Visual Studio 2017 installs
    several links to these windows in the Windows menu, and that the Developer Command
    Prompt already has environment variables defined to suit the main needs of a programmer).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not already have the .NET Core command-line tools installed, remember
    that you can do it in a separate install from the site [https://www.microsoft.com/net/download/core](https://www.microsoft.com/net/download/core)
    in the Command-Line/Other section, which lets you download the installer for all
    versions currently supported. When run, the installer should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b275b9f4-c822-417a-b523-a698ca3f9a57.png)'
  prefs: []
  type: TYPE_IMG
- en: After installation, a new folder should appear at `C:\Program Files\dotnet\sdk`
    named 2.0, (or whichever is the latest version available at the time).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can just check the current version''s details with the `dotnet -version
    and dotnet --info` commands, and see if we have version 2.0 installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f441d89-37a8-487c-a579-975db3284c70.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The window will show some basic commands, such as `--help` and `--version`.
    To check the types of templates available for the latest version, just type `dotnet
    new` (with no extra parameters), and you''ll be presented a list of this kind:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa8e1542-c4ac-4f29-98dd-de37b409f4fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the first time you type that command it will decompress some files
    (it takes a few seconds), to initially populate your local package cache. That
    will only happen once, improving restore speed and enabling offline access.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the minimum possible application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have 11 default types of templates (you can install extra ones from GitHub)
    for as many project types, plus a solution option that creates a `.sln` file including
    the projects inside the depending folders, and distinct options related to configuration
    and Web/ASP.NET solutions.
  prefs: []
  type: TYPE_NORMAL
- en: To test this latest version, inside the Command Prompt, create a new folder,
    move to it, and just type a `dotnet new console` command. This creates two files
    that define the simplest app (console app) for .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: At that moment, you should see a `program.cs` and a `[NameOfDirectory].csproj`
    file, which contains dependency information for your app.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that previous versions used a `project.json` file instead, with the same
    information, but if you open any previous project with V. Studio 2017 it will
    recognize it and migrate it automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The contents of the `.csproj` file, contain a few basic directives in XML format.
  prefs: []
  type: TYPE_NORMAL
- en: To keep working with very basic resources in this initial demo, I'm going to
    use Notepad++ for code coloring and some other editing features.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following content in the `.csproj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0be4c177-7e07-4c2f-ab76-a0d51b1513af.png)'
  prefs: []
  type: TYPE_IMG
- en: As you see, it indicates we're using the .NET SDK, the output is an `exe` file,
    and we're targeting NET Core 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of our `program.cs` file are as expected (no changes from a typical
    Console application, in a classical .NET Framework):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: But, still, we need to download the dependencies, a task that is performed using
    a `dotnet restore` command previous to any other options. After issuing that command,
    you'll see how it downloads all required packages, and a new `obj` directory shows
    up.
  prefs: []
  type: TYPE_NORMAL
- en: And that's it. You can finally issue the `dotnet run` command, which, in turn,
    compiles and executes the app, showing the expected message in the console (nothing
    new, I omited the output).
  prefs: []
  type: TYPE_NORMAL
- en: Changing to ASP .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, to change our application into an ASP.NET Core app, the first thing to
    do is to install the package called `Microsoft.AspNetCore`. We can do this by
    issuing the `dotnet add package Microsoft.AspNetCore` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we do that, the command-line tool will download the appropriate package
    and modify our `.csproj` accordingly, so it is included in our solution as well
    (see the new version of `csproj` after issuing the command):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef2bb94e-08b9-42aa-8ff6-3a586b085d2f.png)'
  prefs: []
  type: TYPE_IMG
- en: We see the presence of a new `<ItemGroup>` tag, indicating the reference to
    include and the version that has been downloaded and added to the project.
  prefs: []
  type: TYPE_NORMAL
- en: We're now ready to create our web starting now that will take the form of a
    class named `Startup.cs` (of course you can name it as you want as long as you
    configure it later. It's not a convention name).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside that file, we''ll reference the three extra namespaces required to create
    a website (although a basic one):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft.AspNetCore.Builder`: To actually build a web server using the `config`
    parameters we''ve defined'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.AspNetCore.Hosting`: To hold the web application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.AspNetCore.Http`: For all HTTP-related activities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With those references, we need to add a method named `Configure` (and this is
    by convention), where we will indicate the minimum actions to perform when the
    server is launched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will start seeing DI in action, because the shape of this very basic
    method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: But, before we start explaining the inner details of that file, let's make sure
    it compiles correctly and that we redirect our application to the new website.
  prefs: []
  type: TYPE_NORMAL
- en: So, we will issue another `dotnet restore` command, so all new references are
    located properly, and the next step will be to modify our main entry point, to
    create a new web host that uses the `Startup` class just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that purpose, the new `Main()` entry point will use a reference to `Microsoft.AspNetCore.Hosting`
    namespace, and define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can repeat the `dotnet run` command and we will see two different
    outputs. On one side, the CLI environment, we will generate a web host and run
    it (by default, using port number `5000`), indicating that in the console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af29f757-4ed4-4201-85d3-1a87a2859dea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That host will keep on running and listen on that port until we stop it using
    *Ctrl* + *C*. Now, we can open a browser and type the URL to see the following
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e08ab7b6-8bbb-41a9-b255-a85a7d515ce5.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, that page doesn't contain any HTML, only the text we order the server
    to send back to the user when a request is received on that port. Just take a
    look at the source code if you want to check this out.
  prefs: []
  type: TYPE_NORMAL
- en: But, before we continue the explanation of the previous code, it's important
    to understand the concept of Middleware, present from the beginning in ASP.NET
    Core.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, middleware refers to software, but to a software that is assembled
    using an application pipeline in a manner that facilitates handling requests and
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, you may wonder what an application pipeline is. Wikipedia defines
    the terms like this: "*In software engineering, a pipeline consists of a chain
    of processing elements (processes, threads, coroutines, functions, etc.), arranged
    so that the output of each element is the input of the next; the name is by analogy
    to a physical pipeline*".'
  prefs: []
  type: TYPE_NORMAL
- en: These pipelines are common in many software languages, even in modern constructions
    as in JavaScript Promises, which define asynchronous pipelines for a sequence
    of calls, improving execution control.
  prefs: []
  type: TYPE_NORMAL
- en: One important feature of pipelines is that each component of the pipeline can
    decide whether it passes information to the next component or returns directly,
    and has the ability to perform custom actions before and after that component
    is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: In ASP.NET Core, to build a request pipeline, we use delegates to handle each
    request. And, again, we find some of the SOLID principles present in this architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Every time you need to configure one of these delegates, you use one method
    belonging to the method's families called `Use*`, `Run*` and `Map*` (they are
    sets of predefined extension methods starting with these prefixes, each one with
    a specific purpose).
  prefs: []
  type: TYPE_NORMAL
- en: 'These methods are linked to the `IApplicationBuilder` object that the `Configure`
    method receives via Dependency Injection. The following schema visually explains
    this structure (notice that the thread of execution follows the black arrows):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e904ea53-abd1-4178-941b-77b86fa9fec2.png)'
  prefs: []
  type: TYPE_IMG
- en: In this manner, it's totally up to the programmer to keep on passing the `IApplicationBuilder`
    object to another middleware piece (notice the call to `next()`) or avoid any
    other call, in which case it returns to the calling method.
  prefs: []
  type: TYPE_NORMAL
- en: If one of these delegates decides not to pass a request to the next delegate,
    that's called **short-circuiting** the request pipeline. This is often convenient
    to avoid having to perform any unnecessary work.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of exception handling delegates, they need to be called early in
    the pipeline, to allow them to catch exceptions that might occur later in the
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go now for the explanation of the previous code with all this in mind.
  prefs: []
  type: TYPE_NORMAL
- en: The Startup class and Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Startup` class coded previously is, therefore, the component in charge
    of configuring the request pipeline and handling all requests made to the application.
  prefs: []
  type: TYPE_NORMAL
- en: This class is mandatory (although, as mentioned, it could be named differently)
    because the runtime will look inside it for the methods that take care of configuration
    aspects, and that includes services as well. You can consider it as a convenient
    way to achieve independent configurations via the first SOLID principle (SoC).
  prefs: []
  type: TYPE_NORMAL
- en: One of the interesting features linked to this separation of responsibility
    is that you can define distinct **Startup** classes depending on the environment
    (development, production, and so on). The appropriate one will be selected at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: This class is defined in such a way that accepts dependencies provided via Dependency
    Injection, as well. For instance, you can declare variables of types `IHostingEnvironment`
    or `ILoggerFactory` to gain the ability to configure diverse functionality related
    to hosting or logging (remember in, Chapter 3, *Introducing Dependency Injection
    in .Net Core 2.0*).
  prefs: []
  type: TYPE_NORMAL
- en: So, what is mandatory in this class and what is optional? The `Configure` method
    is mandatory. No matter what the name of the class, the runtime will look for
    it inside and call it to make sure the required conditions apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the `ConfigureServices()` method is optional, but if it is present,
    it will be called prior to `Configure()` during that initial process. The following
    schema illustrates this sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c606338c-ce7b-447d-8d4c-ad99ecd6ffad.png)'
  prefs: []
  type: TYPE_IMG
- en: '(Image courtesy: [http://developer.telerik.com/featured/understanding-asp-net-core-initialization/](http://developer.telerik.com/featured/understanding-asp-net-core-initialization/))'
  prefs: []
  type: TYPE_NORMAL
- en: Before going any further in demos, let's explain the previous code in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Code explanation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with the `Main()` method, after a reference to the `Hosting` subspace
    that we mentioned previously, we build a new web server by calling the `WebHostBuilder`
    class. This class permits configuration and building of a web server using various
    middleware pieces and entry point conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, after calling the constructor, we piped another three calls:'
  prefs: []
  type: TYPE_NORMAL
- en: One to `UseKestrel()`, which is the default, light-weight server for development
    that Visual Studio 2017 (and the CLI) uses (we'll explain that in a while)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another call to `UseStartup<Startup>()`, to indicate where the server will find
    the `Configure()` method to initiate its process (remember the name of the class
    is irrelevant, as far as it contains the method `Kestrel` looks for initially)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, finally, another one to `Build()`, which creates and initializes the new
    server with those previous values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all that in place, that last sentence simply calls the `Run()` method to
    launch the process.
  prefs: []
  type: TYPE_NORMAL
- en: When launching that process, the `Configure` method turns on. Its only parameter
    (in this case), is of type `IApplicationBuilder`, and, as you see, is served to
    this method by Dependency Injection (no previous references or instantiation were
    made by our code).
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, when a server is created, the main, basic objects implied in the
    communication process are served in this manner, expecting from the user all required
    behaviors in the form of subsequent calls to its methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s pretty self-explanatory if we take a look at the interface definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa04f5a6-c91e-46c7-844a-ad9e9c73504a.png)'
  prefs: []
  type: TYPE_IMG
- en: By the time the `Configure` method receives an instance of the `IApplicationBuilder`
    class, a bunch of extra functionality is available. As mentioned previously, it
    has been made available via extension methods, adopting the form of `Use*`, `Run*`,
    and `Map*` methods, which help the programmer in coding configuration aspects
    and obtaining more independence and granularity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how the following screenshot shows different configuration options and
    suggests the use of middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e14830b-65c3-4608-afee-98d832519948.png)'
  prefs: []
  type: TYPE_IMG
- en: Each of these extension methods supplies a way to call the implied delegate.
    Notice that while the `Use*` family of methods calls `Next()` implicitly many
    times to keep on going in the pipeline (actually it depends on other features),
    the `Run*` family stops the propagation and short-circuits the pipeline (therefore,
    it doesn't call a next request delegate).
  prefs: []
  type: TYPE_NORMAL
- en: Also, the `Map*` family allows branching the pipeline, making calls that return
    to that point and extending functionality accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The New ASP.NET servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's quickly review some important aspects of the servers used when programming
    for ASP.NET Core since that is one of the main changes linked to this new platform.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, an ASP.NET Core application runs an in-process HTTP server implementation.
    That implementation is listening for HTTP requests and sends those requests to
    the application wrapped in an object named `HttpContext` that holds a set of features
    composed into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This version of ASP.NET provides two distinct server implementations: `Kestrel`
    and `WebListener`. As the official documentation reminds us:'
  prefs: []
  type: TYPE_NORMAL
- en: Kestrel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Kestrel` is a cross-platform HTTP server based on `libuv`, a cross-platform
    asynchronous I/O library:'
  prefs: []
  type: TYPE_NORMAL
- en: '`libuv` is defined as a multi-platform support library with a focus on asynchronous
    I/O. It was primarily developed for use by Node.js, but it''s also used by Luvit,
    Julia, pyuv, and others.'
  prefs: []
  type: TYPE_NORMAL
- en: Kestrel is the web server included by default in the ASP.NET Project templates.
    The advantage is that if your application accepts requests exclusively from an
    internal network, it can be used by itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the working scheme of a default scenario with Kestrel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eda9b927-3790-45fd-b410-dad0faef0c7a.png)'
  prefs: []
  type: TYPE_IMG
- en: '(Image courtesy: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/))'
  prefs: []
  type: TYPE_NORMAL
- en: However, if you expose the application to the internet, there are some security
    issues for which Kestrel is not prepared to cope (it's relatively new and still
    doesn't have the whole required set of defense resources). For those cases, the
    recommended configuration is to use a reverse proxy server, such as IIS, Apache,
    or Nginx, to provide functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that a reverse proxy server, as the documentation states, *receives
    HTTP requests from the Internet and forwards them to Kestrel after some preliminary
    handling* (see the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcbed41a-719b-4b2f-a69e-ef755a25a391.png)'
  prefs: []
  type: TYPE_IMG
- en: '(Image courtesy: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/))'
  prefs: []
  type: TYPE_NORMAL
- en: Another important point is that you can't use any of those reverse proxy servers
    without Kestrel or a custom server implementation. This is because ASP.NET Core
    was designed to run in its own process so it can behave consistently across platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The problem that we might face here is that IIS, Nginx, and Apache prescribe
    their own startup process and environment. The consequence is that to use them
    directly it should adapt to the requirements of each one.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, Kestrel gives ASP.NET Core the ability to code `Program` and `Startup`
    classes in any required form to suit the user's needs, while avoiding another
    dependency on a concrete, specific server. That's one of the reasons why middleware
    is so important in this context.
  prefs: []
  type: TYPE_NORMAL
- en: WebListener
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`WebListener` is a Windows-only HTTP server based on the `Http.Sys` kernel
    driver. It serves as an alternative for those scenarios where exposing our app
    to the internet is mandatory, but we don''t wish to use IIS if we cannot do it
    for some reason.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following schema represents the role of WebListener in a similar scenario
    as the one presented previously with Kestrel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4bb5714-625b-4f2c-ad9f-25e870db28dd.png)'
  prefs: []
  type: TYPE_IMG
- en: '(Image courtesy: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/))'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way, if you need some of the features that Kestrel doesn''t support
    while working on an internal network, you could use WebListener in a quite comparable
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7796eaba-9226-486a-822e-513f4c0a8157.png)'
  prefs: []
  type: TYPE_IMG
- en: '(Image courtesy: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/))'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, keep in mind that for internal network scenarios, Kestrel is recommended
    because it provides improved performance. In any case, if you want to know more
    about the features provided by WebListener, the official documentation is available
    at [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/weblistener](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/weblistener).
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Inversion in the architecture - OWIN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's also possible to create your own server implementation to work with ASP.NET
    Core. **Open Web Interface for .NET** (**OWIN**) is the third possible implementation
    supported by the platform.
  prefs: []
  type: TYPE_NORMAL
- en: In some ways, the implementation of OWIN also relates to the Dependency Inversion
    Principle. Its main goal is to make web applications decoupled from web servers.
  prefs: []
  type: TYPE_NORMAL
- en: With that purpose, it defines standard ways to create middleware that can be
    used in the pipeline, to configure and tune your server.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the default template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to open Visual Studio 2017 (or 2015, with ASP.NET Core installed)
    and take a look at it and explain how the default templates behave.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that ASP.NET Core can execute using the classical.NET Framework as
    well, so, when you create a new Web project you''ll be asked, initially, to choose
    between three main options: classical ASP.NET, ASP.NET Core with NET Core, and
    ASP.NET Core with classical .NET Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5a62e2e-b436-405f-b72b-1ded0e64ec91.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once selected, you''ll be offered another choice window: Empty, Web API, Web
    Application, Web Application (Model-View-Controller), and some new options added
    to version 2.0 for third-party libraries, which include Angular, React.js, and
    React.js and Redux.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, the one we're using now creates an application with the minimum
    configuration to be able to create and run a web server using Kestrel and present
    some text in the browser. It's simple, but it allows us to check out how it is
    done with more detail and to make some changes.
  prefs: []
  type: TYPE_NORMAL
- en: The other three (Web API, Web Application, and Web App MVC) remind their counterpart
    in classic ASP.NET, with the difference that they use the new architecture and
    configuration files. In this manner, we'll be able to better appreciate the migration
    process needed to pass from the old architecture to the new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following dialog box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed226be6-21c8-4aae-b66f-e4f0e56055a2.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that you can also change authentication as in previous versions and that
    you have a checkbox that allows enabling Docker support.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting project is a bit more complex than the basic demo we did previously,
    although the basic pieces are the same. However, there are some noticeable changes
    in configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you compile the application and activate the See all files option in the
    Solution Explorer, you'll notice some extra configuration files that take care
    of a few tasks, such as launching the browser on the default URL. These options
    are defined inside the `launchSettings.json` file available inside the `Properties`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'A look at it is also quite explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, three main areas of configuration apply here: `iisSettings`, to
    indicate IIS behavior, including the URL to use, a `profiles` section that only
    contains one profile for `IISExpress`, indicating that a browser should be launched
    and a hint on the development mode, and a final one under the name of the application
    itself (`ASPNETCoreDemo1`), with similar information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, if you dig into the `\bin` or `\obj` directories, you''ll see some
    more, such as `ASPNETCoreDemo1.runtimeconfig.json` with extra information. And,
    finally, if you examine the .`csproj` you''ll see some additions as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that on the project's context menu option at the Solution Explorer
    you now have an option that allows you to open it directly in Visual Studio 2017.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Not many changes, but now it indicates the use of the `wwwroot` folder and it
    adds the `ApplicationInsights` call. And, obviously, there's no indication of
    filetype, since, by default, the compiled assembly is a DLL.
  prefs: []
  type: TYPE_NORMAL
- en: The Entry Point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with `program.cs`. Its `main()` method is similar, but it contains
    new middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The three main differences are: `UseContentRoot()`, `UseIISIntegration()`,
    and `UseApplicationInsights()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`UseContentRoot(Directory.GetCurrentDirectory())`, indicates that whenever
    the user requests a physical resource, that''s the directory to search in. By
    default, it''s going to point to the `wwwroot` directory.'
  prefs: []
  type: TYPE_NORMAL
- en: '`UseIISIntegration()` is there to indicate that IIS will be used as a reverse
    proxy (as we mentioned previously), and finally, `UseApplicationInsights()` helps
    monitor and audit your application.'
  prefs: []
  type: TYPE_NORMAL
- en: As the official documentation states ([https://github.com/Microsoft/ApplicationInsights-aspnetcore/wiki/Getting-Started-with-Application-Insights-for-ASP.NET-Core](https://github.com/Microsoft/ApplicationInsights-aspnetcore/wiki/Getting-Started-with-Application-Insights-for-ASP.NET-Core))
    it allows us to *Monitor your live ASP.NET Core applications with Visual Studio
    Application Insights. Application Insights is an extensible analytics platform
    that monitors the performance and usage of your live web applications. With the
    feedback you get about the performance and effectiveness of your app in the wild,
    you can make informed choices about the direction of the design in each development
    lifecycle.*
  prefs: []
  type: TYPE_NORMAL
- en: So, we have an entry point reinforced with new middleware, and thus, we can
    use DI from the start. Let's see what it's done in the `Startup` class (the configuration).
  prefs: []
  type: TYPE_NORMAL
- en: The default Startup class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first point to notice is the presence of `ConfigureServices` (even if it's
    empty). As you can see in the following screenshot, it allows adding distinct
    services to our pipeline, storing them in the `services` collection. This will
    be the place to register our own services as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also notice that some of these methods are ready to add services with distinct
    lifetime configuration (`AddSingleton`, `AddScoped`, and `AddTransient`). Later,
    we''ll see how to add services at this point to allow applications to use a given
    functionality, such as Database Access, and so on, using this `IServiceCollection`
    object that it received through Dependency Injection (see the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d92032f-eea0-49fc-804b-c8bf0531f737.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As for the `Configure()` method, this time it receives (via Dependency Injection,
    of course), three instances of types `IApplicationBuilder`, `IHostingEnvironment`,
    and `ILoggerFactory` as the following code shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first one is used at the end to launch the application, only this time using
    the `async/await` structure to guarantee a formal asynchronous call, returning
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: '`ILoggerFactory` is used in a similar manner as we did in Chapter 3, *Introducing
    Dependency Injection in .NET Core 2.0*, to configure messages that will be output
    to the console.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `IHostingEnvironment` variable is used to check if the application
    is in development mode, and, in that case, to configure a developer exception
    page, which we can define elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core distinguishes four possible development modes: `development`,
    `production`, `staging`, and a fourth one `environment` that allows defining your
    own. That value is configurable inside the `Project/Properties/Debug` window,
    where you can now add distinct environment variables, as you can see in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67749781-f661-4470-910e-e6817c4b0d8c.png)'
  prefs: []
  type: TYPE_IMG
- en: These values are read by the `IHostingEnvironment` object allowing the insertion
    of actions prior to the application launching process. Notice it's not a single
    value, but a collection, so you can add as many environment values as needed and
    use this object's methods to read whether some of them are true.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also use something like `ASPNETCORE_ENVIRONMENT"="MyCompany` to define
    your own and check this value easily, using the `IsEnvironment()` method, as you
    can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9d6845f-e431-40aa-b5e7-8af821d6c4da.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, if we change the previous `development` value for a customized one, such
    as `PACKT`, we can modify the exit in the browser with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be different in this case, so we''re free to configure anything
    and mix it with other values to have a totally customized, mode-dependent, experience:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/029c6027-b9b3-4666-aeb9-0b9ebc5ec85e.png)'
  prefs: []
  type: TYPE_IMG
- en: But, there's much more in relation to DI, as we're going to see in the next
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection in ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of course, this behavior is possible thanks to the presence of a DI Container
    inside the ASP.NET Core engine. The official documentation states it very clearly:
    *if a given type has declared that it has dependencies, and the container has
    been configured to provide the dependency types, it will create the dependencies
    as part of creating the requested instance*.'
  prefs: []
  type: TYPE_NORMAL
- en: The container, in this way, manages an object's lifetime and avoids the need
    for hard-coded object construction.
  prefs: []
  type: TYPE_NORMAL
- en: Besides other built-in implementations, remember that ASP.NET Core provides
    a simple DI Container (that we already tested in Chapter 3, *Introducing Dependency
    Injection in .Net Core 2.0*), represented by the `IServiceProvider` interface.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned, the place to configure services using that interface in this
    platform is the `ConfigureServices` method, which we will analyze in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Services provided by ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s quite a large list of services available inside ASP.NET Core via Dependency
    Injection. The following table shows these services together with an indication
    of its lifetime:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Service Type** | **Lifetime** |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.AspNetCore.Hosting.IHostingEnvironment` | Singleton |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.Extensions.Logging.ILoggerFactory` | Singleton |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.Extensions.Logging.ILogger<T>` | Singleton |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.AspNetCore.Hosting.Builder.IApplicationBuilderFactory` | Transient
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.AspNetCore.Http.IHttpContextFactory` | Transient |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.Extensions.Options.IOptions<T>` | Singleton |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Diagnostics.DiagnosticSource` | Singleton |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Diagnostics.DiagnosticListener` | Singleton |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.AspNetCore.Hosting.IStartupFilter` | Transient |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.Extensions.ObjectPool.ObjectPoolProvider` | Singleton |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.Extensions.Options.IConfigureOptions<T>` | Transient |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.AspNetCore.Hosting.Server.IServer` | Singleton |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.AspNetCore.Hosting.IStartup` | Singleton |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.AspNetCore.Hosting.IApplicationLifetime` | Singleton |'
  prefs: []
  type: TYPE_TB
- en: As you see, this is a pretty comprehensive list of choices, to which we have
    to add the functionality already available and "installable" via `Run*`, `Use*`,
    and `Map*` methods commented on previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can distinguish two flavors of method, here: those already available
    and ready to include at will (the ones shown in `Program/Main`), and those that
    you can customize (using the `Startup` class), either by addition or by creating
    your own classes and interfaces and adding them to the `ConfigureServices` initial
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: The relation of services available at startup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In summary, we have several ways to include functionality via Dependency Injection
    in ASP.NET Core 2.0, via the Startup class:'
  prefs: []
  type: TYPE_NORMAL
- en: By creating your own constructor for the Startup class, which refers to a previously
    define map Interface => Class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By referring to the service required in the `ConfigureServices` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using the `Configure()` method in the ways we've seen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you consider the methods of `Startup` in the order they are executed, the
    following services are at your disposal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor: `IHostingEnvironment`, `ILoggerFactory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`* ConfigureServices`: `IServiceCollection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configure: `IApplicationBuilder`, `IHostingEnvironment`, `ILoggerFactory`,
    `IApplicationLifetime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying Services in the Web Application template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Web Application template is much more revealing regarding the use of services
    and the role of Dependency Injection, so we're going to create a project equivalent
    to the classic ASP.NET MVC 5 available for a classic .NET Framework so we can
    compare both, identifying this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you create one of these new projects, you''ll probably identify many of
    the elements that were present in the previous version: folders for controllers
    and views, Razor files defining the distinct views in the application, and so
    on.'
  prefs: []
  type: TYPE_NORMAL
- en: But, now that we've seen some of the main changes, a review of the critical
    files is quite enlightening. There are no changes in `Program/Main`, but we'll
    find a lot in the `Startup` class. The references (`using` statements) are the
    same as in the basic demo, so I'm omitting the code here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most interesting come inside the `Startup` class itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Up to this point, the default template only initializes the MVC engine, considering
    it an extra service, totally optional to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further on, we''ll see how to use this method to register and configure other
    built-in or customized services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we now have a constructor and a read-only private property (`Configuration`)
    of type `IConfigurationRoot`. Well, it happens that the `builder.Build()` method
    called at the end of the constructor, is of this type and provides a convenient
    way to include and access all configuration information loaded from several `.json`
    files in the distinct application's folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that information is collected at the very beginning of the process of initialization,
    so whatever has to be read from the outside is ready before `ConfigureServices`
    and `Configure` come into play (see the following screenshot showing the value
    of `Configuration` after loading):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/973d5311-1183-457c-ad0f-8d1af9f5db9f.png)'
  prefs: []
  type: TYPE_IMG
- en: As you see, the `ConfigurationBuilder` class is created in the first sentence
    of the constructor, and takes care of loading and reading the content of all these
    .`json` files, and adding environment variables. This allows further access to
    any `json`-defined value, and the ability to tune-up the application with external
    information.
  prefs: []
  type: TYPE_NORMAL
- en: With all that info collected, the `ConfigureServices` method comes and registers
    a set of services, such as MVC, by adding a `UseMvc` call (yes, it's not available
    by default, and has to be explicitly added to the pipeline if we want to use that
    architecture).
  prefs: []
  type: TYPE_NORMAL
- en: As you've seen along these samples, this ASP.NET middleware, such as MVC, follows
    a convention of using a single `Add*ServiceName*` extension method to register
    all of the services required by that feature. Also, notice that this call only
    adds the service to the collection of services, but it does not configure it (that
    comes later).
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `Configure()` method comes in. It first recovers information from
    the `Configuration` object (`Logging` section) and adds debugging capabilities
    in the way we saw in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It follows with error handling, by checking if we are in development mode or
    another one (it also enables `BrowserLink` capabilities), and goes on with a call
    to `UseStaticFiles()`, to allow recovering and serving local files (you guessed
    it, it's not available by default, either).
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that this feature can be configured to point someplace else (relative
    request path) on the server (see the screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c44a65c-ad4a-4160-8695-e06c9ca28e45.png)'
  prefs: []
  type: TYPE_IMG
- en: The last step is configuring MVC routes with a call to `UseMvc()`, in which
    the route's configuration is provided. Notice how different this approach is in
    comparison to classical ASP.NET MVC 4/5, in which you would register these routes
    in a different file. However, the syntax is similar, only this time you define
    it via lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can deduct from the code, the first lambda argument is given by Dependency
    Injection and it''s of type `IRootBuilder`. Take a look at the Intellisense information
    provided by the IDE to check this feature, which is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af2577e7-c2ee-40f8-a2ee-8d4ffc87c0b9.png)'
  prefs: []
  type: TYPE_IMG
- en: The default route is then configured to point to the `HomeController` class
    and the `Index` action method if no other combination is supplied by the request
    (the syntax has also been a bit simplified).
  prefs: []
  type: TYPE_NORMAL
- en: So, our conclusion after this trip through the `Startup` class is that the most
    important architectural aspects of ASP.NET Core and its MVC variant are provided
    via Dependency Injection, and that it is the developer's duty to tune up their
    application in this manner having the ability to include/exclude only those pieces
    that are needed by the application, with the minimum overload.
  prefs: []
  type: TYPE_NORMAL
- en: Using Dependency Injection in ASP.NET MVC Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Steve Smith proposes a demo ([http://ardalis.com/how-to-list-all-services-available-to-an-asp-net-core-app](http://ardalis.com/how-to-list-all-services-available-to-an-asp-net-core-app))
    that can clarify the total of services available at a given moment.
  prefs: []
  type: TYPE_NORMAL
- en: This gave me an idea for another demo about how to include the namespace `Microsoft.Extensions.DependencyInjection`
    inside a view, using MVC to obtain a list of all services available. So let's
    start with the default template we just analyzed, and make the proper modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, if we want to integrate the list as a new option inside the main menu
    of the Web Application template, we need to add a new link inside the `_Layout.cshtml`
    file that points to the corresponding view that will show all our services. That''s
    quite straightforward (notice that there''s no `ActionLinks` here as in the previous
    version):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e975755-6c3a-42ad-8fae-71d1dd60d6cf.png)'
  prefs: []
  type: TYPE_IMG
- en: With this new line, we're creating a new application menu element and the corresponding
    view (later named `ServicesAvailable`) will take advantage of Bootstrap classes
    loaded in the `_Layout.cshtml` header, to format the output and make it more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we think about the controller (`HomeController` in this case), we can
    add a new action method, following the syntax of the other methods, using the
    `ViewData` object to pass the required information to our new view.
  prefs: []
  type: TYPE_NORMAL
- en: The information we need is stored in the instance of the `IServiceCollection`
    object defined inside `Startup.cs`, and we want to make it available for the controller
    so we can later assign it to our `ViewData` messenger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s revisit the `Startup`, and make a few changes (not many). Actually,
    only these are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We create a public static variable (`_services`) to hold all services once they
    have been configured and assign the `services` variable to it with the sole purpose
    of accessing its content from the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back to the `HomeController`, we can add a new controller with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With these few lines, our services are now available inside the controller,
    and we can pass them to the view in a very simple way (notice there's no data
    model here since it's just a simple collection of data and the `ViewData` object
    serves just fine for this purpose).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last step will be to add the `ServicesAvailable` view. The code
    will be the following (I''ll start with the header''s explanation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: First, recall that when we make a reference to a namespace inside a view, the
    `using` sentence shall not belong to a block of code. Instead, it will be a standalone
    sentence headed by the `@` sign (we need the `DependencyInjection` namespace to
    cast the information passed inside the `ViewData` object into a real `IServiceCollection`
    object).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we recover that info inside a variable (that will be available locally
    in the whole view). Observe that I'm using the `var` keyword instead of the interface
    name because otherwise the compiler will complain. It's easier to do it this way
    and make the casting later in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll use a table to present some information hold in three of the
    services of `IServiceCollection` (called `_services` in the view). Notice also
    the casting is made here with the `as` operator to get a real `IServiceCollection`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And that''s all! Now we can launch the application and select the new menu
    element *List of Services*. A new view will show up containing a, pretty long
    list of services available in this architecture, showing at the same time how
    we can make use of the `DependencyInjection` namespace (or any other) inside a
    view (see the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a075f92c-562f-47fe-8bcb-068821d7d668.png)'
  prefs: []
  type: TYPE_IMG
- en: Garbage Collection and Custom Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In relation to Garbage Collection behavior, ASP.NET MVC automates some operations
    and leaves others to the user's discretion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main rule is as follows: if you register a service and call its constructor
    inside the process, it''s your obligation to dispose of that object, otherwise
    if the container is in charge of creating the object, it will call `Dispose()`
    on any object it implements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, imagine we have a couple of services (`Service1` and `Service2`)
    located in a folder (`Services`), and that both implement the `Disposable` interface.
    To simplify this part, I collapsed the code, so I''m just showing the relevant
    lines to understand this idea (see the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1359a310-8963-41da-ae98-a8389a0eb133.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The behavior will be different depending on the instantiation of each service
    (I''ve commented on each case so you''ll see the difference):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In all, it is a pretty convenient way to manage garbage collection of services.
  prefs: []
  type: TYPE_NORMAL
- en: Using Custom Services through Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this architecture, it is very easy to create any class belonging to our
    data model, or any other part of the application, and have it ready and available
    for Dependency Injection, with all the advantages linked to it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine that we want some adornment in one of our views in the
    form of a random sentence (about programmers and software engineers, for instance),
    and that we would like the classes that hold the information to be treated as
    a service, via Dependency Injection, so we can use that content in distinct application's
    views.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rename the classes used in the previous sample as `ProgrammerSentenceSvc`
    and `EngineerSentenceSvc` and add some very simple information: a `List<string>`
    of sentences that will be used later inside our controller to randomly retrieve
    a couple of these sentences and pass them to the corresponding view.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s modify our services to hold the required information (I''m just showing
    these captures, to focus on the relevant code):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6432441-aa7a-425b-ab22-2004c42d6e48.png)![](img/0fbe71e2-7b9f-4116-bf79-1334804b7ca8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step will be to register these classes in the `Startup` class via
    `ConfigureServices`, as we''ve seen before (I''m using two distinct syntaxes just
    to show):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all we need to have our services available inside any controller. So,
    let''s revisit our `HomeController`, and add the following action method (remember
    that we have to make a reference to our Services namespace, via `using ASPNETCoreDisposeDemo.Services;`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! Any service registered in that manner is automatically available
    inside a controller via Dependency Injection, merely by making a reference to
    it as a parameter of the corresponding action method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to create the view named `Sentences` to recover the information
    and present it to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have added (just like before), a new link next to the default menu pointing
    to the name of this action method, we''ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/995a1979-bb06-4548-8fc9-ea56097b31b8.png)'
  prefs: []
  type: TYPE_IMG
- en: As you see, the output is the expected one, and the general architecture of
    the application with respect to the MVC model is quite similar to previous versions.
  prefs: []
  type: TYPE_NORMAL
- en: Services and data management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although data management is not the target of this book, I'd like to mention
    that the architecture proposed when accessing data inside ASP.NET Core MVC applications
    is relatively alike.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this feature and highlight those parts directly related to Dependency
    Injection, follow the initial instructions at [https://docs.microsoft.com/en-us/ef/core/get-started/aspnetcore/existing-db](https://docs.microsoft.com/en-us/ef/core/get-started/aspnetcore/existing-db).
    That creates a very simple database using SQLLocalDb called `Blogging`. It creates
    a `Blogs` table and adds three registers, just to have some data to work with.
    You''ll also find a link to the complete sample it proposes using several approaches:
    Database First, New Database, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: What I would like to point out here is those fragments of code that imply the
    use of DI inside that solution.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Models'` application folder you'll find the definition of the model
    based on that database in a similar way to the usual result when you scaffold
    an existing database using classic Entity Framework. The main class inherits from
    `DbContext`, defines public virtual properties pointing to the existing entities,
    and names the `DBContext` instance `BloggingContext`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, the first step is to register that context inside the `ConfigureServices`
    method, for which it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58d934a3-79f8-442f-9b63-1cfd15f74918.png)'
  prefs: []
  type: TYPE_IMG
- en: As you see, the connection string is defined directly so that it points to the
    newly created database (`Blogging`).
  prefs: []
  type: TYPE_NORMAL
- en: Next, the services variable is populated with a new entry via the generic method
    `AddDbContext<BlogginContext>.` And, to link that `DbContext` to the `Blogging`
    database and `Action` delegate is passed to the method, allowing it to override
    the `OnConfiguring` method of the `BloggingContext` class. In this manner, the
    real connection configuration can be delayed until this method is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, how does the `BloggingController` class access this `BloggingContext`?
    By Dependency Injection in its constructor. It operates in a similar way to what
    we did in the previous sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9857b83-0a7e-46c5-a34b-3f7a5a705364.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The output shows the three entries loaded in the `Blogs` table, just as expected,
    with the typical CRUD options, presenting the information via Razor views, but
    it''s interesting to highlight the role of DI in this architecture as well (see
    the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff666b1a-21c5-4c90-96f0-f0ef01760a83.png)'
  prefs: []
  type: TYPE_IMG
- en: Again, you've seen how DI is also present in .NET Core-related platforms, such
    as Entity Framework Core.
  prefs: []
  type: TYPE_NORMAL
- en: However, there's an interesting point we haven't covered yet. We saw how to
    make a reference to the `DependencyInjection Namespace` inside a view, but we
    were not really using DI. Let's see how to use the new `@inject` directive inside
    a view with a simple demo.
  prefs: []
  type: TYPE_NORMAL
- en: Using Dependency Injection inside Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For completeness, I'm going to explain a simple demo of how to use DI inside
    a Razor view. It's a quite interesting feature and it can be useful to access
    data, service-related information, or even your own Razor helpers.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to create another view that is able to access the same data as our
    previous `Services` View, but this time without implying the controller in the
    business logic. Besides that, I'll create a Razor helper just to show how we can
    do both tasks thanks to the `@inject` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, inside a new folder (`Helpers`), let''s create a simple helper that
    provides some kind of information (for instance the current system''s time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With this new service in place, we need to register it as we did with the `Sentences*`
    services. The new version of the `ConfigureServices` method will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is all we need on the business logic side since we can use the existing
    services, only in a different way. So, I'll create another action method as part
    of the `HomeController` named `ServicesDI`, and try to replicate the previous
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `[Route("key")]` attribute to redirect URL queries to this
    action method. Actually, it''s even simpler than the others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the programming logic is deferred to the view itself. Thus, the
    `SentencesDI` View will have to reference the namespaces related to the services
    it is going to use, and declare any service required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the rest of the code is pretty self-explanatory. Once services
    are registered and references made, we can use the `@inject` directive to instruct
    the DI container about the resources that our view is going to need. The syntax
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this way, any functionality related to a service that is injected in a view
    can access the data inside the service without having to process it in the controller.
    You might say that this breaks in some way the architecture of the MVC foundations,
    but there are some circumstances in which it might be interesting to separate
    certain data from the controller if it is only related to a particular view.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, surely, you''ll find more useful possibilities. By the way, you can type
    `localhost:[port]/ServicesDI` in the browser to get the corresponding output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f711fe22-b931-4bf8-a799-3ee618634c7c.png)'
  prefs: []
  type: TYPE_IMG
- en: In short, another feature related to Dependency Injection, this time inside
    the Razor views, that we can use inside the ASP.NET Core platform.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on ASP.NET Core and Dependency Injection, analyzing
    how the whole architecture and configuration process is based on the internal
    DI Container of ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how to move from a simple Console app to an ASP.NET Core app, and
    finally, how the distinct servers for development and production can be tuned
    up.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we analyzed the main templates offered by Visual Studio 2017 in relation
    to ASP.NET Core apps and reviewed how they used DI in order to configure and manage
    the required information and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how to use our own custom services and integrate them inside
    ASP.NET Core using DI, either in the controllers or in the Razor Views.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](c2b6c427-7a04-43d9-93bf-076daeb0f024.xhtml), *Object Composition*,
    we will analyze Object Composition and its use within DI contexts.
  prefs: []
  type: TYPE_NORMAL
