<html><head></head><body>
<div id="_idContainer072" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-94"><a id="_idTextAnchor098" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-95" class="calibre5"><a id="_idTextAnchor099" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Effective Game Data Handling and Management with C# in Unity</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">Welcome to </span><a href="B22017_06.xhtml#_idTextAnchor098" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.4.1">Chapter 6</span></em></span></a><span class="kobospan" id="kobo.5.1">, where we’ll delve into effective game data handling and management using C# in Unity. </span><span class="kobospan" id="kobo.5.2">Through practical exploration, you’ll learn how to organize, store, and retrieve game data seamlessly. </span><span class="kobospan" id="kobo.5.3">From understanding data organization and serialization to implementing save and load systems, you’ll be able to empower players to preserve their progress and craft dynamic, data-driven gameplay experiences. </span><span class="kobospan" id="kobo.5.4">By the end of this chapter, you’ll have mastered the art of wielding C# for efficient game data management, unlocking endless possibilities for immersive gameplay. </span><span class="kobospan" id="kobo.5.5">Let’s embark on this journey together, where mastery of game data opens doors to boundless creativity in </span><span><span class="kobospan" id="kobo.6.1">game development.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.7.1">In this chapter, we’re going to cover the following </span><span><span class="kobospan" id="kobo.8.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.9.1">Data organization and serialization </span><span><span class="kobospan" id="kobo.10.1">with C#</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.11.1">Creating save and load systems </span><span><span class="kobospan" id="kobo.12.1">using C#</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.13.1">Data-driven gameplay </span><span><span class="kobospan" id="kobo.14.1">with C#</span></span></li>
</ul>
<h1 id="_idParaDest-96" class="calibre5"><a id="_idTextAnchor100" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.15.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.16.1">To complete this chapter, you must have </span><span><span class="kobospan" id="kobo.17.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.18.1">Unity version 2022.3.13</span></strong><span class="kobospan" id="kobo.19.1">: Download and install Unity, choosing version </span><strong class="source-inline1"><span class="kobospan" id="kobo.20.1">2022.3.13</span></strong><span class="kobospan" id="kobo.21.1"> for optimal compatibility with the </span><span><span class="kobospan" id="kobo.22.1">provided content.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.23.1">Primary IDE – Visual Studio 2022</span></strong><span class="kobospan" id="kobo.24.1">: The tutorials and code samples in this chapter have been crafted using Visual Studio 2022. </span><span class="kobospan" id="kobo.24.2">Ensure it’s installed so that you can follow along seamlessly. </span><span class="kobospan" id="kobo.24.3">Feel free to explore Rider or other IDEs if you prefer, though note that the instructions that have been provided are tailored for </span><span><span class="kobospan" id="kobo.25.1">Visual Studio.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.26.1">GitHub repository for code samples</span></strong><span class="kobospan" id="kobo.27.1">: You can access the code samples and project files for this chapter via this book’s dedicated GitHub repository:  </span><a href="https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2006" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.28.1">https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2006</span></a><span class="kobospan" id="kobo.29.1">. </span><span class="kobospan" id="kobo.29.2">Clone or download the repository so that you have easy access to the code provided in </span><span><span class="kobospan" id="kobo.30.1">this chapter.</span></span></li>
</ul>
<h1 id="_idParaDest-97" class="calibre5"><a id="_idTextAnchor101" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.31.1">Data organization and serialization with C#</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.32.1">In this section, we’ll </span><a id="_idIndexMarker358" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.33.1">dive into data organization and serialization with C# in Unity. </span><span class="kobospan" id="kobo.33.2">Here, we’ll learn how to manage game data efficiently. </span><span class="kobospan" id="kobo.33.3">First, we’ll talk about picking the right data structures, such as arrays and lists, and how to make your own. </span><span class="kobospan" id="kobo.33.4">Then, we’ll cover serialization, which</span><a id="_idIndexMarker359" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.34.1"> helps save and load game data. </span><span class="kobospan" id="kobo.34.2">Then, we’ll explore Unity’s options, such as </span><strong class="bold"><span class="kobospan" id="kobo.35.1">JavaScript Object Notation</span></strong><span class="kobospan" id="kobo.36.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.37.1">JSON</span></strong><span class="kobospan" id="kobo.38.1">) and </span><strong class="bold"><span class="kobospan" id="kobo.39.1">eXtensible Markup Language</span></strong><span class="kobospan" id="kobo.40.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.41.1">XML</span></strong><span class="kobospan" id="kobo.42.1">). </span><span class="kobospan" id="kobo.42.2">By covering some simple examples, we’ll </span><a id="_idIndexMarker360" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.43.1">show you how to organize and save game data neatly using C#. </span><span class="kobospan" id="kobo.43.2">Let’s start learning how to master game </span><span><span class="kobospan" id="kobo.44.1">data management!</span></span></p>
<h2 id="_idParaDest-98" class="calibre7"><a id="_idTextAnchor102" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.45.1">Understanding data structures</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.46.1">Selecting the </span><a id="_idIndexMarker361" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.47.1">appropriate data structure for storing information in your game involves considering factors such as the type of data, how frequently it will be accessed, and the operations you need to perform on that data. </span><span class="kobospan" id="kobo.47.2">Here are some examples to illustrate how you can choose the </span><span><span class="kobospan" id="kobo.48.1">right method:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.49.1">Arrays</span></strong><span class="kobospan" id="kobo.50.1">: Use</span><a id="_idIndexMarker362" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.51.1"> arrays when you have a fixed-size collection of </span><a id="_idIndexMarker363" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.52.1">elements of the </span><span><span class="kobospan" id="kobo.53.1">same type.</span></span><p class="calibre3"><span class="kobospan" id="kobo.54.1">For instance, if you have a game with a set number of levels, as shown in the following code, you might use an array to store level data, such as scores or the completion status for </span><span><span class="kobospan" id="kobo.55.1">each level:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.56.1">
int[] levelScores = new int[10]; // An array to store scores for 10 levels</span></pre></li> <li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.57.1">Lists</span></strong><span class="kobospan" id="kobo.58.1">: Lists</span><a id="_idIndexMarker364" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.59.1"> are dynamic arrays that can grow or shrink in</span><a id="_idIndexMarker365" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.60.1"> size at runtime. </span><span class="kobospan" id="kobo.60.2">They are suitable when you need to add or remove </span><span><span class="kobospan" id="kobo.61.1">elements frequently.</span></span><p class="calibre3"><span class="kobospan" id="kobo.62.1">For example, if you have a game with an inventory system where items can be added or removed dynamically, a list would be more appropriate. </span><span class="kobospan" id="kobo.62.2">Take a look at the following code for </span><span><span class="kobospan" id="kobo.63.1">an example:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.64.1">
List&lt;string&gt; inventoryItems = new List&lt;string&gt;(); // A list to store inventory items
inventoryItems.Add("Sword");
inventoryItems.Add("Potion");</span></pre></li> <li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.65.1">Dictionaries</span></strong><span class="kobospan" id="kobo.66.1">: Dictionaries</span><a id="_idIndexMarker366" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.67.1"> are useful when you </span><a id="_idIndexMarker367" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.68.1">need to associate keys with values. </span><span class="kobospan" id="kobo.68.2">They are ideal for situations where you need to quickly look up values based on </span><span><span class="kobospan" id="kobo.69.1">specific keys.</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.70.1">For instance, if you have a game with a leaderboard, you might use a dictionary to map player names to their scores, as </span><span><span class="kobospan" id="kobo.71.1">shown here:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.72.1">
Dictionary&lt;string, int&gt; leaderboard = new Dictionary&lt;string, int&gt;(); leaderboard.Add("Player1", 1000);
leaderboard.Add("Player2", 1500);</span></pre></li></ul></li> <li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.73.1">Custom data structures</span></strong><span class="kobospan" id="kobo.74.1">: Sometimes, none of the built-in data structures are the </span><a id="_idIndexMarker368" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.75.1">perfect fit for your needs. </span><span class="kobospan" id="kobo.75.2">In such cases, you </span><a id="_idIndexMarker369" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.76.1">can create custom data structures tailored to your </span><span><span class="kobospan" id="kobo.77.1">specific requirements.</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.78.1">For example, if you’re developing a complex RPG game, you might create a custom data structure to represent character attributes and abilities. </span><span class="kobospan" id="kobo.78.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.79.1">Character</span></strong><span class="kobospan" id="kobo.80.1"> class is one such custom </span><span><span class="kobospan" id="kobo.81.1">data structure:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.82.1">
public class Character {
  public string Name;
  public int Health;
  public int AttackDamage;
}</span></pre></li></ul></li> </ul>
<p class="calibre3"><span class="kobospan" id="kobo.83.1">By carefully </span><a id="_idIndexMarker370" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.84.1">considering the nature of your data and the operations you need to perform, you can choose the most appropriate data structure for your game, ensuring optimal performance and efficient </span><span><span class="kobospan" id="kobo.85.1">data management.</span></span></p>
<h2 id="_idParaDest-99" class="calibre7"><a id="_idTextAnchor103" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.86.1">Enhancing game performance with proper data structure selection</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.87.1">In the </span><a id="_idIndexMarker371" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.88.1">world of game creation, where speed and efficiency matter most, picking the right data structures is crucial. </span><span class="kobospan" id="kobo.88.2">It helps game makers achieve smoother and faster gameplay, making their games more enjoyable </span><span><span class="kobospan" id="kobo.89.1">for players.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.90.1">Choosing the appropriate data structure can significantly benefit game performance in </span><span><span class="kobospan" id="kobo.91.1">several ways:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.92.1">Optimized memory usage</span></strong><span class="kobospan" id="kobo.93.1">: Using the right data structure helps minimize memory usage, which is crucial for performance, especially in </span><span><span class="kobospan" id="kobo.94.1">resource-intensive games.</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.95.1">For example, if your game only needs to store a fixed number of elements of the same type, using an array instead of a list can save memory because arrays have a </span><span><span class="kobospan" id="kobo.96.1">fixed size.</span></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.97.1">Faster access and retrieval</span></strong><span class="kobospan" id="kobo.98.1">: Certain data structures offer faster access and retrieval times, which can improve overall </span><span><span class="kobospan" id="kobo.99.1">game responsiveness.</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.100.1">For instance, dictionaries provide constant-time lookups, making them ideal for scenarios where you need to quickly retrieve values based on keys, such as accessing player data in </span><span><span class="kobospan" id="kobo.101.1">a leaderboard.</span></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.102.1">Efficient data manipulation</span></strong><span class="kobospan" id="kobo.103.1">: Choosing the appropriate data structure can streamline data manipulation operations, leading to smoother </span><span><span class="kobospan" id="kobo.104.1">gameplay experiences.</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.105.1">Lists, for example, allow for efficient insertion and removal of elements, making them suitable for dynamic scenarios such as managing an inventory where items are frequently added </span><span><span class="kobospan" id="kobo.106.1">or removed.</span></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.107.1">Enhanced code readability and maintainability</span></strong><span class="kobospan" id="kobo.108.1">: Using the right data structure can make your code more readable and maintainable, leading to easier debugging and future updates. </span><span class="kobospan" id="kobo.108.2">Custom data structures tailored to your game’s specific needs can improve code organization and clarity, making it easier </span><a id="_idIndexMarker372" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.109.1">for you and other developers to understand and modify the </span><span><span class="kobospan" id="kobo.110.1">code base.</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.111.1">For instance, if your game includes challenges, you can design a custom class specifically for managing these challenges. </span><span class="kobospan" id="kobo.111.2">Within this class, you can incorporate attributes such as a list of rewards and a unique identifier for each challenge. </span><span class="kobospan" id="kobo.111.3">This approach enhances the readability of your </span><span><span class="kobospan" id="kobo.112.1">code base.</span></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.113.1">Reduced processing overhead</span></strong><span class="kobospan" id="kobo.114.1">: Optimal data structures help reduce processing overhead, contributing to smoother gameplay and better </span><span><span class="kobospan" id="kobo.115.1">overall performance.</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.116.1">For example, if your game needs to iterate through a collection of elements in a specific order, using a list instead of a dictionary can eliminate unnecessary key-value pair lookups, resulting in faster </span><span><span class="kobospan" id="kobo.117.1">iteration times.</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.118.1">In summary, selecting the appropriate data structure is critical for optimizing game performance as it helps minimize memory usage, improve access times, streamline data manipulation, enhance code readability, and reduce processing overhead. </span><span class="kobospan" id="kobo.118.2">By understanding the characteristics and advantages of different data structures, game developers can design more efficient and responsive gameplay experiences </span><span><span class="kobospan" id="kobo.119.1">for players.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.120.1">In the upcoming subsection, we’ll delve deeper into Unity’s serialization, exploring its role in efficiently saving and </span><span><span class="kobospan" id="kobo.121.1">loading data.</span></span></p>
<h2 id="_idParaDest-100" class="calibre7"><a id="_idTextAnchor104" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.122.1">Serialization in Unity</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.123.1">Serialization</span></strong><span class="kobospan" id="kobo.124.1"> is the </span><a id="_idIndexMarker373" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.125.1">process of converting complex objects or data structures into a format that can be easily stored or transmitted and then reconstructed later. </span><span class="kobospan" id="kobo.125.2">In the context of Unity game development, serialization plays a crucial role in saving and loading game data. </span><span class="kobospan" id="kobo.125.3">By serializing game objects and their properties, Unity can store them in a format that can be saved to disk or transferred over the network, allowing for persistence between sessions and enabling features such as saving games and </span><span><span class="kobospan" id="kobo.126.1">networked multiplayer.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.127.1">Serialization</span><a id="_idIndexMarker374" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.128.1"> is a fundamental aspect of game development for </span><span><span class="kobospan" id="kobo.129.1">several reasons:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.130.1">Persistence between sessions</span></strong><span class="kobospan" id="kobo.131.1">: Serialization allows game state and player progress to be saved and loaded between gameplay sessions. </span><span class="kobospan" id="kobo.131.2">This enables features such as saving and loading game progress, maintaining player inventories, and preserving </span><span><span class="kobospan" id="kobo.132.1">game settings.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.133.1">Network communication</span></strong><span class="kobospan" id="kobo.134.1">: Serialization facilitates transmitting game data over the network, which is essential for multiplayer games, client-server architectures, and online features. </span><span class="kobospan" id="kobo.134.2">By serializing game objects and messages, Unity can send data between clients and </span><span><span class="kobospan" id="kobo.135.1">servers efficiently.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.136.1">Data interchange</span></strong><span class="kobospan" id="kobo.137.1">: Serialization allows data to be exchanged between different systems and platforms. </span><span class="kobospan" id="kobo.137.2">For example, game data can be serialized into a standardized format such as JSON or XML, allowing it to be shared with other applications or integrated with </span><span><span class="kobospan" id="kobo.138.1">web services.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.139.1">Data persistence</span></strong><span class="kobospan" id="kobo.140.1">: Serialization allows data to be stored in a structured format, such as files or databases, ensuring that it persists even when the game isn’t running. </span><span class="kobospan" id="kobo.140.2">This is crucial for features such as saving and loading user preferences, high scores, and </span><span><span class="kobospan" id="kobo.141.1">game configurations.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.142.1">By understanding the principles of serialization and mastering Unity’s serialization options, we can implement robust and flexible data management systems, enabling features such as save games, networked multiplayer, and data-driven gameplay mechanics. </span><span class="kobospan" id="kobo.142.2">Serialization is a fundamental tool in our toolkit, empowering us to create immersive and dynamic gaming experiences across platforms </span><span><span class="kobospan" id="kobo.143.1">and genres.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.144.1">In Unity, serialization is seamlessly integrated into the engine’s workflow, allowing us to easily save and load game data using built-in APIs and utilities. </span><span class="kobospan" id="kobo.144.2">Unity provides various serialization options, including JSON, XML, and binary serialization, each suited to different use cases and requirements. </span><span class="kobospan" id="kobo.144.3">As we can see in </span><span><span class="kobospan" id="kobo.145.1">this section.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.146.1">Let’s explore the options that are available in Unity so that we can integrate them into our game. </span><span class="kobospan" id="kobo.146.2">We’ll begin by defining each option and providing an example for better understanding. </span><span class="kobospan" id="kobo.146.3">We’ll delve into each one and illustrate </span><span><span class="kobospan" id="kobo.147.1">their usage.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.148.1">JSON serialization and deserialization</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.149.1">JSON is a</span><a id="_idIndexMarker375" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.150.1"> lightweight data-interchange format that is commonly used for transmitting data between a server and a web application. </span><span class="kobospan" id="kobo.150.2">In Unity, JSON </span><a id="_idIndexMarker376" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.151.1">serialization and deserialization </span><a id="_idIndexMarker377" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.152.1">are useful for scenarios where you need to exchange data with external systems or </span><span><span class="kobospan" id="kobo.153.1">web services.</span></span></p>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.154.1">Example</span></em><span class="kobospan" id="kobo.155.1">: In the following code block, we’re utilizing Unity’s built-in system to serialize and </span><span><span class="kobospan" id="kobo.156.1">deserialize data:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.157.1">
// Serialize object to JSON string
string jsonString = JsonUtility.ToJson(myObject);
// Deserialize JSON string back to object
MyClass deserializedObject = JsonUtility.FromJson&lt;MyClass&gt;(jsonString);</span></pre> <h3 class="calibre9"><span class="kobospan" id="kobo.158.1">XML serialization and deserialization</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.159.1">XML is a </span><a id="_idIndexMarker378" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.160.1">versatile format that is used for data exchange and configuration settings. </span><span class="kobospan" id="kobo.160.2">Unity supports XML serialization and deserialization, making it suitable for scenarios where you need to work</span><a id="_idIndexMarker379" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.161.1"> with legacy systems or integrate with platforms</span><a id="_idIndexMarker380" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.162.1"> that use XML as the data </span><span><span class="kobospan" id="kobo.163.1">interchange format.</span></span></p>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.164.1">Example</span></em><span class="kobospan" id="kobo.165.1">: The following code block demonstrates how to serialize and deserialize data to and </span><span><span class="kobospan" id="kobo.166.1">from XML.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.167.1">To utilize this type of serialization, you must include the </span><strong class="source-inline"><span class="kobospan" id="kobo.168.1">using System.IO;</span></strong><span class="kobospan" id="kobo.169.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.170.1">using System.Xml.Serialization;</span></strong><span class="kobospan" id="kobo.171.1"> namespaces, </span><span><span class="kobospan" id="kobo.172.1">like so:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.173.1">
// Serialize object to XML string
XmlSerializer serializer = new XmlSerializer(typeof(MyClass));
StringWriter writer = new StringWriter();
serializer.Serialize(writer, myObject);
string xmlString = writer.ToString();
// Deserialize XML string back to object
StringReader reader = new StringReader(xmlString);
MyClass deserializedObject = (MyClass)serializer.Deserialize(reader);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.174.1">Let’s take a closer look at the </span><a id="_idIndexMarker381" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.175.1">XML serialization and deserialization </span><span><span class="kobospan" id="kobo.176.1">provided </span></span><span><a id="_idIndexMarker382" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.177.1">here:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.178.1">Serialization process</span></strong></span><span><span class="kobospan" id="kobo.179.1">:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.180.1">Serialization is the process of converting an object into a format that can be easily stored or transmitted and </span><span><span class="kobospan" id="kobo.181.1">reconstructed later</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.182.1">XmlSerializer</span></strong><span class="kobospan" id="kobo.183.1"> is a class provided by the .NET framework for serializing and deserializing objects to and from </span><span><span class="kobospan" id="kobo.184.1">XML format</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.185.1">XmlSerializer serializer = new XmlSerializer(typeof(MyClass));</span></strong><span class="kobospan" id="kobo.186.1">: This line creates an instance of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.187.1">XmlSerializer</span></strong><span class="kobospan" id="kobo.188.1"> class that specifies the type of object (</span><strong class="source-inline1"><span class="kobospan" id="kobo.189.1">MyClass</span></strong><span class="kobospan" id="kobo.190.1">) to </span><span><span class="kobospan" id="kobo.191.1">be serialized</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.192.1">StringWriter writer = new StringWriter();</span></strong><span class="kobospan" id="kobo.193.1">: This line creates a </span><strong class="source-inline1"><span class="kobospan" id="kobo.194.1">StringWriter</span></strong><span class="kobospan" id="kobo.195.1"> object, which is used to write XML content as </span><span><span class="kobospan" id="kobo.196.1">a string</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.197.1">serializer.Serialize(writer, myObject);</span></strong><span class="kobospan" id="kobo.198.1">: This line serializes the </span><strong class="source-inline1"><span class="kobospan" id="kobo.199.1">myObject</span></strong><span class="kobospan" id="kobo.200.1"> instance of </span><strong class="source-inline1"><span class="kobospan" id="kobo.201.1">MyClass</span></strong><span class="kobospan" id="kobo.202.1"> into XML format and writes it </span><span><span class="kobospan" id="kobo.203.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.204.1">StringWriter</span></strong></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.205.1">string xmlString = writer.ToString();</span></strong><span class="kobospan" id="kobo.206.1">: This line converts the XML content written to </span><strong class="source-inline1"><span class="kobospan" id="kobo.207.1">StringWriter</span></strong><span class="kobospan" id="kobo.208.1"> into a string representation and stores it in the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.209.1">xmlString</span></strong></span><span><span class="kobospan" id="kobo.210.1"> variable</span></span></li></ul></li>
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.211.1">Deserialization process</span></strong></span><span><span class="kobospan" id="kobo.212.1">:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.213.1">Deserialization </span><a id="_idIndexMarker383" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.214.1">is the process of reconstructing an object from its serialized </span><span><span class="kobospan" id="kobo.215.1">XML representation.</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.216.1">StringReader reader = new StringReader(xmlString);</span></strong><span class="kobospan" id="kobo.217.1">: This line creates a </span><strong class="source-inline1"><span class="kobospan" id="kobo.218.1">StringReader</span></strong><span class="kobospan" id="kobo.219.1"> object, which is used to read XML content from </span><span><span class="kobospan" id="kobo.220.1">a string.</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.221.1">(MyClass)serializer.Deserialize(reader);</span></strong><span class="kobospan" id="kobo.222.1">: This line deserializes the XML content from </span><strong class="source-inline1"><span class="kobospan" id="kobo.223.1">StringReader</span></strong><span class="kobospan" id="kobo.224.1"> back into an object of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.225.1">MyClass</span></strong><span class="kobospan" id="kobo.226.1"> type. </span><span class="kobospan" id="kobo.226.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.227.1">Deserialize</span></strong><span class="kobospan" id="kobo.228.1"> method of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.229.1">XmlSerializer</span></strong><span class="kobospan" id="kobo.230.1"> class is used for </span><span><span class="kobospan" id="kobo.231.1">this purpose.</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.232.1">The deserialized object is then assigned to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.233.1">deserializedObject</span></strong><span class="kobospan" id="kobo.234.1"> variable, ready for use in </span><span><span class="kobospan" id="kobo.235.1">the program.</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.236.1">In summary, the provided code block demonstrates how to serialize an object of the </span><strong class="source-inline"><span class="kobospan" id="kobo.237.1">MyClass</span></strong><span class="kobospan" id="kobo.238.1"> type as an XML string and then deserialize the XML string back into an object of the same type using the </span><strong class="source-inline"><span class="kobospan" id="kobo.239.1">XmlSerializer</span></strong><span class="kobospan" id="kobo.240.1"> class in C#. </span><span class="kobospan" id="kobo.240.2">This process allows objects to be easily persisted to storage or transmitted over a network in XML format and reconstructed later for use in </span><span><span class="kobospan" id="kobo.241.1">the application.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.242.1">Binary serialization and deserialization</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.243.1">Binary serialization </span><a id="_idIndexMarker384" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.244.1">and deserialization are ideal for scenarios where you need to </span><a id="_idIndexMarker385" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.245.1">save and load game data efficiently, such as implementing save games or storing configuration settings locally on the user’s device. </span><span class="kobospan" id="kobo.245.2">Binary serialization provides a compact representation of data and faster read/write times compared to text-based formats such as JSON </span><span><span class="kobospan" id="kobo.246.1">or XML.</span></span></p>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.247.1">Example</span></em><span class="kobospan" id="kobo.248.1">: The following code block shows how to serialize and deserialize data to and from </span><span><span class="kobospan" id="kobo.249.1">binary format.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.250.1">To utilize this type of serialization, you must include the </span><strong class="source-inline"><span class="kobospan" id="kobo.251.1">using System.IO;</span></strong><span class="kobospan" id="kobo.252.1"> and</span><strong class="source-inline"><span class="kobospan" id="kobo.253.1"> using System.Runtime.Serialization.Formatters.Binary;</span></strong><span class="kobospan" id="kobo.254.1"> namespaces, </span><span><span class="kobospan" id="kobo.255.1">as</span></span><span><a id="_idIndexMarker386" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.256.1"> follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.257.1">
// Serialize object to binary format
BinaryFormatter formatter = new BinaryFormatter();
MemoryStream stream = new MemoryStream();
formatter.Serialize(stream, myObject);
byte[] binaryData = stream.ToArray();
// Deserialize binary data back to object
stream = new MemoryStream(binaryData);
MyClass deserializedObject = (MyClass)formatter.Deserialize(stream);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.258.1">Let’s take a closer </span><a id="_idIndexMarker387" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.259.1">look at this </span><span><span class="kobospan" id="kobo.260.1">code block:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.261.1">Serialization process</span></strong></span><span><span class="kobospan" id="kobo.262.1">:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.263.1">Serialization is the process of converting an object into a format that can be easily stored or transmitted and </span><span><span class="kobospan" id="kobo.264.1">reconstructed later</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.265.1">BinaryFormatter</span></strong><span class="kobospan" id="kobo.266.1"> is a class provided by the .NET framework for serializing and deserializing objects to and from </span><span><span class="kobospan" id="kobo.267.1">binary format</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.268.1">BinaryFormatter formatter = new BinaryFormatter();</span></strong><span class="kobospan" id="kobo.269.1">: This line creates an instance of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.270.1">BinaryFormatter</span></strong><span class="kobospan" id="kobo.271.1"> class, which is used for </span><span><span class="kobospan" id="kobo.272.1">binary serialization</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.273.1">MemoryStream stream = new MemoryStream();</span></strong><span class="kobospan" id="kobo.274.1">: This line creates a </span><strong class="source-inline1"><span class="kobospan" id="kobo.275.1">MemoryStream</span></strong><span class="kobospan" id="kobo.276.1"> object, which is used to store binary data </span><span><span class="kobospan" id="kobo.277.1">in memory</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.278.1">formatter.Serialize(stream, myObject);</span></strong><span class="kobospan" id="kobo.279.1">: This line serializes the </span><strong class="source-inline1"><span class="kobospan" id="kobo.280.1">myObject</span></strong><span class="kobospan" id="kobo.281.1"> instance into binary format and writes it </span><span><span class="kobospan" id="kobo.282.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.283.1">MemoryStream</span></strong></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.284.1">byte[] binaryData = stream.ToArray();</span></strong><span class="kobospan" id="kobo.285.1">: This line converts the binary data written to </span><strong class="source-inline1"><span class="kobospan" id="kobo.286.1">MemoryStream</span></strong><span class="kobospan" id="kobo.287.1"> into a byte array, which can be easily stored </span><span><span class="kobospan" id="kobo.288.1">or transmitted</span></span></li></ul></li>
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.289.1">Deserialization process</span></strong></span><span><span class="kobospan" id="kobo.290.1">:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.291.1">Deserialization</span><a id="_idIndexMarker388" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.292.1"> is the process of reconstructing an object from its serialized </span><span><span class="kobospan" id="kobo.293.1">binary representation.</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.294.1">stream = new MemoryStream(binaryData);</span></strong><span class="kobospan" id="kobo.295.1">: This line creates a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.296.1">MemoryStream</span></strong><span class="kobospan" id="kobo.297.1"> object, initialized with the binary data stored in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.298.1">binaryData</span></strong> <span><span class="kobospan" id="kobo.299.1">byte array.</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.300.1">(MyClass)formatter.Deserialize(stream);</span></strong><span class="kobospan" id="kobo.301.1">: This line deserializes the binary data from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.302.1">MemoryStream</span></strong><span class="kobospan" id="kobo.303.1"> back into an object of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.304.1">MyClass</span></strong><span class="kobospan" id="kobo.305.1"> type. </span><span class="kobospan" id="kobo.305.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.306.1">Deserialize</span></strong><span class="kobospan" id="kobo.307.1"> method of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.308.1">BinaryFormatter</span></strong><span class="kobospan" id="kobo.309.1"> class is used for </span><span><span class="kobospan" id="kobo.310.1">this purpose.</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.311.1">The deserialized object is then assigned to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.312.1">deserializedObject</span></strong><span class="kobospan" id="kobo.313.1"> variable, ready for use in </span><span><span class="kobospan" id="kobo.314.1">the program.</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.315.1">In summary, the preceding code block demonstrates how to serialize an object of the </span><strong class="source-inline"><span class="kobospan" id="kobo.316.1">MyClass</span></strong><span class="kobospan" id="kobo.317.1"> type to binary format and then deserialize the binary data back into an object of the same type using the </span><strong class="source-inline"><span class="kobospan" id="kobo.318.1">BinaryFormatter</span></strong><span class="kobospan" id="kobo.319.1"> class in C#. </span><span class="kobospan" id="kobo.319.2">This process allows objects to be easily persisted to storage or transmitted over a network in binary format and reconstructed later for use in </span><span><span class="kobospan" id="kobo.320.1">the application.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.321.1">ScriptableObject serialization</span></h3>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.322.1">ScriptableObjects</span></strong><span class="kobospan" id="kobo.323.1"> are </span><a id="_idIndexMarker389" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.324.1">Unity assets that allow you to store data in a serialized </span><a id="_idIndexMarker390" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.325.1">format and create custom editor interfaces for modifying that data in Unity Editor. </span><span class="kobospan" id="kobo.325.2">They are useful for managing configuration settings, defining game parameters, and creating reusable components that can be shared across multiple </span><span><span class="kobospan" id="kobo.326.1">game objects.</span></span></p>
<p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.327.1">Example</span></em><span class="kobospan" id="kobo.328.1">: In the following code blocks, we will explore an example of scriptable object data. </span><span class="kobospan" id="kobo.328.2">Then, we’ll demonstrate how to utilize serialization and deserialization with </span><span><span class="kobospan" id="kobo.329.1">scriptable objects.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.330.1">The first code block</span><a id="_idIndexMarker391" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.331.1"> contains a ScriptableObject that’s designed for game settings, encapsulating essential data relevant to the </span><span><span class="kobospan" id="kobo.332.1">game’s operation:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.333.1">
[CreateAssetMenu(fileName = "NewSettings", menuName = "Game Settings")]
public class GameSettings : ScriptableObject {
    public int playerHealth;
    public int enemyCount;
    public float playerSpeed;
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.334.1">For the second code block, the </span><strong class="source-inline"><span class="kobospan" id="kobo.335.1">SettingsManager</span></strong><span class="kobospan" id="kobo.336.1"> class contains a reference to the </span><strong class="source-inline"><span class="kobospan" id="kobo.337.1">GameSettings</span></strong><span class="kobospan" id="kobo.338.1"> data and includes functions for saving and </span><span><span class="kobospan" id="kobo.339.1">loading settings:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.340.1">
public class SettingsManager : MonoBehaviour {
    public GameSettings gameSettings;
    // Serialize the GameSettings ScriptableObject to a file
    public void SaveSettings() {
        string jsonSettings = JsonUtility.ToJson(gameSettings);
        System.IO.File.WriteAllText(Application.persistentDataPath + "/settings.json", jsonSettings);
    }
    // Deserialize the GameSettings ScriptableObject from a file
    public void LoadSettings() {
        if (System.IO.File.Exists(Application.persistentDataPath + "/settings.json")) {
            string jsonSettings = System.IO.File.ReadAllText(Application.persistentDataPath + "/settings.json");
            gameSettings = JsonUtility.FromJson&lt;GameSettings&gt;(jsonSettings);
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.341.1">Let’s take a </span><a id="_idIndexMarker392" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.342.1">closer look at the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.343.1">SettingsManager</span></strong></span><span><span class="kobospan" id="kobo.344.1"> class:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.345.1">The </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.346.1">SaveSettings()</span></strong></span><span><span class="kobospan" id="kobo.347.1"> method:</span></span><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.348.1">public void</span></strong> <strong class="source-inline1"><span class="kobospan" id="kobo.349.1">SaveSettings() { ... </span><span class="kobospan" id="kobo.349.2">}</span></strong><span class="kobospan" id="kobo.350.1">: This method is responsible for saving the game settings to </span><span><span class="kobospan" id="kobo.351.1">a file</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.352.1">JsonUtility.ToJson(gameSettings)</span></strong><span class="kobospan" id="kobo.353.1">: This method serializes the </span><strong class="source-inline1"><span class="kobospan" id="kobo.354.1">gameSettings</span></strong><span class="kobospan" id="kobo.355.1"> object to </span><span><span class="kobospan" id="kobo.356.1">JSON format</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.357.1">System.IO.File.WriteAllText(...)</span></strong><span class="kobospan" id="kobo.358.1">: This method writes the serialized JSON data to a file named </span><strong class="source-inline1"><span class="kobospan" id="kobo.359.1">settings.json</span></strong><span class="kobospan" id="kobo.360.1"> in the persistent data path of </span><span><span class="kobospan" id="kobo.361.1">the application</span></span></li></ul></li>
<li class="calibre11"><span class="kobospan" id="kobo.362.1">The </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.363.1">LoadSettings()</span></strong></span><span><span class="kobospan" id="kobo.364.1"> method:</span></span><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.365.1">public void LoadSettings() { ... </span><span class="kobospan" id="kobo.365.2">}</span></strong><span class="kobospan" id="kobo.366.1">: This method is responsible for loading the game settings from </span><span><span class="kobospan" id="kobo.367.1">a file</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.368.1">System.IO.File.Exists(...)</span></strong><span class="kobospan" id="kobo.369.1">: This method checks if the </span><strong class="source-inline1"><span class="kobospan" id="kobo.370.1">settings.json</span></strong><span class="kobospan" id="kobo.371.1"> file exists in the persistent </span><span><span class="kobospan" id="kobo.372.1">data path</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.373.1">System.IO.File.ReadAllText(...)</span></strong><span class="kobospan" id="kobo.374.1">: This method reads the JSON data from the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.375.1">settings.json</span></strong></span><span><span class="kobospan" id="kobo.376.1"> file</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.377.1">JsonUtility.FromJson&lt;GameSettings&gt;(jsonSettings)</span></strong><span class="kobospan" id="kobo.378.1">: This method deserializes the JSON data back into a </span><strong class="source-inline1"><span class="kobospan" id="kobo.379.1">GameSettings</span></strong><span class="kobospan" id="kobo.380.1"> object and assigns it to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.381.1">gameSettings</span></strong></span><span><span class="kobospan" id="kobo.382.1"> variable</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.383.1">Overall, the </span><strong class="source-inline"><span class="kobospan" id="kobo.384.1">SettingsManager</span></strong><span class="kobospan" id="kobo.385.1"> class provides functionality to save and load game settings using JSON serialization </span><a id="_idIndexMarker393" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.386.1">and deserialization. </span><span class="kobospan" id="kobo.386.2">It demonstrates basic file I/O operations in Unity for handling </span><span><span class="kobospan" id="kobo.387.1">persistent data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.388.1">Regarding ScriptableObjects, we have the flexibility to save them using XML or binary formats, and we can treat them as custom classes that encapsulate </span><span><span class="kobospan" id="kobo.389.1">specific data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.390.1">To summarize, choosing the appropriate serialization and deserialization options in Unity depends on factors such as data interchange requirements, performance considerations, and integration with external systems. </span><span class="kobospan" id="kobo.390.2">Understanding the strengths and limitations of each option allows developers to make informed decisions and implement efficient data management solutions in their </span><span><span class="kobospan" id="kobo.391.1">Unity projects.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.392.1">Having understood the importance of data organization, let’s consider the role save and load systems can play in a </span><span><span class="kobospan" id="kobo.393.1">game’s management.</span></span></p>
<h1 id="_idParaDest-101" class="calibre5"><a id="_idTextAnchor105" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.394.1">Creating save and load systems using C#</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.395.1">Save and load systems </span><a id="_idIndexMarker394" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.396.1">play a pivotal role in managing game progress and ensuring seamless player experiences. </span><span class="kobospan" id="kobo.396.2">In this section, we’ll delve into various methods, from basic </span><strong class="bold"><span class="kobospan" id="kobo.397.1">PlayerPrefs</span></strong><span class="kobospan" id="kobo.398.1"> to </span><a id="_idIndexMarker395" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.399.1">more robust file-based save systems, enabling us, as developers, to preserve and retrieve player data within </span><span><span class="kobospan" id="kobo.400.1">Unity efficiently.</span></span></p>
<h2 id="_idParaDest-102" class="calibre7"><a id="_idTextAnchor106" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.401.1">PlayerPrefs</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.402.1">PlayerPrefs </span><a id="_idIndexMarker396" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.403.1">in Unity serve as a straightforward solution for storing key-value pairs, which is crucial for preserving simple game data. </span><span class="kobospan" id="kobo.403.2">Understanding PlayerPrefs is fundamental for efficiently managing basic player preferences and progress within Unity projects. </span><span class="kobospan" id="kobo.403.3">Operating as a key-value store, PlayerPrefs is specifically designed for storing player preferences and small data amounts between game sessions. </span><span class="kobospan" id="kobo.403.4">Its simple interface facilitates setting and retrieving data, making it ideal for managing settings, user preferences, and basic </span><span><span class="kobospan" id="kobo.404.1">game progress.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.405.1">Usage tips</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.406.1">Let’s explore </span><a id="_idIndexMarker397" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.407.1">essential usage tips for maximizing the benefits of PlayerPrefs in Unity game development, including insights into data serialization, encryption, and security measures, as well as performance </span><span><span class="kobospan" id="kobo.408.1">optimization techniques:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.409.1">Data serialization</span></strong><span class="kobospan" id="kobo.410.1">: While PlayerPrefs natively supports storing basic data types, such as integers, floats, and strings, more complex data structures require serialization. </span><span class="kobospan" id="kobo.410.2">We can serialize custom data structures into a format that’s compatible with PlayerPrefs, enabling us to store and retrieve complex </span><span><span class="kobospan" id="kobo.411.1">game data.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.412.1">Encryption and security</span></strong><span class="kobospan" id="kobo.413.1">: You can protect sensitive player data by implementing encryption mechanisms before storing them in PlayerPrefs. </span><span class="kobospan" id="kobo.413.2">By encrypting PlayerPrefs data, we can safeguard against unauthorized access and protect </span><span><span class="kobospan" id="kobo.414.1">player privacy.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.415.1">Optimizing performance</span></strong><span class="kobospan" id="kobo.416.1">: PlayerPrefs access involves disk I/O operations, which can impact performance, especially in resource-intensive games. </span><span class="kobospan" id="kobo.416.2">To mitigate performance overhead, batch PlayerPrefs operations where possible and minimize frequent read/write operations </span><span><span class="kobospan" id="kobo.417.1">during gameplay.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.418.1">Incorporating these usage tips will help us optimize PlayerPrefs usage, ensuring data security, performance efficiency, and effective handling of complex game data in </span><span><span class="kobospan" id="kobo.419.1">Unity projects.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.420.1">Now, let’s look at an example demonstrating how to utilize PlayerPrefs for saving and </span><span><span class="kobospan" id="kobo.421.1">loading data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.422.1">In this first code block, the </span><strong class="source-inline"><span class="kobospan" id="kobo.423.1">GameData</span></strong><span class="kobospan" id="kobo.424.1"> class is a custom class containing game data fields that must be saved </span><span><span class="kobospan" id="kobo.425.1">and loaded:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.426.1">
// Define a class for game data serialization
[System.Serializable]
public class GameData {
    public int playerLevel;
    public int playerExperience;
    // Additional game data fields...
</span><span class="kobospan1" id="kobo.426.2">}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.427.1">The second code block</span><a id="_idIndexMarker398" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.428.1"> contains the save and load functions, which use PlayerPrefs with the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.429.1">GameData</span></strong></span><span><span class="kobospan" id="kobo.430.1"> class:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.431.1">
// Save game data to PlayerPrefs
public void SaveGame() {
    GameData gameData = new GameData();
    // Populate game data with current game state
    gameData.playerLevel = PlayerController.instance.level;
    gameData.playerExperience = PlayerController.instance.experience;
    // Serialize game data to JSON
    string jsonData = JsonUtility.ToJson(gameData);
    // Save serialized data to PlayerPrefs
    PlayerPrefs.SetString("GameData", jsonData);
    PlayerPrefs.Save();
}
// Load game data from PlayerPrefs
public void LoadGame() {
    if (PlayerPrefs.HasKey("GameData")) {
        // Retrieve serialized data from PlayerPrefs
        string jsonData = PlayerPrefs.GetString("GameData");
        // Deserialize JSON data to game data object
        GameData gameData = JsonUtility.FromJson&lt;GameData&gt;(jsonData);
        // Apply loaded game data to game state
        PlayerController.instance.level = gameData.playerLevel;
        PlayerController.instance.experience = gameData.playerExperience;
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.432.1">Let’s take a</span><a id="_idIndexMarker399" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.433.1"> closer look at the saving and </span><span><span class="kobospan" id="kobo.434.1">loading functions:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.435.1">SaveGame()</span></strong></span><span><span class="kobospan" id="kobo.436.1">:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.437.1">This function is responsible for saving the </span><span><span class="kobospan" id="kobo.438.1">game data.</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.439.1">It initializes a new instance of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.440.1">GameData</span></strong><span class="kobospan" id="kobo.441.1"> class, which likely contains fields representing various aspects of the </span><span><span class="kobospan" id="kobo.442.1">game state.</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.443.1">The current game state is then captured and stored in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.444.1">GameData</span></strong><span class="kobospan" id="kobo.445.1"> instance. </span><span class="kobospan" id="kobo.445.2">In this example, it appears to be capturing the player’s level and experience from a </span><strong class="source-inline1"><span class="kobospan" id="kobo.446.1">PlayerController</span></strong> <span><span class="kobospan" id="kobo.447.1">singleton instance.</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.448.1">Next, the game data is serialized to JSON format </span><span><span class="kobospan" id="kobo.449.1">using </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.450.1">JsonUtility.ToJson()</span></strong></span><span><span class="kobospan" id="kobo.451.1">.</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.452.1">Finally, the serialized JSON data is stored in </span><strong class="source-inline1"><span class="kobospan" id="kobo.453.1">PlayerPrefs</span></strong><span class="kobospan" id="kobo.454.1"> using </span><strong class="source-inline1"><span class="kobospan" id="kobo.455.1">PlayerPrefs.SetString()</span></strong><span class="kobospan" id="kobo.456.1"> with the </span><strong class="source-inline1"><span class="kobospan" id="kobo.457.1">GameData</span></strong><span class="kobospan" id="kobo.458.1"> key, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.459.1">PlayerPrefs.Save()</span></strong><span class="kobospan" id="kobo.460.1"> is called to persist </span><span><span class="kobospan" id="kobo.461.1">the changes.</span></span></li></ul></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.462.1">LoadGame()</span></strong></span><span><span class="kobospan" id="kobo.463.1">:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.464.1">This</span><a id="_idIndexMarker400" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.465.1"> function loads the saved </span><span><span class="kobospan" id="kobo.466.1">game data.</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.467.1">First, it checks if existing game data is stored in </span><strong class="source-inline1"><span class="kobospan" id="kobo.468.1">PlayerPrefs</span></strong><span class="kobospan" id="kobo.469.1"> by using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.470.1">GameData</span></strong><span class="kobospan" id="kobo.471.1"> key </span><span><span class="kobospan" id="kobo.472.1">alongside </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.473.1">PlayerPrefs.HasKey()</span></strong></span><span><span class="kobospan" id="kobo.474.1">.</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.475.1">If there is saved data, it retrieves the serialized JSON string from </span><strong class="source-inline1"><span class="kobospan" id="kobo.476.1">PlayerPrefs</span></strong> <span><span class="kobospan" id="kobo.477.1">using </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.478.1">PlayerPrefs.GetString("GameData")</span></strong></span><span><span class="kobospan" id="kobo.479.1">.</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.480.1">The JSON data is then deserialized back into a </span><strong class="source-inline1"><span class="kobospan" id="kobo.481.1">GameData</span></strong><span class="kobospan" id="kobo.482.1"> object </span><span><span class="kobospan" id="kobo.483.1">using </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.484.1">JsonUtility.FromJson&lt;GameData&gt;()</span></strong></span><span><span class="kobospan" id="kobo.485.1">.</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.486.1">Finally, the loaded game data is applied to the game state. </span><span class="kobospan" id="kobo.486.2">In this example, it seems to be setting the player’s level and experience back to their </span><span><span class="kobospan" id="kobo.487.1">saved values.</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.488.1">Overall, these functions provide a simple mechanism for saving and loading game data using PlayerPrefs, allowing for basic persistence of game state </span><span><span class="kobospan" id="kobo.489.1">between sessions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.490.1">Now that we’ve discussed the significant benefits of PlayerPrefs, let’s examine situations where it may not be the </span><span><span class="kobospan" id="kobo.491.1">optimal choice.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.492.1">Exploring the limitations and alternatives to PlayerPrefs</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.493.1">While </span><a id="_idIndexMarker401" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.494.1">PlayerPrefs offers convenience and simplicity for storing small amounts of data in Unity games, it also has several limitations and disadvantages that may prompt us to explore </span><span><span class="kobospan" id="kobo.495.1">alternative solutions:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.496.1">Limited storage capacity</span></strong><span class="kobospan" id="kobo.497.1">: PlayerPrefs has a limited storage capacity, making it unsuitable for storing large amounts of data or complex data structures. </span><span class="kobospan" id="kobo.497.2">Attempting to store excessive data in PlayerPrefs can lead to performance issues and </span><span><span class="kobospan" id="kobo.498.1">memory constraints.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.499.1">Security concerns</span></strong><span class="kobospan" id="kobo.500.1">: PlayerPrefs data is stored in plain text in the player’s registry (on Windows) or a </span><strong class="bold"><span class="kobospan" id="kobo.501.1">plist</span></strong><span class="kobospan" id="kobo.502.1"> file (on macOS and iOS), making it susceptible to tampering and unauthorized access. </span><span class="kobospan" id="kobo.502.2">For applications that require enhanced security measures or compliance with data protection regulations, PlayerPrefs may not provide adequate protection for </span><span><span class="kobospan" id="kobo.503.1">sensitive data.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.504.1">Platform dependencies</span></strong><span class="kobospan" id="kobo.505.1">: PlayerPrefs storage locations and behavior may vary across</span><a id="_idIndexMarker402" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.506.1"> different platforms and devices. </span><span class="kobospan" id="kobo.506.2">This platform dependency can introduce inconsistencies and compatibility issues when deploying games to multiple platforms, requiring developers to implement platform-specific handling or alternative </span><span><span class="kobospan" id="kobo.507.1">storage solutions.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.508.1">Limited data types</span></strong><span class="kobospan" id="kobo.509.1">: PlayerPrefs supports a limited set of data types, including integers, floats, and strings. </span><span class="kobospan" id="kobo.509.2">Complex data structures, arrays, or custom objects cannot be directly stored in PlayerPrefs without serialization and conversion, leading to additional complexity and potential </span><span><span class="kobospan" id="kobo.510.1">performance overhead.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.511.1">Persistence challenges</span></strong><span class="kobospan" id="kobo.512.1">: PlayerPrefs data is persisted across game sessions, but it may not persist across different devices or installations. </span><span class="kobospan" id="kobo.512.2">Uninstalling or reinstalling the game, clearing application data, or switching devices can result in the loss of PlayerPrefs data, affecting player progress </span><span><span class="kobospan" id="kobo.513.1">and preferences.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.514.1">Performance overhead</span></strong><span class="kobospan" id="kobo.515.1">: Accessing PlayerPrefs involves disk I/O operations, which can introduce performance overhead, especially when reading or writing large amounts of data frequently. </span><span class="kobospan" id="kobo.515.2">For applications that require high-performance data storage or real-time data access, PlayerPrefs may not meet </span><span><span class="kobospan" id="kobo.516.1">performance requirements.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.517.1">Due to these limitations and considerations, we may opt for alternative data storage solutions, such as binary serialization, JSON serialization, database systems, or cloud-based storage services. </span><span class="kobospan" id="kobo.517.2">These solutions offer greater flexibility, scalability, security, and performance for managing game data, especially in scenarios involving large datasets, complex data structures, or stringent security requirements. </span><span class="kobospan" id="kobo.517.3">While PlayerPrefs remains a convenient option for simple data storage needs, we should carefully evaluate our requirements and consider alternative solutions when designing data management systems for </span><span><span class="kobospan" id="kobo.518.1">Unity games.</span></span></p>
<h2 id="_idParaDest-103" class="calibre7"><a id="_idTextAnchor107" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.519.1">Custom Save System</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.520.1">In the </span><a id="_idIndexMarker403" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.521.1">constantly changing world of game creation, the need for strong and flexible save systems becomes more and more clear. </span><span class="kobospan" id="kobo.521.2">Enter the Custom Save System – a smart solution that’s designed to handle the complexities of data management with skill and effectiveness. </span><span class="kobospan" id="kobo.521.3">Unlike usual methods, such as PlayerPrefs, the </span><strong class="bold"><span class="kobospan" id="kobo.522.1">Custom Save System</span></strong><span class="kobospan" id="kobo.523.1"> gives us a versatile set of tools, including encryption, options for saving to the cloud, and smooth integration with </span><span><span class="kobospan" id="kobo.524.1">scriptable objects.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.525.1">Custom Save System features</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.526.1">Let’s explore </span><a id="_idIndexMarker404" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.527.1">what features we can use in our custom </span><span><span class="kobospan" id="kobo.528.1">save system:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.529.1">Generic functionality</span></strong><span class="kobospan" id="kobo.530.1">: The custom save system boasts generic functions for saving and loading data, allowing for seamless integration with various scriptable objects. </span><span class="kobospan" id="kobo.530.2">With dynamic parameters and return values tailored to the specific needs of each data type, it ensures adaptability and versatility in </span><span><span class="kobospan" id="kobo.531.1">data management.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.532.1">Encryption and decryption</span></strong><span class="kobospan" id="kobo.533.1">: Security is paramount in the world of game development. </span><span class="kobospan" id="kobo.533.2">Leveraging encryption and decryption mechanisms, the Custom Save System ensures the confidentiality and integrity of sensitive player data. </span><span class="kobospan" id="kobo.533.3">Through robust cryptographic algorithms, it guards against unauthorized access and tampering, fostering player trust </span><span><span class="kobospan" id="kobo.534.1">and confidence.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.535.1">We’ll kick things off by crafting ScriptableObjects to manage the system’s data. </span><span class="kobospan" id="kobo.535.2">I’ll draft the </span><strong class="source-inline"><span class="kobospan" id="kobo.536.1">PlayerData</span></strong><span class="kobospan" id="kobo.537.1"> script, which will store essential player information, as demonstrated in the subsequent </span><span><span class="kobospan" id="kobo.538.1">code block:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.539.1">
  [CreateAssetMenu(fileName = "PlayerData", menuName = "Data/Player Data")]
  public class PlayerData : ScriptableObject
  {
      public string playerName;
      public int playerLevel;
      public float playerExperience;
  }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.540.1">Additionally, I’ll craft a </span><a id="_idIndexMarker405" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.541.1">script for </span><strong class="source-inline"><span class="kobospan" id="kobo.542.1">GameSettings</span></strong><span class="kobospan" id="kobo.543.1">, which will store relevant game data, as exemplified in the subsequent </span><span><span class="kobospan" id="kobo.544.1">code block:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.545.1">
    [CreateAssetMenu(fileName = "GameSettings", menuName = "Data/Game Settings")]
    public class GameSettings : ScriptableObject
    {
        public int soundVolume;
        public bool isFullScreen;
        public int graphicsQuality;
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.546.1">After creating these scripts, you can right-click, select </span><strong class="bold"><span class="kobospan" id="kobo.547.1">Create</span></strong><span class="kobospan" id="kobo.548.1">, and choose </span><strong class="bold"><span class="kobospan" id="kobo.549.1">Data</span></strong><span class="kobospan" id="kobo.550.1"> to generate instances for both game settings and player data in the project. </span><span class="kobospan" id="kobo.550.2">Organize them by creating a folder named </span><strong class="source-inline"><span class="kobospan" id="kobo.551.1">Data</span></strong><span class="kobospan" id="kobo.552.1"> and placing the instances inside it. </span><span class="kobospan" id="kobo.552.2">Once you’ve done this, they’ll be structured similarly to the settings instance shown in </span><span><em class="italic"><span class="kobospan" id="kobo.553.1">Figure 6</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.554.1">.1</span></em></span><span><span class="kobospan" id="kobo.555.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer069">
<span class="kobospan" id="kobo.556.1"><img alt="Figure 6.1 – Game Settings ScriptableObject instance" src="image/B22017_06_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.557.1">Figure 6.1 – Game Settings ScriptableObject instance</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.558.1">These </span><a id="_idIndexMarker406" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.559.1">data files have been provided for demonstration purposes only, allowing you to adjust them according to your </span><span><span class="kobospan" id="kobo.560.1">project requirements.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.561.1">Next, we’ll proceed by creating a save manager script. </span><span class="kobospan" id="kobo.561.2">However, before diving into that, we must</span><a id="_idIndexMarker407" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.562.1"> integrate </span><strong class="bold"><span class="kobospan" id="kobo.563.1">NewtonSoft</span></strong><span class="kobospan" id="kobo.564.1"> into our project manually since it’s not included in Unity Editor version </span><strong class="source-inline"><span class="kobospan" id="kobo.565.1">2022.3.13</span></strong><span class="kobospan" id="kobo.566.1">. </span><span class="kobospan" id="kobo.566.2">Follow </span><span><span class="kobospan" id="kobo.567.1">these steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.568.1">Navigate to the top bar and open the </span><strong class="bold"><span class="kobospan" id="kobo.569.1">Window</span></strong><span class="kobospan" id="kobo.570.1"> menu, then select </span><strong class="bold"><span class="kobospan" id="kobo.571.1">Package Manager</span></strong><span class="kobospan" id="kobo.572.1">. </span><span class="kobospan" id="kobo.572.2">Click on the </span><strong class="bold"><span class="kobospan" id="kobo.573.1">Add</span></strong><span class="kobospan" id="kobo.574.1"> button located in the top-left corner. </span><span class="kobospan" id="kobo.574.2">This action will prompt a menu to appear, as shown in </span><span><em class="italic"><span class="kobospan" id="kobo.575.1">Figure 6</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.576.1">.2</span></em></span><span><span class="kobospan" id="kobo.577.1">:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer070">
<span class="kobospan" id="kobo.578.1"><img alt="Figure 6.2 – Adding the package from the git URL in the Package Manager panel" src="image/B22017_06_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.579.1">Figure 6.2 – Adding the package from the git URL in the Package Manager panel</span></p>
<ol class="calibre15">
<li value="2" class="calibre11"><span class="kobospan" id="kobo.580.1">Paste </span><a href="https://com.unity.nuget.newtonsoft-json" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.581.1">com.unity.nuget.newtonsoft-json</span></a><span class="kobospan" id="kobo.582.1"> into the provided panel, then click </span><strong class="bold"><span class="kobospan" id="kobo.583.1">Add</span></strong><span class="kobospan" id="kobo.584.1">, as </span><a id="_idIndexMarker408" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.585.1">depicted in </span><span><em class="italic"><span class="kobospan" id="kobo.586.1">Figure 6</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.587.1">.3</span></em></span><span><span class="kobospan" id="kobo.588.1">:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer071">
<span class="kobospan" id="kobo.589.1"><img alt="Figure 6.3 – Adding the link for the git URL in the Package Manager panel" src="image/B22017_06_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.590.1">Figure 6.3 – Adding the link for the git URL in the Package Manager panel</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.591.1">Wait for the installation</span><a id="_idIndexMarker409" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.592.1"> to finish and for Unity Editor to compile before creating the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.593.1">SaveManager</span></strong></span><span><span class="kobospan" id="kobo.594.1"> script.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.595.1">The SaveManager script</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.596.1">This</span><a id="_idIndexMarker410" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.597.1"> script is the </span><a id="_idIndexMarker411" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.598.1">fundamental component that’s responsible for saving and loading data in our game. </span><span class="kobospan" id="kobo.598.2">As mentioned earlier, this approach is not standard, but rather one method we’ll utilize for our game. </span><span class="kobospan" id="kobo.598.3">Feel free to adopt this method or implement your own approach according to your needs. </span><span class="kobospan" id="kobo.598.4">The following code block contains the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.599.1">SaveManager</span></strong></span><span><span class="kobospan" id="kobo.600.1"> script:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.601.1">
    public class SaveManager : MonoBehaviour
    {
        private const string saveFileName = "saveData1.dat";
        private const string cloudSaveFileName = "cloudSaveData.dat";
        private static byte[] key = Convert.FromBase64String("kwAXmhR48HenPp04YXrKSNfRcFSiaQx35BlHnI7kzK0=");
        private static byte[] iv = Convert.FromBase64String("GcVb7iqWex9uza+Fcb3BCQ==");
        public static void SaveData(string key, string data)
        {
            string filePath = Path.Combine(Application.persistentDataPath, saveFileName);
            // Load existing data
            Dictionary&lt;string, string&gt; savedData = LoadSavedData();
            // Add or update data based on its key
            savedData[key] = data;
            // Serialize the entire dictionary
            string jsonData = JsonConvert.SerializeObject(savedData);
            byte[] encryptedData = EncryptData(jsonData);
            // Write the serialized data to the file
            using (FileStream fileStream = new FileStream(filePath, FileMode.Create))
            {
                fileStream.Write(encryptedData, 0, encryptedData.Length);
            }
        }
        public static string LoadData(string key)
        {
            string filePath = Path.Combine(Application.persistentDataPath, saveFileName);
            // Load existing data
            Dictionary&lt;string, string&gt; savedData = LoadSavedData();
            // Extract data based on its key
            if (savedData.ContainsKey(key))
            {
                return savedData[key];
            }
            else
            {
                Debug.LogWarning("No save data found for key: " + key);
                return null;
            }
        }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.602.1">Let’s</span><a id="_idIndexMarker412" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.603.1"> take a closer look at the save and load methods that will be used from </span><span><span class="kobospan" id="kobo.604.1">other scripts:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.605.1">SaveData</span></strong></span><span><span class="kobospan" id="kobo.606.1">:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.607.1">Saves a key-value pair to </span><span><span class="kobospan" id="kobo.608.1">a file</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.609.1">Loads existing data, updates or adds new data based on the key, and serializes the dictionary </span><span><span class="kobospan" id="kobo.610.1">to JSON</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.611.1">Encrypts the JSON data and writes it to </span><span><span class="kobospan" id="kobo.612.1">the file</span></span></li></ul></li>
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.613.1">LoadData</span></strong></span><span><span class="kobospan" id="kobo.614.1">:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.615.1">Loads data from the save file based on the </span><span><span class="kobospan" id="kobo.616.1">provided key</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.617.1">Checks if the key exists in the dictionary and returns the </span><span><span class="kobospan" id="kobo.618.1">corresponding value</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.619.1">Logs a warning and returns </span><strong class="source-inline1"><span class="kobospan" id="kobo.620.1">null</span></strong><span class="kobospan" id="kobo.621.1"> if the key </span><span><span class="kobospan" id="kobo.622.1">doesn’t exist</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.623.1">The following code block contains static methods that handle input/output operations to load and save </span><span><span class="kobospan" id="kobo.624.1">game data:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.625.1">
        private static Dictionary&lt;string, string&gt; LoadSavedData()
        {
            string filePath = Path.Combine(Application.persistentDataPath, saveFileName);
            if (File.Exists(filePath))
            {
                byte[] encryptedData = File.ReadAllBytes(filePath);
                string jsonData = DecryptData(encryptedData);
                return JsonConvert.DeserializeObject&lt;Dictionary&lt;string, string&gt;&gt;(jsonData);
            }
            else
            {
                Debug.LogWarning("No save data found.");
                return new Dictionary&lt;string, string&gt;();
            }
        }
        public static void DeleteSaveData()
        {
            string filePath = Path.Combine(Application.persistentDataPath, saveFileName);
            if (File.Exists(filePath))
            {
                File.Delete(filePath);
                Debug.Log("Save data deleted.");
            }
            else
            {
                Debug.LogWarning("No save data found to delete.");
            }
        }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.626.1">Let’s take a</span><a id="_idIndexMarker413" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.627.1"> closer look at the previous </span><span><span class="kobospan" id="kobo.628.1">code block:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="source-inline1"><span class="kobospan" id="kobo.629.1">LoadSavedData</span></strong></span><span><span class="kobospan" id="kobo.630.1">:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.631.1">Loads saved data from the file and returns it as </span><span><span class="kobospan" id="kobo.632.1">a dictionary</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.633.1">Reads encrypted data, decrypts it, deserializes JSON into a dictionary, and </span><span><span class="kobospan" id="kobo.634.1">returns it</span></span></li></ul></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.635.1">DeleteSaveData</span></strong><span class="kobospan" id="kobo.636.1">: Deletes the save data file if </span><span><span class="kobospan" id="kobo.637.1">it exists</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.638.1">In the following code block, we’re dealing with encryption and decryption to secure </span><span><span class="kobospan" id="kobo.639.1">the data:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.640.1">
        private static byte[] EncryptData(string data)
        {
            using (Aes aesAlg = Aes.Create())
            {
                aesAlg.Key = key;
                aesAlg.IV = iv;
                ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);
                using (MemoryStream msEncrypt = new MemoryStream())
                {
                    using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                    {
                        using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                        {
                            swEncrypt.Write(data);
                        }
                        return msEncrypt.ToArray();
                    }
                }
            }
        }
        private static string DecryptData(byte[] encryptedData)
        {
            using (Aes aesAlg = Aes.Create())
            {
                aesAlg.Key = key;
                aesAlg.IV = iv;
                ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);
                using (MemoryStream msDecrypt = new MemoryStream(encryptedData))
                {
                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                    {
                        using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                        {
                            return srDecrypt.ReadToEnd();
                        }
                    }
                }
            }
        }
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.641.1">Let’s consider </span><a id="_idIndexMarker414" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.642.1">the encryption methods (</span><strong class="source-inline"><span class="kobospan" id="kobo.643.1">EncryptData</span></strong> <span><span class="kobospan" id="kobo.644.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.645.1">DecryptData</span></strong></span><span><span class="kobospan" id="kobo.646.1">):</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.647.1">Encrypts and decrypts data using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.648.1">AES</span></strong> <span><span class="kobospan" id="kobo.649.1">encryption algorithm</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.650.1">Encrypts input data using the encryption key and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.651.1">IV</span></strong></span><span><span class="kobospan" id="kobo.652.1"> (</span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.653.1">EncryptData</span></strong></span><span><span class="kobospan" id="kobo.654.1">)</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.655.1">Decrypts encrypted data using the same key and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.656.1">IV</span></strong></span><span><span class="kobospan" id="kobo.657.1"> (</span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.658.1">DecryptData</span></strong></span><span><span class="kobospan" id="kobo.659.1">)</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.660.1">In this script, there’s a method called </span><strong class="source-inline"><span class="kobospan" id="kobo.661.1">SaveData</span></strong><span class="kobospan" id="kobo.662.1"> for saving data. </span><span class="kobospan" id="kobo.662.2">It requires the data to be in string format, along with its corresponding key. </span><span class="kobospan" id="kobo.662.3">We have opted to store the data in a dictionary of string and string, enabling us to easily manage loading and saving data for </span><span><span class="kobospan" id="kobo.663.1">various files.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.664.1">For loading, we’re decrypting the string data and then </span><span><span class="kobospan" id="kobo.665.1">loading it.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.666.1">Additionally, I’ve implemented </span><strong class="bold"><span class="kobospan" id="kobo.667.1">AES encryption</span></strong><span class="kobospan" id="kobo.668.1"> methods to secure the data during encryption and </span><a id="_idIndexMarker415" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.669.1">decryption processes. </span><span class="kobospan" id="kobo.669.2">While the details of AES encryption are beyond the scope of this book, you’re encouraged to explore it further if you’re interested in learning about </span><span><span class="kobospan" id="kobo.670.1">encryption techniques</span></span><span><span class="kobospan" id="kobo.671.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.672.1">To facilitate</span><a id="_idIndexMarker416" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.673.1"> the generation of keys and IV, I’ve prepared a helper script. </span><span class="kobospan" id="kobo.673.2">You can utilize this script by attaching it to a GameObject within your scene. </span><span class="kobospan" id="kobo.673.3">This script will enable you to create the necessary key and IV for encryption purposes. </span><span class="kobospan" id="kobo.673.4">You can find the generated keys in the </span><strong class="source-inline"><span class="kobospan" id="kobo.674.1">SaveManager</span></strong><span class="kobospan" id="kobo.675.1"> script; there’s no need to repeat the creation process as it only </span><span><span class="kobospan" id="kobo.676.1">occurs once.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.677.1">You can obtain the </span><strong class="source-inline"><span class="kobospan" id="kobo.678.1">KeyAndIVGenerator</span></strong><span class="kobospan" id="kobo.679.1"> script from the following </span><span><span class="kobospan" id="kobo.680.1">code block:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.681.1">
public class KeyAndIVGenerator : MonoBehaviour
{
    public static void GenerateKeyAndIV()
    {
        using (Aes aes = Aes.Create())
        {
            aes.GenerateKey();
            aes.GenerateIV();
            // Convert key and IV to base64 strings for easy storage and usage
            string base64Key = Convert.ToBase64String(aes.Key);
            string base64IV = Convert.ToBase64String(aes.IV);
            Debug.Log("Generated Key: " + base64Key);
            Debug.Log("Generated IV: " + base64IV);
        }
    }
    private void Start()
    {
        GenerateKeyAndIV();
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.682.1">Here’s an</span><a id="_idIndexMarker417" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.683.1"> explanation of the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.684.1">KeyAndIVGenerator</span></strong></span><span><span class="kobospan" id="kobo.685.1"> class:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.686.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.687.1">KeyAndIVGenerator</span></strong><span class="kobospan" id="kobo.688.1"> class contains a method named </span><strong class="source-inline1"><span class="kobospan" id="kobo.689.1">GenerateKeyAndIV</span></strong><span class="kobospan" id="kobo.690.1">, which is responsible </span><a id="_idIndexMarker418" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.691.1">for generating encryption keys and </span><strong class="bold"><span class="kobospan" id="kobo.692.1">initialization </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.693.1">vectors</span></strong></span><span><span class="kobospan" id="kobo.694.1"> (</span></span><span><strong class="bold"><span class="kobospan" id="kobo.695.1">IVs</span></strong></span><span><span class="kobospan" id="kobo.696.1">).</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.697.1">Inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.698.1">GenerateKeyAndIV</span></strong><span class="kobospan" id="kobo.699.1"> method, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.700.1">KeyAndIVGenerator</span></strong><span class="kobospan" id="kobo.701.1"> class creates an instance of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.702.1">Aes</span></strong><span class="kobospan" id="kobo.703.1"> class using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.704.1">Aes.Create()</span></strong><span class="kobospan" id="kobo.705.1"> method, which represents the </span><span><span class="kobospan" id="kobo.706.1">AES algorithm.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.707.1">Then, it calls the </span><strong class="source-inline1"><span class="kobospan" id="kobo.708.1">GenerateKey()</span></strong><span class="kobospan" id="kobo.709.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.710.1">GenerateIV()</span></strong><span class="kobospan" id="kobo.711.1"> methods on the </span><strong class="source-inline1"><span class="kobospan" id="kobo.712.1">Aes</span></strong><span class="kobospan" id="kobo.713.1"> instance to generate a random encryption key </span><span><span class="kobospan" id="kobo.714.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.715.1">IV</span></strong></span><span><span class="kobospan" id="kobo.716.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.717.1">After generating the key and </span><strong class="source-inline1"><span class="kobospan" id="kobo.718.1">IV</span></strong><span class="kobospan" id="kobo.719.1">, it converts them into base64 strings using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.720.1">Convert.ToBase64String()</span></strong><span class="kobospan" id="kobo.721.1"> method. </span><strong class="source-inline1"><span class="kobospan" id="kobo.722.1">Base64</span></strong><span class="kobospan" id="kobo.723.1"> encoding is used for easy storage and usage of the key </span><span><span class="kobospan" id="kobo.724.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.725.1">IV</span></strong></span><span><span class="kobospan" id="kobo.726.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.727.1">Finally, it logs the generated key and </span><strong class="source-inline1"><span class="kobospan" id="kobo.728.1">IV</span></strong><span class="kobospan" id="kobo.729.1"> to the console using </span><strong class="source-inline1"><span class="kobospan" id="kobo.730.1">Debug.Log()</span></strong><span class="kobospan" id="kobo.731.1"> for </span><span><span class="kobospan" id="kobo.732.1">debugging purposes.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.733.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.734.1">Start</span></strong><span class="kobospan" id="kobo.735.1"> method is called when the </span><strong class="source-inline1"><span class="kobospan" id="kobo.736.1">KeyAndIVGenerator</span></strong><span class="kobospan" id="kobo.737.1"> object is initialized, and it invokes the </span><strong class="source-inline1"><span class="kobospan" id="kobo.738.1">GenerateKeyAndIV</span></strong><span class="kobospan" id="kobo.739.1"> method to generate the key and </span><strong class="source-inline1"><span class="kobospan" id="kobo.740.1">IV</span></strong><span class="kobospan" id="kobo.741.1"> when the </span><span><span class="kobospan" id="kobo.742.1">object starts.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.743.1">Overall, this code block demonstrates how to generate encryption keys and </span><strong class="source-inline"><span class="kobospan" id="kobo.744.1">IV</span></strong><span class="kobospan" id="kobo.745.1"> values using the AES algorithm and convert them into </span><strong class="source-inline"><span class="kobospan" id="kobo.746.1">base64</span></strong><span class="kobospan" id="kobo.747.1"> strings for storage and usage. </span><span class="kobospan" id="kobo.747.2">This is commonly used in cryptography for </span><span><span class="kobospan" id="kobo.748.1">securing data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.749.1">The following code block provides an example of the </span><strong class="source-inline"><span class="kobospan" id="kobo.750.1">GameManager</span></strong><span class="kobospan" id="kobo.751.1"> script, which utilizes the</span><a id="_idIndexMarker419" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.752.1"> save and load methods from </span><strong class="source-inline"><span class="kobospan" id="kobo.753.1">SaveManager</span></strong><span class="kobospan" id="kobo.754.1"> to manage the process of saving and loading </span><strong class="source-inline"><span class="kobospan" id="kobo.755.1">PlayerData</span></strong> <span><span class="kobospan" id="kobo.756.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.757.1">GameSettings</span></strong></span><span><span class="kobospan" id="kobo.758.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.759.1">
    public class GameManager : MonoBehaviour
    {
        public PlayerData playerData;
        public GameSettings gameSettings;
        private void Start()
        {
            LoadGameData();
        }
        private void OnApplicationQuit()
        {
            SaveGameData();
         }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.760.1">Let’s consider the Unity </span><span><span class="kobospan" id="kobo.761.1">callback functions:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.762.1">In the </span><strong class="source-inline1"><span class="kobospan" id="kobo.763.1">Start</span></strong><span class="kobospan" id="kobo.764.1"> method, it calls the </span><strong class="source-inline1"><span class="kobospan" id="kobo.765.1">LoadGameData</span></strong><span class="kobospan" id="kobo.766.1"> function to load the player data and game settings when the </span><span><span class="kobospan" id="kobo.767.1">game starts</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.768.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.769.1">OnApplicationQuit</span></strong><span class="kobospan" id="kobo.770.1"> method is invoked when the application is about to quit, and it calls the </span><strong class="source-inline1"><span class="kobospan" id="kobo.771.1">SaveGameData</span></strong><span class="kobospan" id="kobo.772.1"> function to save the player data and game settings </span><span><span class="kobospan" id="kobo.773.1">before exiting</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.774.1">The following code block contains the logic for loading and </span><span><span class="kobospan" id="kobo.775.1">saving data:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.776.1">
        private void LoadGameData()
        {
            if (playerData == null)
            {
            }
            else
            {
                JsonUtility.FromJsonOverwrite(SaveManager.LoadData("playerData"), playerData);
            }
            if (gameSettings == null)
            {
                gameSettings = ScriptableObject.CreateInstance&lt;GameSettings&gt;();
            }
            else
            {  JsonUtility.FromJsonOverwrite(SaveManager.LoadData("gameSettings"), gameSettings);
            }
        }
        private void SaveGameData()
        {
            SaveManager.SaveData("playerData", JsonUtility.ToJson(playerData));
            SaveManager.SaveData("gameSettings", JsonUtility.ToJson(gameSettings));
        }
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.777.1">Let’s take a closer look at the saving and </span><span><span class="kobospan" id="kobo.778.1">loading functions:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.779.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.780.1">LoadGameData</span></strong><span class="kobospan" id="kobo.781.1"> function loads the player data and game settings from the save files using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.782.1">SaveManager.LoadData</span></strong><span class="kobospan" id="kobo.783.1"> method. </span><span class="kobospan" id="kobo.783.2">If the data is not found, it creates new instances of </span><strong class="source-inline1"><span class="kobospan" id="kobo.784.1">PlayerData</span></strong> <span><span class="kobospan" id="kobo.785.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.786.1">GameSettings</span></strong></span><span><span class="kobospan" id="kobo.787.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.788.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.789.1">SaveGameData</span></strong><span class="kobospan" id="kobo.790.1"> function saves the player data and game settings to the save files using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.791.1">SaveManager.SaveData</span></strong><span class="kobospan" id="kobo.792.1"> method. </span><span class="kobospan" id="kobo.792.2">It converts the data objects into JSON format using </span><strong class="source-inline1"><span class="kobospan" id="kobo.793.1">JsonUtility.ToJson</span></strong> <span><span class="kobospan" id="kobo.794.1">before saving.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.795.1">Overall, this</span><a id="_idIndexMarker420" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.796.1"> code block demonstrates a basic implementation of loading and saving game data using JSON serialization. </span><span class="kobospan" id="kobo.796.2">It ensures that the player data and game settings are persisted across game sessions, allowing for a seamless </span><span><span class="kobospan" id="kobo.797.1">gaming experience.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.798.1">In this section, we learned how to save and load scriptable objects, the techniques of saving and loading to a file, encrypting using AES to protect the data, and how to generate encryption keys. </span><span class="kobospan" id="kobo.798.2">Finally, we’ve practiced using these </span><span><span class="kobospan" id="kobo.799.1">concepts practically.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.800.1">Now, we need to understand the benefits of using a custom approach </span><span><span class="kobospan" id="kobo.801.1">over PlayerPrefs.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.802.1">Advantages over PlayerPrefs</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.803.1">While </span><a id="_idIndexMarker421" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.804.1">PlayerPrefs offers simplicity, the Custom Save System goes beyond its limitations, providing a variety of features and functionalities unmatched by traditional storage methods. </span><span class="kobospan" id="kobo.804.2">By reducing performance overhead and improving data security, it marks a new era of data management in Unity </span><span><span class="kobospan" id="kobo.805.1">game development.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.806.1">To summarize, the Custom Save System represents innovation and creativity – a testament to the ongoing pursuit of excellence in game development. </span><span class="kobospan" id="kobo.806.2">With its capacity to streamline data management, enhance security measures, and improve player experiences, it has become the cornerstone of modern game development practices, reshaping the landscape with </span><span><span class="kobospan" id="kobo.807.1">each save.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.808.1">In the next section, we are going to implement ScriptableObjects with the player progress part of our game while saving and </span><span><span class="kobospan" id="kobo.809.1">loading data.</span></span></p>
<h1 id="_idParaDest-104" class="calibre5"><a id="_idTextAnchor108" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.810.1">Data-driven gameplay with C#</span></h1>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.811.1">Data-driven design</span></strong><span class="kobospan" id="kobo.812.1"> is an approach to game development where game behavior, content, and</span><a id="_idIndexMarker422" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.813.1"> configuration are defined and controlled by external data files rather than hardcoded into the game’s source code. </span><span class="kobospan" id="kobo.813.2">This approach offers several benefits, including increased flexibility, easier content iteration, and enhanced maintainability. </span><span class="kobospan" id="kobo.813.3">By separating game data from code, we can modify game behavior, tweak parameters, and add new content without requiring code changes, thus accelerating iteration cycles and empowering designers to experiment with </span><span><span class="kobospan" id="kobo.814.1">gameplay mechanics.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.815.1">Let’s begin with one of the uses of ScriptableObjects for </span><span><span class="kobospan" id="kobo.816.1">managing data.</span></span></p>
<h2 id="_idParaDest-105" class="calibre7"><a id="_idTextAnchor109" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.817.1">Creating data for stats</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.818.1">We have</span><a id="_idIndexMarker423" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.819.1"> the </span><strong class="source-inline"><span class="kobospan" id="kobo.820.1">PlayerMovement</span></strong><span class="kobospan" id="kobo.821.1"> script in our project, as shown in the following code block, which handles the </span><span><span class="kobospan" id="kobo.822.1">player’s movement:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.823.1">
   public class PlayerMovement : MonoBehaviour
   {
       public float moveSpeed = 5f;
       public float jumpForce = 5f;
       public float dashForce = 10f;
       public float dashCooldown = 2f;
       public Transform groundChecker;
       public LayerMask groundLayer;
       public float groundDistance;
       public Rigidbody playerRigidbody;
       private bool isGrounded = true;
       private bool canDash = true;
       private Vector3 movementVector;
  private void MovePlayer()
  {
      Vector3 movement = new Vector3(movementVector.x , 0f , movementVector.y) * moveSpeed * Time.deltaTime;
      transform.Translate(movement);
  }
//rest of code
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.824.1">Here, we </span><a id="_idIndexMarker424" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.825.1">can create a ScriptableObject that will contain the parameters of player movement, such as speed and force. </span><span class="kobospan" id="kobo.825.2">Then, we can obtain a reference to </span><span><span class="kobospan" id="kobo.826.1">that ScriptableObject.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.827.1">The following code block contains a ScriptableObject named </span><strong class="source-inline"><span class="kobospan" id="kobo.828.1">PlayerStats</span></strong><span class="kobospan" id="kobo.829.1"> that will store </span><span><span class="kobospan" id="kobo.830.1">movement data:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.831.1">
[CreateAssetMenu(fileName = "PlayerStats", menuName = "Data/Player Stats")]
 public class PlayerStats : ScriptableObject
 {
     [SerializeField] float moveSpeed = 5f;
     [SerializeField] float jumpForce = 5f;
     [SerializeField] float dashForce = 10f;
     [SerializeField] float dashCooldown = 2f;
     public float MoveSpeed { get =&gt; moveSpeed; set =&gt; moveSpeed = value; }
     public float JumpForce { get =&gt; jumpForce; set =&gt; jumpForce = value; }
     public float DashForce { get =&gt; dashForce; set =&gt; dashForce = value; }
     public float DashCooldown { get =&gt; dashCooldown; set =&gt; dashCooldown = value; }
 }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.832.1">Now, we can </span><a id="_idIndexMarker425" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.833.1">utilize the </span><strong class="source-inline"><span class="kobospan" id="kobo.834.1">PlayerStats</span></strong><span class="kobospan" id="kobo.835.1"> ScriptableObject as a variable within the player movement script and substitute any previous logic that used the movement variables with the player </span><span><span class="kobospan" id="kobo.836.1">stats accordingly:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.837.1">
  public class PlayerMovement : MonoBehaviour
  {
      public PlayerStats playerStats;
      public Transform groundChecker;
      public LayerMask groundLayer;
      public float groundDistance;
      public Rigidbody playerRigidbody;
      private bool isGrounded = true;
      private bool canDash = true;
      private Vector3 movementVector;
      private void MovePlayer()
      {
        Vector3 movement = new Vector3(movementVector.x , 0f , movementVector.y) * playerStats.MoveSpeed * Time.deltaTime;
        transform.Translate(movement);
      }
  //rest of code
  }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.838.1">We did this </span><a id="_idIndexMarker426" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.839.1">because we require a single reference for all movement parameters, and it will be convenient later to apply or adjust the stats from other scripts, such as special power-ups, without altering the code within the player movement script. </span><span class="kobospan" id="kobo.839.2">We can directly modify the ScriptableObject, and it will impact the </span><span><span class="kobospan" id="kobo.840.1">player’s movement.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.841.1">Moreover, if we include items in our game, consolidating all data into individual ScriptableObjects for each type of item would streamline usage and modifications across all objects. </span><span class="kobospan" id="kobo.841.2">Without directly referencing those objects, we can alter the data file, and it will impact all objects utilizing </span><span><span class="kobospan" id="kobo.842.1">that data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.843.1">Let’s consider another use </span><span><span class="kobospan" id="kobo.844.1">for ScriptableObjects.</span></span></p>
<h2 id="_idParaDest-106" class="calibre7"><a id="_idTextAnchor110" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.845.1">Challenge system</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.846.1">We can </span><a id="_idIndexMarker427" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.847.1">utilize ScriptableObjects for player progression within challenges, allowing us to effectively track challenges and save the </span><span><span class="kobospan" id="kobo.848.1">progress made.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.849.1">We will commence by migrating </span><strong class="source-inline"><span class="kobospan" id="kobo.850.1">CommonChallengeData</span></strong><span class="kobospan" id="kobo.851.1"> into a ScriptableObject, as demonstrated in the following </span><span><span class="kobospan" id="kobo.852.1">code block:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.853.1">
    [CreateAssetMenu(fileName = "CommonChallengeData", menuName = "Data/Common Challenge Data")]
    [Serializable]
    public class CommonChallengeData : ScriptableObject
    {
        public bool isCompleted;
        public RewardType rewardType; // Type of reward
        public int rewardAmount;      // Amount or value of the reward
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.854.1">Then, upon </span><a id="_idIndexMarker428" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.855.1">completion of the challenge, we can utilize the save manager we previously established to store the challenge statistics. </span><span class="kobospan" id="kobo.855.2">This can be seen in the </span><strong class="source-inline"><span class="kobospan" id="kobo.856.1">CompleteChallenge</span></strong><span class="kobospan" id="kobo.857.1"> function within </span><strong class="source-inline"><span class="kobospan" id="kobo.858.1">EnemyWavesChallenge</span></strong><span class="kobospan" id="kobo.859.1"> in the following </span><span><span class="kobospan" id="kobo.860.1">code block:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.861.1">
    public class EnemyWavesChallenge : BaseChallenge
    {
        //Rest of Code
        public override void CompleteChallenge()
        {
            if (!commonData.isCompleted)
            {
                RewardManager.Instance.GrantReward(commonData);
                commonData.isCompleted = true;
                SaveManager.SaveData(challengeSavedKey, JsonUtility.ToJson(commonData));
            }
            else
            {
                Debug.Log("Challenge already completed!");
            }
        }
        //Rest of code
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.862.1">We included </span><a id="_idIndexMarker429" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.863.1">the last line in the </span><strong class="source-inline"><span class="kobospan" id="kobo.864.1">CompleteChallenge</span></strong><span class="kobospan" id="kobo.865.1"> method to save the challenge data within the completion function of the challenge. </span><span class="kobospan" id="kobo.865.2">Thus, before commencing the challenge, we will verify its completion status in the </span><span><span class="kobospan" id="kobo.866.1">challenge manager.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.867.1">Additionally, we must utilize the data loading functionality from the </span><strong class="source-inline"><span class="kobospan" id="kobo.868.1">SaveManager</span></strong><span class="kobospan" id="kobo.869.1"> script within the </span><strong class="source-inline"><span class="kobospan" id="kobo.870.1">StartChallenge</span></strong><span class="kobospan" id="kobo.871.1"> function inside </span><strong class="source-inline"><span class="kobospan" id="kobo.872.1">ChallengeManager</span></strong><span class="kobospan" id="kobo.873.1">, as illustrated in the following </span><span><span class="kobospan" id="kobo.874.1">code block:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.875.1">
    public class ChallengeManager : Singlton&lt;ChallengeManager&gt;
    {
        //Rest of code
        public void StartChallenge(ChallengeType challengeType)
        {
            if (challengeDictionary.TryGetValue(challengeType, out BaseChallenge challengeScript))
            {
                JsonUtility.FromJsonOverwrite(SaveManager.LoadData(challengeScript.challengeSavedKey), challengeScript.commonData);
                if (!challengeScript.commonData.isCompleted)
                {
                    SetCurrentChallenge(challengeScript);
                    currentChallenge.StartChallenge();
                }
                else
                {
                    Debug.Log("Challenge already completed!");
                }
            }
            else
            {
                Debug.LogError($"No challenge script found for ChallengeType {challengeType}");
            }
        }
//Rest of code
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.876.1">This is a </span><a id="_idIndexMarker430" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.877.1">straightforward method to transition existing code for utilizing ScriptableObjects or an improved data management approach. </span><span class="kobospan" id="kobo.877.2">Furthermore, it integrates saving and loading functionalities to monitor challenge progress. </span><span class="kobospan" id="kobo.877.3">While designing the system from scratch would offer a better data handling strategy, this system was constructed differently. </span><span class="kobospan" id="kobo.877.4">We had the opportunity to modify it in this chapter, emphasizing the importance of adapting existing code bases. </span><span class="kobospan" id="kobo.877.5">We’ll delve deeper into refining these skills in </span><a href="B22017_07.xhtml#_idTextAnchor112" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.878.1">Chapter 7</span></em></span></a><span><span class="kobospan" id="kobo.879.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.880.1">To summarize, data-driven gameplay</span><a id="_idIndexMarker431" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.881.1"> with C# offers a powerful framework for creating dynamic, customizable, and immersive gaming experiences. </span><span class="kobospan" id="kobo.881.2">By embracing data-driven design principles, and leveraging ScriptableObjects for modular gameplay elements, we can build flexible, extensible, and engaging games that captivate players and stand the test </span><span><span class="kobospan" id="kobo.882.1">of time.</span></span></p>
<h1 id="_idParaDest-107" class="calibre5"><a id="_idTextAnchor111" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.883.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.884.1">In this chapter, we delved into concepts and techniques that are vital for efficient game development. </span><span class="kobospan" id="kobo.884.2">We began by exploring the importance of data structures and their impact on game performance, emphasizing the significance of choosing the appropriate data structure for optimal results. </span><span class="kobospan" id="kobo.884.3">Serialization in Unity took center stage as we navigated Unity’s serialization options, including XML, JSON, and binary serialization methods. </span><span class="kobospan" id="kobo.884.4">We discussed the nuances of each serialization method and its suitability for different scenarios, laying the groundwork for robust data management in </span><span><span class="kobospan" id="kobo.885.1">Unity projects.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.886.1">We continued by doing a deep dive into PlayerPrefs and its limitations in Unity game development, paving the way for the Custom Save System. </span><span class="kobospan" id="kobo.886.2">Through detailed discussions and practical examples, we unveiled the features and advantages of the Custom Save System over PlayerPrefs, highlighting its role in elevating data-driven gameplay experiences. </span><span class="kobospan" id="kobo.886.3">The </span><strong class="source-inline"><span class="kobospan" id="kobo.887.1">SaveManager</span></strong><span class="kobospan" id="kobo.888.1"> Script emerged as a pivotal component, facilitating seamless data saving and loading operations with enhanced efficiency and flexibility. </span><span class="kobospan" id="kobo.888.2">By leveraging C# and scriptableObjects, we are empowered to embrace data-driven gameplay mechanics and optimize the challenge system for enhanced user engagement and progression. </span><span class="kobospan" id="kobo.888.3">Through meticulous exploration and hands-on learning, this chapter has equipped us with the knowledge and tools needed to master data organization and serialization in Unity </span><span><span class="kobospan" id="kobo.889.1">with C#.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.890.1">In </span><a href="B22017_07.xhtml#_idTextAnchor112" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.891.1">Chapter 7</span></em></span></a><span class="kobospan" id="kobo.892.1">, we’ll dive into the realm of collaborative game development and version control systems. </span><span class="kobospan" id="kobo.892.2">Building on our foundational knowledge, we’ll explore how to effectively contribute to existing code bases and collaborate within development teams using C#. </span><span class="kobospan" id="kobo.892.3">From understanding version control systems to mastering code merging and conflict resolution techniques, we’ll equip ourselves with essential skills to navigate shared code repositories seamlessly. </span><span class="kobospan" id="kobo.892.4">Through practical examples and step-by-step guidance, we’ll learn about the intricacies of collaborating with shared code repositories and maintaining code quality in a team environment. </span><span class="kobospan" id="kobo.892.5">Join us as we delve deeper into the collaborative aspects of game development, paving the way for enhanced teamwork and code </span><span><span class="kobospan" id="kobo.893.1">management practices.</span></span></p>
</div>
</body></html>