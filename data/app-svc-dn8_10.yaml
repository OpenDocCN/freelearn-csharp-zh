- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Building Serverless Nanoservices Using Azure Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure 函数构建无服务器纳米服务
- en: In this chapter, you will be introduced to Azure Functions, which can be configured
    to only require server-side resources while they execute. They execute when they
    are triggered by an activity like a message sent to a queue or a file uploaded
    to Azure Storage, or at a regularly scheduled interval.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解 Azure 函数，它可以配置为在执行时仅需要服务器端资源。它们在触发活动时执行，例如向队列发送消息或将文件上传到 Azure 存储时，或者在定期的时间间隔内。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding Azure Functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Azure 函数
- en: Building an Azure Functions project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 Azure 函数项目
- en: Responding to timer and resource triggers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应定时器和资源触发器
- en: Publishing an Azure Functions project to the cloud
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Azure 函数项目发布到云端
- en: Cleaning up Azure Functions resources
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理 Azure 函数资源
- en: Understanding Azure Functions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Azure 函数
- en: '**Azure Functions** is an event-driven serverless compute platform. You can
    build and debug locally and later deploy to Microsoft Azure cloud. Azure Functions
    can be implemented in many languages, not just C# and .NET. It has extensions
    for Visual Studio 2022 and Visual Studio Code and a command-line tool.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure 函数**是一个事件驱动的无服务器计算平台。您可以在本地构建和调试，然后部署到微软 Azure 云。Azure 函数可以使用多种语言实现，而不仅仅是
    C# 和 .NET。它支持 Visual Studio 2022 和 Visual Studio Code 的扩展，以及一个命令行工具。'
- en: But first, you might be wondering, “How is it possible to have a service without
    a server?”
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，你可能想知道，“没有服务器如何提供服务？”
- en: '*Serverless* does not literally mean there is no server. What serverless means
    is a service without a *permanently running server*, and usually that means not
    running for most of the time or running with low resources and scaling up dynamically
    when needed. This can save a lot of costs.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*无服务器*字面上并不意味着没有服务器。无服务器真正意味着的是一个没有*永久运行服务器*的服务，通常这意味着大部分时间不运行或资源使用低，并在需要时动态扩展。这可以节省很多成本。'
- en: For example, organizations often have business functions that only need to run
    once per hour, once per month, or on an ad hoc basis. Perhaps the organization
    prints checks (cheques in England) to pay its employees at the end of the month.
    Those checks might need the salary amounts converted to words to print on the
    check. A function to convert numbers to words could be implemented as a serverless
    service.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，组织通常有一些只需要每小时运行一次、每月运行一次或按需运行的业务功能。也许组织在月底打印支票（在英国称为cheques）来支付员工的工资。这些支票可能需要将工资金额转换为文字以打印在支票上。可以将将数字转换为文字的功能实现为一个无服务器服务。
- en: For another example, with a content management system, editors might upload
    new images, and those images might need to be processed in various ways, like
    generating thumbnails and other optimizations. This work can be added to a queue,
    or an Azure function can be triggered when the file is uploaded to Blob Storage.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用内容管理系统，编辑器可能会上传新的图片，这些图片可能需要以各种方式处理，如生成缩略图和其他优化。这项工作可以添加到队列中，或者当文件上传到 Blob
    存储时触发 Azure 函数。
- en: Azure Functions can be much more than just a single function. They support complex,
    stateful, workflows and event-driven solutions using **Durable Functions**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 函数可以远不止是一个单一的功能。它们支持复杂的状态化工作流和事件驱动的解决方案，使用**Durable Functions**。
- en: 'I do not cover Durable Functions in this book, so if you are interested, you
    can learn more about implementing them using C# and .NET at the following link:
    [https://learn.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-overview?tabs=csharp](https://learn.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-overview?tabs=csharp).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这本书中不涉及 Durable Functions，如果您感兴趣，可以在此链接中了解更多关于使用 C# 和 .NET 实现它们的信息：[https://learn.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-overview?tabs=csharp](https://learn.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-overview?tabs=csharp)。
- en: Azure Functions has a programming model based on triggers and bindings that
    enable your serverless service to respond to events and connect to other services
    like data stores.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 函数基于触发器和绑定的编程模型，使你的无服务器服务能够响应事件并连接到其他服务，如数据存储。
- en: Azure Functions triggers and bindings
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure 函数触发器和绑定
- en: '**Triggers** and **bindings** are key concepts for Azure Functions.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**触发器**和**绑定**是 Azure 函数的关键概念。'
- en: 'Triggers are what cause a function to execute. Each function must have one,
    and only one, trigger. The most common triggers are shown in the following list:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器是导致函数执行的原因。每个函数必须有一个，且只有一个触发器。以下列出了最常见的触发器：
- en: '**HTTP**: This trigger responds to an incoming HTTP request, typically a `GET`
    or `POST`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP**: 此触发器响应传入的 HTTP 请求，通常是 `GET` 或 `POST`。'
- en: '**Azure SQL**: This trigger responds when a change is detected on a SQL table.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure SQL**: 此触发器在检测到 SQL 表上的更改时响应。'
- en: '**Cosmos DB**: This trigger uses the Cosmos DB Change Feed to listen for inserts
    and updates.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cosmos DB**: 此触发器使用 Cosmos DB 变更流来监听插入和更新。'
- en: '**Timer**: This trigger responds to a scheduled time occurring. It does not
    retry if a function fails. The function is not called again until the next time
    on the schedule.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Timer**: 此触发器响应预定时间的到来。如果函数失败，则不会重试。直到下一次预定时间，函数不会被再次调用。'
- en: '**SignalR**: This trigger responds to messages sent from Azure SignalR Service.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SignalR**: 此触发器响应来自 Azure SignalR 服务的消息。'
- en: '**Queue** and **RabbitMQ**: These triggers respond to a message arriving in
    a queue ready for processing.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列**和**RabbitMQ**: 这些触发器响应队列中到达的消息，准备进行处理。'
- en: '**Blob Storage**: This trigger responds to a new or updated **binary large
    object** (**Blob**).'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blob Storage**: 此触发器响应新的或更新的 **二进制大对象** (**Blob**)。'
- en: '**Event Grid** and **Event Hub**: These triggers respond when a predefined
    event occurs.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Event Grid**和**Event Hub**: 这些触发器在预定义的事件发生时响应。'
- en: 'Bindings allow functions to have inputs and outputs. Each function can have
    zero, one, or more bindings. Some common bindings are shown in the following list:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定允许函数有输入和输出。每个函数可以有零个、一个或多个绑定。以下列出了一些常见的绑定：
- en: '**Azure SQL**: Read or write to a table in a SQL Server database.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure SQL**: 在 SQL Server 数据库中读取或写入表。'
- en: '**Blob Storage**: Read or write to any file stored as a BLOB.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blob Storage**: 读取或写入存储为 BLOB 的任何文件。'
- en: '**Cosmos DB**: Read or write documents to a cloud-scale data store.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cosmos DB**: 读取或写入云规模数据存储中的文档。'
- en: '**SignalR**: Receive or make remote method calls.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SignalR**: 接收或执行远程方法调用。'
- en: '**HTTP**: Make an HTTP request and receive the response.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP**: 发起 HTTP 请求并接收响应。'
- en: '**Queue** and **RabbitMQ**: Write a message to a queue or read a message from
    a queue.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列**和**RabbitMQ**: 向队列写入消息或从队列读取消息。'
- en: '**SendGrid**: Send an email message.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SendGrid**: 发送电子邮件消息。'
- en: '**Twilio**: Send an SMS message.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Twilio**: 发送短信消息。'
- en: '**IoT hub**: Write to an internet-connected device.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IoT hub**: 向互联网连接的设备写入。'
- en: 'You can see the full list of supported triggers and bindings at the following
    link: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings?tabs=csharp#supported-bindings](https://learn.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings?tabs=csharp#supported-bindings).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中查看支持的触发器和绑定的完整列表：[https://learn.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings?tabs=csharp#supported-bindings](https://learn.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings?tabs=csharp#supported-bindings)。
- en: Triggers and bindings are configured differently for different languages. For
    C# and Java, you decorate methods and parameters with attributes. For the other
    languages, you configure a file named `function.json`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器和绑定对于不同的语言配置方式不同。对于 C# 和 Java，你需要在方法和参数上使用属性进行装饰。对于其他语言，你需要配置一个名为 `function.json`
    的文件。
- en: NCRONTAB expressions
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NCRONTAB 表达式
- en: The **Timer** trigger uses **NCRONTAB expressions** to define the frequency
    of the timer. The default time zone is **Coordinated Universal Time** (**UTC**).
    This can be overridden but you really should use UTC for the reasons you learned
    about in *Chapter 7*, *Handling Dates, Times, and Internationalization*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**Timer** 触发器使用 **NCRONTAB 表达式**来定义计时器的频率。默认时区是 **协调世界时** (**UTC**)。这可以被覆盖，但你真的应该使用
    UTC，原因你已经在 *第7章*，*处理日期、时间和国际化* 中了解到了。'
- en: If you are hosting in an App Service plan, then you can alternatively use a
    `TimeSpan`, but I recommend learning NCRONTAB expressions for flexibility.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是在 App Service 计划中托管，那么你可以使用 `TimeSpan` 作为替代，但我推荐学习 NCRONTAB 表达式以获得灵活性。
- en: 'An NCRONTAB expression consists of five or six parts (if seconds are included):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: NCRONTAB 表达式由五个或六个部分组成（如果包含秒数）：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A star `*` in the value field above means all legal values, as in parentheses
    for that column. You can specify ranges using a hyphen, and a step value using
    `/`. Here are some examples of how values can be specified in this format:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的值字段中的星号 `*` 表示该列的所有合法值，就像括号中的那样。你可以使用破折号指定范围，并使用 `/` 指定步长值。以下是一些如何以这种格式指定值的示例：
- en: '`0` means at that value. For example, for hours, at midnight.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 表示该值。例如，对于小时，表示午夜。'
- en: '`0,6,12,18` means at those listed values. For example, for hours, at midnight,
    6 a.m., 12 noon, and 6 p.m.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0,6,12,18` 表示那些列出的值。例如，对于小时，表示午夜、上午6点、中午12点和下午6点。'
- en: '`3-7` means at that inclusive range of values. For example, for hours, at 3
    a.m., 4 a.m., 5 a.m., 6 a.m., and 7 a.m.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3-7` 表示该值的包含范围。例如，对于小时，表示上午3点、上午4点、上午5点、上午6点和上午7点。'
- en: '`4/3` means a start value of `4` and a step value of `3`. For example, for
    hours, at 4 a.m., 7 a.m., 10 a.m., 1 p.m., 4 p.m., 7 p.m., and 10 p.m.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4/3` 表示起始值为 `4`，步长值为 `3`。例如，对于小时，表示上午4点、上午7点、上午10点、下午1点、下午4点、下午7点和晚上10点。'
- en: '*Table 10.1* shows some more examples:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*表10.1* 显示了一些更多示例：'
- en: '| **Expression** | **Description** |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **描述** |'
- en: '| `0 5 * * * *` | Once every hour of the day at minute 5 of each hour. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `0 5 * * * *` | 每小时一次，在每小时的第5分钟。|'
- en: '| `0 0,10,30,40 * * * *` | Four times an hour – at minutes 0, 10, 30, and 40
    during every hour. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `0 0,10,30,40 * * * *` | 每小时四次 – 在每个小时的第0分钟、第10分钟、第30分钟和第40分钟。|'
- en: '| `* * */2 * * *` | Every 2 hours. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `* * */2 * * *` | 每2小时一次。|'
- en: '| `0,15 * * * * *` | At 0 and 15 seconds every minute. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `0,15 * * * * *` | 每分钟的第0秒和第15秒。|'
- en: '| `0/15 * * * * *` | At 0, 15, 30, and 45 seconds every minute, aka every 15
    seconds. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `0/15 * * * * *` | 每分钟的第0秒、第15秒、第30秒和第45秒，也称为每15秒一次。|'
- en: '| `0-15 * * * * *` | At 0, 1, 2, 3, and so on up to 15 seconds past each minute,
    but not 16 to 59 seconds past each minute. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `0-15 * * * * *` | 在每分钟的0秒、1秒、2秒、3秒，等等，直到15秒之后，但不是每分钟的16秒到59秒。|'
- en: '| `0 30 9-16 * * *` | Eight times a day – at hours 9:30 A.M, 10:30 A.M, and
    so on up to 4:30 P.M. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `0 30 9-16 * * *` | 每天八次 – 在上午9:30、上午10:30，等等，直到下午4:30。|'
- en: '| `0 */5 * * * *` | 12 times an hour – at second 0 of every 5^(th) minute of
    every hour. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `0 */5 * * * *` | 每小时12次 – 在每小时的第5分钟的每0秒。|'
- en: '| `0 0 */4 * * *` | 6 times a day – at minute 0 of every 4^(th) hour of every
    day. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `0 0 */4 * * *` | 每天六次 – 在每天每4小时的第0分钟。|'
- en: '| `0 30 9 * * *` | 9:30 AM every day. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `0 30 9 * * *` | 每天上午9:30。|'
- en: '| `0 30 9 * * 1-5` | 9:30 AM every workday. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `0 30 9 * * 1-5` | 每个工作日上午9:30。|'
- en: '| `0 30 9 * * Mon-Fri` | 9:30 AM every workday. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `0 30 9 * * Mon-Fri` | 每个工作日上午9:30。|'
- en: '| `0 30 9 * Jan Mon` | 9:30 AM every Monday in January. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `0 30 9 * Jan Mon` | 1月每周一上午9:30。|'
- en: 'Table 10.1: Examples of NCRONTAB expressions'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1：NCRONTAB表达式的示例
- en: 'Now let’s build a simple console app to test your understanding of NCRONTAB
    expressions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们构建一个简单的控制台应用程序来测试您对NCRONTAB表达式的理解：
- en: Use your preferred code editor to add a new console app named `NCrontab.Console` to
    a `Chapter10` solution.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器将名为 `NCrontab.Console` 的新控制台应用程序添加到 `Chapter10` 解决方案中。
- en: 'In the `NCrontab.Console` project, treat warnings as errors, globally and statically
    import the `System.Console` class, and add a package reference for `NCrontab.Signed`,
    as shown in the following markup:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NCrontab.Console` 项目中，将警告视为错误，全局和静态导入 `System.Console` 类，并为 `NCrontab.Signed`
    添加包引用，如下面的标记所示：
- en: '[PRE1]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The NCRONTAB library is only for parsing expressions. It is not itself a scheduler.
    You can learn more about it in the GitHub repository at the following link: [https://github.com/atifaziz/NCrontab](https://github.com/atifaziz/NCrontab).'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: NCRONTAB库仅用于解析表达式。它本身不是一个调度器。您可以在以下链接的GitHub仓库中了解更多信息：[https://github.com/atifaziz/NCrontab](https://github.com/atifaziz/NCrontab)。
- en: Build the `NCrontab.Console` project to restore packages.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目 `NCrontab.Console` 以恢复包。
- en: 'In `Program.cs`, delete the existing statements. Add statements to define a
    date range for the year 2023, output a summary of NCRONTAB syntax, and construct
    an NCRONTAB schedule, and then use it to output the next 40 occurrences that would
    occur in 2023, as shown in the following code:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，删除现有的语句。添加语句以定义2023年的日期范围，输出NCRONTAB语法的摘要，并构建一个NCRONTAB计划，然后使用它来输出2023年将发生的下一个40个事件，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note the following:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: The default potential time span for occurrences is the whole year of 2023.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发生事件的默认潜在时间跨度是2023年全年。
- en: The default expression is `0,30 * * * * *`, meaning at 0 and 30 seconds of every
    minute of every hour of every day of every weekday of every month.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认表达式是 `0,30 * * * * *`，意味着在每个月每个工作日每天每小时的每分钟的第0秒和第30秒。
- en: The formatting for the syntax help assumes each component will be three characters
    wide because `-3` is used for output formatting. You could write a cleverer algorithm
    to dynamically adjust the arrows to point to variable width components, but I
    was lazy. I will leave that as an exercise for you.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法帮助的格式化假设每个组件将占用三个字符宽，因为用于输出格式的 `-3`。你可以编写一个更聪明的算法来动态调整箭头指向可变宽度的组件，但我很懒惰。我将把这个留给你作为练习。
- en: Our expression includes seconds, so when parsing, we must set that as an additional
    option.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的表达式包括秒，因此在解析时必须将其设置为附加选项。
- en: After defining the schedule, the schedule calls its `GetNextOccurrences` method
    to return a sequence of all the calculated occurrences.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义计划后，计划调用其 `GetNextOccurrences` 方法以返回所有计算出的发生序列。
- en: The loop only outputs the first 40 occurrences. That should be enough to understand
    how most expressions work.
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环只输出前 40 个发生次数。这应该足以理解大多数表达式的工作方式。
- en: 'Start the console app without debugging, and note the occurrences are every
    30 seconds, as shown in the following partial output:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不带调试启动控制台应用程序，并注意发生次数为每 30 秒一次，如下部分输出所示：
- en: '[PRE3]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that although the start time is `Sun, 01 Jan 2023 00:00:00`, that value
    is excluded from the occurrences because it is not a “next” occurrence.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，尽管开始时间是 `Sun, 01 Jan 2023 00:00:00`，但该值不包括在发生次数中，因为它不是一个“下一个”发生。
- en: Close the console app.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭控制台应用程序。
- en: 'In `Program.cs`, modify the components of the expression to test some of the
    examples in the table, or make up your own examples. Try the expression `0 0 */4
    * * *`, and note it should have the following partial output:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，修改表达式的组件以测试表中的某些示例，或者创建自己的示例。尝试表达式 `0 0 */4 * * *`，并注意它应该有如下部分输出：
- en: '[PRE4]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that although the start time is `Sun, 01 Jan 2023 00:00:00`, that value
    is excluded from the occurrences because it is not a “next” occurrence. So, Sunday
    only has five occurrences. Monday onward has the expected six occurrences per
    day.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管开始时间是 `Sun, 01 Jan 2023 00:00:00`，但该值不包括在发生次数中，因为它不是一个“下一个”发生。因此，星期日只有五个发生次数。从星期一开始，每天应有预期的六个发生次数。
- en: Azure Functions versions and languages
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure Functions 版本和语言
- en: Azure Functions version 4 of the runtime host is the only version still generally
    available. All older versions have reached end-of-life.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时主机 Azure Functions 的版本 4 是唯一仍然普遍可用的版本。所有旧版本都已达到生命周期的终点。
- en: '**Good Practice**: Microsoft recommends using v4 for functions in all languages.
    v1, v2, and v3 are in maintenance mode and should be avoided.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：Microsoft 建议在所有语言中使用 v4。v1、v2 和 v3 处于维护模式，应避免使用。'
- en: 'Languages and platforms supported by Azure Functions v4 include:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions v4 支持的语言和平台包括：
- en: '**C#, F#**: .NET 8, .NET 7, .NET 6, and .NET Framework 4.8\. Note that .NET
    6 and .NET 7 (and in future, .NET 9) are only supported in the isolated worker
    model because they are **Standard-Term Support** (**STS**) releases, or, in the
    case of .NET 6, they are older LTS releases. .NET 8 is supported in both isolated
    and in-process worker models because it is a **Long-Term Support** (**LTS**) release.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C#** 和 **F#**：.NET 8, .NET 7, .NET 6, 和 .NET Framework 4.8。注意，.NET 6 和 .NET
    7（以及未来的 .NET 9）仅支持在隔离工作模型中，因为它们是 **标准支持期**（**STS**）版本，或者，在 .NET 6 的情况下，它们是较旧的长期支持（**LTS**）版本。.NET
    8 支持隔离和进程内工作模型，因为它是一个 **长期支持**（**LTS**）版本。'
- en: '**JavaScript**: Node 14, 16, and 18\. TypeScript is supported via transpiling
    (transforming/compiling) to JavaScript.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript**：Node 14, 16, 和 18。TypeScript 通过转换（转换/编译）到 JavaScript 支持。'
- en: '**Java** 8, 11, and 17.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java** 8, 11, 和 17。'
- en: '**PowerShell** 7.2.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PowerShell** 7.2。'
- en: '**Python** 3.7, 3.8, 3.9, and 3.10.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python** 3.7, 3.8, 3.9, 和 3.10。'
- en: '**More Information**: You can review the whole table of languages at the following
    link: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-versions?tabs=v4&pivots=programming-language-csharp#languages](https://learn.microsoft.com/en-us/azure/azure-functions/functions-versions?tabs=v4&pivots=programming-language-csharp#languages).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中查看整个语言表：[https://learn.microsoft.com/en-us/azure/azure-functions/functions-versions?tabs=v4&pivots=programming-language-csharp#languages](https://learn.microsoft.com/en-us/azure/azure-functions/functions-versions?tabs=v4&pivots=programming-language-csharp#languages)。'
- en: In this book, we will only look at implementing Azure Functions using C# and
    .NET 8 so that we can use the in-process and isolated worker models and get LTS.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将只查看使用 C# 和 .NET 8 实现 Azure Functions，这样我们就可以使用进程内和隔离工作模型并获得 LTS。
- en: 'For advanced uses, you can even register a custom handler that would enable
    you to use any language you like for the implementation of an Azure function.
    You can read more about Azure Functions custom handlers at the following link:
    [https://learn.microsoft.com/en-us/azure/azure-functions/functions-custom-handlers](https://learn.microsoft.com/en-us/azure/azure-functions/functions-custom-handlers).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级用途，您甚至可以注册一个自定义处理程序，这样您就可以使用您喜欢的任何语言来实现 Azure 函数。您可以在以下链接中了解更多关于 Azure Functions
    自定义处理程序的信息：[https://learn.microsoft.com/en-us/azure/azure-functions/functions-custom-handlers](https://learn.microsoft.com/en-us/azure/azure-functions/functions-custom-handlers)。
- en: Azure Functions worker models
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure Functions 工作模型
- en: 'Azure Functions have two worker models, in-process and isolated, as described
    in the following list:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 有两种工作模型，进程内和隔离，如下列表所述：
- en: '**In-process**: Your function is implemented in a class library that must run
    in the same process as the host, which means your functions must run on the most
    recent LTS release of .NET. The latest LTS release is .NET 8\. The next LTS release
    will be .NET 10 in November 2025, but .NET 8 will be the last release that supports
    in-process hosting. After .NET 8, only the isolated worker model will be supported
    for all versions.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程内**：您的函数在一个类库中实现，必须在与宿主相同的进程中运行，这意味着您的函数必须在 .NET 最新的 LTS 版本上运行。最新的 LTS
    版本是 .NET 8。下一个 LTS 版本将在 2025 年 11 月的 .NET 10 中发布，但 .NET 8 将是支持进程内托管的最后一个版本。在 .NET
    8 之后，将只支持所有版本的隔离工作模型。'
- en: '**Isolated**: Your function is implemented in a console app that runs in its
    own process. Your function can therefore execute on any supported .NET version,
    have full control over its `Main` entry point, and have additional features like
    invocation middleware. From .NET 9 onward, this will be the only worker model.
    You can read more about this decision at the following link: [https://techcommunity.microsoft.com/t5/apps-on-azure-blog/net-on-azure-functions-august-2023-roadmap-update/ba-p/3910098](https://techcommunity.microsoft.com/t5/apps-on-azure-blog/net-on-azure-functions-august-2023-roadmap-update/ba-p/3910098).'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离型**：您的函数在一个控制台应用程序中实现，该应用程序在其自己的进程中运行。因此，您的函数可以在任何支持的 .NET 版本上执行，完全控制其
    `Main` 入口点，并具有调用中间件等附加功能。从 .NET 9 开始，这将是唯一的工作模型。您可以在以下链接中了解更多关于此决定的信息：[https://techcommunity.microsoft.com/t5/apps-on-azure-blog/net-on-azure-functions-august-2023-roadmap-update/ba-p/3910098](https://techcommunity.microsoft.com/t5/apps-on-azure-blog/net-on-azure-functions-august-2023-roadmap-update/ba-p/3910098)。'
- en: '**Good Practice**: New projects should use the isolated worker model.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：新项目应使用隔离工作模型。'
- en: Azure Functions hosting plans
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure Functions 托管计划
- en: 'After testing locally, you must deploy your Azure Functions project to an Azure
    hosting plan. There are three Azure Functions plans to choose from, as described
    in the following list:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地测试后，您必须将 Azure Functions 项目部署到 Azure 托管计划。您可以从以下列表中选择三种 Azure Functions 计划：
- en: '**Consumption**: In this plan, host instances are dynamically added and removed
    based on activity. This plan is the closest to *serverless*. It scales automatically
    during periods of high load. The cost is only for compute resources when your
    functions are running. You can configure a timeout for function execution times
    to ensure your functions do not run forever.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消费型**：在此方案中，根据活动动态添加和删除托管实例。此方案与 *无服务器* 方案最为接近。在负载高峰期间自动扩展。成本仅针对运行时的计算资源。您可以配置函数执行时间的超时，以确保您的函数不会永远运行。'
- en: '**Premium**: This plan supports elastic scaling up and down, perpetually warm
    instances to avoid cold starts, unlimited execution duration, multicore instance
    sizes up to four cores, potentially more predictable costs, and high-density app
    allocation for multiple Azure Functions projects. The cost is based on the number
    of core seconds and memory allocated across instances. At least one instance must
    be allocated at all times, so there will always be a minimum monthly cost per
    active plan, even if it never executes that month.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级**：此方案支持弹性上下文扩展，始终处于预热状态的实例以避免冷启动，无限制的执行时长，多核实例大小最多可达四个核心，成本可能更具可预测性，并为多个
    Azure Functions 项目提供高密度应用分配。成本基于实例间分配的核心秒数和内存。必须始终分配至少一个实例，因此即使该月没有执行，也始终会有一个最低的每月成本。'
- en: '**Dedicated**: Executes in the cloud equivalent of a server farm. Hosting is
    provided by an Azure App Service plan that controls the allocated server resources.
    Azure App Service plans include Basic, Standard, Premium, and Isolated. This plan
    can be an especially good choice if you already have an App Service plan used
    for other projects like ASP.NET Core MVC websites, gRPC, OData, and GraphQL services,
    and so on. The cost is only for the App Service plan. You can host as many Azure
    Functions and other web apps in it as you like.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专用**：在云中的服务器农场等效环境中执行。托管由控制分配服务器资源的 Azure App Service 计划提供。Azure App Service
    计划包括基本、标准、高级和隔离。如果你已经有一个用于其他项目（如 ASP.NET Core MVC 网站、gRPC、OData 和 GraphQL 服务等）的
    App Service 计划，那么这个计划可能是一个特别好的选择。费用仅限于 App Service 计划。你可以在这个计划中托管尽可能多的 Azure Functions
    和其他 Web 应用。'
- en: '**Warning!** Premium and Dedicated plans both run on Azure App Service plans.
    You must carefully select the correct App Service plan that works with your Azure
    Functions hosting plan. For example, for Premium, you should choose an Elastic
    Premium plan like `EP1`. If you choose an App Service plan like `P1V1`, then you
    are choosing a dedicated plan that will not elastically scale!'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**警告！**高级和专用计划都运行在 Azure App Service 计划上。你必须仔细选择与你的 Azure Functions 托管计划兼容的正确
    App Service 计划。例如，对于高级计划，你应该选择一个弹性高级计划，如 `EP1`。如果你选择一个像 `P1V1` 这样的 App Service
    计划，那么你选择的是一个不会弹性扩展的专用计划！'
- en: 'You can read more about your choices at the following link: [https://learn.microsoft.com/en-us/azure/azure-functions/functions-scale](https://learn.microsoft.com/en-us/azure/azure-functions/functions-scale).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中了解更多关于你的选择：[https://learn.microsoft.com/en-us/azure/azure-functions/functions-scale](https://learn.microsoft.com/en-us/azure/azure-functions/functions-scale)。
- en: Azure Storage requirements
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure 存储要求
- en: 'Azure Functions requires an Azure Storage account for storing information for
    some bindings and triggers. These Azure Storage services can also be used by your
    code for its implementation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 需要一个 Azure 存储账户来存储某些绑定和触发器的信息。这些 Azure 存储服务也可以由你的代码用于其实施：
- en: '**Azure Files**: Stores and runs your function app code in a Consumption or
    Premium plan.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 文件存储**：在消费或高级计划中存储和运行你的函数应用代码。'
- en: '**Azure Blob Storage**: Stores state for bindings and function keys.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Blob 存储**：存储绑定和函数键的状态。'
- en: '**Azure Queue Storage**: Used for failure and retry handling by some triggers.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 队列存储**：某些触发器用于故障和重试处理。'
- en: '**Azure Table Storage**: Task hubs in Durable Functions use Blob, Queue, and
    Table Storage.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 表存储**：Durable Functions 中的任务中心使用 Blob、队列和表存储。'
- en: Testing locally with Azurite
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Azurite 本地测试
- en: Azurite is an open-source local environment for testing Azure Functions with
    its related Blob, Queue, and Table Storage. Azurite is cross-platform on Windows,
    Linux, and macOS. Azurite supersedes the older Azure Storage Emulator.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Azurite 是一个开源的本地环境，用于测试 Azure Functions 及其相关的 Blob、队列和表存储。Azurite 在 Windows、Linux
    和 macOS 上都是跨平台的。Azurite 取代了旧的 Azure 存储模拟器。
- en: 'To install Azurite:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Azurite：
- en: For Visual Studio 2022, Azurite is included.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Visual Studio 2022，Azurite 已包含在内。
- en: For Visual Studio Code, search for and install the Azurite extension.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Visual Studio Code，搜索并安装 Azurite 扩展。
- en: For JetBrains Rider, install the Azure Toolkit for Rider plugin, which includes
    Azurite.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 JetBrains Rider，安装 Azure Toolkit for Rider 插件，该插件包括 Azurite。
- en: 'For installation at the command prompt, you must have Node.js version 8 or
    later installed and then you can enter the following command:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于在命令提示符下的安装，你必须安装 Node.js 8 或更高版本，然后可以输入以下命令：
- en: '[PRE5]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once you have locally tested an Azure function, you can switch to an Azure Storage
    account in the cloud.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在本地测试了 Azure 函数，你可以切换到云中的 Azure 存储账户。
- en: 'You can learn more about Azurite at the following link: [https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azurite](https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azurite).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中了解更多关于 Azurite 的信息：[https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azurite](https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azurite)。
- en: Azure Functions authorization levels
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure Functions 授权级别
- en: 'Azure Functions has three authorization levels that control whether an API
    key is required:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 有三个授权级别，用于控制是否需要 API 密钥：
- en: '**Anonymous**: No API key is required.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匿名**：不需要 API 密钥。'
- en: '**Function**: A function-level key is required.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**：需要函数级别的密钥。'
- en: '**Admin**: The master key is required.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理员**：需要主密钥。'
- en: API keys are available through the Azure portal.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: API 密钥可通过 Azure 门户获取。
- en: Azure Functions support for dependency injection
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure Functions 支持依赖注入
- en: Dependency injection in Azure Functions is built on the standard .NET dependency
    injection features, but there are implementation differences depending on your
    chosen worker model.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 中的依赖注入建立在标准的 .NET 依赖注入功能之上，但具体实现方式取决于你选择的工人模型。
- en: To register dependency services, create a class that inherits from the `FunctionsStartup`
    class and override its `Configure` method. Add the `[FunctionsStartup]` assembly
    attribute to specify the class name registered for startup. Add services to the
    `IFunctionsHostBuilder` instance passed to the method. You will do this in a task
    later in this chapter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册依赖服务，创建一个继承自 `FunctionsStartup` 类的类，并重写其 `Configure` 方法。添加 `[FunctionsStartup]`
    程序集属性以指定注册的启动类名。将服务添加到传递给方法的 `IFunctionsHostBuilder` 实例中。你将在本章后面的任务中这样做。
- en: Normally, the class that implements an Azure Functions function is `static`
    with a `static` method. A `static` class is not instantiated with a constructor.
    Dependency injection uses constructor injection so that means you must use instance
    classes for injected services and for your function class implementation. You
    will see how to do this in the coding task.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，实现 Azure Functions 函数的类是 `static` 的，并且有一个 `static` 方法。`static` 类不使用构造函数进行实例化。依赖注入使用构造函数注入，这意味着你必须使用实例类来注入服务以及你的函数类实现。你将在编码任务中看到如何做到这一点。
- en: Installing Azure Functions Core Tools
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Azure Functions 核心工具
- en: '**Azure Functions Core Tools** provides the core runtime and templates for
    creating functions, which enable local development on Windows, macOS, and Linux
    using any code editor.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure Functions 核心工具**提供了创建函数的核心运行时和模板，这使你能够在 Windows、macOS 和 Linux 上使用任何代码编辑器进行本地开发。'
- en: Azure Functions Core Tools is included in the **Azure development** workload
    of Visual Studio 2022, so you might already have it installed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions 核心工具包含在 Visual Studio 2022 的 **Azure 开发** 工作负载中，因此你可能已经安装了它。
- en: 'You can install the latest version of **Azure Functions Core Tools** from the
    following link:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从以下链接安装最新版本的 **Azure Functions 核心工具**：
- en: '[https://www.npmjs.com/package/azure-functions-core-tools](https://www.npmjs.com/package/azure-functions-core-tools)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.npmjs.com/package/azure-functions-core-tools](https://www.npmjs.com/package/azure-functions-core-tools)'
- en: The page found at the preceding link has instructions for installing using **Microsoft
    Software Installer** (**MSI**) and `winget` on Windows, Homebrew on Mac, `npm`
    on any operating system, and common Linux distributions.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个链接中找到的页面提供了在 Windows 上使用 **Microsoft 软件安装程序 (MSI)** 和 `winget`、在 Mac 上使用
    Homebrew、在任何操作系统上使用 `npm` 以及常见 Linux 发行版上安装的说明。
- en: If you are using JetBrains Rider, then install Azure Functions Core Tools via
    Rider.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 JetBrains Rider，那么通过 Rider 安装 Azure Functions 核心工具。
- en: Building an Azure Functions project
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Azure Functions 项目
- en: Now, we can create an Azure Functions project. Although they can be created
    in the cloud using the Azure portal, developers will have a better experience
    creating and running them locally first. You can then deploy to the cloud once
    you have tested your function on your own computer.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个 Azure Functions 项目。虽然它们可以通过 Azure 门户在云端创建，但开发者最好先在本地创建和运行它们，以便获得更好的体验。一旦你在自己的电脑上测试了函数，你就可以将其部署到云端。
- en: Each code editor has a slightly different experience to get started with an
    Azure Functions project, so let’s have a look at each in turn, starting with Visual
    Studio 2022.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每个代码编辑器在开始 Azure Functions 项目时都有略微不同的体验，因此让我们逐一查看，从 Visual Studio 2022 开始。
- en: Using Visual Studio 2022
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 2022
- en: 'If you prefer to use Visual Studio 2022, here are the steps to create an Azure
    Functions project:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用 Visual Studio 2022，以下是如何创建 Azure Functions 项目的步骤：
- en: 'In Visual Studio 2022, create a new project, as defined in the following list:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2022 中，创建一个新项目，如下列所示：
- en: 'Project template: **Azure Functions**'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**Azure Functions**
- en: 'Solution file and folder: `Chapter10`'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter10`
- en: 'Project file and folder: `Northwind.AzureFunctions.Service`'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Northwind.AzureFunctions.Service`
- en: '**Functions worker**: **.NET 8.0 Isolated (Long Term Support)**'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数工作者**：**.NET 8.0 Isolated (长期支持)**'
- en: '**Function**: **Http trigger**'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**：**Http 触发器**'
- en: '**Use Azurite for runtime storage account (AzureWebJobsStorage)**: Selected'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 Azurite 作为运行时存储账户 (AzureWebJobsStorage)**: 已选择'
- en: '**Enable** **Docker**: Cleared'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**禁用** **Docker**：已清除'
- en: '**Authorization level**: **Anonymous**'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权级别**：**匿名**'
- en: Click **Create**.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建**。
- en: Configure the startup project for the solution to be the current selection.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置解决方案的启动项目为当前选择。
- en: Using Visual Studio Code
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Visual Studio Code
- en: 'If you prefer to use Visual Studio Code, here are the steps to create an Azure
    Functions project:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢使用 Visual Studio Code，以下是如何创建 Azure Functions 项目的步骤：
- en: 'In Visual Studio Code, navigate to **Extensions** and search for Azure Functions
    (`ms-azuretools.vscode-azurefunctions`). It has dependencies on two other extensions:
    Azure Account (`ms-vscode.azure-account`) and Azure Resources (`ms-azuretools.vscode-azureresourcegroups`),
    so those will be installed too. Click the **Install** button to install the extension.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，导航到 **扩展** 并搜索 Azure Functions (`ms-azuretools.vscode-azurefunctions`)。它依赖于两个其他扩展：Azure
    账户 (`ms-vscode.azure-account`) 和 Azure 资源 (`ms-azuretools.vscode-azureresourcegroups`)，因此这些也将被安装。点击
    **安装** 按钮来安装扩展。
- en: Create a folder named `Northwind.AzureFunctions.Service`. (If you previously
    created the same project using Visual Studio 2022, then create a new folder named
    `Chapter10-vscode` and create this new project folder in there instead.)
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Northwind.AzureFunctions.Service` 的文件夹。（如果您之前使用 Visual Studio 2022 创建了相同的项目，那么请创建一个名为
    `Chapter10-vscode` 的新文件夹，并将此新项目文件夹放在那里。）
- en: In Visual Studio Code, open the `Northwind.AzureFunctions.Service` folder.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，打开 `Northwind.AzureFunctions.Service` 文件夹。
- en: 'Navigate to **View** | **Command Palette**, type `azure f`, and then in the
    list of **Azure Functions** commands, click **Azure Functions: Create New Project…**.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **视图** | **命令面板**，输入 `azure f`，然后在 Azure Functions 命令列表中，点击 **Azure Functions：创建新项目…**。
- en: Select the `Northwind.AzureFunctions.Service` folder to contain your function
    project.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择包含您的函数项目的 `Northwind.AzureFunctions.Service` 文件夹。
- en: 'At the prompts, select the following:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示时，选择以下选项：
- en: 'Select a language: **C#**'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择语言：**C#**
- en: 'Select a .NET runtime: **.NET 8 Isolated LTS**.'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个 .NET 运行时：**.NET 8 Isolated LTS**。
- en: 'Select a template for your project’s first function: **HTTP trigger**.'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择项目第一个函数的模板：**HTTP trigger**。
- en: 'Provide a function name: `NumbersToWordsFunction`'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个函数名称：`NumbersToWordsFunction`
- en: 'Provide a namespace: `Northwind.AzureFunctions.Service`'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个命名空间：`Northwind.AzureFunctions.Service`
- en: 'Select the authorization level: **Anonymous**'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择授权级别：**匿名**
- en: Navigate to **Terminal** | **New Terminal**.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **终端** | **新建终端**。
- en: 'At the command prompt, build the project, as shown in the following command:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符下，构建项目，如下所示：
- en: '[PRE6]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using the func CLI
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 func CLI
- en: 'If you prefer to use the command line and some other code editor, here are
    the steps to create and start an Azure Functions project:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢使用命令行和一些其他代码编辑器，以下是如何创建和启动 Azure Functions 项目的步骤：
- en: Create a `Chapter10-cli` folder with a subfolder named `Northwind.AzureFunctions.Service`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Chapter10-cli` 的文件夹，并在其中创建一个名为 `Northwind.AzureFunctions.Service` 的子文件夹。
- en: 'In command prompt or terminal, in the `Northwind.AzureFunctions.Service` folder,
    create a new Azure Functions project using C#, as shown in the following command:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中，在 `Northwind.AzureFunctions.Service` 文件夹中，使用以下命令创建一个新的 Azure Functions
    项目，使用 C#：
- en: '[PRE7]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In command prompt or terminal, in the `Northwind.AzureFunctions.Service` folder,
    create a new Azure Functions function using `HTTP trigger` that can be called
    anonymously, as shown in the following command:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中，在 `Northwind.AzureFunctions.Service` 文件夹中，使用以下命令创建一个新的 Azure Functions
    函数，使用 `HTTP trigger` 可以匿名调用：
- en: '[PRE8]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Optionally, you can start the function locally, as shown in the following command:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，您可以在本地启动函数，如下所示：
- en: '[PRE9]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you cannot find `func` at the command prompt or terminal, then try installing
    the Azure Functions Core Tools using Chocolatey, as described at the following
    link: [https://community.chocolatey.org/packages/azure-functions-core-tools](https://community.chocolatey.org/packages/azure-functions-core-tools).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在命令提示符或终端中找不到 `func`，那么请尝试使用 Chocolatey 安装 Azure Functions Core Tools，如以下链接所述：[https://community.chocolatey.org/packages/azure-functions-core-tools](https://community.chocolatey.org/packages/azure-functions-core-tools)。
- en: Reviewing the Azure Functions project
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查 Azure Functions 项目
- en: 'Before we write a function, let’s review what makes an Azure Functions project:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写函数之前，让我们回顾一下构成 Azure Functions 项目的要素：
- en: 'Open the project file, and note the Azure Functions version and the package
    references needed to implement an Azure function that responds to HTTP requests,
    as shown in the following markup:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目文件，并注意 Azure Functions 版本和实现响应 HTTP 请求的 Azure 函数所需的包引用，如下所示：
- en: '[PRE10]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In `host.json`, note that logging to Application Insights is enabled but excludes
    `Request` types, as shown in the following markup:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `host.json` 中，请注意已启用将日志记录到 Application Insights，但排除了 `Request` 类型，如下所示：
- en: '[PRE11]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Application Insights is Azure’s monitoring and logging service. We will not
    be using it in this chapter.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Application Insights是Azure的监控和日志服务。我们将在本章中不使用它。
- en: 'In `local.settings.json`, confirm that during local development, your project
    will use local development storage and an isolated worker model, as shown in the
    following markup:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`local.settings.json`中，确认在本地开发期间，你的项目将使用本地开发存储和隔离的工作模型，如下所示：
- en: '[PRE12]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the `AzureWebJobsStorage` setting is blank or missing, which might happen
    if you are using Visual Studio Code, then add it, set it to `UseDevelopmentStorage=true`,
    and then save changes.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`AzureWebJobsStorage`设置是空的或缺失的，这可能发生在你使用Visual Studio Code的情况下，那么添加它，将其设置为`UseDevelopmentStorage=true`，然后保存更改。
- en: '`FUNCTIONS_WORKER_RUNTIME` is the language being used by your project. `dotnet`
    means a .NET class library; `dotnet-isolated` means a .NET console app. Other
    values include `java`, `node`, `powershell`, and `python`.'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`FUNCTIONS_WORKER_RUNTIME`是你项目使用的语言。`dotnet`表示.NET类库；`dotnet-isolated`表示.NET控制台应用程序。其他值包括`java`、`node`、`powershell`和`python`。'
- en: 'In the `Properties` folder, in `launchSettings.json`, note the randomly assigned
    port number for the web service, as shown in the following configuration:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Properties`文件夹中，在`launchSettings.json`中，注意为网络服务随机分配的端口号，如下面的配置所示：
- en: '[PRE13]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Change the port number to `5101` and save the changes to the file.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将端口号更改为`5101`并将更改保存到文件中。
- en: Implementing a simple function
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个简单的函数
- en: 'Let’s implement the function to convert numbers into words by using the `Humanizer`
    package:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`Humanizer`包实现将数字转换为文字的函数：
- en: 'In the project file, add a package reference for Humanizer, as shown in the
    following markup:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，添加对Humanizer的包引用，如下所示：
- en: '[PRE14]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Build the project to restore packages.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目以恢复包。
- en: If you are using Visual Studio 2022, in the `Northwind.AzureFunctions.Service`
    project, right-click `Function1.cs` and rename it to `NumbersToWordsFunction.cs`.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用Visual Studio 2022，在`Northwind.AzureFunctions.Service`项目中，右键单击`Function1.cs`并将其重命名为`NumbersToWordsFunction.cs`。
- en: 'In `NumbersToWordsFunction.cs`, modify the contents to implement an Azure function
    to convert an amount as a number into words, as shown in the following code:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NumbersToWordsFunction.cs`中，修改内容以实现将金额作为数字转换为文字的Azure函数，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Testing a simple function
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试一个简单的函数
- en: 'Now we can test the function in our local development environment:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在我们本地开发环境中测试这个函数：
- en: 'Start the `Northwind.AzureFunctions.Service` project:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`Northwind.AzureFunctions.Service`项目：
- en: If you are using Visual Studio Code, you will need to navigate to the **Run
    and Debug** pane, make sure that **Attach to .NET Functions** is selected, and
    then click the **Run** button.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用Visual Studio Code，你需要导航到**运行和调试**面板，确保**附加到.NET函数**被选中，然后点击**运行**按钮。
- en: On Windows, if you see a **Windows Security Alert** from **Windows Defender
    Firewall**, then click **Allow access**.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上，如果你看到来自**Windows Defender防火墙**的**Windows安全警报**，那么点击**允许访问**。
- en: 'Note that **Azure Functions Core Tools** hosts your function, as shown in the
    following output and in *Figure 10.1*:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意**Azure Functions Core Tools**托管你的函数，如下面的输出和*图10.1*所示：
- en: '[PRE16]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![](img/B19587_10_01.png)'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B19587_10_01.png)'
- en: 'Figure 10.1: Azure Functions Core Tools hosting a function'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.1：Azure Functions Core Tools托管一个函数
- en: It might take a few minutes for the `Host` `lock` `lease` message to appear
    so do not worry if it doesn’t show immediately.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Host` `lock` `lease`消息可能需要几分钟才能出现，所以如果它没有立即显示，请不要担心。'
- en: Select the URL for your function and copy it to the clipboard.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的函数的URL并将其复制到剪贴板。
- en: Start Chrome.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Chrome。
- en: 'Paste the URL into the address box, append the query string `?amount=123456`,
    and note the successful response in the browser of **one hundred and twenty-three
    thousand four hundred and fifty-six**, as shown in *Figure 10.2*:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将URL粘贴到地址框中，追加查询字符串`?amount=123456`，并在浏览器的**十二万三千四百五十六**中注意成功的响应，如图*图10.2*所示：
- en: '![](img/B19587_10_02.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19587_10_02.png)'
- en: 'Figure 10.2: A successful call to the Azure function running locally'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：对本地运行的Azure函数的成功调用
- en: 'In the command prompt or terminal, note the function was called successfully,
    as shown in the following output:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中，注意函数调用成功，如下面的输出所示：
- en: '[PRE17]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Try calling the function without an amount in the query string, or a non-integer
    value for the amount like `apples`, and note the function returns a `400` status
    code indicating a bad request with a custom message, `Failed to parse: apples`.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '尝试调用函数时在查询字符串中不包含金额，或者金额为非整数值，如`apples`，并注意函数返回一个`400`状态码，表示有自定义消息的无效请求，`Failed
    to parse: apples`。'
- en: Close Chrome and shut down the web server (or in Visual Studio Code, stop debugging).
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭Chrome并关闭Web服务器（或在Visual Studio Code中停止调试）。
- en: Responding to timer and resource triggers
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应定时器和资源触发
- en: Now that you have seen an Azure Functions function that responds to an HTTP
    request, let’s build some that respond to other types of triggers.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了一个响应HTTP请求的Azure Functions函数，让我们构建一些响应其他类型触发器的函数。
- en: Support for HTTP and timer triggers is built in. Support for other bindings
    is implemented as extension packages.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 内置了对HTTP和定时器触发的支持。其他绑定的支持作为扩展包实现。
- en: Implementing a Timer triggered function
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现定时器触发的函数
- en: First, we will make a function that runs every hour and requests a page from
    [amazon.com](https://www.amazon.com/) for the eighth edition of my book, *C# 12
    and .NET 8 – Modern Cross-Platform Development Fundamentals*, so that I can keep
    track of its Best Sellers Rank in the United States.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个每小时运行一次的函数，请求[amazon.com](https://www.amazon.com/)上我书籍第八版（*C# 12和.NET
    8 – 现代跨平台开发基础*）的页面，以便我可以跟踪其在美国的最佳卖家排名。
- en: 'The function will need to make HTTP `GET` requests so we should inject the
    HTTP client factory. To do that, we will need to add some extra package references
    and create a special startup class:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 函数需要执行HTTP `GET`请求，因此我们应该注入HTTP客户端工厂。为此，我们需要添加一些额外的包引用并创建一个特殊的启动类：
- en: 'In the `Northwind.AzureFunctions.Service` project, add package references for
    working with Azure Functions extensions and timers, as shown in the following
    markup:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Northwind.AzureFunctions.Service`项目中，添加用于处理Azure Functions扩展和计时器的包引用，如下面的标记所示：
- en: '[PRE18]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Build the `Northwind.AzureFunctions.Service` project to restore packages.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目`Northwind.AzureFunctions.Service`以恢复包。
- en: 'In `Program.cs`, import namespaces for working with dependency injection and
    HTTP media headers, as shown in the following code:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，导入用于处理依赖注入和HTTP媒体头的命名空间，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In `Program.cs`, add statements to configure a HTTP client factory for making
    requests to Amazon as if it was the Chrome browser as a dependency service, as
    shown highlighted in the following code:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中添加语句以配置一个HTTP客户端工厂，用于向亚马逊发送请求，就像它是Chrome浏览器作为依赖服务一样，如下面的高亮代码所示：
- en: '[PRE20]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The Chrome version on June 5, 2023, was `114.0.5735.91`. The major version number
    usually increments monthly, so in November 2023, it will likely be `119`, and
    in November 2024, it will likely be `131`.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2023年6月5日的Chrome版本是`114.0.5735.91`。主要版本号通常每月递增，因此到2023年11月，它可能为`119`，到2024年11月，它可能为`131`。
- en: Add a class file named `ScrapeAmazonFunction.cs`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`ScrapeAmazonFunction.cs`的类文件。
- en: 'Modify its contents to implement a function that requests the page for the
    seventh edition of my book on the Amazon website and process the response, which
    is compressed using GZIP, to extract the book’s Best Seller Rank, as shown in
    the following code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改其内容以实现一个函数，该函数请求亚马逊网站上我第七版书的页面，并处理使用GZIP压缩的响应，以提取书籍的最佳卖家排名，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Testing the Timer triggered function
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试定时器触发的函数
- en: 'Information about a function can be retrieved by making an HTTP `GET` request
    in the following format:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下格式的HTTP `GET`请求检索函数信息：
- en: '`http://locahost:5101/admin/functions/<functionname>`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://locahost:5101/admin/functions/<functionname>`'
- en: 'Now we can test the Timer function in our local development environment:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试本地开发环境中的定时器函数：
- en: 'Start the `Northwind.AzureFunctions.Service` project:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`Northwind.AzureFunctions.Service`项目：
- en: If you are using Visual Studio Code, you will need to make sure you have the
    Azurite extension installed and the Azurite services running. Navigate to the
    **Run and Debug** pane, make sure that **Attach to .NET Functions** is selected,
    and then click the **Run** button.
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用Visual Studio Code，你需要确保已安装Azurite扩展并且Azurite服务正在运行。导航到**运行和调试**面板，确保已选择**附加到.NET
    Functions**，然后点击**运行**按钮。
- en: 'Note there are now two functions, as shown in the following partial output:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意现在有两个函数，如下面的部分输出所示：
- en: '[PRE22]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the `HttpRequests` folder, add a new file named `azurefunctions-scrapeamazon.http`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HttpRequests`文件夹中，添加一个名为`azurefunctions-scrapeamazon.http`的新文件。
- en: 'Modify its contents to define a global variable and two requests to the Azure
    Functions locally hosted service, as shown in the following code:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改其内容以定义一个全局变量和两个请求到本地托管的Azure Functions服务，如下代码所示：
- en: '[PRE23]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Send the first request and note that a JSON document is returned with information
    about the `NumbersToWordsFunction` function, as shown in the following response:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送第一个请求并注意返回了一个包含`NumbersToWordsFunction`函数信息的JSON文档，如下所示：
- en: '[PRE24]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Send the second request and note that a JSON document is returned with information
    about the `ScrapeAmazonFunction` function. The most interesting information for
    this function is the binding type and schedule, as shown in the following partial
    response:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送第二个请求并注意返回了一个包含`ScrapeAmazonFunction`函数信息的JSON文档。对于这个函数，最有趣的信息是绑定类型和计划，如下部分响应所示：
- en: '[PRE25]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add a third request that will trigger the timer function manually without having
    to wait for the hour mark by sending a `POST` request with an empty JSON document
    in the body to its `admin` endpoint, as shown in the following code:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个第三个请求，通过发送一个包含空JSON文档的`POST`请求到其`admin`端点，手动触发计时器函数，而无需等待小时标记，如下代码所示：
- en: '[PRE26]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Send the third request and note that it was successfully accepted, as shown
    in the following response:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送第三个请求并注意它被成功接受，如下所示：
- en: '[PRE27]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Remove the `{}` in the body of the request, send it again, and note the client
    error response from which we can deduce that an empty JSON document is required,
    as shown in the following response:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在请求体中移除`{}`，再次发送，并注意从客户端错误响应中我们可以推断出需要一个空JSON文档，如下响应所示：
- en: '[PRE28]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Add the empty JSON document back.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将空JSON文档添加回去。
- en: 'At the command prompt or terminal for the Azure Functions service, note that
    the function was triggered by our call. It outputs the time it was triggered (13:49
    p.m.) and the time of its next occurrence in its normal timer schedule (2 p.m.)
    if I were to leave the service running, as shown in the following output:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Azure Functions服务的命令提示符或终端中，注意函数是由我们的调用触发的。它输出了触发时间（下午1:49）和其正常计时计划中的下一次发生时间（如果服务继续运行，时间为下午2点），如下所示：
- en: '[PRE29]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Optionally, wait until the hour mark and note that the next occurrence triggers,
    as shown in the following output:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，等待直到小时标记，并注意下一次触发，如下所示：
- en: '[PRE30]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If I were to stop the service running, wait for more than an hour, and then
    start the service, it would immediately run the function because it is past due,
    as shown highlighted in the following output:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我停止运行服务，等待超过一小时，然后启动服务，它将立即运行函数，因为已经过期，如下所示（高亮显示）：
- en: '[PRE31]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Shut down the Azure Functions service.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭Azure Functions服务。
- en: Implementing a function that works with queues and BLOBs
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现与队列和Blob一起工作的函数
- en: The HTTP-triggered function responded directly to the `GET` request with plain
    text. We will now define a similar function to bind to Queue Storage and add a
    message to a queue to indicate that an image needs to be generated and uploaded
    to Blob Storage. This can then be printed as a check.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP触发的函数直接以纯文本形式响应了`GET`请求。我们现在将定义一个类似的功能，将其绑定到队列存储，并向队列中添加一条消息，表示需要生成并上传到Blob存储的图像。然后可以将其打印出来作为检查。
- en: When running the service locally, we want to generate the image of the check
    BLOB in the local filesystem to make it easier to ensure it is working correctly.
    We will set a custom environment variable in local settings to detect that condition.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当在本地运行服务时，我们希望在本地文件系统中生成支票BLOB的图像，以便更容易确保其正确工作。我们将在本地设置中设置一个自定义环境变量来检测该条件。
- en: 'We need a font that looks like handwriting. Google has a useful website where
    you can search for, preview, and download fonts. The one we will use is Caveat,
    as shown at the following link:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个看起来像手写的字体。谷歌有一个有用的网站，你可以在这里搜索、预览和下载字体。我们将使用的是Caveat字体，如下链接所示：
- en: '[https://fonts.google.com/specimen/Caveat?category=Handwriting&preview.text=one%20hundred%20and%20twenty%20three%20thousand,%20four%20hundred%20and%20fifty%20six&preview.text_type=custom#standard-styles](https://fonts.google.com/specimen/Caveat?category=Handwriting&preview.text=one%20hundred%20and%20twenty%20three%20thousand,%20four%20hundred%20and%20fifty%20six&preview.text_type=custom#standard-styles)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://fonts.google.com/specimen/Caveat?category=Handwriting&preview.text=one%20hundred%20and%20twenty%20three%20thousand,%20four%20hundred%20and%20fifty%20six&preview.text_type=custom#standard-styles](https://fonts.google.com/specimen/Caveat?category=Handwriting&preview.text=one%20hundred%20and%20twenty%20three%20thousand,%20four%20hundred%20and%20fifty%20six&preview.text_type=custom#standard-styles)'
- en: 'Let’s go:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: 'Download the font at the link above, extract the ZIP file, and copy the files
    into a folder named `fonts`, as shown in Visual Studio 2022 in *Figure 10.3*:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上面的链接下载字体，解压 ZIP 文件，并将文件复制到名为 `fonts` 的文件夹中，如图 10.3 所示的 Visual Studio 2022：
- en: '![](img/B19587_10_03.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19587_10_03.png)'
- en: 'Figure 10.3: The fonts folder with the Caveat font files in Visual Studio 2022'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3：Visual Studio 2022 中带有 Caveat 字体文件的字体文件夹
- en: Select the `Caveat-Regular.ttf` font file.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Caveat-Regular.ttf` 字体文件。
- en: 'In **Properties**, set **Copy to Output Directory** to **Copy always**, as
    shown in *Figure 10.3*. This adds an entry to the project file, as shown highlighted
    in the following markup:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **属性** 中，将 **复制到输出目录** 设置为 **始终复制**，如图 10.3 所示。这将在项目文件中添加一个条目，如下所示高亮显示的标记：
- en: '[PRE32]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you are using Visual Studio Code, manually add the preceding entry to the
    project file.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用的是 Visual Studio Code，请手动将前面的条目添加到项目文件中。
- en: 'In the `Northwind.AzureFunctions.Service` project, add package references for
    working with the Azure Queue and Blob Storage extensions and drawing with `ImageSharp`,
    as shown in the following markup:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.AzureFunctions.Service` 项目中，添加用于处理 Azure 队列和 Blob 存储扩展以及使用 `ImageSharp`
    绘图的包引用，如下所示标记：
- en: '[PRE33]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Build the project to restore packages.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目以还原包。
- en: In the `Northwind.AzureFunctions.Service` project, add a new class named `NumbersToChecksFunction.cs`.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.AzureFunctions.Service` 项目中，添加一个名为 `NumbersToChecksFunction.cs`
    的新类。
- en: 'In `NumbersToChecksFunction.cs`, add statements to register the function with
    an output binding for Queue Storage so that it can write to a named queue, and
    when the amount is successfully parsed to return the words to the queue, as shown
    in the following code:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NumbersToChecksFunction.cs` 中添加语句以将函数与用于队列存储的输出绑定注册，以便它可以写入命名队列，并且当金额成功解析后返回到队列，如下所示代码：
- en: '[PRE34]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In `local.settings.json`, add an environment variable named `IS_LOCAL` with
    a value of `true`, as shown highlighted in the following configuration:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `local.settings.json` 中，添加一个名为 `IS_LOCAL` 的环境变量，其值为 `true`，如图所示高亮显示的配置：
- en: '[PRE35]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Add a class file named `CheckGeneratorFunction.cs`.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `CheckGeneratorFunction.cs` 的类文件。
- en: 'Modify its contents, as shown in the following code:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改其内容，如下所示代码：
- en: '[PRE36]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下事项：
- en: The `[QueueTrigger("checksQueue")] string message` parameter means the function
    is triggered by a message being added to the `checksQueue` and the queued item
    is automatically passed to the parameter named `message`.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[QueueTrigger("checksQueue")] string message` 参数表示函数由添加到 `checksQueue` 的消息触发，并且队列项自动传递给名为
    `message` 的参数。'
- en: We use ImageSharp to create a 1200x600 image of a check.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 ImageSharp 创建一个 1200x600 的支票图像。
- en: We use the current UTC date and time to name the BLOB to avoid duplicates. In
    a real implementation, you would need something more robust like GUIDs.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用当前的 UTC 日期和时间来命名 BLOB 以避免重复。在实际实现中，你可能需要更健壮的机制，如 GUID。
- en: If the `IS_LOCAL` environment variable is set to `true`, then we save the image
    as a PNG to the local filesystem in a `blobs` subfolder.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果将 `IS_LOCAL` 环境变量设置为 `true`，则我们将图像作为 PNG 格式保存到本地文件系统的 `blobs` 子文件夹中。
- en: We save the image as a PNG to a memory stream that is then returned as a byte
    array and uploaded to the BLOB container defined by the `[BlobOutput("checks-blob-container/check.png")]`
    attribute.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将图像保存为 PNG 格式到内存流中，然后作为字节数组返回并上传到由 `[BlobOutput("checks-blob-container/check.png")]`
    属性定义的 BLOB 容器。
- en: Testing the function that works with queues and BLOBs
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试与队列和 BLOB 一起工作的函数
- en: 'Now we can test the function that works with queues and BLOBs in our local
    development environment:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试在本地开发环境中与队列和 BLOB 一起工作的函数：
- en: 'Start the `Northwind.AzureFunctions.Service` project:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 `Northwind.AzureFunctions.Service` 项目：
- en: If you are using Visual Studio Code, you will need to navigate to the **Run
    and Debug** pane, make sure that **Attach to .NET Functions** is selected, and
    then click the **Run** button.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用的是 Visual Studio Code，你需要导航到 **运行和调试** 面板，确保已选择 **附加到 .NET Functions**，然后点击
    **运行** 按钮。
- en: 'Note there are now four functions, as shown in the following partial output:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意现在有四个函数，如下所示部分输出：
- en: '[PRE37]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the `HttpRequests` folder, add a new file named `azurefunctions-numberstochecks.http`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `HttpRequests` 文件夹中，添加一个名为 `azurefunctions-numberstochecks.http` 的新文件。
- en: 'Modify its contents, as shown in the following code:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改其内容，如下所示代码：
- en: '[PRE38]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Send the request and note that a JSON document is returned with information
    about the `NumbersToWordsFunction` function, as shown in the following response:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求并注意返回了一个包含 `NumbersToWordsFunction` 函数信息的 JSON 文档，如下所示响应：
- en: '[PRE39]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'At the command prompt or terminal, note the function call was successful and
    a message was sent to the queue that then triggered the `CheckGeneratorFunction`,
    as shown in the following output:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中，注意函数调用成功，并将消息发送到队列中，从而触发了 `CheckGeneratorFunction`，如下所示输出：
- en: '[PRE40]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the `Northwind.AzureFunctions.Service\bin\Debug\net8.0\blobs` folder, note
    the image created locally in the `blobs` folder, as shown in *Figure 10.4*:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Northwind.AzureFunctions.Service\bin\Debug\net8.0\blobs` 文件夹中，注意在 `blobs`
    文件夹中创建的本地图像，如图 *图 10.4* 所示：
- en: '![](img/B19587_10_04.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19587_10_04.png)'
- en: 'Figure 10.4: The check image generated in the project blobs folder'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4：在项目 blob 文件夹中生成的验证图像
- en: 'Note the check image, as shown in *Figure 10.5*:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意验证图像，如图 *图 10.5* 所示：
- en: '![](img/B19587_10_05.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19587_10_05.png)'
- en: 'Figure 10.5: The check image opened in Windows Paint'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5：在 Windows Paint 中打开的验证图像
- en: Publishing an Azure Functions project to the cloud
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Azure Functions 项目发布到云端
- en: Now, let’s create a function app and related resources in an Azure subscription,
    then deploy your functions to the cloud and run it there.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 Azure 订阅中创建一个函数应用和相关资源，然后将您的函数部署到云端并运行。
- en: 'If you do not already have an Azure account, then you can sign up for a free
    one at the following link: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有 Azure 账户，那么您可以在以下链接处免费注册：[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)。
- en: Using Visual Studio 2022 to publish
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 2022 发布
- en: 'Visual Studio 2022 has a GUI to publish to Azure:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022 提供了一个用于发布到 Azure 的图形用户界面：
- en: In **Solution Explorer**, right-click the `Northwind.AzureFunctions.Service`
    project and select **Publish**.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **解决方案资源管理器** 中，右键单击 `Northwind.AzureFunctions.Service` 项目并选择 **发布**。
- en: Select **Azure** and then click **Next**.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Azure** 然后点击 **下一步**。
- en: Select **Azure Function App (Linux)** and click **Next**.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Azure Function App (Linux)** 并点击 **下一步**。
- en: Sign in and enter your Azure credentials.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录并输入您的 Azure 凭据。
- en: Select your subscription; for example, I chose my subscription named **Pay-As-You-Go**.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您的订阅；例如，我选择了名为 **Pay-As-You-Go** 的订阅。
- en: In the **Function Instance** section, click the **+ Create New** button.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **函数实例** 部分，点击 **+ 创建新** 按钮。
- en: 'Complete the dialog box, as shown in *Figure 10.6*:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成对话框，如图 *图 10.6* 所示：
- en: '**Name**: This must be globally unique. It suggested a name based on the project
    name and the current date and time.'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：这必须是全局唯一的。建议根据项目名称和当前日期时间命名。'
- en: '**Subscription name**: Select your subscription.'
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅名称**：选择您的订阅。'
- en: '**Resource group**: Select or create a new resource group to make it easier
    to delete everything later. I chose `apps-services-book`.'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源组**：选择或创建一个新的资源组，以便稍后更容易删除所有内容。我选择了 `apps-services-book`。'
- en: '**Plan Type**: **Consumption** (pay for only what you use).'
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计划类型**：**消费**（仅为您使用的付费）。'
- en: '**Location**: A data center nearest to you. I chose **UK South**.'
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置**：您最近的数据中心。我选择了 **UK South**。'
- en: '**Azure Storage**: Create a new account named `northwindazurefunctions` (or
    something else that is globally unique) in a data center nearest to you and choose
    **Standard – Locally Redundant Storage** for the account type.'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 存储**：在您最近的数据中心中创建一个名为 `northwindazurefunctions`（或任何其他全局唯一的名称）的新账户，并为账户类型选择
    **Standard – 本地冗余存储**。'
- en: '**Application Insights**: **None**.'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序洞察**：**无**。'
- en: '![](img/B19587_10_06.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19587_10_06.png)'
- en: 'Figure 10.6: Creating a new Azure function app'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6：创建新的 Azure 函数应用
- en: Click **Create**. This process can take a minute or more.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建**。此过程可能需要一分钟或更长时间。
- en: In the **Publish** dialog, click **Finish** and then click **Close**.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **发布** 对话框中，点击 **完成** 然后点击 **关闭**。
- en: 'In the **Publish** window, click the **Publish** button, as shown in *Figure
    10.7*:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **发布** 窗口中，点击 **发布** 按钮，如图 *图 10.7* 所示：
- en: '![](img/B19587_10_07.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19587_10_07.png)'
- en: 'Figure 10.7: An Azure Function App ready to publish using Visual Studio 2022'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7：使用 Visual Studio 2022 准备发布的 Azure Function App
- en: 'Review the output window, as shown in the following publishing output:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出窗口，如图以下发布输出所示：
- en: '[PRE41]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the **Publish** window, click **Open site** and note your Azure Functions
    v4 host site is ready.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **发布** 窗口中，点击 **打开站点** 并注意您的 Azure Functions v4 主站已准备就绪。
- en: 'Test the function in your browser by appending the following relative URL to
    the address box, as shown in *Figure 10.8*:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将以下相对 URL 添加到地址框中，在浏览器中测试函数，如图 *图 10.8* 所示：
- en: '`/api/NumbersToWordsFunction?amount=987654321`'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`/api/NumbersToWordsFunction?amount=987654321`'
- en: '![](img/B19587_10_08.png)'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B19587_10_08.png)'
- en: 'Figure 10.8: Calling the function hosted in the Azure cloud'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.8：调用 Azure 云中托管的功能
- en: Using Visual Studio Code to publish
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Visual Studio Code 进行发布
- en: 'You can learn how to publish using Visual Studio Code at the following link:'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在以下链接中学习如何使用 Visual Studio Code 进行发布：
- en: '[https://learn.microsoft.com/en-us/azure/azure-functions/functions-develop-vs-code?tabs=csharp#sign-in-to-azure](https://learn.microsoft.com/en-us/azure/azure-functions/functions-develop-vs-code?tabs=csharp#sign-in-to-azure)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/azure/azure-functions/functions-develop-vs-code?tabs=csharp#sign-in-to-azure](https://learn.microsoft.com/en-us/azure/azure-functions/functions-develop-vs-code?tabs=csharp#sign-in-to-azure)'
- en: Now that you’ve successfully published your Azure Functions project to the cloud,
    it’s important to understand how to manage your resources efficiently. Let’s explore
    how to clean up our Azure Functions resources to avoid unnecessary costs and ensure
    tidy resource management.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已成功将 Azure Functions 项目发布到云端，了解如何高效地管理资源变得很重要。让我们探讨如何清理我们的 Azure Functions
    资源，以避免不必要的成本并确保资源管理整洁。
- en: Cleaning up Azure Functions resources
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理 Azure Functions 资源
- en: 'You can use the following steps to delete the function app and its related
    resources to avoid incurring further costs:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下步骤删除函数应用及其相关资源，以避免产生更多成本：
- en: In your browser, navigate to [https://portal.azure.com/](https://portal.azure.com/).
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中，导航到 [https://portal.azure.com/](https://portal.azure.com/)
- en: In the Azure portal, in your function app’s **Overview** blade, select **Resource
    Group**.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Azure 门户中，在您的函数应用的 **概览** 选项卡中，选择 **资源组**。
- en: Confirm that it contains only resources that you want to delete; for example,
    there should be a **Storage account**, a **Function App**, and an **App Service
    plan**.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认它只包含您想要删除的资源；例如，应该有一个 **存储账户**、一个 **函数应用** 和一个 **应用服务计划**。
- en: If you are sure you want to delete all the resources in the group, then click
    **Delete resource group** and accept any other confirmations. Alternatively, you
    can delete each resource individually.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您确定要删除组中的所有资源，请单击 **删除资源组** 并接受任何其他确认。或者，您可以逐个删除每个资源。
- en: Practicing and exploring
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with deeper research.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题、进行一些动手实践，以及更深入地研究本章的主题来测试您的知识和理解。
- en: Exercise 10.1 – Test your knowledge
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.1 – 测试您的知识
- en: 'Answer the following questions:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What is the difference between the in-process and isolated worker models for
    Azure Functions?
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure Functions 的进程内和隔离工作模型之间有什么区别？
- en: What attribute do you use to cause a function to trigger when a message arrives
    in a queue?
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您使用什么属性来使函数在队列中收到消息时触发？
- en: What attribute do you use to make a queue available to send messages to?
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您使用什么属性来使队列可用于发送消息？
- en: What schedule does the following NCRONTAB expression define?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下 NCRONTAB 表达式定义了什么计划？
- en: '`0 0 */6 * 6 6`'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`0 0 */6 * 6 6`'
- en: How can you configure a dependency service for use in a function?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何配置依赖服务以在函数中使用？
- en: Exercise 10.2 – Explore topics
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.2 – 探索主题
- en: 'Use the links on the following page for more details on the topics covered
    in this chapter:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接获取本章涵盖主题的更多详细信息：
- en: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-10---building-serverless-nanoservices-using-azure-functions](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-10---building-serverless-nanoservices-using-azure-functions)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-10---building-serverless-nanoservices-using-azure-functions](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-10---building-serverless-nanoservices-using-azure-functions)'
- en: Summary
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了：
- en: Some of the concepts around Azure Functions
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions 的一些概念
- en: How to build serverless services using Azure Functions
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Azure Functions 构建无服务器服务
- en: How to respond to HTTP, Timer, and Queue triggers
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何响应 HTTP、定时器和队列触发器
- en: How to bind to Queue and Blob Storage
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何绑定到队列和 Blob 存储
- en: How to deploy an Azure Functions project to the cloud
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将 Azure Functions 项目部署到云端
- en: In the next chapter, you will learn about SignalR, a technology for performing
    real-time communication between client and server.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将了解 SignalR，这是一种在客户端和服务器之间进行实时通信的技术。
