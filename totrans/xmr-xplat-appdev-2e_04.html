<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. XamChat – a Cross-platform App</h1></div></div></div><p class="calibre8">The best way to truly learn a programming skill, in my opinion, is to take on a simple project that requires you to exercise that skill. This gives new developers a project where they can focus on the concepts they are trying to learn without the overhead of fixing bugs or following customer requirements. To increase our understanding of Xamarin and cross-platform <a id="id222" class="calibre1"/>development, let's develop a simple app called <strong class="calibre2">XamChat</strong> for iOS and Android.</p><p class="calibre8">In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Our sample application concept</li><li class="listitem">The Model layer of our application</li><li class="listitem">Mocking a web service</li><li class="listitem">The ViewModel layer of our application</li><li class="listitem">Writing unit tests</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec30" class="calibre1"/>Starting our sample application concept</h1></div></div></div><p class="calibre8">The concept is simple: a chat application that uses a standard Internet connection as an alternative to send text messages. There are several popular applications like this on the Apple App Store, probably due<a id="id223" class="calibre1"/> to the cost of text messaging and support for devices such as the iPod Touch or iPad. This will be a neat real-world example that can be useful for users, and will cover specific topics in developing applications for iOS and Android.</p><p class="calibre8">Before we start with<a id="id224" class="calibre1"/> the development, let's list the set of screens that we'll need:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">Login / sign up</strong>: This <a id="id225" class="calibre1"/>screen will include a standard login and sign-up process for the user</li><li class="listitem"><strong class="calibre2">List of conversations</strong>: This screen <a id="id226" class="calibre1"/>will include a button to start a new conversation</li><li class="listitem"><strong class="calibre2">List of friends</strong>: This screen will provide a way to add new friends when we start a new<a id="id227" class="calibre1"/> conversation</li><li class="listitem"><strong class="calibre2">Conversation</strong>: This screen <a id="id228" class="calibre1"/>will have a list of messages between you and another user, and an option to reply</li></ul></div><p class="calibre8">So a quick wireframe layout of the application will help you grasp a better understanding of the layout of the app. The following figure shows you the set of screens to be included in your app:</p><div><img src="img/00027.jpeg" alt="Starting our sample application concept" class="calibre9"/></div><p class="calibre10"> </p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec31" class="calibre1"/>Developing our Model layer</h1></div></div></div><p class="calibre8">Since we have a good<a id="id229" class="calibre1"/> idea of what the application is, the next step is to develop the business objects, or Model layer, of this application. Let's start by defining a few classes that will contain the data to be used throughout the app. It is recommended, for the sake of organization, to add these to a <code class="literal">Models</code> folder in your project. This is the bottom layer of the MVVM design pattern.</p><p class="calibre8">Let's begin with a class that represents a user. The class can be created as follows:</p><div><pre class="programlisting">public class User
{
  public string Id { get; set; }
  public string Username { get; set; }
  public string Password { get; set; }
}</pre></div><p class="calibre8">Pretty straightforward so far; let's move on to create classes representing a conversation and a message as follows:</p><div><pre class="programlisting">public class Conversation
{
  public string Id { get; set; }
  public string UserId { get; set; } 
  public string Username { get; set; }
}
public class Message
{
  public string Id { get; set; }
  public string ConversationId { get; set; }
  public string UserId { get; set; } 
  public string Username { get; set; }
  public string Text { get; set; }
}</pre></div><p class="calibre8">Notice that we are using strings as identifiers for the various objects. This will simplify our integration<a id="id230" class="calibre1"/> with Azure Mobile Services in the later chapters. <code class="literal">UserId</code> is the value that will be set by the application to change the user that the object is associated with.</p><p class="calibre8">Now, let's go ahead and set up our solution by performing the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Start by creating a new solution and a new <strong class="calibre2">Portable Library</strong> project.</li><li class="listitem" value="2">Name the project <code class="literal">XamChat.Core</code> and the solution <code class="literal">XamChat</code>.</li><li class="listitem" value="3">You can also choose to use a <strong class="calibre2">Shared Project</strong> for this project, but I chose to use a portable class library because it encourages better programming practices in general.</li></ol><div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec32" class="calibre1"/>Writing a mock web service</h1></div></div></div><p class="calibre8">Many times when developing a mobile application, you might need to begin the development of your application<a id="id231" class="calibre1"/> before the real backend web service is available. To prevent the development from halting entirely, a good approach would be to develop a mock version of the service. This is also helpful when you need to write unit tests, or just need to add a real backend to your app later.</p><p class="calibre8">First, let's break down the operations our app will perform against a web server. The operations are as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">Log in with a username and password.</li><li class="listitem" value="2">Register a new account.</li><li class="listitem" value="3">Get the user's list of friends.</li><li class="listitem" value="4">Add friends by their usernames.</li><li class="listitem" value="5">Get a list of the existing conversations for the user.</li><li class="listitem" value="6">Get a list of messages in a conversation.</li><li class="listitem" value="7">Send a message.</li></ol><div></div><p class="calibre8">Now let's define an<a id="id232" class="calibre1"/> interface that offers a method for each scenario. The method is as follows:</p><div><pre class="programlisting">public interface IWebService
{
  Task&lt;User&gt; Login(string username, string password);
  Task&lt;User&gt; Register(User user);
  Task&lt;User[]&gt; GetFriends(string userId);
  Task&lt;User&gt; AddFriend(string userId, string username);
  Task&lt;Conversation[]&gt; GetConversations(string userId);
  Task&lt;Message[]&gt; GetMessages(string conversationId);
  Task&lt;Message&gt; SendMessage(Message message);
}</pre></div><p class="calibre8">As you can see, we're simplifying any asynchronous communication with a web service by leveraging the<a id="id233" class="calibre1"/> <strong class="calibre2">Task Parallel Library</strong> (<strong class="calibre2">TPL</strong>) from the .NET base class libraries.</p><p class="calibre8">Since communicating with a web service can be a lengthy process, it is always a good idea to use the <code class="literal">Task&lt;T&gt;</code> class for these operations. Otherwise, you can inadvertently run a lengthy task on the user interface thread, which will prevent user input during the operation. <code class="literal">Task</code> is definitely needed for web requests, since users could be using a cellular Internet connection on iOS and Android, and it will give us the ability to use the <code class="literal">async</code> and <code class="literal">await</code> keywords down the road.</p><p class="calibre8">Now let's implement a<a id="id234" class="calibre1"/> fake service that implements this interface. Place classes such as <code class="literal">FakeWebService</code> in the <code class="literal">Fakes</code> folder of the project. Let's start with the class declaration and the first method of the interface:</p><div><pre class="programlisting">public class FakeWebService
{
  public int SleepDuration { get; set; }

  public FakeWebService()
  {
    SleepDuration = 1;
  }
  private Task Sleep()
  {
    return Task.Delay(SleepDuration);
  }
  public async Task&lt;User&gt; Login(string username, string password)
  {
    await Sleep();
    return new User { Id = "1", Username = username };
  }
}</pre></div><p class="calibre8">We started off with a <code class="literal">SleepDuration</code> property to store a number in milliseconds. This is used to simulate an interaction with a web server, which can take some time. It is also useful for changing the <code class="literal">SleepDuration</code> value in different situations. For example, you might want to set this to a small number when writing unit tests so that the tests execute quickly.</p><p class="calibre8">Next, we implemented a <a id="id235" class="calibre1"/>simple <code class="literal">Sleep</code> method to return a task that introduces a delay of a number <a id="id236" class="calibre1"/>of milliseconds. This method will be used throughout the fake service to cause a delay on each operation.</p><p class="calibre8">Finally, the <code class="literal">Login</code> method <a id="id237" class="calibre1"/>merely used an <code class="literal">await</code> call on the <code class="literal">Sleep</code> method and returned a <code class="literal">new User</code> object with the appropriate <code class="literal">Username</code>. For now, any username or password combination will work; however, you might wish to write some code here to check specific credentials.</p><p class="calibre8">Now, let's implement a few more methods to continue our <code class="literal">FakeWebService</code> class as follows:</p><div><pre class="programlisting">public async Task&lt;User&gt; Register(User user)
{
  await Sleep();

  return user;
}
public async Task&lt;User[]&gt; GetFriends(string userId)
{
  await Sleep();

  return new[]
  {
    new User { Id = "2", Username = "bobama" },
    new User { Id = "3", Username = "bobloblaw" },
    new User { Id = "4", Username = "gmichael" },
  };
}
public async Task&lt;User&gt; AddFriend(string userId, string username)
{
  await Sleep();
  return new User { Id = "5", Username = username };
}</pre></div><p class="calibre8">For each of these methods, we used exactly the same pattern as the <code class="literal">Login</code> method. Each method<a id="id238" class="calibre1"/> will delay and return some sample data. Feel free to mix the data with your own values.</p><p class="calibre8">Now, let's implement the <a id="id239" class="calibre1"/><code class="literal">GetConversations</code> method required by the interface as follows:</p><div><pre class="programlisting">public async Task&lt;Conversation[]&gt; GetConversations(string userId)
{
  await Sleep();

  return new[]
  {
    new Conversation { Id = "1", UserId = "2" },
    new Conversation { Id = "2", UserId = "3" },
    new Conversation { Id = "3", UserId = "4" },
  };
}</pre></div><p class="calibre8">Basically, we just create a new array of the <code class="literal">Conversation</code> objects with arbitrary IDs. We also make sure to match up the <code class="literal">UserId</code> values with the IDs we have used on the <code class="literal">User</code> objects so far.</p><p class="calibre8">Next, let's implement <code class="literal">GetMessages</code> to retrieve a list of messages as follows:</p><div><pre class="programlisting">public async Task&lt;Message[]&gt; GetMessages(int conversationId)
{
  await Sleep();

  return new[]
  {
    new Message
    {
      Id = "1",
      ConversationId = conversationId,
      UserId = "2",
      Text = "Hey",
    },
    new Message
    {
      Id = "2",
      ConversationId = conversationId,
      UserId = "1",
      Text = "What's Up?",
    },
    new Message
    {
      Id = "3",
      ConversationId = conversationId,
      UserId = "2",
      Text = "Have you seen that new movie?",
    },
    new Message
    {
      Id = "4",
      ConversationId = conversationId,
      UserId = "1",
      Text = "It's great!",
    },
  };
}</pre></div><p class="calibre8">Once again, we are adding some arbitrary data here, and mainly making sure that <code class="literal">UserId</code> and <code class="literal">ConversationId</code> match <a id="id240" class="calibre1"/>our existing data so far.</p><p class="calibre8">And finally, we will write one more method to send a message, as follows:</p><div><pre class="programlisting">public async Task&lt;Message&gt; SendMessage(Message message)
{
  await Sleep();

  return message;
}</pre></div><p class="calibre8">Most of these methods are very straightforward. Note that the service doesn't have to work perfectly; it should merely complete each operation successfully with a delay. Each method should also return test data of some kind to be displayed in the UI. This will give us the ability to implement our iOS and Android applications while filling in the web service later.</p><p class="calibre8">Next, we need to implement a<a id="id241" class="calibre1"/> simple interface for persisting application settings. Let's define an interface named <code class="literal">ISettings</code> as follows:</p><div><pre class="programlisting">public interface ISettings
{
  User User { get; set; }
  void Save();
}</pre></div><p class="calibre8">We are making <code class="literal">ISettings</code> synchronous, but you might want to set up the <code class="literal">Save</code> method to be asynchronous and return <code class="literal">Task</code> if you plan on storing settings in the cloud. We don't really need this with our application since we will only be saving our settings locally.</p><p class="calibre8">Later on, we'll implement this interface on each platform using Android and iOS APIs. For now, let's just implement a fake version that will be used later when we write unit tests. We will implement the interface with the following lines of code:</p><div><pre class="programlisting">public class FakeSettings : ISettings
{
  public User User { get; set; }
  public void Save() { }
}</pre></div><p class="calibre8">Note that the fake version doesn't actually need to do anything; we just need to provide a class that will implement the interface and not throw any unexpected errors.</p><p class="calibre8">This completes the Model layer of the application. Here is a final class diagram of what we have implemented so far:</p><div><img src="img/00028.jpeg" alt="Writing a mock web service" class="calibre9"/></div><p class="calibre10"> </p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec33" class="calibre1"/>Writing the ViewModel layer</h1></div></div></div><pre>ViewModels</code> folder within your project:</pre><div><pre class="programlisting">public class BaseViewModel
{
  protected readonly IWebService service = ServiceContainer.Resolve&lt;IWebService&gt;();
  protected readonly ISettings settings = ServiceContainer.Resolve&lt;ISettings&gt;();

  public event EventHandler IsBusyChanged = delegate { };

  private bool isBusy = false;
  public bool IsBusy
  {
    get { return isBusy; }
    set
    {
      isBusy = value;
      IsBusyChanged(this, EventArgs.Empty);
    }
  }
}</pre></div><p class="calibre8">The <code class="literal">BaseViewModel</code> class is a great place to place any common functionality that you plan on reusing throughout your application. For this app, we only need to implement some functionality to indicate whether the ViewModel layer is busy. We provided a property and an event that the UI will be able to subscribe to and display a wait indicator on the screen. We also added some fields for the services that will be needed. Another common functionality that could be added would be validation for user inputs; however, we don't really need it for this application.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec11" class="calibre1"/>Implementing our LoginViewModel class</h2></div></div></div><p class="calibre8">Now that we have a base<a id="id244" class="calibre1"/> class for all of the ViewModel layers, we can implement a ViewModel layer for the first screen in our application, the <a id="id245" class="calibre1"/><strong class="calibre2">Login</strong> screen.</p><p class="calibre8">Now let's implement a <code class="literal">LoginViewModel</code> class as follows:</p><div><pre class="programlisting">public class LoginViewModel : BaseViewModel
{
  public string Username { get; set; }
  public string Password { get; set; }
  public async Task Login()
  {
    if (string.IsNullOrEmpty(Username))
      throw new Exception("Username is blank.");

    if (string.IsNullOrEmpty(Password))
      throw new Exception("Password is blank.");

    IsBusy = true;
    try
    {
      settings.User = await service.Login(Username, Password);
      settings.Save();
    }
    finally
    {
      IsBusy = false;
    }
  }
}</pre></div><p class="calibre8">In this class, we implemented the following:</p><div><ul class="itemizedlist"><li class="listitem">We subclassed <code class="literal">BaseViewModel</code> to get access to <code class="literal">IsBusy</code> and the fields that contain common services</li><li class="listitem">We added the <code class="literal">Username</code> and <code class="literal">Password</code> properties to be set by the View layer</li><li class="listitem">We added a <code class="literal">User</code> property to be set when the login process is completed</li><li class="listitem">We implemented a <code class="literal">Login</code> method to be called from View, with validation on the <code class="literal">Username</code> and <code class="literal">Password</code> properties</li><li class="listitem">We set <code class="literal">IsBusy</code> during the call to the <code class="literal">Login</code> method on <code class="literal">IWebService</code></li><li class="listitem">We set the <code class="literal">User</code> property by awaiting the result from <code class="literal">Login</code> on the web service</li></ul></div><p class="calibre8">Basically, this is the <a id="id246" class="calibre1"/>pattern that we'll follow for the rest of the ViewModel layers in the application. We provide properties for the View layer to be set by the user's input, and methods to call for various operations. If it is a method that could take some time, such as a web request, you should<a id="id247" class="calibre1"/> always return <code class="literal">Task</code> and use the <code class="literal">async</code> and <code class="literal">await</code> keywords.</p><div><h3 class="title2"><a id="tip06" class="calibre1"/>Tip</h3><p class="calibre8">Note that we used <code class="literal">try</code> and <code class="literal">finally</code> blocks for setting <code class="literal">IsBusy</code> back to <code class="literal">false</code>. This will ensure that it gets reset properly even when an exception is thrown. We plan on handling the error in the View layer so that we can display a native pop up to the user displaying a message.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec12" class="calibre1"/>Implementing our RegisterViewModel class</h2></div></div></div><p class="calibre8">Since we have finished<a id="id248" class="calibre1"/> writing our <code class="literal">ViewModel</code> class to<a id="id249" class="calibre1"/> log in, we will now need to create one for the user's registration.</p><p class="calibre8">Let's implement another ViewModel layer to register a new user:</p><div><pre class="programlisting">public class RegisterViewModel : BaseViewModel
{
  public string Username { get; set; }
  public string Password { get; set; }
  public string ConfirmPassword { get; set; }
}</pre></div><p class="calibre8">These properties will handle inputs from the user. Next, we need to add a <code class="literal">Register</code> method as follows:</p><div><pre class="programlisting">public async Task Register()
{
  if (string.IsNullOrEmpty(Username))
    throw new Exception("Username is blank.");
  if (string.IsNullOrEmpty(Password))
    throw new Exception("Password is blank.");
  if (Password != ConfirmPassword)
    throw new Exception("Passwords don't match.");
  IsBusy = true;
  try
  {
    settings.User = await service.Register(new User { Username = Username, Password = Password, });
    settings.Save();
  }
  finally
  {
    IsBusy = false;
  }
}</pre></div><p class="calibre8">The<a id="id250" class="calibre1"/> <code class="literal">RegisterViewModel</code> class is very similar to the <code class="literal">LoginViewModel</code> class, but has an additional <code class="literal">ConfirmPassword</code> property for the UI to be set. A good rule to follow for when to split the ViewModel layer's functionality is to always create a new class when the UI has a new screen. This helps you keep your code clean and somewhat follow the<strong class="calibre2"> Single Responsibility Principal (SRP)</strong> for your classes. The <strong class="calibre2">SRP</strong> states that a class<a id="id251" class="calibre1"/> should only have a single purpose or responsibility. We'll try to follow this concept to keep our classes small and organized, which can be more important than usual when sharing code across platforms.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec13" class="calibre1"/>Implementing our FriendViewModel class</h2></div></div></div><p class="calibre8">Next on the list is a <a id="id252" class="calibre1"/>ViewModel layer to work with a user's friend list. We will need a method to load a user's friend list<a id="id253" class="calibre1"/> and add a new friend.</p><p class="calibre8">Now let's implement the <code class="literal">FriendViewModel</code> as follows:</p><div><pre class="programlisting">public class FriendViewModel : BaseViewModel
{
  public User[] Friends { get; private set; }
  public string Username { get; set; }
}</pre></div><p class="calibre8">Now we'll need a method to load friends. This method is as follows:</p><div><pre class="programlisting">public async Task GetFriends()
{
  if (settings.User == null)
    throw new Exception("Not logged in.");

  IsBusy = true;
  try
  {
    Friends = await service.GetFriends(settings.User.Id);
  }
  finally
  {
    IsBusy = false;
  }
}</pre></div><p class="calibre8">Finally, we'll need a<a id="id254" class="calibre1"/> method to add a new friend and <a id="id255" class="calibre1"/>then update the list of friends contained locally:</p><div><pre class="programlisting">public async Task AddFriend()
{
  if (settings.User == null)
    throw new Exception("Not logged in.");

  if (string.IsNullOrEmpty(Username))
    throw new Exception("Username is blank.");

  IsBusy = true;
  try
  {
    var friend = await service.AddFriend(settings.User.Id, Username);

    //Update our local list of friends
    var friends = new List&lt;User&gt;();
    if (Friends != null)
      friends.AddRange(Friends);
    friends.Add(friend);

    Friends = friends.OrderBy(f =&gt; f.Username).ToArray();
  }
  finally
  {
    IsBusy = false;
  }
}</pre></div><p class="calibre8">Again, this class is fairly straightforward. The only thing new here is that we added some logic to update the list of<a id="id256" class="calibre1"/> friends and sort them <a id="id257" class="calibre1"/>within our client application and not the server. You can also choose to reload the complete list of friends if you have a good reason to do so.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec14" class="calibre1"/>Implementing our MessageViewModel class</h2></div></div></div><p class="calibre8">Our final required ViewModel layer<a id="id258" class="calibre1"/> will handle messages and conversations. We need to create a way to load conversations and messages and<a id="id259" class="calibre1"/> send a new message.</p><p class="calibre8">Let's start implementing our <code class="literal">MessageViewModel</code> class as follows:</p><div><pre class="programlisting">public class MessageViewModel : BaseViewModel
{
  public Conversation[] Conversations { get; private set; }
  public Conversation Conversation { get; set; }
  public Message[] Messages { get; private set; }
  public string Text { get; set; }
}</pre></div><p class="calibre8">Next, let's implement a method to retrieve a list of conversations as follows:</p><div><pre class="programlisting">public async Task GetConversations()
{
  if (settings.User == null)
    throw new Exception("Not logged in.");

  IsBusy = true;
  try
  {
    Conversations = await service.GetConversations(settings.User.Id);
  }
  finally
  {
    IsBusy = false;
  }
}</pre></div><p class="calibre8">Similarly, we need to retrieve a list of messages within a conversation. We will need to pass the conversation<a id="id260" class="calibre1"/> ID to the service as<a id="id261" class="calibre1"/> follows:</p><div><pre class="programlisting">public async Task GetMessages()
{
  if (Conversation == null)
    throw new Exception("No conversation.");

  IsBusy = true;
  try
  {
    Messages = await service.GetMessages(Conversation.Id);
  }
  finally
  {
    IsBusy = false;
  }
}</pre></div><p class="calibre8">Finally, we need to write some code to send a message and update the local list of messages as follows:</p><div><pre class="programlisting">public async Task SendMessage()
{
  if (settings.User == null)
    throw new Exception("Not logged in.");

  if (Conversation == null)
    throw new Exception("No conversation.");

  if (string.IsNullOrEmpty (Text))
    throw new Exception("Message is blank.");

  IsBusy = true;
  try
  {
    var message = await service.SendMessage(new Message 
    {
      UserId = settings.User.Id,ConversationId = Conversation.Id, 
      Text = Text
    });
    //Update our local list of messages
    var messages = new List&lt;Message&gt;();
    if (Messages != null)
      messages.AddRange(Messages);
    messages.Add(message);

    Messages = messages.ToArray();
  }
  finally
  {IsBusy = false;
  }
}</pre></div><p class="calibre8">This concludes the ViewModel layer of our application and the entirety of the shared code used on iOS and <a id="id262" class="calibre1"/>Android. For the <code class="literal">MessageViewModel</code> class, you could have also chosen to put the <code class="literal">GetConversations</code> and <code class="literal">Conversations</code> properties in their own class, since they can be considered as a separate<a id="id263" class="calibre1"/> responsibility, but it is not really necessary.</p><p class="calibre8">Here is the final class diagram of our ViewModel layer:</p><div><img src="img/00029.jpeg" alt="Implementing our MessageViewModel class" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec34" class="calibre1"/>Writing unit tests</h1></div></div></div><p class="calibre8">Since all the code we've written so far is not dependent on the user interface, we can easily write unit tests against our classes. This step is generally taken after the first implementation of a <code class="literal">ViewModel</code> class. Proponents<a id="id264" class="calibre1"/> of <strong class="calibre2">Test Driven Development</strong> (<strong class="calibre2">TDD</strong>) would recommend writing tests first and implementing things afterward, so choose which method is best for you. In either case, it is a good idea to write tests against your shared code before you start using them from the View layer, so that you can catch bugs before they hold up your development on the UI.</p><p class="calibre8">Xamarin projects take <a id="id265" class="calibre1"/>advantage of an open source testing framework called <a id="id266" class="calibre1"/><strong class="calibre2">NUnit</strong>. It was originally derived from a Java testing framework called<a id="id267" class="calibre1"/> <strong class="calibre2">JUnit</strong>, and it is the de-facto standard for unit testing C# applications. Xamarin Studio provides several project templates for writing tests with <strong class="calibre2">NUnit</strong>.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec15" class="calibre1"/>Setting up a new project for unit tests</h2></div></div></div><p class="calibre8">Let's set up a new project for<a id="id268" class="calibre1"/> unit tests by performing the<a id="id269" class="calibre1"/> following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Add a new <strong class="calibre2">NUnit Library</strong> <strong class="calibre2">Project</strong> to your solution, which is found under the <strong class="calibre2">C#</strong> section.</li><li class="listitem" value="2">Name the project <code class="literal">XamChat.Tests</code> to keep things consistent.</li><li class="listitem" value="3">Next, let's set the library to a Mono/.NET 4.5 project under <strong class="calibre2">Project Options</strong>, then navigate to <strong class="calibre2">Build</strong> | <strong class="calibre2">General</strong> | <strong class="calibre2">Target Framework</strong>.</li><li class="listitem" value="4">Right-click on <strong class="calibre2">Project References</strong> and choose <strong class="calibre2">Edit References</strong>.</li><li class="listitem" value="5">Under the <strong class="calibre2">Projects</strong> tab, add a reference to <strong class="calibre2">XamChat.Core</strong>.</li><li class="listitem" value="6">Now, open the <code class="literal">Test.cs</code> file and you will notice the following required attributes that make up a unit test using NUnit:<div><ul class="itemizedlist1"><li class="listitem"><code class="literal">using NUnit.Framework</code>: This attribute is the main statement to be used to work with NUnit</li><li class="listitem"><code class="literal">[TestFixture]</code>: This decorates a class to indicate that the class has a list of methods for running tests</li><li class="listitem"><code class="literal">[Test]</code>: This decorates a method to indicate a test</li></ul></div></li></ol><div></div><p class="calibre8">In addition to the required C# attributes, there are several others that are useful for writing tests, and they are as follows:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">[TestFixtureSetUp]</code>: This decorates a method that runs before all the tests contained within a text fixture class.</li><li class="listitem"><code class="literal">[SetUp]</code>: This decorates a method that runs before each test in a test fixture class.</li><li class="listitem"><code class="literal">[TearDown]</code>: This decorates a method that runs after each test in a test fixture class.</li><li class="listitem"><code class="literal">[TestFixtureTearDown]</code>: This decorates a method that runs after all the tests in a text fixture class have been completed.</li><li class="listitem"><code class="literal">[ExpectedException]</code>: This decorates a method that is intended to throw an exception. It is useful for test cases that are supposed to fail.</li><li class="listitem"><code class="literal">[Category]</code>: This decorates a test method and can be used to organize different tests; for example, you might categorize them as fast and slow tests.</li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec16" class="calibre1"/>Writing assertions</h2></div></div></div><p class="calibre8">The next concept to learn about <a id="id270" class="calibre1"/>writing tests with NUnit is how to write <strong class="calibre2">assertions</strong>. An assertion is a method that will throw an exception if a certain value is not true. It will cause a<a id="id271" class="calibre1"/> test to fail and give a descriptive explanation as to what happened. NUnit has a couple of different sets of APIs for assertions; however, we will use the more readable and fluent versions of the APIs.</p><p class="calibre8">The basic syntax of a fluent-style API is<a id="id272" class="calibre1"/> using the <code class="literal">Assert.That</code> method. The following example this:</p><div><pre class="programlisting">Assert.That(myVariable, Is.EqualTo(0));</pre></div><p class="calibre8">Likewise, you can assert the opposite:</p><div><pre class="programlisting">Assert.That(myVariable, Is.Not.EqualTo(0));</pre></div><p class="calibre8">Or any of the following:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">Assert.That(myVariable, Is.GreaterThan(0));</code></li><li class="listitem"><code class="literal">Assert.That(myBooleanVariable, Is.True);</code></li><li class="listitem"><code class="literal">Assert.That(myObject, Is.Not.Null);</code></li></ul></div><p class="calibre8">Feel free to explore the APIs. With code completion in Xamarin Studio, you should be able to discover useful static members or methods on the <code class="literal">Is</code> class to use within your tests.</p><p class="calibre8">Before we begin writing specific tests for our application, let's write a static class and method to create a global setup to be used throughout our tests. You can rewrite <code class="literal">Test.cs</code> as follows:</p><div><pre class="programlisting">public static class Test
{
  public static void SetUp()
  {
    ServiceContainer.Register&lt;IWebService&gt;(() =&gt;new FakeWebService { SleepDuration = 0 });
    ServiceContainer.Register&lt;ISettings&gt;(() =&gt;new FakeSettings());
  }
}</pre></div><p class="calibre8">We'll use this method throughout our tests to set up fake services in our Model layer. Additionally, this replaces the existing services so that our tests execute against new instances of these classes. This is a good practice in unit testing to guarantee that no old data is left behind from a previous test. Also, notice that we set <code class="literal">SleepDuration</code> to <code class="literal">0</code>. This will make our tests run very quickly.</p><p class="calibre8">We will begin by creating a <a id="id273" class="calibre1"/><code class="literal">ViewModels</code> folder in our test project and adding a class named <code class="literal">LoginViewModelTests</code> as follows:</p><div><pre class="programlisting">[TestFixture]
public class LoginViewModelTests
{
  LoginViewModel loginViewModel;
  ISettings settings;
  [SetUp]
  public void SetUp()
  {
    Test.SetUp();
    settings = ServiceContainer.Resolve&lt;ISettings&gt;();
    loginViewModel = new LoginViewModel();
  }
  [Test]
  public async Task LoginSuccessfully()
  {
    loginViewModel.Username = "testuser";
    loginViewModel.Password = "password";
    await loginViewModel.Login();
    Assert.That(settings.User, Is.Not.Null);
  }
}</pre></div><p class="calibre8">Notice our use of a <code class="literal">SetUp</code> method<a id="id274" class="calibre1"/>. We recreate the objects used in every test to make sure that no old data is left over from the previous test runs. Another point to note is that you must return a <code class="literal">Task</code> when using <code class="literal">async</code>/<code class="literal">await</code> in a test method. Otherwise, NUnit would not be able to<a id="id275" class="calibre1"/> know when a test completes.</p><p class="calibre8">To run the test, use the NUnit menu found docked to the right of Xamarin Studio, by default. Go ahead and run the test using the <strong class="calibre2">Run Test</strong> button that has a gear icon. You will get a successful result similar to what is shown in the following screenshot:</p><div><img src="img/00030.jpeg" alt="Writing assertions" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">You can also<a id="id276" class="calibre1"/> view the <strong class="calibre2">Test Results</strong> pane, which will show you the extended details if a test fails, as shown in<a id="id277" class="calibre1"/> the following screenshot:</p><div><img src="img/00031.jpeg" alt="Writing assertions" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">To see what happens when a test fails, go ahead and modify your test to assert against an incorrect value as follows:</p><div><pre class="programlisting">//Change Is.Not.Null to Is.Null
Assert.That(settings.User, Is.Null);</pre></div><p class="calibre8">You will get a very <a id="id278" class="calibre1"/>descriptive error in the <strong class="calibre2">Test Results</strong> pane, as shown in the following screenshot:</p><div><img src="img/00032.jpeg" alt="Writing assertions" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Now let's implement<a id="id279" class="calibre1"/> another test for the <code class="literal">LoginViewModel</code> class; let's make sure that we get the appropriate outcome if the username and password fields are blank. The test is implemented as follows:</p><div><pre class="programlisting">[Test]
public async Task LoginWithNoUsernameOrPassword()
{
  //Throws an exception
  await loginViewModel.Login();
}</pre></div><p class="calibre8">If we run the test as it is, we will get an exception and the test will fail. Since we expect an exception to occur, we can decorate the method to make the test pass only if an exception occurs as follows:</p><div><pre class="programlisting">[Test, 
  ExpectedException(typeof(Exception), 
  ExpectedMessage = "Username is blank.")]</pre></div><div><h3 class="title2"><a id="tip07" class="calibre1"/>Tip</h3><p class="calibre8">Note that in our ViewModel, the Exception type is thrown if a field is blank. You can also change the type of expected exception in cases where it is a different exception type.</p></div><p class="calibre8">More tests are included with the sample code along with this book. It is recommended that you write tests against each <a id="id280" class="calibre1"/>public operation on each <code class="literal">ViewModel</code> class. Additionally, write tests for any validation or other important business logic. I would also recommend that you write tests<a id="id281" class="calibre1"/> against the Model layer; however, this is not needed in our project yet since we only have fake implementations.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec35" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we went through the concept of building a sample application called XamChat. We also implemented the core business objects for the application in the Model layer. Since we do not have a server to support this application yet, we implemented a fake web service. This gives you the flexibility to move forward with the app without building a server application. We also implemented the ViewModel layer. This layer will expose operations in a simple way to the View layer. Finally, we wrote tests covering the code we've written so far using NUnit. Writing tests against shared code in a cross-platform application can be very important, as it is the backbone of more than one application.</p><p class="calibre8">After completing this chapter, you should have completed the shared library for our cross-platform application in its entirety. You should have a very firm grasp on our application's architecture and its distinct Model and ViewModel layers. You should also have a good understanding of how to write fake versions of parts of your application that you might not be ready to implement yet. In the next chapter, we will implement the iOS version of XamChat.</p></div></body></html>