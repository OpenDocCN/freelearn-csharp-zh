- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core Fundamentals (Part 1)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to create a basic REST API using ASP.NET
    Core. ASP.NET Core provides a lot of features that make it easy to build web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Routing** is used to map incoming requests to the corresponding controller
    actions. We will discuss how to use attribute routing to configure the routing
    for ASP.NET Core web APIs. **Configuration** is used to provide the initial settings
    for an application on its startup, such as database connection strings, API keys,
    and other settings. Configuration is often used with **environments**, such as
    development, staging, and production. At the conclusion of this chapter, you will
    have the skills to create RESTful routes for your ASP.NET Core web APIs and utilize
    the ASP.NET Core configuration framework to manage configurations for different
    environments.'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code examples in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8).
  prefs: []
  type: TYPE_NORMAL
- en: You can use Visual Studio 2022 or **VS Code** to open the solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18971_02.xhtml#_idTextAnchor068)*,* we introduced how to create
    a simple ASP.NET Core web API project using the default controller-based template.
    The project uses some attributes, such as `[Route("api/controller")]`, `[HttpGet]`,
    and so on, to map incoming requests to the corresponding controller actions. These
    attributes are used to configure the routing for the ASP.NET Core web API project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Routing is a mechanism that monitors incoming requests and determines which
    action method is to be invoked for those requests. ASP.NET Core provides two types
    of routing: conventional routing and attribute routing. Conventional routing is
    typically used for ASP.NET Core MVC applications, while ASP.NET Core web APIs
    use attribute routing. In this section, we will discuss attribute routing in more
    detail.'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the `RoutingDemo` sample project from `/samples/chapter3/RoutingDemo/`
    in the chapter's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: What is attribute routing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `Program.cs` file in the `RoutingDemo` project. You will find the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code adds endpoints for controller actions to the `IEndpointRouteBuilder`
    instance without specifying any routes. To specify the routes, we need to use
    the `[Route]` attribute on the controller class and the action methods. The following
    code shows how to use the `[Route]` attribute on the `WeatherForecastController`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `[controller]` token is a placeholder for the controller
    name. In this case, the controller name is `WeatherForecast`, so the `[controller]`
    route template is replaced with `WeatherForecast`. That means the route for the
    `WeatherForecastController` class is `/WeatherForecast`.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core has some built-in route tokens, such as `[controller]`, `[action]`,
    `[area]`, `[page]`, and so on. These tokens are enclosed in square brackets (`[]`)
    and will be replaced with the corresponding values. Note that these tokens are
    reserved route parameter names and should not be used as a route parameter like
    `{controller}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ASP.NET Core REST web APIs, we usually use a `[Route("api/[controller]")]`
    template to represent API endpoints. You can find the `PostsController` class
    in the `Controllers` folder. The following code shows the routing attribute of
    the `PostsController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The route for the `PostsController` class is `/api/Posts`. This is an indication
    that the endpoint is a REST API endpoint. Whether you use `/api` as the route
    prefix or not is up to you. There is no standard for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some developers prefer to use lowercase for route templates, such as `/api/posts`.
    To achieve this, the route value can be explicitly specified; for example, `[Route("api/posts")]`.
    However, it seems a bit tedious to specify the route value for each controller
    class. Fortunately, ASP.NET Core provides a way to configure the route value globally.
    Add the following code to the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code converts all route templates to lowercase. Actually, the
    text matching in ASP.NET Core routing is case-insensitive. So, this change only
    affects the generated paths’ URLs, such as the URLs in Swagger UI and the `/api/Posts`
    or `/api/posts` to hit the same controller route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple routes can be applied to one controller class. The following code
    shows how to apply multiple routes to the `PostsController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the `PostsController` class has two routes: `/api/posts` and
    `/api/some-posts-whatever`. It is not recommended to have multiple routes for
    the same controller class as this can lead to confusion. If you require multiple
    routes for the same controller class, please ensure that you have strong reasons
    for doing so.'
  prefs: []
  type: TYPE_NORMAL
- en: In ASP.NET Core REST APIs, we usually do not use the `[action]` token because
    the action name is not included in the route template. Similarly, do not use the
    `[Route]` attribute for action methods. Instead, we use the HTTP method to distinguish
    action methods. We will discuss this in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping HTTP methods to action methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'REST APIs are centered on resources. When we design a REST API, we need to
    map the CRUD operations to the HTTP methods. In ASP.NET Core, we can use the following
    HTTP verb attributes to map HTTP methods to action methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[HttpGet]` maps an HTTP `GET` method to an action method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[HttpPost]` maps an HTTP `POST` method to an action method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[HttpPut]` maps an HTTP `PUT` method to an action method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[HttpDelete]` maps an HTTP `DELETE` method to an action method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[HttpPatch]` maps an HTTP `PATCH` method to an action method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[HttpHead]` maps an HTTP `HEAD` method to an action method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows how to use the `[HttpGet]` attribute to map the HTTP
    `GET` method to the `GetPosts()` action method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In ASP.NET Core REST APIs, each action must have an HTTP verb attribute. If
    you do not specify an HTTP verb attribute, the framework cannot determine which
    method should be invoked for the incoming request. In the preceding code, a `GET`
    request to the `/api/posts` endpoint is mapped to the `GetPosts()` action method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to use the `[HttpGet]` attribute to map the HTTP
    `GET` method to the `GetPost()` action method with a route template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `HttpGet` attribute has an `{id}` route template, which is a route
    parameter. The route parameter is enclosed in curly braces ( `{}`). The route
    parameter is used to capture the value from the incoming request. For example,
    a `GET` request to the `/api/posts/1` endpoint is mapped to the `GetPost(int id)`
    action method, and the value `1` is captured by the `{id}` route parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to use the `[HttpPut]` attribute to publish a
    post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `HttpPut` attribute has an `{id}/publish` route template. The
    `publish` literal is used to match the `publish` literal in the incoming request.
    So, a `PUT` request to the `/api/posts/1/publish` endpoint is mapped to the `PublishPost(int
    id)` action method, and the value `1` is captured by the `{id}` route parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'When defining a route template, please make sure there are no conflicts. For
    example, we want to add a new action method to get posts by a user ID. If we use
    the following code, it will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because we already have a `GetPost()` action method that uses `[HttpGet("{id}")]`.
    When sending a `GET` request to the `/api/posts/1` endpoint, the request matches
    multiple actions, so you will see a `500` error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To fix it, we need to specify a different template, such as `[HttpGet("user/{userId}")]`.
  prefs: []
  type: TYPE_NORMAL
- en: Route constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we introduced how to use a route parameter to capture
    the value from an incoming request. A `[HttpGet("{id}")]` attribute can match
    a `GET` request to the `/api/posts/1` endpoint. But what if the request is a `GET`
    request to the `/``api/posts/abc` endpoint?
  prefs: []
  type: TYPE_NORMAL
- en: As the `id` parameter is of type `int`, the framework will try to convert the
    captured value to an `int` value. If the conversion fails, the framework will
    return a `400 Bad Request` response. So, a `GET` request to the `/api/posts/abc`
    endpoint will fail and return a `400 Bad` `Request` response.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add route constraints to route parameters to restrict the values of
    the route parameters. For example, we can add a route constraint to the `id` parameter
    to ensure that the `id` parameter is an integer. The following code shows how
    to add a route constraint to the `id` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `id` parameter must be an integer. A `GET` request to the `/api/posts/abc`
    endpoint will return a `404 Not Found` response because the route does not match.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core provides a set of built-in route constraints, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int`: The parameter must be an integer value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool`: The parameter must be a Boolean value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`datetime`: The parameter must be a DateTime value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal`: The parameter must be a `decimal` value. Similarly, there are `double`,
    `float`, `long`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`guid`: The parameter must be a GUID value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minlength(value)`: The parameter must be a string with a minimum length; for
    example, `{name:minlength(6)}`, which means the `name` parameter must be a string
    and the length of the string must be at least 6 characters. Similarly, there are
    `maxlength(value)`, `length(value)`, `length(min, max)`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min(value)`: The parameter must be an integer with a minimum value; for example,
    `{id:min(1)}`, which means the `id` parameter must be an integer and the value
    must be greater than or equal to 1\. Similarly, there are `max(value)`, `range(min,`
    `max)`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alpha`: The parameter must be a string with one or more letters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regex(expression)`: The parameter must be a string that matches the regular
    expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required`: The parameter must be provided in the route; for example, `{id:required}`,
    which means the `id` parameter must be provided in the route.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value of the route parameter does not match the route constraint, the
    action method will not accept the request, and a `404 Not Found` response will
    be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple route constraints can be applied together. The following code shows
    how to apply multiple route constraints to the `id` parameter, which means the
    `id` parameter must be an integer and the value must be greater than or equal
    to 1 and less than or equal to 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Route constraints can be used to make a route more specific. However, they should
    not be used to validate the input. If the input is invalid, the API should return
    a `400 Bad Request` response rather than a `404 Not` `Found` response.
  prefs: []
  type: TYPE_NORMAL
- en: Binding source attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can define parameters in the action. See the following action method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `GetPost()` method has a parameter named `id`, which matches the parameter
    in the `{id}` route template. So, the value of `id` will come from the route,
    such as 1 in the `/api/posts/1` URL. This is called parameter inference.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core offers the following binding source attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[FromBody]`: The parameter is from the request body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromForm]`: The parameter is from the form data in the request body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromHeader]`: The parameter is from the request header'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromQuery]`: The parameter is from the query strings in the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromRoute]`: The parameter is from the route path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromServices]`: The parameter is from the **DI** container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, we can define a pagination action method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code means the `pageIndex` parameter and the `pageSize` parameter
    should be from query strings in the URL, such as `/api/posts/paged?pageIndex=1&pageSize=10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an `[ApiController]` attribute is applied to a controller class, a set
    of default inference rules will be applied, so we do not need to explicitly add
    these binding source attributes. For example, the following code shows a `POST`
    action method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `keyword` parameter is a simple type, so `[FromQuery]` inferred that the
    `keyword` parameter should be from the query strings in the URL, such as `/api/posts/search?keyword=xyz`.
    If we want to force the `keyword` parameter to be from the request body, we can
    use the `[FromBody]` attribute as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Then, the `keyword` parameter must be from the request body. Note that this
    is a bad example because we usually do not use the request body to pass a simple
    type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default inference rules of those binding source attributes are listed next:'
  prefs: []
  type: TYPE_NORMAL
- en: For complex type parameters, if the type is registered in the DI container,
    `[FromServices]` is inferred.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For complex type parameters that are not registered in the DI container, `[FromBody]`
    is inferred. It does not support multiple `[``FromBody]` parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For types such as `IFormFile` and `IFormFileCollection`, `[FromForm]` is inferred.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any parameters that appear in the route, `[FromRoute]` is inferred.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any parameters of simple types, such as `int`, `string`, and so on, `[FromQuery]`
    is inferred.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a parameter can be inferred based on these rules, the binding source attribute
    can be omitted. Otherwise, we need to explicitly specify the binding source attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Routing is a very important concept in REST APIs. Ensure that routes are well
    designed, intuitive, and easy to understand. This will help the consumers of your
    REST APIs use them easily.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will check the configuration in ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core provides a comprehensive configuration framework that makes it
    easy to work with configuration settings. A configuration is considered a key-value
    pair. These configuration settings are stored in a variety of sources, such as
    JSON files, environment variables, and command-line arguments, or in the cloud,
    such as Azure Key Vault. In ASP.NET Core, these sources are referred to as **configuration
    providers**. Each configuration provider is responsible for loading configuration
    settings from a specific source.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core supports a set of configuration providers, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The file configuration provider, such as, `appsettings.json`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The User secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The environment variables configuration provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command-line configuration provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Azure App Configuration provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Azure Key Vault configuration provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration of ASP.NET Core is provided by the `Microsoft.Extension.Configuration`
    NuGet package. You do not need to install this package explicitly as it is already
    installed with the default ASP.NET Core template, which provides several built-in
    configuration providers, such as `appsettings.json`. These configuration providers
    are configured in priority order. We will discuss this in more detail in the *Understanding
    the priorities of configuration and environment variables* section. First, let
    us look at how to use `appsettings.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create a new ASP.NET Core web API project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can download the example project named `ConfigurationDemo` from the `/samples/chapter3/ConfigurationDemo`
    folder in the chapter's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Using appsettings.json
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, ASP.NET Core apps are configured to read configuration settings
    from `appsettings.json` using `JsonConfigurationProvider`. The `appsettings.json`
    file is located in the project’s root directory, which is a JSON file that contains
    key-value pairs. The following code shows the default content of the `appsettings.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You will find another `appsettings.Development.json` file, which will be used
    for the development environment. We will introduce the environment in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us add a `"MyKey": "MyValue"` key-value pair to the `appsettings.json`
    file. This key-value pair is an example configuration that we will read in the
    code using `JsonConfigurationProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new controller named `ConfigurationController` in the `Controllers`
    folder. In this controller, we will read the configuration value from the `appsettings.json`
    file and return it as a string. The following code shows the `ConfigurationController`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the configuration settings, we need to inject the `IConfiguration`
    interface into the constructor of the controller. The `IConfiguration` interface
    represents a set of key/value application configuration properties. The following
    code shows how to access the configuration settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application and send a request to the `/Configuration/my-key` endpoint.
    You can use any HTTP client, such as Postman, Thunder Client in VS Code, or HttpRepl.
    The following code shows how to use HttpRepl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration supports hierarchical settings. For example, consider the
    following configuration settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the `Type` and `ConnectionString` properties, we can use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use a colon (`:`) to separate the hierarchical settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application and send a request to the `/Configuration/database-configuration`
    endpoint. If you use HttpRepl, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows a response from HttpRepl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Using the `IConfiguration` interface, we can access the configuration settings
    with the `configuration[key]` format. However, hardcoding the keys is not a good
    practice. To avoid hardcoding, ASP.NET Core supports the options pattern, which
    can provide a strongly typed way to access hierarchical settings.
  prefs: []
  type: TYPE_NORMAL
- en: Using the options pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the options pattern, we need to create a class that represents the configuration
    settings. The following code shows how to create a class named `DatabaseOption`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `SectionName` field is used to specify the section name in the `appsettings.json`
    file. This field is not mandatory. But if we do not define it here, we will need
    to pass a hardcoded string for the section name when we bind the configuration
    section. To better leverage the strong typing, we can define a `SectionName` field.
    The `Type` and `ConnectionString` properties are used to represent the `Type`
    and `ConnectionString` fields in the `appsettings.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Note that an option class must be non-abstract with a public parameterless constructor.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple ways to use the options pattern. Let's continue.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ConfigurationBinder.Bind() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, Let's use the `ConfigurationBinder.Bind()` method, which attempts to
    bind a given object instance to configuration values by recursively matching property
    names against configuration keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ConfigurationController` class, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Run the application and send a request to the `/Configuration/database-configuration-with-bind`
    endpoint. You will see the same response as in the previous section, *Using appsettings.json*.
    In this way, we can use the strongly typed option class to access the configuration
    settings, such as `databaseOption.Type`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ConfigurationBinder.Get<TOption>() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also use the `ConfigurationBinder.Get<TOption>()` method, which attempts
    to bind the configuration instance to a new instance of type `T`. If this configuration
    section has a value, then that value will be used; otherwise, it attempts to bind
    the configuration instance by matching property names against configuration keys
    recursively. The code is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Run the application and send a request to the `/Configuration/database-configuration-with-generic-type`
    endpoint. You will see the same response as in the *Using* *appsettings.json*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Using the IOptions<TOption> interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ASP.NET Core provides built-in DI support for the options pattern. To use DI,
    we need to register the `DatabaseOption` class in the `Services.Configure()` method
    of the `Program.cs` file. The following code shows how to register the `DatabaseOption`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use DI to inject the `IOptions<DatabaseOption>` interface into
    the `ConfigurationController` class. The following code shows how to inject the
    `IOptions<DatabaseOption>` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Run the application and send a request to the `/Configuration/database-configuration-with-ioptions`
    endpoint. You will see the same response as in the *Using* *appsettings.json*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Using other options interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have introduced several ways to use the options pattern. What differences
    do they have?
  prefs: []
  type: TYPE_NORMAL
- en: Run the application and test the preceding endpoints. You will see all responses
    are the same, which contains a `Type` property with the value `SQL Server`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep the application running. Let''s make a change to the `appsettings.json`
    file. Change the `Type` property from `SQL Server` to `MySQL`. Save the file and
    send the requests to these endpoints again. You will find the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '`database-configuration` returns the *new* value `MySQL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`database-configuration-with-bind` returns the *new* value `MySQL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`database-configuration-with-generic-type` returns the *new* value `MySQL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`database-configuration-with-ioptions` returns the *old* value `SQL Server`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try to use the `IOptionsSnapshot<T>` interface to replace the `IOptions<TOption>`
    interface. The `IOptionsSnapshot<TOption>` interface provides a snapshot of options
    for the current request. The following code shows how to use the `IOptionsSnapshot<TOption>`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Run the application again. Change the `Type` property in the `appsettings.json`
    file. Send requests to the `/Configuration/database-configuration-with-ioptions-snapshot`
    endpoint. You will find the response is the *new* value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, we now know the difference between the `IOptions<TOption>` interface
    and the `IOptionsSnapshot<TOption>` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: The `IOptions<TOption>` interface provides a way to access options, but it cannot
    get the latest value if the setting value has been changed when the application
    is running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IOptionsSnapshot<TOption>` interface provides a snapshot of options for
    the current request. The `IOptionsSnapshot<TOption>` interface is useful when
    we want to get the latest options for the current request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But why?
  prefs: []
  type: TYPE_NORMAL
- en: 'The ASP.NET Core framework provides built-in support for `appsetting.json`
    using `JsonConfigurationProvider`, which reads the configuration values from the
    `appsettings.json` file. When the framework registers `JsonConfigurationProvider`,
    the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `reloadOnChange` parameter is set to `true`, which means the configuration
    values will be reloaded if the `appsettings.json` file has been changed. So, the
    `ConfigurationBinder.Bind()` method and the `ConfigurationBinder.Get<TOption>()`
    method can get the latest value.
  prefs: []
  type: TYPE_NORMAL
- en: However, when the `IOptions<TOption>` interface is registered by the ASP.NET
    Core framework, it is registered as a *singleton* service, which means an instance
    of `IOption<TOption>` will be created only once. You can inject it into any service
    lifetime, but it cannot read the latest value if the setting value has been changed.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the `IOptionsSnapshot<TOption>` interface is registered as a *scoped*
    service, so it cannot be injected into a singleton service. It is useful in scenarios
    if you want to get the latest options for each request.
  prefs: []
  type: TYPE_NORMAL
- en: It looks like `IOptionsSnapshot<TOption>` is better than `IOptions<TOption>`.
    Not really. `IOptionsSnapshot<TOption>` can only cache options for the current
    request. It may cause performance issues because it is recomputed per request.
    So, you need to choose the interface to use wisely. If the options are not changed,
    you can use the `IOptions<TOption>` interface. If the options are changed frequently
    and you want to ensure the app gets the latest value per request, you can use
    the `IOptionsSnapshot<TOption>` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another options interface called `IOptionsMonitor<TOption>`. It is
    a combination of the `IOptions<TOption>` and the `IOptionsSnapshot<TOption>` interfaces.
    It provides the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a singleton service, which can be injected into any service lifetime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports reloadable configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of using the `IOptionsMonitor<TOption>` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `IOptionsMonitor<TOption>` interface provides the `CurrentValue` property
    to get the latest value. It also provides the `OnChange(Action<TOption, string>
    listener)` method to register a listener that will be called whenever the options
    are reloaded. Normally, you do not need to use the `OnChange()` method unless
    you want to do something when the options are reloaded.
  prefs: []
  type: TYPE_NORMAL
- en: Using named options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, we need to use multiple database instances in our application. Consider
    the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than creating two classes to represent the two database options, we
    can use the named options feature. The following code shows how to use the named
    options feature for each section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, register the named options feature in the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows how to access the named options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application and send a request to the `/Configuration/database-configuration-with-named-options`
    endpoint. You will find the response contains the two database options, as shown
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, Let''s summarize the options feature in ASP.NET Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Server lifetime** | **Reloadable** **configuration** | **Named options**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `IOptions<TOption>` | Singleton | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| `IOptionsSnapshot<TOption>` | Scope | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `IOptionsMonitor<TOption>` | Singleton | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: Table 3.1 – Summary of the options feature in `ASP.NET` Core
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how to register a group of options to make the `Program.cs`
    file cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: Group options registration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](B18971_02.xhtml#_idTextAnchor068), we introduced how to use
    group registration to register multiple services in an extension method. The group
    registration feature is also available for the options feature. The following
    code shows how to use the group registration feature to register multiple options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, register the options in the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `Program.cs` file is much cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: Other configuration providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We mentioned that ASP.NET Core supports multiple configuration providers. The
    configuration provider for reading the `appsettings.json` file is `JsonConfigurationProvider`,
    which is derived from the `FileConfigurationProvider` base class. There are some
    other implementations of the `FileConfigurationProvider` base class, such as `IniConfigurationProvider`,
    `XmlConfigurationProvider`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides `JsonConfigurationProvider`, the ASP.NET Core framework automatically
    registers the following configuration providers:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Development` environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **non-prefixed environment variables configuration provider** is used to read
    environment variables that do not have a prefix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **command-line configuration provider** is used to read command-line arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us see more details about these configuration providers.
  prefs: []
  type: TYPE_NORMAL
- en: User secrets configuration provider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is not a good practice to store sensitive information in the `appsettings.json`
    file. For example, if the database connection string is stored in the `appsettings.json`
    file, developers may accidentally commit the database connection string (or other
    sensitive information, secrets, and so on) to the source control system, which
    will cause security issues.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can use the user secrets feature to store sensitive information
    in the local secrets file. The user secrets feature is only available in the `Development`
    environment. By default, the ASP.NET Core framework registers the user secrets
    configuration provider after the JSON configuration provider. Therefore, the user
    secrets configuration provider has higher priority than the JSON configuration
    provider, so it will override the JSON configuration provider if the same configuration
    key exists in both providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use user secrets, we need to use the Secret Manager tool to store the secrets
    in a local secrets file. Run the following command in the project folder to initialize
    a local secrets file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command creates a `UserSecretsId` property in the `.csproj` file.
    By default, the value of the `UserSecretsId` property is a GUID, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can use the Secret Manager tool to store secrets in the local secrets
    file. Run the following command from the project folder to store secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the preceding commands, a `secrets.json` file is created in the
    `%APPDATA%\Microsoft\UserSecrets\<UserSecretsId>` folder. The `secrets.json` file
    contains the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note that the JSON structure is flattened.
  prefs: []
  type: TYPE_NORMAL
- en: Location of the secrets.json file
  prefs: []
  type: TYPE_NORMAL
- en: If you use Linux or macOS, the `secrets.json` file is created in the `~/.``microsoft/usersecrets/<UserSecretsId>`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Run `dotnet run` to run the application and send a request to the `/Configuration/database-configuration`
    endpoint. You will find the response contains the database options from the user
    secrets, which overrides the database options from the `appsettings.json` file
    and contains a PostgreSQL database type.
  prefs: []
  type: TYPE_NORMAL
- en: The local secrets file is out of the project folder and not committed to the
    source control system. Keep in mind that the Secret Manager tool is only for development
    purposes. Developers should have the responsibility to protect the local secrets
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some commands to operate the local secrets file. You need to run
    the following commands from the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you download the code example for this section, the secrets file is not included
    in the repository. You need to run the `dotnet user-secrets init` command to initialize
    the secrets file on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables configuration provider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: .NET and ASP.NET Core define some environment variables that can be used to
    configure the application. These specific variables have a prefix of `DOTNET_`,
    `DOTNETCORE_`, or `ASPNETCORE_`. Variables that have the `DOTNET_` or `DOTNETCORE_`
    prefix are used to configure the .NET runtime. Variables that have the `ASPNETCORE_`
    prefix are used to configure ASP.NET Core. For example, the `ASPNETCORE_ENVIRONMENT`
    variable is used to set the environment name. We will discuss the environment
    in the *Environments* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'For those environment variables that do not have the `ASPNETCORE_` prefix,
    ASP.NET Core can also use the environment variables configuration provider to
    read them. Environment variables have a higher priority than the `appsettings.json`
    file. For example, we have the following configuration in the `appsettings.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we set the `Database__Type` environment variable to `MySQL`, the `Database__Type`
    value in the `appsettings.json` file will be overridden by the environment variable
    value. The following code shows how to access an environment variable in PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: To represent the hierarchical keys of environment variables, it is recommended
    to use `__` (double underscore) as a separator because it is supported by all
    platforms. Please do not use `:` because it is not supported by Bash.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following command to set an environment variable in PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To check if the environment variable is set correctly, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use Bash, you need to use the following command to set the environment
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`export Database__Type="SQLite"`'
  prefs: []
  type: TYPE_NORMAL
- en: For more information, please refer to [https://linuxize.com/post/how-to-set-and-list-environment-variables-in-linux/](https://linuxize.com/post/how-to-set-and-list-environment-variables-in-linux/).
  prefs: []
  type: TYPE_NORMAL
- en: Also, please note that, unlike in Windows, environment variable names are case-sensitive
    on macOS and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: You will see the output is `SQLite`. Now, in the same PowerShell session, you
    can use `dotnet run` to run the application and send a request to the `/Configuration/database-configuration`
    endpoint. You will find the response contains the `SQLite` value, even though
    the `appsettings.json` file contains the `SQL Server` value. That means the environment
    variable value overrides the `appsettings.json` file value.
  prefs: []
  type: TYPE_NORMAL
- en: Command-line configuration provider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Command-line arguments have a higher priority than environment variables. By
    default, the configuration settings set on the command line override values set
    with other configuration providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the example in the previous section, the `Database__Type` value is
    set to `SQL Server` in the `appsettings.json` file. We also set the `Database__Type`
    environment variable to `SQLite`. Now, let us change the value to `MySQL` in the
    command-line argument using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Send a request to the `/Configuration/database-configuration` endpoint. You
    will find the response contains the `MySQL` value, which means the command-line
    argument value overrides the environment variable value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Command-line arguments can also be set in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If `--` or `/` is used for the key, the value can follow a space. Otherwise,
    the value must follow the `=` sign. Please do not mix the two ways in the same
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Key Vault configuration provider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Azure Key Vault is a cloud-based service that provides secure storage for secrets,
    such as passwords, certificates, and keys. The Azure Key Vault configuration provider
    is used to read the secrets from an Azure Key Vault. It is a good choice for running
    the application in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, you need to install the following NuGet packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Azure.Extensions.AspNetCore.Configuration.Secrets`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Azure.Identity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure App Configuration is a cloud-based service that provides a centralized
    configuration store for managing application settings and feature flags. App Configuration
    complements Azure Key Vault. It aims to simplify tasks of working with complex
    application settings. You need to install the following NuGet packages to use
    the Azure App Configuration provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft.Azure.AppConfiguration.AspNetCore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will not cover details of the Azure Key Vault and Azure App Configuration
    providers in this book. For more information, please refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/azure/key-vault/general/](https://learn.microsoft.com/en-us/azure/key-vault/general/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/azure-app-configuration/](https://docs.microsoft.com/en-us/azure/azure-app-configuration/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we introduced how to read the configuration settings
    from various resources, including the `appsettings.json` file, user secrets, environment
    variables, and command-line arguments. In this section, we will discuss environments
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create a new ASP.NET Core web API project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: You can download the example project named `EnvironmentDemo` from the `/samples/chapter3/EnvironmentsDemo`
    folder in the chapter's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: We have mentioned the default ASP.NET Core web API template contains an `appsettings.json`
    file and an `appsettings.Development.json` file. When we run the application using
    `dotnet run`, the application runs in the `Development` environment. So the configuration
    settings in the `appsettings.Development.json` file override the configuration
    settings in the `appsettings.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following section to the `appsettings.Development.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following section to the `appsettings.Development.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that user secrets have higher priority than the `appsettings.Development.json`
    file. So, if you configured the local user secrets in the previous section, please
    clear the secrets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new controller named `ConfigurationController.cs` and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Run the application using `dotnet run`. Send the request to the `/Configuration/database-configuration`
    endpoint. You will find the response contains a `LocalDB` value, which means the
    `appsettings.Development.json` file overrides the `appsettings.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: So, where is the environment name `Development` set?
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the launchSettings.json file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `launchSettings.json` file in the `Properties` folder. You will find
    the `ASPNETCORE_ENVIRONMENT` environment variable is set to `Development`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `launchSettings.json` file is used to configure the local development environment.
    It is not deployable. The default `launchSettings.json` file contains three profiles:
    `http`, `https`, and `IIS Express`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `http` profile is used to run the application with the HTTP protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `https` profile is used to run the application with the HTTPS protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IIS Express` profile is used to run the application in IIS Express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `commandName` field in the `http` and `https` profiles is `Project`, which
    means the Kestrel server is launched to run the application. Similarly, the `IISExpress`
    value in the `IIS Express` profile means the application expects IIS Express to
    be the web server.
  prefs: []
  type: TYPE_NORMAL
- en: What is the Kestrel server?
  prefs: []
  type: TYPE_NORMAL
- en: Kestrel is a cross-platform web server for ASP.NET Core. Kestrel is included
    and enabled by default in ASP.NET Core project templates. ASP.NET Core can also
    be hosted in IIS (or IIS Express), but IIS is not cross-platform. So, Kestrel
    is the preferred web server for ASP.NET Core applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running `dotnet run`, the first profile with the `commandName` value,
    `Project`, is used. For the demo project, the `http` profile is used. The `ASPNETCORE_ENVIRONMENT`
    environment variable is set to `Development` in the `http` profile. So, the application
    runs in the `Development` environment. You can see the output in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We can specify the profile to use when running the application using the `--``launch-profile`
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note that this approach is only available for Kestrel profiles. You cannot use
    this argument to run the application in IIS Express.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use VS 2022 to open the project, you can choose which profile to use,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.1 – Choosing a profile to \uFEFFuse in Visual Studio 2022](img/Figure_3.1_B18971.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Choosing a profile to use in Visual Studio 2022
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's explore how to configure the application to run in the `Production`
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several ways to change the environment. Let''s create a new file
    named `appsettings.Production.json`. This configuration file will be used for
    the `Production` environment. Add the following section to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will specify the environment as `Production` to apply this configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Using the launchSettings.json file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For development purposes, we can create a new profile in the `launchSettings.json`
    file, which specifies the `ASPNETCORE_ENVIRONMENT` variable as `Production`. Add
    the following section to the `launchSettings.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to run the application in the `Production` environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see in the console that the application runs in the `Production` environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: It looks good. Let's try to access the `/Configuration/database-configuration`
    endpoint. You will see the response is from the `appsettings.Production.json`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ASPNETCORE_ENVIRONMENT environment variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also set the `ASPNETCORE_ENVIRONMENT` environment variable to `Production`
    in the current session, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, you can set the environment variable globally in your system.
    Use the following command to set the environment variable globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `Machine` argument sets the environment variable globally. You can also
    set the environment variable for the current user by using the `User` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Using the --environment argument
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another way is to set the environment with the `--``environment` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Using the launch.json file in VS Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you use VS Code to open the project, you can set the environment in the
    `launch.json` file in the `.vscode` folder. When you open an ASP.NET Core project,
    VS Code will prompt you to add required assets to debug the project. A `launch.json`
    file and a `tasks.json` file will be added to the `.vscode` folder. If you do
    not see the prompt, you can open the Command Palette and run the **.NET: Generate
    Assets for Build and** **Debug** command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `launch.json` file and you will find the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add a new configuration following the existing one. Change the `ASPNETCORE_ENVIRONMENT`
    field to `Production` and use `.NET Core Launch (Production)` as the name. Save
    the file. You can now run the application in the `Production` environment by clicking
    the green arrow in the debug panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Running the application in a specific environment in VS Code](img/Figure_3.2_B18971.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Running the application in a specific environment in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `launch.json` file is only used in VS Code `dotnet` `run` command.
  prefs: []
  type: TYPE_NORMAL
- en: Using the launchSettings.json file in Visual Studio 2022
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Visual Studio 2022 provides a **Launch Profiles** dialog to set up the environment
    variables. You have multiple ways to open the **Launch** **Profiles** dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Debug** menu | *<Your project name>* **Debug Properties**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click the arrow next to the green arrow in the debug panel and select *<Your
    project name>* **Debug Properties**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right-click the project in the **Solution Explorer** window and select **Properties**.
    In the **Debug / General** tab, click the **Open debug launch profiles** **UI**
    link.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, you can see the **Launch** **Profiles** dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – The Launch Profiles dialog in Visual Studio 2022](img/Figure_3.3_B18971.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – The Launch Profiles dialog in Visual Studio 2022
  prefs: []
  type: TYPE_NORMAL
- en: If you make changes here, you need to restart the application to apply the changes.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to set the environment. With the environment set, we can
    use different configurations for different environments.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the priorities of configuration and environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We introduced quite a few different ways to read configuration values and environment
    variables. Let us see how configuration and environment variables are prioritized.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the priorities of the configuration sources (the
    lowest number has the highest priority):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Source** | **Priority** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Command-line arguments | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Non-prefixed environment variables | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| User secrets (`Development` environment only) | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `appsettings.{Environment}.json` | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `appsettings.json` | 5 |'
  prefs: []
  type: TYPE_TB
- en: Table 3.2 – Priorities of configuration sources
  prefs: []
  type: TYPE_NORMAL
- en: If other configuration providers are registered in the `Program.cs` file, the
    later registered providers have higher priority than the earlier registered providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of environment variables such as `ASPNETCORE_ENVIRONMENT`, the following
    table shows the priorities:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Source** | **Priority** |'
  prefs: []
  type: TYPE_TB
- en: '| Command-line arguments | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `launchSettings.json` (development purposes only) | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Environment variable in the current process | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| System environment variable | 4 |'
  prefs: []
  type: TYPE_TB
- en: Table 3.3 – Priorities of environment variables
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are some other ways to configure the environment that are not
    listed in the preceding table. For example, if you deploy the ASP.NET Core application
    to Azure App Service, you can set the `ASPNETCORE_ENVIRONMENT` environment variable
    in the App Service configuration. For Linux apps and container apps, Azure App
    Service passes these settings to the container using the `--env` flag to set the
    environment variable in the container.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the environment in the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Keep running the application in the `Production` environment. Let''s try to
    access the Swagger UI page: `http://localhost:5161/swagger`. You will find it
    shows a `404 Not Found` error. Why?'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because the Swagger UI page is only enabled in the `Development` environment.
    You can see the code in the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code means that the Swagger UI page is enabled for the development
    environment only.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three environment names, `Development`, `Staging`, and `Production`, are
    predefined in the ASP.NET Core framework, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `app.Environment.IsDevelopment()` method checks the current environment.
    If the current environment is `Development`, the Swagger UI page is enabled. Otherwise,
    it is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the environment in code, use the following code when creating `WebApplicationBuilder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The environment name is stored in the `IHostEnvironment.EnvironmentName` property.
    You can define your own environment names. For example, you can define an environment
    name such as `Test`. But the framework provides built-in methods, such as `IsDevelopment()`,
    `IsStaging()`, and `IsProduction()`, to check the environment. If you define your
    own environment names, you can use the `IHostEnvironment.IsEnvironment(string
    environmentName)` method to check the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `System.Environment` class to get the environment variable in
    the code, such as `ASPNETCORE_ENVIRONMENT`. Add the following code to the `Program.cs`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application, and you can see the `ASPNETCORE_ENVIRONMENT` environment
    variable in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: What should we do for different environments?
  prefs: []
  type: TYPE_NORMAL
- en: 'For the development environment, we can enable the Swagger UI page, show detailed
    error messages, output debugging information, and so on. For the production environment,
    we should configure the application for best performance and maximum security.
    Consider the following points for the production environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Disable the Swagger UI page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable detailed error messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show a friendly error message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not output debugging information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable HTTPS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable the response compression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable monitoring and logging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we explored three important components of ASP.NET Core: routing,
    configuration, and environments. We discussed how to configure routing for an
    ASP.NET Core web API application and how to read parameters from the request.
    Additionally, we learned how to read configuration values from various sources,
    such as `appsettings.json`, environment variables, and command-line arguments.
    We also explored how to read configurations based on the environment, allowing
    us to enable different features for different environments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will learn about two more essential components of ASP.NET
    Core: logging and middleware.'
  prefs: []
  type: TYPE_NORMAL
