- en: Physically-Based Rendering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于物理的渲染
- en: 'Introduced in Unity 5, PBR is a shading model that seeks to render graphics
    in a way that acts in a similar manner to how light works in the real world. Previous
    chapters have repeatedly mentioned it without revealing too much about it. If
    you want to understand not only how PBR works, but how to make the most out of
    it, this is the chapter you should read. In this chapter, you will learn the following
    recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 5中引入的PBR是一种着色模型，它试图以与真实世界中光的行为相似的方式渲染图形。前几章反复提到了它，但没有透露太多细节。如果你想了解PBR的工作原理，以及如何充分利用它，那么你应该阅读这一章。在这一章中，你将学习以下配方：
- en: Understanding the metallic setup
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解金属设置
- en: Adding transparency to PBR
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向PBR添加透明度
- en: Creating mirrors and reflective surfaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建镜子和反射表面
- en: Baking lights in your scene
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景中烘焙灯光
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: All the lighting models encountered in [Chapter 4](part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08),
    *Understanding Lighting Models*, were very primitive descriptions of how light
    behaves. The most important aspect during their making was *efficiency*. Real-time
    shading is expensive, and techniques such as Lambertian or BlinnPhong are a compromise
    between computational cost and realism.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08)“理解光照模型”中遇到的所有光照模型，都是对光的行为的非常原始的描述。在制作过程中最重要的方面是**效率**。实时着色成本高昂，Lambertian或BlinnPhong等技术是在计算成本和真实感之间的一种折衷。
- en: Having a more powerful GPU has allowed us to write progressively more sophisticated
    lighting models and rendering engines, with the aim of simulating how light actually
    behaves. This is, in a nutshell, the philosophy behind PBR. As the name suggests,
    it tries to get as close as possible to the physics behind the processes that
    give a unique look at each material. Despite this, the term PBR has been widely
    used in marketing campaigns and is more of a synonym for **state-of-the-art rendering**
    rather than a well-defined technique.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 更强大的GPU使我们能够编写越来越复杂的照明模型和渲染引擎，目的是模拟光的真实行为。简而言之，这就是PBR背后的哲学。正如其名所示，它试图尽可能接近赋予每种材料独特外观的过程背后的物理原理。尽管如此，PBR这个术语在营销活动中被广泛使用，它更多的是**最先进渲染**的同义词，而不是一个定义明确的技巧。
- en: 'Unity implements PBR in two main ways:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Unity实现PBR的两种主要方式：
- en: The first is a completely new lighting model (called Standard). Surface Shaders
    allow developers to specify the physical properties of a material, but they do
    not impose actual physical constraints on them. PBR fills this by gap using a
    lighting model that enforces principles of physics such as **energy conservation**
    (an object cannot reflect more light than the amount it receives), **microsurface
    scattering** (rough surfaces reflect light more erratically compared to smooth
    ones), **Fresnel reflectance** (specular reflections appear at grazing angles),
    and **surface occlusion** (the darkening of corners and other geometries that
    are hard to light). All these aspects, and many others, are used to calculate
    the standard lighting model.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种是一个全新的光照模型（称为标准）。表面着色器允许开发者指定材料的物理属性，但它们不对它们施加实际的物理约束。PBR通过使用强制执行物理原则（如**能量守恒**（一个物体不能反射比它接收到的光更多的光）、**微表面散射**（粗糙表面与光滑表面相比，反射光更不规则）、**菲涅耳反射率**（在掠射角处出现镜面反射）、和**表面遮挡**（难以照亮的角落和其他几何形状的变暗）的光照模型来填补这一空白）。所有这些方面以及许多其他方面都被用来计算标准光照模型。
- en: The second aspect that makes PBR so realistic is called **Global Illumination**
    (**GI**) and is the simulation of physically-based light transport. It means that
    objects are not drawn in the scene as if they were separate entities. They all
    contribute to the final rendering as light can reflect on them before hitting
    something else. This aspect is not captured in the shaders themselves, but is
    an essential part of how the rendering engine works. Unfortunately, accurately
    simulating how light rays actually bounce over surfaces in real time is beyond
    the capabilities of modern GPUs. Unity makes some clever optimizations that allow
    us to retain visual fidelity without sacrificing performance. Some of the most
    advanced techniques (such as reflections), however, require user input.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PBR（物理基础渲染）如此逼真的第二个方面被称为**全局照明**（**GI**），它是对基于物理的光线传输的模拟。这意味着场景中的物体不是作为独立的实体被绘制出来。它们都贡献于最终的渲染，因为光线可以在击中其他物体之前反射在其上。这一方面在着色器本身中并未捕捉到，但它是渲染引擎工作方式的一个基本部分。不幸的是，在实时中准确模拟光线如何在表面上实际反弹超出了现代GPU的能力。Unity进行了一些巧妙的优化，使我们能够在不牺牲性能的情况下保持视觉保真度。然而，一些最先进的技术（如反射）则需要用户输入。
- en: All of these aspects will be covered in this chapter. It is important to remember
    that PBR and GI do not automatically guarantee that your game will be photorealistic.
    Achieving photorealism is a very challenging task and, like every art, it requires
    great expertise and exceptional skills.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖所有这些方面。重要的是要记住，PBR和GI并不自动保证你的游戏将是照片般的真实。实现照片般的真实是一个极具挑战性的任务，就像每一种艺术一样，它需要极大的专业知识和非凡的技能。
- en: Understanding the metallic setup
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解金属设置
- en: Unity provides three different types of PBR shaders; they are referred to in
    the drop-down menu of the material's Inspector tab as Standard, Standard (Roughness
    Setup), and Standard (Specular setup). The main difference is that Standard and
    Standard (Roughness Setup) expose the Metallic property, but Standard contains
    a Smoothness property while the second replaces Smoothness with Roughness**.** Standard
    (Specular setup) contains Smoothness, but replaces the Metallic property with Specular.
    Smoothness and Roughness are opposites of each other, so a `1` Smoothness means `0`
    Roughness and vice versa. You can generally get the same result no matter which
    shader you use, so it mostly comes down to personal preference.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了三种不同的PBR着色器；在材质的检查器标签页的下拉菜单中，它们被称为标准、标准（粗糙度设置）和标准（光泽度设置）。主要区别在于，标准和标准（粗糙度设置）暴露了金属属性，但标准包含一个平滑度属性，而第二个用粗糙度替换了平滑度****。**标准（光泽度设置）包含平滑度，但用光泽度替换了金属属性。平滑度和粗糙度是彼此的相反，所以`1`平滑度意味着`0`粗糙度，反之亦然。您通常可以使用任何着色器得到相同的结果，所以这主要取决于个人偏好。
- en: 'These setups represent different ways in which you can initialize PBR materials.
    One of the concepts that has driven PBR is the ability to provide meaningful,
    physically-related properties that artists and developers can tweak and play with.
    The properties of some materials are easier to represent, indicating how *metallic*
    they are. For others, it is more important to specify how they reflect lights
    directly through its **specularity**. This recipe will show you how to use the
    **metallic** **setup** effectively. It''s important to remember that the metallic
    workflow is not just for metallic materials; it is a way of defining how materials
    will look according to how metallic or non-metallic their surface is. Despite
    being presented as two different types of shaders, both Metallic and Specular
    setups are generally equally expressive. As shown in the Unity documentation at
    [http://docs.unity3d.com/Manual/StandardShaderMetallicVsSpecular.html](http://docs.unity3d.com/Manual/StandardShaderMetallicVsSpecular.html) and
    mentioned earlier, the same materials can usually be recreated with both setups
    (see the following screenshot):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置代表了你可以初始化PBR材料的不同方式。推动PBR的一个概念是提供有意义的、与物理相关的属性，艺术家和开发者可以调整和玩耍。某些材料的属性更容易表示，表明它们有多**金属**。对于其他材料，更重要的是指定它们如何通过其**光泽度**直接反射光线。这个配方将向您展示如何有效地使用**金属****设置**。重要的是要记住，金属工作流程不仅适用于金属材质；它是一种定义材料将如何根据其表面是金属还是非金属来呈现的方式。尽管作为两种不同类型的着色器呈现，但金属和光泽度设置通常具有同等的表现力。如Unity文档[http://docs.unity3d.com/Manual/StandardShaderMetallicVsSpecular.html](http://docs.unity3d.com/Manual/StandardShaderMetallicVsSpecular.html)中所示，以及前面提到的，相同的材料通常可以用这两种设置重新创建（见以下截图）：
- en: '![](img/00115.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00115.jpeg)'
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe will use the Standard Shader, so there is no need to create a new
    one. The steps to start the recipe are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将使用标准着色器，因此无需创建新的着色器。开始配方的步骤如下：
- en: Create a new material (`MetallicMat`).
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的材质（`MetallicMat`）。
- en: From its Inspector, make sure that Standard is selected from its Shader drop-down
    menu.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其检查器中，确保从Shader下拉菜单中选择了Standard。
- en: 'You will also need a textured 3D model. Our basic character we''ve been using
    previously will work perfectly. Drag and drop it into the scene. Afterward, drag
    and drop the `MetallicMat` material onto each of the parts of the character. Also,
    assign the texture for the material to the Albedo property:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要一个纹理化的3D模型。我们之前使用的基本角色将完美适用。将其拖放到场景中。之后，将`MetallicMat`材质拖放到角色的各个部分上。同时，将材质的纹理分配给Albedo属性：
- en: '![](img/00116.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00116.jpeg)'
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'There are two main textures that need to be configured in the Standard Shader:
    Albedo and Metallic. To use the metallic workflow effectively, we need to initialize
    these maps correctly:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准着色器中需要配置两种主要纹理：Albedo和Metallic。为了有效地使用金属工作流程，我们需要正确初始化这些图：
- en: The Albedo map should be initialized with the unlit texture of the 3D model.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Albedo图应该使用3D模型的未光照纹理初始化。
- en: To create the Metallic map, start by duplicating the file for your Albedo map.
    You can do this by selecting the map from the Project tab and pressing *Ctrl + D*.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建Metallic图，首先复制你的Albedo图文件。你可以通过从项目选项卡中选择图并按*Ctrl + D*来实现。
- en: Use white (`#ffffff`) to color the regions of the map that correspond to materials
    that are made of pure metal. Use black (`#000000`) for all the other colors. Shades
    of grey should be used for dusty, weathered, or worn-out metal surfaces, rust,
    scratched paint, and so on. As a matter of fact, Unity uses only the red channel
    to store the metallic value; the green and blue ones are ignored.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用白色（`#ffffff`）为对应纯金属材质的区域着色。对于所有其他颜色使用黑色（`#000000`）。灰色阴影用于灰尘、风化或磨损的金属表面、锈迹、划痕油漆等。事实上，Unity只使用红色通道来存储金属值；绿色和蓝色通道被忽略。
- en: 'Use the alpha channel of the image to provide information about the Smoothness
    of the material:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用图像的alpha通道来提供关于材料**平滑度**的信息：
- en: '![](img/00117.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00117.jpeg)'
- en: An example of a Metallic map opened in Photoshop
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Photoshop中打开的Metallic图示例
- en: 'For our simple character, the belt and the little ends of the hoodie are the
    only parts we need to be metallic. I''ve also made the opacity around 55% for
    the main character, with the belt having a higher opacity of 80%:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的简单角色，腰带和连帽衫的小末端是我们需要金属化的唯一部分。我还将主要角色的不透明度设置为55%，腰带的不透明度更高，为80%：
- en: 'Assign the Metallic map to the material. The Metallic slider will disappear
    as these two properties are now controlled by the map. You may use the Smoothness
    slider to provide a modifier on the map you''ve provided:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Metallic图分配给材质。当这两个属性现在由图控制时，Metallic滑块将消失。你可以使用Smoothness滑块来提供对提供的图的修饰：
- en: '![](img/00118.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00118.jpeg)'
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Metals are known for the conducting of electricity; light is in the form of
    electromagnetic waves, meaning that almost all metals behave in a similar way
    compared to non-conductors (often referred as **insulators**). Conductors tend
    to reflect most photons (70-100%), resulting in high reflectance. The remaining
    light is absorbed, rather than diffused, suggesting that conductors have a very
    dark diffuse component. Insulators, conversely, have a low reflectance (4%); the
    rest of the light is scattered on the surface, contributing to their diffused
    looks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 金属因其导电性而闻名；光以电磁波的形式存在，这意味着几乎所有金属与非导体（通常称为**绝缘体**）相比都有相似的行为。导体倾向于反射大多数光子（70-100%），导致高反射率。剩余的光被吸收，而不是扩散，这表明导体具有非常暗的扩散分量。相反，绝缘体的反射率很低（4%）；其余的光在表面散射，有助于它们的扩散外观。
- en: In the Standard Shader, purely metallic materials have dark diffuse components,
    and the color of their specular reflections is determined by the Albedo map. Conversely,
    the diffuse component of purely non-metallic materials is determined by the Albedo
    map; the color of their specular highlights is determined by the color of the
    incoming light. Following these principles allows the metallic workflow to combine
    the Albedo and specular into the Albedo map, enforcing physically-accurate behaviors.
    This also allows for saving more space, resulting in a significant speed increase
    at the expenses of reduced control over the look of your materials.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准着色器中，纯金属材质具有暗淡的漫反射组件，其镜面反射的颜色由Albedo图决定。相反，纯非金属材质的漫反射组件由Albedo图决定；其镜面高光的颜色由入射光的颜色决定。遵循这些原则允许金属工作流程将Albedo和镜面反射合并到Albedo图中，强制执行物理准确的特性。这也允许节省更多空间，从而在牺牲对材质外观控制的情况下显著提高速度。
- en: See also
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'For more information about the metallic setup, you can refer to these links:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 关于金属设置更多信息，您可以参考以下链接：
- en: '**Calibration chart**: How to calibrate a metallic material ([http://blogs.unity3d.com/wp-content/uploads/2014/11/UnityMetallicChart.png](http://blogs.unity3d.com/wp-content/uploads/2014/11/UnityMetallicChart.png))'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**校准图**：如何校准金属材质([http://blogs.unity3d.com/wp-content/uploads/2014/11/UnityMetallicChart.png](http://blogs.unity3d.com/wp-content/uploads/2014/11/UnityMetallicChart.png))'
- en: '**Material chart**: How to initialize the Standard Shader parameters for common
    materials ([http://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html](http://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html))'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**材质图**：如何初始化标准着色器参数以用于常见材质([http://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html](http://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html))'
- en: '**Quixel MEGASCANS**: A vast library of materials, including textures and PBR
    parameters ([https://megascans.se/](https://megascans.se/))'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Quixel MEGASCANS**：一个包含纹理和PBR参数的庞大材料库([https://megascans.se/](https://megascans.se/))'
- en: '**PBR Texture Conversion**: How traditional shaders can be converted to PBR
    shaders ([http://www.marmoset.co/toolbag/learn/pbr-conversion](http://www.marmoset.co/toolbag/learn/pbr-conversion))'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PBR纹理转换**：如何将传统着色器转换为PBR着色器([http://www.marmoset.co/toolbag/learn/pbr-conversion](http://www.marmoset.co/toolbag/learn/pbr-conversion))'
- en: '**Substance Designer**: A node-based software to work with PBR ([https://www.allegorithmic.com/products/substance-designer](https://www.allegorithmic.com/products/substance-designer))'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Substance Designer**：一个基于节点的软件，用于处理PBR([https://www.allegorithmic.com/products/substance-designer](https://www.allegorithmic.com/products/substance-designer))'
- en: '**The Theory of** **Physically-Based Rendering**: A complete guide about PBR
    ([https://www.allegorithmic.com/pbr-guide](https://www.allegorithmic.com/pbr-guide))'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于物理渲染的理论**：关于PBR的完整指南([https://www.allegorithmic.com/pbr-guide](https://www.allegorithmic.com/pbr-guide))'
- en: Adding transparency to PBR
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为PBR添加透明度
- en: Transparency is such an important aspect in games that the Standard Shader supports
    three different ways of doing it. This recipe is useful if you need to have realistic
    materials with transparent or semi-transparent properties. Glasses, bottles, windows,
    and crystals are good candidates for PBR transparent shaders. This is because
    you can still have all the realism introduced by PBR with the addition of a transparent
    or translucent effect. If you need transparency for something different, such
    as UI elements or pixel art, there are more efficient alternatives that are explored
    in the *Creating a transparent material* recipe in [Chapter 3](part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08),
    *Surface Shaders and Texture Mapping*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 透明度在游戏中是一个非常重要的方面，标准着色器支持三种不同的实现方式。如果您需要具有透明或半透明特性的真实材料，这个配方非常有用。眼镜、瓶子、窗户和晶体是PBR透明着色器的良好候选者。这是因为您仍然可以通过添加透明或半透明效果来获得PBR引入的所有真实感。如果您需要为UI元素或像素艺术等不同事物实现透明度，[第3章](part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08)中“创建透明材料”配方中探讨了更有效的替代方案，*表面着色器和纹理映射*。
- en: In order to have a transparent standard material, changing the alpha channel
    of its Albedo color property is not enough. Unless you properly set its Rendering
    Mode, your material will not appear transparent.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拥有一个透明的标准材质，仅更改其Albedo颜色属性的alpha通道是不够的。除非您正确设置其渲染模式，否则您的材质将不会显示为透明。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe will use the Standard Shader, so there is no need to create a new
    one:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方将使用标准着色器，因此无需创建新的着色器：
- en: Create a new material (`TransparencyMat`).
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的材质(`TransparencyMat`)。
- en: Make sure that the Shader property is set to either Standard or Standard (Specular
    setup) from the material's Inspector tab.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保从材质的检查器标签页将Shader属性设置为标准或标准（镜面设置）。
- en: 'Assign the newly created material to the 3D object that you want to be transparent:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的材质分配给您想要设置为透明的3D对象：
- en: '![](img/00119.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00119.jpeg)'
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: The Standard Shader provides three different types of transparencies. Despite
    being very similar, they have subtle differences and fit in different contexts.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 标准着色器提供了三种不同类型的透明度。尽管它们非常相似，但它们有细微的差别，适用于不同的环境。
- en: Semi-transparent materials
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 半透明材料
- en: 'Some materials such as clear plastics, crystal, and glass are semi-transparent.
    This means that they both require all the realistic effects of PBR (such as specular
    highlights and Fresnel refraction and reflection), but allow the geometry behind an
    object with the material attached to be seen. If this is what you need, perform
    the following steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一些材料，如透明塑料、晶体和玻璃是半透明的。这意味着它们都需要PBR的所有真实效果（如镜面高光和菲涅耳折射和反射），但允许看到附着在材质上的物体背后的几何体。如果您需要这样做，请执行以下步骤：
- en: From the material's Inspector tab, set Rendering Mode to Transparent.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从材质的检查器标签页，将渲染模式设置为透明。
- en: 'The amount of transparency is determined by the alpha channel of the Albedo
    color or the Albedo map (if any). If you click on the box to the right of the
    Albedo section, you''ll bring up a Color menu. Adjusting the A channel will make
    the item more visible or less visible:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 透明度的大小由Albedo颜色的alpha通道或Albedo贴图（如果有）决定。如果您点击Albedo部分右侧的框，会弹出一个颜色菜单。调整A通道会使项目更可见或更不可见：
- en: '![](img/00120.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00120.jpeg)'
- en: 'Setting the A channel to `44` provides the following effect:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将A通道设置为`44`会产生以下效果：
- en: '![](img/00121.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00121.jpeg)'
- en: 'The following screenshot shows the Unity calibration scene with four different
    highly polished plastic spheres. From left to right, their transparency is increasing.
    The last sphere is fully transparent, but retains all the added effects of PBR:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了Unity校准场景中的四个不同的高光塑料球体。从左到右，它们的透明度逐渐增加。最后一个球体是完全透明的，但保留了所有添加的PBR效果：
- en: '![](img/00122.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00122.jpeg)'
- en: The Unity Calibration Scene can be downloaded for free from the Asset Store
    at [https://www.assetstore.unity3d.com/en/#!/content/25422](https://www.assetstore.unity3d.com/en/#!/content/25422).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Unity校准场景可以从Asset Store免费下载，网址为[https://www.assetstore.unity3d.com/en/#!/content/25422](https://www.assetstore.unity3d.com/en/#!/content/25422)。
- en: The Transparent rendering mode is perfect for windows, bottles, gems, and headsets.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 透明渲染模式非常适合窗户、瓶子、宝石和耳机。
- en: You should notice that many transparent materials don't usually project shadows.
    On top of this, the Metallic and Smoothness properties of a material can interfere
    with the transparency effect. A mirror-like surface can have the alpha set to
    zero, but if it reflects all the incoming light, it won't appear transparent.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意到，许多透明材质通常不会投射阴影。除此之外，材质的金属和光滑度属性可能会干扰透明效果。具有类似镜面的表面可以将alpha设置为零，但如果它反射所有入射光，它就不会看起来透明。
- en: Fading objects
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消失的物体
- en: 'Sometimes, you want an object to fully disappear with a fading effect. In this
    case, specular reflections and Fresnel refraction and reflection should disappear
    as well. When a fading object is fully transparent, it should also be invisible.
    To do this, perform the following steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您希望物体通过渐变效果完全消失。在这种情况下，镜面反射和菲涅耳折射和反射也应该消失。当一个渐变物体完全透明时，它也应该不可见。为此，请执行以下步骤：
- en: From the material's Inspector tab, set Rendering Mode to Fade.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从材质的检查器标签页，将渲染模式设置为渐变。
- en: 'As before, use the alpha channel of the Albedo color or map to determine the
    final transparency:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，使用Albedo颜色或贴图的alpha通道来确定最终的透明度：
- en: '![](img/00123.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00123.jpeg)'
- en: 'The following screenshot shows four fading spheres. It is clear from the screenshot
    that the PBR effects fade with the sphere as well. As you can see in the following
    image, the last one on the right is almost invisible:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了四个渐变球体。从截图可以看出，PBR效果随着球体的渐变而消失。正如您在以下图像中看到的那样，最右边的一个几乎看不见：
- en: '![](img/00124.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00124.jpeg)'
- en: This rendering mode works best for non-realistic objects, such as holograms,
    laser rays, faux lights, ghosts, and particle effects.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种渲染模式最适合非真实物体，如全息图、激光束、假灯、鬼魂和粒子效果。
- en: Solid geometries with holes
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带孔的实体几何体
- en: 'Most of the materials encountered in a game are solid, meaning that they don''t
    allow light to pass through them. At the same time, many objects have a very complex
    (yet flat) geometry. Modeling leaves and grass with 3D objects is often overkilled.
    A more efficient approach is to use a quad (rectangle) with a leaf texture. While
    the leaf itself is solid, the rest of the texture should be fully transparent.
    If this is what you want, then perform the following steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中遇到的许多材质都是实心的，这意味着它们不允许光线穿透。同时，许多物体具有非常复杂（但平坦）的几何形状。用3D对象建模树叶和草地通常是过度设计。一个更有效的方法是使用带有树叶纹理的四边形（矩形）。虽然树叶本身是实心的，但纹理的其余部分应该是完全透明的。如果你想要这样，请执行以下步骤：
- en: From the material's Inspector tab, set Rendering Mode to Cutout.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从材质的“检查器”选项卡中，将渲染模式设置为“剪裁”。
- en: Use the Alpha Cutoff slider to determine the cutoff threshold. All the pixels
    in the Albedo map with an alpha value equal to or less than Alpha Cutoff will
    be hidden.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Alpha截止滑块确定截止阈值。所有Albedo图中Alpha值等于或小于Alpha截止的像素将被隐藏。
- en: 'The following image, taken from the *Unity Official Tutorials* on PBR ([https://www.youtube.com/watch?v=fD_ho_ofY6A](https://www.youtube.com/watch?v=fD_ho_ofY6A)),
    shows you how the effect of the Cutout rendering mode can be used to create a
    hole in the geometry:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像来自Unity官方教程中的PBR（[https://www.youtube.com/watch?v=fD_ho_ofY6A](https://www.youtube.com/watch?v=fD_ho_ofY6A)），展示了如何使用剪裁渲染模式的效果在几何形状中创建一个洞：
- en: '![](img/00125.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00125.jpeg)'
- en: It's worth noticing that Cutout does not allow the back of the geometry to be
    seen. In the previous example, you could not see the inner volume of the sphere.
    If you require such an effect, you need to create your own shader and make sure
    that the back geometry is not culled.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，剪裁不允许看到几何形状的背面。在先前的例子中，你无法看到球体的内部体积。如果你需要这种效果，你需要创建自己的着色器并确保背面几何形状不被裁剪。
- en: See also
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: As mentioned previously, some of the examples in this recipe have been created
    using the Unity Shader Calibration Scene, which is freely available in the Asset
    Store at [https://www.assetstore.unity3d.com/en/#!/content/25422](https://www.assetstore.unity3d.com/en/#!/content/25422).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，本食谱中的一些示例是使用Unity Shader Calibration Scene创建的，该场景在Asset Store中免费提供，链接为[https://www.assetstore.unity3d.com/en/#!/content/25422](https://www.assetstore.unity3d.com/en/#!/content/25422).
- en: More information about Albedo and Transparency can be found at
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于反照率和透明度的信息可以在以下找到
- en: '[http://docs.unity3d.com/Manual/StandardShaderMaterialParameterAlbedoColor.html](http://docs.unity3d.com/Manual/StandardShaderMaterialParameterAlbedoColor.html).'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Unity3D官方文档](http://docs.unity3d.com/Manual/StandardShaderMaterialParameterAlbedoColor.html).'
- en: Creating mirrors and reflective surfaces
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建镜子和反射表面
- en: Specular materials reflect lights when objects are viewed from certain angles.
    Unfortunately, even the Fresnel reflection, which is one of the most accurate
    models, does not correctly reflect lights from nearby objects. The lighting models
    examined in the previous chapters took into account only light sources, but ignored
    light that is reflected from other surfaces. With what you've learned about shaders
    so far, making a mirror is simply not possible.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当从特定角度观察物体时，镜面材质会反射光线。不幸的是，即使是 Fresnel 反射，这是最准确模型之一，也无法正确地反射来自附近物体的光线。前几章中检查的光照模型只考虑了光源，但忽略了来自其他表面的反射光线。根据你到目前为止对着色器的了解，制作镜子是根本不可能的。
- en: 'Global illumination makes this possible by providing PBR shaders with information
    about their surroundings. This allows objects to have not just specular highlights,
    but also real reflections, which depend on the other objects around them. Real-time
    reflections are very costly and require manual setting up and tweaking in order
    to work. When done properly, they can be used to create mirror-like surfaces,
    as seen in the following diagram:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供关于其周围环境的信息，全局照明使得使用PBR着色器成为可能。这使得物体不仅具有镜面高光，还有真实的反射，这些反射取决于周围的物体。实时反射非常昂贵，并且需要手动设置和调整才能工作。当正确设置时，它们可以用来创建类似镜面的表面，如下面的图中所示：
- en: '![](img/00126.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/00126.jpeg)'
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe will not feature any new shader. Quite the opposite; most of the
    work is done directly in the editor. Perform the following steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱不会介绍任何新的着色器。相反，大部分工作都是在编辑器中直接完成的。请执行以下步骤：
- en: Create a new scene.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景。
- en: Create a quad (GameObject | 3D Object | Quad), which will serve as a mirror.
    I've rotated it to -65 in the Y axis to make it easy to see.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个四边形（GameObject | 3D Object | Quad），它将作为镜子。我已经将它绕Y轴旋转了-65度，以便更容易看到。
- en: Create a new material (`MirrorMat`) and attach it to the mirror.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的材质（`MirrorMat`）并将其附加到镜子上。
- en: Place the quad in a scene with other objects.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将四边形放置在包含其他物体的场景中。
- en: 'Create a new reflection probe from GameObject | Light | Reflection Probe and
    place it in front of the quad:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GameObject | Light | Reflection Probe创建一个新的反射探针并将其放置在四边形前方：
- en: '![](img/00127.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00127.jpeg)'
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'If the preceding steps have been followed correctly, you should have a quad
    in the middle of your scene, close to a reflection probe. In order to make it
    in a mirror, some changes need to be made:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的步骤都正确执行，你应该在场景中间有一个四边形，靠近反射探针。为了使其成为镜子，需要进行一些更改：
- en: Change the shader of the material to Standard and its Rendering Mode to Opaque.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将材质的着色器更改为Standard，并将渲染模式更改为不透明。
- en: Change its Metallic and Smoothness properties to one. You should see the material
    reflecting the sky more clearly.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其金属和光滑度属性更改为一个。你应该看到材质更清晰地反射天空。
- en: Select the reflection probe and change its Size and Probe Origin until it is
    in front of the quad and it encloses all the objects that you want to reflect.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择反射探针并调整其大小和探针原点，直到它位于四边形前方并包围所有你想要反射的物体。
- en: To make the item more clear under the Cubemap capture settings, change the Resolution
    to `2048`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在Cubemap捕获设置下使项目更清晰，将分辨率更改为`2048`。
- en: Finally, change its Type to Realtime and the Refresh Mode to Every frame. Also,
    make sure that Culling Mask is set to Everything.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将其类型更改为实时并刷新模式更改为每帧。同时，确保清除遮罩设置为一切。
- en: 'Your reflection probe should be configured, as shown in the following screenshot:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的反射探针应该配置如下所示：
- en: '![](img/00128.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00128.jpeg)'
- en: 'Using these settings, you should see something similar to this:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这些设置，你应该看到类似以下内容：
- en: '![](img/00129.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00129.jpeg)'
- en: You may notice that the bunny seems larger in the reflection rather than what's
    beside it. If your probe is used for a real mirror, you should check the Box Projection
    flag (in this example, setting the box size to `1`, `1`, `1` does a pretty good
    job of looking like a mirror). If it is used for other reflective surfaces, such
    as shiny pieces of metal or glass tables, you can uncheck it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在反射中兔子看起来比它旁边的物体要大。如果你的探头用于真实镜子，你应该检查“盒投影”标志（在这个例子中，将盒子大小设置为`1`，`1`，`1`可以很好地模拟镜子的效果）。如果它用于其他反射表面，例如闪亮的金属片或玻璃桌面，你可以取消选中它。
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When a shader wants information about its surroundings, it is usually provided
    in a structure called **cube** **maps**. They have been briefly mentioned in [Chapter
    2](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08), *Creating Your First
    Shader*, as one of the shader property types, among `Color`, `2D`, `Float`, and
    `Vector`. Loosely speaking, cube maps are the 3D equivalent of 2D textures; they
    represent a 360-degree view of the world, as seen from a center point.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当着色器需要关于其周围环境的信息时，它通常在一个称为**立方体贴图**的结构中提供。它们在[第2章](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08)，“创建你的第一个着色器”中简要提到，作为着色器属性类型之一，包括`Color`，`2D`，`Float`和`Vector`。简单来说，立方体贴图是2D纹理的3D等价物；它们代表从中心点看到的360度世界视图。
- en: 'Unity previews cube maps with a spherical projection, as seen in the following
    diagram:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Unity使用球形投影预览立方体贴图，如下面的图所示：
- en: '![](img/00130.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00130.jpeg)'
- en: When cube maps are attached with a camera, they are referred to as **skyboxes**,
    as they are used to provide a way to reflect the sky. They can be used to reflect
    geometries that are not in the actual scene, such as nebulae, clouds, and stars.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当立方体贴图与相机一起使用时，它们被称为**天空盒**，因为它们用于提供反射天空的方法。它们可以用来反射实际场景中不存在的几何形状，例如星云、云彩和星星。
- en: 'The reason why they are called cube maps is because of the way they are created:
    a cube map is made up of six different textures, each one attached to the face
    of a cube. You can create a cube map manually or delegate it to a **reflection
    probe**. You can imagine a reflection probe as a collection of six cameras, creating
    a 360-degree mapping of the surrounding area. This also gives you an idea as to
    why probes are so expensive. By creating one in our scene, we allow Unity to know
    which objects are around the mirror. If you need more reflective surfaces, you
    can add multiple probes. You need no further action for the reflection probes
    to work. The Standard Shaders will use them automatically.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它们被称为立方体贴图是因为它们的创建方式：立方体贴图由六个不同的纹理组成，每个纹理都附着在立方体的一个面上。你可以手动创建立方体贴图或将任务委托给**反射探针**。你可以想象反射探针是一组六个相机，创建周围区域的360度映射。这也解释了为什么探针如此昂贵。通过在我们的场景中创建一个探针，我们让Unity知道哪些对象在镜子周围。如果你需要更多的反射表面，你可以添加多个探针。对于反射探针的工作，你无需采取任何进一步的操作。标准着色器将自动使用它们。
- en: You should notice that when they are set to Realtime, they render their cube
    map at the beginning of every frame. There is a trick to make this faster; if
    you know that part of the geometry that you want to reflect does not move, you
    can bake the reflection. This means that Unity can calculate the reflection before
    starting the game, allowing more precise (and computationally expensive) calculations.
    In order to do this, your reflection probe must be set to Baked and will work
    only for objects that are flagged as Static. Static objects cannot move or change,
    which makes them perfect for terrain, buildings, and props. Every time a static
    object is moved, Unity will regenerate the cube maps for its baked reflection
    probes. This might take a few minutes to several hours.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到，当它们设置为实时时，它们会在每一帧的开始渲染立方体贴图。有一个技巧可以使这个过程更快；如果你知道你想要反射的几何形状部分不会移动，你可以烘焙反射。这意味着Unity可以在游戏开始前计算反射，从而允许更精确（且计算成本更高）的计算。为了做到这一点，你的反射探针必须设置为烘焙，并且仅适用于标记为静态的对象。静态对象不能移动或改变，这使得它们非常适合地形、建筑和道具。每次移动静态对象时，Unity都会为其烘焙的反射探针重新生成立方体贴图。这可能会花费几分钟到几个小时。
- en: You can mix Realtime and Baked probes to increase the realism of your game.
    Baked probes will provide very high-quality reflections, environmental reflections,
    while the real-time ones can be used to move objects such as cars or mirrors.
    The *Baking lights in your scene* section will explain in detail how light baking
    works.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将实时和烘焙探针混合使用，以增加你游戏的现实感。烘焙探针将提供非常高质量的反射和环境反射，而实时探针可以用来移动汽车或镜子等对象。在“场景中烘焙灯光”部分将详细解释光照烘焙是如何工作的。
- en: See also
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'If you are interested in learning more about reflection probes, you should
    check these links:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于反射探针的信息，你应该查看以下链接：
- en: 'Unity manual about the Reflection Probe: [http://docs.unity3d.com/Manual/class-ReflectionProbe.html](http://docs.unity3d.com/Manual/class-ReflectionProbe.html)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity关于反射探针的手册：[http://docs.unity3d.com/Manual/class-ReflectionProbe.html](http://docs.unity3d.com/Manual/class-ReflectionProbe.html)
- en: Box projection and other advanced Reflection Probe settings: [https://docs.unity3d.com/Manual/AdvancedRefProbe.html](https://docs.unity3d.com/Manual/AdvancedRefProbe.html)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箱体投影和其他高级反射探针设置：[https://docs.unity3d.com/Manual/AdvancedRefProbe.html](https://docs.unity3d.com/Manual/AdvancedRefProbe.html)
- en: Baking lights in your scene
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景中烘焙灯光
- en: Rendering lighting is a very expensive process. Even with state-of-the-art GPUs,
    accurately calculating the **light transport** (which is how light bounces between
    surfaces) can take hours. In order to make this process feasible for games, real-time
    rendering is essential. Modern engines compromise between realism and efficiency;
    most of the computation is done beforehand in a process called **light baking**.
    This recipe will explain how light baking works and how you can get the most out
    of it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染光照是一个非常昂贵的进程。即使是最先进的GPU，准确计算**光传输**（即光如何在表面之间反射）也可能需要数小时。为了使这一过程对游戏可行，实时渲染是必不可少的。现代引擎在真实感和效率之间做出妥协；大部分计算都在一个称为**光照烘焙**的过程中提前完成。本指南将解释光照烘焙是如何工作的以及如何最大限度地利用它。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Light baking requires you to have a scene ready. It should have geometries and,
    obviously, lights. For this recipe, we will rely on Unity's standard features
    so there is no need to create additional shaders or materials. We will be reusing
    the map that we used previously in [Chapter 1](part0026.html#OPEK0-e8c76c858d514bc3b1668fda96f8fa08), *Post
    Processing Stack*. For better control, you might want to access the Lighting window.
    If you don't see it, select Window | Lighting | Settings from the menu and dock
    it where it is more convenient for you.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 灯光烘焙需要你有一个准备好的场景。它应该有几何体，显然，还有灯光。对于这个配方，我们将依赖 Unity 的标准功能，因此不需要创建额外的着色器或材质。我们将重新使用之前在[第
    1 章](part0026.html#OPEK0-e8c76c858d514bc3b1668fda96f8fa08)，*后处理堆栈*中使用的地图。为了更好的控制，你可能想要访问照明窗口。如果你看不到它，请从菜单中选择
    Window | Lighting | Settings 并将其停靠在更方便的位置。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Light baking requires some manual configuration. There are three essential,
    yet independent, steps that you need to take.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 灯光烘焙需要一些手动配置。你需要采取三个基本且独立的步骤。
- en: Configuring the static geometry
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置静态几何体
- en: 'These steps must be followed for the configuration:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤必须遵循配置：
- en: Identify all the objects in your scene that do not change position, size, and
    material. Possible candidates are buildings, walls, terrain, props, trees, and
    others. In our case, it will be all of the objects aside from the `FPSController`
    and its children.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别场景中所有位置、大小和材质不发生变化的物体。可能的候选物体包括建筑、墙壁、地形、道具、树木等。在我们的例子中，除了`FPSController`及其子对象之外的所有物体。
- en: 'Select these objects and check the Static box from the Inspector tab, as shown
    in the following screenshot. If any of the selected objects have children, Unity
    will ask if you want them to be considered static as well. If they meet the requirements
    (fixed position, size, and material), select Yes, change children in the pop-up
    box:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择这些物体，并在检查器标签中勾选静态框，如图所示。如果选中的任何物体有子对象，Unity 将询问你是否希望它们也被视为静态。如果它们满足要求（固定位置、大小和材质），请选择是，并在弹出框中更改子对象：
- en: '![](img/00131.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00131.jpeg)'
- en: If a light qualifies as a static object but illuminates non-static geometry,
    make sure that its Baking property is set to Mixed. If it will affect only static
    objects, set it to Baked.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个灯光符合静态物体的资格但照亮了非静态几何体，请确保其 Baking 属性设置为 Mixed。如果它只会影响静态物体，请将其设置为 Baked。
- en: Configuring the light probes
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置光探头
- en: 'There are objects in your game that will move, such as the main character,
    enemies, and the other **non-playable characters** (**NPCs**). If they enter a
    static region that is illuminated, you might want to surround it with light probes.
    To do this, follow the given steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的游戏中，有一些物体将会移动，例如主要角色、敌人以及其他**非玩家角色**（NPC）。如果它们进入一个被照亮的静态区域，你可能想要用光探头来包围它。为此，请按照以下步骤操作：
- en: From the menu, navigate to GameObject | Light | Light Probe Group. A new object
    called Light Probe Group will appear in Hierarchy.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中，导航到 GameObject | Light | Light Probe Group。在 Hierarchy 中将出现一个名为 Light Probe
    Group 的新对象。
- en: 'Once selected, eight interconnected spheres will appear. Click and move them
    around the scene so that they enclose the static region in which your characters
    can enter. The following screenshot shows an example of how light probes can be
    used to enclose the volume of a static office space:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦选择，将出现八个相互连接的球体。点击并移动它们，使它们围绕场景，将静态区域包围起来，其中角色可以进入。以下截图显示了如何使用光探头来包围静态办公空间的体积示例：
- en: '![](img/00132.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00132.jpeg)'
- en: 'For our example, it would just be the center area the player is able to enter:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，它将是玩家能够进入的中心区域：
- en: '![](img/00133.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00133.jpeg)'
- en: Select the moving objects that will enter the light probe region.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择将进入光探头区域的移动物体。
- en: 'From their Inspector, expand their **renderer component** (usually Mesh Renderer)
    and make sure that Light Probes is not set to Off checked (see the following screenshot):'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在它们的检查器中，展开它们的**渲染器组件**（通常是网格渲染器），并确保光探头未设置为关闭（请参见以下截图）：
- en: '![](img/00134.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00134.jpeg)'
- en: Deciding where and when to use light probes is a critical problem; more information
    about this can be found in the *How it works... *section for this recipe.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 决定在哪里以及何时使用光探头是一个关键问题；关于此的信息可以在本食谱的 *How it works...* 部分找到。
- en: Baking the lights
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 烘焙灯光
- en: 'To bake the lights, follow the given steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要烘焙灯光，请按照以下步骤操作：
- en: 'First, select the lights you''d like to bake. Confirm from the Inspector tab
    that the Mode is set to Baked in the Light component:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，选择你想要烘焙的灯光。从检查器选项卡确认在“灯光”组件中“模式”设置为“烘焙”：
- en: '![](img/00135.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00135.jpeg)'
- en: To finally bake the lights, open the Lighting window by going to Window | Lighting
    | Settings. Once there, select the Global Maps tab.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要最终烘焙灯光，请通过转到“窗口”|“光照”|“设置”打开光照窗口。一旦进入，选择“全局贴图”选项卡。
- en: If the Auto Generate checkbox is enabled, Unity will automatically execute the
    baking process in the background. If not, click on Generate Lighting.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果启用了“自动生成”复选框，Unity 将在后台自动执行烘焙过程。如果没有，请点击“生成光照”。
- en: Light baking can take several hours even for a relatively small scene. If you
    are constantly moving static objects or lights, Unity will restart the process
    from scratch, causing a severe slowdown in the editor. You can uncheck the Auto checkbox
    from the Lighting | Lightmaps | Settings tab to prevent this so that you can decide
    when to start the process manually.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是相对较小的场景，轻度烘焙也可能需要几个小时。如果你一直在移动静态物体或灯光，Unity 将从头开始重新启动这个过程，导致编辑器严重减速。你可以从“光照”|“光照贴图”|“设置”选项卡中取消选中“自动”复选框来防止这种情况，这样你就可以决定何时手动启动过程。
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The most complicated part of rendering is the light transport. During this phase,
    the GPU calculates how the rays of light bounce between objects. If an object
    and its lights don't move, this calculation can be done only once as it will never
    change during the game. Flagging an object as Static is how to tell Unity that
    such an optimization can be made.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染中最复杂的部分是光传输。在这个阶段，GPU 计算光线如何在物体之间反弹。如果一个物体及其灯光不移动，这个计算只需进行一次，因为游戏过程中它不会改变。将物体标记为静态就是告诉
    Unity 可以进行这种优化的方式。
- en: 'Loosely speaking, light baking refers to the process of calculating the global
    illumination of a static object and saving it in what is called a **lightmap**.
    Once baking is completed, lightmaps can be seen in the Global Maps tab of the
    Lighting window:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，轻度烘焙是指计算静态对象的全局光照并将其保存到所谓的**光照贴图**中的过程。一旦烘焙完成，光照贴图可以在光照窗口的全局贴图选项卡中看到：
- en: '![](img/00136.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00136.jpeg)'
- en: 'Light baking comes at a great expense: memory. Every static surface is, in
    fact, retextured so that it already includes its lighting condition. Let''s imagine
    that you have a forest of trees, all sharing the same texture. Once they are made
    static, each tree will have its very own texture. Light baking not only increases
    the size of your game, but can take a lot of texture memory if used indiscriminately.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 轻度烘焙代价高昂：内存。实际上，每个静态表面都会重新纹理化，以便它已经包含了其光照条件。让我们想象一下，你有一片森林，所有的树都使用相同的纹理。一旦它们被设置为静态，每棵树都将拥有自己的纹理。轻度烘焙不仅会增加游戏的大小，如果无差别地使用，还会消耗大量的纹理内存。
- en: The second aspect introduced in this recipe is **light probing**. Light baking
    produces extremely high-quality results for static geometries, but does not work
    on moving objects. If your character is entering a static region, it can look
    somehow *detached* from the environment. Its shading will not match the surroundings,
    resulting in an aesthetically unpleasant result. Other objects, such as **skinned
    mesh renderers**, will not receive global illumination even if made static. Baking
    lights in real-time is not possible, although light probes offer an effective
    alternative. Every light probe samples the global illumination at a specific point
    in space. A light probe group can sample several points in space, allowing the
    interpolation of global illumination within a specific volume. This allows us
    to cast a better light on moving objects, even despite the fact that global illumination
    has been calculated only for a few points. It is important to remember that light
    probes need to enclose a volume in order to work. It is best to place light probes
    in regions where there is a sudden change in light conditions. Similar to lightmaps,
    probes consume memory and should be placed wisely; remember that they exist only
    for non-static geometry. Since there are no visible objects in the demoscene,
    this was done purely for demonstration purposes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方中引入的第二个方面是**光线探针**。光线烘焙对于静态几何体可以产生非常高质量的结果，但无法应用于移动物体。如果你的角色进入了一个静态区域，它可能会看起来有些*脱离*环境。它的着色不会与周围环境匹配，导致视觉效果不愉快。其他物体，例如**皮肤网格渲染器**，即使设置为静态也不会接收到全局照明。实时烘焙光线是不可能的，尽管光线探针提供了一个有效的替代方案。每个光线探针在空间中的特定点采样全局照明。一个光线探针组可以在空间中的几个点进行采样，允许在特定体积内进行全局照明的插值。这使我们能够在移动物体上投射更好的光线，即使全局照明只计算了几个点。重要的是要记住，光线探针需要包围一个体积才能工作。最好将光线探针放置在光线条件突然变化的区域。与光照贴图类似，探针会消耗内存，应该明智地放置；记住，它们仅存在于非静态几何体中。由于演示场景中没有可见的物体，这纯粹是为了演示目的而进行的。
- en: Even while using light probes, there are a few aspects that Unity's global illumination
    cannot capture. Non-static objects, for instance, cannot reflect light on other
    objects.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用光线探针，Unity的全局照明仍然无法捕捉到一些方面。例如，非静态物体无法在其他物体上反射光线。
- en: See also
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: You can read more about light probes at [http://docs.unity3d.com/Manual/LightProbes.html](http://docs.unity3d.com/Manual/LightProbes.html).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://docs.unity3d.com/Manual/LightProbes.html](http://docs.unity3d.com/Manual/LightProbes.html)了解更多关于光线探针的信息。
