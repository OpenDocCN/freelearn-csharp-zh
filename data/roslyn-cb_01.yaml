- en: Writing Diagnostic Analyzers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写诊断分析器
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Creating, debugging, and executing an analyzer project in Visual Studio
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中创建、调试和执行分析器项目
- en: Creating a symbol analyzer to report issues about symbol declarations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个符号分析器以报告符号声明的问题
- en: Creating a syntax node analyzer to report issues about language syntax
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个语法节点分析器以报告语言语法的问题
- en: Creating a syntax tree analyzer to analyze source file and report syntax issues
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个语法树分析器以分析源文件并报告语法问题
- en: Creating a method body analyzer to analyze whole method and report issues
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个方法体分析器以分析整个方法并报告问题
- en: Creating a compilation analyzer to analyze whole compilation and report issues
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个分析整个编译并报告问题的编译分析器
- en: Writing unit tests for an analyzer project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为分析器项目编写单元测试
- en: Publishing the NuGet package and VSIX for an analyzer project
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布分析器项目的 NuGet 包和 VSIX
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: Diagnostic analyzers are extensions to the Roslyn C# compiler and Visual Studio
    IDE to analyze user code and report diagnostics. Users will see these diagnostics
    in the error list after building the project from Visual Studio, and even when
    building the project on the command line. They will also see the diagnostics live
    while editing the source code in the Visual Studio IDE. Analyzers can report diagnostics
    to enforce specific code styles, improve code quality and maintenance, recommend
    design guidelines, or even report very domain-specific issues which cannot be
    covered by the core compiler. This chapter enables C# developers to write, debug,
    test, and publish analyzers that perform different kinds of analyses.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 诊断分析器是 Roslyn C# 编译器和 Visual Studio IDE 的扩展，用于分析用户代码并报告诊断。用户在从 Visual Studio
    构建项目后，甚至在命令行构建项目时都会看到这些诊断。当在 Visual Studio IDE 中编辑源代码时，他们也会实时看到诊断。分析器可以报告诊断以强制执行特定的代码样式、提高代码质量和维护性、推荐设计指南，甚至报告无法由核心编译器覆盖的非常特定的问题。本章使
    C# 开发者能够编写、调试、测试和发布执行不同类型分析的分析器。
- en: If you are not familiar with the Roslyn's architecture and API layers, it is
    recommended that, before reading this chapter further, you read the Preface of
    this book to gain a basic understanding of Roslyn APIs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉 Roslyn 的架构和 API 层，建议在继续阅读本章之前，先阅读本书的序言，以获得对 Roslyn API 的基本了解。
- en: Diagnostic analyzers are built on top of the Roslyn's **CodeAnalysis**/**Compiler
    layer** API. Analyzers can analyze specific code units, such as a symbol, syntax
    node, code block, compilation, and so on, by registering one or more analyzer
    actions. The compiler layer makes a callback into the analyzer whenever it compiles
    a code unit of interest. The analyzer can report diagnostics on code units, which
    are added to the list of the compiler diagnostics and reported back to the end
    user.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 诊断分析器建立在 Roslyn 的 **CodeAnalysis**/**编译器层** API 之上。分析器可以通过注册一个或多个分析器操作来分析特定的代码单元，例如符号、语法节点、代码块、编译等。编译器层在编译感兴趣的代码单元时会对分析器进行回调。分析器可以在代码单元上报告诊断，这些诊断被添加到编译器诊断列表中，并报告给最终用户。
- en: 'Analyzers can be broadly categorized into the following two buckets based on
    the kind of analysis performed:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 根据执行的分析类型，分析器可以大致分为以下两个类别：
- en: '**Stateless analyzers**: Analyzers that report diagnostics about a specific
    code unit by registering one or more analyzer actions that:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态分析器**：通过注册一个或多个分析器操作来报告特定代码单元诊断的分析器：'
- en: Do not require maintaining any state across analyzer actions.
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要在分析器操作之间维护任何状态。
- en: Independent of the order of execution of individual analyzer actions.
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与单个分析器操作的执行顺序无关。
- en: For example, an analyzer that looks at every single class declaration independently
    and reports issues about the declaration is a stateless analyzer. We will show
    you how to write a stateless symbol, syntax node, and syntax tree analyzer, later
    in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个独立检查每个类声明并报告声明问题的分析器是一个无状态分析器。我们将在本章后面向您展示如何编写无状态符号、语法节点和语法树分析器。
- en: '**Stateful analyzers**: Analyzers that report diagnostics about a specific
    code unit, but in the context of an enclosing code unit, such as a code block
    or a compilation. These are more complicated analyzers that require powerful and
    wider analysis, hence, need careful design to achieve efficient analyzer execution
    without memory leaks. These analyzers require at least one of the following kinds
    of state manipulation for analysis:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有状态的分析器**：报告特定代码单元诊断信息，但在包含代码单元的上下文中，例如代码块或编译。这些分析器更复杂，需要强大和广泛的分析，因此需要仔细设计以实现高效的分析器执行而不会出现内存泄漏。这些分析器至少需要以下一种状态操作进行分析：'
- en: Access to immutable state objects for the enclosing code unit, such as a compilation
    or the code block. For example, access to certain well-known types defined in
    a compilation.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问包含代码单元的不可变状态对象，例如编译或代码块。例如，访问在编译中定义的某些已知类型。
- en: Perform analysis over the enclosing code unit, with mutable state defined and
    initialized in a start action for the enclosing code unit, intermediate nested
    actions that access and/or update this state, and an end action to report diagnostic
    on the individual code units.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在包含代码单元上执行分析，其中在包含代码单元的启动操作中定义和初始化可变状态，中间嵌套操作访问和/或更新此状态，以及一个结束操作来报告单个代码单元的诊断。
- en: For example, an analyzer that looks at all class declarations in a compilation,
    gathering and updating a common state when analyzing each class declaration, and
    then finally, after it has analyzed all declarations, reports issues about those
    declarations is a stateful analyzer. We will show you how to write a stateful
    method body and compilation analyzer in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个分析器检查编译中的所有类声明，在分析每个类声明时收集和更新公共状态，然后最终，在分析所有声明后，报告有关这些声明的诊断信息，这是一个有状态的分析器。在本章中，我们将向您展示如何编写有状态的方法体和编译分析器。
- en: By default, analyzers can analyze and report diagnostics on source files in
    a project. However, we can also write an analyzer that analyzes additional files,
    that is, non-source text files included in the project, and also report diagnostics
    in additional files. Non-source files could be files, such as Web.config files
    in a web project, cshtml files in a Razor project, XAML files in a WPF project,
    and so on. You can read more about how to write and consume additional file analyzers
    at [https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md.](https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，分析器可以分析并报告项目中源文件的诊断信息。然而，我们也可以编写一个分析器来分析额外的文件，即项目中包含的非源文本文件，并在额外文件中报告诊断信息。非源文件可以是文件，例如
    Web.config 文件在 Web 项目中，cshtml 文件在 Razor 项目中，XAML 文件在 WPF 项目中等等。您可以在 [https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md](https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md)
    中了解更多关于如何编写和消费额外文件分析器的信息。
- en: Creating, debugging, and executing an analyzer project in Visual Studio
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中创建、调试和执行分析器项目
- en: We will show you how to install the .NET Compiler Platform SDK, create an analyzer
    project from a template, and then debug and execute the default analyzer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向您展示如何安装 .NET 编译器平台 SDK，从模板创建分析器项目，然后调试和执行默认分析器。
- en: The analyzer project that you create in this recipe can be used in the subsequent
    recipes in this chapter to add new analyzers and write unit tests.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您在此配方中创建的分析器项目可以用于本章后续配方中添加新的分析器和编写单元测试。
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have Visual Studio 2017 installed on your machine to execute
    the recipes in this chapter. You can install a free community version of Visual
    Studio 2017 from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的机器上安装 Visual Studio 2017 才能执行本章中的配方。您可以从 [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)
    安装免费的 Visual Studio 2017 社区版。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Start Visual Studio and click on File | New | Project.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 并点击 File | New | Project。
- en: 'Search for `Analyzer` templates in the textbox at the top right corner of the
    New Project dialog, select Download the .NET Compiler Platform SDK, and click
    on OK:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新建项目对话框右上角的文本框中搜索 `Analyzer` 模板，选择下载 .NET 编译器平台 SDK，然后点击 OK：
- en: '![](img/b8e145ad-e7b0-4e57-b64f-49b179c96b71.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8e145ad-e7b0-4e57-b64f-49b179c96b71.png)'
- en: The new project will have an `index.html` file opened by default. Click on Download
    .NET Compiler Platform SDK Templates >> button to install the analyzer SDK templates.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新项目将默认打开 `index.html` 文件。点击下载 .NET 编译器平台 SDK 模板 >> 按钮，以安装分析器 SDK 模板。
- en: '![](img/b7dad759-4dcc-49b0-b7ed-e4efe64b0d2d.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7dad759-4dcc-49b0-b7ed-e4efe64b0d2d.png)'
- en: In the subsequent File Download dialog, click on Open.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在随后的文件下载对话框中，点击打开。
- en: '![](img/b1755f2f-8bbc-4e5d-823c-f1334ba66654.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1755f2f-8bbc-4e5d-823c-f1334ba66654.png)'
- en: 'Click Install on the next VSIX Installer dialog and End Tasks on the subsequent
    prompt to install the SDK:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个 VSIX 安装程序对话框中点击安装，在随后的提示中点击结束任务以安装 SDK：
- en: '![](img/2d961daa-1c5a-432d-ac44-073cae33659d.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d961daa-1c5a-432d-ac44-073cae33659d.png)'
- en: Start a new instance of Visual Studio and click on File | New | Project... to
    get the New Project dialog.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的 Visual Studio 实例，然后点击文件 | 新建 | 项目... 以获取新项目对话框。
- en: Change the project target framework combo box to .NET Framework 4.6 (or above).
    Under Visual C# | Extensibility, choose Analyzer with Code Fix (NuGet + VSIX),
    name your project `CSharpAnalyzers`, and click on OK.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目目标框架组合框更改为 .NET Framework 4.6（或更高版本）。在 Visual C# | 扩展性下，选择具有代码修复功能的分析器（NuGet
    + VSIX），将项目命名为 `CSharpAnalyzers`，然后点击确定。
- en: '***![](img/c236cecc-9323-4f98-8b76-5f4c3efe80cd.png)***'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '***![](img/c236cecc-9323-4f98-8b76-5f4c3efe80cd.png)***'
- en: 'You should now have an analyzers solution with 3 projects: `CSharpAnalyzers
    (Portable)`, `CSharpAnalyzers.Test` , and `CSharpAnalyzer.Vsix`**:**'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在应该有一个包含 3 个项目的分析器解决方案：`CSharpAnalyzers (Portable)`、`CSharpAnalyzers.Test`
    和 `CSharpAnalyzer.Vsix`**：
- en: '![](img/80081d9c-64db-4850-9fa1-a91a00ef78d6.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80081d9c-64db-4850-9fa1-a91a00ef78d6.png)'
- en: 'Open source file `DiagnosticAnalyzer.cs` in `CSharpAnalyzers` project and set
    breakpoints (press *F9*) at the start of the `Initialize` and `AnalyzeSymbol`
    methods, as shown here:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CSharpAnalyzers` 项目中打开源文件 `DiagnosticAnalyzer.cs` 并在 `Initialize` 和 `AnalyzeSymbol`
    方法的开始处设置断点（按 *F9*），如图所示：
- en: '![](img/9803a238-34f8-4fe6-b161-5b3729c02efb.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9803a238-34f8-4fe6-b161-5b3729c02efb.png)'
- en: Set `CSharpAnalyzers.Vsix` as the start-up project and click on *F5* to build
    the analyzer and start debugging a new instance of Visual Studio with the analyzer
    enabled.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `CSharpAnalyzers.Vsix` 设置为启动项目，然后点击 *F5* 构建分析器并启动一个新的 Visual Studio 实例，其中启用了分析器并开始调试。
- en: In the new Visual Studio instance, create a new C# class library project, say
    `ClassLibrary`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 Visual Studio 实例中，创建一个新的 C# 类库项目，例如 `ClassLibrary`。
- en: Verify that we hit both the preceding breakpoints in our analyzer code in the
    first VS instance. You can step through the analyzer code using *F10* or click
    on *F5* to continue debugging.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证我们在第一个 VS 实例的分析器代码中触发了前面的断点。您可以使用 *F10* 单步执行分析器代码或点击 *F5* 继续调试。
- en: 'We should now see the analyzer diagnostic in the error list and a squiggle
    in the editor:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在应该在错误列表中看到分析器诊断，并在编辑器中看到一个波浪线：
- en: '![](img/ada9a9c5-b73c-4514-ba72-bdb5615cc51a.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ada9a9c5-b73c-4514-ba72-bdb5615cc51a.png)'
- en: Edit the name of the class from `Class1` to `CLASS1`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类的名称从 `Class1` 编辑为 `CLASS1`。
- en: We should hit the breakpoint in the `AnalyzeSymbol` method again. Continue debugging
    with *F5* and the diagnostic and squiggle should go away immediately, demonstrating
    the powerful live and extensible analysis.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该在 `AnalyzeSymbol` 方法中再次遇到断点。使用 *F5* 继续调试，诊断和波浪线应立即消失，展示了强大的实时和可扩展的分析功能。
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '.NET Compiler Platform SDK is a wrapper project that redirects us to fetch
    the project templates for analyzer + CodeFix projects for C# and Visual Basic.
    Creating a new project from these templates creates a fully functional analyzer
    project which has a default analyzer, unit tests, and a VSIX project:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 编译器平台 SDK 是一个包装项目，它将我们重定向到获取 C# 和 Visual Basic 的分析器 + CodeFix 项目模板。从这些模板创建新项目将创建一个功能齐全的分析器项目，该项目具有默认分析器、单元测试和
    VSIX 项目：
- en: '`CSharpAnalyzers`: Core analyzer project that contains the default analyzer
    implementation that reports a diagnostic for all type names that contain any lowercase
    letters.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSharpAnalyzers`: 包含默认分析器实现的核心分析器项目，该实现报告所有包含任何小写字母的类型名称的诊断。'
- en: '`CSharpAnalyzers.Test`: Analyzer unit test project that contains a couple of
    analyzer and code fixer unit tests and test helpers.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSharpAnalyzers.Test`: 包含一些分析器和代码修复单元测试以及测试辅助工具的分析器单元测试项目。'
- en: '`CSharpAnalyzers.Vsix`: The VSIX project that packages the analyzer into a
    VSIX. This is the start-up project in the solution.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSharpAnalyzers.Vsix`: 将分析器打包成 VSIX 的 VSIX 项目。这是解决方案中的启动项目。'
- en: Clicking on *F5* to start debugging the solution builds and deploys the analyzer
    to the Visual Studio extension hive and then starts a new Visual Studio instance
    from this hive. Our analyzer is enabled by default for all C# projects created
    in this VS instance.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 *F5* 以启动调试解决方案，构建并部署分析器到 Visual Studio 扩展存储库，然后从这个存储库启动一个新的 Visual Studio
    实例。在我们的分析器中，默认情况下为在此 VS 实例中创建的所有 C# 项目启用。
- en: 'Let''s expand a bit more on the diagnostic analyzer source code defined in
    `DiagnosticAnalyzers.cs`. It contains a type named `CSharpAnalyzersAnalyzer`,
    which derives from `DiagnosticAnalyzer`. `DiagnosticAnalyzer` is an abstract type
    with the following two abstract members:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨一下在 `DiagnosticAnalyzers.cs` 中定义的诊断分析器源代码。它包含一个名为 `CSharpAnalyzersAnalyzer`
    的类型，该类型继承自 `DiagnosticAnalyzer`。`DiagnosticAnalyzer` 是一个抽象类型，具有以下两个抽象成员：
- en: '`SupportedDiagnostics` property: Analyzer must define one or more supported
    diagnostic descriptors. Descriptors describe the metadata for the diagnostics
    that an analyzer can report in analyzer actions. It contains fields such as the
    diagnostic ID, message format, title, description, hyperlink to documentation
    for the diagnostic, and so on. Can be used to create and report diagnostics:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SupportedDiagnostics` 属性：分析器必须定义一个或多个受支持的诊断描述符。描述符描述了分析器在分析器动作中可以报告的诊断的元数据。它包含诊断
    ID、消息格式、标题、描述、诊断文档的超链接等字段。可用于创建和报告诊断：'
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`Initialize` method: Diagnostic analyzers must implement the `Initialize` method
    to register analyzer action callbacks for a specific code entity kind of interest,
    which is named type symbols for the default analyzer. The initialize method is
    invoked once for the analyzer lifetime to allow analyzer initialization and registration
    of actions.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Initialize` 方法：诊断分析器必须实现 `Initialize` 方法以注册对特定代码实体类型的分析器动作回调，对于默认分析器，这个类型被称为类型符号。初始化方法在分析器生命周期内只被调用一次，以允许分析器初始化和注册动作。'
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Invoke `AnalysisContext.EnableConcurrentExecution()` in the `Initialize` method
    if your analyzer can handle action callbacks from multiple threads simultaneously
    -- this enables the analyzer driver to execute the analyzer more efficiently on
    a machine with multiple cores. Additionally, also invoke `AnalysisContext.ConfigureGeneratedCodeAnalysis()`
    in the`Initialize` method to configure whether or not the analyzer wants to analyze
    and/or report diagnostics in generated code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的分析器可以同时处理来自多个线程的动作回调，请在 `Initialize` 方法中调用 `AnalysisContext.EnableConcurrentExecution()`，这使分析器驱动程序能够在具有多个核心的机器上更有效地执行分析器。此外，还应在
    `Initialize` 方法中调用 `AnalysisContext.ConfigureGeneratedCodeAnalysis()` 以配置分析器是否想要分析和/或报告生成代码中的诊断。
- en: Analyzer actions are invoked for every code entity of interest in a user s source
    code. Additionally, as the user edits code and a new compilation is created, action
    callbacks are continuously invoked for entities defined in the new compilation
    during code editing. The error list makes sure that it only reports the diagnostics
    from the active compilation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器动作会在用户源代码中感兴趣的每个代码实体上被调用。此外，当用户编辑代码并创建新的编译时，在代码编辑期间，对于新编译中定义的实体，动作回调会持续调用。错误列表确保它只报告活动编译中的诊断。
- en: Use [http://source.roslyn.io](http://source.roslyn.io) for rich semantic search
    and navigation of Roslyn source code, which is open sourced at [https://github.com/dotnet/roslyn.git](https://github.com/dotnet/roslyn.git).
    For example, you can look at the definition and references for `DiagnosticAnalyzer`
    using the query URL [http://source.roslyn.io/#q=DiagnosticAnalyzer](http://source.roslyn.io/#q=DiagnosticAnalyzer).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [http://source.roslyn.io](http://source.roslyn.io) 进行丰富的语义搜索和导航 Roslyn 源代码，该代码在
    [https://github.com/dotnet/roslyn.git](https://github.com/dotnet/roslyn.git) 上开源。例如，你可以使用查询
    URL [http://source.roslyn.io/#q=DiagnosticAnalyzer](http://source.roslyn.io/#q=DiagnosticAnalyzer)
    查看对 `DiagnosticAnalyzer` 的定义和引用。
- en: Creating a symbol analyzer to report issues about symbol declarations
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建符号分析器以报告关于符号声明的相关问题
- en: A symbol analyzer registers action callbacks to analyze one or more kinds of
    symbol declarations, such as types, methods, fields, properties, events, and so
    on, reports semantic issues about declarations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 符号分析器注册动作回调以分析一种或多种符号声明，例如类型、方法、字段、属性、事件等，并报告关于声明的语义问题。
- en: 'In this section, we will create a symbol analyzer that extends the compiler
    diagnostic *CS0542* (member names cannot be the same as their enclosing type)
    to report a diagnostic if member names are the same as any of the outer parent
    type. For example, the analyzer will report a diagnostic for the innermost type
    `NestedClass` here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个符号分析器，该分析器扩展了编译器诊断 *CS0542*（成员名称不能与其封装类型相同）以报告如果成员名称与任何外部父类型相同，则报告诊断。例如，分析器将在此处报告内部最深层类型
    `NestedClass` 的诊断：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have created and opened an analyzer project, say `CSharpAnalyzers`
    in Visual Studio 2017\. Refer to the first recipe in this chapter to create this
    project.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在 Visual Studio 2017 中创建并打开一个分析器项目，例如 `CSharpAnalyzers`。请参阅本章的第一个配方以创建此项目。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In Solution Explorer, double-click on `Resources.resx` file in `CSharpAnalyzers`
    project to open the resource file in the resource editor.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中，双击 `CSharpAnalyzers` 项目中的 `Resources.resx` 文件以在资源编辑器中打开资源文件。
- en: 'Replace the existing resource strings for `AnalyzerDescription`, `AnalyzerMessageFormat`
    and `AnalyzerTitle` with new strings:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `AnalyzerDescription`、`AnalyzerMessageFormat` 和 `AnalyzerTitle` 的现有资源字符串替换为新字符串：
- en: '![](img/fb520471-e9c9-4c9f-b339-2b600de5d40c.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb520471-e9c9-4c9f-b339-2b600de5d40c.png)'
- en: 'Replace the `Initialize` method implementation with the following:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Initialize` 方法实现替换为以下内容：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Click on *Ctrl* + *F5* to start a new Visual Studio instance with the analyzer
    enabled.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 *Ctrl* + *F5* 以启动一个新的带有分析器启用的 Visual Studio 实例。
- en: 'In the new Visual Studio instance, create a new C# class library with the following
    code:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 Visual Studio 实例中，使用以下代码创建一个新的 C# 类库：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Verify the compiler reported diagnostic *CS0542* in the error list: `''NestedClass'':
    member names cannot be the same as their enclosing type`.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '验证编译器在错误列表中报告了诊断 *CS0542*：`''NestedClass'': member names cannot be the same
    as their enclosing type`。'
- en: 'Change the class library code to following:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类库代码更改为以下内容：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Verify that *CS0542* isn t reported anymore, but the error list has our analyzer
    diagnostic:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 *CS0542* 诊断不再报告，但错误列表中有我们的分析器诊断：
- en: '![](img/1d7b4dc1-787d-4528-ad6d-cf93ea8d292d.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d7b4dc1-787d-4528-ad6d-cf93ea8d292d.png)'
- en: 'Replace the innermost type declaration for `NestedClass` with a field: `public
    int NestedClass`, and verify the same analyzer diagnostic is reported. You should
    get the same diagnostic for other member kinds such as method, property, and events
    with the same name.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `NestedClass` 的内部最深层类型声明替换为字段：`public int NestedClass`，并验证是否报告了相同的分析器诊断。您应该为具有相同名称的其他成员类型（如方法、属性和事件）获得相同的诊断。
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Symbol analyzers register one or more symbol action callbacks to analyze symbol
    kinds of interest. Note that, unlike the default implementation that registered
    a delegate method named `AnalyzeSymbol`, we registered a lambda callback.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 符号分析器注册一个或多个符号动作回调以分析感兴趣的符号类型。请注意，与注册名为 `AnalyzeSymbol` 的委托方法的默认实现不同，我们注册了一个
    lambda 回调。
- en: 'We specified interest in analyzing all the top-level symbol kinds that can
    have an enclosing type, namely types, methods, fields, properties, and events
    in the `RegisterSymbolAction` invocation:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `RegisterSymbolAction` 调用中指定了对所有可以具有封装类型的顶级符号类型的兴趣，即类型、方法、字段、属性和事件：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The analyzer driver ensures that the registered lambda is invoked for all symbols
    of the registered interest kinds in the compilation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器驱动程序确保为注册的兴趣类型的所有符号调用注册的 lambda。
- en: Analysis skips the immediate enclosing type, as C# compiler already reports
    error *CS0542,* if a member has the same name as its enclosing type.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 分析跳过了直接封装类型，因为 C# 编译器已经报告了错误 *CS0542*，如果成员具有与其封装类型相同的名称。
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Core analysis works by looping over the outer types and comparing the name of
    the symbol in a symbol analysis context with the relevant outer types, until it
    finds a match, in which case, it reports a diagnostic; if the outer type has no
    containing type, it doesn t report a diagnostic.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 核心分析通过遍历外部类型，并在符号分析上下文中比较符号的名称与相关外部类型，直到找到匹配项，在这种情况下报告诊断；如果外部类型没有包含类型，则不报告诊断。
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It is recommended that symbol actions only analyze and report diagnostics about
    declarations, not the executable code within it. If you need to analyze executable
    code within a symbol, you should try to register other action kinds discussed
    later in this chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 建议符号操作仅分析并报告关于声明的诊断，而不是其中可执行代码。如果您需要分析符号内的可执行代码，应尝试注册本章后面讨论的其他动作类型。
- en: There s more...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '**Trivia**: The preceding implementation of the symbol analyzer does not have
    optimal performance. For example, if you have *n* levels of type nesting, and
    *m* fields in the inner innermost nested type, the analysis we implemented will
    be *O(m*n)* algorithmic complexity. Can you implement an alternate implementation
    where the analysis can be implemented with a much superior *O(m + n)* complexity?'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**趣闻**：符号分析器的先前实现没有最佳性能。例如，如果您有 *n* 级别的类型嵌套，以及最内层嵌套类型中的 *m* 个字段，我们实现的分析将是 *O(m*n)*
    算法复杂度。您能否实现一个替代实现，其中分析可以以更优越的 *O(m + n)* 复杂度实现？'
- en: See also
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Our current analyzer implementation is completely stateless because it doesn
    t require analysis that is dependent upon more than one symbol at a time. We analyze
    each symbol individually and report diagnostics for it. However, if you need to
    do more complex analysis that requires collecting state from multiple symbols
    and then doing a compilation-wide analysis, you should write a stateful compilation
    analyzer with symbol and compilation actions. This is covered later in this chapter
    in the recipe *Creating a compilation analyzer to analyze a whole compilation
    and report issues.*
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的分析器实现是完全无状态的，因为它不需要依赖于多个符号的分析。我们单独分析每个符号并为其报告诊断。然而，如果您需要进行更复杂的分析，这需要从多个符号中收集状态然后进行全局编译分析，您应该编写一个具有符号和编译动作的有状态编译分析器。这将在本章后面的食谱
    *创建一个分析整个编译并报告问题的编译分析器* 中介绍。
- en: Creating a syntax node analyzer to report issues about language syntax
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个语法节点分析器以报告关于语言语法的相关问题
- en: A syntax node analyzer registers action callbacks to analyze one or more kinds
    of syntax nodes, such as operators, identifiers, expressions, declarations, and
    so on, and reports semantic issues about syntax. These analyzers generally need
    to fetch semantic information about different syntax nodes being analyzed and
    use the compiler semantic model APIs to get this information.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 语法节点分析器注册动作回调以分析一种或多种语法节点，例如运算符、标识符、表达式、声明等，并报告关于语法的语义问题。这些分析器通常需要获取正在分析的不同语法节点的语义信息，并使用编译器语义模型
    API 获取这些信息。
- en: In this section, we will create a syntax analyzer that analyzes `VariableDeclarationSyntax`
    nodes for local declarations and reports a diagnostic recommending use of the
    explicit type instead of an implicitly typed declaration, that is, variables defined
    with the keyword `var`, such as `var i = new X();`*.* Analyzer will not report
    diagnostics if there is a compiler syntax error (implicitly typed declarations
    cannot define more than one variable), or the right side of the assignment has
    an error type or special System type such as int, char, string, and so on. For
    example, the analyzer will not flag locals `local1`, `local2`, and `local3` here,
    but will flag `local4`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个语法分析器，该分析器分析 `VariableDeclarationSyntax` 节点以进行局部声明，并报告一个诊断建议使用显式类型而不是隐式类型声明，即使用关键字
    `var` 定义的变量，例如 `var i = new X();`*.* 如果存在编译器语法错误（隐式类型声明不能定义多个变量），或者赋值右侧有错误类型或特殊
    System 类型（如 int、char、string 等），分析器将不会报告诊断。例如，分析器不会标记本例中的局部变量 `local1`、`local2`
    和 `local3`，但会标记 `local4`。
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have created and opened an analyzer project, say `CSharpAnalyzers`
    in Visual Studio 2017\. Refer to the first recipe in this chapter to create this
    project.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建并打开一个分析器项目，例如在 Visual Studio 2017 中创建名为 `CSharpAnalyzers` 的项目。请参考本章的第一个食谱来创建此项目。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: In Solution Explorer, double-click on `Resources.resx` file in `CSharpAnalyzers`
    project to open the resource file in the resource editor.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中，双击 `CSharpAnalyzers` 项目中的 `Resources.resx` 文件以在资源编辑器中打开资源文件。
- en: 'Replace the existing resource strings for `AnalyzerDescription`, `AnalyzerMessageFormat`
    and `AnalyzerTitle` with new strings:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `AnalyzerDescription`、`AnalyzerMessageFormat` 和 `AnalyzerTitle` 的现有资源字符串替换为新字符串：
- en: '![](img/41de0b15-eb6f-442a-bb06-508abe40df8f.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/41de0b15-eb6f-442a-bb06-508abe40df8f.png)'
- en: 'Replace the `Initialize` method implementation with the following:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Initialize` 方法实现替换为以下内容：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Click on *Ctrl* + *F5* to start a new Visual Studio instance with the analyzer
    enabled.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 *Ctrl* + *F5* 以启动一个新的带有分析器的 Visual Studio 实例。
- en: 'In the new Visual Studio instance, create a new C# class library with the following
    code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 Visual Studio 实例中，创建一个新的 C# 类库，代码如下：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Verify the analyzer diagnostic is not reported in the error list for explicitly
    typed variables.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证分析器诊断未在错误列表中报告显式类型变量。
- en: 'Now, add the following implicitly typed variable declarations to the method:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下隐式类型变量声明添加到方法中：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Verify the analyzer diagnostic is not reported in the error list for implicitly
    typed variables with error type or special type.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证分析器诊断不会在错误列表中报告具有错误类型或特殊类型的隐式类型变量。
- en: 'Add the violating implicitly typed variable declaration to the method:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将违反的隐式类型变量声明添加到方法中：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Verify the analyzer diagnostic is reported for this implicitly typed variable:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证分析器诊断是否报告了此隐式类型变量：
- en: '![](img/546651f4-032c-4497-ae9a-10e69500c726.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/546651f4-032c-4497-ae9a-10e69500c726.png)'
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Syntax node analyzers register one or more syntax node action callbacks to analyse
    syntax kinds of interest. We specified interest in analyzing `VariableDeclaration`
    syntax kind in the `RegisterSyntaxNodeAction` invocation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 语法节点分析器注册一个或多个语法节点动作回调以分析感兴趣的语法类型。我们在`RegisterSyntaxNodeAction`调用中指定了对分析`VariableDeclaration`语法类型的兴趣。
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Analysis works by operating on the syntax node and semantic model exposed off
    the syntax node analysis context in the callback. We first do syntactic checks
    to verify that we are operating on a valid implicitly typed declaration:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 分析通过在回调中操作语法节点和从语法节点分析上下文公开的语义模型来工作。我们首先进行语法检查，以验证我们正在操作一个有效的隐式类型声明：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then perform semantic checks using the semantic model APIs to get semantic
    type information about the type declaration syntax node and verify it is not an
    error type or primitive system type:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用语义模型API执行语义检查，以获取类型声明语法节点的语义类型信息，并验证它不是错误类型或原始系统类型：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can perform many powerful semantic operations on the syntax node exposed
    from the `SyntaxNodeAnalysisContext` using the public semantic model APIs, for
    reference see [https://github.com/dotnet/roslyn/blob/master/src/Compilers/Core/Portable/Compilation/SemanticModel.cs](https://github.com/dotnet/roslyn/blob/master/src/Compilers/Core/Portable/Compilation/SemanticModel.cs).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用公共语义模型API在从`SyntaxNodeAnalysisContext`公开的语法节点上执行许多强大的语义操作，有关参考，请参阅[https://github.com/dotnet/roslyn/blob/master/src/Compilers/Core/Portable/Compilation/SemanticModel.cs](https://github.com/dotnet/roslyn/blob/master/src/Compilers/Core/Portable/Compilation/SemanticModel.cs)。
- en: If both the syntactic and semantics check succeed, then we report a diagnostic
    about recommending explicit type instead of var.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语法和语义检查都成功，则我们报告关于推荐显式类型而不是`var`的诊断。
- en: Creating a syntax tree analyzer to analyze the source file and report syntax
    issues
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个语法树分析器来分析源文件并报告语法问题
- en: A syntax tree analyzer registers action callbacks to analyze the syntax/grammar
    for the source file and reports pure syntactic issues. For example, a missing
    semicolon at the end of a statement is a syntactic error, while assigning an incompatible
    type to a symbol with no possible type conversion is a semantic error.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 语法树分析器注册动作回调以分析源文件的语法/语法，并报告纯语法问题。例如，语句末尾缺少分号是一个语法错误，而将不兼容的类型分配给没有可能类型转换的符号是一个语义错误。
- en: 'In this section, we will write a syntax tree analyzer that analyzes all the
    statements in a source file and generates a syntax warning for any statement that
    is not enclosed in a block, that is curly braces `{` and `}`. For example, the
    following code will generate a warning for both the `if` statement and the `System.Console.WriteLine`
    invocation statement, but the `while` statement is not flagged:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个语法树分析器，该分析器分析源文件中的所有语句，并为任何未在块中（即花括号`{}`）封装的语句生成语法警告。例如，以下代码将为`if`语句和`System.Console.WriteLine`调用语句生成警告，但`while`语句不会被标记：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have created and opened an analyzer project, say `CSharpAnalyzers`
    in Visual Studio 2017\. Refer to the first recipe in this chapter to create this
    project.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在Visual Studio 2017中创建并打开一个分析器项目，例如`CSharpAnalyzers`。请参阅本章的第一个配方以创建此项目。
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: In Solution Explorer, double-click on the `Resources.resx` file in `CSharpAnalyzers`
    project to open the resource file in the resource editor.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中，双击`CSharpAnalyzers`项目中的`Resources.resx`文件以在资源编辑器中打开资源文件。
- en: Replace the existing resource strings for `AnalyzerDescription`, `AnalyzerMessageFormat`
    and `AnalyzerTitle` with new strings.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AnalyzerDescription`、`AnalyzerMessageFormat`和`AnalyzerTitle`的现有资源字符串替换为新字符串。
- en: '![](img/50ca5379-4258-4a4b-9d62-a066f1470a0b.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/50ca5379-4258-4a4b-9d62-a066f1470a0b.png)'
- en: 'Replace the `Initialize` method implementation with the following:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Initialize`方法实现替换为以下内容：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Click on *Ctrl* + *F5* to start a new Visual Studio instance with the analyzer
    enabled.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击*Ctrl* + *F5*以启动一个新的带有分析器启用的Visual Studio实例。
- en: 'In the new Visual Studio instance, create a new C# class library with the following
    code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的Visual Studio实例中，创建一个新的C#类库，代码如下：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Verify the analyzer diagnostic is neither reported for the method block for
    `Method` nor the `while` statement, but is reported for the `if` statement and
    `System.Console.WriteLine` invocation statement:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证分析器诊断既未报告`Method`方法块，也未报告`while`语句，而是报告了`if`语句和`System.Console.WriteLine`调用语句：
- en: '![](img/19a037fe-9bdb-4204-9dcf-5b2476d657c2.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/19a037fe-9bdb-4204-9dcf-5b2476d657c2.png)'
- en: 'Now, add curly braces around the `System.Console.WriteLine` invocation statement
    and verify the only single warning is now reported for the `if` statement:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`System.Console.WriteLine`调用语句周围添加花括号，并验证现在只为`if`语句报告了一个警告：
- en: '![](img/d48ccb86-abd2-49be-b373-b48cd26e2574.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d48ccb86-abd2-49be-b373-b48cd26e2574.png)'
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Syntax tree analyzers register callbacks to analyze syntax of all source files
    in the compilation. Our analysis works by getting the roots of the syntax tree
    and then operating on all the descendant syntax nodes of the roots which are of
    type `StatementSyntax`. First, we note that a block statement is itself an aggregate
    statement, and by definition has curly braces, so we skip past these.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 语法树分析器注册回调以分析编译中所有源文件的语法。我们的分析是通过获取语法树的根并操作根的所有类型为`StatementSyntax`的子语法节点来工作的。首先，我们注意到一个块语句本身是一个聚合语句，并且根据定义具有花括号，所以我们跳过这些。
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We then perform syntactic checks for the parent of statement syntax. If the
    parent of the statement is also a statement, but not a block with curly braces,
    then we report a diagnostic on the first syntax token of the statement recommending
    usage of curly braces.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后对语句语法的父级进行语法检查。如果语句的父级也是一个语句，但不是一个带有花括号的块，那么我们在语句的第一个语法标记上报告一个诊断，建议使用花括号。
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`SyntaxTreeAnalysisContext` provided to syntax tree actions does not expose
    the semantic model for the source file, hence no semantic analysis can be performed
    within a syntax tree action.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`SyntaxTreeAnalysisContext`提供给语法树操作的语义模型不暴露源文件，因此无法在语法树操作内执行语义分析。'
- en: Creating a method body analyzer to analyze whole method and report issues
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建方法体分析器以分析整个方法和报告问题
- en: A stateful method body or code block analyzer registers action callbacks that
    require whole method body analysis to report issues about the method declaration
    or executable code. These analyzers generally need to initialize some mutable
    state at the start of the analysis, which is updated while analyzing the method
    body, and the final state is used to report diagnostics.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 状态方法体或代码块分析器注册了需要整个方法体分析来报告关于方法声明或可执行代码问题的操作回调。这些分析器通常需要在分析开始时初始化一些可变状态，这些状态在分析方法体时更新，并且最终状态用于报告诊断。
- en: In this section, we will create a code block analyzer that flags unused method
    parameters. For example, it will not flag `param1` and `param2` as unused, but
    will flag `param3` and `param4`*.*
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个代码块分析器，标记未使用的方法参数。例如，它不会标记`param1`和`param2`为未使用，但会标记`param3`和`param4`*.*。
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have created and opened an analyzer project, say `CSharpAnalyzers`
    in Visual Studio 2017\. Refer to the first recipe in this chapter to create this
    project.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在Visual Studio 2017中创建并打开一个分析器项目，例如`CSharpAnalyzers`。请参考本章的第一个配方来创建此项目。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In Solution Explorer, double-click on `Resources.resx` file in `CSharpAnalyzers`
    project to open the resource file in the resource editor.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中，双击`CSharpAnalyzers`项目中的`Resources.resx`文件以在资源编辑器中打开资源文件。
- en: Replace the existing resource strings for `AnalyzerDescription`, `AnalyzerMessageFormat`
    and `AnalyzerTitle` with new strings.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AnalyzerDescription`、`AnalyzerMessageFormat`和`AnalyzerTitle`的现有资源字符串替换为新字符串。
- en: '![](img/8e00bba6-4e68-4384-b87c-fb70231c1fc5.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e00bba6-4e68-4384-b87c-fb70231c1fc5.png)'
- en: Replace the `Initialize` method implementation with the code from `CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/DiagnosticAnalyzer.cs/`
    method named `Initialize`*.*
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Initialize`方法实现替换为来自`CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/DiagnosticAnalyzer.cs/`中名为`Initialize`*.*的方法的代码。
- en: Add private class `UnusedParametersAnalyzer` from `CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/DiagnosticAnalyzer.cs/`
    type named `UnusedParametersAnalyzer` in your analyzer to perform the core method
    body analysis for a given method.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的分析器中添加来自 `CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/DiagnosticAnalyzer.cs/`
    的私有类 `UnusedParametersAnalyzer`，该类名为 `UnusedParametersAnalyzer`，以执行给定方法的核心理法体分析。
- en: Click on *Ctrl* + *F5* to start a new Visual Studio instance with the analyzer
    enabled.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 *Ctrl* + *F5* 以启动一个新的带有分析器的 Visual Studio 实例。
- en: 'In the new Visual Studio instance, create a new C# class library with the following
    code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 Visual Studio 实例中，创建一个新的 C# 类库，代码如下：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Verify the analyzer diagnostic is not reported for `param1` and `param2`, but
    is reported for `param3` and `param4`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证分析器诊断信息对于 `param1` 和 `param2` 没有报告，但对于 `param3` 和 `param4` 有报告：
- en: '![](img/13cb91bb-0028-4ff8-aaf8-0d5b4031ada9.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13cb91bb-0028-4ff8-aaf8-0d5b4031ada9.png)'
- en: 'Now, add code to use `param3` in the local declaration statement, delete `param4`,
    and verify the diagnostics go away:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向本地声明语句中添加使用`param3`的代码，删除`param4`，并验证诊断信息是否消失：
- en: '![](img/bfac07c2-a169-420c-bf00-312f99b4b1ae.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bfac07c2-a169-420c-bf00-312f99b4b1ae.png)'
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Code block analyzers register code block actions to analyze executable code
    blocks in the compilation. You can register either a stateless `CodeBlockAction`
    or a stateful `CodeBlockStartAction` with nested actions to analyze syntax nodes
    within a code block. Our analyzer registers a `CodeBlockStartAction` to perform
    stateful analysis.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块分析器注册代码块操作以分析编译中的可执行代码块。您可以注册无状态的 `CodeBlockAction` 或具有嵌套操作的 `CodeBlockStartAction`
    以分析代码块内的语法节点。我们的分析器注册了一个 `CodeBlockStartAction` 以执行有状态的分析。
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Analysis begins with a couple of early bail out checks: we are only interested
    in analyzing executable code within a method body and methods that have at least
    one parameter.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 分析从几个早期的退出检查开始：我们只对分析方法体内部的可执行代码以及至少有一个参数的方法感兴趣。
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We allocate a new `UnusedParametersAnalyzer` instance for every method to be
    analyzed. A constructor of this type initializes the mutable state tracked for
    analysis (explained later):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个要分析的方法分配一个新的 `UnusedParametersAnalyzer` 实例。此类构造函数初始化分析中跟踪的可变状态（稍后解释）：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We then register a nested syntax node action, `UnusedParametersAnalyzer.AnalyzeSyntaxNode`*,*
    on the given code block context for the given method. We register interest in
    analyzing `IdentifierName` syntax nodes within the code block:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在给定方法的给定代码块上下文中注册一个嵌套的语法节点操作，`UnusedParametersAnalyzer.AnalyzeSyntaxNode`，并注册对代码块内
    `IdentifierName` 语法节点的分析兴趣：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, we register a nested `CodeBlockEndAction` to be executed on the instance
    of `UnusedParametersAnalyzer` at the end of the code block analysis.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在代码块分析结束时注册一个嵌套的 `CodeBlockEndAction` 以在 `UnusedParametersAnalyzer` 实例上执行。
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Nested end actions are always guaranteed to be executed *after* all the nested
    non-end actions registered on the same analysis context have finished executing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的结束操作总是在同一分析上下文中注册的所有嵌套非结束操作执行完毕后保证执行。
- en: 'Let''s now understand the working of the core `UnusedParametersAnalyzer` type
    to analyze a specific code block. This analyzer defines mutable state fields to
    track parameters (and their names) that are considered to be unused:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在了解核心 `UnusedParametersAnalyzer` 类型的工作原理，以分析特定的代码块。此分析器定义了可变状态字段以跟踪被认为是未使用的参数（及其名称）：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We initialize this mutable state in the constructor of the analyzer. At the
    start of the analysis, we filter out implicitly declared parameters and parameters
    with no source locations - these are never considered to be redundant. We mark
    the remaining parameters as unused.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在分析器的构造函数中初始化这个可变状态。在分析开始时，我们过滤掉隐式声明的参数和没有源位置的参数——这些永远不会被认为是冗余的。我们将剩余的参数标记为未使用。
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`AnalyzeSyntaxNode` has been registered as a nested syntax node action to analyze
    all `IdentifierName` nodes within the code block. We perform a couple of quick
    checks at the start of the method and bail out of analysis if (a) We have no unused
    parameters in our current analysis state, or (b) The identifier name doesn''t
    match any of the unused parameter names. The latter check is done to avoid the
    performance hit of attempting to compute symbol info for the identifier.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnalyzeSyntaxNode` 已注册为嵌套的语法节点操作，用于分析代码块内的所有 `IdentifierName` 节点。我们在方法开始时进行一些快速检查，如果
    (a) 我们当前分析状态中没有未使用的参数，或者 (b) 标识符名称不匹配任何未使用的参数名称，则退出分析。后者的检查是为了避免尝试计算标识符符号信息的性能损失。'
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Then, we use the semantic model APIs to get semantic symbol info for the identifier
    name and check if it binds to one of the parameters that is currently considered
    unused. If so, we remove this parameter (and it's name) from the unused set.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用语义模型 API 获取标识符名称的语义符号信息，并检查它是否绑定到当前被视为未使用的参数之一。如果是这样，我们从未使用集合中删除此参数（及其名称）。
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Finally, the registered code block end action walks through all the remaining
    parameters in the unused set and flags them as unused parameters.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注册的代码块结束操作遍历未使用集合中的所有剩余参数，并将它们标记为未使用参数。
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Creating a compilation analyzer to analyze whole compilation and report issues
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个分析整个编译并报告问题的编译分析器
- en: A stateful compilation analyzer registers action callbacks that require compilation-wide
    analysis of symbols and/or syntax to report issues about declarations or executable
    code in the compilation. These analyzers generally need to initialize some mutable
    state at the start of the analysis, which is updated while analyzing the compilation,
    and the final state is used to report diagnostics.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有状态的编译分析器注册了需要编译范围内符号和/或语法分析的回调，以报告有关声明或可执行代码的问题。这些分析器通常需要在分析开始时初始化一些可变状态，该状态在分析编译时更新，并使用最终状态来报告诊断信息。
- en: 'In this section, we will create an analyzer that performs compilation-wide
    analysis and reports. Diagnostic secure types must not implement interfaces with
    insecure methods for the following scenarios:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个执行编译范围内分析和报告的分析器。对于以下场景，诊断安全类型不得实现具有不安全方法的接口：
- en: Assume we have an interface, say `MyNamespace.ISecureType`, which is a well-known
    secure interface, i.e. it is a marker for all secure types in an assembly*.*
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们有一个接口，比如 `MyNamespace.ISecureType`，这是一个众所周知的安全接口，即它是表示程序集中所有安全类型的标记*。
- en: Assume we have a method attribute, say `MyNamespace.InsecureMethodAttribute`*,*
    which marks the method on which the attribute is applied as insecure. An interface
    which has any member with such an attribute, must be considered insecure.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们有一个方法属性，比如 `MyNamespace.InsecureMethodAttribute`*，它标记了应用此属性的方法为不安全。任何具有此类属性的成员的接口都必须被视为不安全。
- en: We want to report diagnostics for types implementing the well-known secure interface
    that also implements any insecure interfaces.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望报告实现知名安全接口同时也实现任何不安全接口的类型的相关诊断信息。
- en: Analyzer performs compilation-wide analysis to detect such violating types and
    reports diagnostics for them in the compilation end action.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器执行编译范围内的分析以检测此类违规类型，并在编译结束操作中报告它们的诊断信息。
- en: Getting ready
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have created and opened an analyzer project, say `CSharpAnalyzers`
    in Visual Studio 2017\. Refer to the first recipe in this chapter to create this
    project.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建并打开一个分析器项目，例如在 Visual Studio 2017 中创建 `CSharpAnalyzers`。请参阅本章的第一个配方以创建此项目。
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In Solution Explorer, double click on `Resources.resx` file in `CSharpAnalyzers`
    project to open the resource file in the resource editor.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中，双击 `CSharpAnalyzers` 项目中的 `Resources.resx` 文件以在资源编辑器中打开资源文件。
- en: Replace the existing resource strings for `AnalyzerDescription`, `AnalyzerMessageFormat`
    and `AnalyzerTitle` with new strings.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 `AnalyzerDescription`、`AnalyzerMessageFormat` 和 `AnalyzerTitle` 资源字符串替换为新字符串。
- en: '![](img/4fbcc7c0-2864-459d-939d-460b9fc28ae0.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4fbcc7c0-2864-459d-939d-460b9fc28ae0.png)'
- en: Replace the `Initialize` method implementation with the code from `CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/DiagnosticAnalyzer.cs/`
    method named `Initialize`**.**
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Initialize` 方法实现替换为来自 `CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/DiagnosticAnalyzer.cs/`
    方法名为 `Initialize`** 的代码**。
- en: Add a private class `CompilationAnalyzer` from `CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/DiagnosticAnalyzer.cs/`
    type named `CompilationAnalyzer` in your analyzer to perform the core method body
    analysis for a given method.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的分析器中添加一个名为 `CompilationAnalyzer` 的私有类，来自 `CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/DiagnosticAnalyzer.cs/`
    类型，以执行给定方法的核心理法体分析。
- en: Click on *Ctrl* + *F5* to start a new Visual Studio instance with the analyzer
    enabled.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 *Ctrl* + *F5* 以启动一个新的带有分析器的 Visual Studio 实例。
- en: 'In the new Visual Studio instance, enable full solution analysis for C# projects
    by following the steps here: [https://msdn.microsoft.com/en-us/library/mt709421.aspx](https://msdn.microsoft.com/en-us/library/mt709421.aspx)'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 Visual Studio 实例中，通过遵循此处提供的步骤启用 C# 项目的完整解决方案分析：[https://msdn.microsoft.com/en-us/library/mt709421.aspx](https://msdn.microsoft.com/en-us/library/mt709421.aspx)
- en: '![](img/ddcca190-41a4-4447-a097-de7de89802d6.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ddcca190-41a4-4447-a097-de7de89802d6.png)'
- en: 'In the new Visual Studio instance, create a new C# class library with the following
    code:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 Visual Studio 实例中，创建一个新的 C# 类库，代码如下：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Verify the analyzer diagnostic is not reported for `MyInterfaceImpl1` and `MyInterfaceImpl`*3*,
    but is reported for `MyInterfaceImpl2`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证分析器诊断信息对于 `MyInterfaceImpl1` 和 `MyInterfaceImpl`*3* 没有报告，但对于 `MyInterfaceImpl2`
    有报告：
- en: '![](img/532fc9dd-d8c3-4f1b-94dd-b02f5ee9170a.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/532fc9dd-d8c3-4f1b-94dd-b02f5ee9170a.png)'
- en: Now, change `MyInterfaceImpl2` so that it no longer implements `IInsecureInterface`
    and verify that the diagnostic is no longer reported.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `MyInterfaceImpl2` 改为不再实现 `IInsecureInterface` 并验证诊断信息不再报告。
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Compilation analyzers register compilation actions to analyze symbols and/or
    syntax nodes in the compilation. You can register either a stateless `CompilationAction`
    or a stateful `CompilationStartAction` with nested actions to analyze symbols
    and/or syntax nodes within a compilation. Our analyzer registers a `CompilationStartAction`
    to perform stateful analysis.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 编译分析器注册编译操作以分析编译中的符号和/或语法节点。您可以注册无状态的 `CompilationAction` 或具有嵌套操作的 `CompilationStartAction`
    以分析编译内的符号和/或语法节点。我们的分析器注册了一个 `CompilationStartAction` 来执行有状态分析。
- en: '[PRE36]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Analysis begins with a couple of early bail out checks: we are only interested
    in analyzing compilations which have source or metadata types by name `MyNamespace.ISecureType`
    and `MyNamespace.InsecureMethodAttribute`.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 分析从几个早期退出检查开始：我们只对具有名为 `MyNamespace.ISecureType` 和 `MyNamespace.InsecureMethodAttribute`
    的源或元数据类型的编译进行分析。
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We allocate a new `CompilationAnalyzer` instance for compilations to be analyzed.
    A constructor of this type initializes the mutable and immutable state tracked
    for analysis (explained later).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为要分析的编译分配一个新的 `CompilationAnalyzer` 实例。此类构造函数初始化分析中跟踪的可变和不可变状态（稍后解释）。
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We then register a nested symbol action, `CompilationAnalyzer.AnalyzeSymbol`,
    on the given compilation start context for the given compilation. We register
    interest in analyzing type and method symbols within the compilation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在给定的编译开始上下文中注册一个嵌套符号操作，`CompilationAnalyzer.AnalyzeSymbol`，以分析给定的编译中的类型和符号。
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Finally, we register a nested `CompilationEndAction` to be executed on the instance
    of `CompilationAnalyzer` at the end of the compilation analysis.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在编译分析结束时注册一个嵌套的 `CompilationEndAction` 以在 `CompilationAnalyzer` 实例上执行。
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Nested compilation end actions are always guaranteed to be executed *after*
    all the nested non-end actions registered on the same analysis context have finished
    executing.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的编译结束操作始终保证在相同分析上下文中注册的所有嵌套非结束操作执行完毕后执行。
- en: Let's now understand the working of the core `CompilationAnalyzer` type to analyze
    a specific compilation. This analyzer defines an immutable state for type symbols
    corresponding to the secure interface and insecure method attribute. It also defines
    mutable state fields to track the set of types defined in the compilation that
    implement the secure interface and a set of interfaces defined in the compilation
    that have methods with an insecure method attribute.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解核心 `CompilationAnalyzer` 类型的运作方式，以便分析特定的编译。此分析器为对应于安全接口和不安全方法属性的类型符号定义了一个不可变状态。它还定义了可变状态字段，以跟踪编译中定义的实现安全接口的类型集合以及编译中定义的具有不安全方法属性的方法集合。
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: At the start of the analysis, we initialize the set of secure types and interfaces
    with insecure methods to be empty.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析开始时，我们将安全类型和不安全方法接口的集合初始化为空。
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`AnalyzeSymbol` is registered as a nested symbol action to analyze all types
    and methods within the compilation. For every type declaration in the compilation,
    we check whether it implements the secure interface, and if so, add it to our
    set of secure types. For every method declaration in the compilation, we check
    whether its containing type is an interface and the method has the insecure method
    attribute, and if so, add the containing interface type to our set of interface
    types with insecure methods.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnalyzeSymbol` 被注册为嵌套符号操作，以分析编译内的所有类型和方法。对于编译中的每个类型声明，我们检查它是否实现了安全接口，如果是，则将其添加到我们的安全类型集合中。对于编译中的每个方法声明，我们检查其包含的类型是否为接口以及方法是否具有不安全方法属性，如果是，则将包含的接口类型添加到我们的具有不安全方法接口类型集合中。'
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Finally, the registered the compilation end action uses the final state at the
    end of compilation analysis to report diagnostics. Analysis in this action starts
    by bailing out early if we either have no secure types or no interfaces with insecure
    methods. Then, we walk through all secure types and all interfaces with insecure
    methods, and for every pair. check whether the secure type or any of its base
    types implements the insecure interface. If so, we report a diagnostic on the
    secure type.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注册的编译结束操作使用编译分析结束时的最终状态来报告诊断。在此操作中，如果既没有安全类型也没有不安全方法的接口，则分析将提前退出。然后，我们遍历所有安全类型和所有不安全方法的接口，并对每一对进行检查，看安全类型或其任何基类型是否实现了不安全接口。如果是这样，我们在安全类型上报告一个诊断。
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Writing unit tests for an analyzer project
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为分析器项目编写单元测试
- en: In this section, we will show you how to write and execute unit tests for an
    analyzer project.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何编写和执行分析器项目的单元测试。
- en: Getting ready
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have created and opened an analyzer project, say `CSharpAnalyzers`
    in Visual Studio 2017\. Refer to the first recipe in this chapter to create this
    project.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建并打开一个分析器项目，例如在Visual Studio 2017中创建`CSharpAnalyzers`。请参阅本章的第一个配方以创建此项目。
- en: How to do it...
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open UnitTests.cs in the `CSharpAnalyzers.Test` project in the Solution Explorer
    solution to view the default unit tests created for the default symbol analyzer
    (type names should not contain lowercase letters) for the template analyzer project.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中打开`CSharpAnalyzers.Test`项目中的`UnitTests.cs`，以查看为模板分析器项目创建的默认单元测试（类型名称不应包含小写字母）。
- en: '![](img/7968ef6e-c4f5-4f16-81ec-759165b887d2.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7968ef6e-c4f5-4f16-81ec-759165b887d2.png)'
- en: 'Navigate to Test | Windows | Test Window to open the Test Explorer window to
    view the unit tests in the project. Default analyzer project has two unit tests:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到测试 | 窗口 | 测试窗口以打开测试资源管理器窗口，查看项目中的单元测试。默认分析器项目有两个单元测试：
- en: '`TestMethod1`: This tests the scenario where analyzer diagnostic does not fire
    on the test code and'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestMethod1`：这个测试了分析器诊断在测试代码上没有触发的场景。'
- en: '`TestMethod2`: This tests the scenario where analyzer diagnostic does fire
    on the test code.'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestMethod2`：这个测试了分析器诊断在测试代码上确实触发的场景。'
- en: '![](img/0a6370b3-cdf3-459a-b787-ca1674514e1f.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a6370b3-cdf3-459a-b787-ca1674514e1f.png)'
- en: Note that the unit test project contains unit tests for both the DiagnosticAnalyzer
    and CodeFixProvider. This chapter deals with analyzer testing only. We will expand
    on the unit tests for the CodeFixProvider later in this book.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，单元测试项目包含对DiagnosticAnalyzer和CodeFixProvider的单元测试。本章仅处理分析器测试。我们将在本书的后面部分扩展对CodeFixProvider的单元测试。
- en: Run all the unit tests for the project by right-clicking Not Run tests node
    in the Test Explorer, executing the Run selected tests context menu command, and
    verify that the tests pass.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在测试资源管理器中右键单击“未运行测试”节点，执行“运行选中测试”上下文菜单命令来运行项目的所有单元测试，并验证测试是否通过。
- en: 'Edit `TestMethod1` so that the test code now has a type with lower-case letters:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`TestMethod1`，使测试代码现在有一个小写字母的类型：
- en: '[PRE45]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Right-click on `TestMethod1` in the editor, execute the Run tests context menu
    command, and verify that the test now fails with the diagnostic mismatch assert
    - `expected "0" actual "1"`:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中右键单击`TestMethod1`，执行“运行测试”上下文菜单命令，并验证测试现在由于诊断不匹配断言而失败 - `预期 "0" 实际 "1"`：
- en: '![](img/b151333e-80c8-45c6-b17e-908bbcaef64e.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b151333e-80c8-45c6-b17e-908bbcaef64e.png)'
- en: 'Edit `TestMethod1` to now add an excepted diagnostic for the new test code:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`TestMethod1`以现在添加对新测试代码的预期诊断：
- en: '[PRE46]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Run the unit test again and note that the test still fails, but now it fails
    due to a difference in the location (column number) at which the diagnostic was
    reported.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行单元测试并注意，测试仍然失败，但现在失败是因为诊断报告的位置（列号）不同。
- en: '![](img/d6d79d20-cf18-40ab-9f0a-1d6dfacbac8a.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d6d79d20-cf18-40ab-9f0a-1d6dfacbac8a.png)'
- en: Edit the diagnostic location to use the correct expected column number and rerun
    the test - verify that the test passes now.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑诊断位置以使用正确的预期列号并重新运行测试 - 验证测试现在是否通过。
- en: '[PRE47]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Edit `TestMethod1` and change the test code to rename `Class1` to `CLASS1`:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`TestMethod1`并将测试代码更改为将`Class1`重命名为`CLASS1`：
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Run the unit test again and verify that the test fails now due to a diagnostic
    mismatch assert - `expected "1" actual "0"`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行单元测试并验证测试现在由于诊断不匹配断言而失败 - `预期 "1" 实际 "0"`。
- en: '![](img/364e25f7-e9c6-4ef6-bcf3-65e7d9e6c899.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/364e25f7-e9c6-4ef6-bcf3-65e7d9e6c899.png)'
- en: 'Edit `TestMethod1` to remove the expected diagnostic and verify the test passes:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `TestMethod1` 以删除预期诊断并验证测试通过：
- en: '[PRE49]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The analyzer unit test project allows us to write unit tests for the execution
    of our analyzer on different code samples. Each unit test is marked with a `TestMethod`
    attribute and defines sample test code, expected diagnostic(s) reported by the
    analyzer on that code (if any), and invocation of test helper method(s), here
    `VerifyCSharpDiagnostic`*,* to verify diagnostics.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器单元测试项目允许我们为分析器在不同代码样本上的执行编写单元测试。每个单元测试都带有 `TestMethod` 属性，并定义了示例测试代码、分析器在代码上报告的预期诊断（如果有），以及调用测试辅助方法（此处为
    `VerifyCSharpDiagnostic`*，*）以验证诊断。
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Unit tests can define expected diagnostics using the `DiagnosticResult` type,
    which must specify the diagnostic `Id`, `Message`, `Severity` and `Locations`
    for the diagnostic:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以使用 `DiagnosticResult` 类型定义预期诊断，该类型必须指定诊断的 `Id`、`Message`、`Severity` 和
    `Locations`：
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Computing the correct line number and column number for an expected diagnostic,
    for example (11, 15), can be a bit tricky. The approach that normally works is
    to start with a default location of (0, 0), execute the test once, and look at
    the failure text in the Test Explorer window to get the expected and actual line
    number. Then, replace the expected line number in the test code with the actual
    line number. Re-execute the test and repeat the process to get the correct column
    number.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 计算预期诊断的正确行号和列号（例如，(11, 15)）可能有点棘手。通常有效的方法是从默认位置 (0, 0) 开始，执行一次测试，然后查看测试资源管理器窗口中的失败文本以获取预期和实际行号。然后，将测试代码中的预期行号替换为实际行号。重新执行测试并重复此过程以获取正确的列号。
- en: '`UnitTest` type containing all the unit tests also overrides the following
    methods to return the `DiagnosticAnalyzer` (and optionally a `CodeFixProvider`)
    to be tested:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 包含所有单元测试的 `UnitTest` 类型还重写了以下方法以返回要测试的 `DiagnosticAnalyzer`（以及可选的 `CodeFixProvider`）：
- en: '[PRE52]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, let us expand a bit more on the test framework helpers for the unit tests.
    The analyzer unit test project contains two primary helper abstract types to write
    unit tests for analyzers and code fixes:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地介绍单元测试的测试框架辅助工具。分析器单元测试项目包含两个主要的辅助抽象类型，用于编写分析器和代码修复的单元测试：
- en: '`DiagnosticVerifier`**:** Contains helper methods to run `DiagnosticAnalyzer`
    unit tests that verify the analyzer diagnostics for a given set of test sources.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DiagnosticVerifier`**:** 包含辅助方法以运行 `DiagnosticAnalyzer` 单元测试，这些测试验证给定测试源集的分析器诊断。'
- en: '`CodeFixVerifier`: Contains helper methods to run `DiagnosticAnalyzer` and
    `CodeFixProvider` unit tests that verify the analyzer diagnostics for a given
    set of test sources before and after applying a code fix. This type derives from
    `DiagnosticVerifier`.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CodeFixVerifier`: 包含辅助方法以运行 `DiagnosticAnalyzer` 和 `CodeFixProvider` 单元测试，这些测试在应用代码修复前后验证给定测试源集的分析器诊断。此类型继承自
    `DiagnosticVerifier`。'
- en: In the default analyzer project, `UnitTest` type derives from `CodeFixVerifier`,
    but could also be changed to derive from `DiagnosticVerifier`*,* if you are only
    interested in writing analyzer unit tests. We will just focus on the `DiagnosticVerifier`
    here; `CodeFixVerifier` is covered later in chapter***.***
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认的分析器项目中，`UnitTest` 类型继承自 `CodeFixVerifier`，但也可以改为继承自 `DiagnosticVerifier`*，*
    如果你只对编写分析器单元测试感兴趣。我们在这里将只关注 `DiagnosticVerifier`；`CodeFixVerifier` 将在后面的章节中介绍***。***
- en: '`DiagnosticVerifier` type is split into 2 source files `DiagnosticVerifier.cs`
    and `DiagnosticVerifier.Helper.cs`*.*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`DiagnosticVerifier` 类型分为 2 个源文件 `DiagnosticVerifier.cs` 和 `DiagnosticVerifier.Helper.cs`*.*'
- en: '![](img/b642ab13-ec95-410a-bde9-7cc2d0cf7a52.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b642ab13-ec95-410a-bde9-7cc2d0cf7a52.png)'
- en: '`DiagnosticVerifier.Helper.cs` contains the following core functionality:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DiagnosticVerifier.Helper.cs` 包含以下核心功能：'
- en: Helper methods to create a compilation with source files based on given C# or
    VisualBasic source code (Set up compilation and documents region in the preceding
    screenshot).
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供辅助方法以创建基于给定 C# 或 VisualBasic 源代码的源文件编译（前一个截图中的“设置编译和文档”区域）。
- en: Helper methods to invoke the preceding functionality to create a compilation
    with the given C# or VisualBasic source code, and execute the given `DiagnosticAnalyzer`
    on the compilation to produce analyzer diagnostics and return sorted diagnostics
    for verification (Get Diagnostics region in the preceding screenshot).
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供辅助方法以调用前面的功能来创建包含给定 C# 或 VisualBasic 源代码的编译，并在编译上执行给定的 `DiagnosticAnalyzer`
    以生成分析器诊断，并返回排序后的诊断以进行验证（前一个截图中的“获取诊断”区域）。
- en: '`DiagnosticVerifier.cs` contains the following core functionality:'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DiagnosticVerifier.cs` 包含以下核心功能：'
- en: Method(s) to get the `DiagnosticAnalyzer` type to be tested (To be implemented
    by Test classes region in the preceding screenshot).
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取要测试的 `DiagnosticAnalyzer` 类型的方法（在前一个截图中的“测试类要实现区域”中实现）。
- en: Private helpers to perform actual diagnostic comparison and verification and
    formatting of diagnostics to get a string representation of actual/expected diagnostics
    when a unit test fails (Actual comparisons and verifications region and Formatting
    Diagnostics region in the preceding screenshot).
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行实际的诊断比较和验证以及格式化诊断，以便在单元测试失败时获取实际/预期诊断的字符串表示（前一个截图中的“实际比较和验证区域”和“格式化诊断区域”）。
- en: Diagnostic verification methods `VerifyCSharpDiagnostic` and `VerifyBasicDiagnostic`
    that can be invoked by the unit tests to verify analyzer diagnostics generated
    on the given C# or Visual Basic source code (Verifier wrappers section in the
    preceding screenshot). These methods invoke the Get Diagnostics helpers to create
    a compilation and get sorted analyzer diagnostics and then invoke the preceding
    private helpers to compare and verify diagnostics.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诊断验证方法 `VerifyCSharpDiagnostic` 和 `VerifyBasicDiagnostic` 可以通过单元测试调用，以验证在给定的
    C# 或 Visual Basic 源代码上生成的分析器诊断（前一个截图中的“验证器包装器”部分）。这些方法调用获取诊断辅助工具来创建编译并获取排序后的分析器诊断，然后调用前面的私有辅助工具来比较和验证诊断。
- en: See also
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Live Unit testing is a new feature in *Visual Studio 2017* Enterprise Edition,
    which automatically runs the impacted unit tests in the background as you edit
    code, and visualizes the results and code coverage live, in the editor, in real-time.
    Refer to [Chapter 6](eb1b605b-117f-4adf-a111-cfb686799929.xhtml)*, Live Unit Testing
    in Visual Studio Enterprise*, to enable live unit testing for the project and
    visualize unit tests automatically executing after you edit the code in the steps
    in this recipe.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Live 单元测试是 *Visual Studio 2017* 企业版中的新功能，它会在您编辑代码时在后台自动运行受影响的单元测试，并在编辑器中实时可视化结果和代码覆盖率。请参阅[第
    6 章](eb1b605b-117f-4adf-a111-cfb686799929.xhtml)*，Visual Studio 企业版中的 Live 单元测试*，以启用项目的实时单元测试并可视化在您按照本食谱中的步骤编辑代码后自动执行的单元测试。
- en: Publishing NuGet package and VSIX for an analyzer project
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布分析器项目的 NuGet 包和 VSIX
- en: We will show you how to configure, build, and publish a NuGet package and a
    VSIX package for an analyzer project created in Visual Studio 2017 using the .NET
    Compiler platform SDK.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向您展示如何配置、构建和发布一个用于在 Visual Studio 2017 中使用 .NET 编译器平台 SDK 创建的分析器项目的 NuGet
    包和 VSIX 包。
- en: Before we start digging into these topics, let's understand the difference between
    NuGet-based analyzer packages and VSIX-based analyzer packages. NuGet and VSIX
    are basically two different packaging schemes for the Microsoft development platform
    to package files such as assemblies, resources, build targets, tools, and so on,
    into a single installable package.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨这些主题之前，让我们了解基于 NuGet 的分析器包和基于 VSIX 的分析器包之间的区别。NuGet 和 VSIX 是微软开发平台为打包文件（如程序集、资源、构建目标、工具等）到单个可安装包的两种基本不同的打包方案。
- en: NuGet is a more generic packaging scheme. NuGet packages (`.nupkg` files) can
    be directly referenced in .NET projects and installed to a specific project or
    solution using the NuGet package manager in Visual Studio. Analyzer NuGet packages
    based on the analyzer template project get installed as AnalyzerReferences in
    the project file, and then get passed onto the compiler command line to be executed
    during build. Additionally, AnalyzerReferences are resolved at design time by
    the Visual Studio IDE and executed while code editing to generate live diagnostics.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NuGet 是一种更通用的打包方案。NuGet 包（`.nupkg` 文件）可以直接在 .NET 项目中引用，并使用 Visual Studio 中的
    NuGet 包管理器安装到特定的项目或解决方案。基于分析器模板项目的分析器 NuGet 包被安装为项目文件中的 AnalyzerReferences，然后传递给编译器命令行以在构建期间执行。此外，AnalyzerReferences
    在 Visual Studio IDE 中设计时解析，并在代码编辑时执行以生成实时诊断。
- en: A VSIX package is a `.vsix` file that contains one or more Visual Studio extensions,
    together with the metadata Visual Studio uses to classify and install the extensions.
    An analyzer VSIX package can be installed machine-wide or to a specific extension
    hive, and is enabled for all projects/solutions opened from the Visual Studio
    hive. Unlike a `NuGet` package, it cannot be installed specifically to a project/solution
    and does not travel along with the project sources.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VSIX 包是一个 `.vsix` 文件，它包含一个或多个 Visual Studio 扩展，以及 Visual Studio 用来分类和安装扩展的元数据。分析器
    VSIX 包可以全局安装或安装到特定的扩展分叉中，并针对从 Visual Studio 分叉打开的所有项目/解决方案启用。与 `NuGet` 包不同，它不能专门安装到项目/解决方案中，并且不会与项目源一起移动。
- en: 'As of Visual Studio 2017, analyzers installed as `AnalyzerReferences` via NuGet
    packages execute during both: command line builds and live code editing in Visual
    Studio. Analyzers installed via Analyzer VSIX packages execute only during live
    code editing in Visual Studio and not during project build. Hence, only analyzer
    NuGet packages can be configured to execute in continuous integration (CI) build
    systems and break the build.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Visual Studio 2017，通过 NuGet 包安装的 `AnalyzerReferences` 分析器在命令行构建和 Visual Studio
    中的实时代码编辑期间都会执行。通过 Analyzer VSIX 包安装的分析器仅在 Visual Studio 中的实时代码编辑期间执行，不在项目构建期间执行。因此，只有分析器
    NuGet 包可以配置为在持续集成 (CI) 构建系统中执行并中断构建。
- en: Getting ready
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have created and opened an analyzer project, say `CSharpAnalyzers`
    in Visual Studio 2017\. Refer to the first recipe in this chapter to create this
    project.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在 Visual Studio 2017 中创建并打开一个分析器项目，例如 `CSharpAnalyzers`。请参阅本章的第一个配方以创建此项目。
- en: How to do it...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Build `CSharpAnalyzers` solution in Visual Studio by executing the Build | Build
    Solution command.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中通过执行“构建 | 构建解决方案”命令来构建 `CSharpAnalyzers` 解决方案。
- en: Open the binary output folder for the `CSharpAnalyzers` project (`<%SolutionFolder%>\CSharpAnalyzers\bin\debug`)
    in Windows Explorer and verify that the NuGet package for the analyzer named,
    `CSharpAnalyzers.1.0.X.Y.nupkg`, is generated in the folder.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 资源管理器中打开 `CSharpAnalyzers` 项目的二进制输出文件夹 (`<%SolutionFolder%>\CSharpAnalyzers\bin\debug`)，并验证名为
    `CSharpAnalyzers.1.0.X.Y.nupkg` 的分析器 NuGet 包是否已生成在文件夹中。
- en: Double*-*click on the `Diagnostic.nuspec` file in the `CSharpAnalyzers` project
    in Solution Explorer to view and configure the properties of the nupkg.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中双击 `CSharpAnalyzers` 项目的 `Diagnostic.nuspec` 文件，以查看和配置 nupkg 的属性。
- en: '![](img/4e45c11e-5f9e-4379-b39a-50e9a0c0af40.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e45c11e-5f9e-4379-b39a-50e9a0c0af40.png)'
- en: Rebuild the project to regenerate the nupkg with new properties.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建项目以使用新属性重新生成 nupkg。
- en: 'Publish the nupkg as a public or private package by following the steps listed
    here: [https://docs.microsoft.com/en-us/nuget/create-packages/publish-a-package](https://docs.microsoft.com/en-us/nuget/create-packages/publish-a-package).'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照此处列出的步骤发布 nupkg 为公共或私有包：[https://docs.microsoft.com/en-us/nuget/create-packages/publish-a-package](https://docs.microsoft.com/en-us/nuget/create-packages/publish-a-package)。
- en: Open the binary output folder for the `CSharpAnalyzers.Vsix` project (`<%SolutionFolder%\CSharpAnalyzers.Vsix\bin\debug`)
    in Windows Explorer and verify that VSIX for the analyzer named, `CSharpAnalyzers.Vsix.vsix`,
    is present in the folder.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 资源管理器中打开 `CSharpAnalyzers.Vsix` 项目的二进制输出文件夹 (`<%SolutionFolder%\CSharpAnalyzers.Vsix\bin\debug`)，并验证名为
    `CSharpAnalyzers.Vsix.vsix` 的 VSIX 是否存在于文件夹中。
- en: Double-click on the `source.extension.vsixmanifest` file in the `CSharpAnalyzers.Vsix`
    project in the Solution Explorer to view and configure the properties of the VSIX
    package.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中双击 `CSharpAnalyzers.Vsix` 项目的 `source.extension.vsixmanifest` 文件，以查看和配置
    VSIX 包的属性。
- en: '![](img/a078be13-99a0-4e17-ae52-6d3f77675ed4.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a078be13-99a0-4e17-ae52-6d3f77675ed4.png)'
- en: Rebuild the VSIX project to regerate the VSIX.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建 VSIX 项目以重新生成 VSIX。
- en: 'Publish it to the Visual Studio Extension Gallery by following the steps listed
    here: [https://msdn.microsoft.com/en-us/library/ff728613.aspx](https://msdn.microsoft.com/en-us/library/ff728613.aspx).'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照此处列出的步骤发布到 Visual Studio 扩展库：[https://msdn.microsoft.com/en-us/library/ff728613.aspx](https://msdn.microsoft.com/en-us/library/ff728613.aspx)。
