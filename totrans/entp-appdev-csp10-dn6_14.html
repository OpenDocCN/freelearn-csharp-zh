<html><head></head><body>
		<div><h1 id="_idParaDest-206"><em class="italic"><a id="_idTextAnchor1228"/>Chapter 11</em>: Creating an ASP.NET Core 6 Web Application</h1>
			<p>Up until now, we have built all the core components of the application, such as the data access layer and service layer, and all these components are primarily server-side components, also known as <strong class="bold">backend components</strong>. </p>
			<p>In this chapter, we will build the presentation layer/<strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) for our e-commerce application, which is also known as the <strong class="bold">client-side component</strong>. The UI is the face of the application; having a good presentation layer not only helps with keeping users engaged in the application but also encourages users to come back to the application. This is especially the case with enterprise applications, where a good presentation layer helps users to navigate through the application easily and helps them in performing various day-to-day activities that are dependent on the application with ease.</p>
			<p>We will focus on understanding ASP.NET Core MVC and developing a web application using ASP.NET Core MVC. Primarily, we will cover the following topics:</p>
			<ul>
				<li>Introduction to frontend web development</li>
				<li>Integrating APIs with the service layer</li>
				<li>Creating the controller and actions</li>
				<li>Creating a UI using ASP.NET Core MVC</li>
				<li>Understanding Blazor</li>
			</ul>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor1229"/><a id="_idTextAnchor1230"/>Technical requirements</h1>
			<p>For this chapter, you need a basic knowledge of C#, .NET Core, HTML, and CSS. The code examples for the chapter can be found here: <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter11/RazorSample">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter11/RazorSample</a>.</p>
			<p>You can find more code examples here: <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application</a>.</p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor1231"/><a id="_idTextAnchor1232"/>Introduction to frontend web development</h1>
			<p>The <a id="_idIndexMarker988"/>presentation <a id="_idIndexMarker989"/>layer is all about code that a browser can render and display to the user. Wheneve<a id="_idTextAnchor1233"/>r a page gets loaded in a browser, it creates a hierarchy of various elements, such as textboxes and labels, that are presen<a id="_idTextAnchor1234"/>t on the page. This hierarchy is known <a id="_idIndexMarker990"/>as the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>). </p>
			<p>A good frontend is all about the ability to manipulate the DOM as needed, and there are many technologies/libraries that support manipulating the DOM and loading data dynamically using the de facto language of the web, JavaScript. Be it jQuery (which simplifies the use of JavaScript), full-blown client-side frameworks such as Angular, React, or Vue (which support complete client-side rendering), or ASP.NET Core frameworks such as ASP.NET Core MVC, Razor Pages, or Blazor, it all boils down to handling the three major building blocks of the web: HTML, CSS, and JavaScript. Let's look into these three building blocks:</p>
			<ul>
				<li><strong class="bold">Hypertext Markup Language</strong> (<strong class="bold">HTML</strong>): HTML, as the full form states, is a mark<a id="_idTextAnchor1235"/>up<a id="_idIndexMarker991"/> language that browsers can understand and display the contents. It primarily consists of a series of tags, which <a id="_idTextAnchor1236"/>are known <a id="_idIndexMarker992"/>as <strong class="bold">HTML elements</strong>, and allows developers to define the structure of the page. For example, if you want to create a form that needs to allow the user to enter their first name and last name, it can be defined by using input HTML elements.</li>
				<li><strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>): The<a id="_idIndexMarker993"/> presentation layer is all about presenting data in a way that makes a web application more appealing to users and en<a id="_idTextAnchor1237"/>sures that the application is usable, irrespective of the device/resolution that a user tries to load the application in. This is where CSS plays a critical role in defining how the content is displayed on the browser. It controls various things, such as the styling of the pages, the theme of the application, and the color palette, and, more importantly, makes them responsive so that users have the same experience using the application, be it loaded on a mobile or a desktop.</li>
			</ul>
			<p>The good thing <a id="_idIndexMarker994"/>about modern web development is we don't need to write everythin<a id="_idTextAnchor1238"/>g from scratch and many libraries are available that can be picked and used as they are, in the application. We will be using one such library for an e-commerce application, which is explained in the <em class="italic">Creating a UI using ASP.NET Core MVC</em> section.</p>
			<ul>
				<li><strong class="bold">JavaScript</strong>: JavaScript is <a id="_idIndexMarker995"/>a scripting language that helps in performing various advanced dynamic operations, for example, validating input text entered in a form or<a id="_idTextAnchor1239"/> things such as enabling/disabling HTML elements conditionally or retrieving data from an API. JavaScript gives more power to web pages and adds many programming features that a developer can use to perform advanced operations on the client side. Just like HTML and CSS, all browsers can understand JavaScript, which forms an important part of the presentation layer. All these components can be linked to each other, as shown in the following di<a id="_idTextAnchor1240"/>agram:</li>
			</ul>
			<div><div><img src="img/Figure_11.1_B18507.jpg" alt="Figure 11.1 – HTML, CSS, and JavaScript&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – HTML, CSS, and JavaScript</p>
			<p class="callout-heading">Note</p>
			<p class="callout">HTML, CSS, and JavaScript all go hand in hand and play an important role in developing client-side/frontend applications and would require dedicated books to explain fully. Some related links can be found in the <em class="italic">Further reading</em> section.</p>
			<p>Now that we <a id="_idIndexMarker996"/>understand the importance of HTML, CSS, and JavaScript, we need to know how we can use them to build the presentation layer of a web application so that it can support multiple browsers and devices with different resolutions and is able to manage the state (HTTP being stateless). </p>
			<p>One technique could be to create all the HTML pages a<a id="_idTextAnchor1241"/>nd host them on a web server; however, while this works well with static sites and also involves building everything from the ground up, if we want the content to be more dynamic and want a rich UI, we need to use technologies that can generate the HTML pages dynamically and provide seamless support to interact with the backend. Let's look, in the next section, at various technologies that can be used to generate dynami<a id="_idTextAnchor1242"/><a id="_idTextAnchor1243"/>c HTML.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor1244"/>Razor syntax</h2>
			<p>Before<a id="_idIndexMarker997"/> we start understanding the various possible frameworks provided by ASP.NET Core, let's first understand what the Razor syntax is. It is a<a id="_idIndexMarker998"/> markup syntax to embed server-side c<a id="_idTextAnchor1245"/>omponents into HTML. We can use <a id="_idTextAnchor1246"/>the Razor syntax to bind any dynamic data for display or send it back to the server from a view/page for further processing. The Razor syntax is primarily written in Razor files/Razor view pages, which are nothing more than files used by C# to generate dynamic HTML. They go with the <code>.cshtml</code> extension and support the Razor syntax. The Razor <a id="_idTextAnchor1247"/>syntax is processed by an engine called <a id="_idIndexMarker999"/>the <strong class="bold">view engine</strong>, and t<a id="_idTextAnchor1248"/>he default view engine is known as the <strong class="bold">Razor engine</strong>.</p>
			<p>To embed <a id="_idIndexMarker1000"/>the Razor syntax, we typically use <code>@</code>, which tells the Razor engine to parse and generate HTML out of the engine. <code>@</code> can be followed by any C# built-in methods to generate HTML. For example, <code>&lt;b&gt;@DateTime.Now&lt;/b&gt;</code> can be used to display the current date and time in a Razor view/page. Apart from this, just like C#, the Razor syntax also supports code blocks and controls structures and variables, among other things. Some sample Razor syntax going through the Razor engine is shown in the followi<a id="_idTextAnchor1249"/>ng figure:</p>
			<div><div><img src="img/Figure_11.2_B18507.jpg" alt="Figure 11.2 – Razor syntax&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – Razor syntax</p>
			<p>The <a id="_idIndexMarker1001"/>R<a id="_idTextAnchor1250"/>azor syntax<a id="_idIndexMarker1002"/> also supports defining HTML controls; for example, to define a textbox, we can use the following Razor syntax:</p>
			<pre class="source-code">&lt;input asp-for=' FirstName ' /&gt;</pre>
			<p>T<a id="_idTextAnchor1251"/>he preceding code is known as an <code>input</code> tag helper and the Razor syntax takes care of what is known as <strong class="bold">directive</strong> tag helpers to bind data to an HTML control and generate rich, dynamic HTML. Let's discuss this briefly:</p>
			<ul>
				<li><strong class="bold">Directives</strong>: Under <a id="_idIndexMarker1003"/>the hood, each Razor view/page is parsed by the Razor engine, and <a id="_idTextAnchor1252"/>a C# class is used to generate dynamic HTML and then send it back to the browser. Directives can be used to control the behavior of this class, which further controls the dynamic HTML that is generated.</li>
			</ul>
			<p>For example, the <code>@using</code> directive can be used to include any namespaces in the Razor view/page, or the <code>@code</code> directive can be used to include any C# members.</p>
			<p>One of the most used directives is <code>@model</code>, which allows you to bind a model to a view, which helps in validating the type of view as well <a id="_idTextAnchor1253"/>as helps with IntelliSense. This process <a id="_idIndexMarker1004"/>of binding views to a specific class/model is known as <strong class="bold">strongly typing</strong> views. We will be strongly typing all our views in our e-commerce application, which we will see in the <em class="italic">Creating a UI using ASP.NET Core MVC</em> section.</p>
			<ul>
				<li><strong class="bold">Tag helpers</strong>: If you <a id="_idIndexMarker1005"/>used ASP.NET MVC before ASP.NET Core, you would h<a id="_idTextAnchor1254"/>ave come across HTML helpers, which are classes that help to bind data and generate HTML controls.</li>
			</ul>
			<p>However, with <a id="_idIndexMarker1006"/>ASP.NET Core, we have tag helpers, which help us to bind data to an HTML control. The benefit of tag helpers over HTML helpers is that tag helpers<a id="_idIndexMarker1007"/> use the same syntax as HTML with additional attributes assigned to the standard HTML controls that can be generated from dynamic data. For example, to generate an HTML textbox control, typically, we write the following code:</p>
			<pre>&lt;input type='text' id='Name' name='Name' value=' Mastering enterprise application development Book'&gt;</pre>
			<p>Using tag helpers, this would be rewritten as shown in the following code, where <code>@Name</code> is the property of the model that the view is strongly typed to:</p>
			<pre>&lt;input type='text' asp-for='@Name'&gt;</pre>
			<p>So, as you can see, it's all about writing HTML but taking advantage of Razor m<a id="_idTextAnchor1255"/>arkup to generate dyna<a id="_idTextAnchor1256"/>mic HTML. ASP.NET Core comes with many built-in tag helpers, and more details about them can be found here: <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/built-in/?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/built-in/?view=aspnetcore-6.0</a>.</p>
			<p>I<a id="_idTextAnchor1257"/>t is not required to know about/remember every tag helper, and we will use this reference documentation as and when we develop our application UI.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since Razor syntax is markup, it's not necessary to know all the syntax. The foll<a id="_idTextAnchor1258"/>owing link can be used as a reference for Razor syntax: <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-6.0</a>.</p>
			<p>With this, let's look into the various options in ASP.NET Core as well as other common frameworks to develop the pr<a id="_idTextAnchor1259"/><a id="_idTextAnchor1260"/>esentation layer.</p>
			<h2 id="_idParaDest-210">Exploring Razor Pag<a id="_idTextAnchor1261"/>es</h2>
			<p>Razor Pages<a id="_idIndexMarker1008"/> is <a id="_idTextAnchor1262"/>the default way to implement a web <a id="_idIndexMarker1009"/>application using ASP.NET Core. Razor Pages relies on the concept of having a Razor file that can serve requests directly and an optional C# file associated with that Razor file for any additional processing. A typical Razor application can be created with the following command:</p>
			<pre class="source-code"><strong class="bold">dotnet new webapp</strong> <strong class="bold">--framework net6.0 -o RazorSample</strong> </pre>
			<p>As you can see, the project has Razor pages and their corresponding C# files. On opening any Razor view, we see a directive called <code>@page</code>, which helps in browsing the page. So, for example, <code>/index</code> will be routed to <code>index.cshtml</code>. It's important that all Razor pages have the <code>@page</code> directive at the top of the page and are placed in the <code>Pages</code> folder, as the ASP.NET Core runtime looks for all the Razor pages in this folder.</p>
			<p>A Razor page can be further associated with a C# class, also known as a <code>PageModel</code> class, by using another directive called <code>@model</code>. The following is the code for the <code>index.cshtml</code> page:</p>
			<pre class="source-code">@page</pre>
			<pre class="source-code">@model IndexModel</pre>
			<pre class="source-code">@{</pre>
			<pre class="source-code">    ViewData["Title"] = "Home page";</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">&lt;form method="post"&gt;</pre>
			<pre class="source-code">    &lt;div class="text-center"&gt;</pre>
			<pre class="source-code">        &lt;select asp-for="WeekDaySelected" </pre>
			<pre class="source-code">          asp-items="Model.WeekDay"&gt;&lt;/select&gt;</pre>
			<pre class="source-code">        &lt;button type=Submit name="Submit"&gt;Submit&lt;/button&gt;</pre>
			<pre class="source-code">        &lt;br&gt;</pre>
			<pre class="source-code">        &lt;h3&gt;@ViewData["Message"]&lt;/h3&gt;</pre>
			<pre class="source-code">    &lt;/div&gt;</pre>
			<pre class="source-code">&lt;/form&gt;</pre>
			<p><a id="_idTextAnchor1263"/>The <code>PageModel</code> cl<a id="_idTextAnchor1264"/>ass is nothing more than a C# class that can have specific methods for <code>GET</code> and <code>POST</code> calls <a id="_idIndexMarker1010"/>so that data on the Razor page can be dynamically fetched, say, from an API. This class needs to be inherited by <code>Microsoft.AspNetCore.Mvc.RazorPages.PageModel</code> and is a standard C# class. <code>PageModel</code> for <code>index.cshtml</code>, which is part of <code>index.cshtml.cs</code>, is shown in the<a id="_idIndexMarker1011"/> following code:</p>
			<pre class="source-code">public class IndexModel : PageModel</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    public IndexModel(ILogger&lt;IndexModel&gt; logger)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public List&lt;SelectListItem&gt; WeekDay { get; set; }</pre>
			<pre class="source-code">    public void OnGet()</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        this.WeekDay = new List&lt;SelectListItem&gt;();</pre>
			<pre class="source-code">        this.WeekDay.Add(new SelectListItem</pre>
			<pre class="source-code">                              {</pre>
			<pre class="source-code">                                  Value = 'Monday',</pre>
			<pre class="source-code">                                  Text =  'Monday'</pre>
			<pre class="source-code">                              });</pre>
			<pre class="source-code">        this.WeekDay.Add(new SelectListItem</pre>
			<pre class="source-code">                              {</pre>
			<pre class="source-code">                                  Value = 'Tuesday',</pre>
			<pre class="source-code">                                  Text =  'Tuesday'</pre>
			<pre class="source-code">                              });                                  </pre>
			<pre class="source-code">                              </pre>
			<pre class="source-code">    <a id="_idTextAnchor1265"/>}</pre>
			<pre class="source-code">}    </pre>
			<p>Here, you can see t<a id="_idTextAnchor1266"/>hat we are populating additional data that was used on the Razor page via the <code>OnGet</code> method, which is also known as a <code>PageModel</code> handler and can be used for the initialization of the Razor page. Like <code>OnGet</code>, we can add an <code>OnPost</code> handler that <a id="_idIndexMarker1012"/>can be used to submit data back from the Razor page to <code>PageModel</code> and further the process.</p>
			<p>The <code>OnPost</code> method <a id="_idIndexMarker1013"/>will automatically bind all the properties in the <code>PageModel</code> class if they meet the following two conditions:</p>
			<ul>
				<li>The property is annotated with the <code>BindProperty</code> attribute.</li>
				<li>The Razor page has an HTML control with the same name as the property.</li>
			</ul>
			<p>So, for example, if we wanted to bind the value of the <code>select</code> control in the preceding code, we need to first add a property to the <code>PageModel</code> class, as shown in the following code:</p>
			<pre class="source-code">[BindProperty]</pre>
			<pre class="source-code">public string WeekDaySelected { get; set; }</pre>
			<p>Then, use the property name for the <code>select</code> control, as shown here, and Razor Pages will automatically bind the selected value to this property:</p>
			<pre class="source-code">&lt;select asp-for='WeekDaySelected' asp-items='Model.WeekDay'&gt;&lt;/select&gt;</pre>
			<p>We can use an asynchronous naming convention for the <code>OnGet</code> and <code>OnPost</code> methods so that they can be named as <code>OnGetAsync/OnPostAsync</code> if we are using asynchronous programming.</p>
			<p>Razor Pages also supports calling methods based on the verb. The patt<a id="_idTextAnchor1267"/>ern for the method name should follow the <code>OnPost[handler]/OnPost[handler]Async</code> convention, where <code>[handl<a id="_idTextAnchor1268"/>er]</code> is the value set on the <code>asp-page-handler</code> attribute of any tag helper.</p>
			<p>For example, the following code will call the <code>OnPostDelete/OnPostDeleteAsync</code> method from the corresponding <code>PageModel</code> class:</p>
			<pre class="source-code">&lt;input type='submit' asp-page-handler='Delete' val<a id="_idTextAnchor1269"/>ue='Delete' /&gt;s</pre>
			<p>For the services <a id="_idIndexMarker1014"/>configuration part, Razor Pages can be configured using the <code>AddRazorPages</code> method in the <code>Program</code> class by adding the service to the <a id="_idIndexMarker1015"/>ASP.NET Core <code>MapRazorPages</code> middleware needs to be injected for the Razor pages endpoint in the <code>Program</code> class, as shown in the <a id="_idIndexMarker1016"/>following code. This is done so that all the Razor pages can be requested using the name of the page:</p>
			<pre class="source-code">app.MapRa<a id="_idTextAnchor1270"/>zorPages();</pre>
			<p>This completes a simple Razor page application setup; we saw another sample in <a href="B18507_09_Epub.xhtml#_idTextAnchor860"><em class="italic">Chapter 9</em></a>, <em class="italic">Working with Data in .NET 6</em>, that used Razor Pages to retrieve data from a database <a id="_idIndexMarker1017"/>using <strong class="bold">Entity Framework Core</strong> (<strong class="bold">EF Core</strong>).</p>
			<p>Razor Pages is the easiest form of developing web applications in ASP.NET Core; however, for a more structured form of developing web applications that can handle complex features, we can go with ASP.NET Core MVC. Let's explore developing web apps using ASP.NET Co<a id="_idTextAnchor1271"/><a id="_idTextAnchor1272"/>re MVC in the next section.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor1273"/>Exploring the ASP.NET Core MVC website</h2>
			<p>As the <a id="_idIndexMarker1018"/>name suggests, ASP.NET Core MVC is <a id="_idIndexMarker1019"/>based on the MVC pattern discussed in <a href="B18507_10_Epub.xhtml#_idTextAnchor1040"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating an ASP.NET Core 6 Web API</em>, and is a<a id="_idTextAnchor1274"/> framework in ASP.NET Core to build web applications. We saw in <a href="B18507_10_Epub.xhtml#_idTextAnchor1040"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating an ASP.NET Core 6 Web API</em>, that the ASP.NET Core Web API also uses the MVC pattern; however, A<a id="_idTextAnchor1275"/>SP.NET Core MVC also supports views to display data. The underlying design pattern is the same, where we have a model to hold data, a controller to transfer the data, and views to render and display the data.</p>
			<p>ASP.NET Core MVC supports all the features that were discussed in <a href="B18507_10_Epub.xhtml#_idTextAnchor1040"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating an ASP.NET Core 6 Web API</em>, such as routing, DI, model binding, and model validation, and uses the same bootstrapping technique of using the <code>Program</code> class. Like the Web API, .NET 6 application services and middlewares are configured in the <code>Program</code> class.</p>
			<p>One of the key differences with MVC is the additional loading of views for which, instead of <code>AddControllers</code>, we need to use <code>AddControllersWithViews</code> in the <code>Program</code> class. An example is sh<a id="_idTextAnchor1276"/>own in the following figure:</p>
			<div><div><img src="img/Figure_11.3_B18507.jpg" alt="Figure 11.3 – MVC request life cycle&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – MVC request life cycle</p>
			<p><code>AddControllersWithViews</code> primarily takes care of loading the view<a id="_idTextAnchor1277"/>s and handling the data <a id="_idIndexMarker1020"/>sent by the controller, but <a id="_idIndexMarker1021"/>most importantly, it takes care of config<a id="_idTextAnchor1278"/>uring the Razor engine service that is used to process the Razor syntax in views and generate dynamic HTML.</p>
			<p>Controller actions in ASP.NET Core MVC need to be routed based on the action name passed in the URL, so on the routing part, instead of calling <code>MapController</code>, we configure <code>MapControllerRoute</code> and pass a pattern to it. So, the default routing configuration in the <code>UseEndpoints</code> middleware looks as in the following code snippet:</p>
			<pre class="source-code">app.UseEndpoints(endpoints =&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">endpoints.MapControllerRoute(</pre>
			<pre class="source-code">name: 'default',</pre>
			<pre class="source-code">pattern: '{controller=Products}/{action=Index}/{id?}');</pre>
			<pre class="source-code">});</pre>
			<p>Here, in the pattern, we are telling the middleware that the first part of the URL should be a <code>controller</code> name, followed by the action name and an optional <code>id</code> parameter. If nothing is passed in the URL, the default route is the <code>Index</code> action method of <code>ProductsController</code>. So, primarily, this is the convention-based routing we discussed in <a href="B18507_10_Epub.xhtml#_idTextAnchor1040"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating an ASP.NET Core 6 Web API</em>.</p>
			<p>Just like <a id="_idIndexMarker1022"/>Razor Pages, views in <a id="_idIndexMarker1023"/>ASP.NET Core MVC applications su<a id="_idTextAnchor1279"/>pport the Razor syntax and allow strongly typed views; that is, a view can be bound to a model for typ<a id="_idTextAnchor1280"/>e checking, and model properties can be associated with HTML controls with compile-time IntelliSense support.</p>
			<p>Since ASP.NET Core MVC gives more structure to the application, we will be using ASP.NET Core MVC for our presentation layer development, and it is discussed in detail while implementing the presentati<a id="_idTextAnchor1281"/>on layer in subsequent sections.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There is always a common question on which technology to choose for frontend development. The following link has some recommendations around this topic: <a href="https://docs.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/choose-between-traditional-web-and-single-page-apps">https://docs.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/choose-between-traditional-web-and-single-page-apps</a>. All the pros and cons should be evaluated before choosing the frontend technology as there are no one-size-<a id="_idTextAnchor1282"/>fits-all requirements.</p>
			<p>With this foundation, let's move on to the next section, where we will start integrating the backend APIs developed up until <a id="_idTextAnchor1283"/><a id="_idTextAnchor1284"/>now with our presentation layer.</p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor1285"/>Integrating APIs with the service layer</h1>
			<p>In this <a id="_idIndexMarker1024"/>section, we will be developing the <code>Packt.Ecommerce.Web</code> ASP.N<a id="_idTextAnchor1286"/>ET Core MVC application, which <a id="_idIndexMarker1025"/>is created by adding the <code>ASP.NET Core web application(Model-View-Contro<a id="_idTextAnchor1287"/>ller)</code> template. As we have already developed various APIs needed for the presentation layer, we will first build a wrapper class that will be used to communicate with these APIs.</p>
			<p>This is a single wrapper <a id="_idIndexMarker1026"/>class that will be used to communicate with various APIs, so let's create the contract for this class. For simplicity, we<a id="_idIndexMarker1027"/> will limit the requirements to the most important workflow in our e-commerce application, and that will be as follows:</p>
			<ul>
				<li>The landing page retrieves all products in the system and allows users to search/filter the products.</li>
				<li>View the details of the products, add them to the cart, and be able to add more products to the cart.</li>
				<li>Complete the order and see the invoice.</li>
			</ul>
			<p>To follow a more structured approach, we will segregate various classes and interfaces into separate folders. Let's see how in the following steps:</p>
			<ol>
				<li>To start with, let's add a <code>Contracts</code> folde<a id="_idTextAnchor1288"/>r to the <code>Packt.Ecommerce.Web</code> p<a id="_idTextAnchor1289"/>roject and add an interface with the name <code>IECommerceService</code>. This interface will have the following methods:<pre>// Method to retrieve all products and filter.
Task&lt;IEnumerable&lt;ProductListViewModel&gt;&gt; GetProductsAsync(string filterCriteria = null);
// Method to get details of specific product.
Task&lt;ProductDetailsViewModel&gt; GetProductByIdAsync(string productId, string productName);
// Method to create and order, this method is primarily used to create a cart which is nothing but an order with order status as 'Cart'.
Task&lt;OrderDetailsViewModel&gt; CreateOrUpdateOrder(OrderDetailsViewModel order);
// Method to retrieve order by ID, also used to retrieve cart/order before checkout.
Task&lt;OrderDetailsViewModel&gt; GetOrderByIdAsync(string orderId);
        Task&lt;InvoiceDetailsViewModel&gt; GetInvoiceByIdAsync(string invoiceId);
// Method to submit cart and create invoice.
Task&lt;InvoiceDetailsViewModel&gt; SubmitOrder(OrderDetailsViewModel order);
// Method to retrieve invoice details by Id.
Task&lt;InvoiceDetailsViewModel&gt; GetInvoiceByIdAsync(string invoiceId);</pre></li>
				<li>Now, let's<a id="_idIndexMarker1028"/> add a folder called <code>Services</code> and add a class called <code>EcommerceService</code>. This class will inherit <code>IECommerceService<a id="_idTextAnchor1290"/></code> and implement all the methods.</li>
				<li>As we <a id="_idIndexMarker1029"/>need to call various APIs, we need to make use of<a id="_idIndexMarker1030"/> the <code>Packt.Ecommerce.Common.Options.ApplicationSettings</code> using the <code>options</code> pattern.</li>
			</ol>
			<p>The <code>Program<a id="_idTextAnchor1291"/></code> class will have the following services configured for our MVC application:</p>
			<ul>
				<li><code>AddControllersWithViews</code>: This will inject the necessa<a id="_idTextAnchor1292"/>ry services for ASP.NET Core MVC to use controllers and views.</li>
				<li><code>ApplicationSettings</code>: This will configure the <code>ApplicationSettings</code> class using the <code>IOptions</code> pattern with the following code:<pre>builder.Services.Configure&lt;ApplicationSettings&gt;(this.Configuration.GetSection('ApplicationSettings'));</pre></li>
				<li><code>AddHttpClient</code>: This will inject <code>System.Net.Http.IHttpClientFactory</code> and related classes that will allow us to create an <code>HttpClient</code> object. Additionally, we will configure the retry policy and circuit break policy, as discussed in <a href="B18507_10_Epub.xhtml#_idTextAnchor1040"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating an ASP.NET Core 6 Web API</em>.</li>
				<li>Mapping <code>EcommerceService</code> to <code>IECommerceService</code> using the .NET Core DI container.</li>
			</ul>
			<ol>
				<li value="4">Configure <a id="_idIndexMarker1031"/>the app insights using the following <a id="_idIndexMarker1032"/>code:<pre>string appinsightsInstrumentationKey = this.Configuration.GetValue&lt;string&gt;('AppSettings:InstrumentationKey');
if (!string.IsNullOrWhiteSpace(appinsightsInstrumentationKey))
            {
                builder.Services.AddLogging(logging =&gt;
                {                                                       logging.AddApplicationInsights(
                  appinsightsInstrumentationKey);
                });                
                   builder.Services
                   .AddApplicationInsightsTelemetry 
                   (appinsightsIns<a id="_idTextAnchor1293"/>trumentationKey);
            }</pre></li>
			</ol>
			<p>Moving o<a id="_idTextAnchor1294"/>n to the middleware, we will be injecting the following middleware using the <code>Program</code> class, apart from the default routing middleware:</p>
			<ul>
				<li><code>UseStatusCodePagesWithReExecute</code>:<a id="_idTextAnchor1295"/> This middleware is used to redirect to a<a id="_idIndexMarker1033"/> custom page other than for the <code>500</code> error code. We will add a method in <code>ProductController</code> in the next section that will be executed and loads the relevant view based on the error code. This middleware takes a string as an input <a id="_idIndexMarker1034"/>parameter, which is nothing more than the route that should be executed in the case of an error, and to pass an error code, it allows a placeholder of <code>{0}</code>. So, the middleware configuration would look as follows:<pre>app.UseStatusCodePagesWithReExecute('/Products/Error/{0}');</pre></li>
				<li><strong class="bold">Error handling</strong>: As for<a id="_idIndexMarker1035"/> the presentation<a id="_idIndexMarker1036"/> la<a id="_idTextAnchor1296"/>yer, unlike with the API, we need to redirect users to a custom page that, in the case of runtime failures, has relevant information, such as a user-friendly failure message and a relevant logging ID that can be used to retrieve the actual failure at a later stage. However, in the case of a development environment, we can show the complete error along with the stack. So, we will configure two middlewares as shown in the following code:<pre>{
if (env.IsDevelopment())
    app.UseDeveloperExceptionPage();
}
else
{
    app.UseExceptionHandler('/Products/Error/500');
}</pre></li>
			</ul>
			<p>Here, we can see that for the development environment, we are using the <code>UseDeveloperExceptionPage</code> middleware, which will load the full exception stack trace, whereas, for non-development environments, we are using the <code>UseExceptionHandler</code> middleware, wh<a id="_idTextAnchor1297"/>ich takes the path of the error action method that needs to be executed. Additionally, here, we don't need our custom error handling middleware, as the ASP.NET Core middleware takes care of logging detailed errors to the logging provider, which is Application Insights in our case.</p>
			<ul>
				<li><code>UseStaticFiles</code>: To <a id="_idIndexMarker1037"/>allow various static f<a id="_idTextAnchor1298"/>iles, such as CSS, JavaScript, images, and any other static files, we don't need to go <a id="_idIndexMarker1038"/>through the entire request pipeline, and that is where this middleware comes into play, which allows serving static files and supports short-circuiting the rest of the pipeline for static files.</li>
			</ul>
			<p>Coming back to <a id="_idIndexMarker1039"/>the <code>EcommerceService</code> class, let's first define the local variables and the constructor of this class, which will inject the <code>HTTPClient</code> factory and <code>ApplicationSettings</code> using the following code:</p>
			<pre class="source-code">private readonly HttpClient httpClient;</pre>
			<pre class="source-code">private readonly ApplicationSettings applicationSettings;</pre>
			<pre class="source-code">public ECommerceService(IHttpClientFactory httpClientFactory, IOptions&lt;ApplicationSettings&gt; applicationSettings)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">NotNullValidator.ThrowIfNull(applicationSettings, nameof(applicationSettings));</pre>
			<pre class="source-code">IHttpClientFactory httpclientFactory = httpClientFactory;</pre>
			<pre class="source-code">this.httpClient = httpclientFactory.CreateClient();</pre>
			<pre class="source-code">this.applicationSettings <a id="_idTextAnchor1299"/>= applicationSettings.Value;</pre>
			<pre class="source-code">}</pre>
			<p>Now, to implement me<a id="_idTextAnchor1300"/>thods as per our <code>IECommerceService</code> interface, we will use the following steps for the Get APIs:</p>
			<div><div><img src="img/Figure_11.4_B18507.jpg" alt="Figure 11.4 – Get call to API&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4 – Get call to API</p>
			<p>Based on<a id="_idIndexMarker1040"/> the <a id="_idIndexMarker1041"/>steps in the preceding figure, the implementation of <code>GetProductsAsync</code>, which is primarily used to retrieve products for the landing page and apply any filters while doing a product search, will look as shown in the following code:</p>
			<pre class="source-code">public async Task&lt;IEnumerable&lt;ProductListViewModel&gt;&gt; GetProductsAsync(string filterCriteria = null)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    IEnumerable&lt;ProductListViewModel&gt; products = new List&lt;ProductListViewModel&gt;();</pre>
			<pre class="source-code">    using var productRequest = new </pre>
			<pre class="source-code">      HttpRequestMessage(HttpMethod.Get, </pre>
			<pre class="source-code">        $'{this.applicationSettings.ProductsApiEndpoint}</pre>
			<pre class="source-code">        ?filterCriteria={filterCriteria}');</pre>
			<pre class="source-code">    var productResponse = await this.httpClient.SendAsync(</pre>
			<pre class="source-code">      productRequest).ConfigureAwait(false);</pre>
			<pre class="source-code">    if (!productResponse.IsSuccessStatusCode)</pre>
			<pre class="source-code">    {        await this.ThrowServiceToServiceErrors(</pre>
			<pre class="source-code">               productResponse).ConfigureAwait(false);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    if (productResponse.StatusCode != </pre>
			<pre class="source-code">      System.Net.HttpStatusCode.NoContent)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        products = await productResponse.Content</pre>
			<pre class="source-code">          .ReadFromJsonAsync&lt;Ienumerable</pre>
			<pre class="source-code">           &lt;ProductListViewModel&gt;&gt;().Config<a id="_idTextAnchor1301"/>ureAwait(false);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    return products;</pre>
			<pre class="source-code">}</pre>
			<p><a id="_idTextAnchor1302"/>For the <code>POST</code>/<code>PUT</code> APIs, we<a id="_idIndexMarker1042"/> will have similar steps with slight <a id="_idIndexMarker1043"/>modifications, as shown in the following figure:</p>
			<div><div><img src="img/Figure_11.5_B18507.jpg" alt="Figure 11.5 – Post call to API&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.5 – Post call to API</p>
			<p>Based on <a id="_idIndexMarker1044"/>this, the st<a id="_idTextAnchor1303"/>rategy implementation of <code>CreateOrUpdateOrder</code>, which is primarily used to create the shopping cart, will look as shown in the<a id="_idIndexMarker1045"/> following code:</p>
			<pre class="source-code">public async Task&lt;OrderDetailsViewModel&gt; CreateOrUpdateOrder(OrderDetailsViewModel order)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    NotNullValidator.ThrowIfNull(order, nameof(order));</pre>
			<pre class="source-code">    using var orderRequest = new </pre>
			<pre class="source-code">      StringContent(JsonSerializer.Serialize(order), </pre>
			<pre class="source-code">      Encoding.UTF8, ContentType);</pre>
			<pre class="source-code">    var orderResponse = await this.httpClient.PostAsync(new </pre>
			<pre class="source-code">      Uri($'{this.applicationSettings.OrdersApiEndpoint}'), </pre>
			<pre class="source-code">      orderRequest).ConfigureAwait(false);</pre>
			<pre class="source-code">    if (!orderResponse.IsSuccessStatusCode)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        await this.ThrowServiceToServiceErrors(</pre>
			<pre class="source-code">          orderResponse).ConfigureAwait(false);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    var createdOrder = await orderResponse.Content</pre>
			<pre class="source-code">      .ReadFromJsonAsync&lt;OrderDetailsViewModel&gt;()</pre>
			<pre class="source-code">      .ConfigureAw<a id="_idTextAnchor1304"/>ait(false);</pre>
			<pre class="source-code">    return createdOrder;</pre>
			<pre class="source-code">}</pre>
			<p>Similarly, we<a id="_idIndexMarker1046"/> will implement <code>GetProductByIdAsync</code>, <code>GetOrder<a id="_idTextAnchor1305"/>ByIdAsync</code>, <code>GetInvoiceByIdAsync</code>, and <code>SubmitOrder</code> using <a id="_idIndexMarker1047"/>one of the preceding strategies and using the relevant API endpoints.</p>
			<p>Now, let's create the controllers and action methods that will<a id="_idTextAnchor1306"/><a id="_idTextAnchor1307"/> talk to <code>EcommerceService</code> and load the relevant views.</p>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor1308"/>Creating the controller and actions</h1>
			<p>We have already <a id="_idIndexMarker1048"/>seen that routing takes c<a id="_idTextAnchor1309"/>are of mapping the request URI to an action method in a control<a id="_idTextAnchor1310"/>ler, so let's further understand how the action methods then<a id="_idIndexMarker1049"/> load the respective views. As you will have noticed, all the views in the ASP.NET Core MVC project are part of the <code>Views</code> folder, and when the action method execution is completed, it simply looks for <code>Views/&lt;ControllerName&gt;/&lt;Action&gt;.cshtml</code>.</p>
			<p>For example, an action method mapping to the <code>Products/Index</code> route will load the <code>Views/Products/Index.cshtml</code> view. This is handled by calling the <code>Microsoft.AspNetCore.Mvc.Controller.View</code> method at the end of every action method.</p>
			<p>There are additional overloads and helpe<a id="_idTextAnchor1311"/>r methods that can override this behavior and route to a dif<a id="_idTextAnchor1312"/>ferent view as needed. Before we talk about these helper methods, just like the Web API, each action method in the MVC controller can also return <code>IActionResult</code>, which means we can make use of helper methods to redirect to a view. In ASP.NET Core MVC, every controller is inherited by a base class, <code>Microsoft.AspNetCore.Mvc.Controller</code>, which comes with a few helper methods, and loading <a id="_idIndexMarker1050"/>a view via an action method is handled by the following helper methods in<a id="_idIndexMarker1051"/> the <code>Microsoft.AspNetCore.Mvc.Controller</code> class:</p>
			<ul>
				<li><code>View</code>: This method has <a id="_idIndexMarker1052"/>multiple overloads and primarily loads the view from the folder under <code>Views</code> based on the controller name. For example, calling this method in <code>ProductsController</code> can load any <code>.cshtml</code> file from the <code>Views/Products</code> folder. Additionally, it can take the name of the view, which can be loaded if required, and supports passing an object that can be retrieved in views by strongly typing the view.</li>
				<li><code>RedirectToAction</code>: Although<a id="_idIndexMarker1053"/> the <code>View</code> method handles most scenarios, there would be scenarios where we need to call another action method within the same controller or another controller, which is where <code>RedirectToAction</code> helps. This method comes with various overloads and allows us to specify the name of the action method, controller method, and object that the action method can receive as route values.</li>
			</ul>
			<p>In short, to load the views and pass data from controllers, we will be passing respective models to the <code>View</code> method and, as required, we will use <code>RedirectToAction</code> whenever ther<a id="_idTextAnchor1313"/>e is a need to call another action method.</p>
			<p>Now, the ques<a id="_idTextAnchor1314"/>tion is how to handle data retrieval (<code>GET</code> calls) versus data submission (<code>POST</code> calls), and in ASP.NET Core MVC, all the action methods support annotating with HTTP verbs using the <code>HttpGet</code> and <code>HttpPost</code> attributes. The following are a few rules that can be used to annotate methods:</p>
			<ul>
				<li>If we want to retrieve data, then the action method is annotated using <code>HttpGet</code>.</li>
				<li>If we want to submit data to an action method, it should be annotated using <code>HttpPost</code> with the relevant object as the input parameter to that action method.</li>
			</ul>
			<p>Typically, methods that need to send data from a controller to a view should be annotated with <code>[HttpGet]</code>, and methods that need to receive data from a view for further submission to the database should be annotated using <code>[HttpPost]</code>.</p>
			<p>Now, let's move on to adding the required controllers and implementing them. When we add <code>Packt.Ecommerce.Web</code>, it creates a <code>Controllers</code> folder with <code>HomeController</code> created by default, which we need to delete. Then we need to add the three controllers by right-clicking on the <code>Controllers</code> folder, then selecting <code>ProductsController</code>, <code>CartController</code>, and <code>OrdersController</code>.</p>
			<p>All these <a id="_idIndexMarker1054"/>controllers <a id="_idIndexMarker1055"/>will have the following two common properties, one for logging and one for calling methods of <code>EcommerceService</code>. They are further initialized using constructor injection as follows:</p>
			<pre class="source-code">private readonly ILogger&lt;ProductsController&gt; logger;</pre>
			<pre class="source-code">private readonly IECommerceService eCommerceService;</pre>
			<p>Let's now discuss what is defined in each of these controllers:</p>
			<ul>
				<li><code>ProductsController</code>: This controller will contain the <code>public async Task&lt;IActionResult&gt; Index(string searchString, string category)</code> action method to load the default view for listing all the products, which further supports filtering. There will be another method, <code>public async Task&lt;IActionResult&gt; De<a id="_idTextAnchor1315"/>tails(string productId, string productName)</code>, that<a id="_idTextAnchor1316"/> takes the ID and name of the product and loads the details of the specified product. As both these methods are used for retrieving, they will be annotated using <code>[HttpGet]</code>. Additionally, this controller will have the <code>Error</code> method, as discussed earlier. Since it can receive an error code as an input parameter from the <code>UseStatusCodePagesWithReExecute</code> middleware, we will have simple logic to load the views accordingly:<pre>[Route('/Products/Error/{code:int}')]
public IActionResult Error(int code)
{
    if (code == 404)
    {
        return 
          this.View('~/Views/Shared/NotFound.cshtml');
    }
    else
    {
        return 
         this.View('~/Views/Shared/Error.cshtml', new 
         ErrorViewModel { CorrelationId = 
         Activity.Current?.RootId ?? 
         this.HttpContext.TraceIdentifier });
    }
}</pre></li>
				<li><code>CartController</code>: This controller contains the <code>public async Task&lt;IActionResult&gt; Index(ProductListViewModel product)</code> action method to add a product to the cart, where we will create an order with the <a id="_idIndexMarker1056"/>order status set to <code>'Cart'</code>, as this needs to receive <a id="_idIndexMarker1057"/>data and further pass it to the API, which will be annotated with <code>[HttpPost]</code>. For simplicity, this is left anonymous but can be restricted for the logged-in users. Once the order is created, thi<a id="_idTextAnchor1317"/>s method will make use of the <code>RedirectToAction</code> helper method and redirects to the <code>public async Task&lt;IActionResult&gt; I<a id="_idTextAnchor1318"/>ndex(string orderId)</code> action method within this controller, which further loads the cart with all the products and the checkout form. This method can also be used to directly navigate to the shopping cart.</li>
				<li><code>OrdersController</code>: This is the last controller in the flow, which contains the <code>public async Task&lt;IActionResult&gt; Create(OrderDetailsViewModel order)</code> action method to submit the order after filling in the payment details. This method updates the status of the order to <code>Submitted</code>, then creates an invoice for the order, and finally, redirects to another action method, <code>public async Task&lt;IActionResult&gt; Index(string invoiceId)</code>, which loads the final invoice of <a id="_idIndexMarker1058"/>the <a id="_idIndexMarker1059"/>order and completes the transaction.</li>
			</ul>
			<p>The following diagram represents the flow between vari<a id="_idTextAnchor1319"/>ous methods across controllers to complete the shopping workflow:<a id="_idTextAnchor1320"/></p>
			<div><div><img src="img/Figure_11.6_B18507.jpg" alt="Figure 11.6 – Flow between controller action methods&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.6 – <a id="_idTextAnchor1321"/>Flow between controller action methods<a id="_idTextAnchor1322"/><a id="_idTextAnchor1323"/></p>
			<p>With this knowledge, let's design the views in the next section.</p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor1324"/>Creating a UI using ASP.NET Core MVC</h1>
			<p>Up until now, we <a id="_idIndexMarker1060"/>have defi<a id="_idTextAnchor1325"/>ned a <a id="_idIndexMarker1061"/>service to communicate w<a id="_idTextAnchor1326"/>ith backend APIs and further defined controllers that will pass the data to views using models. Now, let's build various views that will render the data and present it to users.</p>
			<p>To begin <a id="_idIndexMarker1062"/>with, let's see the various components<a id="_idIndexMarker1063"/> that are involved in rendering the views:</p>
			<ul>
				<li>The <code>Views</code> folder: All views are part of this folder, with each controller-specific view segregated by a subfolder, and finally, each action method is represented by a <code>.cshtml</code> file.</li>
			</ul>
			<p>To add a view, we can right-click on the action method and click <strong class="bold">Add View</strong>, which will automatically create a folder (if it isn't already present) with the name of the controller and add the view. Additionally, while doing this, we can specify the model that the view would be bound to.</p>
			<ul>
				<li>The <code>Layout</code> pa<a id="_idTextAnchor1327"/>ge: This is a c<a id="_idTextAnchor1328"/>ommon requirement in a web application where we have a common section across the application, such as a header with a menu or left navigation. To have a modular structure for our pages and to avoid any repetition, ASP.Net Core MVC comes with a layout page that is typically named <code>_Layout.cshtml</code> and is part of the <code>Views/Shared</code> folder. This page can be used as a parent page for all the views in our MVC project. A typical layout page looks like the one shown in the following code:<pre>&lt;!DOCTYPE html&gt;
&lt;html lang='en'&gt;
&lt;head&gt;
    &lt;meta charset='utf-8'&gt;
    &lt;meta name='viewport' content='width=device-width, 
     initial-scale=1'&gt;
    &lt;meta http-equiv='x-ua-compatible' 
     content='ie=edge'&gt;
    &lt;title&gt;Ecommerce Packt&lt;/title&gt;
&lt;/head&gt;
&lt;body class='hold-transition sidebar-mini layout-top-nav'&gt;    
        &lt;!-- Navbar --&gt;        
        &lt;!-- Main content --&gt;        
         @RenderBody()
&lt;/body&gt;
&lt;/html&gt;</pre></li>
			</ul>
			<p>Here, you<a id="_idIndexMarker1064"/> can see that it allows <a id="_idIndexMarker1065"/>us to define the skeleton layout of the application, and then finally, there is a Razor method called <code>@RenderBody()</code>, which actually loads the child view. To specify a layout page in any view, we can use the following syntax, which adds <code>_Layout.cshtml</code> as a parent page to the v<a id="_idTextAnchor1329"/>iew:</p>
			<pre>@{
    Layout = '~/Views/Shared/__Layout.cshtml';
}</pre>
			<p>However, there is no need to repeat this code in all the views, and that's where <code>_ViewStart.cshtml</code> comes in handy. Let's see how it helps in reusing some of the code across views:</p>
			<ul>
				<li><code>_ViewStart.cshtml</code>: This is a generic view that is located directly under the <code>Views</code> folder and is used by the Razor engine to execute any code that needs to be executed before the code in the view. So, typically, this is used to define the layout page and so, the preceding code can be added to this file so that it gets applied across the application.</li>
				<li><code>_ViewImports.cshtml</code>: This is another page that can be used to import any common directives or namespaces across the application. Just like <code>_ViewStart</code>, this is also located directly under the root folder; however, both <code>_ViewStart</code> and <code>_ViewImport</code> can be in one (or more than one) folder and they are executed hierarchically starting from the one in the root views folder to the lower-level one in any subfolders. To enable client-side telemetry using Application Insights, we inject <code>JavaScriptSnippet</code> as shown in the following code. We learned about injecting dependent services into views in <a href="B18507_05_Epub.xhtml#_idTextAnchor445"><em class="italic">Chapter 5</em></a>, <em class="italic">Dependency Injection in .NET 6</em>. In the following code, <code>JavaScriptSnippet</code> is injected into the view:<pre>    @inject Microsoft.ApplicationInsights.AspNetCore.JavaScriptSnippet JavaScriptSnippet</pre></li>
				<li><code>wwwroot</code>: This<a id="_idIndexMarker1066"/> is the root folder of the application, and all the static resources, such as JavaScript, CSS, and any image files, are placed here. This can<a id="_idIndexMarker1067"/> further hold an<a id="_idTextAnchor1330"/>y HTML plugins that we want to use in our application. As we have already configured the <code>Use<a id="_idTextAnchor1331"/>StaticFiles</code> middleware in our application, content from the folder can be directly served without any processing. The default template of ASP.NET Core MVC comes with a segregation of folders based on their type; for example, all JavaScript files are placed inside a <code>js</code> folder, CSS files are placed in a <code>css</code> folder, and so on. We will stick to that folder structure for our application.<p class="callout-heading">Note</p><p class="callout">The process of automa<a id="_idTextAnchor1332"/>tically generating views by right-clicking on the action method and using built-in templates is<a id="_idIndexMarker1068"/> known as <strong class="bold">scaffolding</strong> and can be used if are you new to the Razor syntax. However, creating a view using scaffolding or manually placing it inside <a id="_idTextAnchor1333"/><a id="_idTextAnchor1334"/>the respective folder and strongly typing it results in the same behavior.</p></li>
			</ul>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor1335"/>Setting up AdminLTE, the layout page, and views</h2>
			<p>An important<a id="_idIndexMarker1069"/> thing for <a id="_idTextAnchor1336"/>getting the same look and feel across an application is to choose<a id="_idTextAnchor1337"/> the right styling framework. Doing that not only<a id="_idTextAnchor1338"/> gives a consistent layout but also simplifies the responsive design, which helps in rendering the pages correctly in various resolutions. The ASP.NET Core MVC project template that we are using for <code>Packt.Ecommerce.Web</code> comes out of the box with Bootstrap as its styling framework. We will further extend this to a theme known as <code>AdminLTE</code>, which comes with some interesting layouts <a id="_idIndexMarker1070"/>and dashboards that can be plugged into our presentation layer.</p>
			<p>Let's perform <a id="_idIndexMarker1071"/>the following steps to integrate <code>AdminLTE</code> into our application:</p>
			<ol>
				<li value="1">Download the most recent version of <code>AdminLTE</code> from here: <a href="https://github.com/ColorlibHQ/AdminLTE/releases">https://github.com/ColorlibHQ/AdminLTE/releases</a>.</li>
				<li>Extract the ZIP file downloaded in the previous step and navigate to <code>AdminLTE-3.0.5\dist\css</code>. Copy <code>adminlte.min.css</code> and paste it inside the <code>wwwroot/css</code> folder of <code>Packt.Ecommerce.Web</code>.</li>
				<li>Navigate to <code>AdminLTE-3.0.5\dist\js</code>. Copy <code>adminlte.min.js</code> and paste it inside the <code>wwwroot/js</code> folder of <code>Packt.Ecommerce.Web</code>.</li>
				<li>Navigate to <code>AdminLTE-3.0.5\dist\img</code>. Copy the required images and paste them inside the <code>wwwroot/img</code> folder of <code>Packt.Ecommerce.Web</code>.</li>
				<li>Copy the <code>AdminLTE-3.0.5\plugins</code> folder and paste it inside t<a id="_idTextAnchor1339"/>he <code>wwwroot</code> folder of <code>Packt.Ecommerce.Web</code>.</li>
			</ol>
			<p>More information <a id="_idIndexMarker1072"/>about <code>Adm<a id="_idTextAnchor1340"/>inLTE</code> can be found at <a href="https://adminlte.io/docs/2.4/installation">https://adminlte.io/docs/2.4/installation</a>.</p>
			<p>Now, navigate<a id="_idIndexMarker1073"/> to the <code>Views/_Layout.cshtml</code> page and remove all the existing code and replace it with the code from <code>Packt.Ecommerce.Web\Views\Shared\_Layout.cshtml</code>. On a high level, the layout is divided into the following:</p>
			<ul>
				<li>A header with navigation to the home page on the left side</li>
				<li>A search box in the header and a dropdown with search categories in the center</li>
				<li>The shopping cart in the header on the right side</li>
				<li>A breadcrumb trail to display the navigation</li>
				<li>A section to render the child view using <code>@RenderBody()</code></li>
			</ul>
			<p>A couple of other<a id="_idIndexMarker1074"/> key things that are needed to complete the integration of the <code>AdminLTE</code> template are as follows:</p>
			<ul>
				<li>Add the following styles defined in the <code>&lt;head&gt;</code> tag:<pre>&lt;link rel='stylesheet' href='~/plugins/fontawesome-free/css/all.min.css'&gt;
&lt;link rel='stylesheet' href='~/css/adminlte.min.css'&gt;</pre></li>
				<li>Add the following JavaScript files just before the end of the <code>&lt;body&gt;</code> tag:<pre>&lt;!-- REQUIRED SCRIPTS (Order shouldn't matter)--&gt;
&lt;!-- jQuery --&gt;
&lt;script src='~/plugins/jquery/jquery.min.js'&gt;&lt;/script&gt;
&lt;!-- Bootstrap 4 --&gt;
&lt;script src='~/plugins/bootstrap/js/bootstrap.bundle.min.js'&gt;&lt;/script&gt;
<a id="_idTextAnchor1343"/>&lt;!-- AdminLTE App --&gt;
&lt;script src='~/js/adminlte.min.js'&gt;&lt;/script&gt;</pre></li>
			</ul>
			<p>With this, we h<a id="_idTextAnchor1344"/>ave the <code>AdminLTE</code> theme integrated into our application. To<a id="_idTextAnchor1345"/> render the JavaScript required to enable the client telemetry using Application Insights, add the following code inside the <code>head</code> tag of <code>_Layout.cshtml</code>:</p>
			<pre class="source-code">    @Html.Raw(JavaScriptSnippet.FullScript)</pre>
			<p>The previous code injects the JavaScript required to send telemetry data from views along with the instrumentation key. Unlike the server side or the client side, the instrumentation key is exposed. Anyone can see the instrumentation key from the browser developer tools. But, this is how client-side telemetry is set up. At this point, the risk of this is that unwanted data can be pushed by a malicious user or attacker as the instrumentation key has write-only access. If you wish to make the client-side telemetry more <a id="_idIndexMarker1075"/>secure, you can expose a secure REST API from your service and log the telemetry events from there. You will learn more about Application Insights features in <a href="B18507_14_Epub.xhtml#_idTextAnchor1674"><em class="italic">Chapter 14</em></a>, <em class="italic">Health and Diagnostics</em>.</p>
			<p>Now, the application layout is ready. Let's now move on to defining various views in the application.</p>
			<h3>Creating the Products/Index view</h3>
			<p>This <a id="_idIndexMarker1076"/>view will be used to list all the <a id="_idIndexMarker1077"/>products available on our e-commerce application and is strongly typed with the <code>IEnumerable&lt;Packt.Ecommerce.DTO.Models.ProductListViewModel&gt;</code> model. It uses th<a id="_idTextAnchor1346"/>e <code>Index</code> action method of <code>ProductsController</code> to retrieve data.</p>
			<p>In this view, we will use a simple Razor <code>@foreach (var item in Model)</code> loop and for each product, we will display an image of the product, its name<a id="_idTextAnchor1347"/>, and its price. A sample of this view looks as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_11.7_B18507.jpg" alt="Figure 11.7 – Products view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.7 – Products view</p>
			<p>Here, you can see that there is a search bar and a category dropdown coming from the layout page. Clicking<a id="_idIndexMarker1078"/> on the <a id="_idIndexMarker1079"/>product image will navigate to the <code>Products/Details</code> view. To support this navigation, we will make use of <code>AnchorTagHelper</code> and pass the product ID and name to the <code>Details</code> action method of <code>ProductsController</code> to further load the details of th<a id="_idTextAnchor1348"/>e product in the <code>Products/Details</code> view.</p>
			<h3>Creating the Products/Details view</h3>
			<p>This <a id="_idIndexMarker1080"/>view will load the details of the <a id="_idIndexMarker1081"/>product based on the product ID and the name passed from the <code>Products/Index</code> view. We will be using a sample page from <code>AdminLTE</code> as shown here: <a href="https://adminlte.io/themes/dev/AdminLTE/pages/examples/e_commerce.html">https://adminlte.io/themes/dev/AdminLTE/pages/examples/e_commerce.html</a>.</p>
			<p>This page will be strongly typed with <code>Packt.Ecommerce.DTO.Models.ProductDetailsViewModel</code> and will display all th<a id="_idTextAnchor1349"/>e details of the product. A sample of this page is shown in the following screenshot:</p>
			<div><div><img src="img/Figure_11.8_B18507.jpg" alt="Figure 11.8 – Product details view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.8 – Product details view</p>
			<p>As you can see, <a id="_idTextAnchor1350"/>there<a id="_idIndexMarker1082"/> is an <code>'Cart'</code>, this will call the <code>Index</code> action method of <code>CartController</code> to create the cart.</p>
			<p>To pass data <a id="_idIndexMarker1083"/>back to the action method, we will take the help of <code>FormTagHelper</code>, which allows us to wrap the page in an HTML form and specify the action and controller that the page can be submitted to using the following code:</p>
			<pre class="source-code">&lt;form asp-action='Index' asp-controller='Cart'&gt;</pre>
			<p>With this code, once the <code>Submit</code> type, the page gets submitted to the <code>Index</code> action method of <code>CartController</code> to further save it to the database. However, we still need to pass the product details back to the <code>Index</code> action method and, for that, we will take the help of <code>InputTagHelper</code> and create hidden fields for all the values that need to be passed back to the action method.</p>
			<p>The most important thing here is that the name of the hidden variable should match the name of the <a id="_idIndexMarker1084"/>property in the model, so we will be adding the following code inside the form to pass the<a id="_idIndexMarker1085"/> product values back to the controller:</p>
			<pre class="source-code">&lt;input asp-for='Id' type='hidden'&gt;</pre>
			<pre class="source-code">&lt;input asp-for='Name' type='hidden'&gt;</pre>
			<pre class="source-code">&lt;<a id="_idTextAnchor1351"/>input asp-for='Price' type='hidden'&gt;</pre>
			<pre class="source-code">&lt;input asp-for='ImageUrls[0]' type='hidden'&gt;</pre>
			<p>ASP.NET Core MVC's model binding system reads these values and creates the product object needed for the <code>Index</code> method of <code>CartController</code>, which further calls the backend system to create the order.</p>
			<h3>Creating the Cart/Index view</h3>
			<p>This view<a id="_idIndexMarker1086"/> will<a id="_idIndexMarker1087"/> <a id="_idTextAnchor1352"/>load the cart details and will have a checkout form to fill in all the details and complete the order. Here, we can navigate back to the home page to add more products or complete the order.</p>
			<p>This view is strongly typed <a id="_idTextAnchor1353"/>with <code>Packt.Ecommerce.DTO.Models.OrderDetailsViewModel</code> and loads data using the <code>Index</code> action method of <code>OrdersController</code>. Here, we are using the Bootstrap checkout form example from <a href="https://getbootstrap.com/docs/4.5/examples/checkout/">https://getbootstrap.com/docs/4.5/examples/checkout/</a>.</p>
			<p>This form makes<a id="_idIndexMarker1088"/> use of model validations and HTML attributes to perform validation on the required fields, and we are taking the help of ASP.NET Core MVC tag helpers and a few HTML helpers to render the form. A sample property with model validations would be as shown in the following code:</p>
			<pre class="source-code">public class AddressViewModel</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">        [Required(ErrorMessage = 'Address is required')]</pre>
			<pre class="source-code">        public string Address1 { get; set; }      </pre>
			<pre class="source-code">        [Required(ErrorMessage = 'City is required')]</pre>
			<pre class="source-code">        public string City { get; set; }</pre>
			<pre class="source-code">        [Required(ErrorMessage = 'Country is required')]</pre>
			<pre class="source-code">        public string Country { get; set; }</pre>
			<pre class="source-code">}</pre>
			<p>This model is used in <a href="https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/data/Packt.Ecommerce.DTO.Models/OrderDetailsViewModel.cs">https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/data/Packt.Ecommerce.DTO.Models/OrderDetailsViewModel.cs</a> and triggers necessary <a id="_idIndexMarker1089"/>validations while placing an order.</p>
			<p>As this form also needs to be submitted, the entire form is wrapped in <code>FormTagHelper</code>, as shown in the following code:</p>
			<pre class="source-code">&lt;form asp-action='Create' asp-controller='Orders'&gt;</pre>
			<p>To show these validations on the UI, add the following scripts to <code>_layout.cshtml</code> just after all the other scripts we added earlier:</p>
			<pre class="source-code">&lt;script src='~/lib/jquery-validation/dist/jquery.validate.min.js'&gt;&lt;/script&gt;</pre>
			<pre class="source-code">&lt;script src='~/lib/jquery-validation-unobtrusive/jquery.validate.unobtrusive.min.js'&gt;&lt;/script&gt;</pre>
			<p>To display an<a id="_idIndexMarker1090"/> error message, we can make use of a validation message tag helper, as shown in the following code snippet. On the server side, this can be further evaluated using <code>ModelState.IsValid</code>:</p>
			<pre class="source-code">&lt;input asp-for='ShippingAddress.Address1' class='form-control' placeholder='1234 Main St'/&gt;</pre>
			<pre class="source-code">&lt;span asp-validation-for='ShippingAddress.Address1' cla<a id="_idTextAnchor1355"/>ss='text-danger'&gt;&lt;/span&gt;</pre>
			<p>A sample of this page would be as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_11.9_B18507.jpg" alt="Figure 11.9 – Cart and checkout page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.9 – Cart and checkout page</p>
			<p>We will use <code>InputTagHelper</code> as hidden fields and textboxes to pass any additional in<a id="_idTextAnchor1356"/>formation<a id="_idIndexMarker1091"/> back to the action method. The good thing about textboxes is if the <code>id</code> attribute of the <a id="_idIndexMarker1092"/>textbox matches the property name, that data is automatically passed back to the action method and ASP.NET Core MVC's model binding system will take care of mapping it to the required object, which, in this case, is of the <code>Packt.Ecommerce.DTO.Models.OrderDetailsViewModel</code> type, which finally submits the order, generates invoices, and redirects to the <code>Orders/Index</code> action method.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In the preceding screenshot, although we have a checkout form that includes payment information in production applications, we would be integrating with a third-party payment gateway and, usually, this entire form sits on t<a href="https://razorpay.com/docs/payment-gateway/server-integration/dot-net/">he payment gateway side of the application for various security reas</a>ons. <a href="https://stripe.com/docs/api">https://stripe.com/docs/api</a> and <a href="https://razorpay.com/docs/payment-gateway/server-integration/dot-net/">https://razorpay.com/docs/payment-gateway/server-integration/dot-net/</a> are a couple of such third-party providers that help in payment gateway integration.</p>
			<h3>Creating the Orders/Index view</h3>
			<p>Final<a id="_idTextAnchor1357"/>ly, we <a id="_idIndexMarker1094"/>will have the view to <a id="_idIndexMarker1095"/>see the invoice of the order, which is a simple read-only view that displays invoice information sent from the <code>Ind<a id="_idTextAnchor1358"/>ex</code> action method of <code>OrdersController</code>. A sample of this page is shown in the following screenshot:</p>
			<div><div><img src="img/Figure_11.10_B18507.jpg" alt="Figure 11.10 – Final invoice&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.10 – Final invoice</p>
			<p>This completes the integration of various views and, as you have seen, we have limited the views to the most important flow in <a id="_idTextAnchor1359"/><a id="_idTextAnchor1360"/>the e-commerce application. However, you can further add more features using the same principles.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor1361"/>Understanding Blazor</h1>
			<p>B<a id="_idTextAnchor1362"/>lazor is a<a id="_idIndexMarker1096"/> new framework available from .NET Core 3.1 onward to develop the frontend layer of the application. It's one of the alternatives to MVC and Razor Pages and the application model is very much close to SPA; however, instead of JavaScript, we can write the logic in C# and Razor syntax.</p>
			<p>All the code that is written in Blazor is placed in something called a <code>.Razor</code> and is used to represent the application; be it the entire web page or a small dialog popup, everything is created as a component in Blazor applications. A <a id="_idIndexMarker1098"/>typical Razor component looks like the one in the following code snippet:</p>
			<pre class="source-code">@page '/counter'</pre>
			<pre class="source-code">&lt;h1&gt;Counter&lt;/h1&gt;</pre>
			<pre class="source-code">&lt;p&gt;Current count: @currentCount&lt;/p&gt;</pre>
			<pre class="source-code">&lt;button class='btn btn-primary' @onclick='IncrementCount'&gt;Click me&lt;/button&gt;</pre>
			<pre class="source-code">@code {</pre>
			<pre class="source-code">    private int currentCount = 0;</pre>
			<pre class="source-code">    private void IncrementCount()</pre>
			<pre class="source-code">    {        currentCount++;    }</pre>
			<pre class="source-code">}</pre>
			<p>In this code, we are creating a page that increments a counter on the click of a button, and the logic for the click event is handled in the C# code, which update<a id="_idTextAnchor1363"/>s the value in HTML. This page can be accessed using the <code>/counter</code> relative URL.</p>
			<p>The major difference between Blazor and other MVC/Razor Pages is that unlike the request-response model, where every request is sent to the server and HTML is sent back to the browser, Blazor packages all the components (just like SPA) and loads them on the client-side. When the application is requested for the first time, any subsequent calls to the server are to retrieve/submit any API data or to update the DOM. Blazor supports the follow<a id="_idTextAnchor1364"/>ing two hosting models:</p>
			<ul>
				<li><strong class="bold">Blazor WebAssembly</strong> (<strong class="bold">WASM</strong>): WASM <a id="_idIndexMarker1099"/>is low-level instructions that can be run on <a id="_idIndexMarker1100"/>modern browsers, which further helps to run code written in high-level languages such as C# on a browser without any additional plugins. The Blazor WASM hosting model makes use of the open web standards given by WASM and runs the C# code of any Blazor WASM application in a sandbox environment on a browser. At a high level, all the Blazor components are compiled into .NET assemblies and are downloaded to the browser, and WASM loads the .NET Core runtime and loads all the assemblies. It further uses JavaScript interop to refresh the DOM; the o<a id="_idTextAnchor1365"/>nly calls to the <a id="_idIndexMarker1101"/>server would be any backend APIs. The architecture is shown in the following figure:</li>
			</ul>
			<div><div><img src="img/Figure_11.11_B18507.jpg" alt="Figure 11.11 – Blazor WASM hosting&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.11 – Blaz<a id="_idTextAnchor1366"/>or WASM hosting</p>
			<ul>
				<li><code>blazor.server.js</code> and uses SignalR to receive all the DOM updates, and this further means that every user interac<a id="_idTextAnchor1367"/>tion will have a server call (although very light). The architecture is shown in the following figure:</li>
			</ul>
			<div><div><img src="img/Figure_11.12_B18507.jpg" alt="Figure 11.12 – Blazor Server hosting&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.12 – Blazor Server hosting</p>
			<p>.NET 6 comes with<a id="_idIndexMarker1103"/> full tooling support for both hosting models, with their own project templates, and has its pros and cons, which are further explained <a id="_idTextAnchor1368"/>here: <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-6.0</a>.</p>
			<p>Let's now create a <a id="_idIndexMarker1104"/>frontend application as per the following steps using a Blazor Server application, which allows us to add/modify product details for our e-commerce application:</p>
			<ol>
				<li value="1">Add a new Blazor Server application called <code>Packt.Ecommerce.Blazorweb</code> to the enterprise solution and add the <code>Products.razor</code>, <code>AddProduct.Razor</code>, and <code>EditProduct.razor</code> Razor components to the <code>Pages</code> folder.</li>
				<li>This project contains the <code>Program</code> class, which is exactly like any other ASP.NET Core application with a few additional Blazor <a id="_idTextAnchor1369"/>services. <code>_Host.cshtml</code> is the root of the application and an initial call to the application is received by this page and is responded to with HTML. This page further references the <code>blazor.server.js</code> script file for the SignalR connection. Another important component is the <code>App.Razor</code> component, which takes care of routing based on the URL. In Blazor, any component that needs to be mapped to a specific URL will have the <code>@page</code> directive at the beginning of the component, which specifies the relative URL of the application. <code>App.Razor</code> intercepts the URLs and routes them to the specified component. All Razor components are part of a <code>Pages</code> folder, and the <code>Data</code> folder comes with a sample model and a service that is used in the <code>FetchData.razor</code> component.</li>
				<li>Let's add <a id="_idIndexMarker1105"/>the following code to <code>NavMenu.razor</code> to add the <code>Products</code> navigation to the left menu. At this stage, if you run the application, you should be able to see the left menu with the <code>Products</code> navigation; however, it will not navigate to any page:<pre>&lt;li class='nav-item px-3'&gt;
&lt;NavLink class='nav-link' href='prod<a id="_idTextAnchor1370"/>ucts'&gt;
  &lt;span class='oi oi-list-rich' aria-
   hidden='true'&gt;&lt;/span&gt; Products
&lt;/NavLink&gt;
&lt;/li&gt;</pre></li>
				<li>As we are going to retrieve data from the API, we need to inject <code>HTTPClient</code> into our <code>Program</code> class, just as how it's done in ASP.NET Core applications. So, add the following code to the <code>Program</code> class:<pre>builder.Services.AddHttpClient("Products", client =&gt;
{
    client.BaseAddress = new Uri(builder.Configuration["ApplicationSettings:ProductsApiEndpoint"]);
});</pre></li>
				<li>Add the following setting of <code>ApplicationSettings:ProductsApiEndpoint</code> to <code>appsettings.json</code>:<pre>'ApplicationSettings': {
    'ProductsApiEndpoint': 
    'https://localhost:7256/api/products/'
  },</pre></li>
				<li>Since we are going to bind the <code>products</code> data, let's add <code>Packt.Ecommerce.DTO.Models</code> as a project reference to <code>Packt.Ecommerce.Blazorweb</code>. In the <code>Pages</code> folder, add the following code to the <code>Products.razor</code> page inside the <code>@code</code> block in which we are creating a <code>HttpClient</code> object using <code>IHttpClientFactory</code>, which will be injected<a id="_idIndexMarker1106"/> in the next step, and retrieving the <code>products</code> data in the <code>OnInitializedAsync</code> method:<pre>private List&lt;ProductListViewModel&gt; products;
protected override async Task OnInitializedAsync()
    {
        var client = Factory.CreateClient('Products');
        var result = await 
          client.GetAsync('').ConfigureAwait(false);
        result.EnsureSuccessStatusCode();
        products = new List&lt;ProductListViewModel&gt;();
        products = await 
          result.Content.ReadFr<a id="_idTextAnchor1371"/>omJsonAsync
          &lt;List&lt;ProductListViewModel&gt;&gt;()
          .ConfigureAwait(false);
    }</pre></li>
				<li>Next, add the following code at the beginning of the <code>Products.Razor</code> page (outside the <code>@code</code> block). Here, we set the relative route for this component via the <code>@page</code> directive to <code>/products</code>. Next, we inject <code>IHttpClientFactory</code> and the other required namespaces, then add the HTML part<a id="_idIndexMarker1107"/> that renders the list of products. As you can see, it's a mixture of HTML and Razor syntax:<pre>@page '/products'
@inject IHttpClientFactory Factory
@using System.Net.Http.Json;@using Packt.Ecommerce.DTO.Models;
&lt;h1&gt;Products&lt;/h1&gt;
&lt;div&gt;    &lt;a class='btn btn-info' href='addproduct'&gt;&lt;i class='oi oi-plus'&gt;&lt;/i&gt; Add Product&lt;/a&gt; &lt;/div&gt;
@if (products == null)
{ &lt;p&gt;&lt;em&gt;Loading...&lt;/em&gt;&lt;/p&gt; }
else { &lt;table class='table'&gt;&lt;thead&gt;&lt;tr&gt;
                &lt;th&gt;Id&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;
                &lt;th&gt;Price&lt;/th&gt;&lt;th&gt;Quantity&lt;/th&gt;
                &lt;th&gt;ImageUrls&lt;/th&gt;&lt;th&gt;&lt;/th&gt;
            &lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;
            @foreach (var product in products)
            {&lt;tr&gt;
                   &lt;td&gt;@product.Id&lt;/td&gt;
                    &lt;td&gt;@product.Name&lt;/td&gt;
                    &lt;td&gt;@product.Price&lt;/td&gt;
                    &lt;td&gt;@product.Quantity&lt;/td&gt;
                    &lt;td&gt;&lt;img 
                         src='@product.ImageUrls[0]' 
                         class='product-image w-10 
                         col-3' alt='Product' /&gt;&lt;/td&gt;
                    &lt;td&gt;&lt;a class='btn btn-info' 
                          href='editproduct/
                          @product.Id/@product.Name'&gt;
                          &lt;i class='oi oi-pencil'&gt;
<a id="_idTextAnchor1372"/>                          &lt;/i&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
            }
        &lt;/tbody&gt;&lt;/table&gt;<a id="_idTextAnchor1373"/> }</pre></li>
			</ol>
			<p>At this <a id="_idIndexMarker1108"/>point, if you run the application, you should see the output shown in the following screenshot:</p>
			<div><div><img src="img/Figure_11.13_B18507.jpg" alt="Figure 11.13 – Product list Blazor UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.13 – Product list Blazor UI</p>
			<ol>
				<li value="8">Next, let's create the <code>Add/Edit</code> pages in which we will make use of Blazor forms. Some of the important tooling/components that are available for forms are the following.</li>
			</ol>
			<p>A Blazor form is created using an out-of-the-box template in Blazor known as <code>EditForm</code>, and it can be bound directly to any C# object using a model property. A typical <code>EditForm</code> looks as in the following code snippet. Here, we are <a id="_idIndexMarker1109"/>defining to call the <code>OnSubmit</code> method when the form is submitted. Let's add this to <code>AddProduct.razor</code>:</p>
			<pre>&lt;EditForm Model='@product' OnSubmit='@OnSubmit'&gt;
&lt;/EditForm&gt;</pre>
			<p>Here, <code>product</code> is the object of the model that we want to use, which in our case is <code>Packt.Ecommerce.DTO.Models.ProductDetailsViewModel</code>. To bind data to any control, we can use a mix of HTML and Razor syntax, as shown in the following code. Here, we are binding the <code>Name</code> property of the product object to a textbox and, similarly, the <code>Category</code> property to <a id="_idTextAnchor1374"/>the dropdown. Once you enter any value in the textbox or select a value in the dropdown, it is automatically available in these properties to pass it back to any backend API or database. Let's add all the required properties to the HTML element in a similar manner:</p>
			<pre>&lt;InputText id='category' @bind-Value='product.Name'&gt;&lt;/InputText&gt;
&lt;InputSelect @bind-Value='product.Category'&gt;
&lt;option selected disabled value='-1'&gt; Choose Category&lt;/option&gt;
&lt;option value='Clothing'&gt;Clothing&lt;/option&gt;
&lt;option value='Books'&gt;Books&lt;/option&gt;
&lt;/InputSelect&gt;</pre>
			<p>Blazor forms support data validation using data annotations, so any model that we want to bind to the UI can have data annotations, and Blazor applies those validations out of the box to the controls that the property is bound to. To apply validations, we add the <code>DataAnnotationsValidator</code> component and can use the <code>ValidationSummary</code> component to show a summary of all the validation failures. You can find more details at <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/forms-validation?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/blazor/forms-validation?view=aspnetcore-6.0</a>. We can further use the <code>ValidationMessage</code> component at the control level, as shown in<a id="_idIndexMarker1110"/> the following code snippet:</p>
			<pre>&lt;DataAnnotationsValidator /&gt;
&lt;ValidationSummary /&gt;
&lt;InputNumber id='quantity' @bind-Value='product.Quantity'&gt;&lt;/InputNumber&gt;
&lt;ValidationMessage For='@(() =&gt; product.Quantity)' /&gt;</pre>
			<ol>
				<li value="9">In the <code>code</code> component, add an object of <code>ProductDetailsViewModel</code> and name it as the product, that is, as defined in the <code>Model</code> attribute of <code>EditForm</code>, and further implement the <code>OnSub<a id="_idTextAnchor1375"/>mit</code> method.</li>
			</ol>
			<p>The entire code for <code>AddProduct.Razor</code> and <code>EditProduct.<a id="_idTextAnchor1376"/>Razor</code> can be found in the GitHub repository, and once we run the application, we can see the following page:</p>
			<div><div><img src="img/Figure_11.14_B18507.jpg" alt="Figure 11.14 – The Add Product Blazor UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.14 – The Add Product Bl<a id="_idTextAnchor1377"/>azor UI</p>
			<p>This is a basic<a id="_idIndexMarker1111"/> sample for building the frontend us<a id="_idTextAnchor1378"/>ing Blazor that performs list, create, and update operations. However, there are many concepts in Bla<a id="_idTextAnchor1379"/><a id="_idTextAnchor1380"/>zor that can be further explored at <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-6.0</a>.</p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor1381"/>Summary</h1>
			<p>In this chapter, we understood various aspects of the presentation layer and UI design. Along with this, we also learned various skills in developing the presentation layer using ASP.NET Core MVC and Razor Pages, and then, finally, we implemented the presentation layer for our enterprise application using ASP.NET Core MVC and Blazor.</p>
			<p>With these skills, you should be able to build the presentation layer using ASP.NET Core MVC, Razor Pages, and Blazor, and integrate it with the backend API.</p>
			<p>In the next<a id="_idTextAnchor1382"/><a id="_idTextAnchor1383"/> chapter, we will see how to integrate authentication in our system across various layers of the application.</p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor1384"/>Questions</h1>
			<ol>
				<li value="1">Which one of the following is a recommended page to define the left-side navigation that needs to appear throughout the web application?</li>
			</ol>
			<p>a. <code>_ViewStart.cshtml</code></p>
			<p>b. <code>_ViewImports.cshtml</code></p>
			<p>c. <code>_Layout.cshtml</code></p>
			<p>d. <code>Error.cshtml</code></p>
			<p><strong class="bold">Answer: c</strong></p>
			<ol>
				<li value="2">Which of the following pages can be used to configure the <code>Layout</code> page for the entire application?</li>
			</ol>
			<p>a. <code>_ViewStart.cshtml</code></p>
			<p>b. <code>_ViewImports.cshtml</code></p>
			<p>c. <code>_Layout.cshtml</code></p>
			<p>d. <code>Error.cshtml</code></p>
			<p><strong class="bold">Answer: a</strong></p>
			<ol>
				<li value="3">Which of the following special characters is used to write Razor syntax in a <code>.cshtml</code> page?</li>
			</ol>
			<p>a. <code>@</code></p>
			<p>b. <code>#</code></p>
			<p>c. <code>&lt;% %&gt;</code></p>
			<p>d. None of the above</p>
			<p><strong class="bold">Answer: a</strong></p>
			<ol>
				<li value="4">Which method will be called on a button click in the following tag helper code in a Razor page application?<pre>&lt;input type='submit' asp-page<a id="_idTextAnchor1385"/><a id="_idTextAnchor1386"/>-handler='Delete' value='Delete' /&gt;</pre></li>
			</ol>
			<p>a. <code>OnGet() </code></p>
			<p>b. <code>onDelete()</code></p>
			<p>c. <code>OnPostDelete()</code></p>
			<p>d. <code>OnDeleteAsync()</code></p>
			<p><strong class="bold">Answer: c</strong></p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor1387"/>Further reading</h1>
			<ul>
				<li><a href="https://www.packtpub.com/web-development/html5-and-css3-building-responsive-websites">https://www.packtpub.com/web-development/html5-and-css3-building-responsive-websites</a></li>
				<li><a href="https://www.packtpub.com/product/bootstrap-for-asp-net-mvc-second-edition/9781785889479">https://www.packtpub.com/product/bootstrap-for-asp-net-mvc-second-edition/9781785889479</a></li>
				<li><a href="https://developer.mozilla.org/en-US/docs/WebAssembly">https://developer.mozilla.org/en-US/docs/WebAssembly</a></li>
				<li><a href="https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-6.0</a></li>
				<li><a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/views/partial?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/mvc/views/partial?view=aspnetcore-6.0</a></li>
				<li><a href="https://developer.mozilla.org/en-US/docs/Learn/Accessibility">https://developer.mozilla.org/en-US/docs/Learn/Accessibility</a></li>
			</ul>
		</div>
	</body></html>