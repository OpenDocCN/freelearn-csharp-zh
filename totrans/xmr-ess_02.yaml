- en: Chapter 2. Demystifying Xamarin.iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a little background on Mono and Xamarin, let''s dive in and
    see how Xamarin.iOS works. This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.iOS and AOT compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mono assemblies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xamarin.iOS bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management for Xamarin.iOS apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XIB and storyboard code generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xamarin.iOS Designer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xamarin.iOS and Ahead-of-Time compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike most Mono or .NET apps, Xamarin.iOS apps are statically compiled, where
    compilation is accomplished through the Mono **Ahead-of-Time** (**AOT**) compilation
    facilities. AOT is used to comply with Apple's requirements, for example, the
    use of iOS apps to compile, refraining from Just-in-Time compilation facilities,
    or running on virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: Use of AOT compilation comes with some limitations regarding the C# language.
    These limitations will be easier to discuss after discussing the approach to binding
    iOS to C# and .NET. This is why we have pushed this topic to the *Limitations
    of using the AOT compilation* section in the later part of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Additional information about Mono AOT compilation can be found at the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.mono-project.com/AOT#Full_AOT](http://www.mono-project.com/AOT#Full_AOT)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Mono assemblies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Xamarin.iOS ships with an extended subset of Silverlight and desktop .NET assemblies.
    These libraries provide the .NET runtime library support for developers, including
    namespaces such as `System.IO` and `System.Threading`.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.iOS is not binary compatible with assemblies compiled for a different
    profile, meaning your code must be recompiled to generate assemblies that specifically
    target the Xamarin.iOS profile. This is essentially the same thing you have to
    do if you are targeting other profiles such as Silverlight or .NET 4.5.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a complete list of assemblies that ship with Xamarin.iOS, please refer
    to the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.xamarin.com/guides/ios/under_the_hood/assemblies](http://docs.xamarin.com/guides/ios/under_the_hood/assemblies)'
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.iOS bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will discover one of the main sources of power behind Xamarin.iOS.
    This ships with a set of binding libraries that provides support for iOS development.
    What will follow are some details into each of these bindings.
  prefs: []
  type: TYPE_NORMAL
- en: The design principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A number of goals or design principles guided the development of the binding
    libraries. These principles are critical to make C# developers productive in an
    iOS development. The following represents a summary of the design principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Allow developers to subclass Objective-C classes in the same way as they subclass
    other .NET classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a way to call arbitrary Objective-C libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transform the common Objective-C tasks into something much easier while making
    the difficult Objective-C tasks possible to complete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expose Objective-C properties as C# properties as well as expose a strongly
    typed API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Native C# types in lieu of Objective-C types when possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support both C# events and Objective-C Delegation as well as expose C# delegates
    to Object-C APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section has provided you with a general idea of the principles to bear
    in mind. If you are curious to find a complete discussion, you can refer to the
    official documentation available at the following link:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[http://docs.xamarin.com/guides/ios/under_the_hood/api_design/](http://docs.xamarin.com/guides/ios/under_the_hood/api_design/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C# types and type safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Xamarin.iOS bindings are designed to use types familiar to C# developers
    and to increase type safety when possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the API uses C# string instead of `NSString`, meaning the text
    property in `UILabel` is defined in the iOS SDK in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, this is exposed in Xamarin.iOS as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Behind the scenes, the framework takes care of marshaling C# types to the appropriate
    type expected by the iOS SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example is the treatment of `NSArray`. Rather than exposing weakly
    typed arrays, Xamarin.iOS exposes strongly typed arrays to the following Object-C
    property on `UIView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exposed as a C# property in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Use of inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Xamarin.iOS allows you to extend any Objective-C type in the same manner you
    will extend any C# type and features like calling "base" from overridden methods
    work as predicted.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Objective-C delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Objective-C, the delegation design pattern is used extensively to allocate
    responsibility to various objects. Xamarin faced a few inherent challenges in
    mapping iOS delegates to C# and .NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Objective-C, delegates in Objective-C are implemented as objects that respond
    to a set of methods. This set of methods is generally defined as a protocol, and
    although it resembles a C# interface, there is in fact a significant difference
    between a C# interface and an Objective-C protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: In C#, an object that *implements* an interface is required to implement all
    the methods defined on the interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, objects in Objective-C that *adopt* a protocol are not required
    to implement the methods of the protocol for the given circumstance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another challenge is that, in many ways, traditional .NET frameworks have relied
    more heavily on events to accomplish similar capabilities, and the event model
    is much more familiar to .NET developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these differences in mind and hoping to make Xamarin.iOS as intuitive
    to C# developers as possible without compromising the iOS architecture, Xamarin.iOS
    provides four different ways to implement delegate functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Via .NET events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via .NET properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via strongly typed delegates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via weakly typed delegates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via .NET events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For many types, Xamarin.iOS automatically creates an appropriate delegate and
    forwards delegate calls to corresponding .NET events. This makes the development
    experience very natural to C# and .NET developers.
  prefs: []
  type: TYPE_NORMAL
- en: '`UIWebView` is a good example of this. iOS defines `UIWebViewDelegate`, which
    contains a number of methods that a `UIWebView` will forward if a delegate is
    assigned that includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`webViewDidStartLoad`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webViewDidFinishLoad`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webView:didFailLoadWithError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What we find in the Xamarin.iOS class `MonoTouch.UIKit.UIWebView` are three
    events that correspond to the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LoadStarted`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoadFinished`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoadError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via .NET properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although events have the advantage of having multiple subscribers, they come
    with their own limitations. Specifically, this could be where events cannot have
    a return type. In situations where a delegate method must return a value, delegate
    properties are used. The following example shows you how to use a delegate property
    for `UITextField`. In this example, an anonymous method is assigned to the delegate
    property `ShouldReturn` on `UITextField`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Via strongly typed delegates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If events or delegate properties have not been provided or if you would just
    rather work with a delegate, you will be pleased to hear that Xamarin.iOS provides
    a set of .NET classes that correspond to each iOS delegate. These classes contain
    a definition for each method defined on the corresponding protocol. Methods that
    require implementations are defined as abstract and methods that are optional
    are defined as virtual. To use one of these delegates, a developer simply creates
    a new class that inherits from the desired delegate and overrides the methods
    that need to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an example of using strongly typed delegate, we will turn to `UITableViewDataSource`.
    This is the protocol iOS defines to populate a `UITableView` instance. The following
    example demonstrates a data source that can be used to populate `UITableView`
    with phone numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created the delegate, we need to assign it to a `UITableView`
    instance. The property for the `UITableViewDataSource` delegate is named `Source`
    with the following code that shows you how to make the assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Via weakly typed delegates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lastly, Xamarin.iOS provides you with a way to use weakly typed delegates. Unfortunately,
    this method requires a bit more work for the developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Xamarin.iOS, weak delegates can be created using any class that inherits
    from `NSObject`. When creating a weak delegate, you are being handed the responsibility
    to properly decorate your class using the `Export` attribute, which effectively
    teaches iOS how the methods are mapped. The following example shows a weak delegate
    with the appropriate attribute specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The last few steps assign the weak delegate to a `UITableView` instance. By
    Xamarin.iOS convention, weak delegate property names always begin with `Weak`.
    The following example shows you how to assign the weak data source delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once a weak delegate has been assigned, any assigned strong delegates will cease
    to receive calls.
  prefs: []
  type: TYPE_NORMAL
- en: Creating binding libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There might be times when you are required to create your own binding library
    for an Objective-C library that is not delivered as part of Xamarin.iOS and can''t
    be found in the Xamarin component store. Xamarin provides a great deal of guidance
    to create bindings as well as an automated tool to help with some of the drudgery
    work. The following links provide guidance to create custom bindings for Objective-C
    libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type of information | URL to access it |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| General binding information | [http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/](http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Use of the Objective Sharpie automation tool | [http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/objective_sharpie/](http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/objective_sharpie/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Binding types reference | [http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/binding_types_reference_guide/](http://docs.xamarin.com/guides/ios/advanced_topics/binding_objective-c/binding_types_reference_guide/)
    |'
  prefs: []
  type: TYPE_TB
- en: Memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to releasing resources, Xamarin.iOS has this covered for you through
    **garbage collector** (**GC**), which does this on your behalf. On top of this,
    all objects that are derived from `NSObject` utilize the `System.IDisposable`
    interface so that developers have some control over it when the memory is released.
  prefs: []
  type: TYPE_NORMAL
- en: '`NSObject` not only implements the `IDisposable` interface, but also follows
    the .NET dispose pattern. The `IDisposable` interface only requires a single method
    to be implemented, `Dispose()`. The dispose pattern requires an additional method
    to be implemented, `Dispose(bool disposing)`. The disposing parameter indicates
    whether the method is being called from the `Dispose()` method, in which case
    the value is `true`, or from the `Finalize` method, in which case the value is
    `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The disposing parameter is intended to be used to determine if managed objects
    should be freed. If the value is `true`, the managed objects should be released.
    Unmanaged objects should be released regardless of the value. The following code
    demonstrates what should be present in the `Dispose()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Take note of the call to `Dispose(bool disposing)` with a value of `true`.
    Conveniently, the `Dispose()` method is implemented for you by the framework as
    a virtual method on `NSObject`. The following code demonstrates an implementation
    of the `Dispose(bool disposing)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Again, notice the call to `base.Dispose(disposing)`. This call is very important
    as it deals with resources managed within the framework itself.
  prefs: []
  type: TYPE_NORMAL
- en: Why the fuss? Why not clean up everything in `Dispose()`? The answer lies in
    the garbage collector. The order in which the garbage collector destroys objects
    is not defined and thus is unpredictable and subject to change. The .NET dispose
    pattern helps prevent the finalizer from calling `Dispose()` on objects that have
    already been disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read more about the .NET dispose pattern at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx](http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx)'
  prefs: []
  type: TYPE_NORMAL
- en: Disposing of a managed object renders it useless. Even though references to
    the object might still exist, you need to structure your software with the assumption
    that an object that has been disposed of is no longer valid. In some cases, an
    `ObjectDisposedException` will be thrown when accessing methods of a disposed
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Disposing of objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anytime you have an object that is holding substantial resources and is no longer
    required, call the `Dispose()` method. The GC is convenient and fairly sophisticated
    but might not have a complete picture as to the amount of resources a specific
    object has allocated, particularly if those resources are associated with unmanaged
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping objects around
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prevent an object from being destroyed, you simply need to be sure there
    is at least one reference to the object maintained. Once an object's reference
    count reaches `0`, the GC is all happy to call the `Dispose()` method on it and
    the object is no longer usable.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of using the AOT compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned earlier in this chapter, some limitations come with the use
    of the AOT compilation. The following sections outline the limitations imposed
    by Xamarin.iOS due to the use of the AOT compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'No generic subclasses of `NSObject` are allowed. The following will not be
    allowed since `UIViewController` is a subclass of `NSObject`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'P/Invoke is not supported in generic classes, so the following is not supported
    in Xamarin.iOS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Property.SetInfo()` on `a Nullable<T> Type` is not supported. Using Reflection''s
    `Property.SetInfo()` to set the value on a `Nullable<T>` is not currently supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No dynamic code generation. The iOS kernel prevents an app from generating
    code dynamically and thus Xamarin.iOS imposes the following limitations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neither `System.Reflection.Emit` nor `System.Runtime.Remoting` is available
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: No support to create types dynamically
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse callbacks must be registered with the runtime at compile time
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a further limitation for reverse callbacks. In Mono, you can pass
    C# delegates to unmanaged code rather than passing a function pointer. Use of
    AOT imposes some limitations on this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback methods must be flagged with the Mono attribute `MonoPInvokeCallbackAttribute`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback methods must be static; there is no support for instance methods
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime features disabled
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following features are disabled in Xamarin.iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: Profiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Reflection.Emit` functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Reflection.Emit.Save` functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: COM bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JIT engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The metadata verifier (since there is no JIT)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating code for XIB and storyboard files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Apple Interface Builder is a designer built into Xcode that allows for visual
    design of a user interface. The use of the Interface Builder is optional; user
    interfaces can be completely built using iOS APIs. The definitions created by
    the Interface Builder are saved in either XIB or storyboard files with the difference
    being that the XIB files tend to contain a single view. Storyboards, on the other
    hand, contain a set of views along with the transitions or segues between the
    views.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin Studio works in conjunction with Xcode to support the UI design. When
    a storyboard or XIB file is double-clicked on within Xamarin Studio, Xcode is
    launched to facilitate the design of the UI. Once the changes are saved in Xcode
    and you switched back to Xamarin Studio, C# code is generated to support the UI
    design captured in Xcode. The following sections describe this process in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: Generated classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Xamarin Studio generates two files for each custom class found in an XIB file
    or a storyboard file, a designer file, and a non-designer file. For instance,
    a view controller named `LoginViewController` will cause the following files to
    be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LoginViewController.cs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoginViewController.designer.cs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These files are generated after the changes have been saved in Xcode, and Xamarin
    Studio gains focus.
  prefs: []
  type: TYPE_NORMAL
- en: Designer files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Designer files contain a partial class definition for custom classes found
    in the XIB or storyboard file with properties being created for outlets and partial
    methods for the actions that are found. The following example is for a view controller
    with two `UITextField` controls and a single `UIButton` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Designer files are automatically updated once an XIB or storyboard file has
    been altered. As a result, they should not be modified manually because any changes
    will be lost once Xamarin Studio updates them.
  prefs: []
  type: TYPE_NORMAL
- en: Non-designer files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Designer files are used alone but in conjunction with a non-designer file.
    The non-designer file contains a partial class specification, which completes
    the class defined in its corresponding designer file. The non-designer files identify
    the base class, defines constructors that are required to instantiate the class,
    and provides a place to implement functionality either by providing implementations
    for partial methods or by overriding virtual methods on the base class. The following
    example shows a non-designer file with an override and partial method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the partial method implementation in this file is for a method generated
    in the designer file in response to find an action defined in the corresponding
    XIB or storyboard files.
  prefs: []
  type: TYPE_NORMAL
- en: Changes made to the non-designer file will not be lost as these files are only
    created the first time Xamarin Studio encounters the new custom class and are
    not subsequently updated.
  prefs: []
  type: TYPE_NORMAL
- en: Outlets properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Designer classes contain private properties, which correspond to outlets defined
    on the custom class that can then be used from the `CodeBehind` class found in
    the non-designer file. If you need to make these properties public, all you need
    to do is add the accessor properties to the non-designer file similar to how you
    will for any given private field.
  prefs: []
  type: TYPE_NORMAL
- en: Action properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Designer files have the property of containing partial methods that are associated
    to all of the actions defined on the custom class. You should note that these
    methods do not contain an implementation and they serve a dual purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: Their first purpose is that when you insert partial into the class body of the
    non-designer file, Xamarin Studio will offer to autocomplete the signatures of
    all non-implemented partial methods, which allows developers to implement logic
    for actions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Their other purpose is that their signatures have an attribute applied to them,
    exposing them to the Objective-C world. Consequently, they can be invoked once
    the corresponding action is triggered in iOS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xamarin.iOS Designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Xamarin provides an alternative to Apple''s Interface Builder. Xamarin.iOS
    Designer is an add-in for the Xamarin Studio environment that adds full drag-and-drop
    user interface design for iOS storyboards all from within Xamarin Studio. Xamarin.iOS
    Designer provides the following key features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compatible storyboard format**: As you will expect, Xamarin.iOS Designer
    creates storyboards in the same format used by Xcode and the iOS SDK, so switching
    back to Xcode at some point is allowed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eliminates syncing with Xcode**: Using Xamarin.iOS Designer eliminates the
    need to use Xcode in the development process along with the synchronization problems
    that can occur between Xamarin Studio and Xcode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy properties**: Xamarin.iOS Designer automatically creates properties
    that reference controls as they are dropped on a view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy event handlers**: Xamarin.iOS Designer provides a more intuitive means
    to create event handlers, which work in a very similar way as Visual Studio works
    on other UI frameworks such as Silverlight and WPF'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom controls**: User can create their own custom UI controls that are
    accessible from within the toolbox panel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xamarin.iOS Designer can only be used to create storyboards. If you prefer or
    need to work with XIB files, you will need to continue to work with Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we presented the essentials of Xamarin.iOS architecture and
    tried to demystify the way Xamarin.iOS allows developers to create great native
    apps for iOS using C# and Mono. While we have obviously not covered the entire
    iOS SDK, we have described the approach and principles used to build Xamarin.iOS.
    With this knowledge in place, you should be in a good position to move forward
    with Xamarin.iOS development and resolve issues as they arise.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will try to accomplish the same goals for Xamarin.Android.
  prefs: []
  type: TYPE_NORMAL
