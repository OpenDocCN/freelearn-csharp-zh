<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Using Custom Controls and User Controls
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Creating a custom control</li>
<li>Customizing the template of a custom control</li>
<li>Exposing properties from a custom control</li>
<li>Exposing events from a custom control</li>
<li>Extending the functionality of a control using behavior</li>
<li>Creating a User Control interface</li>
<li>Exposing events from a User Control</li>
<li>Customizing the XMLNS namespace</li>
</ul>
<h1 id="uuid-9287341b-b8e4-4449-8fa3-bf977b7a1048">Introduction</h1>
<p>A custom control is a loosely coupled control defined in a class which derives from the <kbd>System.Windows.Controls.Control</kbd> class. You may also derive it from a different custom control, depending on your requirement.</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/53586c85-931b-4eee-a86d-64a0612cc73f.png" style=""/></div>
<p class="mce-root CDPAlignLeft CDPAlign">The UI of custom control is generally defined in a <strong>resource dictionary</strong> inside the <kbd>resource</kbd> file. <span>We can create themes for custom control and reuse them in various projects very </span>easily:</p>
<p>Generally, the <strong>custom controls</strong> are compiled into a <kbd>dll</kbd> assembly and can be reused in multiple places very easily. You have total control over its code, and thus it gives you more flexibility to extend the behavior. Once you build and add a reference to the custom control in your project, you can find it in the Visual Studio control toolbox, which will allow you to drag and drop the control in your XAML design view and start working with it.</p>
<p>On the other end, <strong>User Control</strong> is nothing but a custom control that you derive to control the UI specific to your project. It derives from the <kbd>System.Windows.Controls.UserControls</kbd> class, which basically inherits from <kbd>System.Windows.Controls.Control</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e96ee1e2-b353-4385-81d8-a2bdb808dfdb.png" style=""/></div>
<p>Generally, the User Control gets placed inside a XAML page with tight bonding to its code behind. You can directly access its UI elements from the code behind and do some specific operations.</p>
<div class="packt_tip">A point to remember is that you can't create theming support for User Controls but you can style them by creating theme for its child, custom controls. Also, once you create a User Control UI in one project, you can't change it in the other projects.</div>
<p>In this chapter, we will learn how to create custom controls and User Controls, and then customize them based on need.</p>
<h1 id="uuid-efe99add-7024-45c4-8cc1-e13c4e28b7ce">Creating a custom control</h1>
<p>Before working with custom controls, you will need to know how to create custom controls and how to add them to any XAML pages. In this recipe, we will learn these basic operations first.</p>
<h2 id="uuid-f91fb58a-f19d-4da4-8398-02d8a2c88691">Getting ready</h2>
<p>Let's open the Visual Studio IDE and create a new WPF application project, called <kbd>CH05.SearchControlDemo</kbd>.</p>
<h2 id="uuid-5e4704ba-0a7b-4bda-82bf-c89bc53f4297">How to do it...</h2>
<p>Perform the following steps to create your first custom control, which will contain a text input box and a button to build a search control. At the end, we will add it to the application window:</p>
<ol>
<li>Once the project has been created, right-click on the project, from <span class="packt_screen">Solution Explorer</span>, and follow <span class="packt_screen">Add</span> | <span class="packt_screen">New Item...</span> from the context menu entries. A new dialog window will pop up on the screen.</li>
</ol>
<p> </p>
<ol start="2">
<li>Inside the <span class="packt_screen">Add New Item</span> dialog window, expand the <span class="packt_screen">Installed</span> | <span class="packt_screen">Visual C#</span> | <span class="packt_screen">WPF</span> tree item, from the left navigation panel, and select <span class="packt_screen">Custom Control (WPF)</span> from the right screen:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a82f1bde-027d-4863-a7f8-04f7646a1311.png"/></div>
<ol start="3">
<li>Give the custom control a name (let's say, <kbd>SearchControl.cs</kbd>) and click <span class="packt_screen">Add</span> to create it. This will create the class file named <kbd>SearchControl.cs</kbd> inside the project, and a folder (named <kbd>Themes</kbd>) containing a <kbd>Generic.xaml</kbd> file.</li>
<li>Open the <kbd>Generic.xaml</kbd> file, which will contain a <kbd>Style</kbd> for the custom control that we created. This gets generated automatically by the Visual Studio IDE, while creating the custom control from the default template. Here's the default <kbd>Style</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;Style TargetType="{x:Type local:SearchControl}"&gt; 
    &lt;Setter Property="Template"&gt; 
        &lt;Setter.Value&gt; 
            &lt;ControlTemplate TargetType="{x:Type local:  
                              SearchControl}"&gt; 
                &lt;Border Background="{TemplateBinding  
                              Background}" 
                        BorderBrush="{TemplateBinding  
                              BorderBrush}" 
                        BorderThickness="{TemplateBinding  
                              BorderThickness}"&gt;                         
                &lt;/Border&gt; 
            &lt;/ControlTemplate&gt; 
        &lt;/Setter.Value&gt; 
    &lt;/Setter&gt; 
&lt;/Style&gt; </pre>
<ol start="5">
<li>Now replace the preceding <kbd>Style</kbd> of the control with the following one, which contains an input box and a button, as the control template inside a <kbd>Grid</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;Style TargetType="{x:Type local:SearchControl}"&gt; 
    &lt;Setter Property="Height" Value="26"/&gt; 
    &lt;Setter Property="Width" Value="150"/&gt; 
    &lt;Setter Property="Template"&gt; 
        &lt;Setter.Value&gt; 
            &lt;ControlTemplate TargetType="{x:Type <br/>             local:SearchControl}"&gt; 
                &lt;Grid&gt; 
                    &lt;Grid.ColumnDefinitions&gt; 
                        &lt;ColumnDefinition Width="*"/&gt; 
                        &lt;ColumnDefinition Width="Auto"/&gt; 
                    &lt;/Grid.ColumnDefinitions&gt; 
                    &lt;TextBox x:Name="PART_TextBox" 
                            Grid.Column="0" 
                            Margin="2" 
                            HorizontalAlignment="Stretch" 
                            VerticalAlignment="Stretch"/&gt; 
                    &lt;Button x:Name="PART_Button" 
                            Content="Search" 
                            Grid.Column="1" 
                            Margin="2" Padding="8 2" 
                            HorizontalAlignment="Stretch" 
                            VerticalAlignment="Stretch"/&gt; 
                &lt;/Grid&gt; 
            &lt;/ControlTemplate&gt; 
        &lt;/Setter.Value&gt; 
    &lt;/Setter&gt; 
&lt;/Style&gt; </pre>
<ol start="6">
<li>Now open the <kbd>MainWindow.xaml</kbd> page, and add the following XMLNS namespace:</li>
</ol>
<pre style="padding-left: 90px"/>
<ol start="7">
<li>Now, inside the default <kbd>Grid</kbd> panel, add the custom control that we just created, and optionally set its <kbd>Height</kbd> and <kbd>Width</kbd> properties:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;controls:SearchControl Height="30" 
                            Width="180"/&gt; 
&lt;/Grid&gt; </pre>
<ol start="8">
<li>That's all! Our first custom control has been created and added to the <kbd>MainWindow</kbd> of the application. Let's build and run the application. You will see the following UI on the screen:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5e1e0f8c-438e-4501-b59b-e9aad4f1186d.png" style=""/></div>
<p>We have just added the UI of our custom control here and hence no functionality related to search will work. We will enhance the functionalities in the next recipes.</p>
<h2 id="uuid-0087fe9b-f106-4497-b0da-720da6a88bff">How it works...</h2>
<p>When you first create a custom control in a project, Visual Studio creates a folder named <kbd>Themes</kbd>, and places a file named <kbd>Generic.xaml</kbd>. This file contains all the styles and templates of the custom controls, by default. When you add more custom controls inside the same project, the <kbd>Generic.xaml</kbd> file gets updated with the styles of the new controls.</p>
<p>The property called <kbd>TargetType</kbd> defines the type of the control for which we are going to create the style. In the preceding example, <kbd>&lt;Style TargetType="{x:Type local:SearchControl}"&gt;</kbd> defines the style of the custom control called <kbd>SearchControl</kbd>. To change the UI of the control, we need to update the same style.</p>
<p>The <kbd>&lt;ControlTemplate TargetType="{x:Type local:SearchControl}"&gt;</kbd> defines the template of the control, which generally resides inside the <kbd>Style</kbd>.</p>
<p>The <kbd>Setter</kbd> properties inside the <kbd>Style</kbd> define the default value of various properties of the said control. In the preceding example, we have defined the default value of the <kbd>Height</kbd> and <kbd>Width</kbd> properties. You can add additional property values.</p>
<h2 id="uuid-c86cd835-cf4d-476f-8fea-2034d25d4892">There's more...</h2>
<p>Before going further with the custom controls, you need to learn and understand some other points related to them. Let's discuss them in the following sections.</p>
<h3 id="uuid-7abc07c0-7760-4f7d-86da-99868c32cb61">XMLNS attribute declaration</h3>
<p>When the custom control is present within the same project where you are going to use it, you need to add the XMLNS attribute in the following way:</p>
<pre style="padding-left: 60px"> </pre>
<p>This is the same way we added it in the preceding example. The <kbd>clr-namespace</kbd> defines the namespace where the controls are available. A single namespace can have one or more controls.</p>
<p>When the custom control is present in a different project to the one where you are going to add it, you need to add the XMLNS attribute in the following way:</p>
<pre style="padding-left: 60px"> </pre>
<p>Here, the <kbd>clr-namespace</kbd> defines the namespace of the controls, whereas the <kbd>assembly</kbd> defines the fully qualified name of the assembly where the control is present.</p>
<h3 id="uuid-5b0cc0b9-e6c7-4066-9846-095584fc1ee8">Default styling</h3>
<p>When you create a custom control, all the default properties of its base class, <kbd>Control</kbd>, gets assigned to it. You can use <kbd>TemplateBinding</kbd> to bind the data to a specific control. For example, to change the background color of the input box based on the <kbd>Background</kbd> property set on the control level, you need to create the template binding in the following way:</p>
<pre style="padding-left: 60px">&lt;TextBox x:Name="PART_TextBox" 
         Grid.Column="0" 
         Margin="2" 
         Background="{TemplateBinding Background}" 
         HorizontalAlignment="Stretch" 
         VerticalAlignment="Stretch"/&gt; </pre>
<p>Now, when you change the color of the control, it will change the color of the said input box. Set a color to the <kbd>Background</kbd> property of our search control inside the <kbd>MainWindow.xaml</kbd> and observe the change.</p>
<h3 id="uuid-63037307-1a17-490a-a796-71d66b798fb9">Toolbox integration</h3>
<p>When you create a custom control within the same project and/or reference a <kbd>dll</kbd> containing any custom control, you will be able to utilize the <span class="packt_screen">Visual Studio Toolbox</span> to drag and drop the control directly to the XAML/designer view.</p>
<p>After creating the control or adding the control library in a project, you need to build it first. Now, open any XAML page and navigate to the Visual Studio <span class="packt_screen">Toolbox</span>. You will be able to find the control, as demonstrated here:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/378e0067-6e71-44b8-af54-8fc726ed60fd.png" style=""/></div>
<p>Now you can drag it to the place where you want to add the said control.</p>
<h1 id="uuid-3f68b271-1058-4e39-80ca-815c7c5ec02a">Customizing the template of a custom control</h1>
<p>The development of a custom control always requires its default template to be changed to give it a proper look and make it ready for theming support. That starts with the customization of the template and its default values.</p>
<p>In this recipe, we will learn how to change the template and use <kbd>TemplateBinding</kbd> to create a relation with its property values.</p>
<h2 id="uuid-8ae231e5-01fc-4aff-b4bf-66ba986fdf29">Getting ready</h2>
<p>To get started, launch Visual Studio, create a project, and add a new custom control in it. For this demonstration, we will be using the existing project, <kbd>CH05.SearchControlDemo</kbd>, that we created in the previous recipe. So, let's open the project.</p>
<h2 id="uuid-76651677-e2a1-44cc-89f2-8b5695f89ae2">How to do it...</h2>
<p>As we want to customize the template of the custom control to have a proper template binding, perform the following steps:</p>
<ol>
<li>Open the <kbd>Generic.xaml</kbd> file, which is present under the <kbd>Themes</kbd> folder of the project.</li>
<li>Now, scroll down to the definition of the <kbd>ControlTemplate</kbd> as we need to customize the look and feel of it.</li>
<li>Search for the <kbd>TextBox</kbd> control named <kbd>PART_TextBox</kbd>, and set its <kbd>Background</kbd>, <kbd>BorderBrush</kbd>, <kbd>BorderThickness</kbd>, and <kbd>Foreground</kbd> properties to have a binding with the control's default properties.</li>
<li>Similarly, set the <kbd>Background</kbd> and <kbd>Foreground</kbd> property of the button (<kbd>PART_Button</kbd>) to the same properties of the control, by using template binding. Here's the complete code of the modified control template:</li>
</ol>
<pre style="padding-left: 90px">&lt;ControlTemplate TargetType="{x:Type local:SearchControl}"&gt; 
    &lt;Grid&gt; 
        &lt;Grid.ColumnDefinitions&gt; 
            &lt;ColumnDefinition Width="*"/&gt; 
            &lt;ColumnDefinition Width="Auto"/&gt; 
        &lt;/Grid.ColumnDefinitions&gt; 
        &lt;TextBox x:Name="PART_TextBox" 
                 Grid.Column="0" 
                 Margin="2" 
                 Background="{TemplateBinding Background}" 
                 BorderBrush="{TemplateBinding  
                               BorderBrush}" 
                 BorderThickness="{TemplateBinding  
                                   BorderThickness}" 
                 Foreground="{TemplateBinding Foreground}" 
                 HorizontalAlignment="Stretch" 
                 VerticalAlignment="Stretch"/&gt; 
        &lt;Button x:Name="PART_Button" 
                Content="Search" 
                Grid.Column="1" 
                Margin="2" Padding="4 2" 
                Background="{TemplateBinding Background}" 
                Foreground="{TemplateBinding Foreground}" 
                HorizontalAlignment="Stretch" 
                VerticalAlignment="Stretch"/&gt; 
    &lt;/Grid&gt; 
&lt;/ControlTemplate&gt; </pre>
<ol start="5">
<li>You can also assign default values to your control templates, by using the <kbd>&lt;Setter/&gt;</kbd> tag. You will need to add it inside the <kbd>&lt;Style/&gt;</kbd> definition. To add default values to the <kbd>Height</kbd>, <kbd>Width</kbd>, <kbd>Background</kbd>, <kbd>BorderBrush</kbd>, <kbd>BorderThickness</kbd>, and <kbd>Foreground</kbd> properties, add the following code block inside the <kbd>Style</kbd> tag:</li>
</ol>
<pre style="padding-left: 90px">&lt;Setter Property="Height" Value="30"/&gt; 
&lt;Setter Property="Width" Value="280"/&gt; 
&lt;Setter Property="Background" Value="AliceBlue"/&gt; 
&lt;Setter Property="BorderBrush" Value="LightSkyBlue"/&gt; 
&lt;Setter Property="BorderThickness" Value="1"/&gt; 
&lt;Setter Property="Foreground" Value="Navy"/&gt; </pre>
<ol start="6">
<li>Once done, compile your project and run it. You will see the following screen, where the background of the <kbd>TextBox</kbd> and <kbd>Button</kbd> controls are painted with <kbd>AliceBlue</kbd> color. Similarly, the other styles are applied as per the default values specified:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/d9ae63a7-33a9-44a0-9fca-7f8c0e8d4c99.png" style=""/></div>
</li>
<li>You can override the default style values in your application, where you are using the control. To do this, open the <kbd>MainWindow.xaml</kbd> file and add a custom <kbd>Background</kbd> color, <kbd>BorderBrush</kbd>, <kbd>Foreground</kbd>, and <kbd>BorderThickness</kbd> to the control as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;controls:SearchControl  
        Background="#2200FF00" 
        BorderThickness="2" 
        BorderBrush="GreenYellow" 
        Foreground="Green"/&gt; 
&lt;/Grid&gt; </pre>
<ol start="8">
<li>Now, if you build and run the application, you will notice the UI changed as per the custom value that you specified directly to the control:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/bcd1a13a-70bc-4936-89cb-49b22c9d57e1.png" style=""/></div>
</li>
</ol>
<h2 id="uuid-71331204-68b5-4a7b-936c-ee717d06830b">How it works...</h2>
<p><kbd>TemplateBinding</kbd> is a type of binding used mainly while working with templates. This allows you to replace the visual tree of controls for a completely fresh look and feel, based on the theme or style that you want to use. It also helps you to reference the parent control, read its properties, and apply its values.</p>
<p>When you apply a template binding to a control, present in the <kbd>ControlTemplate</kbd> of the parent control, it first checks whether the property is present to the parent control. If it is not present, it throws an XAML syntax error.</p>
<p>If it finds the property, it checks whether the value is supplied from the place where the custom control has been used. If it finds no reference, it applies the default value to the property.</p>
<h1 id="uuid-8823e08c-9395-4de7-94c9-985c2b53710e">Exposing properties from the custom control</h1>
<p>Most of the time, while using custom controls, we need to expose additional properties based on the requirement. In this recipe, we will demonstrate exposing dependency properties from the custom control and binding the record to the UI.</p>
<h2 id="uuid-14f94553-36cf-40c9-80b6-96bf8acd14fa">Getting ready</h2>
<p>Let's extend our previous project to perform these steps. To get started, launch Visual Studio and open the project <kbd>CH05.SearchControlDemo</kbd>.</p>
<h2 id="uuid-a7b8e972-7590-40d9-a05e-30a74cf3fed9">How to do it...</h2>
<p>Once the project has been opened, perform the following steps to create a dependency property named <kbd>SearchTerm</kbd> and bind it with the control UI:</p>
<ol>
<li>Let's open the <kbd>SearchControl.cs</kbd> to create a dependency property. Inside the class definition, type <kbd>propdp</kbd> and press the <em><span class="KeyPACKT">TAB</span></em> key twice to create the property structure. By default, it generates <kbd>MyProperty</kbd> of type <kbd>int</kbd>.</li>
<li>Change the property type from <kbd>int</kbd> to <kbd>string</kbd> and press <em><span class="KeyPACKT">TAB</span></em>.</li>
<li>Rename <kbd>MyProperty</kbd> to <kbd>SearchTerm</kbd> and press <em><span class="KeyPACKT">TAB</span></em> again.</li>
<li>Now change <kbd>ownerclass</kbd> to <kbd>SearchControl</kbd> and press <em><span class="KeyPACKT">TAB</span></em>.</li>
<li>Pass <kbd>string.Empty</kbd> as the default value to the <kbd>PropertyMetaData</kbd>.</li>
<li>Once these preceding steps are done, your property is ready to use. Now open the <kbd>Generic.xaml</kbd> page to create the binding to the UI control.</li>
<li>Inside the template of the control, find the <kbd>TextBox</kbd> named <kbd>PART_TextBox</kbd>.</li>
</ol>
<p> </p>
<ol start="8">
<li>Now, add the <kbd>Text</kbd> property to it, by using <kbd>TemplateBinding</kbd>. You will see the dependency property (<kbd>SearchTerm</kbd>) listed in the XAML IntelliSense, as shown here:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7d448ece-82e5-4e3e-b1d2-ccddce97e64e.png" style=""/></div>
<ol start="9">
<li>Let's complete the template binding as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;TextBox x:Name="PART_TextBox" 
         Grid.Column="0" 
         Margin="2" 
         Text="{TemplateBinding SearchTerm}" 
         Background="{TemplateBinding Background}" 
         BorderBrush="{TemplateBinding BorderBrush}" 
         BorderThickness="{TemplateBinding  
                           BorderThickness}" 
         Foreground="{TemplateBinding Foreground}" 
         HorizontalAlignment="Stretch" 
         VerticalAlignment="Stretch"/&gt; </pre>
<ol start="10">
<li>Now navigate to the <kbd>MainWindow.xaml</kbd> page and add the <kbd>SearchTerm</kbd> property to the control that we have already added:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/e0e6e883-edb0-486e-ac0d-82fb623d56fa.png" style=""/></div>
</li>
<li>Set some sample strings to it:</li>
</ol>
<pre style="padding-left: 90px">&lt;controls:SearchControl  
        SearchTerm="my search term" 
        Background="#2200FF00" 
        BorderThickness="2" 
        BorderBrush="GreenYellow" 
        Foreground="Green"/&gt; </pre>
<ol start="12">
<li>Build the project and run it. You will see that the string that you assigned to the <kbd>SearchTerm</kbd> property of the control, actually assigned the value to the search <kbd>TextBox</kbd>:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/289ea954-9831-4d3d-8140-df97707ad334.png" style=""/></div>
</li>
</ol>
<h2 id="uuid-90f3bc59-c659-4f62-8da5-b4d3ce1da2a4">How it works...</h2>
<p>Template binding works only with the dependency properties. When you assign a value to the dependency property, it automatically updates the child control where you have created the binding. In our example, when you assign a value to the <kbd>SearchTerm</kbd> property, it sets the value to the textbox (<kbd>PART_TextBox</kbd>) control's <kbd>Text</kbd> property and thus you can see the value provided to it.</p>
<h1 id="uuid-ec496bb4-d7d0-4bb0-8f55-e9b3851e114c">Exposing events from a custom control</h1>
<p>When you build any custom control, you need to expose additional events, based on the child controls and functionality that you want to expose to the user. In this recipe, we will learn how to expose a custom event from a custom control and perform a specific operation using it.</p>
<h2 id="uuid-cabc8b19-c402-4d26-92c6-2ab33806e399">Getting ready</h2>
<p>Let's start with the existing project that we have already used in the previous recipes. Launch the IDE and open the <kbd>CH05.SearchControlDemo</kbd> project inside Visual Studio.</p>
<h2 id="uuid-05df26b3-d711-40e1-94ac-802ccda83a38">How to do it...</h2>
<p>In this recipe, we will create a public event from the <kbd>SearchControl</kbd>, so that we can subscribe to the <kbd>PART_Button</kbd> button event and fetch the user-entered text. To do so, follow perform the following steps:</p>
<ol>
<li>From <span class="packt_screen">Solution Explorer</span>, create a new class named <kbd>SearchEventArgs</kbd>, inside the project.</li>
<li>Extend the <kbd>SearchEventArgs</kbd> class from the <kbd>EventArgs</kbd> and expose a public property (<kbd>SearchTerm</kbd>) of type <kbd>string</kbd>. Here's the class implementation:</li>
</ol>
<pre style="padding-left: 90px">public class SearchEventArgs : EventArgs 
{ 
    public string SearchTerm { get; set; } 
} </pre>
<ol start="3">
<li>Now open the <kbd>SearchControl.cs</kbd> file. We need to create a delegate and event inside it. Let's add the following inside the class implementation:</li>
</ol>
<pre style="padding-left: 90px">public delegate void OnSearchClick(object sender,  
 SearchEventArgs e); 
public event OnSearchClick SearchButtonClick; </pre>
<ol start="4">
<li>The next task is to associate the button click event with the custom event that we have just created. Pass the <kbd>SearchTerm</kbd> to the custom event as an argument. To do this, copy the following code inside the <kbd>SearchControl</kbd> class:</li>
</ol>
<pre style="padding-left: 90px">public override void OnApplyTemplate() 
{ 
    base.OnApplyTemplate(); 
 
    if (GetTemplateChild("PART_Button") is Button  
     searchButton) 
    { 
        searchButton.Click +=  
                    OnSearchButtonClicked_Internal; 
    } 
} 
 
private void OnSearchButtonClicked_Internal(object sender,  
  RoutedEventArgs e) 
{ 
    SearchButtonClick?.Invoke(this, new SearchEventArgs {  
      SearchTerm = SearchTerm }); 
} </pre>
<ol start="5">
<li>Open the <kbd>Generic.xaml</kbd> page and perform a slight change to the <kbd>Text</kbd> property binding of the search <kbd>TextBox</kbd>. Instead of template binding, let's perform a normal data binding, passing a relative source to it. As we need to take input from the user, we will set the binding mode to <kbd>TwoWay</kbd>. Here's the XAML code:</li>
</ol>
<pre style="padding-left: 90px">&lt;TextBox x:Name="PART_TextBox" 
         Grid.Column="0" 
         Margin="2" 
         Text="{Binding SearchTerm, RelativeSource={RelativeSource TemplatedParent}, Mode=TwoWay}" 
         Background="{TemplateBinding Background}" 
         BorderBrush="{TemplateBinding BorderBrush}" 
         BorderThickness="{TemplateBinding  
                           BorderThickness}" 
         Foreground="{TemplateBinding Foreground}" 
         HorizontalAlignment="Stretch" 
         VerticalAlignment="Stretch"/&gt; </pre>
<ol start="6">
<li>Once this is done, open the <kbd>MainWindow.xaml</kbd> and register the <kbd>SearchButtonClick</kbd> event of the <kbd>SearchControl</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;controls:SearchControl  
        SearchTerm="my search term" 
        Background="#2200FF00" 
        BorderThickness="2" 
        BorderBrush="GreenYellow" 
        Foreground="Green" 
        SearchButtonClick="OnSearchButtonClicked"/&gt;</pre>
<ol start="7">
<li>Open the code behind <kbd>MainWindow.xaml.cs</kbd> and modify the event implementation to show a message box to the user, with the text that we passed as a search term. You can find it as <kbd>e.SearchTerm</kbd>, as passed to the event argument. Here's the code for your reference:</li>
</ol>
<pre style="padding-left: 90px">private void OnSearchButtonClicked(object sender,  
 SearchEventArgs e) 
{ 
    MessageBox.Show("You searched for: "" +  
     e.SearchTerm + """); 
} </pre>
<ol start="8">
<li>That's all! Let's build the application and run it. As we already have a default value set to the control, click on the <span class="packt_screen">Search</span> button. You will see a message box with the default search term. Now, change the value to have a different search term. To do so, click on the <kbd>TextBox</kbd> control and replace the string. Now, click on the <span class="packt_screen">Search</span> button once again, which will show the new search term inside the message box. Here's a screenshot of the same operation:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1a25bcdf-d48c-48d9-97a1-ee7c2c51c27f.png"/></div>
<h2 id="uuid-34ecbf70-3e05-4169-8fda-5b288871d5e5">How it works...</h2>
<p>When the application loads with the control on the UI, the first thing that it does is to load its defined template and call the <kbd>OnApplyTemplate()</kbd> method. <kbd>OnApplyTemplate()</kbd> is a virtual method present inside the <kbd>System.Windows.FrameworkElement</kbd> class, which gets invoked when application code or internal processes call the <kbd>System.Windows.FrameworkElement.ApplyTemplate()</kbd>.</p>
<p>As you can see in the <kbd>OnApplyTemplate()</kbd> method implementation, it finds out the template child named <kbd>PART_Button</kbd> using the <kbd>GetTemplateChild</kbd> method call, and registers its associated <kbd>Click</kbd> event:</p>
<pre style="padding-left: 60px">public override void OnApplyTemplate() 
{ 
    base.OnApplyTemplate(); 
 
    if (GetTemplateChild("PART_Button") is Button searchButton) 
    { 
        searchButton.Click += OnSearchButtonClicked_Internal; 
    } 
} </pre>
<p>The <kbd>Click</kbd> event then invokes the custom event (<kbd>SearchButtonClick</kbd>), passing the <kbd>SearchTerm</kbd> as <kbd>SearchEventArgs</kbd>. Now, when you click on the button in the application UI, it fires the <kbd>OnSearchButtonClicked_Internal</kbd> event and bubbles up to the application UI. The <kbd>OnSearchButtonClicked</kbd> event handler then triggers due to its subscription to the custom event and performs the operation. In our case, it shows a message to the user with the search term passed to the search box.</p>
<h1 id="uuid-d21827a3-690e-4621-bcc3-c6908aa62b5f">Extending the functionality of a control using behavior</h1>
<p><strong>Behavior</strong> is a concept to extend the functionality of a control using a reusable component. These components can be attached to any control or a specific type of control to provide designers with the flexibility to design complex user interactions without writing any additional code.</p>
<p>In this recipe, we will learn how to create a behavior and the way to apply it to a control without writing extra code in the code-behind file.</p>
<h2 id="uuid-b9a64b9a-82be-494e-ad6f-35038b3d5af9">Getting ready</h2>
<p>To get started, we need to open the Visual Studio IDE. Create a new project called <kbd>CH05.ControlBehaviorDemo</kbd>, based on the WPF application template.</p>
<h2 id="uuid-1a0f8570-d48a-4f81-9a12-840a6f9d6f27">How to do it...</h2>
<p>Let's start by creating a component which will add a <span class="packt_screen">Size Grow</span> effect to a <kbd>TextBlock</kbd> control when hovering over with the mouse cursor. To do this, perform the following steps:</p>
<ol>
<li>To create and/or use behaviors in an application, you will need to set up the project to have a reference to the <kbd>System.Windows.Interactivity.dll</kbd> assembly file. To do this, right-click on the project and click <span class="packt_screen">Add</span> | <span class="packt_screen">Reference...</span> from the context menu.</li>
<li>From the <span class="packt_screen">Reference Manager</span> dialog, search for <kbd>interactivity</kbd> to find the <span class="packt_screen">System.Windows.Interactivity</span> assembly in the list of assemblies. Select the latest version, as shown in the following screenshot, and click <span class="packt_screen">OK</span>. Make sure you verify the added reference in the project:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/574ed872-afeb-4caf-b34d-075acacafd4a.png" style=""/></div>
<ol start="3">
<li>Now open the <kbd>MainWindow.xaml</kbd> page and add a <kbd>TextBlock</kbd> control inside the default <kbd>Grid</kbd>. Assign a string to its <kbd>Text</kbd> property:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;TextBlock Text="Hover to Grow the size!" 
               HorizontalAlignment="Center" 
               VerticalAlignment="Center"&gt; 
 
    &lt;/TextBlock&gt; 
&lt;/Grid&gt;</pre>
<ol start="4">
<li>If you run the application now, it will have a text in the window. Hovering your mouse on top of that will not have any effect. For that, we need to create the behavior and register it with the <kbd>TextBlock</kbd> control.</li>
<li>Let's create a new class, called <kbd>GrowTextBehavior</kbd>, inside the project.</li>
<li>Mark the class as <kbd>public</kbd> and extend it from the <kbd>Behavior</kbd> class. As we are going to create this component for <kbd>TextBlock</kbd> control, we will extend the class from <kbd>Behavior&lt;TextBlock&gt;</kbd>, as shown here:</li>
</ol>
<pre style="padding-left: 90px">public class GrowTextBehavior : Behavior&lt;TextBlock&gt; </pre>
<ol start="7">
<li>You will need to add the <kbd>System.Windows.Interactivity</kbd> namespace as a <kbd>using</kbd> statement to resolve the class declaration. Alternatively, you can resolve the namespace by clicking the light bulb and selecting <span class="packt_screen">using System.Windows.Interactivity;</span>, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/211aab62-d442-40a2-92e0-0073c15351a2.png"/></div>
<ol start="8">
<li>Add a <kbd>public</kbd> property inside the class to take dynamic input of the size to grow by. Give it a name:</li>
</ol>
<pre style="padding-left: 90px">public int GrowBySize { get; set; } </pre>
<ol start="9">
<li>Now, inside the class, type <kbd>override</kbd> and enter a space. From the list of overridable methods, select <kbd>OnAttached</kbd> and hit the <em><span class="KeyPACKT">Enter</span></em> key. This will override the <kbd>OnAttached()</kbd> method inside the class.</li>
</ol>
<p> </p>
<ol start="10">
<li>Similarly, override the method <kbd>OnDetaching()</kbd> inside the class.</li>
<li>Inside <kbd>OnAttached()</kbd>, register the <kbd>MouseEnter</kbd> and <kbd>MouseLeave</kbd> events for the associated object, which is a <kbd>TextBlock</kbd> in our case. Similarly, inside the <kbd>OnDetaching()</kbd>, unregister the preceding two events. Here's the code that you may like to take as reference:</li>
</ol>
<pre style="padding-left: 90px">protected override void OnAttached() 
{ 
    base.OnAttached(); 
 
    AssociatedObject.MouseEnter +=  
                     AssociatedObject_MouseEnter; 
    AssociatedObject.MouseLeave +=  
                     AssociatedObject_MouseLeave; 
} 
 
protected override void OnDetaching() 
{ 
    base.OnDetaching(); 
 
    AssociatedObject.MouseEnter -=  
                     AssociatedObject_MouseEnter; 
    AssociatedObject.MouseLeave -=  
                     AssociatedObject_MouseLeave; 
} </pre>
<ol start="12">
<li>Now it's time to write our logic to grow and shrink the size of the associated <kbd>TextBlock</kbd> control on mouse over and mouse leave events, respectively. To do so, add the following code block inside the class:</li>
</ol>
<pre style="padding-left: 90px">private void AssociatedObject_MouseLeave(object sender,  
 MouseEventArgs e) 
{ 
    AssociatedObject.FontSize -= GrowBySize; 
} 
 
private void AssociatedObject_MouseEnter(object sender,  
  MouseEventArgs e) 
{ 
    AssociatedObject.FontSize += GrowBySize; 
}</pre>
<ol start="13">
<li>That ends the implementation of the behavior component for our <kbd>TextBlock</kbd> control. Now it's time to register it with the control in the UI. To do so, open the <kbd>MainWindow.xaml</kbd> again and add the following XMLNS namespace declaration:</li>
</ol>
<pre style="padding-left: 90px"> </pre>
<ol start="14">
<li>Now modify the <kbd>TextBlock</kbd> control to register the association with the behavior component that we created. Replace the existing markup with the following:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;TextBlock Text="Hover to Grow the size!" 
               HorizontalAlignment="Center" 
               VerticalAlignment="Center"&gt; 
        &lt;i:Interaction.Behaviors&gt; 
            &lt;b:GrowTextBehavior GrowBySize="10"/&gt; 
        &lt;/i:Interaction.Behaviors&gt; 
    &lt;/TextBlock&gt; 
&lt;/Grid&gt; </pre>
<ol start="15">
<li>Let's build the application and run it. You will see a text message in the application window. Hover over it to see the growing effect on its size:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/66f3007f-9f4b-485c-bd88-12ff030353eb.png"/></div>
<ol start="16">
<li>Take your mouse away from the text to see how it moves back to the original state.</li>
</ol>
<h2 id="uuid-746d3694-8c39-498d-9a1b-997d118aa3e4">How it works...</h2>
<p>The property, <kbd>AssociatedObject</kbd>, returns the object to which the <kbd>System.Windows.Interactivity.Behavior</kbd> is attached. In our case, it's the <kbd>TextBlock</kbd> control passed as <kbd>Behavior</kbd> of type <kbd>T</kbd> (<kbd>Behavior&lt;TextBlock&gt;</kbd>), which is associated in the XAML code block, as mentioned here:</p>
<pre style="padding-left: 60px">&lt;TextBlock Text="Hover to Grow the size!" 
           HorizontalAlignment="Center" 
           VerticalAlignment="Center"&gt; 
    &lt;i:Interaction.Behaviors&gt; 
        &lt;b:GrowTextBehavior GrowBySize="10"/&gt; 
    &lt;/i:Interaction.Behaviors&gt; 
&lt;/TextBlock&gt; </pre>
<p>When the association happens between the control and the component, it registers the two events (<kbd>MouseEnter</kbd> and <kbd>MouseLeave</kbd>) in our example. Now, when you hover over the mouse on top of the <kbd>TextBlock</kbd>, it gets the dynamic association of the events and triggers them. This way, it gets notification of the event and performs based on the logic specified.</p>
<p>You can now associate this behavior to any number of controls of type <kbd>TextBlock</kbd>, without writing additional code behind. The XAML designers can easily pick and associate it with the controls that they want to provide a grow effect on mouse hover.</p>
<div class="packt_tip">If you want to associate the behavior to any control, you need to extend it from <kbd>Behavior</kbd>, instead of <kbd>Behavior&lt;TextBlock&gt;</kbd>. Similarly, to change the type to any other specific control (let's say, <kbd>Label</kbd>), change the <kbd>T</kbd> to <kbd>Label</kbd> as shown here—<kbd>Behavior&lt;Label&gt;</kbd>.</div>
<h1 id="uuid-da55726b-d877-4b63-8c6a-632ce7f6fb34">Creating a User Control interface</h1>
<p>Typically, a User Control is a group of elements and controls joined together to create a reusable component. This is often used to show the same UI in multiple places, either on the same window or in a different window.</p>
<p>In this recipe, we will learn how to create a User Control interface with all its typical features.</p>
<h2 id="uuid-5d78c2f9-ba52-4906-af2a-33665b801891">Getting ready</h2>
<p>Get started by creating a new project. Open the Visual Studio IDE and create a new project based on the WPF application template. Name it <kbd>CH05.UserControlDemo</kbd>.</p>
<h2 id="uuid-9759e4c6-2bc1-4caf-97d4-cd5ad0849adf">How to do it...</h2>
<p>To demonstrate the complete use of User Control, we will be creating a color mixer control, exposing some properties from it and binding data using converters. Perform the following simple steps:</p>
<ol>
<li>Once the project has been created, add a new User Control element inside the project. To do this, right-click on the project and select <span class="packt_screen">Add</span> | <span class="packt_screen">User Control...</span> from the context menu entry.</li>
<li>From the <span class="packt_screen">Add New Item</span> dialog, select <span class="packt_screen">User Control (WPF)</span> as the template to create a blank User Control. Name the control <kbd>ColorMixer</kbd>. Click on the <span class="packt_screen">Add</span> button to create a User Control file called <kbd>ColorMixer.xaml</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2f3450ec-69e5-4d1e-874b-eb23d9ffed82.png"/></div>
<ol start="3">
<li>Once the User Control has been created, open the code-behind file (<kbd>ColorMixer.xaml.cs</kbd>) and add a property <kbd>SelectedColor</kbd> of type <kbd>Color</kbd> inside it. Give it a default color (let's say, <kbd>Colors.OrangeRed</kbd>):</li>
</ol>
<pre style="padding-left: 90px">public Color SelectedColor 
{ 
    get { return (Color)GetValue(SelectedColorProperty); } 
    set { SetValue(SelectedColorProperty, value); } 
} 
 
public static readonly DependencyProperty  
       SelectedColorProperty = 
    DependencyProperty.Register("SelectedColor",  
    typeof(Color), typeof(ColorMixer),  
    new PropertyMetadata(Colors.OrangeRed)); </pre>
<ol start="4">
<li>Let's open the <kbd>ColorMixer.xaml</kbd> file to provide a UI to the control. We will be adding four <kbd>TextBox</kbd> controls to assign the color in RGB mode (Red, Green, Blue, and Alpha) and a <kbd>Border</kbd> to show the output from the RGB mixer.</li>
<li>First, give the User Control a name, so that we can easily set its <kbd>DataContext</kbd> to access its code-behind properties. To do this, add the attribute <kbd>x:Name="userControl"</kbd> to the <kbd>UserControl</kbd> tag.</li>
<li>Set the <kbd>DataContext</kbd> of the <kbd>Grid</kbd> to have an element binding. Add the following attribute inside the <kbd>Grid</kbd> tag:</li>
</ol>
<pre style="padding-left: 90px">DataContext="{Binding ElementName=userControl}" </pre>
<ol start="7">
<li>Now let's divide the default <kbd>Grid</kbd> panel into a few rows and columns. Copy the following row and column definitions inside the <kbd>Grid</kbd> tag to create the structure:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid.RowDefinitions&gt; 
    &lt;RowDefinition Height="*"/&gt; 
    &lt;RowDefinition Height="Auto"/&gt; 
&lt;/Grid.RowDefinitions&gt; 
&lt;Grid.ColumnDefinitions&gt; 
    &lt;ColumnDefinition Width="*"/&gt; 
    &lt;ColumnDefinition Width="Auto"/&gt; 
&lt;/Grid.ColumnDefinitions&gt;</pre>
<ol start="8">
<li>Now it's time to add the controls inside the <kbd>Grid</kbd> to create the UI layout of our User Control. Add a <kbd>Border</kbd> at the first cell of the <kbd>Grid</kbd> and bind its <kbd>Background</kbd> property with the <kbd>SelectedColor</kbd> property of the User Control that we have created:</li>
</ol>
<pre style="padding-left: 90px">&lt;Border BorderThickness="1" BorderBrush="Gray" 
        Grid.Row="0" Grid.Column="0"&gt; 
    &lt;Border.Background&gt; 
        &lt;SolidColorBrush Color="{Binding SelectedColor}"/&gt; 
    &lt;/Border.Background&gt; 
&lt;/Border&gt; </pre>
<ol start="9">
<li>Now add a <kbd>StackPanel</kbd> inside the second cell of the <kbd>Grid</kbd>, which is <kbd>Row=0</kbd>, <kbd>Column=1</kbd>. Add four <kbd>TextBox</kbd> controls and their associated labels inside the panel. Here's the XAML block, which you can copy and place just after the <kbd>Border</kbd> control:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Vertical" 
            Grid.Row="0" Grid.Column="1" 
            Margin="8 4"&gt; 
    &lt;TextBlock Text="R:"/&gt; 
    &lt;TextBox Width="100" /&gt; 
    &lt;TextBlock Text="G:"/&gt; 
    &lt;TextBox Width="100" /&gt; 
    &lt;TextBlock Text="B:"/&gt; 
    &lt;TextBox Width="100" /&gt; 
    &lt;TextBlock Text="A:"/&gt; 
    &lt;TextBox Width="100" /&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="10">
<li>As the basic UI design is ready, let's place the User Control inside the application window. Open <kbd>MainWindow.xaml</kbd> and add the following XMLNS attribute to the <kbd>Window</kbd> tag:</li>
</ol>
<pre style="padding-left: 90px"> </pre>
<ol start="11">
<li>Now replace the default <kbd>Grid</kbd> panel with a <kbd>StackPanel</kbd>, so that we can place multiple controls in a stack.</li>
</ol>
<p> </p>
<ol start="12">
<li>Place <kbd>&lt;local:ColorMixer /&gt;</kbd> inside the <kbd>StackPanel</kbd> and run the application. You will see the following UI on the screen:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/41af04f9-673f-4e92-9180-8acf3c9e0061.png"/></div>
<ol start="13">
<li>The main advantage of a User Control is its ease of use. Creating many instances of it is easy, and there is full design-time support in Visual Studio. Similar to the preceding point, if you place multiple controls of the <kbd>ColorMixer</kbd> instance inside the <kbd>StackPanel</kbd>, you will see multiple copies in the UI. Let's not do it, but if you want to try, replace the entire <kbd>StackPanel</kbd> with the following code block and check out how it places the controls:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Horizontal" 
   Margin="4"&gt; 
    &lt;local:ColorMixer /&gt; 
    &lt;local:ColorMixer /&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="14">
<li>Now let's add the bindings to the <kbd>TextBox</kbd> controls with the <kbd>SelectedColor</kbd> property. As the type of the property is <kbd>Color</kbd>, we will need to create a value converter. So, right-click on the project and add a class by following the context menu path <span class="packt_screen">Add</span> | <span class="packt_screen">Class...</span>,   name it <kbd>ColorToByteConverter</kbd>, and hit <span class="packt_screen">OK</span>.</li>
<li>As we need to access the class from the XAML, we will need to mark it as <kbd>public</kbd>.</li>
</ol>
<p> </p>
<ol start="16">
<li>Now inherit the class from <kbd>IValueConverter</kbd>, to make it a value converter. Click on the lightbulb icon, as shown in the following screenshot, and resolve the namespace. Alternatively, you can add the <kbd>using</kbd> statement to resolve the <kbd>System.Windows.Data</kbd> namespace:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/17e5bdf8-e0eb-4d92-9db4-24814efc9dd4.png"/></div>
<ol start="17">
<li>Now click on the light bulb again and implement the interface. It will add two methods, called <kbd>Convert</kbd> and <kbd>ConvertBack</kbd>, inside the class, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/308c1add-f04a-4fec-9f02-70e575bed35a.png"/></div>
<ol start="18">
<li>Replace the <kbd>Convert</kbd> method with the following code block, which will break the specified color into an RGBA byte value:</li>
</ol>
<pre style="padding-left: 90px">public object Convert(object value,  
                      Type targetType,  
                      object parameter,  
                      CultureInfo culture) 
{ 
    if (value is Color color &amp;&amp;  
      parameter is string parameterValue) //C# 7.x syntax 
    { 
        oldColor = color; 
 
        switch (parameterValue) 
        { 
            case "r": 
                return color.R; 
 
            case "g": 
                return color.G; 
 
            case "b": 
                return color.B; 
 
            default: 
                return color.A; 
        } 
    } 
 
    return value; 
} </pre>
<ol start="19">
<li>Similarly, replace the <kbd>ConvertBack</kbd> method to construct the <kbd>Color</kbd> object from the RGBA values, which you can enter by the <kbd>TextBox.Text</kbd> property:</li>
</ol>
<pre style="padding-left: 90px">public object ConvertBack(object value,  
                          Type targetType,  
                          object parameter,  
                          CultureInfo culture) 
{ 
    var color = oldColor; 
    var colorValue = System.Convert.ToByte(value); 
 
    if (parameter is string parameterValue) //C# 7.x syntax 
    { 
        switch (parameterValue) 
        { 
            case "r": 
                color.R = (byte)colorValue; 
                break; 
 
            case "g": 
                color.G = (byte)colorValue; 
                break; 
 
            case "b": 
                color.B = (byte)colorValue; 
                break; 
 
            default: 
                color.A = (byte)colorValue; 
                break; 
        } 
    } 
 
    oldColor = color; 
    return color; 
} </pre>
<ol start="20">
<li>Once this is done, open the <kbd>ColorMixer.xaml</kbd> file and add the following XMLNS attribute under the <kbd>UserControl</kbd> tag:</li>
</ol>
<pre style="padding-left: 90px"> </pre>
<ol start="21">
<li>Now create a <kbd>&lt;UserControl.Resources&gt;</kbd> tag inside the <kbd>UserControl</kbd> element and register the value converter as a resource. Here's the code that you can copy inside the <kbd>UserControl</kbd> tag:</li>
</ol>
<pre style="padding-left: 90px">&lt;UserControl.Resources&gt; 
    &lt;local:ColorToByteConverter  
         x:Key="ColorToByteConverter"/&gt; 
&lt;/UserControl.Resources&gt;</pre>
<ol start="22">
<li>Let's modify the <kbd>Text</kbd> property of all the four <kbd>TextBox</kbd> controls to have a <kbd>TwoWay</kbd> data binding with the <kbd>SelectedColor</kbd> property, and associate them with the converter that we have added. Pass the proper parameter to the converter, as <kbd>ConverterParameter</kbd>, as mentioned in the following code. You can copy the following code and replace the existing <kbd>StackPanel</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Vertical" 
            Grid.Row="0" Grid.Column="1" 
            Margin="8 4"&gt; 
    &lt;TextBlock Text="R:"/&gt; 
    &lt;TextBox Width="100" 
             Text="{Binding SelectedColor, Converter={StaticResource ColorToByteConverter}, ConverterParameter=r, Mode=TwoWay}"/&gt; 
    &lt;TextBlock Text="G:"/&gt; 
    &lt;TextBox Width="100" 
             Text="{Binding SelectedColor, Converter={StaticResource ColorToByteConverter}, ConverterParameter=g, Mode=TwoWay}"/&gt; 
    &lt;TextBlock Text="B:"/&gt; 
    &lt;TextBox Width="100" 
             Text="{Binding SelectedColor, Converter={StaticResource ColorToByteConverter}, ConverterParameter=b, Mode=TwoWay}"/&gt; 
    &lt;TextBlock Text="A:"/&gt; 
    &lt;TextBox Width="100" 
             Text="{Binding SelectedColor, Converter={StaticResource ColorToByteConverter}, ConverterParameter=a, Mode=TwoWay}"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="23">
<li>At the end, build the project and run the application. You will see the following UI on the screen, where the rectangular <kbd>Border</kbd> control has an <kbd>OrangeRed</kbd> background and the associated <kbd>TextBox</kbd> control has the RGBA byte value of the color:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/89588051-ed78-4bbe-8bc9-199527a6bdd8.png"/></div>
</li>
<li>Now modify the values of the <kbd>TextBox</kbd> controls to have a range (<kbd>0</kbd>–<kbd>255</kbd>) between <kbd>0</kbd> to <kbd>255</kbd> and press <em><span class="KeyPACKT">TAB</span></em> to reflect the change in the UI. Let's replace the values, Red by <kbd>120</kbd>, Green by <kbd>75</kbd>, Blue by <kbd>200</kbd>, and Alpha by <kbd>77</kbd>, as shown in the following screenshot, which will result in a light violet background color for the <kbd>Border</kbd> control:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/043161f3-c872-45c4-97a8-b13f24ee0b50.png"/></div>
</li>
</ol>
<h2 id="uuid-4e8ad0fb-9466-46b0-9509-f1f829c6f79e">How it works...</h2>
<p>A User Control wraps the UI with appropriate properties and events to make it a reusable component. In this User Control, named <kbd>ColorMixer</kbd>, we created a dependency property called <kbd>SelectedColor</kbd> of type <kbd>Color</kbd>.  The user (the developer or the designer) can also set a default value to it, by accessing the property, while adding it to the application UI.</p>
<p>The <kbd>Text</kbd> property of the <kbd>TextBox</kbd> controls, inside the <kbd>ColorMixer.xaml</kbd>, is bound with the <kbd>SelectedColor</kbd> property. As the types of <kbd>Text</kbd> and <kbd>SelectedColor</kbd> properties are different, we required the value converter here.</p>
<p><kbd>ConverterParameter</kbd> is used to define whether we need to break the R, G, B, or A value of the color composition. The <kbd>Convert</kbd> method of the converter class breaks the color according to the parameter and returns, which gets displayed in the appropriate <kbd>TextBox</kbd> control:</p>
<pre style="padding-left: 60px">switch (parameterValue) 
{ 
    case "r": 
        return color.R; 
 
    case "g": 
        return color.G; 
 
    case "b": 
        return color.B; 
 
    default: 
        return color.A; 
} </pre>
<p>Similarly, when you modify the value in the <kbd>TextBox</kbd>, due to its <kbd>TwoWay</kbd> binding mode, the <kbd>ConvertBack</kbd> method of the converter triggers. This constructs the color object based on the values available in all the <kbd>TextBox</kbd> controls and returns, which gets filled in the <kbd>SelectedColor</kbd> property and reflects in the <kbd>Background</kbd> property of the <kbd>Border</kbd> control.</p>
<h1 id="uuid-042d0600-4041-4b27-b607-33f98209b091">Exposing events from a User Control</h1>
<p>In the previous recipe, we learned about User Control, how to create it, and how to expose a dependency property and utilize it. In this recipe, we will learn how to expose events from a User Control, as you will need it in most cases.</p>
<h2 id="uuid-25a55b44-336f-4ab2-83fb-a43662b5656c">Getting ready</h2>
<p>Let's open the same project, <kbd>CH05.UserControlDemo</kbd>, inside the Visual Studio to proceed with this recipe.</p>
<h2 id="uuid-7fb32ebe-db4d-404f-86e1-ef08b360f50a">How to do it...</h2>
<p>To demonstrate the usage of the event, we will add two buttons inside our <kbd>ColorMixer</kbd> User Control and expose the <kbd>OK</kbd> and <kbd>Cancel</kbd> button events from it. To implement the same, perform the following steps:</p>
<ol>
<li>Open the <kbd>ColorMixer.xaml</kbd> file and add the following <kbd>StackPanel</kbd> inside the <kbd>Grid</kbd>, which will place it at row index <kbd>1</kbd> and column index <kbd>0</kbd>. The panel consists of two buttons with labels <kbd>OK</kbd> and <kbd>Cancel:</kbd></li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Horizontal" 
            Grid.Row="1" Grid.Column="0" 
            Grid.ColumnSpan="2" 
            Margin="4 10 4 4" 
            HorizontalAlignment="Right"&gt; 
    &lt;Button Content="OK" Margin="4" 
            Width="50" Click="OnOkClicked"/&gt; 
    &lt;Button Content="Cancel" Margin="4" 
            Width="50" Click="OnCancelClicked"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="2">
<li>Open the <kbd>ColorMixer.xaml.cs</kbd> file and register the button click events (<kbd>OnOkClicked</kbd> and <kbd>OnCancelClicked</kbd>) inside it.</li>
<li>Inside the <kbd>ColorMixer</kbd> class, register the following two delegates and events to handle the <span class="packt_screen">OK</span> and <span class="packt_screen">Cancel</span> button events from outside the control:</li>
</ol>
<pre style="padding-left: 90px">public delegate void OnOkButtonClick(object sender,  
 EventArgs e); 
public delegate void OnCancelButtonClick(object sender,  
 EventArgs e); 
 
public event OnOkButtonClick OkButtonClick; 
public event OnCancelButtonClick CancelButtonClick; </pre>
<ol start="4">
<li>Now update the <kbd>OK</kbd> button and the <kbd>Cancel</kbd> button event handlers to route the event to the place where the control has been used. Here's the code to replace the button click event implementations:</li>
</ol>
<pre style="padding-left: 90px">private void OnOkClicked(object sender, RoutedEventArgs e) 
{ 
    OkButtonClick?.Invoke(sender, e); 
} 
 
private void OnCancelClicked(object sender, RoutedEventArgs e) 
{ 
    CancelButtonClick?.Invoke(sender, e); 
} </pre>
<ol start="5">
<li>To register the associated events, in the application window, open the <kbd>MainWindow.xaml</kbd> file and register the <kbd>OkButtonClick</kbd> and <kbd>CancelButtonClick</kbd> events as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;local:ColorMixer OkButtonClick="OnOkClicked" 
                  CancelButtonClick="OnCancelClicked"/&gt; </pre>
<ol start="6">
<li>Navigate to the <kbd>MainWindow.xaml.cs</kbd> file to implement the associated event handlers. As shared in the following code, show a message box to the UI from the event implementation:</li>
</ol>
<pre style="padding-left: 90px">private void OnOkClicked(object sender, EventArgs e) 
{ 
    MessageBox.Show("OK button clicked"); 
} 
 
private void OnCancelClicked(object sender, EventArgs e) 
{ 
    MessageBox.Show("Cancel button clicked"); 
} </pre>
<ol start="7">
<li>Let's compile the project and run the application. You will see two buttons on the UI. Click on the <span class="packt_screen">OK</span> and <span class="packt_screen">Cancel</span> buttons to see the output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a7ae542f-1d24-4f4c-8590-0cf82e0397c5.png"/></div>
<h2 id="uuid-e14a8625-18d8-49df-82d1-b1a507d11b7b">How it works...</h2>
<p>When you hit the <span class="packt_screen">OK</span> button in the application window, it triggers the event associated with the button click. In our case, it's the <kbd>OnOkClicked</kbd> event, inside the <kbd>ColorMixer</kbd> class. It then routes the event to the custom event <kbd>OkButtonClick</kbd>, which gets caught in the originating place. It's the <kbd>OnOkClicked</kbd> event listener in our <kbd>MainWindow.xaml</kbd>.</p>
<p>Similarly, when you click on the <span class="packt_screen">Cancel</span> button, it raises the <kbd>Click</kbd> event inside the <kbd>ColorMixer</kbd> class and then routes to the <kbd>MainWindow</kbd>. If the association is present, it gets called. In our case, it's the <kbd>OnCancelClicked</kbd> handler in <kbd>MainWindow</kbd> which triggers the message box.</p>
<h1 id="uuid-2ef0afee-d4c1-4ba5-a394-91397de8eeda">Customizing the XMLNS namespace</h1>
<p>XAML namespace is an extension of XML namespace and conventionally written as <kbd>xmlns</kbd> in XAML pages. It is used in all the XAML-related technologies to refer to the assemblies and/or namespaces within the XAML page.</p>
<p>Till now, we have seen how to add the XMLNS attribute entry in XAML to refer to custom controls, User Controls, converters, behaviors, and so on, but all that used an assembly/namespace system to define the entry.</p>
<p>For local declaration, we use the <kbd>clr-namespace:[namespace]</kbd> format, as shown in the following code:</p>
<pre style="padding-left: 60px"> </pre>
<p>For declarations from a different assembly, we use the <kbd>clr-namespace:[namespace];assembly=[assembly]</kbd> format, as shown in the following code:</p>
<pre style="padding-left: 60px"> </pre>
<p>In this recipe, we will learn how to customize the namespace to give a URL representation.</p>
<h2 id="uuid-3ae28b40-7a98-4fdb-8f28-fedc931ead66">Getting ready</h2>
<p>Let's get started by creating a project called <kbd>CH05.NamespaceCustomizationDemo</kbd>. In this example, you can either choose a WPF application template or a WPF class library template.</p>
<h2 id="uuid-281ea985-651e-47a2-80a9-8d2435870c47">How to do it...</h2>
<p>Perform the following steps steps to proceed:</p>
<ol>
<li>Let's create two folders, called <kbd>Behaviors</kbd> and <kbd>Converters</kbd>, inside the project.</li>
<li>Now create one or more behaviors and converters in the respective folders. These will have <kbd>CH05.NamespaceCustomizationDemo.Behaviors</kbd> and <kbd>CH05.NamespaceCustomizationDemo.Converters</kbd> as the namespace for all the behaviors and converters in the respective modules.</li>
<li>To create the URL schema for the namespace representation, open the <kbd>AssemblyInfo.cs</kbd> file present in the <kbd>Properties</kbd> folder of each project.</li>
<li>Now, to create the schema to represent the namespace of the behaviors (<kbd>CH05.NamespaceCustomizationDemo.Behaviors</kbd>), let's add the following inside the file:</li>
</ol>
<pre style="padding-left: 90px">[assembly: XmlnsPrefix("http://schemas.kunal-chowdhury.com/xaml/behaviors", "behaviors")] 
 
[assembly: XmlnsDefinition("http://schemas.kunal-chowdhury.com/xaml/behaviors", "CH05.NamespaceCustomizationDemo.Behaviors")] </pre>
<ol start="5">
<li>Similarly, to define the URL schema for the converters (<kbd>CH05.NamespaceCustomizationDemo.Behaviors</kbd>), add the following inside the same file:</li>
</ol>
<pre style="padding-left: 90px">[assembly: XmlnsPrefix("http://schemas.kunal-chowdhury.com/xaml/converters", "converters")] 
 
[assembly: XmlnsDefinition("http://schemas.kunal-chowdhury.com/xaml/converters", "CH05.NamespaceCustomizationDemo.Converters")]</pre>
<ol start="6">
<li>Navigate to the <kbd>MainWindow.xaml</kbd> file. To add the XMLNS declaration, you can write <kbd/> instead of <kbd/>.</li>
<li>It is a similar case for all the declarations that you have made in the <kbd>AssemblyInfo.cs</kbd> file to represent the namespace as a URL schema.</li>
</ol>
<h2 id="uuid-e4fad2dd-fdfe-458c-9627-01505aee1c82">How it works...</h2>
<p>The <kbd>XmlnsPrefix</kbd> attribute defines the prefix name that you suggest using in the XAML, while declaring the module namespace. Though it is optional to use the same prefix name,  while using the Visual Studio IntelliSense, it automatically adds it.</p>
<p>When you define the XML namespace as URL format, it has multiple benefits over the traditional representation:</p>
<ul>
<li>If you follow the same structure, it is easy to remember.</li>
<li>When you are using custom libraries, you don't have to write the complete namespace and assembly every time in each file. Thus, uses of <kbd/> can be reduced to <kbd/>.</li>
<li>You can define the prefix, so that you can follow the same convention in all the files while defining the XMLNS attribute.</li>
</ul>


            </article>

            
        </section>
    </body></html>