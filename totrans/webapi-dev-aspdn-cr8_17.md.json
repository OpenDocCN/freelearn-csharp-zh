["```cs\npublic class Invoice{\n    public int Id { get; private set; } // Aggregate root Id, which should not be changed once it is set\n    public DateTime Date { get; set; }\n    public InvoiceStatus Status { get; private set; }\n    public decimal Total { get; private set; } // The total amount of the invoice, which should be updated when an item is added or removed, but cannot be changed directly\n    // Other properties\n    public List<InvoiceItem> Items { get; private set; }\n    public void AddItem(InvoiceItem item)\n    {\n        // Add the item to the invoice\n        Items.Add(item);\n        // Update the invoice total, etc.\n        // ...\n    }\n    public void RemoveItem(InvoiceItem item)\n    {\n        // Remove the item from the invoice\n        Items.Remove(item);\n        // Update the invoice total, etc.\n        // ...\n    }\n    public void Close()\n    {\n        // Close the invoice\n        Status = InvoiceStatus.Closed;\n    }\n}\n```", "```cs\npublic interface IInvoiceRepository{\n    Task<Invoice> GetByIdAsync(Guid id);\n    Task<List<Invoice>> GetByCustomerIdAsync(Guid customerId);\n    Task AddAsync(Invoice invoice);\n    Task UpdateAsync(Invoice invoice);\n    Task DeleteAsync(Invoice invoice);\n}\n```", "```cs\npublic class TransferService{\n    private readonly IAccountRepository _accountRepository;\n    private readonly ITransactionRepository _transactionRepository;\n    private readonly INotificationService _notificationService;\n    private readonly IBankTransferService _bankTransferService;\n    public TransferService(IAccountRepository accountRepository, ITransactionRepository transactionRepository, INotificationService notificationService, IBankTransferService bankTransferService)\n    {\n        _accountRepository = accountRepository;\n        _transactionRepository = transactionRepository;\n        _notificationService = notificationService;\n        _bankTransferService = bankTransferService;\n    }\n    public async Task TransferAsync(Guid fromAccountId, Guid toAccountId, decimal amount)\n    {\n        // Get the account from the repository\n        var fromAccount = await _accountRepository.GetByIdAsync(fromAccountId);\n        var toAccount = await _accountRepository.GetByIdAsync(toAccountId);\n        // Transfer money between the accounts\n        fromAccount.Withdraw(amount);\n        toAccount.Deposit(amount);\n        // Save the changes to the repository\n        await _accountRepository.UpdateAsync(fromAccount);\n        await _accountRepository.UpdateAsync(toAccount);\n        // Create transaction records\n        await _transactionRepository.AddAsync(new Transaction\n        {\n            FromAccountId = fromAccountId,\n            ToAccountId = toAccountId,\n            Amount = amount,\n            Date = DateTime.UtcNow\n        });\n        await _transactionRepository.AddAsync(new Transaction\n        {\n            FromAccountId = toAccountId,\n            ToAccountId = fromAccountId,\n            Amount = -amount,\n            Date = DateTime.UtcNow\n        });\n        // Send a notification to the account holder\n        await _notificationService.SendAsync(fromAccount.HolderId, $\"You have transferred {amount}to {toAccount.HolderId}\");\n        await _notificationService.SendAsync(toAccount.HolderId, $\"You have received {amount} from{fromAccount.HolderId}\");\n        // Transfer money between the banks\n        // await _bankTransferService.TransferAsync(fromAccount.BankId, toAccount.BankId, amount);\n    }\n}\n```", "```cs\n[Route(\"api/[controller]\")][ApiController]\npublic class InvoicesController : ControllerBase\n{\n    private readonly IInvoiceService _invoiceService;\n    public InvoicesController(IInvoiceService invoiceService)\n    {\n        _invoiceService = invoiceService;\n    }\n    [HttpPost]\n    public async Task<IActionResult> CreateAsync(InvoiceDto invoiceDto)\n    {\n        var invoice = await _invoiceService.CreateAsync(invoiceDto);\n        return Ok(invoice);\n    }\n    // Omitted other methods\n}\npublic interface IInvoiceService\n{\n    Task<InvoiceDto> CreateAsync(InvoiceDto invoiceDto);\n    // Omitted other methods\n}\npublic class InvoiceService : IInvoiceService\n{\n    private readonly IInvoiceRepository _invoiceRepository;\n    private readonly IMapper _mapper;\n    public InvoiceService(IInvoiceRepository invoiceRepository, IMapper mapper)\n    {\n        _invoiceRepository = invoiceRepository;\n        _mapper = mapper;\n    }\n    public async Task<InvoiceDto> CreateAsync(InvoiceDto invoiceDto)\n    {\n        var invoice = _mapper.Map<Invoice>(invoiceDto);\n        await _invoiceRepository.AddAsync(invoice);\n        return _mapper.Map<InvoiceDto>(invoice);\n    }\n    // Omitted other methods\n}\n```", "```cs\npublic interface IInvoiceService{\n    Task<InvoiceDto?> GetAsync(Guid id, CancellationToken cancellationToken = default);\n    Task<List<InvoiceWithoutItemsDto>> GetPagedListAsync(int pageIndex, int pageSize, CancellationToken cancellationToken = default);\n    Task<InvoiceDto> AddAsync(CreateOrUpdateInvoiceDto invoice, CancellationToken cancellationToken = default);\n    Task<InvoiceDto?> UpdateAsync(Guid id, CreateOrUpdateInvoiceDto invoice, CancellationToken cancellationToken = default);\n    // Omitted\n}\n```", "```cs\npublic InvoiceProfile(){\n    CreateMap<CreateOrUpdateInvoiceItemDto, InvoiceItem>();\n    CreateMap<InvoiceItem, InvoiceItemDto>();\n    CreateMap<CreateOrUpdateInvoiceDto, Invoice>();\n    CreateMap<Invoice, InvoiceWithoutItemsDto>();\n    CreateMap<Invoice, InvoiceDto>();\n}\n```", "```cs\nbuilder.Services.AddAutoMapper(typeof(InvoiceProfile));\n```", "```cs\npublic class InvoiceService(IInvoiceRepository invoiceRepository, IMapper mapper) : IInvoiceService{\n    public async Task<InvoiceDto?> GetAsync(Guid id, CancellationToken cancellationToken = default)\n    {\n        var invoice = await invoiceRepository.GetAsync(id, cancellationToken);\n        return invoice == null ? null : mapper.Map<InvoiceDto>(invoice);\n    }\n    // Omitted\n}\n```", "```cs\n    MediatR package to the CqrsDemo.Core project and the CqrsDemo.WebApi project.`MediatR` provides the following interfaces:*   `IMediator`: This is the main interface of the `MediatR` library. It can be used to send requests to the handlers. It can also be used to publish events to multiple handlers.*   `ISender`: This interface is used to send a request through the mediator pipeline to be handled by a single handler.*   `IPublisher`: This interface is used to publish a notification or event through the mediator pipeline to be handled by multiple handlers.The `IMediator` interface can be used to send all requests or events. For a clearer indication of the purpose of the request or event, it is recommended to use the `ISender` interface for requests handled by a single handler and the `IPublisher` interface for notifications or events that require multiple handlers.\n    ```", "```cs\n    public class GetInvoiceByIdQuery(Guid id) : IRequest<InvoiceDto?>{    public Guid Id { get; set; } = id;}\n    ```", "```cs\n    public class GetInvoiceListQuery(int pageIndex, int pageSize) : IRequest<List<InvoiceWithoutItemsDto>>{    public int PageIndex { get; set; } = pageIndex;    public int PageSize { get; set; } = pageSize;}\n    ```", "```cs\n    public class GetInvoiceByIdQueryHandler(IInvoiceService invoiceService) : IRequestHandler<GetInvoiceByIdQuery, InvoiceDto?>{    public Task<InvoiceDto?> Handle(GetInvoiceByIdQuery request, CancellationToken cancellationToken)    {        return invoiceService.GetAsync(request.Id, cancellationToken);    }}\n    ```", "```cs\n    public class GetInvoiceListQueryHandler(IInvoiceService invoiceService) : IRequestHandler<GetInvoiceListQuery, List<InvoiceWithoutItemsDto>>{    public Task<List<InvoiceWithoutItemsDto>> Handle(GetInvoiceListQuery request, CancellationToken cancellationToken)    {        return invoiceService.GetPagedListAsync(request.PageIndex, request.PageSize, cancellationToken);    }}\n    ```", "```cs\n    [Route(\"api/[controller]\")][ApiController]public class InvoicesController(IInvoiceService invoiceService, ISender mediatorSender) : ControllerBase{    // Omitted}\n    ```", "```cs\n    [HttpGet(\"{id}\")]public async Task<ActionResult<InvoiceDto>> GetInvoice(Guid id){    var invoice = await mediatorSender.Send(new GetInvoiceByIdQuery(id));    return invoice == null ? NotFound() : Ok(invoice);}\n    ```", "```cs\n    [HttpGet][Route(\"paged\")]public async Task<ActionResultIEnumerableInvoiceWithoutItemsDto>>> GetInvoices(int pageIndex, int pageSize){    var invoices = await mediatorSender.Send(new GetInvoiceListQuery(pageIndex, pageSize));    return Ok(invoices);}\n    ```", "```cs\n    builder.Services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(GetInvoiceByIdQueryHandler).Assembly));\n    ```", "```cs\n    public class CreateInvoiceCommand(CreateOrUpdateInvoiceDto invoice) : IRequest<InvoiceDto>{    public CreateOrUpdateInvoiceDto Invoice { get; set; } = invoice;}\n    ```", "```cs\n    public class CreateInvoiceCommandHandler(IInvoiceService invoiceService) : IRequestHandler<CreateInvoiceCommand, InvoiceDto>{    public Task<InvoiceDto> Handle(CreateInvoiceCommand request, CancellationToken cancellationToken)    {        return invoiceService.AddAsync(request.Invoice, cancellationToken);    }}\n    ```", "```cs\n    [HttpPost]public async Task<ActionResult<InvoiceDto>> CreateInvoice(CreateOrUpdateInvoiceDto invoice){    var result = await mediatorSender.Send(new CreateInvoiceCommand(invoice));    return CreatedAtAction(nameof(GetInvoice), new { id = result.Id }, result);}\n    ```", "```cs\n    public string ContactEmail { get; set; } = string.Empty;public string ContactPhone { get; set; } = string.Empty;\n    ```", "```cs\n    dotnet ef migrations add AddContactInfo --startup-project ../CqrsDemo.WebApi\n    ```", "```cs\n    dotnet ef database update --startup-project ../CqrsDemo.WebApi\n    ```", "```cs\n    public class SendInvoiceNotification(Guid invoiceId) : INotification{    public Guid InvoiceId { get; set; } = invoiceId;}\n    ```", "```cs\n    public class SendInvoiceEmailNotificationHandler(IInvoiceService invoiceService) : INotificationHandler<SendInvoiceNotification>{    public async Task Handle(SendInvoiceNotification notification, CancellationToken cancellationToken)    {        // Send email notification        var invoice = await invoiceService.GetAsync(notification.InvoiceId, cancellationToken);        if (invoice is null || string.IsNullOrWhiteSpace(invoice.ContactEmail))        {            return;        }        // Send email notification        Console.WriteLine($\"Sending email notification to {invoice.ContactEmail} for invoice {invoice.Id}\");    }}\n    ```", "```cs\n    public class SendInvoiceTextMessageNotificationHandler(IInvoiceService invoiceService) : INotificationHandler<SendInvoiceNotification>{    public async Task Handle(SendInvoiceNotification notification, CancellationToken cancellationToken)    {        // Send text message notification        var invoice = await invoiceService.GetAsync(notification.InvoiceId, cancellationToken);        if (invoice is null || string.IsNullOrWhiteSpace(invoice.ContactPhone))        {            return;        }        // Send text message notification        Console.WriteLine($\"Sending text message notification to {invoice.ContactPhone} for invoice {invoice.Id}\");    }}\n    ```", "```cs\n    public class InvoicesController(IInvoiceService invoiceService, ISender mediatorSender, IPublisher mediatorPublisher) : ControllerBase{    // Omitted}\n    ```", "```cs\n    [HttpPost]public async Task<ActionResult<InvoiceDto>> CreateInvoice(CreateOrUpdateInvoiceDto invoiceDto){    //var invoice = await invoiceService.AddAsync(invoiceDto);    var invoice = await mediatorSender.Send(new CreateInvoiceCommand(invoiceDto));    await mediatorPublisher.Publish(new SendInvoiceNotification(invoice.Id));    return CreatedAtAction(nameof(GetInvoice), new { id = invoice.Id }, invoice);}\n    ```", "```cs\ndotnet add package Polly.Core\n```", "```cs\nvar pipeline = new ResiliencePipelineBuilder();\n```", "```cs\nvar httpClient = httpClientFactory.CreateClient();httpClient.Timeout = TimeSpan.FromSeconds(10);\n```", "```cs\nvar cancellationToken = new CancellationTokenSource(TimeSpan.FromSeconds(10));var invoice = await invoiceRepository.GetAsync(id, cancellationToken.Token);\n```", "```cs\n    app.MapGet(\"/api/slow-response\", async () =>{    var random = new Random();    var delay = random.Next(1, 20);    await Task.Delay(delay * 1000);    return Results.Ok($\"Response delayed by {delay} seconds\");});\n    ```", "```cs\n    namespace PollyClientWebApi.Controllers;[Route(\"api/[controller]\")][ApiController]public class PollyController(ILogger<PollyController> logger, IHttpClientFactory httpClientFactory) : ControllerBase{    [HttpGet(\"slow-response\")]    public async Task<IActionResult> GetSlowResponse()    {        var client = httpClientFactory.CreateClient(\"PollyServerWebApi\");        var response = await client.GetAsync(\"api/slow-response\");        var content = await response.Content.ReadAsStringAsync();        return Ok(content);    }}\n    ```", "```cs\n    [HttpGet(\"slow-response\")]public async Task<IActionResult> GetSlowResponse(){    var pipeline = new ResiliencePipelineBuilder().AddTimeout(TimeSpan.FromSeconds(5)).Build();    try    {        var response = await pipeline.ExecuteAsync(async cancellationToken =>            await client.GetAsync(\"api/slow-response\", cancellationToken));        var content = await response.Content.ReadAsStringAsync();        return Ok(content);    }    catch (Exception e)    {        logger.LogError(e.Message);        return Problem(e.Message);    }}\n    ```", "```cs\n    Program.cs file of the PollyClientWebApi application and add the following code:\n\n    ```", "```cs\n\n    The preceding code defines a global timeout policy with a timeout of 5 seconds. The policy is named `timeout-5s-pipeline`. You can use any name you like. The `AddResiliencePipeline()` method is used to add the timeout policy to the pipeline.\n    ```", "```cs\n    public class PollyController(ILogger<PollyController> logger, IHttpClientFactory httpClientFactory, ResiliencePipelineProvider<string> resiliencePipelineProvider) : ControllerBase{    // Omitted}\n    ```", "```cs\n    var pipeline = resiliencePipelineProvider.GetPipeline(\"timeout-5s-pipeline\");// Omitted\n    ```", "```cs\nbuilder.Services.AddRateLimiter(options =>{\n    options.AddFixedWindowLimiter(\"FiveRequestsInThreeSeconds\", limiterOptions =>\n    {\n        limiterOptions.PermitLimit = 5;\n        limiterOptions.Window = TimeSpan.FromSeconds(3);\n    });\n    options.RejectionStatusCode = StatusCodes.Status429TooManyRequests;\n    options.OnRejected = async (context, _) =>\n    {\n        await context.HttpContext.Response.WriteAsync(\"Too many requests. Please try later.\", CancellationToken.None);\n    };\n});\n// Omitted\napp.UseRateLimiter();\n```", "```cs\n[EnableRateLimiting(\"FiveRequestsInThreeSeconds\")][ApiController]\n[Route(\"[controller]\")]\npublic class WeatherForecastController(ILogger<WeatherForecastController> logger) : ControllerBase\n{\n    // Omitted\n}\n```", "```cs\n    Polly.RateLimiting package is a wrapper for the System.Threading.RateLimiting package provided by Microsoft. It also depends on the Polly.Core package. So, if you have not installed the Polly.Core package, it will be installed automatically.\n    ```", "```cs\n    app.MapGet(\"/api/normal-response\", async () =>{    var random = new Random();    var delay = random.Next(1, 1000);    await Task.Delay(delay);    return Results.Ok($\"Response delayed by {delay} milliseconds\");});\n    ```", "```cs\n    builder.Services.AddResiliencePipeline(\"rate-limit-5-requests-in-3-seconds\", configure =>{    configure.AddRateLimiter(new FixedWindowRateLimiter(new FixedWindowRateLimiterOptions    { PermitLimit = 5, Window = TimeSpan.FromSeconds(3) }));});\n    ```", "```cs\n    builder.Services.AddResiliencePipeline(\"combined-resilience-policy\", configure =>{    configure.AddRateLimiter(        // Omitted    );    configure.AddTimeout(        // Omitted    );    // You can add more policies here});\n    ```", "```cs\n    [HttpGet(\"rate-limit\")]public async Task<IActionResult> GetNormalResponseWithRateLimiting(){    var client = httpClientFactory.CreateClient(\"PollyServerWebApi\");    try    {        var pipeline = resiliencePipelineProvider.GetPipeline(\"rate-limit-5-requests-in-3-seconds\");        var response = await pipeline.ExecuteAsync(async cancellationToken =>            await client.GetAsync(\"api/normal-response\", cancellationToken));        var content = await response.Content.ReadAsStringAsync();        return Ok(content);    }    catch (Exception e)    {        logger.LogError($\"{e.GetType()} {e.Message}\");        return Problem(e.Message);    }}\n    ```", "```cs\n    Polly.RateLimiting.RateLimiterRejectedException The operation could not be executed because it was rejected by the rate limiter. It can be retried after '00:00:03'.\n    ```", "```cs\n    configure.AddRateLimiter(new SlidingWindowRateLimiter(new SlidingWindowRateLimiterOptions{ PermitLimit = 100, Window = TimeSpan.FromMinutes(1) }));\n    ```", "```cs\n    builder.Services.AddResiliencePipeline(\"rate-limit-5-requests-in-3-seconds\", (configure, context) =>{    var rateLimiter = new FixedWindowRateLimiter(new FixedWindowRateLimiterOptions    { PermitLimit = 5, Window = TimeSpan.FromSeconds(3) });    configure.AddRateLimiter(rateLimiter);    // Dispose the rate limiter when the pipeline is disposed    context.OnPipelineDisposed(() => rateLimiter.Dispose());});\n    ```", "```cs\n    [HttpGet(Name = \"GetWeatherForecast\")]public async Task<ActionResult<IEnumerable<WeatherForecast>>> Get(){    var httpClient = httpClientFactory.CreateClient(\"PollyServerWebApi\");    var pollyPipeline = new ResiliencePipelineBuilder()    .AddRetry(new Polly.Retry.RetryStrategyOptions()    {        ShouldHandle = new PredicateBuilder().Handle<Exception>(),        MaxRetryAttempts = 3,        Delay = TimeSpan.FromMilliseconds(500),        MaxDelay = TimeSpan.FromSeconds(5),        OnRetry = args =>        {            logger.LogWarning($\"Retry {args.AttemptNumber}, due to: {args.Outcome.Exception?.Message}.\");            return default;        }    })    .Build();    HttpResponseMessage? response = null;    await pollyPipeline.ExecuteAsync(async _ =>    {        response = await httpClient.GetAsync(\"/WeatherForecast\");        response.EnsureSuccessStatusCode();    });    if (response != null & response!.IsSuccessStatusCode)    {        var result = await response.Content.ReadFromJsonAsync<IEnumerable<WeatherForecast>>();        return Ok(result);    }    return StatusCode((int)response.StatusCode, response.ReasonPhrase);}\n    ```", "```cs\n    warn: PollyClientWebApi.Controllers.WeatherForecastController[0]      Retry 2, due to: Response status code does not indicate success: 429 (Too Many Requests)..\n    ```", "```cs\n    ShouldHandle = new PredicateBuilder().Handle<Exception>().Or<HttpRequestException>(ex => ex.StatusCode == HttpStatusCode.TooManyRequests),\n    ```", "```cs\n    BackoffType = DelayBackoffType.Exponential,\n    ```", "```cs\n    app.MapGet(\"/api/random-failure-response\", () =>{    var random = new Random();    var delay = random.Next(1, 100);    return Task.FromResult(delay > 20 ? Results.Ok($\"Response is successful.\") : Results.StatusCode(StatusCodes.Status500InternalServerError));});\n    ```", "```cs\n    builder.Services.AddResiliencePipeline(\"circuit-breaker-5-seconds\", configure =>{    configure.AddCircuitBreaker(new CircuitBreakerStrategyOptions    {        FailureRatio = 0.7,        SamplingDuration = TimeSpan.FromSeconds(10),        MinimumThroughput = 10,        BreakDuration = TimeSpan.FromSeconds(5),        ShouldHandle = new PredicateBuilder().Handle<Exception>()    });});\n    ```", "```cs\n    [HttpGet(\"circuit-breaker\")]public async Task<IActionResult> GetRandomFailureResponseWithCircuitBreaker(){    var client = httpClientFactory.CreateClient(\"PollyServerWebApi\");    try    {        var pipeline = resiliencePipelineProvider.GetPipeline(\"circuit-breaker-5-seconds\");        var response = await pipeline.ExecuteAsync(async cancellationToken =>            {                var result = await client.GetAsync(\"api/random-failure-response\", cancellationToken);                result.EnsureSuccessStatusCode();                return result;            });        var content = await response.Content.ReadAsStringAsync();        return Ok(content);    }    catch (Exception e)    {        logger.LogError($\"{e.GetType()} {e.Message}\");        return Problem(e.Message);    }}\n    ```", "```cs\n    {  \"type\": \"https://tools.ietf.org/html/rfc9110#section-15.6.1\",  \"title\": \"An error occurred while processing your request.\",  \"status\": 500,  \"detail\": \"Response status code does not indicate success: 500 (Internal Server Error).\",  \"traceId\": \"00-c5982555dbf0e66d5ca79fd83aa3837c-46cd1cd7f6acb851-00\"}\n    ```", "```cs\n    {  \"type\": \"https://tools.ietf.org/html/rfc9110#section-15.6.1\",  \"title\": \"An error occurred while processing your request.\",  \"status\": 500,  \"detail\": \"The circuit is now open and is not allowing calls.\",  \"traceId\": \"00-1b6dc3f8912f5ebd4e67a39a89dd605a-495d67559eaf22b7-00\"}\n    ```"]