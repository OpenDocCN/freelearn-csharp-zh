- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Minimal APIs – Creating REST Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since .NET 6, minimal APIs are the new way to create REST APIs. With later .NET
    versions, more and more enhancements have been made available, which makes them
    the preferred way to create REST services with .NET.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to create a data representation of the game
    with model types, use these types in a service to implement the game functionality,
    create a minimal API project to create games, update games by setting game moves,
    and return information about games.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll implement functionality to offer an OpenAPI description for developers
    accessing the service to get information about the service, and an easy way to
    create a client application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll be exploring these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating models for the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an in-memory game repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the REST service of the game using minimal APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OpenAPI to describe the service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the service using HTTP files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling .NET Aspire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have a running service implementing the Codebreaker
    Games API with an in-memory games store, accessible using HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in the following GitHub repository:
    [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure).
    The `ch02` source code folder contains the code samples for this chapter. You’ll
    find the code for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Codebreaker.GamesAPIs` – The Web API project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.GamesAPIs.Models` – A library for the data models'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.GameAPIs.Analyzers` – A library containing game move analyzers
    for the game'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.GamesAPIs.Analyzers.Tests` – Unit tests for the game move analyzers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.AppHost` – The host project for .NET Aspire'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.ServiceDefaults` – A library used by the .NET Aspire configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You don’t implement the game move analyzers of the game in this chapter. The
    `Analyzers` project is just for reference purposes, but you can simply use a NuGet
    package for the analyzers (`CNinnovation.Codebreaker.Analyzers`) that has been
    made available for you to build the service.
  prefs: []
  type: TYPE_NORMAL
- en: For the installation of Visual Studio, Visual Studio Code, and .NET Aspire,
    check the README file for this chapter in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: The game models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before creating the REST API project, we start with a library that contains
    the models to represent the game along with a move of the game. This model will
    contain the main data part of the Codebreaker Game API service solution, which
    will be used to read and write to the database (in [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063)),
    while the model also serves as an implementation of the main functionality of
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: The major types in a simplified version are shown in *Figure 2**.1*. The `Game`
    class implements the `IGame` interface. The `IGame` interface is used by the `Analyzers`
    package. A game contains a list of moves. A single game move is represented by
    the `Move` class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The game model](img/B21217_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – The game model
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the game analyzers library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the focus of this book is not implementing the game rules with .NET, you
    can use the existing project, `Codebreaker.GameAPIs.Analyzers`, or just reference
    the NuGet package that has been made available on the NuGet server. This library
    contains game move analyzers for these game types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Game6x4` – Six colors with four codes to guess'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Game8x5` – Eight colors with five codes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Game6x4Mini` – Six colors with four codes with a *small* *children* mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Game5x5x4` – Five colors and five shapes with four codes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The analyzers work using the generic `IGame` interface, which you need to implement
    with the game models library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IGame` interface specifies some common functionalities for the `Codebreaker`
    games, as you can see in the following code snippet. Check the repository for
    the complete interface definition:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Analyzers/Contracts/IGame.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `IGame` interface defines game members used by the analyzers, such as the
    number of codes that must be set and the maximum number of moves allowed, which
    are used by the analyzer to verify correct input data. The `FieldValues` property
    of the `IDictionary<string, IEnumerable<string>>` type defines the possible values
    to select from. With the color game types, this will be a list of colors. With
    the shape game type, this will be a list of colors and a list of shapes. The `Codes`
    property contains an array of strings. How the string looks is different based
    on the game type. The string array contains the correct solution for a game run.
  prefs: []
  type: TYPE_NORMAL
- en: The `analyzers` library also contains record types that are supported by the
    analyzers implementation that you can use for the generic parameters of your game
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'One example of such a type used for the generic parameters is `ColorField`:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Analyzers/Fields/ColorField.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `ColorField` record class just contains a `color` string. This field type
    is used with all game types with the exception of the `Game5x5x4` game type, which
    uses the `ShapeAndColorField` record.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify the results of a game move, three different types are available:
    `ColorResult`, `SimpleColorResult`, and `ShapeAndColorResult`. `SimpleColorResult`
    adds information for small children (which position has a correct color), whereas
    the `ColorResult` record struct just contains information on the number of colors
    placed in a correct hole, and the number of colors placed in an incorrect hole.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the `ColorResult` record struct:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Analyzers/Results/ColorResult.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This record is implemented partially, separating parts of the implementation
    to simplify the source code. The other parts are defined in other source files
    and implement the `IParsable` and `IFormattable` interfaces. The `const` member
    called `Separator` is used with the other parts of the `ColorResult` type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`ColorField`, `ColorResult`, and the other classes representing a field and
    results are just used to analyze moves and return results. The `Game` and `Move`
    classes that you’ll implement in this chapter are just data holders and don’t
    contain any logic. The field guesses and results are all represented using strings,
    which makes them flexible for every game type available and easier to use with
    JSON serialization and database access. Converting the specific field and result
    types to and from strings is done using the `IParsable`, `ISpanParsable`, and
    `IFormattable` interfaces. The parsable interfaces are new since .NET 7 and are
    based on a C# 11 feature that allows static members with interfaces. These types
    are important in case you want to create your own game types and game analyzers.'
  prefs: []
  type: TYPE_NORMAL
- en: You can read the article at [https://csharp.christiannagel.com/2023/04/14/iparsable/](https://csharp.christiannagel.com/2023/04/14/iparsable/)
    for more information about parsable interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring game analyzers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The implementation of the game analyzers is done within the `GameGuessAnalyzer`
    base class and the `ColorGameGuessAnalyzer`, `SimpleGameGuessAnalyzer`, and `ShapeGameGuessAnalyzer`
    derived classes. The implementation of these analyzers is disconnected from the
    game model types. All these analyzers implement the `GetResult` method specified
    with the `IGameGuessAnalyzer<Tresult>` interface. After creating an instance of
    the analyzer passing the game, the guesses, and the move number, just the `GetResult`
    method needs to be invoked to calculate the result of the move.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in checking the analyzers, dive into the `Codebreaker.GameAPIs.Analyzers`
    project within the book’s source code repository. Working through the following
    steps, instead of referencing this project, you can add the `CNinnovation.Codebreaker.Analyzers`
    NuGet package. Just make sure to use the latest 3.x version of this package, as
    4.x and newer versions might contain breaking changes.
  prefs: []
  type: TYPE_NORMAL
- en: If you choose to, you can create an analyzer on your own and also add more game
    types. Make sure to read the information on the game rules in [*Chapter 1*](B21217_01.xhtml#_idTextAnchor014).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a .NET library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The model types are added to the `Codebreaker.GameAPIs.Models` .NET library.
    Having a library allows the creation of different data access libraries (in [*Chapter
    3*](B21217_03.xhtml#_idTextAnchor063)) to offer a flexible data store choice for
    hosting the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the .NET CLI as shown to create the class library, or use Visual
    Studio to create a class library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Implementing classes for the model types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Game` class holding all the data needed by a game is shown here (check
    the GitHub repository for the complete implementation):'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Models/Game.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This class implements the `IGame` interface to support the analyzer to check
    the correctness of a move and to set some game state. In addition to the members
    of the interface, the `Game` class also contains a collection of `Move` objects.
    Primary constructor syntax is used to reduce the number of needed code lines.
  prefs: []
  type: TYPE_NORMAL
- en: Primary constructors
  prefs: []
  type: TYPE_NORMAL
- en: Several classes created in this book make use of primary constructors. Primary
    constructors have been in use with records since C# 9\. With C# 12, primary constructors
    can be used with normal classes and structs. However, while primary constructors
    with records create properties, with classes, these are just parameters. The parameters
    can be assigned to fields and properties, or just be used within members.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Move` class is simpler as it just represents the move of a player within
    a game along with its result:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Models/Move.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `Move` class contains string arrays for the guesses (`GuessPegs`) and the
    results (`KeyPegs`). String arrays can be used for every game type.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the game repository contract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be independent of the data store, the `IGamesRepository` interface defines
    all the members needed from a data store when playing a game. The `AddGameAsync`
    method is invoked when a new game is started. Setting a move, the game needs to
    be updated invoking the `UpdateGameAsync` method. The `GetGameAsync` and `GetGamesAsync`
    methods are specified by the interface to retrieve games:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Models/Data/IGamesRepository.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This interface specifies asynchronous methods. This wouldn’t be required with
    the implementation in this chapter. The next chapter will add asynchronous implementations,
    thus the contract should be ready for this.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying asynchronous methods, it’s a good practice to allow passing a `CancellationToken`.
    This allows canceling long-running operations even across network boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: The `IGamesRepository` interface is specified in the `Codebreaker.GameAPIs.Models`
    library. This makes it possible to reference this interface from all the data
    store libraries that will be implemented later on. In this chapter, just an in-memory
    collection will be implemented as part of the next step.
  prefs: []
  type: TYPE_NORMAL
- en: The minimal APIs project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After having the models and the repository contract in place, we can move over
    to creating the project hosting the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we’ll use ASP.NET Core with minimal APIs to create a REST API, and store
    games and moves in an in-memory repository. To create the running games API, we
    need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Web API project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the games repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a games factory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create data transfer objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create endpoints to run the game via HTTP requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the JSON serializer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add endpoint filters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To better understand how the different classes interact in creating the game
    and setting a move, the flow of the functionality we need to implement is shown
    in the next two figures.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.2* shows the sequence when a new game is created. On invoking the
    API call, `GamesService` is invoked to start the game. This service class uses
    `GamesFactory` to create a new game based on the parameters received and returns
    random code values. For persistence, `GameMemoryRepository` is invoked from `GamesService`
    to add the game before the game is returned.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Creating a game](img/B21217_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Creating a game
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.3* shows the sequence when a game move is set. Because the client
    does not have the complete state of the game, `GamesService` retrieves the game
    from the repository. Then, `GamesFactory` is used again to select an analyzer
    based on the game type, and the analyzer is invoked to find the results of the
    game move. After the results are available with `GamesService`, the game is updated
    with the new move, and the results are returned to the game endpoint.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Setting a game move](img/B21217_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Setting a game move
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement this functionality with the API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Web API project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the Web API project, you can use the .NET CLI as shown or use the
    Web API project template from Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `--``use-minimal-apis` option is used to create minimal APIs instead of
    the traditional controllers. Because the API will be hosted behind an Ingress
    server, the Ingress server will offer HTTPS, while HTTP is okay in the backend.
    To allow but not require HTTPS remove the codeline `app.UseHttpsRedirection();`
    from the code.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring WebApplicationBuilder and WebApplication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the created project, `Program.cs` is created and contains the configuration
    for the dependency injection container with the `WebApplicationBuilder` class
    and the configuration of middleware with the `WebApplication` class. The project
    template creates a random weather service. However, as weather information is
    not needed with the games service, some of the created code can be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The part of the code that remains is shown in the next code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`WebApplication.CreateBuilder` returns `WebApplicationBuilder` and configures
    the dependency injection container, the default configuration, and default logging.
    The `AddEndpointsApiExplorer` and `AddSwaggerGen` methods add services to the
    dependency injection container. The services registered by these two methods are
    needed for the `OpenAPI` description of the services.'
  prefs: []
  type: TYPE_NORMAL
- en: Invoking the `Build` method returns a `WebApplication` instance. This instance
    is then used to configure the middleware. Middleware is invoked with every request
    to the service. The `UseSwagger` method registers the Swagger middleware to create
    an `OpenAPI` description of the service. The `UseSwaggerUI` method registers the
    `SwaggerUI` middleware to show a web page where the API is described and can be
    tested. As an API is not yet implemented, a description will not be generated
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: What is the relationship between Swagger and OpenAPI?
  prefs: []
  type: TYPE_NORMAL
- en: The Swagger specification was created to describe HTTP APIs. In 2015, SmartBear
    Software acquired the Swagger API specification and started to form a new organization
    in 2016 together with Google, IBM, Microsoft, PayPal, and others under the sponsorship
    of the Linux Foundation – the **OpenAPI Initiative**. New versions of this specification
    are defined with OpenAPI.
  prefs: []
  type: TYPE_NORMAL
- en: The `SwaggerXX` method names originate from the original specification and haven’t
    been changed since. These methods are defined within the `Swashbuckle.AspNetCore`
    NuGet package that’s referenced with the Web API project template.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the earlier *Defining the game repository contract* section, we created
    the `IGamesRepository` interface to specify the methods that need to be implemented
    by every data store used with the Games API. We can implement this contract now.
    The `GamesMemoryRepository` class implements the `IGamesRepository` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Data/GamesMemoryRepository.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With the implementation, the `ConcurrentDictionary` class is used for a thread-safe
    collection when multiple clients access the service concurrently. With the implemented
    `AddGameAsync`, `GetGameAsync`, and similar methods, games are added, updated,
    and removed from the dictionary. Here, all the games are just kept in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent state and multiple server instances
  prefs: []
  type: TYPE_NORMAL
- en: This chapter’s implementation of the repository does not persist the state and
    also does not allow multiple server instances to run, as the state is only stored
    within the memory of the process. In the next chapter, other implementations of
    this interface will be used to store the games in a database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating game objects initialized with random values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `GamesFactory` class creates games with random values. The following code
    snippet shows creating a game with six colors and four holes; you can extend this
    to other game types as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Services/GamesFactory.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With the code, pattern matching is used. For every game type, a local function
    such as `Create6x4Game` is defined, which specifies the available colors or shapes,
    the random code, and the maximum number of moves.
  prefs: []
  type: TYPE_NORMAL
- en: Creating data transfer objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`BookData` class to write information to the database and a `BookDTO` class
    for communication, implementing the same properties. With such a design in place,
    a change to the book would result in changing `BookData` and `BookDTO`, as well
    as the implementation to transform these objects. Using the same `Book` class
    with every of these scenarios reduces the programming effort, and also reduces
    the memory and CPU usage during runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: A reason to use different types for data access and communication is the requirements
    for the data mapping to the database and the requirements of the serializer used
    with communication. Nowadays, both EF Core and the `System.Text.Json` serializer
    support constructors with parameters, which might fill the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: If there are other requirements, DTOs can become important. With the games API,
    different data should be used with the communication than used internally with
    the service. In creating a game, not all the data for the game is coming from
    the client. Much of this data, such as the list of available fields as well as
    the code, is generated on the server. When sending a move from the client to the
    server, a game gets updated on the server, but there’s only a subset of a move
    needed that’s sent from the client to the server. When returning information from
    the server to the client, again, only a subset of data is required. This makes
    creating DTOs important.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the games API, to start a new game, we implement the `CreateGameRequest`
    and `CreateGameResponse` class record types:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Models/GameAPIModels.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In creating a game, the client just needs to send the game type and the player’s
    name. This is all that’s needed from the client. In the backend, just a string
    is used for the game type. Using a string allows for easy enhancements of other
    game types. The API using an `enum` type allows showing the available game types
    with the OpenAPI description, as you’ll see in the section about OpenAPI.
  prefs: []
  type: TYPE_NORMAL
- en: After the game is created, the client just needs to have the identifier of the
    game. For convenience, the game type and player name are also returned. The client
    should also know the possible fields that can be selected. This is specified by
    the `FieldValues` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set a game move, we implement the `UpdateGameRequest` and `UpdateGameResponse`
    class record types:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Models/GameAPIModels.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When sending a move, the client needs to send the list of guess pegs. With the
    API service, guess pegs and key pegs are represented with strings, such as the
    `GuessPegs` property. This makes it independent of any game type. With the analyzers,
    different types for every game type are implemented. The `IParsable` interface
    is used to convert string values.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the games service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To simplify the implementation of the endpoints, we create the `GamesService`
    class, which will be injected into the endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Services/GamesService.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`StartGameAsync` just invokes the `AddGameAsync` method with `IGamesRepository`.
    Such a simple implementation is the case with many other methods of `GamesService`.
    This will change in the next chapter when data will be cached in memory before
    accessing the database. When using the in-memory repository, this is not necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing `SetMoveAsync` is more complex, as here we have to decide to use
    one of the game analyzers to calculate the game. For the game type selection and
    the calculation, the `ApplyMove` method is defined as an extension method for
    the `Game` type within the `GamesFactory` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Services/GamesFactory.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of this method uses pattern matching with the `switch` expression
    to invoke the correct analyzer class to get the result of the game move.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having this `Game` extension method in place let’s us switch back to the implementation
    of the `SetMoveAsync` method of the `GamesService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Services/GamesService.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `SetMoveAsync` method retrieves the game from the repository before invoking
    the `ApplyMove` method to do the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Converting transfer objects to and from the object model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In receiving a `CreateGameRequest` to create a new game, there’s no need for
    a conversion. The members of `CreateGameRequest` can directly be used when using
    `GamesService`. We need to create a conversion from a `Game` type to `CreateGameResponse`.
    This is done as an extension method for the `Game` type:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Extensions/ApiModelExtensions.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With the implementation, the needed data from the `Game` type is transferred
    to the `CreateGameResponse` type.
  prefs: []
  type: TYPE_NORMAL
- en: Creating endpoints for the Games API service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before creating the endpoints, the services we created need to be registered
    with the dependency injection container to inject them within the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`GamesMemoryRepository` was created to store game objects in memory. This is
    registered as a singleton for creating a single instance that’s injected into
    the endpoints. Games should be kept as long as the server keeps running. `GamesMemoryRepository`
    implements `IGamesRepository`. In the next chapter, an EF Core context will be
    created to implement the same interface, which will allow changing the `GamesService`
    class implements the `IGamesService` interface. This service class is registered
    scoped; thus one instance is created with every HTTP request.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the middleware, we invoke one extension method that defines all the games
    API endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `MapGameEndpoints` method is an extension method for the `IEndpointRouteBuilder`
    interface and is implemented next.
  prefs: []
  type: TYPE_NORMAL
- en: 'In creating a REST API, different HTTP verbs are used to read and write resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` – With an HTTP `GET` request, resources are returned from the service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` – The HTTP `POST` request creates a new resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` – `PUT` is usually used to update a complete resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH` – With `PATCH`, a partial resource can be sent for an update'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` – The HTTP `DELETE` request deletes a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating games with HTTP POST
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start with the endpoint to create a new game by mapping an HTTP `POST`
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Endpoints/GameEndpoints1.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the source code repository, you will find the `GameEndpoints.cs` and `GameEndPoints1.cs`
    files. The current state of the endpoints is in the `GameEndpoints1.cs` file,
    but this will be changed later on when OpenAPI information is added. The file
    that gets compiled as defined in the project file is `GameEndpoints.cs`. If you
    want to compile the project from the repository with the current version, change
    the settings of the C# file in the project file.
  prefs: []
  type: TYPE_NORMAL
- en: The `MapGameEndpoints` method is – as previously mentioned – an extension method
    for the `IEndpointRouteBuilder` interface. The first method invoked is `MapGroup`
    to define common functionality for the endpoints, which, in turn, uses the returned
    group variable (a `RouteGroupBuilder` object). With this code, the common functionality
    is the `/games` URI, which will be prefixed. You can use this for common authorization
    needs or common logging, which will be shown in later chapters of this book. Common
    functionality for OpenAPI will be shown later in this chapter in the section on
    OpenAPI.
  prefs: []
  type: TYPE_NORMAL
- en: The created group is used with the `MapPost` method. The `MapPost` method will
    be invoked on an HTTP `POST` request. Similarly, `MapGet`, `MapPut`, and `MapDelete`
    are available as well. All these methods offer two overloads, where the overload
    with a pattern and the `Delegate` parameter are used. The `Delegate` parameter
    allows passing a lambda expression with any parameters and any return types –
    this is what minimal APIs take advantage of.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter types specified with the `MapPost` method are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateGameRequest` – This comes from the HTTP body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IGamesService` – The value is injected from the DI container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpContext` and `CancellationToken` – These are special types bound with
    minimal APIs. Another special one is `ClaimsPrincipal`, which is used with authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other binding sources that can be used are route values, query strings, headers,
    and HTML form values. You can also add custom binding to map a route, query, or
    header binding to custom types.
  prefs: []
  type: TYPE_NORMAL
- en: You can add attributes such as `FromBody`, `FromRoute`, `FromServices`, and
    others, which can help with readability and also resolve issues if there’s a conflict.
  prefs: []
  type: TYPE_NORMAL
- en: With the implementation of the lambda expression with the `MapPost` method,
    the injected `gameService` variable is used to start a game. Starting the game
    successfully, a `Game`-derived object is returned, which is converted to `CreateGameResponse`
    with the `ToCreateGameResponse` extension method. The method returns either `HTTP
    201 Created` on success, or `HTTP 400 Bad Request` using the `Results` factory
    class. `Results` offers methods to return the different HTTP status codes.
  prefs: []
  type: TYPE_NORMAL
- en: Using `Results.Created`, a URI is assigned to the first parameter of the method,
    and the second parameter receives the created object. The `201 Created` status
    code is used to return the HTTP location header with a link that can be remembered
    by the client to retrieve the same resource at a later time. The link that’s returned
    here can be used with an HTTP `GET` request to retrieve the game at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an error object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In case of an error, the `MapPost` method returns `Results.BadRequest`. Here,
    we can define an object to return detailed error information to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the `GameError` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Errors/GameError.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `GameError` class defines the `Code`, `Message`, `Target`, and `Details`
    properties. With the `MapPost` method, in the case of requesting an invalid game
    type, the valid game types are returned with the details.
  prefs: []
  type: TYPE_NORMAL
- en: Returning games with HTTP GET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To fulfill a request to a single game, we use the `MapGet` method:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Endpoints/GameEndpoints1.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With the lambda parameters, here, the `Guid` is received from the route parameter.
    Within curly braces, the same variable name is used that matches the variable
    of `Guid`. The implementation simply returns the game with the status code of
    `OK`, or `not found` if the game ID is not found within the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Updating games by setting a move with HTTP PATCH
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To set a move, a game is updated with a move without sending the complete game.
    That’s a partial update, thus we use the HTTP `PATCH` verb to invoke the `MapPatch`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Endpoints/GameEndpoints1.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The complete route for this request is `games/{id}` – prefixed with the pattern
    specified by the group. The `SetMoveAsync` method of `GamesService` does the main
    work. On success, the method returns `UpdateGameResponse`, which is created from
    the `Game` object and the result string.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring JSON serialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To successfully run the application, the JSON serialization needs to be configured.
    The .NET JSON serializer has many configuration options – including polymorphic
    serialization (returning a hierarchy of objects). But with all these features
    supported from serialization and with ASP.NET Core, you need to pay attention
    to the client technologies you use, if the same support is available there. With
    the data types we transfer here, there’s not a lot to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to serialize the enumeration value of game types, we prefer to use strings
    instead of just numbers, which would be returned by default. To return string
    values, the JSON options are configured:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Models/GameAPIModels.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The generic version of the `JsonStringEnumConverter` class is new since .NET
    8 to support Native AOT. The non-generic version of this type uses reflection,
    which is incompatible with Native AOT.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using the attribute with the type, you can also configure the JSON
    serialization behavior with the dependency injection container. The `ConfigureHttpJsonOptions`
    extension method with `JsonOptions` from the `Microsoft.AspNetCore.Http.Json`
    namespace can be used to configure the JSON serialization for minimal APIs. Be
    aware that the OpenAPI generation still uses the MVC serializer configuration,
    thus, here, you need to use the `Configure` method with `Microsoft.AspNetCore.Mvc.JsonOptions`
    as a generic parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating endpoint filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To simplify the code for endpoints, as you’ve seen, endpoints don’t need to
    be specified within top-level statements. You can create multiple classes with
    extension methods to group endpoints together. Within one extension method, you
    can also group endpoints with common behaviors using the `MapGroup` method. We
    also used dependency injection to have the main functionality outside of the endpoint
    implementation in the `GameService` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s another way to simplify the implementation of the endpoints – by using
    custom endpoint filters. Endpoint filters offer similar functionality as ASP.NET
    Core middleware, just with a different scope. By adding an endpoint filter to
    an endpoint, the filter code is invoked every time the endpoint is accessed. Adding
    multiple endpoint filters, the order of adding these is important: one filter
    is invoked after the other. You can also add an endpoint filter to a group; thus
    the filter is invoked with every endpoint specified with this group.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `ValidatePlayernameEndpointFilter`, we create a filter to validate the
    minimum length of the player’s name:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Endpoints/ValidatePlayernameEndpointFilter.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: An endpoint filter implements the `IEndpointFilter` interface. This interface
    defines the `InvokeAsync` method with `EndpointFilterInvocationContext` and `EndpointFilterDelegate`
    parameters. By using `EndpointFilterInvocationContext`, you can access `HttpContext`
    to access all the information about the request and also add responses, as well
    as the parameters passed to the endpoint. With the implementation of `ValidatePlayernameEndpointFilter`,
    the player’s name is validated by accessing the first parameter of the endpoints
    lambda expression, accessing the `CreateGameRequest` object, and accessing the
    `PlayerName` property. An HTTP status code of `400 Bad Request` is returned in
    the case that this does not succeed. To access the different parameters, the index
    of the parameter is needed. With a successful validation, the next endpoint is
    invoked using the `next` variable received with the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using an endpoint filter, you can also remove the exception handling code and
    create code with the filter that’s invoked before and after the next filter or
    the endpoint code is invoked. We implement this functionality with `CreateGameExceptionEndointFilter`:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Endpoints/CreateGameExceptionEndpointFilter.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CreateGameExceptionEndpointFilter` endpoint filter defines a constructor
    to inject the `ILogger` interface. Everything registered with the dependency injection
    container can be injected with an endpoint filter. With this filter, the invocation
    of the next filter – or the endpoint itself, in this case – is surrounded by a
    `try`/`catch` block. Thus, `CodebreakerException` is caught with the endpoint
    invocation, logged, and a result returned. This way, the exception-handling code
    can be removed from the endpoint itself. The following code snippet shows the
    new code for the endpoint implementation with the configured filters:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Endpoints/GameEndpoints2.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With this implementation, the important main functionality of this endpoint
    is easily visible. Validation and error handling is moved outside of the endpoint
    implementation. Calculating all the code together, the code is not becoming smaller,
    just the main functionality of the endpoint is becoming easier.
  prefs: []
  type: TYPE_NORMAL
- en: The real power of endpoint filters comes with shared functionality between different
    endpoints. In [*Chapter 11*](B21217_11.xhtml#_idTextAnchor263), *Logging and Monitoring*,
    we will create an endpoint filter that logs information for every endpoint that
    is configured with this filter.
  prefs: []
  type: TYPE_NORMAL
- en: Running the service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the endpoints implemented, you can run and test the application and see
    the Open API user interface, as shown in *Figure 2**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – OpenAPI UI without extra configuration](img/B21217_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – OpenAPI UI without extra configuration
  prefs: []
  type: TYPE_NORMAL
- en: You can now run the application sending a `POST` request from the Swagger page.
    After getting the game information returned, copy the unique ID from the game,
    and send a `PATCH` request to set a move.
  prefs: []
  type: TYPE_NORMAL
- en: While the application is running, OpenAPI now lacks some information. The returned
    HTTP results are not listed, more description details should be shown, and the
    schema for return types is not available. This is solved in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: OpenAPI information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since there are many .NET versions, the Web API templates reference the `Swashbuckle.AspNetCore`
    NuGet package to create an OpenAPI description. Over the years, with later .NET
    versions, more and more functionality from OpenAPI has been added to ASP.NET Core
    itself, such as the `OpenApiInfo` class, which is now part of the `Microsoft.OpenApis.Models`
    namespace. Swashbuckle was changed to use the new classes and was also changed
    to be based on the `System.Text.Json` serializer instead of `Newtonsoft.Json`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding OpenAPI documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let’s make use of classes from the `Microsoft.OpenApis.Models` namespace
    together with Swashbuckle to configure the OpenAPI documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The Codebreaker Games API is already in its third major version. With the Swagger
    configuration of the dependency injection container, the `AddSwaggerGen` method
    supports receiving configuration options. The `SwaggerDoc` method of the `SwaggerGenOptions`
    options parameter allows specifying different document values, such as the version
    number, title, description, terms of service, contact, and license information,
    as shown in the code snippet. The `OpenApiInfo`, `OpenApiContact`, and `OpenApiLicense`
    classes are part of the `Microsoft.OpenApi.Models` namespace. All this configured
    information will show up in the generated OpenAPI documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The middleware configuration needs to be updated as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, the version number is included with the OpenAPI endpoint invoking the
    `SwaggerEndpoint` method using the `SwaggerUIOptions` parameter. In case you prefer
    a different look for the generated document, you can create your own style sheet,
    and pass the style sheet file by invoking the `options.InjectStylesheet` method.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation for the endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several extension methods are available to add OpenAPI documentation to the
    endpoints, as we’ll do within the `MapGameEndpoints` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `WithTags` method could be added to every endpoint or, as shown here, to
    the endpoint group. `WithTags` adds a category name – or multiple names if the
    API should show up with multiple categories. With this, for the documentation
    for every tag name, a heading is used to show all the endpoints together that
    belong to the same category. If you don’t supply a tag name, the project name
    is used, and all the endpoints are listed in this category.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, using `RouteHandlerBuilder` extension methods, documentation is added
    to every endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Using the `WithName`, `WithSummary`, and `WithOpenApi` methods, a name and description
    of the API – including a description of every parameter – can be added.
  prefs: []
  type: TYPE_NORMAL
- en: Adding return type information to OpenAPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Produces` extension method could be used to define what types are returned
    from endpoints that need to be described. Since .NET 7, there’s a better option:
    using the `TypedResults` class instead of the `Results` class that was used earlier
    in implementing the endpoints. `TypedResults` adds the class specified to the
    OpenAPI documentation. However, if there is more than one type returned, we need
    to specify this with the return types of the endpoint lambda expression.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method to be changed to `TypedResults` is `MapDelete`:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the lambda expression for the `MapDelete` method just
    returns the HTTP status code `204` and doesn’t require a return type for the lambda
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is different with the `MapPatch` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the lambda expression contains several invocations of
    the `TypedResults` factory class. The `BadRequest`, `NotFound`, and `Ok` methods
    are invoked. With `BadRequest`, an object of the `GameError` type is returned.
    This is just a simple record class with a `Message` and other properties to return
    useful information for the clients. The `Ok` method returns an object of the `UpdateGameResponse`
    class. With two or more typed results returned, the lambda expression needs a
    return type. To specify the return type with the lambda expression, .NET 7 added
    generic `Results` types – for example, the type with two generic parameters: `Results<TResult1,
    TResult2>`. The generic types specify the constraint to require the `IResult`
    interface. The `Microsoft.AspNetCore.Http.HttpResults` namespace contains generic
    `Results` types from two to six generic parameters. By using `Results<Ok<UpdateGameResponse>,
    NotFound, BadRequest<InvalidGameMoveError>>`, it’s defined that the method either
    returns an `Ok` result with a `SetMoveError` object, `NotFound`, or `BadRequest`
    with an `InvalidGameMoveError` object. Because the lambda expression makes use
    of the `async` keyword, the complete result is put into a task: `Task<Results<Ok<UpdateGameResponse>,`
    `NotFound, BadRequest<InvalidGameMoveError>>>`.'
  prefs: []
  type: TYPE_NORMAL
- en: With all this OpenAPI configuration in place, we can start the service, generate
    the documentation to describe the API, and use it from a web interface, as shown
    in *Figure 2**.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – OpenAPI documentation](img/B21217_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – OpenAPI documentation
  prefs: []
  type: TYPE_NORMAL
- en: Opening an endpoint, you can see the different HTTP results returned and all
    the schemas created.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the service, the OpenAPI test page can be used. However, there’s a better
    way without leaving Visual Studio or Visual Studio Code. Visual Studio offers
    the **Endpoints Explorer** window to show all the API endpoints in your solution,
    as shown in *Figure 2**.6*. Open this window using **View** | **Other Windows**
    | **Endpoints Explorer**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Endpoints Explorer](img/B21217_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Endpoints Explorer
  prefs: []
  type: TYPE_NORMAL
- en: By selecting an endpoint and opening the context menu, you can generate a request.
    This creates an HTTP file that you can use to send HTTP requests, including the
    body, and see the returned results beside it.
  prefs: []
  type: TYPE_NORMAL
- en: Using HTTP files with Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: If you use Visual Studio Code, install the `REST Client` extension from Huachao
    Mao.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we start a game by sending a `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Codebreaker.GameAPIs.http
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines in the HTTP file specify variables that are referenced later
    surrounded by two curly braces. Every request specified needs to be separated
    by three hash characters, `###`. With this, using Visual Studio or the Visual
    Studio Code extension, you can see a green arrow that, when clicked, sends the
    request. To separate the HTTP header from the body, a blank line is required.
    The body to create a game contains the `gameType` and `playerName` JSON elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'After sending the request to create a game, you can set a move:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Codebreaker.GameAPIs.http
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Before sending the move, get the ID that was returned on creation of the game,
    and paste it into the `id` variable used with the HTTP file. There’s no need to
    save this file; just clicking on the link will send the `PATCH` request. Remember
    to update the move number with every move.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get information about the game, send a `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Codebreaker.GameAPIs.http
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When sending the `GET` request, a body is not supplied. This request gives complete
    information about the game, including its moves, and the result code.
  prefs: []
  type: TYPE_NORMAL
- en: By using HTTP files, you can easily debug the APIs without leaving Visual Studio.
    In case you’re in a debug session, you might need to change the **Request timeout**
    setting in **Text Editor** | **Rest** | **Advanced settings**. The HTTP files
    also serve as good documentation as part of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling .NET Aspire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s add .NET Aspire to this solution. Using Visual Studio, you can select
    the Games API project in **Solution explorer** and use the context menu to select
    **Add** | **.NET Aspire** **Orchestrator Support…**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using Visual Studio, you can use the dotnet CLI to create a .NET
    Aspire project: `dotnet new aspire`. With the two projects created, you can connect
    the Games API project using the explanations from this section.'
  prefs: []
  type: TYPE_NORMAL
- en: This creates two projects (`{solution}.AppHost` and `{solution}.ServiceDefaults`)
    and makes small changes to the Games API project. The `AppHost` project is a web
    application that runs a dashboard to monitor all the configured services. `ServiceDefaults`
    is a library to specify default configurations. This library is referenced by
    the Games API. Let’s look into the details next.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Aspire host
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The source code of the startup code of the Aspire host is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This Aspire host runs a web application that’s only used during development
    time. Here, the `DistributedApplication` class is used with the app builder pattern.
    The `CreateBuilder` method returns the `IDistributedApplicationBuilder` interface,
    which allows the configuration of all the services that should be orchestrated
    by the distributed application. Using this interface, similar to `WebApplicationBuilder`,
    the configuration and DI container can be configured. Contrary to `WebApplicationBuilder`,
    resources can be added that are orchestrated by the app host.
  prefs: []
  type: TYPE_NORMAL
- en: A project resource is added to the resources of the builder by invoking the
    `AddProject` extension method. Adding a project reference to the `Codebreaker.GameAPIs`
    project creates the `Codebreaker_GameAPIs` class in the `Projects` namespace.
    The name passed with the parameter – `gameapis` – can be used when one service
    references another one. Currently, we only have one service in the `Codebreaker`
    solution, but this will change going forward with the chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the ServiceDefaults library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Codebreaker.ServiceDefaults` project is here to be referenced by all service
    projects making use of .NET Aspire functionality. This project adds references
    to NuGet packages for HTTP resiliency, service discovery, and several OpenTelemetry
    packages used for logging, metrics, and distributed tracing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the configuration defined by the `Extensions` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.ServiceDefaults/Extensions.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `AddServiceDefaults` method configures the DI container with OpenTelemetry
    for logging, default health checks, and service discovery, and configures the
    `HttpClient` class with resiliency.
  prefs: []
  type: TYPE_NORMAL
- en: This complete configuration can be used from the Codebreaker Games API by invoking
    the `AddServiceDefaults` method with the application builder. This invocation
    is added from the Visual Studio .NET Aspire integration when adding Aspire orchestration.
    If you created the .NET Aspire projects from the command line, you need to add
    the invocation to the `AddServiceDefaults` method when configuring the DI container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another extension method defined by the service defaults library is `MapDefaultEndpoints`:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.ServiceDefaults/Extensions.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is an extension method to configure the ASP.NET Core middleware with health
    checks. The `MapDefaultEndpoints` method needs to be invoked with the middleware
    configuration of the Games API.
  prefs: []
  type: TYPE_NORMAL
- en: All the functionality mentioned here will be discussed in detail in the following
    chapters. Now, you can already start the Aspire host project, which, in turn,
    starts up the Games API.
  prefs: []
  type: TYPE_NORMAL
- en: Running the .NET Aspire host
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When running the .NET Aspire host, a dashboard is shown that shows the `codebreaker.gameapis`
    project with the resources where you can access endpoints, check environment variables,
    and open log information, as shown in *Figure 2**.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Resources in the .NET Aspire dashboard](img/B21217_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Resources in the .NET Aspire dashboard
  prefs: []
  type: TYPE_NORMAL
- en: While the Aspire host is running, you can play games using the HTTP files created
    earlier, and now monitor the logs, metrics information, and traces (shown in *Figure
    2**.8*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Traces in the .NET Aspire dashboard](img/B21217_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Traces in the .NET Aspire dashboard
  prefs: []
  type: TYPE_NORMAL
- en: Details on logging, metrics, tracing, and adding custom information are covered
    in [*Chapter 11*](B21217_11.xhtml#_idTextAnchor263), *Logging* *and Monitoring*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a Web API using ASP.NET Core minimal APIs. We covered
    creating services and an in-memory repository, configured them with the dependency
    injection container, created models, and used game analyzer classes to calculate
    moves.
  prefs: []
  type: TYPE_NORMAL
- en: We created endpoints to create, read, and update games, specified information
    to show up with the OpenAPI documentation, tested the service using HTTP files,
    and finally, added .NET Aspire for hosting and a dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: After working through this chapter, you deserve a break to play a game. Use
    the HTTP files to create a game and set moves until the answer returned shows
    that you won. Don’t cheat by making `GET` requests to the game before you find
    the answer!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll replace the repository by using Entity Framework
    Core with SQL Server and Azure Cosmos DB to have a persistent games store.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Primary* *constructors*: [https://csharp.christiannagel.com/2023/03/28/primaryctors/](https://csharp.christiannagel.com/2023/03/28/primaryctors/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Microsoft REST API* *Guidelines*: [https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md](https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The OpenAPI* *Initiative*: [https://www.openapis.org/](https://www.openapis.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Minimal APIs parameter* *binding*: https://learn.microsoft.com/aspnet/core/fundamentals/minimal-apis/parameter-binding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JSON serialization* *customization*: [https://learn.microsoft.com/en-us/dotnet/standard/serialization/](https://learn.microsoft.com/en-us/dotnet/standard/serialization/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Swashbuckle.AspNetCore` GitHub repo: https://github.com/domaindrivendev/Swashbuckle.AspNetCore'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET Aspire documentation: [https://learn.microsoft.com/en-us/dotnet/aspire/](https://learn.microsoft.com/en-us/dotnet/aspire/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
