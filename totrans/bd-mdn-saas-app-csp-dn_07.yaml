- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a User Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be exploring how to build a web-based frontend using
    Blazor, a client-side web framework that interfaces with the .NET web API backend
    that we built up in previous chapters. Blazor is a powerful and flexible framework
    that allows us to write C# code that runs in the browser, enabling us to create
    rich and interactive web applications with a single code base.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by looking at the many important techniques that you will have
    to understand before building a user interface. These will be tasks such as generating
    user personas, building user journeys, wireframing, and creating tickets.
  prefs: []
  type: TYPE_NORMAL
- en: After we have covered the background work, we will start by modifying the Dockerized
    development environment to facilitate frontend development and creating a new
    Blazor project. We will also explore the basic structure of a Blazor application,
    including the components, pages, and layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will cover how to connect to a .NET web API backend. We will show how
    to consume data from the web API, using the client code to call the API endpoints
    and retrieve the data, and display it in the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: We will then dive into the details of designing the user interface, including
    creating the layout, designing the components, and adding the necessary controls
    and elements to create a responsive and visually appealing user interface.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a comprehensive understanding of how
    to build a Blazor frontend that connects to a .NET web API backend, and how to
    create a responsive and scalable web application that provides a seamless UX for
    your customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A general introduction to the tech stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make sure your app serves your customers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some practical examples of how to build a UI with Blazor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to interact with the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All code from this chapter can be found at [https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-7](https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-7).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the tech stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many options available to build a frontend for a SaaS application.
    Angular and React are popular JavaScript-based frameworks that are commonly used
    and are as good a choice as any to build a frontend for a SaaS application. However,
    as this is a .NET-focused book, we will stick to .NET technology and use Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor is a modern web application framework developed by Microsoft that allows
    developers to build client-side web applications, using C# and .NET instead of
    JavaScript. Blazor was first introduced as an experimental project in 2018 and
    was later released as part of .NET Core 3.0 in 2019\. The main goal of Blazor
    is to enable developers to write full-stack web applications entirely in C# and
    .NET, providing a more familiar and productive development experience.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor is designed to solve the problem of developing and maintaining complex,
    data-driven web applications that require a lot of client-side interactivity,
    such as a SaaS application. With Blazor, developers can write code that runs in
    a browser using WebAssembly, enabling them to create rich and interactive user
    interfaces without relying on JavaScript. Blazor also provides a wide range of
    built-in features and tools, such as routing, data binding, and form validation,
    which can help developers to build complex web applications more quickly and easily.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor has become popular in recent years due to its ease of use, flexibility,
    and productivity. By allowing developers to use C# and .NET on the client side,
    Blazor provides a more consistent and familiar development experience, reducing
    the learning curve and enabling developers to be more productive. Additionally,
    Blazor’s tight integration with .NET provides a seamless development experience,
    with built-in debugging, testing, and deployment tools.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor is particularly suitable to build SaaS applications because it provides
    a scalable and reliable development platform that can handle a large number of
    users and data. Blazor’s ability to interface with .NET web API backends makes
    it a powerful tool to create a complete end-to-end solution, with a robust backend
    and a responsive frontend. Additionally, Blazor’s built-in features and tools
    to handle user input, data validation, and security make it an ideal choice to
    build complex and secure SaaS applications.
  prefs: []
  type: TYPE_NORMAL
- en: What is WebAssembly?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WebAssembly is a low-level binary format that enables the execution of code
    in a web browser. It is a portable, stack-based virtual machine that runs alongside
    JavaScript and provides a faster and more efficient way to execute code in the
    browser. WebAssembly is designed to work in conjunction with HTML, CSS, and JavaScript,
    allowing developers to write web applications using a variety of programming languages,
    including C, C++, Rust, and AssemblyScript.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly is different from JavaScript in that it is a compiled language,
    whereas JavaScript is an interpreted language. This means that code written in
    WebAssembly can be precompiled, making it faster to load and execute in the browser.
    Additionally, WebAssembly provides a more secure and sandboxed execution environment,
    which can help prevent security vulnerabilities and improve the reliability of
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly is becoming increasingly popular as a way to build web applications,
    especially for performance-intensive tasks such as gaming, image and video processing,
    and scientific simulations. With the increasing popularity of tools and frameworks
    such as Blazor, WebAssembly is also used more frequently in the context of building
    client-side web applications using languages other than JavaScript. Overall, WebAssembly
    is an exciting and powerful technology that changes the way we think about building
    web applications and enables a new era of innovation on the web.
  prefs: []
  type: TYPE_NORMAL
- en: The development environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have done all of our work in Visual Studio Code. We have added extensions
    that allow us to manipulate .NET projects, host and interact with databases, and
    also execute tests on an API.
  prefs: []
  type: TYPE_NORMAL
- en: I selected Visual Studio Code for the examples in this book because it is free,
    cross-platform, and allows us to do all sorts of things without requiring lots
    of tools to be installed. Furthermore, I have used dev containers to try to ensure
    that everything will “just work,” regardless of what computer you are running
    on.
  prefs: []
  type: TYPE_NORMAL
- en: I think this is really cool and also very practical when putting together a
    demo app in a book. I will continue this philosophy for this chapter on building
    a UI, but I need to acknowledge at this point that the development environment
    in the “main” Visual Studio application is superior to Blazor. I hope this will
    change in the near future and that this chapter will stand the test of time.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of the simple example that I present here, Visual Studio Code
    is fine. If you are building a more complex real-world project, then you may want
    to invest in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: UX considerations – knowing your customer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**User experience** (**UX**) is of paramount importance in modern application
    development. How a user interacts with your SaaS application is crucial, as poor
    UX can result in user frustration and abandonment. Therefore, considering the
    user’s experience should be the most important part of the process when designing
    a UI.'
  prefs: []
  type: TYPE_NORMAL
- en: At its core, UX is the practice of designing digital products, services, and
    systems that are useful, usable, and enjoyable for the people who use them. In
    today’s digital age, where people interact with technology on a daily basis, UX
    has become increasingly important to create successful products and services.
    Good UX can enhance a user’s satisfaction, engagement, and loyalty, while bad
    UX can result in frustration, confusion, and abandonment. UX design involves understanding
    user needs, goals, and behaviors, and using that knowledge to inform the design
    of UIs and interactions. It encompasses a range of disciplines, including visual
    design, interaction design, information architecture, and user research, among
    others. As digital products and services continue to play an increasingly important
    role in our daily lives, UX will continue to be a critical factor in their success.
  prefs: []
  type: TYPE_NORMAL
- en: UX is important, but it is also a complex and multifaceted field that can be
    challenging to master. While there are some scientific methods and principles
    that can be applied to UX design, such as user research, usability testing, and
    data analysis, the process of creating a great UX often involves a significant
    amount of artistry and creativity. Unlike some other fields, there are no absolute
    right or wrong answers in UX design, and what works for one user or product may
    not work for another. UX designers must balance a wide range of considerations,
    including user needs, business goals, technical constraints, and visual aesthetics,
    among others. This requires a combination of analytical skills, design skills,
    and intuition to create a UX that is both effective and aesthetically pleasing.
    In short, while there are scientific methods and principles that can help guide
    UX design, there is still a significant amount of artistry involved in creating
    great UXs.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of SaaS applications, UX is even more important than it is in
    other types of software. SaaS applications are typically subscription-based, meaning
    that users pay for access to the software on an ongoing basis. This means that
    they have the option to switch to a competitor at any time if they are not satisfied
    with the service they are receiving. In other words, SaaS companies are in a constant
    battle to retain their users, and poor UX can be the deciding factor in whether
    a user stays or goes. Additionally, SaaS applications are often complex and feature-rich,
    with a wide range of options and settings. This can make the UX even more challenging
    to design, as users need to be able to find what they are looking for quickly
    and easily. As a result, designing a great UX is crucial to the success of a SaaS
    application, as it can help to increase user satisfaction, reduce churn, and ultimately
    drive the success of the business.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll give some general pointers that may be useful to consider
    when you build a SaaS application.
  prefs: []
  type: TYPE_NORMAL
- en: User personas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: User personas are fictional characters that represent different types of users
    who may interact with an application. They are developed by gathering information
    about real users through surveys, interviews, and other forms of research. UX
    designers use this information to create a set of user personas that represent
    the different needs, behaviors, and motivations of their target users. User personas
    are important in the UX design process because they help to create a clear understanding
    of the people who will be using the application. By understanding the characteristics
    of the different personas, designers can make informed decisions about how to
    structure the UI, what features to include, and how to prioritize different aspects
    of the UX. For example, if the target audience includes some individuals who are
    tech-savvy individuals and some less technically proficient, the designer may
    need to create a UI that is both intuitive and easy to navigate. By creating user
    personas, UX designers can ensure that the design of the application is centered
    around the needs and expectations of its users, which can ultimately lead to a
    better UX and greater user satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a possible fictional tech-savvy user called “Sara”:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sara is a tech-savvy user who uses multiple devices and is comfortable with
    technology. She has a good understanding of technology trends and new applications
    and enjoys exploring new features and settings in an application. Sara prefers
    to use the latest technology and applications and may be interested in using keyboard
    shortcuts and other power-user features in an application. She is comfortable
    with troubleshooting issues and finding solutions independently, and may have
    a lower tolerance for slow load times or other technical issues. If an application
    does not meet her expectations, she may be more likely to abandon it. Overall,
    Sara is a user who is comfortable with technology and has high expectations for
    the applications she uses, and the design of the application should reflect her
    needs* *and expectations.*'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an avatar for a user persona is useful for designers and developers
    because it helps to create empathy and a better understanding of the user’s needs,
    goals, and behaviors. We have created the following avatar for Sara!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – An avatar for Sara](img/B19343_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – An avatar for Sara
  prefs: []
  type: TYPE_NORMAL
- en: User journey mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: User journey mapping is a visual representation of the steps a user takes to
    complete a task within an application, from the initial point of contact through
    to the completion of the task. User journey mapping is important because it helps
    to identify pain points and areas of frustration in the UX, as well as opportunities
    for improvement. By mapping the user journey, designers can get a clear picture
    of how users interact with the application and where they may encounter issues.
    This information can then be used to refine the design and make the UX more streamlined
    and intuitive. User journey mapping is related to user personas because it helps
    to create a more detailed understanding of how different personas interact with
    the application. By mapping the user journey for different personas, designers
    can identify how the UX differs between different types of users and make design
    decisions that are tailored to the needs of each persona. Ultimately, user journey
    mapping is a valuable tool to create a user-centered design that meets the needs
    of all users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a user journey for Sara, a tech-savvy user of the `GoodHabit`
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: Sara navigates to the `GoodHabits` app and logs in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The app displays a page with a list of Sara’s existing habits on the left side
    of the screen and an empty add/edit form on the right side of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sara clicks on the **Add New** button under the list of habits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The app populates the form with default values and changes the button text to
    **Save New**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sara fills out the form and clicks on the **Save** **New** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The app validates the form data and creates the new habit, associating it with
    Sara’s user account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The app adds the new habit to the list on the left side of the screen, and the
    habit is automatically selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The app updates the form on the right side of the screen with the new habit’s
    data and changes the button text to **Save Changes**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sara can make further changes to the habit if desired, and then she clicks on
    the **Save** **Changes** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The app validates the form data and updates the habit with the new data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The app highlights the updated habit on the list on the left side of the screen
    to indicate that it has been modified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sara verifies that the new habit has been added or updated successfully and
    is displayed correctly on the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing out these user journeys can be very useful for the design team, and
    also for the dev team, to better understand how users will interact with a system.
    A good understanding of these interactions will result in a better experience
    for the users, which will generally lead to the SaaS app generating more revenue!
  prefs: []
  type: TYPE_NORMAL
- en: It should not be assumed that everyone who uses your SaaS app will have the
    same level of abilities, and it is also very important to consider accessibility.
  prefs: []
  type: TYPE_NORMAL
- en: Accessibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accessibility refers to the practice of designing digital products and content
    in a way that ensures that they are usable by people with disabilities. This includes
    people with visual, auditory, motor, and cognitive impairments, among others.
    Accessibility is important because it helps to ensure that all users, regardless
    of their abilities, can access and use digital products and content. This not
    only benefits individuals with disabilities but also has broader social and economic
    benefits, as it helps to create a more inclusive society.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some tips and things to consider when designing for accessibility:'
  prefs: []
  type: TYPE_NORMAL
- en: Providing alternative text for images so that users with visual impairments
    can understand the content of an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that the color contrast between text and the background is sufficient
    so that users with visual impairments can read the text easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing closed captions or transcripts for videos and audio content so that
    users with auditory impairments can understand the content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using semantic HTML to ensure that assistive technologies can accurately parse
    and interpret the content of a web page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that an application is operable using keyboard-only navigation so that
    users with motor impairments can use an application easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing clear and concise instructions and feedback so that users with cognitive
    impairments can understand and use an application effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may be helpful to create some user personas to represent users who will benefit
    from these accessibility considerations, building some user journeys specifically
    for them.
  prefs: []
  type: TYPE_NORMAL
- en: Designing for accessibility is an important consideration for any digital product
    or content, helping to create a more inclusive and accessible society.
  prefs: []
  type: TYPE_NORMAL
- en: Visually appealing design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While UX always blends art and science to some extent, creating a visually appealing
    design leans much more on artistic creativity. It is easy to overlook this when
    building an application and focus on the more technical aspects. However, having
    a visually appealing design is an important aspect of UX and can have a significant
    impact on how users perceive and interact with digital products and content. A
    well-designed UI can make it easier for users to understand and navigate an application,
    and it can create a sense of trust and credibility that is important to build
    a strong brand. A visually appealing design should be aesthetically pleasing and
    engaging, while also being functional and usable. This means using a consistent
    color scheme, typography, and layout that is easy on the eyes and provides a clear
    visual hierarchy. It also means using appropriate imagery and graphics that enhance
    content and support the overall UX. Ultimately, a visually appealing design should
    be intuitive, easy to use, and engaging, helping to create a positive UX for all
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation and information architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UX design should strive to make the navigation of an application simple and
    intuitive for users. This means designing a clear and consistent menu structure,
    as well as providing helpful labels and descriptions for each menu item. The navigation
    should be easily accessible from any page within the application and enable users
    to quickly and easily move between different areas of it.
  prefs: []
  type: TYPE_NORMAL
- en: In a SaaS app, users often try to accomplish a specific task or goal, and they
    need to be able to easily find the content and features they need to accomplish
    that task. Effective navigation can help users quickly and easily move between
    different areas of an app, without getting lost or confused.
  prefs: []
  type: TYPE_NORMAL
- en: Information architecture is the process of organizing and structuring the content
    within an application in a logical and meaningful way. It involves grouping related
    content together, creating hierarchies of information, and establishing clear
    relationships between different pieces of content. A well-designed information
    architecture can make it easier for users to find the information they need, and
    it can also help to provide context and meaning for the content within the application.
    When designing the information architecture, it is important to consider the needs
    and goals of the users, as well as the content that is being presented, in order
    to create a structure that is clear, intuitive, and effective.
  prefs: []
  type: TYPE_NORMAL
- en: Information architecture is important for a SaaS app because it can help to
    ensure that the content within the app is organized in a way that is intuitive
    and meaningful for users. This can help users to better understand and engage
    with the content, and it can also make it easier for them to find the information
    they need. By designing a clear and effective information architecture, SaaS app
    designers can create an experience that is both functional and enjoyable for users,
    helping to build brand loyalty and customer satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: Responsive design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Responsive design is a design approach that aims to create digital products
    that adapt and respond to different screen sizes and device types. This has become
    increasingly popular as more and more users access websites and applications on
    a wide variety of devices, including desktops, laptops, tablets, and smartphones.
    With responsive design, the layout, content, and functionality of a website or
    application are optimized for each device type, allowing users to have a consistent
    and seamless experience, regardless of the device they use.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve responsive design, UX designers typically use a combination of flexible
    layouts, fluid images, and media queries, which allow the design to adapt to different
    screen sizes and resolutions. This means that elements of the design, such as
    the navigation, content, and images, will adjust and reposition themselves based
    on the size of the screen, in order to provide the best UX possible.
  prefs: []
  type: TYPE_NORMAL
- en: Responsive design helps to create a positive UX, as it ensures that users can
    access and use digital products on any device, at any time. With more and more
    users accessing the web and applications on mobile devices, responsive design
    has become a key consideration for UX designers and is essential to create a successful
    and accessible digital product.
  prefs: []
  type: TYPE_NORMAL
- en: When considering a SaaS application, this becomes even more important, as customers
    of the application will often require that they can access the app at any time,
    and on any device.
  prefs: []
  type: TYPE_NORMAL
- en: Feedback and user testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Feedback and user testing are essential to create a successful UX, as they allow
    designers to gather insights and information from real users about the usability,
    functionality, and effectiveness of their designs. This feedback can be used to
    identify areas of the design that work well, as well as areas that need improvement,
    helping designers to refine and optimize the UX.
  prefs: []
  type: TYPE_NORMAL
- en: To collect feedback and user testing data, UX designers use a variety of techniques,
    including surveys, interviews, usability testing, and user analytics. Surveys
    and interviews can help designers to collect qualitative feedback about the UX,
    including likes, dislikes, and pain points. Usability testing, on the other hand,
    involves observing users as they interact with the design, providing valuable
    insights into how users use an application, as well as areas of the design that
    may be causing confusion or frustration. User analytics can also be used to gather
    data about user behavior, such as how often users access certain features, or
    where they drop off in the user journey.
  prefs: []
  type: TYPE_NORMAL
- en: Once feedback and user testing data have been collected, designers can use them
    to inform and guide their design decisions, making changes and optimizations based
    on the insights gathered from real users. By incorporating feedback and user testing
    into the design process, UX designers can create a more user-centric and effective
    UX, leading to higher engagement, satisfaction, and customer loyalty.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may recall that way back in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056),
    we created a Blazor application. We will now start to build this out.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this chapter, we imagined a user persona called Sara, and we described
    a user journey where Sara adds a new good habit to her database. In this section,
    we will build out that user journey!
  prefs: []
  type: TYPE_NORMAL
- en: Planning the UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building a good UI is a complex process that involves careful planning and thoughtful
    execution. Before starting to create the UI, it’s essential to take the time to
    plan out the layout, design, and functionality of an application. This planning
    should encompass everything, from the UX to user interviews, wireframing, and
    prototyping.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in planning a UI is to define the user personas and UX. Understanding
    a user’s needs and the goals of an application is essential to create an interface
    that is both usable and engaging. One way to accomplish this is by conducting
    user interviews, which can help to identify pain points and opportunities for
    improvement. This feedback can then be used to shape the design and functionality
    of the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Once the user personas and UX are defined, it’s time to start thinking about
    the layout of the UI. Wireframing and prototyping are useful techniques to visualize
    the layout and design of the interface. These techniques allow designers to experiment
    with different ideas and make sure the application is intuitive and easy to navigate.
    Wireframes are basic sketches of the interface that help to establish the overall
    layout, while prototypes are interactive mock-ups that allow users to interact
    with the UI and give feedback.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to wireframing and prototyping, it’s important to consider the technical
    aspects of the application. This includes choosing the right technology stack,
    such as the appropriate framework and tools. For instance, Blazor is a popular
    framework to create UIs using C# and .NET, and it is an excellent choice to build
    a SaaS application.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, planning the UI is a crucial step in creating a simple yet effective
    interface for a SaaS application. It involves considering the UX, conducting user
    interviews, wireframing and prototyping, and choosing the appropriate technology
    stack. With careful planning, it’s possible to create a UI that is both functional
    and aesthetically pleasing, which will ultimately help to improve user engagement
    and satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: So that we can make progress, let’s assume that I have done all of the preceding
    and decided that the following represents the ideal UI for the Good Habits SaaS
    application.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.2 – A mock\uFEFF-up \uFEFFof the Good Habits app](img/B19343_07_2.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – A mock-up of the Good Habits app
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot represents a very basic UI that allows a user to see
    a list of their habits, add a new one, and edit or delete existing habits. This
    is basically just a simple **Create, Read, Update, Delete** (**CRUD**) implementation
    that would probably make a UX designer cry, but it will suffice for this demo!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we will stick to Visual Studio Code to build the UI, we will add some extensions
    to make our lives a bit easier. As always, we’ll do this by modifying `devcontainer.json`
    and add to the extensions array. Add the following extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These extensions will make our lives much easier as we build out this UI!
  prefs: []
  type: TYPE_NORMAL
- en: You will need to exit and re-enter the dev container environment so that the
    changes can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a ticket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In software development, a “ticket” is a term used to describe a unit of work
    that needs to be done on a project. Tickets are usually created to track bugs,
    feature requests, and any other tasks that need to be completed by the development
    team. They provide a way for project managers and developers to keep track of
    what needs to be done, who is responsible for completing a task, and the status
    of the work. Tickets can be as simple as a bug report or feature request, or they
    can be very detailed and include requirements, designs, and other documentation.
    The use of tickets helps to keep the development process organized and efficient,
    ensuring that everyone on a team is working toward the same goals.
  prefs: []
  type: TYPE_NORMAL
- en: Gherkin is a language that is often used to write specifications for software
    development projects, and it can be used when creating tickets. It is designed
    to be easy to understand by both technical and non-technical stakeholders, and
    it helps to ensure that everyone is on the same page when it comes to what needs
    to be done. Gherkin specifications are written in a specific format that is easy
    to read and understand, and they can be used to create automated tests that ensure
    that the software meets the requirements that have been specified. By using Gherkin
    to write tickets, developers can ensure that the work they do is directly tied
    to the needs of a project and that everyone on a team understands what needs to
    be done and why. This can help to reduce confusion and misunderstandings, leading
    to a more efficient and effective development process.
  prefs: []
  type: TYPE_NORMAL
- en: Gherkin is a plain-text, domain-specific language that is commonly used to assist
    in the writing of automated acceptance tests for software applications. It is
    designed to be human-readable and easy to understand by stakeholders, developers,
    and testers alike. Gherkin provides a simple syntax to define the behavior of
    an application in a structured and organized way, using a set of keywords and
    phrases.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key benefits of using Gherkin to write UI tickets is that it helps
    to ensure clarity and consistency across the development team. By using a standardized
    format to describe the desired behavior of a UI, everyone involved in the development
    process can understand what is expected and how to implement it. Gherkin also
    provides a common language that can be used to communicate between team members
    with different backgrounds and expertise.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of using Gherkin for UI tickets is that it promotes a user-centric
    approach to software development. By focusing on the desired user behavior and
    experience, Gherkin encourages developers to build applications that are intuitive,
    easy to use, and meet the needs of the end user. This approach can lead to more
    effective testing and a better overall UX.
  prefs: []
  type: TYPE_NORMAL
- en: Gherkin is a powerful tool to write UI tickets that can help to promote clarity,
    consistency, and user-centered design in software development. By providing a
    common language and structured format to describe behavior, Gherkin can help to
    ensure that everyone involved in the development process understands what is expected
    and how to achieve it. Additionally, by enabling automated testing, Gherkin can
    help to catch issues early and ensure a high-quality end product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a ticket that could be used to describe the user journey
    that we defined for Sara previously. We will use this ticket to guide us in the
    development of the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding ticket gives us a roadmap to follow to develop the UI. Coupled
    with the wireframe that we have created previously, it should be easy to build
    this simple UI!
  prefs: []
  type: TYPE_NORMAL
- en: But before we get started building, let’s take a quick look at the technology
    that we will use!
  prefs: []
  type: TYPE_NORMAL
- en: What is Blazor?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blazor is a modern web framework to build interactive web UIs using C# and .NET.
    It allows developers to write web applications using the same familiar language
    and tools that are used for desktop and mobile applications, as well as for RESTful
    APIs. Blazor supports two models to build web applications – Blazor WebAssembly
    and Blazor Server.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor WebAssembly is a client-side model that allows developers to build web
    applications entirely in C# and run them in any modern web browser, without the
    need for any server-side code. The application is loaded and executed directly
    in the browser, and any communication with the server is performed using standard
    web technologies such as HTTP and WebSockets – frequently using a WebAPI backend,
    which we used in previous chapters. Blazor WebAssembly applications can run both
    online and offline, making them suitable to build progressive web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor Server is a server-side model that allows developers to build web applications,
    using a similar programming model to client-side Blazor but with the server running
    the application code and rendering the UI in the browser. In this model, the application
    code runs on the server, and the UI is streamed to the client as HTML and JavaScript.
    This allows Blazor Server applications to have the same rich interactive features
    as client-side applications but with a higher degree of control over the UX.
  prefs: []
  type: TYPE_NORMAL
- en: Both models of Blazor provide developers with a powerful and modern way to build
    web applications, with the choice between client-side and server-side, depending
    on the specific requirements of a project. Blazor’s use of C# and .NET makes it
    a compelling option for developers who are already familiar with these technologies,
    and the ability to share code between the web and other types of applications
    can lead to greater efficiency and productivity. Additionally, Blazor’s support
    for Razor syntax and integration with Visual Studio and other development tools
    makes it a familiar and comfortable environment for developers to work in.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we will use Blazor WebAssembly (Wasm). This is a good choice
    when building a SaaS application with a RESTful API backend for a few reasons,
    some of which are stated here:'
  prefs: []
  type: TYPE_NORMAL
- en: Wasm runs entirely in the browser, which means that a user does not need to
    wait for server responses to load the application. This can result in faster load
    times, better UX, and reduced server load.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the application runs entirely in the browser, it can be made available
    offline. This is particularly useful for users who are on the go and do not have
    access to reliable internet connections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wasm allows more efficient processing of complex computations and graphics-intensive
    applications, which is particularly relevant for SaaS applications that may require
    a lot of data processing or advanced graphics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By offloading more of the processing to the client side, a Wasm-based SaaS application
    can reduce the amount of data that needs to be sent back and forth between a server
    and a client. This can result in reduced bandwidth requirements, faster load times,
    and reduced server load.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wasm can provide better security for SaaS applications, as it runs in a sandboxed
    environment, which makes it more difficult for malicious actors to exploit vulnerabilities
    in the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because Wasm is platform-agnostic, SaaS applications built using Wasm can be
    run on a variety of devices, including desktops, laptops, tablets, and smartphones.
    This can help to increase the reach of the application and make it more accessible
    to users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Blazor project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already set up a Blazor project in [*Chapter 2*](B19343_02.xhtml#_idTextAnchor056),
    but I’ll recap the steps here. Open a console and type in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! You can now start the client by typing `dotnet run` into the console.
    You’ll see the following in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – The Hello, world! Blazor app](img/B19343_07_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – The Hello, world! Blazor app
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with this template and make it look a bit more like the mock-up.
    Initially, we will use dummy data, but we will connect the frontend up to the
    API – by the end of this chapter, we will have a full stack SaaS application!
  prefs: []
  type: TYPE_NORMAL
- en: Building the UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, there is a small amount of config required in `Program.cs` in the client
    application. Make the class look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding base address connects to the API gateway that we configured
    in [*Chapter 6*](B19343_06.xhtml#_idTextAnchor140).
  prefs: []
  type: TYPE_NORMAL
- en: With that small piece of config done, we can get started with the functionality
    by adding a new page that will display the information we built up in the database
    in the previous chapters. We will also modify the navigation menu to link to this
    new page, removing the sample pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Pages` folder, you can delete the `Counter.razor` and `FetchData.razor`
    files and add a new file called `Habits.razor`. Your `Pages` folder should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The Pages folder](img/B19343_07_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – The Pages folder
  prefs: []
  type: TYPE_NORMAL
- en: 'With the preceding configured, we can add some basic setup on the `Habits.razor`
    page. Open the file and copy in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will give us an outline that we can start to build upon.
    However, before we can see this in the app, we need to modify the navigation menu
    to link to this new page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Shared` folder and locate the `NavMenu.razor` file. Change the navigation
    menu code to match the following. Note that the `href` property matches what we
    set in the `@page` attribute on the `Habits.razor` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With the menu configured, we can now run the application with `dotnet run` and
    see the changes we have made.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Starting to build the GoodHabits page](img/B19343_07_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Starting to build the GoodHabits page
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see that we have successfully added the
    navigation and sketched out the GoodHabits page! Let’s add some more functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by modifying the code in the code block to allow us to view, add,
    edit, and delete the habits. We will shortly bind these functions to UI controls
    so that we can manipulate the habits in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `@code` block, start by adding some class-level variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will allow us to select a habit out of the list, edit that habit, and store
    a state variable that tells the view when we are editing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a function that allows us to select a habit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a function that will allow us to add a new habit with some default properties
    to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a function that will allow us to edit a habit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a function that will allow us to delete a habit from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a function that will allow us to edit a habit from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a function that will allow us to save a habit that we have been editing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add a function that will allow us to cancel any edits that we made,
    should we change our minds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That should allow us to manipulate the habits in the list! Now, we will add
    the UI and bind the elements to the functions that we just created!
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by adding the list of habits to the left-hand pane. Copy the following
    HTML in directly under the `<h3>Good Habits</h3>` line in the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we loop over the list of dummy habits that we included in the
    code block, binding these habits to the functions that we added to the `@code`
    block. We have added buttons to add, edit, and delete the habits in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to add the HTML to display or edit the habit on the right-hand
    side of the screen. Add the following HTML directly under the `<h3>Habit` `Details</h3>`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There is quite a lot going on here. We have added two forms, one that is shown
    if the `IsEditing` property is set to `true` and one that is shown if it is not,
    allowing us to view or edit the habits.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to understand what is happening is to start the project and see
    what we have created!
  prefs: []
  type: TYPE_NORMAL
- en: 'Type `dotnet run` into the console and go to the site in a browser. Then, navigate
    to the GoodHabits page, and you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 7.6 – The Good Habits UI](img/B19343_07_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – The Good Habits UI
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, we have a list of habits, and clicking
    on the name of any of these will bring up the “view” form.
  prefs: []
  type: TYPE_NORMAL
- en: The UI should be fairly intuitive, if not very pretty! I think it is a very
    useful exercise to play with this UI and look at how the various functions and
    elements we added to the Razor file interact.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have a functional UI, but there is no connection to that backend
    yet. Let’s work on that now!
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the UI to the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we built the UI and added the functionality to add, delete, view,
    and update the habits. However, currently, there is no connection to the API that
    we have built up. Let’s remedy that now!
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with CORS issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CORS** stands for **Cross-Origin Resource Sharing**. It’s a mechanism that
    allows web pages to make requests to a different domain than the one that served
    the web page. CORS is a security feature that helps to prevent unauthorized access
    to web servers. When a web page attempts to make a cross-origin request, the server
    it makes the request to must respond with specific headers that allow the request
    to go through. If the server does not send these headers, the browser will block
    the request.'
  prefs: []
  type: TYPE_NORMAL
- en: We need to configure the API gateway project to accept connections from any
    origin when in development mode. Please note that this represents a security risk
    and should not be replicated in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `Program.cs` in the `API Gateway` project (*not in the Blazor project
    – make sure you are in the correct* `Program.cs` *file!!*). Locate the development
    settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, make sure that the following code is included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that the API will accept requests, but again, this is only
    suitable in development and not suitable for a production environment!
  prefs: []
  type: TYPE_NORMAL
- en: Logic, including calling the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will modify the code that we built previously to connect to the API. If we
    did our jobs well, and correctly separated the UI elements from the logic, we
    should be able to make this change by only modifying the code. Let’s see how we
    did!
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a string constant that points to the API URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to set the port correctly. Also, note that hardcoding a URL is not
    really good practice, but it will suffice for this demo.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, comment out or delete the three dummy habits that we added. From now
    on, we will get the habits that we stored in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add a hook to fetch the habits from the database. We will tap into
    the initialization hooks and add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This uses `httpClient` to call the API endpoint, which will return the list
    of habits that are stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can add the calls to interact with the add and edit endpoints, we
    will need to create some classes. Add two private classes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, modify the `AddHabit` method to interact with the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a line to the `DeleteHabit` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, modify the `SaveHabit` method to include the required interactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That’s done! With just a few small changes, we are now hooked up to the API
    and the database. We have now created the outline of a fully functioning SaaS
    application!
  prefs: []
  type: TYPE_NORMAL
- en: To prove this, go into the **Run and Debug** menu and execute the **Run All**
    compound task that we created in [*Chapter 6*](B19343_06.xhtml#_idTextAnchor140).
    This will start both the microservice projects, the API gateway, and the client
    project. Then, navigate to the client in the browser. You should see the contents
    of your habits database on the screen! We are much closer to completing our SaaS
    application!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – The Good Habits UI, connected to the gateway API](img/B19343_07_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – The Good Habits UI, connected to the gateway API
  prefs: []
  type: TYPE_NORMAL
- en: Building usable UIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example that we have built here is a good technical demonstration of the
    essential techniques to incorporate the SaaS backend with a UI, but I think it’s
    safe to say that it lacks a bit of flair. These days, the average consumer expectations
    of a UI for a SaaS app are very high – essentially, customers will demand a very
    similar experience to a native application but running in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: To make a UI look more modern and responsive, we would typically use an off-the-shelf
    responsive UI framework. In addition to expecting the UI to perform like a desktop
    app, there is generally also an expectation that the UI should work on a tablet
    and a phone. Finally, not everyone shares the same abilities, and there are standard
    methods to endure that your UI is accessible to differently abled persons. In
    this section, we will look into all this, starting with responsive UI frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Responsive UI frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Responsive UI frameworks are a collection of pre-built components, styles, and
    scripts designed to help developers create responsive and adaptive web applications
    with ease. These frameworks provide developers with a set of tools that can be
    used to build UIs that automatically adjust to different devices and screen sizes,
    ensuring a consistent and enjoyable UX across various platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The use of responsive UI frameworks can significantly streamline the development
    process by providing ready-to-use components and a cohesive design system. This
    enables developers to focus more on an application’s functionality and less on
    the complexities of building responsive layouts from scratch. Additionally, these
    frameworks typically adhere to well-established design principles and best practices,
    ensuring that the final product is not only visually appealing but also accessible
    and user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap is an open source and widely used CSS framework developed by Twitter.
    It simplifies the process of creating responsive and mobile-first websites by
    providing a comprehensive set of reusable components, such as buttons, forms,
    and navigation elements. Bootstrap also includes a responsive grid system based
    on the **Flexible Box Layout Module** (**Flexbox**), making it easy to create
    fluid layouts that adapt to different screen sizes. With its extensive documentation
    and large community, Bootstrap remains a popular choice among developers.
  prefs: []
  type: TYPE_NORMAL
- en: Foundation, created by ZURB, is another popular responsive frontend framework
    that focuses on providing a robust and flexible foundation to build custom web
    applications. It offers various pre-built components, a responsive grid system,
    and a modular architecture that enables developers to use only the components
    they need for their projects. Foundation is known for its performance optimizations
    and compatibility with a wide range of devices, making it a suitable choice for
    complex projects that require advanced customization and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Material-UI is a popular React-based UI framework that implements Google’s Material
    Design guidelines. Material-UI provides a consistent and modern look and feel
    for web applications, ensuring that UIs are both visually appealing and easy to
    navigate. It includes a set of pre-built components, a responsive layout system,
    and a theming system that allows for easy customization. By following Material
    Design principles, Material-UI helps developers create UIs that adhere to established
    usability standards.
  prefs: []
  type: TYPE_NORMAL
- en: While Flexbox is a powerful CSS layout module that simplifies the design of
    flexible and responsive layouts for web pages, it is not a full-fledged responsive
    UI framework. Instead, it is a valuable tool that can be used in conjunction with
    other frameworks to create adaptive layouts. Many responsive UI frameworks, such
    as Bootstrap and Foundation, incorporate Flexbox as part of their grid systems,
    leveraging its capabilities to create versatile and fluid layouts for their components.
  prefs: []
  type: TYPE_NORMAL
- en: It is definitely recommended to choose one of these to integrate with your project.
    It would be an excellent learning exercise to apply one of these frameworks to
    the demo UI that we created previously!
  prefs: []
  type: TYPE_NORMAL
- en: Responsive design techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simply installing one of the responsive frameworks described previously is not
    quite enough. You will need to master some of the techniques to get the most out
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will quickly explore the fundamental responsive design techniques,
    including fluid grids, flexible images, and media queries. By understanding and
    applying these techniques in conjunction with responsive UI frameworks, you can
    build usable UIs that provide a consistent and enjoyable experience across various
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Fluid grids form the backbone of responsive design by enabling flexible layouts
    that adjust dynamically, based on screen size. Instead of using fixed-width units
    such as pixels, fluid grids use relative units such as percentages to define the
    width of elements. This ensures that the layout automatically scales and reflows
    as the viewport changes. For example, when working with Bootstrap, you can create
    a fluid grid by utilizing its predefined grid classes, such as `.container`, `.row`,
    and `.col`. These classes enable you to define a responsive grid structure that
    adapts to different screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Flexible images ensure that media content, such as images and videos, also scales
    and adapts to different screen sizes. By setting the max-width property of images
    to 100%, images will automatically scale down to fit the width of their containing
    element, preventing them from overflowing and disrupting the layout. When working
    with frameworks such as Foundation or Material-UI, you can use their built-in
    classes or components to handle image scaling, ensuring that your media content
    remains responsive across various devices.
  prefs: []
  type: TYPE_NORMAL
- en: Media queries are a powerful CSS feature that allows you to apply different
    styles based on the characteristics of a user’s device, such as screen size, resolution,
    or orientation. By using media queries, you can define breakpoints at which your
    layout and styles change, ensuring that your UI remains usable and visually appealing
    at different screen sizes. Most responsive UI frameworks, such as Bootstrap and
    Material-UI, provide predefined media queries and breakpoints that you can use
    or customize to suit your specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: By combining these core responsive design techniques with the features provided
    by responsive UI frameworks, you can create web applications that are not only
    visually appealing but also highly functional and adaptable to various devices
    and screen sizes. This ultimately contributes to building usable UIs that enhance
    the overall UX and cater to diverse user needs and preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Designing for different screen sizes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These days, it is impossible to predict what device a user will choose to use
    to access your SaaS application. As a result, it’s crucial to consider different
    screen sizes and resolutions when designing responsive web applications. By doing
    so, you can ensure that your UIs look and function well across different devices,
    providing a consistent and enjoyable UX.
  prefs: []
  type: TYPE_NORMAL
- en: 'When designing for different screen sizes, it’s essential to follow a few key
    guidelines and best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: It can be very helpful to take a mobile-first approach. Start by designing your
    layout and UI for smaller screens, such as smartphones, and then progressively
    enhance the design for larger screens. This approach ensures that your application
    remains functional and visually appealing on smaller devices, while taking advantage
    of the additional screen real estate on larger ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned earlier, responsive UI frameworks such as Bootstrap, Foundation,
    and Material-UI provide pre-built components, grid systems, and predefined media
    queries that make it easier to create adaptive layouts for various screen sizes.
    Leveraging these frameworks can significantly streamline the development process
    and ensure that your UIs remain consistent and functional across different devices.
    Remember to apply best practices and use good responsive design techniques!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always test on multiple devices and screen sizes. During the development process,
    test your application on a variety of devices and screen sizes to identify potential
    issues and ensure a consistent UX. You can use device emulators, browser developer
    tools, or physical devices to test your application’s responsiveness and make
    any necessary adjustments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimize your application’s performance for different devices, as slower load
    times and inefficient resource usage can significantly impact the UX, especially
    on mobile devices. Consider factors such as image optimization, code minification,
    and lazy loading to improve the performance of your application across different
    screen sizes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By following these guidelines and best practices, you can create responsive
    web applications that provide a consistent and enjoyable UX across various devices
    and screen sizes. Utilizing responsive UI frameworks and responsive design techniques
    will ensure that your UIs adapt seamlessly, catering to the diverse needs and
    preferences of your users.
  prefs: []
  type: TYPE_NORMAL
- en: Accessibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating accessible and inclusive web applications is an essential aspect of
    responsible and empathetic design. By considering the needs of differently abled
    users, you ensure that your SaaS applications provide equal access and opportunities
    for everyone, fostering a more inclusive online environment.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing accessibility and inclusivity in your web applications is really important
    for a few reasons. Doing so gives a wider audience reach. By making your application
    accessible, you cater to a larger audience, including differently abled users,
    who might otherwise face barriers when interacting with your application.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, a UI that is designed to be accessible will result in a
    better overall experience in general. Accessible design principles often result
    in better usability for all users, as they promote clear and intuitive interfaces
    that are easy to navigate and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is the right thing to do. We should strive to make the internet,
    and indeed the world, a more inclusive place. If we can make a very tiny difference
    by taking the time to make our applications accessible, then we should!
  prefs: []
  type: TYPE_NORMAL
- en: To create more accessible web applications, it’s important to follow established
    accessibility standards and guidelines, such as the **Web Content Accessibility
    Guidelines** (**WCAG**) and the **Americans with Disabilities Act** (**ADA**)
    Standards for Accessible Design. These guidelines provide a framework to ensure
    that your application is usable and accessible for differently abled users.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several tools and techniques available to address common accessibility
    challenges and improve the UX for differently abled users:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Screen readers**: These assistive technologies convert text and other onscreen
    content into speech or braille, helping visually impaired users to access and
    navigate web applications. Ensure that your application’s content is structured
    semantically, with proper use of headings, landmarks, and alternative text for
    images to support screen reader users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keyboard navigation**: Some users may rely solely on a keyboard to navigate
    web applications. Ensure that your application supports keyboard navigation by
    providing visible focus indicators, logical tab order, and keyboard-accessible
    interactive elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Color contrast**: Users with visual impairments or color blindness may have
    difficulty perceiving content with low contrast. Ensure that your application’s
    color scheme and design elements adhere to the recommended contrast ratios, as
    specified by the WCAG.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accessible forms**: Users with cognitive or motor impairments may struggle
    with complex forms and input fields. Simplify forms, provide clear labels, and
    use proper input types to make it easier for all users to interact with your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accessible Rich Internet Applications (ARIA)**: This set of attributes helps
    enhance the accessibility of dynamic content and advanced UI controls. Use ARIA
    attributes to provide additional information about the structure and functionality
    of your application, ensuring that assistive technologies can interpret and interact
    with it correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By considering the needs of differently abled users and implementing these tools
    and techniques, you can create web applications that are more accessible, inclusive,
    and user-friendly. This not only benefits your users but also contributes to the
    overall success of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve covered a lot of ground in terms of designing and building
    a UI for a SaaS application. We’ve talked about the importance of UX and how to
    design for user personas, plan user journeys, and create visually appealing and
    responsive designs. We’ve also discussed the importance of UI testing and how
    to build a simple UI using Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key takeaways from this chapter is the importance of UX in the development
    of a SaaS application. A well-designed and intuitive UI can make all the difference
    in terms of user adoption, retention, and satisfaction. By planning for user personas
    and user journeys, we can ensure that we’re building an interface that meets the
    needs and expectations of our target audience.
  prefs: []
  type: TYPE_NORMAL
- en: Another important takeaway is the value of using a modern UI framework such
    as Blazor. By using Blazor, we can take advantage of the power and flexibility
    of .NET to build rich, interactive, and responsive UIs that can communicate effectively
    with backend APIs. Blazor allows us to use C# and .NET skills to build web applications
    that run in a browser, using WebAssembly to execute .NET code on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve also covered some key best practices to build a UI, including designing
    for accessibility, using responsive design, optimizing performance and load times,
    and providing feedback and testing for users. These are all essential elements
    of a well-designed and user-friendly UI.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of the chapter, we delved into how to connect a Blazor UI
    to a backend API. We discussed how to configure the Blazor client to communicate
    with the API, how to define data models, and how to retrieve and update data.
    We also talked about the importance of error handling, testing, and debugging,
    ensuring that our application is robust and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: By following the steps outlined in this chapter, you will have a good understanding
    of how to design and build a UI for a SaaS application and how to connect that
    interface to a backend API. You will be equipped with the tools and knowledge
    needed to build an intuitive, visually appealing, and responsive UI that meets
    the needs of your target audience, while also being performant and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, the UI is a critical component of any SaaS application, and designing
    and building a great UI requires a combination of technical and creative skills.
    By following the best practices and guidelines covered in this chapter, you will
    be well on your way to building a UI that is intuitive, engaging, and effective,
    helping you to achieve your business goals.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about authentication and authorization, with
    specific reference to how this will affect a multi-tenant, microservice SaaS application!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Build beautiful web apps with Blazor: [https://dotnet.microsoft.com/en-us/apps/aspnet/web-apps/blazor](https://dotnet.microsoft.com/en-us/apps/aspnet/web-apps/blazor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VS Code and Blazor WASM: [https://dev.to/sacantrell/vs-code-and-blazor-wasm-debug-with-hot-reload-5317](https://dev.to/sacantrell/vs-code-and-blazor-wasm-debug-with-hot-reload-5317)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Call a web API from ASP.NET Core Blazor: [https://learn.microsoft.com/en-us/aspnet/core/blazor/call-web-api?view=aspnetcore-7.0&pivots=server](https://learn.microsoft.com/en-us/aspnet/core/blazor/call-web-api?view=aspnetcore-7.0&pivots=server)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blazor WebAssembly HttpClient: [https://code-maze.com/blazor-webassembly-httpclient/](https://code-maze.com/blazor-webassembly-httpclient/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Blazor, and how does it allow us to create web applications using C#
    and .NET?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we automatically generate a client that connects to a .NET web API from
    a Blazor application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we consume data from a .NET web API in a Blazor application, and what
    are some best practices to handle errors and exceptions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a user persona?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to map a user journey before starting to build a UI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
