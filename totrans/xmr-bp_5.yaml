- en: Chapter 5. Building a Stocklist Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章. 构建股票列表应用程序
- en: In this chapter, we step back into `Xamarin.Forms` and look at detailing our XAML
    interfaces using CustomRenderers, Styles, and ControlTemplates. We will also look
    at the use of animations and a basic introduction to compound animations. Then,
    we are going to build a simple web service providing our mobile application with
    a JSON feed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了`Xamarin.Forms`，并探讨了如何使用CustomRenderers、Styles和ControlTemplates来详细设计我们的XAML界面。我们还将探讨动画的使用以及复合动画的基本介绍。然后，我们将构建一个简单的Web服务，为我们的移动应用程序提供JSON数据流。
- en: 'Expected knowledge:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 预期知识：
- en: JSON serialization/deserialization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON序列化/反序列化
- en: Some understanding of API controllers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些关于API控制器的理解
- en: Visual Studio
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio
- en: Some understanding of Linq queries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些关于Linq查询的理解
- en: Some understanding of Observables and IObservables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些关于Observables和IObservables的理解
- en: Some knowledge of IIS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些关于IIS的知识
- en: 'In this chapter, you will learn the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Understanding the backend
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解后端
- en: Creating an ASP.Net Web API 2 project
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建ASP.Net Web API 2项目
- en: Building an API controller
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建API控制器
- en: Setting up mobile projects
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置移动项目
- en: Building core mobile projects
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建核心移动项目
- en: Improving app performance
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高应用性能
- en: Creating a global `App.xaml`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建全局`App.xaml`
- en: Theming with `ControlTemplates`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ControlTemplates`进行主题化
- en: Updating the `MainPageViewModel`
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`MainPageViewModel`
- en: Creating Stocklist web service controller
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建股票列表Web服务控制器
- en: '`ListViews` and `ObservableCollections`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListViews`和`ObservableCollections`'
- en: Value converters
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值转换器
- en: Styles
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式
- en: Further optimization with XAML
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XAML进行进一步优化
- en: Creating `StockItemDetailsPage`
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`StockItemDetailsPage`
- en: Custom renderers
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义渲染器
- en: Adding styles for custom elements
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为自定义元素添加样式
- en: Creating the `StockItemDetailsPageViewModel`
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`StockItemDetailsPageViewModel`
- en: Setting up native platform projects
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置本地平台项目
- en: Hosting the Web API project locally
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地托管Web API项目
- en: Understanding the backend
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解后端
- en: As mobile developers, we are client side developers. We build user interfaces
    and absorb JSON data from web services. One advantage of developing in both server
    and client is the ability to tailor the back end to meet the needs of the mobile
    application. This can result in enhancing performance with data transactions on
    a web API. Building fast and reliable mobile applications can be difficult if
    we have to build off an old, slow-running back end. If users experience slow and
    unstable applications, they will normally never return to use it again.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 作为移动开发者，我们是客户端开发者。我们构建用户界面，并从Web服务中吸收JSON数据。在服务器和客户端同时开发的一个优势是能够根据移动应用程序的需求调整后端。这可以通过在Web
    API上进行数据事务来提高性能。如果我们必须基于一个旧的有问题的后端进行构建，构建快速且可靠的移动应用程序可能会很困难。如果用户遇到缓慢和不稳定的应用程序，他们通常永远不会再次使用它。
- en: In this example, we will build a simple web service that our mobile application
    will use. Let's begin by opening up Visual Studio.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将构建一个简单的Web服务，我们的移动应用程序将使用它。让我们首先打开Visual Studio。
- en: Creating an ASP.Net Web API 2 project
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ASP.Net Web API 2项目
- en: 'We are going to start with creating a new project in Microsoft Visual Studio.
    Go to **File** | **New Project** and select a new Visual C# ASP.Net project:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在Microsoft Visual Studio中创建一个新项目开始。转到**文件** | **新建项目**，然后选择一个新的Visual C#
    ASP.Net项目：
- en: '![Creating an ASP.Net Web API 2 project](img/B05293_05_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![创建ASP.Net Web API 2项目](img/B05293_05_01.jpg)'
- en: We want to then select the **Empty** template and click the **Web API** checkbox.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想选择**Empty**模板，然后点击**Web API**复选框。
- en: '![Creating an ASP.Net Web API 2 project](img/B05293_05_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![创建ASP.Net Web API 2项目](img/B05293_05_02.jpg)'
- en: We can actually test the project right away and click **Run**, it will automatically
    deploy the site and run the application in your default browser. We now have our
    base **ASP.NET** application template, let's look more closely at the project
    structure. In the Solution Explorer, starting with the `Models` folder, this is
    where we create all our data objects that represent the data in the application,
    which are the objects that will be serialized to JSON and sent over HTTP requests.
    Then, in the `Controllers` folder, this is where we have our API controllers,
    which are objects that handle HTTP requests. These are the main two areas we are
    going to be focusing on.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以立即测试项目并点击**运行**，它将自动部署网站并在你的默认浏览器中运行应用程序。我们现在有了我们的基础**ASP.NET**应用程序模板，让我们更仔细地看看项目结构。在解决方案资源管理器中，从`Models`文件夹开始，这是我们创建所有代表应用程序中数据的对象的地方，这些对象将被序列化为JSON并通过HTTP请求发送。然后，在`Controllers`文件夹中，这是我们API控制器所在的地方，这些是处理HTTP请求的对象。这是我们将要关注的两个主要区域。
- en: 'Let''s start with creating a data model for a single stock item. Add a new
    file to the `Models` folder called `StockItem.cs`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建单个库存项目的数据模型开始。在`Models`文件夹中添加一个名为`StockItem.cs`的新文件：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This object will be serialized into JSON and passed through our API controllers
    for the mobile application to retrieve. Normally, in every `MVC` / `ASP.NET` application,
    we have a data source layer and a Web API layer. In our data source layer, this
    is where the database sits, we store data here where our business logic layer
    will perform reads and writes. Our API layer will normally use the business logic
    layer to access the data and send over the network, a visual representation can
    be seen as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象将被序列化为JSON并通过我们的API控制器传递给移动应用程序以检索。通常，在每一个`MVC` / `ASP.NET`应用程序中，我们都有一个数据源层和一个Web
    API层。在我们的数据源层，这就是数据库所在的地方，我们在这里存储数据，我们的业务逻辑层将执行读取和写入。我们的API层通常使用业务逻辑层来访问数据并通过网络发送，可视表示如下：
- en: '![Creating an ASP.Net Web API 2 project](img/B05293_05_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![创建ASP.Net Web API 2项目](img/B05293_05_03.jpg)'
- en: Building an API controller
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建API控制器
- en: Web API controllers are used to handle web requests. 99% of the time, mobile
    applications will always use an API layer in which it will call web requests to
    retrieve data, perform login, and so on. For our example, we are going to add
    a new empty `WEBAPI 2` controller.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Web API控制器用于处理Web请求。99%的情况下，移动应用程序总是会使用一个API层，它将调用Web请求来检索数据、执行登录等。在我们的例子中，我们将添加一个新的空`WEBAPI
    2`控制器。
- en: '![Building an API controller](img/B05293_05_04.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![构建API控制器](img/B05293_05_04.jpg)'
- en: 'Implement the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 实现以下内容：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Looking more closely at the code above, the API has two functions, one for
    returning all stock items, and another for returning a particular stock item.
    If we want to access this API controller via HTTP requests, the URLs will be:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看上面的代码，这个API有两个函数，一个用于返回所有库存项目，另一个用于返回特定的库存项目。如果我们想通过HTTP请求访问这个API控制器，URL将会是：
- en: Get all stock items
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取所有库存项目
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Get a particular stock item by ID
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过ID获取特定的库存项目
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Does this format look familiar?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个格式看起来熟悉吗？
- en: We will use these two calls inside our mobile application to retrieve data we
    have sitting on the backend.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的移动应用程序中使用这两个调用来检索后端的数据。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In order to have this API live we have two options: we can either deploy the
    site online (that is, using Azure or Amazon), or we can host it locally (using
    localhost).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个API活跃，我们有两种选择：我们可以将网站部署到线上（即使用Azure或Amazon），或者我们可以本地托管它（使用localhost）。
- en: Let's test the API layer and run the project. When the browser opens, paste
    the following URL into the browser: `localhost:{PORT}/api/GetAllStockItems`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试API层并运行项目。当浏览器打开时，将以下URL粘贴到浏览器中：`localhost:{PORT}/api/GetAllStockItems`。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The port number will be automatically assigned when the project is run so make
    sure you paste the correct port number specific to your project.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目运行时，端口号将自动分配，所以请确保你粘贴了特定于你项目的正确端口号。
- en: You should see an XML displayer with the results from the items in the API controller.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个XML显示器，显示API控制器中项目的结果。
- en: Setting up the mobile projects
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置移动项目
- en: 'Moving back to the client side, we now need to start building our mobile applications.
    Let''s start with creating a blank `Xamarin.Forms` application:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 回到客户端，我们现在需要开始构建我们的移动应用程序。让我们从创建一个空的`Xamarin.Forms`应用程序开始：
- en: '![Setting up the mobile projects](img/B05293_05_05.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![设置移动项目](img/B05293_05_05.jpg)'
- en: Call the application `Stocklist`, and let's start with the iOS application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序命名为 `Stocklist`，让我们从 iOS 应用程序开始。
- en: Building core mobile projects
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建核心移动项目
- en: Let's add two new PCL projects, call them `Stocklist.XamForms` and `Stocklist.Portable`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加两个新的 PCL 项目，命名为 `Stocklist.XamForms` 和 `Stocklist.Portable`。
- en: '![Building core mobile projects](img/B05293_05_06.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![构建核心移动项目](img/B05293_05_06.jpg)'
- en: 'In the **Stocklist.Portable** project we want to add the following nuget packages:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Stocklist.Portable** 项目中，我们想要添加以下 NuGet 包：
- en: Microsoft HTTP client libraries
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft HTTP 客户端库
- en: Autofac
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Autofac
- en: Newtonsoft.Json
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Newtonsoft.Json
- en: Reactive extensions (main library)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式扩展（主要库）
- en: 'In the `Stocklist.XamForms` project we want to add the following nuget packages:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Stocklist.XamForms` 项目中，我们想要添加以下 NuGet 包：
- en: Microsoft HTTP client libraries
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft HTTP 客户端库
- en: Autofac
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Autofac
- en: Xamarin.Forms
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xamarin.Forms
- en: Reactive extensions (main library)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式扩展（主要库）
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Just copy the exact names of the libraries to bring up the libraries you require
    via the Package Manager tool.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 只需复制库的确切名称，通过包管理器工具调出所需的库。
- en: Now that we have our projects ready to go we can begin coding. From our previous
    solution in [Chapter 3](ch03.html "Chapter 3. Building a GPS Locator Application"),
    *Building a GPS Locator Application*, we want to reuse some major parts, such
    as the `IoC` container, modules, and cross-platform navigation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了项目，我们可以开始编码。从我们之前的解决方案 [第 3 章](ch03.html "第 3 章。构建 GPS 定位器应用程序")，*构建
    GPS 定位器应用程序*，我们想要重用一些主要部分，例如 `IoC` 容器、模块和跨平台导航。
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Keeping mobile solutions modular and decoupled makes it easier to share code
    between different solutions. Why do you think we have nuget packages?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 保持移动解决方案模块化和解耦，使得在不同解决方案之间共享代码变得更容易。你认为我们为什么有 NuGet 包？
- en: Like our `Locator` application, we will reuse the `MainPage` and `MainPageViewModel` objects.
    Copy these items over to your new projects and place the XAML page into a new
    folder called `Pages` in `Stocklist.XamForms`, and place the view-model object
    into a new folder called `ViewModels` inside `Stocklist.Portable`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的 `Locator` 应用程序一样，我们将重用 `MainPage` 和 `MainPageViewModel` 对象。将这些项目复制到您的新项目中，并将
    XAML 页面放入 `Stocklist.XamForms` 中的新文件夹 `Pages`，并将视图模型对象放入 `Stocklist.Portable`
    内的新文件夹 `ViewModels` 中。
- en: Improving app performance
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高应用性能
- en: Let's look at a few ways we can improve application performance. Mobile phones
    do not have desktop processors, users typically run your application an older
    devices, meaning the performance power maybe be lacking. This is why we must test
    applications on older and newer devices to compare the performance difference
    and any API/OS changes that may effect behavior.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以通过哪些方式提高应用程序的性能。手机没有桌面处理器，用户通常在较旧的设备上运行您的应用程序，这意味着性能可能不足。这就是为什么我们必须在较旧和较新的设备上测试应用程序，以比较性能差异以及可能影响行为的任何
    API/OS 变更。
- en: Tip
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Running applications on simulators can give different results when running on devices.
    Make sure you always test on physical devices before releasing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器上运行应用程序与在设备上运行时可能会得到不同的结果。确保在发布前始终在物理设备上进行测试。
- en: Let's take a look at the `MainPage.xaml` page from the `Locator` project. Here
    we will make small tweaks in the XAML layout to slightly improve the performance.
    The changes are very minor and will only improve performance by a millisecond
    here and there, but when you combine 100s of these small improvements, the end
    result will make a difference.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Locator` 项目的 `MainPage.xaml` 页面。在这里，我们将对 XAML 布局进行一些小的调整，以略微提高性能。这些更改非常微小，并且只会在这里和那里提高毫秒级的性能，但当你将
    100 多个这样的小改进结合起来时，最终结果将会有所不同。
- en: We can see a **Grid** with three elements inside, now why did we pick a Grid?
    Grids are good for views which we use to control any overlaying, or covering entire
    section/pages in which it is placed. Our first question is do we need to cover
    the entire screen for the landing page? No we don't, so we can replace the Grid
    with a `StackLayout`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一个包含三个元素的 **Grid**，那么我们为什么选择 Grid 呢？Grid 适用于视图，我们用它来控制任何覆盖或覆盖放置位置的整个部分/页面。我们的第一个问题是是否需要覆盖整个屏幕以用于着陆页？不，我们不需要，因此我们可以用
    `StackLayout` 替换 Grid。
- en: One rule to apply, don't use a Grid when a `StackLayout` will do, and don't
    use multiple StackLayouts when a Grid will do.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一条规则：当 `StackLayout` 可以胜任时，不要使用 Grid，当 Grid 可以胜任时，不要使用多个 StackLayout。
- en: 'One `StackLayout` will render faster than a single Grid when we don''t need
    to cover the screen or do any overlaying. Let''s replace the containing Grid with
    a `StackLayout`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不需要覆盖整个屏幕或进行任何叠加时，一个 `StackLayout` 的渲染速度会比单个 `Grid` 快。让我们将包含的 `Grid` 替换为
    `StackLayout`：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Don''t stop now, let''s add some more. Turn attention to the `DescriptionLabel`,
    creating bindings for static text values that never change is wasteful. Instead,
    we will use `Spans` because they are a tad faster to render. First, create a new
    `.resx` file called `LabelResources.resx`, add a new variable called `DescriptionMessage`,
    and set the value to the string `Welcome to the Grocery Store`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不要停下来，让我们再添加一些。关注 `DescriptionLabel`，为永远不会改变的静态文本值创建绑定是浪费的。相反，我们将使用 `Spans`，因为它们渲染得更快。首先，创建一个名为
    `LabelResources.resx` 的新 `.resx` 文件，添加一个名为 `DescriptionMessage` 的新变量，并将值设置为字符串
    `欢迎来到杂货店`：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ignore everything above the first `data` tag; this will be automatically generated
    when the file is created.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略第一个 `data` 标签之上的所有内容；当文件创建时，这将自动生成。
- en: 'Now, let''s import the `namespace` prefix in our `MainPage`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的 `MainPage` 中导入 `namespace` 前缀：
- en: 'Add the preceding line to the starting tag of the page:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的行添加到页面的起始标签中：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now let''s rebuild the label item:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新构建标签项：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Looking at this more closely, we have a `Span` that is enclosed by a `FormattedString`
    tag, and the `FormattedString` tag is enclosed in the `Label.FormattedText` property.
    The `Span` is taking a static reference from our new `LabelResources`, and we
    have also moved the `OnPlatform` changes into the `Span` object (exactly the same
    as the label, but instead of the `TextColor` property, we are using the `Foreground`
    property).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，我们有一个被 `FormattedString` 标签包围的 `Span`，而 `FormattedString` 标签则被包含在 `Label.FormattedText`
    属性中。`Span` 正在从我们的新 `LabelResources` 中获取静态引用，并且我们也将 `OnPlatform` 的更改移动到了 `Span`
    对象中（与标签完全相同，但不是使用 `TextColor` 属性，而是使用 `Foreground` 属性）。
- en: These are two tiny enhancements for one label, you probably won't notice much
    of a difference in performance. If we had a page with a lot of static labels,
    it would make a small difference in loading speeds. Rendering labels is expensive.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对一个标签的两个微小改进，你可能不会在性能上注意到太大的差异。如果我们有一个包含大量静态标签的页面，它会在加载速度上产生微小的影响。渲染标签是昂贵的。
- en: 'We can also apply these performance improvements to both button titles. Let''s
    remove the bindings for the `Text` property on both buttons and replace them with
    the static values. Open up the `LabelResources` file and add the static values
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将这些性能改进应用到按钮标题上。让我们移除两个按钮上 `Text` 属性的绑定，并用静态值替换它们。打开 `LabelResources` 文件，并按以下方式添加静态值：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then we apply it to the properties of the buttons:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将它应用到按钮的属性上：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To finish off the landing page, let''s add an image above the buttons:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成着陆页，让我们在按钮上方添加一个图像：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'All image files can be retrieved from the GitHub link: [https://github.com/flusharcade/chapter5-stocklist](https://github.com/flusharcade/chapter5-stocklist).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所有图像文件都可以从 GitHub 链接获取：[https://github.com/flusharcade/chapter5-stocklist](https://github.com/flusharcade/chapter5-stocklist)。
- en: The property `IsOpaque` is flagged to true on this image because the image is
    opaque. Setting this property to `true` allows another small performance enhancement.
    Transparent images are expensive to render.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个图像是不透明的，所以 `IsOpaque` 属性被标记为 true。将此属性设置为 `true` 允许进行另一个小的性能提升。透明图像渲染成本较高。
- en: 'Our last addition to the page is to set the title of the page to another static
    value from our `LabelResources`. Add a new value called `WelcomeTitle`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对页面最后的补充是将页面的标题设置为来自我们的 `LabelResources` 的另一个静态值。添加一个名为 `WelcomeTitle` 的新值：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now let''s add it to the starting flag for `MainPage`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将其添加到 `MainPage` 的启动标志中：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our finished implementation will look as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成的实现将如下所示：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s review the small changes we made to this one `ContentPage`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们对这个 `ContentPage` 做的小改动：
- en: Don't use a `StackLayout` when a Grid will do
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 Grid 可以胜任时，不要使用 `StackLayout`
- en: Don't use multiple StackLayouts, use a Grid
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用多个 StackLayout，使用 Grid
- en: Replace bindings with static values where possible
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，用静态值替换绑定
- en: Set the `IsOpaque` flag to `true` when the image is opaque
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当图像不透明时，将 `IsOpaque` 标志设置为 `true`
- en: Use `FormattedText` and `Span` on labels with static label values
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在具有静态标签值的标签上使用 `FormattedText` 和 `Span`
- en: The more enhancements we can apply, the faster your application will run. We
    will look at more enhancements in later projects.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以应用更多的改进，你的应用程序将运行得更快。我们将在后续的项目中查看更多的改进。
- en: Creating a global App.xaml
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个全局的 App.xaml
- en: In all `Xamarin.Forms` projects we must create an `Application` file that inherits the
    `Application` class. We are going to extend this `Application` file and create
    a global resource dictionary. If you came from WPF you will recognize the use
    of a global resource dictionary that we can reference in all XAML sheets. This
    global resource dictionary is kept in the `App.xaml` file. It will have references
    to different converters, styles, and data templates. Rather than declaring static
    resource dictionaries at the top of every `ContentPage` or `ContentView`, we want
    to create only one dictionary that every XAML interface can access. This means
    we only create one dictionary at startup throughout the entire life of the application,
    rather than creating multiple dictionaries on views when they are displayed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有 `Xamarin.Forms` 项目中，我们必须创建一个继承自 `Application` 类的 `Application` 文件。我们将扩展这个
    `Application` 文件并创建一个全局资源字典。如果你来自 WPF，你会认识到全局资源字典的使用，我们可以在所有的 XAML 表格中引用它。这个全局资源字典保存在
    `App.xaml` 文件中。它将包含对不同的转换器、样式和数据模板的引用。我们不想在每个 `ContentPage` 或 `ContentView` 的顶部声明静态资源字典，我们只想创建一个所有
    XAML 接口都可以访问的字典。这意味着我们只在应用程序启动时创建一个字典，而不是在视图显示时创建多个字典。
- en: 'Let''s create a new `ContentPage`, call it `App.xaml`, and place it in the
    `Stocklist.XamForms` project. We can now remove the `App.cs` file that already
    exists in this project. Inside the `App.xaml` file, implement the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的 `ContentPage`，命名为 `App.xaml`，并将其放置在 `Stocklist.XamForms` 项目中。我们现在可以删除该项目中已经存在的
    `App.cs` 文件。在 `App.xaml` 文件中，实现以下内容：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We declare an `Application` object using XAML, and in the resources section
    of the application we create the global dictionary. We also need to open the `App.xaml.cs`
    file and initialize the component (exactly the same as the initialization of the
    `ContentPage` and `ContentView`), the resource dictionary, and the `MainPage`
    object in the Application:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 XAML 声明一个 `Application` 对象，并在应用程序的资源部分创建全局字典。我们还需要打开 `App.xaml.cs` 文件并初始化组件（与
    `ContentPage` 和 `ContentView` 的初始化完全相同），资源字典，以及 `MainPage` 对象：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Didn't we forget to do something prior to resolving `NavigationPage`?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在解析 `NavigationPage` 之前忘记做某件事了吗？
- en: 'We must add our `XamForms` module to the `IoC` container. First, let''s reuse
    the navigation setup from the `Locator` project. Create a new folder called `UI`
    and copy the following files from the `Xamarin.Forms` project in the `Locator`
    application:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将我们的 `XamForms` 模块添加到 `IoC` 容器中。首先，让我们重用 `Locator` 项目中的导航设置。创建一个名为 `UI`
    的新文件夹，并将以下文件从 `Locator` 应用程序中的 `Xamarin.Forms` 项目复制过来：
- en: '`INavigableXamarinFormsPage.cs`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INavigableXamarinFormsPage.cs`'
- en: '`NavigationService.cs`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavigationService.cs`'
- en: '`XamarinNavigationExtensions.cs`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XamarinNavigationExtensions.cs`'
- en: 'We will need to change the namespace in each file from `Locator.UI` to `Stocklist.XamForms.UI`,
    and make changes to the `PageNames` enum in the `GetPage` function:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将每个文件中的命名空间从 `Locator.UI` 更改为 `Stocklist.XamForms.UI`，并在 `GetPage` 函数中对
    `PageNames` 枚举进行修改：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Great! We now have the navigation service ready, let''s register this with
    the `XamFormsModule`. Create a new folder in the `Stocklist.XamForms` project,
    add a new file for `XamFormsModule`, implementing the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在已经有了导航服务，让我们将其注册到 `XamFormsModule`。在 `Stocklist.XamForms` 项目中创建一个新文件夹，为
    `XamFormsModule` 添加一个新文件，实现以下内容：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that our `XamFormsModule` is registered, we can resolve the `NavigationPage`
    and `NavigationService`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经注册了 `XamFormsModule`，我们可以解析 `NavigationPage` 和 `NavigationService`。
- en: Let's start building the items that will be contained in the global resource
    dictionary.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建将包含在全局资源字典中的项目。
- en: Theming with ControlTemplates
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ControlTemplates 进行主题化
- en: '`ControlTemplates` allow separation of logical view hierarchy from visual hierarchy.
    Similar to a `DataTemplate`, a `ControlTemplate` will produce the visual hierarchy
    for your controller page. One advantage of `ControlTemplates`, is the concept
    of theming. Many software applications provide settings to change user interface
    styles (Visual Studio and Xamarin Studio offer a dark and light theme). We are
    going to implement two themes for the `MainPage` and provide a `Button` to switch
    between the two.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`ControlTemplates` 允许将逻辑视图层次结构与视觉层次结构分离。类似于 `DataTemplate`，`ControlTemplate`
    将为你的控制器页面生成视觉层次结构。`ControlTemplates` 的一个优点是主题的概念。许多软件应用程序提供更改用户界面样式的设置（Visual
    Studio 和 Xamarin Studio 提供暗色和亮色主题）。我们将为 `MainPage` 实现两个主题，并提供一个 `Button` 来在两者之间切换。'
- en: 'Let''s start with opening the `App.xaml` page, and adding the first `ControlTemplate`
    for the black theme:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开`App.xaml`页面并添加黑色主题的第一个`ControlTemplate`开始：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here we simply copy the content of the `MainPage` apply minor color changes
    as the templates are changed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是复制`MainPage`的内容，并根据模板的变化进行微小的颜色更改。
- en: 'Now let''s add another `ControlTemplate` for the white theme:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为白色主题添加另一个`ControlTemplate`：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice the use of the `ContentPresenter` object in each template?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个模板中`ContentPresenter`对象的使用？
- en: 'This is used to position content that will be shared across multiple templates.
    Open up `MainPage.xaml` and replace the content with the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于定位将在多个模板之间共享的内容。打开`MainPage.xaml`，并将内容替换为以下内容：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The content placed on the `MainPage` will be positioned where the `ContentPresenter`
    objects are situated in the `ControlTemplates`. The content is simply a button
    that will be shared across both `ControlTemplates`. We will start by setting the
    default `ControlTemplate` to the black theme.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 放置在`MainPage`上的内容将位于`ControlTemplates`中`ContentPresenter`对象所在的位置。内容只是一个将在两个`ControlTemplates`之间共享的按钮。我们将首先设置默认的`ControlTemplate`为黑色主题。
- en: Notice the two command bindings set up on the `ContentPage`?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`ContentPage`上设置的命令绑定？
- en: 'As our `ControlTemplates` need to bind to the `Commands` in our `MainPageViewModel`,
    we have to add some extra work setting up these bindings. Open up the `MainPage.xaml.cs`
    and implement these custom bindings:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`ControlTemplates`需要绑定到`MainPageViewModel`中的`Commands`，我们必须做一些额外的工作来设置这些绑定。打开`MainPage.xaml.cs`并实现这些自定义绑定：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These custom bindings will set up the link between each `ControlTemplate` and
    the view-model. Now each `Command` inside the `ControlTemplate` will respond to
    the `Command` implemented in the view-model.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些自定义绑定将设置每个`ControlTemplate`和视图模型之间的链接。现在，`ControlTemplate`内的每个`Command`都将对视图模型中实现的`Command`做出响应。
- en: 'Now let''s finish off the **Change Theme** addition. First, let''s add the
    two template definitions:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们完成**更改主题**的添加。首先，让我们添加两个模板定义：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `originalTemplate Boolean` is used as a flag for switching to the opposite
    template with every button click. Next, we must initiate `ControlTemplate` from
    our global resource dictionary:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`originalTemplate Boolean`用作每次按钮点击时切换到相反模板的标志。接下来，我们必须从我们的全局资源字典中初始化`ControlTemplate`：'
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Each time the button is pressed, it will check to see if we are on the default
    template (the black theme) and switch to the white template if we are on the black
    template. We will also switch the background color between black and white to
    match the current theme.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每次按钮被按下时，它将检查我们是否在默认模板（黑色主题）上，如果我们在黑色模板上，则切换到白色模板。我们还将背景颜色在黑色和白色之间切换，以匹配当前主题。
- en: All done. Now let's move over to the `MainPageViewModel` to finish up the page's
    `BindingContext`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了。现在让我们转到`MainPageViewModel`以完成页面的`BindingContext`。
- en: Updating the MainPageViewModel
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新MainPageViewModel
- en: Now that we have rebuilt our `MainPage`, let's make some small changes to the
    `MainPageViewModel`. Since we replaced the label bindings with static values,
    we remove the following variables, `DescriptionMessage`, `ExitTitle`, and `LocationTitle`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经重新构建了我们的`MainPage`，让我们对`MainPageViewModel`做一些小的更改。由于我们用静态值替换了标签绑定，我们移除了以下变量，`DescriptionMessage`、`ExitTitle`和`LocationTitle`。
- en: 'Now we should have the following `private` properties:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该有以下`private`属性：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now simply update `LocationCommand` to the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需更新`LocationCommand`为以下内容：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We must also update our constructor:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须更新我们的构造函数：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here we simply rename some variables to match our application. We must also
    copy over the `Enums` and `Extras` folder, and replace the  `LocationPage` enum
    to `StocklistPage`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是将一些变量重命名以匹配我们的应用程序。我们还必须复制`Enums`和`Extras`文件夹，并将`LocationPage`枚举更改为`StocklistPage`。
- en: 'Next, we need to add the `PortableModule`. Create a new folder called `Modules`
    and copy the `PortableModule` from `Location.Portable`. Change the `PortableModule`
    class to the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加`PortableModule`。创建一个名为`Modules`的新文件夹，并将`Location.Portable`中的`PortableModule`复制到新文件夹中。将`PortableModule`类更改为以下内容：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, we need to add `INavigationService`. Create a new folder called `UI`
    and add `INavigationService` from `Location.Portable` into the new `UI` folder.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要添加`INavigationService`。创建一个名为`UI`的新文件夹，并将`Location.Portable`中的`INavigationService`添加到新的`UI`文件夹中。
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Building project templates can reduce time spent setting up projects and recreating
    similar modules.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 构建项目模板可以减少设置项目和重新创建类似模块所需的时间。
- en: '![Updating the MainPageViewModel](img/B05293_05_07.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![更新 MainPageViewModel](img/B05293_05_07.jpg)'
- en: Before we move any further we must update the namespaces in the code sheets
    copied from the `Locator` project. The easiest way is by using **Search** | **Replace
    in Files...**. We want to replace the text `Location.Portable` with the text.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们必须更新从 `Locator` 项目复制的代码中的命名空间。最简单的方法是使用 **搜索** | **在文件中替换...**。我们想要将文本
    `Location.Portable` 替换为文本。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful doing this; only apply a global replacement when the string is specific.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事时要小心；只有当字符串是特定的时候才应用全局替换。
- en: Creating the Stocklist web service controller
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Stocklist Web 服务控制器
- en: 'Let''s build our client web service controller to access the API. Since we
    built the back end, we should be able to whip this up very quickly. Our first step
    is to create the object which will deserialize a `StockItem`. We refer to these
    as contracts. Add a new folder in your `Stocklist.Portable` project called `StocklistWebServiceController`,
    and add another folder in this called `Contracts`. Create a new file called `StockItemContract.cs`
    and implement the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的客户端 Web 服务控制器以访问 API。由于我们已经构建了后端，我们应该能够非常快速地完成这项工作。我们的第一步是创建一个对象，该对象将反序列化
    `StockItem`。我们把这些称为合约。在你的 `Stocklist.Portable` 项目中添加一个新的文件夹，命名为 `StocklistWebServiceController`，然后在其中添加另一个文件夹，命名为
    `Contracts`。创建一个名为 `StockItemContract.cs` 的新文件，并实现以下内容：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let''s go ahead and build the `IStocklistWebServiceController` interface:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续构建 `IStocklistWebServiceController` 接口：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The functions match the exact functions we have in the API controller. Before
    we implement this interface we have to create a new file called `Config.resx`
    in the `Resources` folder. For now, let''s just add some empty values for each
    URL path because we don''t know these until we either have the site running locally,
    or if we deploy it somewhere:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数与 API 控制器中的函数完全匹配。在我们实现此接口之前，我们必须在 `Resources` 文件夹中创建一个新的文件，命名为 `Config.resx`。目前，让我们为每个
    URL 路径添加一些空值，因为我们不知道这些信息，除非我们在本地运行站点，或者将其部署到某个地方：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now let''s implement the `IStocklistWebServiceController` interface. Starting
    the constructor; we will have to retrieve the `HttpClientHandler` (we will register
    this in the `IoC` container later):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现 `IStocklistWebServiceController` 接口。从构造函数开始；我们不得不检索 `HttpClientHandler`（我们将在稍后的
    `IoC` 容器中注册它）：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now let''s implement the first function to retrieve all the items. It will
    use a `HttpClient` to create an `Observable` from the asynchronous function `SendAsync`
    via an `HttpClient`. The `Observable` stream will be generated from the results
    returned from this function. We will then retrieve the response as a string (this
    will be JSON), and deserialize the string into multiple `StockItemContracts`,
    which then (using Linq) will be passed into the `Observable` stream and returned
    to the result of the function:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现第一个函数来检索所有项目。它将使用 `HttpClient` 通过 `SendAsync` 异步函数创建一个 `Observable`，然后通过
    `HttpClient`。`Observable` 流将从这个函数返回的结果生成。然后我们将响应作为字符串检索（这将是一个 JSON），并将字符串反序列化为多个
    `StockItemContracts`，然后（使用 Linq）将它们传递到 `Observable` 流中，并返回函数的结果：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And now for the `GetStockItem` function:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来实现 `GetStockItem` 函数：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Great! We now have our `StocklistWebServiceController`; we now need to register
    this object to the interface inside the IoC container. Open up the `PortableModule`
    class and add the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在有了 `StocklistWebServiceController`；我们现在需要将此对象注册到 IoC 容器中的接口。打开 `PortableModule`
    类，并添加以下内容：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ListViews and ObservableCollections
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表视图和 ObservableCollections
- en: Now we move on to `StocklistPage` and `StocklistPageViewModel`; these will be
    used to display all the items we pull down from the API. On the frontend we will
    be using<span highlight="">&nbsp;</span>`ListView`, they are the most common UI
    elements for displaying lists of data that are pulled down from any API. The beauty
    of `ListViews` is how they are presented via each platform. Placing a `ListView`
    in our XAML sheet via `Xamarin.Forms` on iOS will render a `UITableView`, on Android
    a native `ListView`, and in Windows a `FrameworkElement`. We can also create custom
    cell items and set up data bindings specific to each item, so with each contract
    that is deserialized, we want to have a separate view-model that will be used
    for representing the data on each cell.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向`StocklistPage`和`StocklistPageViewModel`；这些将用于显示我们从API拉取的所有项目。在前端，我们将使用`ListView`，它们是显示从任何API拉取的数据列表的最常见UI元素。`ListView`的美丽之处在于它们如何通过每个平台呈现。通过`Xamarin.Forms`在iOS上的XAML表单中放置一个`ListView`将渲染一个`UITableView`，在Android上是一个原生的`ListView`，而在Windows上是一个`FrameworkElement`。我们还可以创建自定义单元格项并设置针对每个项目的特定数据绑定，因此，对于每个反序列化的合同，我们希望有一个单独的视图模型来表示每个单元格上的数据。
- en: 'Let''s add a new file to the `ViewModels` folder in the `Stocklist.Portable`
    project called `StockItemViewModel.cs` and implement the constructor:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Stocklist.Portable`项目的`ViewModels`文件夹中添加一个名为`StockItemViewModel.cs`的新文件，并实现其构造函数：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we want to add the `private` properties; they will be the same properties
    as in `StockItemContract`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要添加`private`属性；它们将与`StockItemContract`中的属性相同：
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can choose to only represent certain items in a custom view cell. Inside
    the view-model we only create properties that will be displayed on the view.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择只在一个自定义视图单元格中表示某些项目。在视图模型内部，我们只创建将在视图中显示的属性。
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then we simply create the `public` properties for each `private` variable,
    following is one to get you started:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们只需为每个`private`变量创建相应的`public`属性，以下是一个帮助你开始的例子：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here we are building a translation layer between the objects we deserialize and
    the objects we want to display. This is good for separating the logic contained
    in the view-models, as they have extra logic for processing the data to be displayed.
    We want our contracts to purely reflect the properties in the JSON object.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在构建一个翻译层，在反序列化的对象和我们要显示的对象之间。这对于分离视图模型中包含的逻辑是有好处的，因为它们有额外的逻辑来处理要显示的数据。我们希望我们的合同纯粹反映JSON对象中的属性。
- en: 'Next, we add a public method on the view-model called `Apply`. This will take
    a `StockItemContract` as a parameter and update the properties of the view-model.
    It will be called when we want to update the data to be displayed:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在视图模型上添加一个名为`Apply`的公共方法。这个方法将接受一个`StockItemContract`作为参数并更新视图模型的属性。它将在我们想要更新要显示的数据时被调用：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Our next step is to implement the StocklistPageViewModel. This view-model will
    contain an `ObservableCollection`, which will be used to bind to the `ListView`.
    After we retrieve a list of contracts, we build another list of `StockItemViewModels`.
    Each item will apply the data from the contract and the new `StockItemViewModel`
    will be added to the `ObservableCollection`. We will apply the contract to update
    the data and then add the view-model to `ObservableCollection`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是实现`StocklistPageViewModel`。这个视图模型将包含一个`ObservableCollection`，它将被用于绑定到`ListView`。在我们检索到合同列表后，我们将构建另一个`StockItemViewModels`列表。每个项目将应用合同中的数据，新的`StockItemViewModel`将被添加到`ObservableCollection`中。我们将应用合同来更新数据，然后将视图模型添加到`ObservableCollection`。
- en: 'Let''s begin by adding a new file to the `ViewModels` folder called `StocklistPageViewModel.cs`,
    and start by creating a new view-model with its constructor:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向`ViewModels`文件夹添加一个名为`StocklistPageViewModel.cs`的新文件开始，并首先创建一个新的视图模型及其构造函数：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The navigation service is the same as the one used in the `Locator` project.
    We will register this later on in `Stocklist.XamForms` project. We use the `IStocklistWebServiceController`
    to fetch the `StockItems` from the API.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 导航服务与`Locator`项目中使用的相同。我们将在`Stocklist.XamForms`项目中稍后注册它。我们使用`IStocklistWebServiceController`从API获取`StockItems`。
- en: 'We then need to register our `StockItemViewModel` inside `PortableModule`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在`PortableModule`内部注册我们的`StockItemViewModel`：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice how we are using the `InstancePerDependency` function instead of `SingleInstance`?
    Since we are instantiating multiple items, if we used `SingleInstance`, the same
    data would be copied and changed across all `StockItemViewModels`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何使用 `InstancePerDependency` 函数而不是 `SingleInstance` 的？由于我们正在实例化多个项，如果我们使用
    `SingleInstance`，相同的数据将在所有 `StockItemViewModels` 之间复制并更改。
- en: 'Now let''s add the `private` and `public` properties:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加 `private` 和 `public` 属性：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we have all the properties, we can build the list of items for the `ObservableCollection`.
    Next, we add the `LoadAsync` function, it is responsible for creating the list
    of `StockItemViewModels`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有属性，我们可以构建 `ObservableCollection` 的项目列表。接下来，我们添加 `LoadAsync` 函数，它负责创建
    `StockItemViewModels` 的列表：
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `LoadAsync` function will be used to retrieve all contracts and build a
    list of `StockItemViewModels`. Every time we add a new `StockItemViewModel` to `ObservableCollection`,
    a `CollectionChanged` event will be fired to notify the `ListView` to update.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadAsync` 函数将用于检索所有合同并构建 `StockItemViewModels` 的列表。每次我们将新的 `StockItemViewModel`
    添加到 `ObservableCollection` 时，都会触发一个 `CollectionChanged` 事件来通知 `ListView` 更新。'
- en: Have a look at how we are instantiating `StockItemViewModel` through `stockItemfactory`.
    It uses `Func` (`Func<StockItemViewModel>`) to generate a new view model every
    time we execute `Func`. This is why we need to call `InstancePerDependency`, so
    separate items are created. If we left the ending function on the registration
    as `SingleInstance`, even though we are calling `Func` on `StockItemViewModel`,
    it will only ever create one object.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们是如何通过 `stockItemfactory` 实例化 `StockItemViewModel` 的。它使用 `Func` (`Func<StockItemViewModel>`)
    在每次执行 `Func` 时生成一个新的视图模型。这就是为什么我们需要调用 `InstancePerDependency`，以便创建独立的项。如果我们将注册上的结束函数设置为
    `SingleInstance`，即使我们在 `StockItemViewModel` 上调用 `Func`，也只会创建一个对象。
- en: 'Now let''s build the user interface for the `StocklistPage`. It will contain
    the `ListView` for displaying the `StockItems` from the API:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们构建 `StocklistPage` 的用户界面。它将包含用于显示从 API 获取的 `StockItems` 的 `ListView`：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Why can't we use StackLayout?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不能使用 StackLayout？
- en: Since we need one element overlaying another, we have to use Grid. The `ActivityIndicator`
    is used to show the loading progress of our `LoadAync` function. When this is
    loading, our `ListView` will be invisible and the loading indicator is displayed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要一个元素覆盖另一个元素，我们必须使用 Grid。`ActivityIndicator` 用于显示 `LoadAsync` 函数的加载进度。当正在加载时，我们的
    `ListView` 将不可见，并显示加载指示器。
- en: Value converters
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值转换器
- en: In some cases, there are times when we need to data bind two properties of incompatible
    types. A `Converter` is an object that converts the value from source to target
    and vice versa. Each converter must implement the `IValueConverter` interface,
    which implements two functions, `Convert` and `ConvetBack`. We are going to create
    a converter that will take a `bool` as the source, and simply return the opposite
    value to the value in the source.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，有时我们需要将不兼容类型的两个属性进行数据绑定。`Converter` 是一个对象，它将值从源转换为目标，反之亦然。每个转换器都必须实现
    `IValueConverter` 接口，该接口实现了两个函数，`Convert` 和 `ConvertBack`。我们将创建一个转换器，它将 `bool`
    作为源，并简单地返回与源值相反的值。
- en: The `ConvertBack` method will only be used if the data binding is a `TwoWay`
    binding.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConvertBack` 方法仅在数据绑定是 `TwoWay` 绑定时才会使用。'
- en: 'In the `Stocklist.XamForms` project, add a new folder called `Converters`,
    and inside this folder create a new file called `NotConverter.cs`, implement the
    following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Stocklist.XamForms` 项目中，添加一个名为 `Converters` 的新文件夹，并在该文件夹内创建一个名为 `NotConverter.cs`
    的新文件，实现以下内容：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Even though the `InProgress` property doesn't use a two way binding, we still
    have to implement the `ConvertBack` function as part of the interface.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `InProgress` 属性不使用双向绑定，我们仍然必须实现 `ConvertBack` 函数作为接口的一部分。
- en: Now back to the `StocklistPage.xaml`. When the `bool` property in the view-model
    changes, the `Convert` function of the `NotConverter` will be called. When the
    `IsProgress` value changes, the converter will be called and will return the opposite
    value for the `IsVisible` state on the `ListView`. When the progress is running,
    the `ListView` is invisible, and when the progress is not running, the `ListView`
    is visible.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到 `StocklistPage.xaml`。当视图模型中的 `bool` 属性发生变化时，`NotConverter` 的 `Convert`
    函数将被调用。当 `IsProgress` 值发生变化时，转换器将被调用，并将返回 `ListView` 上 `IsVisible` 状态的反向值。当进度正在运行时，`ListView`
    不可见，当进度未运行时，`ListView` 可见。
- en: Now we are going to look at creating an `App.xaml` which will contain the DataTemplate
    used for each cell.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨创建一个包含每个单元格使用的`DataTemplate`的`App.xaml`。
- en: Adding a DataTemplate to the global resource dictionary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将`DataTemplate`添加到全局资源字典
- en: Now let's get back to the `App.xaml` file. Since we require a custom cell in
    our `ListView` on the `StocklistPage`, we are going to create a `DataTemplate`
    in the global resource dictionary. `DataTemplate` can be created in two ways,
    as an inline template or in a resource dictionary. There is no better method,
    it's more on personal preference. In our example, we are going to be creating
    ours in a resource dictionary.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到`App.xaml`文件。由于我们在`StocklistPage`的`ListView`中需要一个自定义单元格，我们将在全局资源字典中创建一个`DataTemplate`。`DataTemplate`可以以两种方式创建，作为内联模板或在资源字典中。没有更好的方法，这更多是个人偏好的问题。在我们的例子中，我们将创建资源字典中的我们的`DataTemplate`。
- en: 'Open up the `App.xaml` file and insert the `DataTemplate` in the resource dictionary
    like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`App.xaml`文件，并按如下方式在资源字典中插入`DataTemplate`：
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we want to set the `ItemTemplate` property on our `ListView` in the `StocklistPage`.
    Open up the `StocklistPage` and add the following to the `ListView` declaration:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想在`StocklistPage`中的`ListView`上设置`ItemTemplate`属性。打开`StocklistPage`，并将以下内容添加到`ListView`声明中：
- en: '[PRE46]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If we wanted to use the inline template approach, we would do this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用内联模板方法，我们会这样做：
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Styles
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式
- en: In our custom cell we have three labels without any styling or font assignation.
    We are going to spice up the look of each cell using `Style`. A `Style` groups
    a collection of property values into one object that can be applied to multiple
    visual element instances. The idea of this is to reduce repetitive markup so we
    can reuse similar styles across similar controls in our XAML. There are multiple
    ways to apply styling to a control in `Xamarin.Forms`. In this example, we will
    show you how to create a global style in the `App.xaml` file, and apply it to
    different controls in our application.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的自定义单元格中，我们有三个标签，没有任何样式或字体分配。我们将使用`Style`来增强每个单元格的外观。`Style`将一组属性值组合成一个对象，可以应用于多个视觉元素实例。这种做法的目的是减少重复的标记，以便我们可以在XAML中跨相似控件重用类似的样式。在`Xamarin.Forms`中，有多种方法可以将样式应用于控件。在这个例子中，我们将向您展示如何在`App.xaml`文件中创建全局样式，并将其应用于我们应用程序中的不同控件。
- en: 'Our first global style will be for the title label in our custom cell. Let''s
    open up the `App.xaml` file and insert the following into our resource dictionary:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个全局样式将是自定义单元格中的标题标签。让我们打开`App.xaml`文件，并将以下内容插入到我们的资源字典中：
- en: '[PRE48]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In preceding markup, each style will contain a list of `Setter` properties.
    These refer to the `BindableProperties` on our control. Now that we have our `Style`,
    we can refer to this static resource inside our `DataTemplate`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的标记中，每个样式将包含一个`Setter`属性的列表。这些指的是我们控件上的`BindableProperties`。现在我们有了`Style`，我们可以在`DataTemplate`内部引用这个静态资源：
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Great! We have just created and set our first style on a `Label`. Let''s add
    some more styles to `MainPageControlTemplates`. We are going to style the buttons
    as they both share the same styled properties. Add the following to the global
    resource dictionary:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们刚刚在`Label`上创建并设置了我们的第一个样式。让我们向`MainPageControlTemplates`添加更多样式。我们将对按钮进行样式化，因为它们都共享相同的样式属性。将以下内容添加到全局资源字典中：
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Looking closer at the preceding style, we can even use the `<OnPlatform>` tags
    to change setter values based on the platform.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看前面的样式，我们甚至可以使用`<OnPlatform>`标签根据平台更改设置值。
- en: 'Now let''s apply this `Style` to our `MainPage` buttons:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个`Style`应用到我们的`MainPage`按钮上：
- en: '[PRE51]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: See how we are reducing the size of the markup?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们是如何减少标记大小的？
- en: This is one example of how we can apply `Styles`, we will see more techniques
    in further chapters.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们应用`Styles`的一个例子，我们将在后续章节中看到更多技术。
- en: Further optimization with XAML
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用XAML进行进一步优化
- en: Previously, we talked about some minor changes we can apply to our XAML to improve
    on the performance. Let's look at how we can apply some performance enhancements
    on a `ListView`. If you have worked with any native `ListView` or `UITableView`,
    one of the biggest problems is the memory usage when we have a lot of elements
    to load whilst we are scrolling (that is, loading an image into each bitmap for
    every cell).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了一些我们可以应用于XAML的微小更改，以改进性能。让我们看看我们如何在`ListView`上应用一些性能提升。如果您使用过任何本地的`ListView`或`UITableView`，最大的问题之一就是我们滚动时加载大量元素时的内存使用（即，为每个单元格加载一个位图）。
- en: How do we solve this issue?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？
- en: 'We use techniques for caching cells and reusing cells. Since `Xamarin.Forms`
    2.0, they have introduced some new features and enhancements around cell recycling
    mechanisms and caching strategies on `ListViews`. In order to set a caching strategy,
    we have two options:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用缓存单元格和重用单元格的技术。自从 `Xamarin.Forms` 2.0 以来，他们引入了一些关于 `ListViews` 上的单元格回收机制和缓存策略的新功能和增强。为了设置缓存策略，我们有两种选择：
- en: '`RetainElement`: This is the default behavior. It will generate a cell for
    each item in the list, cell layout will run for each cell creation. We should
    only be using this method if the cell layout is frequently changing, or if a cell
    has a large number of bindings.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RetainElement`: 这是默认行为。它将为列表中的每个项目生成一个单元格，单元格布局将在每个单元格创建时运行。我们只有在单元格布局经常变化，或者一个单元格有大量绑定时才应使用此方法。'
- en: '`RecycleElement`: This takes advantage of native cell recycling mechanisms
    on iOS and Android. It will minimize the memory footprint and maximize the performance
    of a `ListView`. We should use this method if cells have a small to moderate amount
    of bindings, are similar in layout, and the cell view-model contains all the data.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecycleElement`: 这利用了 iOS 和 Android 上的原生单元格回收机制。它将最小化内存占用并最大化 `ListView` 的性能。如果单元格有少量到中等的绑定，布局相似，并且单元格视图模型包含所有数据，我们应该使用此方法。'
- en: Tip
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We should always be aiming to use the second element, try to design your cells
    around this setting.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终致力于使用第二个元素，尽量设计你的单元格围绕这个设置。
- en: 'We are going to use the second caching strategy on our `ListView`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的 `ListView` 上使用第二种缓存策略：
- en: '[PRE52]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`RecycleElement` should be used as much as possible as we always want to tailor
    our apps to maximize performance wherever we can. Since we have a fairly simple
    cell design with a small amount of bindings and we keep all the data inside our
    view-model, we are able to use this setting.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 应尽可能多地使用 `RecycleElement`，因为我们总是希望根据我们的应用程序来最大化性能。由于我们的单元格设计相当简单，绑定数量少，并且我们保持所有数据在视图模型中，我们能够使用此设置。
- en: 'Now let''s have a look at another simple addition we can use to improve the
    loading speed of our XAML sheets. Turning on XAML compilation allows your XAML
    sheets to be compiled rather than interpreted, which can provide multiple benefits:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个我们可以用来提高我们的 XAML 表格加载速度的简单添加。开启 XAML 编译功能可以让你的 XAML 表格被编译而不是被解释，这可以提供多种好处：
- en: Helps markup errors
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助标记错误
- en: Reduces application size
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减小应用程序大小
- en: Removes load and instantiation time
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少加载和实例化时间
- en: 'It is highly recommended to have this setting on with all your `Xamarin.Forms`
    applications as it will increase the loading speed of your user interfaces (in
    particular with Android). We can add the compiled XAML by opening up the `App.xaml.cs`
    file and pasting the code below the preceding namespace:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 非常推荐在所有 `Xamarin.Forms` 应用程序中启用此设置，因为它将提高你用户界面的加载速度（特别是在 Android 上）。我们可以通过打开
    `App.xaml.cs` 文件并将以下代码粘贴在先前的命名空间下面来添加编译后的 XAML：
- en: '[PRE53]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If we add up all the performance additions we have applied to the project, we should
    see some improvement in the user interfaces as they present between different screens.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将我们对项目应用的所有性能改进加起来，我们应该会在用户界面在不同屏幕之间呈现时看到一些改进。
- en: Creating StockItemDetailsPage
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 StockItemDetailsPage
- en: 'Now we move on to our last page of the application. We are going to add another
    page for displaying the details of a selected stock item from the previous `StocklistPage`.
    Firstly, we need to handle items selected from `ListView`, so open up `StocklistPage.xaml`
    and update the `ListView` element with the `SelectedItem` object bound to the
    `Selected` item in our view-model (we will add this after the XAML update). This
    will be set as a `TwoWay` binding because the data will change from both sides
    (from the view as we selected items, and the view-model as we will need the selected
    object data when we navigate to the stock details page):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们继续到我们应用程序的最后一页。我们将为显示从上一个 `StocklistPage` 中选择的股票项目的详细信息添加另一个页面。首先，我们需要处理从
    `ListView` 中选择的项，所以打开 `StocklistPage.xaml` 并更新 `ListView` 元素，将其 `SelectedItem`
    对象绑定到我们的视图模型中的 `Selected` 项（我们将在 XAML 更新后添加此绑定）。这将设置为 `TwoWay` 绑定，因为数据将从两边改变（从视图，因为我们选择了项，以及视图模型，因为我们将在导航到股票详情页时需要选择对象的数据）：
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now let''s add to the `StocklistPageViewModel`; we need to add a `public``StockItemViewModel`
    property that will hold the data of our binding when an item is selected from
    the list. The ID property of the selected `StockItemViewModel` will be passed
    through the navigation parameters for our `StockItemDetailsPage`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加到`StocklistPageViewModel`；我们需要添加一个`public`的`StockItemViewModel`属性，它将保存从列表中选择项目时的绑定数据。所选`StockItemViewModel`的ID属性将通过导航参数传递给我们的`StockItemDetailsPage`：
- en: '[PRE55]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now let''s add the new `StocklistItemDetailsPage`. Create a new XAML `ContentPage`
    and add the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加新的`StocklistItemDetailsPage`。创建一个新的XAML `ContentPage`并添加以下内容：
- en: '[PRE56]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Looking more closely at the code, we have added four labels and `ActivityIndicator`,
    which are used to show the progress of our page loading the data. We have also
    included a custom control `CustomLabel`, we reference this item via the namespace
    as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看代码，我们添加了四个标签和`ActivityIndicator`，它们用于显示页面加载数据的进度。我们还包含了一个自定义控件`CustomLabel`，我们通过以下方式引用此项目：
- en: 'Whatever name follows the `xmlns` keyword, this name must be called first to
    reference the item within the namespace we are trying to use, like this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 无论跟随`xmlns`关键字之后的名称是什么，这个名称必须首先被调用，以便在我们要使用的命名空间内引用项目，如下所示：
- en: '[PRE57]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now we must create our `CustomLabel` object, which will be used for a `CustomRenderer`
    for Android, as we are going to set the font of this label to a custom `Typeface`,
    which we will include in both native projects. Create a new folder called `Controls`
    in the `Stocklist.XamForms` project, and create the following file, called `CustomLabel.cs`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须创建我们的`CustomLabel`对象，它将被用于Android的`CustomRenderer`，因为我们将设置此标签的字体为自定义的`Typeface`，我们将将其包含在两个原生项目中。在`Stocklist.XamForms`项目中创建一个名为`Controls`的新文件夹，并创建以下文件，名为`CustomLabel.cs`：
- en: '[PRE58]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In our `CustomLabel`, we are adding a custom binding, which will be used specifically
    to set the font style for Android. When we set the font style on the native side,
    we have to set the custom font by the filename not the font name, whereas in iOS
    we reference the custom font by the font name and not the filename.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`CustomLabel`中，我们添加了一个自定义绑定，这个绑定将专门用于为Android设置字体样式。当我们设置原生侧的字体样式时，我们必须通过文件名而不是字体名来设置自定义字体，而在iOS中，我们通过字体名而不是文件名来引用自定义字体。
- en: 'When we set up custom bindings, we must always include a `static` property,
    this is our `BindableProperty`, which is used to reference the item of the UI
    element that we are binding on. Then we must always include the actual property
    which is referenced in the XAML:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置自定义绑定时，我们必须始终包含一个`static`属性，这是我们所说的`BindableProperty`，它用于引用我们正在绑定的UI元素的项。然后我们必须始终包含在XAML中引用的实际属性：
- en: '[PRE59]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Custom renderers
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义渲染器
- en: 'You will find `Xamarin.Forms` covers most of the native controls via cross-platform
    elements such as XAML objects, but there are some UI elements which we must implement
    ourselves using `CustomRenderers`. `CustomRenderers` allows anyone to override
    the rendering process for specific controls placed in our XAML, and render native
    elements on the platform side. We must place a renderer specific to each platform,
    but for this example, we are only going to apply a custom renderer for the Android
    project as we want our custom labels to use custom fonts. iOS doesn''t need a
    renderer to allow custom fonts; all we have to do is add the reference to our
    font file in the `info.plist` file. Open up the `info.plist` file in your iOS
    project and add a new entry called `Fonts provided by application` (for an array
    element we simply add the path of our font file `GraCoRg_.ttf`). Then add the
    font file into the `Resources` folder of the iOS project, make sure the build
    action of the font file is set to `BundleResource` (do this by right-clicking
    on the file):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现`Xamarin.Forms`通过跨平台元素（如XAML对象）覆盖了大多数原生控件，但有一些UI元素我们必须自己使用`CustomRenderers`来实现。`CustomRenderers`允许任何人覆盖我们XAML中特定控件的重绘过程，并在平台侧渲染原生元素。我们必须放置针对每个平台的特定渲染器，但在这个例子中，我们只将为Android项目应用自定义渲染器，因为我们希望我们的自定义标签使用自定义字体。iOS不需要渲染器来允许自定义字体；我们只需在`info.plist`文件中添加对字体文件的引用即可。在你的iOS项目中打开`info.plist`文件，并添加一个名为`Fonts
    provided by application`（对于数组元素，我们只需添加我们的字体文件路径`GraCoRg_.ttf`）的新条目。然后将字体文件添加到iOS项目的`Resources`文件夹中，确保字体文件的构建操作设置为`BundleResource`（通过右键单击文件来完成此操作）：
- en: '![Custom renderers](img/B05293_05_08.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![自定义渲染器](img/B05293_05_08.jpg)'
- en: We also want to add this font file into the `Assets` folder of the Android project,
    and make sure we set the build action to `AndroidAsset`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望将此字体文件添加到Android项目的`Assets`文件夹中，并确保将构建操作设置为`AndroidAsset`。
- en: 'You can grab this font file from the GitHub link: [https://github.com/flusharcade/chapter5-stocklist](https://github.com/flusharcade/chapter5-stocklist).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从GitHub链接获取此字体文件：[https://github.com/flusharcade/chapter5-stocklist](https://github.com/flusharcade/chapter5-stocklist)。
- en: 'To implement the equivalent for Android, we must create a `CustomRenderer`
    for the `CustomLabel` item in our `Controls` folder. Open the Android project,
    create a new folder called `Renderers`, and add a new file called `CustomLabelRenderer`,
    and implement the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Android上实现等效功能，我们必须在`Controls`文件夹中为`CustomLabel`项目创建一个`CustomRenderer`。打开Android项目，创建一个名为`Renderers`的新文件夹，并添加一个名为`CustomLabelRenderer`的新文件，然后实现以下内容：
- en: '[PRE60]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In just about all the renderers, we are exposed to the `OnElementChanged` function
    which is called when a `Xamarin.Forms` custom control is created in order to render
    the corresponding native control. In some circumstances, the `OnElementChanged`
    method can be called multiple times, so care must be taken when instantiating
    a new native control in order to prevent memory leaks, which can have a large
    performance impact. In our case, we are not rendering a new control, so we only
    need to check that the `NewElement` and `Control` objects are not null when the
    function is called. We must also cast the `NewElement` item to our custom item,
    as this is the object which contains the custom binding for the `AndroidFontStyle`
    property. The `NewElement` will always be the custom item, so we can always cast
    it.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有渲染器中，我们都会暴露`OnElementChanged`函数，当在`Xamarin.Forms`中创建自定义控件以渲染相应的本地控件时会被调用。在某些情况下，`OnElementChanged`方法可能会被多次调用，因此在实例化新的本地控件时必须小心，以防止内存泄漏，这可能会对性能产生重大影响。在我们的案例中，我们并没有渲染新的控件，所以我们只需要检查当函数被调用时`NewElement`和`Control`对象不是null。我们还必须将`NewElement`项转换为我们的自定义项，因为这个对象包含了`AndroidFontStyle`属性的定制绑定。`NewElement`始终是自定义项，所以我们总是可以将其转换。
- en: We can also now access the native UI frameworks; in this case, we are using
    the Android `Typeface` framework to create a custom `Typeface` which will use
    our font file. Then this `Typeface` is set to the `Typeface` property of the `Control`
    element (this is the actual element which will be displayed), in this case, because
    it is a `LabelRenderer`, the `Control` element is an Android `TextView`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在也可以访问本地的UI框架；在这种情况下，我们使用Android的`Typeface`框架创建一个自定义的`Typeface`，它将使用我们的字体文件。然后这个`Typeface`被设置为`Control`元素的`Typeface`属性（这是实际将被显示的元素），在这种情况下，因为它是一个`LabelRenderer`，`Control`元素是一个Android的`TextView`。
- en: Note
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In other renderers, we can set this control element to specific native elements,
    which we will be doing in further chapters.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他渲染器中，我们可以将此控件元素设置为特定的本地元素，我们将在后续章节中这样做。
- en: 'Finally, we have to add the following line to export and register the renderer:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须添加以下行以导出和注册渲染器：
- en: '[PRE61]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Adding styles for custom elements
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为自定义元素添加样式
- en: 'We still have one more addition to finalise the `StockItemDetailsPage`. We
    are going to add a style for the `CustomLabel`. Open up the `App.xaml` file and
    add the following style:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加一个额外的元素来最终确定`StockItemDetailsPage`。我们将为`CustomLabel`添加一个样式。打开`App.xaml`文件并添加以下样式：
- en: '[PRE62]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We have included a `Setter` for the `AndroidFontStyle` property we created
    earlier. Don''t forget we must also add the namespace reference for the `Controls`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为之前创建的`AndroidFontStyle`属性添加了一个`Setter`。别忘了我们还需要添加`Controls`的命名空间引用：
- en: That's everything for the user interface. Now let's move on to implementing
    the view-model for the `StockItemDetailsPage`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面部分就到这里。现在让我们继续实现`StockItemDetailsPage`的视图模型。
- en: Creating StockItemDetailsPageViewModel
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建StockItemDetailsPageViewModel
- en: Now we move on to the last view-model in our application. Add a new file called
    `StockItemDetailsPageViewModel` to our ViewModels folder in the `Stocklist.Portable`
    project.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续到我们应用程序中的最后一个视图模型。在`Stocklist.Portable`项目的`ViewModels`文件夹中添加一个名为`StockItemDetailsPageViewModel`的新文件。
- en: 'Let''s start by implementing the `private` properties:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从实现`private`属性开始：
- en: '[PRE63]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You should be able to add the `public` properties yourself. Here is the first
    to get you started:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够自己添加`public`属性。以下是一个开始示例：
- en: '[PRE64]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now we need to add the `LoadAsync` function, which will use `StocklistWebServiceController`
    to pull the data from our API for a specific `StockItem`. Notice the use of the
    `InProgress` property, this is used to track the loading progress; as we are downloading
    in the background we want to display this progress to the user interface via an
    `ActivityIndicator`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要添加`LoadAsync`函数，它将使用`StocklistWebServiceController`从我们的API中获取特定`StockItem`的数据。注意`InProgress`属性的使用，这用于跟踪加载进度；因为我们是在后台下载，我们想要通过`ActivityIndicator`将此进度显示给用户界面：
- en: '[PRE65]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then we add our constructor which will pull out the registered IoC objects
    and assign our `private` properties accordingly:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加我们的构造函数，它将提取已注册的IoC对象并相应地分配我们的`private`属性：
- en: '[PRE66]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, we need to register the view-model in the `CommonModule`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在`CommonModule`中注册视图模型：
- en: '[PRE67]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Add the extra enum for the `StockItemDetailsPage` to `PageEnums.cs`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 将额外的枚举`StockItemDetailsPage`添加到`PageEnums.cs`中：
- en: '[PRE68]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'And add the extra switch case to `NavigationService`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 并在`NavigationService`中添加额外的switch case：
- en: '[PRE69]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Setting up the native platform projects
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置原生平台项目
- en: 'Now we move on to the native platform layer and prepare the iOS, Android, and
    Windows Phone projects. We are going to start with iOS; let''s start by adding
    the NuGet packages required for the project:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向原生平台层，并准备iOS、Android和Windows Phone项目。我们将从iOS开始；让我们先添加项目所需的NuGet包：
- en: Microsoft HTTP client libraries
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软HTTP客户端库
- en: Modern HTTP client
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代HTTP客户端
- en: Autofac
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Autofac
- en: Reactive extensions (main library)
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式扩展（主要库）
- en: 'Once we''ve added these packages to the project, let''s open the `AppDelegate`
    file and add the same `InitIoC` function we used in the `Locator` project:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将这些包添加到项目中，让我们打开`AppDelegate`文件并添加我们在`Locator`项目中使用的相同的`InitIoC`函数：
- en: '[PRE70]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then call this method before we load the application:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在加载应用程序之前调用此方法：
- en: '[PRE71]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Before running the iOS application, let''s also set up the Android project.
    We want to start by adding the same libraries as iOS, then opening `MainActivity.cs`,
    and adding the same function `InitIoC` as shown in the preceding example. Then,
    finally, we call the `InitIoC` function before we load the application:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行iOS应用程序之前，让我们也设置Android项目。我们想要从添加与iOS相同的库开始，然后打开`MainActivity.cs`，并添加与前面示例中相同的函数`InitIoC`。然后，最后，在我们加载应用程序之前调用`InitIoC`函数：
- en: '[PRE72]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Simple, right? See how much code we are simply copying from another project?
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 简单，对吧？看看我们有多少代码是从另一个项目中复制的？
- en: The more problems we solve in other projects, the quicker we can piece together
    apps that have similar functionality.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在其他项目中解决的问题越多，我们就能越快地拼凑出具有相似功能的应用程序。
- en: Hosting the Web API project locally
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地托管Web API项目
- en: Before we can access the API layer from our mobile application, we have to set
    up hosting. For this example, we are going to walkthrough setup for hosting locally.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够从我们的移动应用程序访问API层之前，我们必须设置托管。对于这个例子，我们将演示本地托管的设置。
- en: Hosting locally does not require much work, but it will require an instance
    of Windows and Mac OSX running together. You can achieve this by simply running
    parallels, or using a **Windows** and **Mac** computer.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地托管不需要做太多工作，但它将需要一个同时运行Windows和Mac OSX的实例。你可以通过简单地运行 parallels，或者使用一台**Windows**和**Mac**电脑来实现这一点。
- en: 'Our first step is to open Visual Studio from our Windows instance and click
    the run button:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是从我们的Windows实例打开Visual Studio并点击运行按钮：
- en: '![Hosting the Web API project locally](img/B05293_05_09.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![本地托管Web API项目](img/B05293_05_09.jpg)'
- en: When the project starts, it will automatically open up your default web browser
    and show the application.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目启动时，它将自动打开你的默认网络浏览器并显示应用程序。
- en: Tip
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Since we don't have any visible web pages, we don't need to have the browser
    open. If the project is running, the web API will be running so we will be able
    to ping it over an HTTP request.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有任何可见的网页，我们不需要打开浏览器。如果项目正在运行，Web API也将运行，因此我们可以通过HTTP请求ping它。
- en: Now that we have the backend running, how do we access the API?
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了后端，我们如何访问API？
- en: If you are running via two separate computers, we should be able to simply access
    the API through the IP address of the computer. In order to find out the IP address
    of the computer, open up a new command prompt window and type in `ipconfig`. This
    will display the IPv4 address that the computer has been assigned to on the current
    network.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过两个独立的计算机运行，我们应该能够简单地通过计算机的IP地址访问API。为了找出计算机的IP地址，打开一个新的命令提示符窗口并输入`ipconfig`。这将显示计算机在当前网络中分配的IPv4地址。
- en: '![Hosting the Web API project locally](img/B05293_05_10.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![本地托管 Web API 项目](img/B05293_05_10.jpg)'
- en: Note
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order for the local set up to work, please make sure both the mobile device
    and the computer hosting the WEB API are both on the same **WIFI/LAN** connection.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本地设置能够工作，请确保移动设备和托管 WEB API 的计算机都在相同的 **WIFI/LAN** 连接上。
- en: 'To confirm we have this working, paste the following URL into a web browser
    on the Windows instance and see if we get results:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认我们已成功设置，请将以下 URL 粘贴到 Windows 实例上的网页浏览器中，并查看是否得到结果：
- en: '[PRE73]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The port is automatically assigned when the project is run, so when the browser
    appears with the localhost URL, paste the URL extension `api/StockItems`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目运行时，端口会自动分配，所以当浏览器出现带有 localhost URL 时，粘贴 URL 扩展名 `api/StockItems`。
- en: Now we want to test this link on the Mac instance, but before we do, we have
    to change some settings in the `applicationhost.config` file located in `"C:\Users[YourName]\Documents\IISExpress\config\applicationhost.config"`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想在 Mac 实例上测试这个链接，但在做之前，我们必须更改位于 `"C:\Users[YourName]\Documents\IISExpress\config\applicationhost.config"`
    的 `applicationhost.config` 文件中的某些设置。
- en: If you are using Visual Studio 2015, it will be located in `/{project folder}/.vs/config/applicationhost.config`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Visual Studio 2015，它将位于 `/{项目文件夹}/.vs/config/applicationhost.config`。
- en: 'If you haven''t got **Internet Information Services** (**IIS**) switched on,
    follow these steps, to install IIS to serve static content:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有开启 **Internet Information Services** (**IIS**)，请按照以下步骤安装 IIS 以提供静态内容：
- en: Click the Start button, click **Control Panel**, click **Programs**, and then
    click **Turn Windows features** on or off.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击开始按钮，点击 **控制面板**，点击 **程序**，然后点击 **启用或关闭 Windows 功能**。
- en: In the list of **Windows features**, select **Internet Information Services**,
    and then click **OK**.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Windows 功能** 列表中，选择 **Internet Information Services**，然后点击 **确定**。
- en: 'Look through the file until you can file your application entry like this:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看文件，直到你可以像这样添加你的应用程序条目：
- en: Note
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The best way to find your particular entry is by searching for the `port` number.
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 找到你的特定条目的最佳方式是通过搜索 `端口` 号码。
- en: '[PRE74]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the `<bindings>` section, we want to add another row:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<bindings>` 部分中，我们想添加另一行：
- en: '[PRE75]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Now we want to allow incoming connections on this `PORT` and `IPv4 Address`
    from other computers.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们想允许来自其他计算机的此 `PORT` 和 `IPv4 地址` 的入站连接。
- en: Note
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're running Windows 7, most incoming connections are locked down, so you
    need to specifically allow incoming connections to your application.
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你正在运行 Windows 7，大多数入站连接都是锁定状态，因此你需要特别允许应用程序的入站连接。
- en: 'First, start an administrative command prompt and run these commands, replacing
    `{IPv4}:{PORT}` with the `IPv4 Address` and `PORT` you are using:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，启动一个管理命令提示符并运行以下命令，将 `{IPv4}:{PORT}` 替换为你正在使用的 `IPv4 地址` 和 `PORT`：
- en: '[PRE76]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This just tells `http.sys that it''s OK to talk to this URL`. Next, run the
    following command:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这只是告诉 `http.sys` 与此 URL 通信是允许的。接下来，运行以下命令：
- en: '[PRE77]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This adds a rule in the Windows Firewall, allowing incoming connections to the
    port for computers on your local subnet.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这在 Windows 防火墙中添加了一个规则，允许本地子网上的计算机访问该端口的入站连接。
- en: 'Now we should be able to access the running API from our Mac instance. This
    time, paste the URL with the IPv4 address instead of `localhost: {IPv4 address}:{port}/api/StockItems`.'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在我们应该能够从我们的 Mac 实例访问正在运行的 API。这次，粘贴带有 IPv4 地址的 URL 而不是 `localhost: {IPv4 address}:{port}/api/StockItems`。'
- en: If all was successful, we should have the following XML layout displayed like
    this:![Hosting the Web API project locally](img/B05293_05_11.jpg)
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该看到以下 XML 布局显示如下：![本地托管 Web API 项目](img/B05293_05_11.jpg)
- en: 'Excellent! Now let''s add these URL settings to our mobile application. Open
    up the `Config.resx` file in the `Resources` folder of the `Stocklist.Portable`
    project, and fill in these values:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优秀！现在让我们将这些 URL 设置添加到我们的移动应用程序中。打开 `Stocklist.Portable` 项目的 `Resources` 文件夹中的
    `Config.resx` 文件，并填写这些值：
- en: '[PRE78]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Now let's test our project on iOS and Android, and we should be able to see
    our `StocklistPage` fill with items from our API controller.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 iOS 和 Android 上测试我们的项目，我们应该能够看到我们的 `StocklistPage` 从我们的 API 控制器中填充项目。
- en: Summary
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have built an application for retrieving a web service using `Xamarin.Forms`.
    We set up a `ListView` and created an `ObservableCollection` for displaying JSON
    objects. We also learned how to set up a simple web service on the back end. In
    the next chapter, we will create an application for both iOS and Android using
    the native libraries. We will use Signal R on the client and server side, and
    set up a hub and proxy connections via a client.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用`Xamarin.Forms`构建了一个用于检索网络服务的应用程序。我们设置了一个`ListView`并创建了一个`ObservableCollection`来显示JSON对象。我们还学习了如何在后端设置一个简单的网络服务。在下一章中，我们将使用原生库创建一个适用于iOS和Android的应用程序。我们将在客户端和服务器端使用Signal
    R，并通过客户端设置中心代理连接。
