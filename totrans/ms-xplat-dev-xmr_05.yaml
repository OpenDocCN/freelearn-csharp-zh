- en: Chapter 5. Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a detailed look at the networking capabilities
    of Xamarin applications and various service integration scenarios. The chapter
    also includes real-world examples on how to use local storage for data caching
    on connected app scenarios. It is divided into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Connected apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SignalR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns and best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform-specific concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connected apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile applications by definition should be as lightweight and resource-efficient
    as possible. You cannot expect to package media and other content into the application
    and then distribute the app or create an extravagant size of storage for user
    data, especially with applications whose main purpose is to provide user access
    to related content or store and manipulate the data.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, while dealing with cross-platform projects, one of the easiest
    ways to create unified business logic and storage is to create a web service layer
    and delegate the responsibility and logic to this layer. In this scenario, the
    application(s) would be simply responsible for serving the content provided by
    the service layer or communicating the user input to the service layer.
  prefs: []
  type: TYPE_NORMAL
- en: This approach not only increases the efficiency of the application(s) but also
    creates an abstraction between the logic implementation and the presentation.
    This allows the developers to be free from the platform constraints on technology
    choices for storage and execution.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to mention that applications' dependency on external resources
    is not a matter of choice but has rather become a necessity, since applications
    are more and more dependent on third-party web service APIs and social media networks.
  prefs: []
  type: TYPE_NORMAL
- en: Web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A web service is generally defined as an interoperable machine-to-machine communication
    over the wire (network). In the context of cross-platform application, the most
    important term in this definition would be "interoperable". Web services written
    in different frameworks or languages and running on different type of runtimes
    and hardware conform to the same standards, most of which can be consumed by applications
    running on a variety of platforms, including Xamarin target platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin target platforms, namely iOS and Android, and Windows Runtime, can access
    stateless web services using the TCP/IP (short for Transmission Control Protocol
    / Internet Protocol) stack over a secure or non-secure HTTP (short for Hypertext
    Transfer Protocol) transport layer. Even though various data representations can
    be consumed via web services, JSON and XML are the most common text-based notations
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While defining or accessing a web service, there are three basic elements that
    need to be taken into consideration. We can call these the A-B-C of a web service:
    Address, Binding, and Contract. The address is the remote access location to the
    service, binding defines the transport and security protocols, and contract defines
    the data types and the methods used by the service.'
  prefs: []
  type: TYPE_NORMAL
- en: While the methods and data types defined in the web service contract are very
    case-specific, transport and serialization protocols that can be used by Xamarin
    applications can be generalized.
  prefs: []
  type: TYPE_NORMAL
- en: In web service scenarios, if the consumer is a Xamarin target platform, you
    should always be persistent about using asynchronous implementation for the client
    implementation. Asynchronous implementation for the web service clients decreases
    the chance of blocking the main thread, as discussed previously, and protects
    the application from network shortage related errors and crashes.
  prefs: []
  type: TYPE_NORMAL
- en: Transport
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For Xamarin applications on both iOS and Android platforms, the main communication
    protocol is HTTP. HTTP transport can be secured on the client and/or message level
    using a certificate or credentials.
  prefs: []
  type: TYPE_NORMAL
- en: The message-level security is optional in other versions of iOS and Xamarin.Android
    applications. In iOS 9, the **App Transport Security** (**ATS**) feature enforces
    secure connections to network resources. Even though it is possible to add certain
    domains to the exclusion list, or to turn off the ATS altogether for the target
    applications, it is strongly advised that you use secure transport over HTTP (or
    HTTPS) for Xamarin.iOS applications.
  prefs: []
  type: TYPE_NORMAL
- en: Even though communication protocols for TCP, UDP, or web sockets over HTTP are
    fully or partially supported on Xamarin platforms, with the current service infrastructure
    implementation, these communication channels cannot be used with web services.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Messaging specifications of a service define which format should be used while
    communicating data over the HTTP transport layer.
  prefs: []
  type: TYPE_NORMAL
- en: In Xamarin applications dealing with web services, messages should be constructed
    either according to the SOAP (Simple Object Access Protocol) or using POX (short
    for Plain Old XML) or JSON, depending on the service requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '![Messaging](img/B04693_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simple SOAP Communication Example
  prefs: []
  type: TYPE_NORMAL
- en: The messaging structure is mainly important for the serialization and deserialization
    of request and response pairs between the client and server implementations. Hence,
    it is possible to employ other types of data communication models, which would
    require additional custom implementation for the client and the server.
  prefs: []
  type: TYPE_NORMAL
- en: SOAP/XML services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SOAP web services use XML data objects enveloped in SOAP-defined schemas. **Windows
    Communication Foundation** (**WCF**) services and ASP.Net Legacy Services (ASMX)
    are both SOAP services and conform to the SOAP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: SOAP web service contracts are defined in **Web Service Description Language**
    (**WSDL**) and the WSDL document, together with other XML data schemas (for example,
    XSD files), are generally accessible through the web service URL. Using this document,
    web services can be defined in a consistent manner, irrespective of the underlying
    language, and can be interfaced with and consumed by various clients.
  prefs: []
  type: TYPE_NORMAL
- en: '![SOAP/XML services](img/B04693_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Service WSDL for a SOAP 1.1 Service
  prefs: []
  type: TYPE_NORMAL
- en: In Xamarin applications, one of the possible ways to create a so-called proxy
    (service consumer) is to use the Silverlight SDK to generate the access code.
    The main reason for using the Silverlight SDK is the fact that the Windows Communication
    Foundation client infrastructure is not fully included in the Xamarin core and
    only a subset of client features, very similar to the Silverlight framework, can
    be used to access web services.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to generate the client, you can simply use the command-line tool to
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SLSvcUtil can be found in various SDKs including Windows Phone 7, Windows Phone
    8, Windows Phone 8.1 (Silverlight), as well as the actual Silverlight SDK directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`C:\Program Files (x86)\Microsoft SDKs\Windows Phone\v7.0\Tools\SlSvcUtil.exe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C:\Program Files (x86)\Microsoft SDKs\Windows Phone\v8.0\Tools\SlSvcUtil.exe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C:\Program Files (x86)\Microsoft SDKs\Windows Phone\v8.1\Tools\SlSvcUtil.exe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C:\Program Files (x86)\Microsoft SDKs\Silverlight\v5.0\Tools\SlSvcUtil.exe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding command would generate a WCF client that can communicate with
    any web service that supports the SOAP 1.1 profile. If we were to consume a WCF
    service, the supported binding configurations would be `BasicHttpBinding` and
    `WebHttpBinding` (essentially a REST binding). `WSHttpBinding` and similar configurations
    use other SOAP profiles to envelope the data requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: '![SOAP/XML services](img/B04693_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Generating Silverlight Proxy
  prefs: []
  type: TYPE_NORMAL
- en: The generated client would have both the Event-Based and Asynchronous Programming
    Model (APM) asynchronous methods for accessing the client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Another approach would be to create a web reference in Visual Studio or Xamarin
    Studio. A web reference can only be used to communicate with services that implement
    the WS-I Basic Profile 1.1 (in other words, SOAP 1.1). Web reference generated
    clients use the ASMX communication stack (.NET 2.0 Services Technology) as opposed
    to the WCF client infrastructure used by service references.
  prefs: []
  type: TYPE_NORMAL
- en: '![SOAP/XML services](img/B04693_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Add Web Reference Dialog (Visual Studio)
  prefs: []
  type: TYPE_NORMAL
- en: If we were to compare the generated clients from the web reference and the Silverlight
    SDK, we could easily identify the underlying technologies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the class diagram for both of the generated proxies, we can get
    some more insight into the method execution strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SOAP/XML services](img/B04693_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Generated Proxy Comparison
  prefs: []
  type: TYPE_NORMAL
- en: The ideal way to integrate the generated proxy in a cross-platform project would
    be to add the service reference in a portable class library to be used by platform-specific
    projects. In order to be able to add a service reference in a PCL project in Visual
    Studio, you must remove Windows Phone 8.1 as one of the targets and/or add a reference
    to the `System.ServiceModel` namespace (Visual Studio will automatically remove
    Windows Phone 8.1 from the targets list). The Windows Phone 8.1 platform does
    not include the Windows Communication Foundation client assemblies. After this
    step, the **Add Service Reference** option will appear under the project context
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: For scenarios involving Windows Phone 8.1, the more appropriate solution would
    be to use a RESTful service and a client.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RESTful services are one of the most common distributed system implementations
    involving mobile applications. Compared to SOAP services, they don't have the
    overhead of SOAP protocols or the enveloping of the request/response pairs. In
    essence, network traffic caused by a SOAP method call is the same as the request/response
    pair of a REST call. The simplicity of the **Representational State Transfer**
    (**REST**) model increases the performance and maintainability. Stateless and
    cacheable approaches of RESTful services makes them an optimal solution for Xamarin
    target platforms.
  prefs: []
  type: TYPE_NORMAL
- en: REST services can essentially be described as static HTTP endpoints. The HTTP
    verbs (GET, PUT, POST, and DELETE) used to access these endpoints define the type
    of method to be invoked on the service layer (PUT for update, POST for create,
    and DELETE for delete actions). The messaging structure can vary from JSON to
    XML, even to ATOM.
  prefs: []
  type: TYPE_NORMAL
- en: On Xamarin target platforms, there are various out-of-the-box options and additional
    components available for REST-based web services. Any of these options can be
    used to execute web requests and request/response pairs can be serialized/deserialized
    according to the requirements and chosen messaging media-type.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are making ordinary web requests to the REST endpoints, the simplest
    implementation would involve the `HttpClient`, which is included in the `System.Net.Http`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if we were to implement a base class that will handle the CRUD
    (create, read, update, and delete) methods on the RESTful version of the web service
    used in the previous section (`TravelTrace.ReferenceDataService`), we could implement
    a per-call wrapper around the inner HTTP client layer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that we are using the base address as the server address and,
    if any, using the security token to initialize our client. In this implementation,
    the create method will simply create the HTTP client and use the authentication
    token as a default header. Another important requirement is to set the "Accept"
    header to announce which type of content the client is expecting from the server
    (JSON in this example).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After the HTTP pipeline is ready to execute the requests, we can start implementing
    the base methods for the REST service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `GetRegions` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this request can be visualized in the debug screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![RESTful services](img/B04693_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: JSON data returned from Web API
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this is only the string representation of the service data, and we
    would need to extend our implementation to include a JSON serializer. There are
    multiple options available for serialization, including the standard libraries
    available through the *Microsoft BCL* package: `System.Xml` and `System.Json`
    namespaces. *NewtonSoft Json.NET* is still one of the most popular JSON libraries
    and available through NuGet.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using this implementation, we can create generic methods in the base class implementation
    and push the serialization responsibility to this layer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can extend this generic implementation for other web methods and create the
    basis for our RESTful client. The authentication scenario will be discussed further
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more REST consumer implementations available for the Xamarin
    developer and these modules can be included in cross-platform projects via components
    and NuGet packages (RestSharp, Hammock, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: OData and OAuth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OData and OAuth are two widely accepted standards/protocols for RESTful communication
    scenarios. Xamarin mobile applications that deal with external resources, and
    especially third-party web service APIs, are generally implementing these protocols.
  prefs: []
  type: TYPE_NORMAL
- en: OData
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike SOAP, which is a communication protocol, REST is simply an architectural
    approach to web service implementations. RESTful services do not need to conform
    to certain specifications and may vary greatly. In order to identify the requirements
    for RESTful services and create a uniform structure for data being exchanged between
    the client applications and the server, OData was initiated by Microsoft in 2007\.
    OData is now an internationally accepted protocol that is maintained by OASIS
    and supported/used by various applications, platforms, and companies (for example,
    Microsoft Azure Mobile Services, Microsoft Office 365 Web Access, Salesforce,
    SAP Netweaver Gateway Solution, IBM WebSphere, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: In OData protocol, each object set is defined by an endpoint in line with REST
    principles. For GET requests, these entity set endpoints can either accept object
    identifiers, which results in the details of that specific entity instance, or
    entities in the list can be queried with OData filter and other query options.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the WSDL in SOAP/XML services, accessible endpoints (entity sets
    and functions) and types used in the service contracts are generally served through
    the metadata endpoint with a CSDL (OData Common Schema Definition Language) file
    in OData.
  prefs: []
  type: TYPE_NORMAL
- en: To access the whole list of elements, visit `http://localhost/Xamarin.Master.TravelTrace.Service.Api/odata/regions`.
  prefs: []
  type: TYPE_NORMAL
- en: To access a single element in the entity set endpoint, visit `http://localhost/Xamarin.Master.TravelTrace.Service.Api/odata/regions(guid'90222c18-66fa-441a-b069-0115faa1e0f1')`.
  prefs: []
  type: TYPE_NORMAL
- en: To query the list of elements with a filter, visit `http://localhost/Xamarin.Master.TravelTrace.Service.Api/odata/regions?$filter=Continent
    eq 'Europe'`.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced OData queries involving additional property expansions, lambda operators,
    and functions are also possible with the OData protocol; however, these topics
    are beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple NuGet packages and components available both as open source
    and/or free to download that help with the client generation for OData services.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OAuth is an open standard used generally by service providers for authorization.
    A general use case for OAuth would be to use third-party identity providers such
    as Live ID (Microsoft), Google, Facebook, or Twitter for authentication and authorization
    in a mobile or web application.
  prefs: []
  type: TYPE_NORMAL
- en: A classic OAuth 2.0 implementation scenario is generally a two-step process.
    The first step involves the user granting access to the client application through
    the provider web interface. The second step is using the authorization code received
    from the provider's web interface to get an access token to access the provider's
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: '![OAuth](img/B04693_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Facebook as Auth Provider
  prefs: []
  type: TYPE_NORMAL
- en: The first step of the authorization process on a web application is generally
    an `iframe` displaying the provider's authorization page. In a Xamarin application,
    this step is executed using a web view control or a more specialized implementation
    (`WebAuthenticationBroker` is an out-of-box control on Windows Phone 8.1). Implementing
    the two-step authentication process can become quite cumbersome considering the
    fact that the provider's page makes a callback request to the client application
    page with the authorization token and the client app is responsible for parsing
    and extracting this token either from the callback URL or the body of the content.
  prefs: []
  type: TYPE_NORMAL
- en: '![OAuth](img/B04693_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xamarin.Auth Components
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide access to OAuth APIs and simplify the implementation, developers
    can make use of the available Xamarin OAuth component: Xamarin.Auth (available
    on Xamarin.iOS and Xamarin.Android platforms). There is also an accompanying component
    for social media provider APIs: Xamarin.Social.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Xamarin.Auth implementation, authenticating with the Facebook API
    can become as simple as a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: SignalR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET SignalR is a web server-side technology that allows developers to pass
    real-time updates to their applications. SignalR works in a similar way to WCF
    duplex channels where the server side is accessible through the main service contract
    and the server-to-client communication occurs through the callback contract. While
    WCF duplex channels provide support for the same scenarios as SignalR, duplex
    channel implementation is currently not supported in any of the Xamarin target
    platforms. On the other hand, there is a component available for use on all Xamarin
    target platforms for SignalR.
  prefs: []
  type: TYPE_NORMAL
- en: '![SignalR](img/B04693_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SignalR Component
  prefs: []
  type: TYPE_NORMAL
- en: SignalR takes advantage of `WebSockets`, which enables bidirectional communication
    over the HTTP transport. In essence, `WebSockets` works almost in the same way
    as TCP Sockets; however, the connection is established over the HTTP transport
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: Using SignalR, applications requiring real-time data can be implemented without
    resorting to polling or listener channel implementations, which is neither scalable
    nor efficient on mobile platforms.
  prefs: []
  type: TYPE_NORMAL
- en: SignalR is generally implemented with a Hub application on the server-side,
    which creates different event sinks to be subscribed by different applications.
    Each client that subscribes to a certain channel gets event notifications and
    data over these channels in a normal broadcast scenario in a string format or
    already deserialized as a complex type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: SignalR server implementations can, generally speaking, replace RESTful service
    actions. These duplex hubs can provide functions to be called by the consumers
    as well as update calls from the server to listening clients.
  prefs: []
  type: TYPE_NORMAL
- en: While different message formats can be used to exchange data, most implementations
    employ the JSON format to serialize and deserialize data, and Json.NET is the
    default serialization library used by the SignalR component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'On top of the server invoked events, SignalR channels also offer lifetime events:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Received**: Raised when any data is received on the connection. Provides
    the received data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConnectionSlow**: Raised when the client detects a slow or frequently dropping
    connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reconnecting**: Raised when the underlying transport begins reconnecting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reconnected**: Raised when the underlying transport has reconnected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**StateChanged**: Raised when the connection state changes. Provides the old
    state and the new state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Closed**: Raised when the connection has disconnected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SignalR supports SSL transport security as well as having the ability to integrate
    with the existing authentication and authorization providers already being used
    by the web server and mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns and best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In mobile applications, developers often use certain reusable design patterns
    while using web services and other communication channels in development projects.
    These patterns aim to increase the efficiency and increase the code sharing not
    only between platforms but also among various execution domains of cross-platform
    mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: Async conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The generated proxies for WCF and/or SOAP/XML services generally include either
    an event-based async implementation or an asynchronous invoke pattern with begin
    and end methods. Both of these implementations can be converted to a task-based
    async pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In order to convert the event-based async service method to a task-based one,
    we can use `TaskCompletionSource<T>` and return the task that is produced (refer
    to [Chapter 3](ch03.html "Chapter 3. Asynchronous Programming"), *Asynchronous
    Programming*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For the async invoke pattern, we can use the designated methods from the `TaskFactory`.
    The `FromAsync` method of the `TaskFactory` uses the begin and end methods together
    with the async state object (which can, for example, be used for cancellation
    token or progress callback) and creates an awaitable task.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Data model abstraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following the quality identifiers that were put forward previously, in service-related
    scenarios, it is important to create a data model abstraction layer which can
    be used by different branches of a cross-platform application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the travelers'' guide application example from previous sections, we
    can analyze the sharing strategy. In this example, as a development team or a
    single developer, we are responsible for:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the service layer responsible for accessing the database and connecting
    to external APIs, if necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the shared common logic which will be used by Xamarin applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Xamarin.iOS and Xamarin.Android applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Windows Phone 8.1 application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the web interface which will employ a Silverlight component (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For simplicity, we will be implementing only a single data type and a single
    GET method.
  prefs: []
  type: TYPE_NORMAL
- en: For the contracts and the data objects, we can create a portable library that
    will be targeting Xamarin platforms together with .NET 4.5\. The reason we are
    including the .NET profile is because we will be using the data model in the service
    layer implementation as well.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation starts by creating the Data Transfer Model objects. These
    objects are generally the reflection of the database tables used on the service
    layer. However, one-to-one mapping between DTOs and DBOs (Entity Framework items)
    is not absolutely necessary since the DTO abstraction layer's sole purpose is
    to create an abstraction layer over the actual data repository that we will be
    dealing with.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that we are including Json.NET attributes to define class properties.
    They are used to format the JSON object attributes during serialization/deserialization
    to camel-case (for example, camelCase), which is the JavaScript convention, rather
    than the .NET convention of pascal-case (for example, PascalCase) for property
    names. These property definitions can be used with RESTful clients and web service
    implementations. This will not interfere with other service or client layer use
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the model, we can define the interface(s) that will be used
    by the web service and associated clients. We will define two interfaces for synchronous
    implementation on the service layer and asynchronous consumption on the client
    side.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The service implementation strategy would normally be to use a RESTful layer.
    For demonstration purposes, let's implement the WCF service in a separate project,
    reusing the data model defined and the interface previously created.
  prefs: []
  type: TYPE_NORMAL
- en: '![Data model abstraction](img/B04693_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Solution Structure
  prefs: []
  type: TYPE_NORMAL
- en: In this implementation, each service method will be calling a data repository
    (Entity Framework/MSSQL) and the repository will be returning the DTO objects
    by converting the database layer entities.
  prefs: []
  type: TYPE_NORMAL
- en: The next section of the project that we need to implement would be the service
    data consumer layer. We will create a new portable library for this layer and
    use a generated WCF client. After creating the project and adding the reference
    to the `System.ServiceModel` namespace and the common portable library that contains
    the DTO model, an important detail to remember is to make sure that the generated
    proxy reuses the referenced libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '![Data model abstraction](img/B04693_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Service Reference Properties
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are using the Silverlight SDK to generate the client, it is a little
    more complicated to include the existing libraries so that the types are reused.
    In order to do this, you can use the "reference" switch (or simply, `/r`: ) and
    point the utility to the assemblies that contain the implemented types.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After creating the proxy, we have a structure in which the data model and the
    contracts are shared by different layers of the application including the service,
    data access layer, service proxy, and finally, the applications.
  prefs: []
  type: TYPE_NORMAL
- en: '![Data model abstraction](img/B04693_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Shared service structure
  prefs: []
  type: TYPE_NORMAL
- en: The implementation, however, should be further extended with conversions to
    task-based async implementation on the service proxy. Another useful improvement
    would be to implement local DB caching and offline storage. For this caching layer,
    the same DTO implementation can be reused.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to include a Windows Phone 8.1 client in this cross-platform project,
    the only solution to the lack of WCF infrastructure would be to exchange the WCF
    service with a RESTful implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Service cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When dealing with network scenarios, it is important to keep in mind that mobile
    devices do not always have a good network connectivity or network at all. In order
    to make the Xamarin connected app usable even in offline scenarios, a caching
    layer can be implemented to store and return data items that do not often change.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in travel guide applications, users will want to access guides,
    and possibly maps, even when they are with a roaming connection or, even worse,
    without any connection at all. To facilitate offline storage, we can implement
    a SQLite database that uses the existing data transfer objects as storage items
    and updates the data on certain intervals when there is Internet connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: The first step of the implementation would be to revise our DTO layer classes
    and add SQLite attributes if needed. This will create a dependency on the service
    layer for SQLite assemblies; the other option is either to use linked code files
    between the service layer and the client libraries or to recreate the DTO objects
    specifically for the SQLite data store.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario, in order to create a data context that will use the online
    storage if available and use the local data storage if Internet connectivity is
    limited, we can implement the same data interface that we created for the service
    proxy in the previous examples for the SQLite data source and create one parent
    handler for the data sync context.
  prefs: []
  type: TYPE_NORMAL
- en: '![Service cache](img/B04693_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data Abstraction on App Tiers
  prefs: []
  type: TYPE_NORMAL
- en: In the sync context, for GET methods, the service calls will be used only for
    updating the local storage and actual results will be returned from the local
    storage. For PATCH, POST, and PUT calls, depending on the online connectivity,
    we will be either saving the data locally or pushing the deltas and new object
    instances to the service and updating the local data with the updates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For performance improvement in this implementation, when we are loading data
    for certain visualizations, we can first call the local data provider and continue
    with UI updates and then call the web service method and the same continuation
    delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Platform-specific concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are other concepts and network communication methods on Xamarin platforms
    that are provided by the native runtime and supported by Xamarin.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for an Android or Windows Phone application to access Internet, the
    application manifest should declare that the application will need to use the
    network to access resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The permission on Android system is declared using the `uses-permission` tag
    in the manifest node of the XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'While this declaration will suffice in most use case scenarios, in order to
    access the current network status or the Wi-Fi status, you must also declare the
    network state permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: For a Windows phone, the app capability to declare would be `ID_CAP_NETWORKING`.
  prefs: []
  type: TYPE_NORMAL
- en: Application manifests for both platforms can be edited through the application
    project properties in the designated configuration section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Permissions](img/B04693_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Android Manifest
  prefs: []
  type: TYPE_NORMAL
- en: iOS, other than the App Transport Security (ATS) that was mentioned previously,
    does not enforce any manifest setup or permissions for applications to use network
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: NSUrlConnection/NSUrlSession (iOS Only)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from the different client libraries available for use with Xamarin target
    platforms, some native implementations can also be used to call and receive external
    web data. One of these available options for Xamarin.iOS platform is `NSUrlConnection`.
    With the help of `NSUrlConnection`, developers can make web requests and use the
    response.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple web request to retrieve the data from the previously demonstrated
    static data endpoint on iOS would look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The implementation for the connection delegate would involve the deserialization
    of the data and assigning the result to the `TaskCompletionSource` so the method
    execution can be finalized.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Even though this implementation is possible on the iOS platform, considering
    the cost of passing the mono to iOS bridge (likewise on Android and JNC Bridge),
    this type of implementation should be avoided, and either only native or mono
    runtime code should be used to communicate over the network.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar manner, we can implement the usage scenario for the new `NSUrlSession`
    class in iOS. However, `NSUrlSession` can also be used in background download
    scenarios. Therefore, we will discuss it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Background downloads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the application requires larger network resources than the client UI can
    wait for, in Xamarin mobile applications we can resort to background downloads.
    Both iOS and Android platforms offer implementations for background downloads
    and these strategies can be executed on Xamarin runtime.
  prefs: []
  type: TYPE_NORMAL
- en: For Xamarin.Android application developers, the easiest way to execute a background
    download is to use the Download Manager API service/application provided since
    API level 9\. The download manager can be initialized with a request and the application
    can subscribe to event notification(s) regarding the download status.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a request to pass onto the `DownloadManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the request is ready to be executed, we can get the `DownloadManager`
    instance and queue the download request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The download reference can be used to get the current status information about
    the queued download or cancel the ongoing background download.
  prefs: []
  type: TYPE_NORMAL
- en: To get the current status of the download or cancel it, we can use the respective
    methods on the `DownloadManager` instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This implementation can be extended with the notification(s) that are received
    from the `DownloadManager` application using a `BroadcastReceiver` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can now register the broadcast receiver with the `DownloadManager` instance
    and update the UI with a possible delegated implementation for updating it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: On top of the broadcasts mechanism, the Download Manager App UI can also be
    invoked within the Xamarin applications to give a uniform UI about on-going or
    completed transfers.
  prefs: []
  type: TYPE_NORMAL
- en: On the iOS platform (at least post iOS 7), background transfers (both download
    and upload operations) are made possible with `NSUrlSession`. `NSUrlSession` provides
    an easy to implement interface that lets developers create an efficient and reliable
    transfer processes.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation strategy for `NSUrlSession` initially involves the implementation
    of an `NSUrlSessionDelegate`, which will be the responsible "handler" for the
    transfer process. Basic methods related to the health and status of the transfer
    are exposed through this delegate and can be implemented to provide required information
    for the transfer or give real-time updates to the application user.
  prefs: []
  type: TYPE_NORMAL
- en: '`DidFinishEventsForBackgroundSession` is called when the background session
    is complete'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DidReceiveChallenge` is invoked when the server requests credentials'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DidBecomeInvalid` is invoked when there is a problem with the session'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSUrlSessionDelegate` provides the base implementation for more specialized
    transfer delegates: `NSUrlSessionDownloadDelegate` for download operations and
    `NSUrlSessionTaskDelegate` for upload operations. These delegate classes expose
    additional status methods related to the transfer tasks (for example, download
    delegate provides methods to retrieve notifications about the download progress).'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if we were to use the same example as on Xamarin.Android with
    the `BroadcastReceiver` implementation, the `NSUrlSessionDownloadDelegate` implementation
    would require three basic methods for completion, error, and progress.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: After the delegate implementation is complete, we can create the session and
    start the download operation using the `NSUrlSession`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: On top of the handler implementation, the iOS app can be woken to execute certain
    code, such as a local mobile notification to inform the user about the completed
    sessions. For the task complete event, one needs to use the iOS application delegate
    (refer to [Chapter 2](ch02.html "Chapter 2. Memory Management"), *Memory Management*)
    for `DidFinishEventsForBackgroundSession`.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile notifications (also called pushed notifications for remote scenarios)
    are user notifications that are executed on the OS level to inform the user about
    application-related updates. They can be triggered both locally or by using a
    remote server.
  prefs: []
  type: TYPE_NORMAL
- en: Push notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Push notifications are subtle UI messages that can help an application to provide
    the user information about an asynchronous task being executed by the service
    layer or about an external event that is related to the application instance itself
    (for example, messages from social networks, approval for a travel reservation,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to create and receive push notifications on both Xamarin platforms
    and Windows Phone. These notifications are triggered by a secondary server/application
    (for example, service layer), brokered by the corresponding messaging infrastructure
    provider for the platform and displayed by the application on the target client.
    For the Android platform, the messaging provider is **Google Cloud Messaging**
    (**GCM**) and it is the **Apple Notification Push Service** (**APNS**) for iOS.
    Both of these service providers require your application to be registered to receive
    push notifications and the server application to have the credentials to be able
    to authenticate with the notification services. Similarly, **Windows Notification
    Services** (**WNS**) adopts a federated authentication mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Both GCM and APNS use a subscription model in which the client app on a specific
    device subscribes/registers for the push notifications and an addressing token
    is created. The addressing token is used, later on, by the server to send push
    notifications to the message broker service (for example, GCM) and the queued
    messages are delivered to the specific client.
  prefs: []
  type: TYPE_NORMAL
- en: '![Push notifications](img/B04693_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Push Notifications
  prefs: []
  type: TYPE_NORMAL
- en: On top of the classic messaging model, GCM also supports topic-based and group-based
    messages where the receivers are not limited to a single device/application pair.
    It is also possible with GCM to create a duplex channel where the client is able
    to send messages back to the server layer.
  prefs: []
  type: TYPE_NORMAL
- en: Push notifications on these platforms can be used to trigger various tasks,
    the most common of which is to navigate to a certain view and continue the business
    process flow initialized by the notification.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is relatively elementary on the client side to subscribe to push
    notifications, cross-platform scenarios require complex implementation to introduce
    a single server environment to provide messages to both GCM and APNS. However,
    there are platform-agnostic implementations available for both of these platforms.
    The Microsoft Azure platform and the notification hub is one of these solutions,
    where communication with GCM and APNS are both supported through usage of the
    same business logic implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though there are multiple cloud service providers as development platforms
    for creating the backend for mobile applications, Microsoft Azure stands out among
    the competitors with its inherent natural bond to the .NET platform and subsequently
    Xamarin, considering its evolution. Most of the features supported by Azure have
    a specific implementation for Xamarin target platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Mobile Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure Mobile Services is a scalable cloud development platform that helps developers
    add functionality to their mobile applications with ease. The patterns and features
    described in this chapter related to network services such as OData services,
    offline data storage, push notifications, and OAuth authentication providers are
    already included in the mobile services SDK and can be configured through the
    Azure management console.
  prefs: []
  type: TYPE_NORMAL
- en: In order to demonstrate aforementioned features, we can incorporate them into
    our demo application.
  prefs: []
  type: TYPE_NORMAL
- en: The initial step would be to create a mobile service on the Azure management
    console. For this purpose, we will select a compute service and create the mobile
    service.
  prefs: []
  type: TYPE_NORMAL
- en: '![Azure Mobile Services](img/B04693_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Create Compute Service
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will set up the mobile service endpoint and create the SQL database
    to store the online data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Azure Mobile Services](img/B04693_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mobile Service Setup
  prefs: []
  type: TYPE_NORMAL
- en: Once the setup is complete, the "personalized" service layer project can be
    downloaded in order to integrate the mobile services into the application project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Azure Mobile Services](img/B04693_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Connect Mobile Services to an existing Xamarin app
  prefs: []
  type: TYPE_NORMAL
- en: In the service layer project, you will notice that there is only a single controller
    created for your convenience. We will be extending the project with additional
    controllers and adding a reference to our own DTO data model. In order to reuse
    the types created in the previous sections, instead of referencing the common
    data model project directly, we add the data type files as a reference to the
    new service project that we downloaded from the Azure portal. The reason for the
    referenced files is that the data objects in the service project have to derive
    from `EntityData` class. Another change we need to make is to convert the class
    definitions to partial and remove the SQLite references, for example, you can
    comment out the SQLite property descriptors or use conditional compilation.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are using `AZURE` as the build constant for the Azure web
    service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create a data object definition using a `partial` declaration for
    the `Region` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: After this step, you can simply use the existing project item template for the
    controller to add the specialized data endpoint (Microsoft Azure Mobile Services
    Table Controller).
  prefs: []
  type: TYPE_NORMAL
- en: '![Azure Mobile Services](img/B04693_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Microsoft Azure Mobile Services Table Controller
  prefs: []
  type: TYPE_NORMAL
- en: This will create a controller for the data object and insert the type into the
    data context.
  prefs: []
  type: TYPE_NORMAL
- en: Once the project is published and the mobile services are running, SQL database
    tables are going to be migrated automatically. This migration also applies to
    data table column changes or future additions to the DTO model.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can add the NuGet package or the component to our client application
    and add the necessary initialization code, as described in the start page of mobile
    services section on the Azure management console.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main activity, we create the following mobile service instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to an event handler or the `OnCreate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: After the code is successfully executed, the data on the Azure database can
    be observed using SQL Management Studio or the Visual Studio SQL Server tools.
  prefs: []
  type: TYPE_NORMAL
- en: '![Azure Mobile Services](img/B04693_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Azure Data Sample
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a working service layer and a client that can communicate with
    it, we can have a look at the local synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Azure offline data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For local data caching and offline scenarios, Azure Mobile Services SDK already
    implements a synchronization framework where the local data is stored in SQLite
    database and the synchronization is handled by pull and push commands (push requests
    upload local changes to the cloud store whereas pull requests download the latest
    changes from the server) using a default conflict handler. Each pull request automatically
    issues a push request where the local data is pushed to the cloud storage. Conflicts
    are resolved according to the created and updated fields, which are members of
    each object type defined using the `EntityData` base class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before starting the implementation, we need to download and install the Azure
    Mobile Services SQLiteStore NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: In order to initialize the default local data store, we will use the `MobileServicesSQLiteStore`
    implementation. Custom local store implementation can be incorporated using the
    `IMobileServiceLocalStore` interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: After the local store is initialized and the synchronization context is created,
    we can implement the synchronization method that can be called every time the
    application starts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Both the `PushAsync` and `PullAsync` methods additionally accept filter expressions
    so one can limit the synchronization to certain entities.
  prefs: []
  type: TYPE_NORMAL
- en: In this implementation, once the synchronization context is in place, if the
    service connection is not available, the `IMobileServiceSyncTable<T>` interface
    implementations handle the offline data and the data is kept in the local store
    until the next push operation.
  prefs: []
  type: TYPE_NORMAL
- en: Azure authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Azure platform provides various authentication mechanisms for Xamarin mobile
    applications. Each authentication mechanism can be integrated into existing mobile
    applications with a service backend through NuGet packages and/or components.
  prefs: []
  type: TYPE_NORMAL
- en: Being a multi-tenant, cloud-based directory and identity management service,
    Azure Active Directory (Azure AD) provides application developers an easy way
    to create single sign-on experience on a large number of cloud SaaS applications.
    It is also possible to incorporate an existing Windows Server Active Directory
    into applications and leverage the existing on-premise identity stores. These
    features make the Azure AD an ideal candidate for LOB applications.
  prefs: []
  type: TYPE_NORMAL
- en: Another authentication strategy for Azure Mobile Services is to configure an
    existing authentication provider such as Facebook, Google, Twitter, or Microsoft
    and secure the service requests using the Azure Mobile SDK. In order to register
    an authentication provider, the first step would be to create a consumer app on
    the target platform.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if we were to use Live ID for our authentication scenarios, we
    would need to use the Live Connect App management site ([https://account.live.com/developers/applications/index](https://account.live.com/developers/applications/index)).
    Similarly, for Twitter, we would need to create a Twitter consumer application
    on the Twitter application management console ([https://apps.twitter.com/](https://apps.twitter.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Azure authentication](img/B04693_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Live Connect app management site
  prefs: []
  type: TYPE_NORMAL
- en: Once the application setup is in place, the Azure management console can be
    used to update the mobile services configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '![Azure authentication](img/B04693_05_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mobile Services Identity Configuration
  prefs: []
  type: TYPE_NORMAL
- en: After the identity provider for the mobile services has been set up, the web
    service project can be easily protected simply by adding the Authorize attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: On the client apps, the authentication is handled by simply using the `LoginAsync`
    method on the Azure Mobile Services SDK client with the correct authentication
    provider.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The result is the same authentication screen received using the Xamarin.Auth
    component.
  prefs: []
  type: TYPE_NORMAL
- en: '![Azure authentication](img/B04693_05_23-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Brokered Authentication
  prefs: []
  type: TYPE_NORMAL
- en: Azure Cloud integration scenarios extend far beyond the ones described here.
    The features that are included in this cloud-based development platform can help
    developers enhance their Xamarin apps with ease and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided an overview of various network channels that can be used
    in Xamarin applications to create connected applications.
  prefs: []
  type: TYPE_NORMAL
- en: Web services are definitely on the essentials list for modern mobile applications
    because of the interoperability of the protocols in place for web services (both
    SOAP/XML and REST/JSON). Unfortunately, XML services are a little harder to integrate
    with Windows Phone 8.1 runtime (even though they are still supported by Windows
    Phone Silverlight runtime) because the Windows Communication Foundation client
    infrastructure is not included in Windows Phone runtime. However, the same RESTful
    service proxies can be used by applications on each Xamarin target platform and
    Windows Phone.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud integration options such as mobile services and Azure Active Directory
    were discussed with demonstration samples. Each of these technologies provides
    additional connectivity and integration opportunities for Xamarin mobile apps.
    SignalR is another web technology that grants additional communication capabilities
    to mobile applications by means of bidirectional communication between the client
    apps and the server.
  prefs: []
  type: TYPE_NORMAL
- en: Several common service and web implementation patterns were demonstrated using
    the TravelTrace application scope that we will be using for various scenarios
    in the remainder of this book. Each pattern described targets different quality
    identifiers initially mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed some of the platform-specific network options.
  prefs: []
  type: TYPE_NORMAL
