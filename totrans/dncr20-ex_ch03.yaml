- en: Building Our First .NET Core Game – Tic-Tac-Toe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning is more fun if we do it while playing games. With this thought, let's
    continue our quest to learn .NET Core 2.0 by writing our very first game in .NET
    Core 2.0, Tic-Tac-Toe. In this chapter, we will understand the anatomy of the
    ASP.NET Core 2.0 application that we created in [Chapter 1](ch01.html), *Getting
    Started*, and understand each file and its purpose in the application. Then, we
    will quickly understand the basics of SignalR Core, which is the technology we
    will use to write the game in .NET Core 2.0\. We will then proceed with the quick
    setup of SignalR Core, followed by the design and coding of the basic Tic-Tac-Toe
    game, in which players can specify their own images instead of conventional *X*
    and *O*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the topics that we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of ASP.NET Core 2.0 application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tic-Tac-Toe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SignalR Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anatomy of an ASP.NET Core 2.0 application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss the *who is who and what is what* of the ASP.NET
    Core 2.0 application that we created in the *Creating a simple* *running code* section
    of [Chapter 1](ch01.html), *Getting Started*. The idea is to understand the purpose
    and use of each file that comes with the MVC template when creating the application,
    so that we can make the best possible use of them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows what our application structure looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7b5942b-09e6-4867-b4b6-b688f2575575.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For ease of understanding, the items are numbered from 1 to 12\. We will walk
    through each item and understand what they bring to the table:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connected Services: This doesn''t present itself as a physical file in the
    project template created by .NET Core 2.0 tooling, and is only visible when the
    project is opened from Visual Studio 2017 IDE; that is, it''s a Visual Studio
    2017 feature. The intent is to make it easier for developers to add connected
    services to their application. The services may be deployed on-premises or in
    the cloud. Earlier, this used be available as Add Connected Service in the project''s,
    right-click context menu; now it''s available as a node in Solution Explorer for
    web and mobile projects. One of the services that every ASP.NET Core web app can
    leverage is Application Insights. The entire comprehensive list of services can
    be found at [https://docs.microsoft.com/en-us/azure/#pivot=services&panel=all](https://docs.microsoft.com/en-us/azure/#pivot=services&panel=all).
    If we click on the Connected Services node in Solution Explorer, we will see a
    new full page window in Visual Studio which has three tabs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/39fb2154-050b-47ee-a0f8-0bedee914fe2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Overview: This tab is in the `GettingStarted` section of the ASP.NET Core app.
    It lists Microsoft''s official documentation links for ASP.NET Core app development,
    adding services, and deploying it to the cloud.'
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connected Services: This is the section that enables us to add connected services
    to the application. Right-click on the Connected Services node in Solution Explorer;
    we see a context menu item, Add Connected Service. If we click this item, it also
    navigates to the same place. We will add connected services in subsequent chapters,
    when we discuss Azure:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4099ae78-3b92-493f-9931-31290397cd52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Publish: To publish the web app in the cloud or on-premises. We will discuss
    this further in a later chapter, when we publish our app in Azure.'
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Dependencies: This node has been around in Visual Studio for a while now. Again,
    this isn''t present as a physical file in the system. There is a tooling update
    in Visual Studio 2017, which categorizes the dependencies and groups them into
    the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Analyzers: The analyzers are included in the project by default, as shown here:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4ae41f65-6923-4332-91a7-58cfa08b921e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'NuGet: The NuGet packages referred by the project are listed here. In the default
    ASP.NET Core 2.0 MVC template, we will see just one NuGet package called `Microsoft.AspNetCore.All`
    and that''s awesome, as we no longer need to worry about versioning different
    packages and plumbing them to use in our app. `Microsoft.AspNetCore.All` is a
    metapackage; that is, it only references other packages. It references all ASP.NET
    Core packages and their dependencies, and all Entity Framework Core packages and
    their dependencies. The version of this package represents the ASP.NET Core and
    Entity Framework Core version. And the best part is that even though it''s just
    one package, you can still go ahead and visualize all the packages that come with
    it alongside their dependencies:'
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/043d4ea3-3737-4dd4-ad95-b5430bb2b5eb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'SDK: Displays the target SDK. For the default ASP.NET Core 2.0 app, it would
    be Microsoft.NETCore.App.'
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bower: This is the package manager for the web. It helps manage all the client-related
    stuff, such as HTML, CSS, JavaScript, fonts, and images. All the client-side packages
    are listed here. In the default project template, we can see stuff such as bootstrap,
    jquery, and so on.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: These are the four types of dependency that come with the default ASP.NET Core
    2.0 MVC template. But we are not limited to these dependencies alone. Based on
    the package manager of choice, we may also have **node package manager** (**npm**)
    or other package managers as the dependency listed here. In this chapter, we will
    use npm to install the SignalR client package, as it is available through npm.
  prefs: []
  type: TYPE_NORMAL
- en: The immediate question that comes to mind is what is Node.js? Node.js is a platform
    built on Chrome's JavaScript runtime engine for easily building fast and scalable
    applications. It uses an event-driven, non-blocking, asynchronous I/O model, which
    makes it lightweight and efficient, perfect for data-intensive (and non-CPU-intensive)
    real-time applications. So, npm is the package manager for JavaScript. To use
    npm, we need to install Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties: Double-clicking on the Properties node of the project in Solution
    Explorer takes us to the project properties page and, on expanding this, displays
    the `launchSettings.json` file, where all the launch/startup-related configurations
    are serialized and saved as JSON. The following is the default code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s evident that the values in the preceding code match the Debug section
    of the properties page of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a4228fb-5479-4c48-931a-d2362c3a13f8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'wwwroot: All client-side packages and images are part of this folder. Files
    in this folder are served as static content and can be bundled and minified to
    reduce payloads and page rendering by using `bundleconfig.json`. A few of the
    common folders are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`css`: Contains cascading style sheets'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`images`: Contains the image assets that are needed in the app'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`js`: Contains JavaScript files'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lib`: Contains the client-side packages'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Controllers: Contains the controllers as per the Model-View-Controller (MVC)
    architecture.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Models: Contains the models as per the MVC architecture.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Views: Contains the views as per the MVC architecture.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`appsettings.json`: The application settings for the application. It contains
    the key and value-based settings in JSON format. If you are an old school ASP.NET
    web developer, you can think of it as the `appSettings` section defined inside
    `web.config`. The following is the sample configuration for `Logging`, which comes
    with the default template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`bower.json`: The Bower package manager is part of Visual Studio, as mentioned
    previously. This client-side package manager is one of the most widely-used package
    managers in the open source community for managing packages. `bower.json` is used
    by Bower to download and manage the client-side packages. This is very similar
    to the `packages.config` file that is used for managing NuGet packages. Just specify
    the package name that you want in the JSON file and Bower will do the rest. In
    case you do not see the packages, just right-click on the file in Solution Explorer
    and click Restore Packages. The following is the code snippet from `bower.json`,
    which lists the dependencies as `bootstrap`, `jquery`, and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In case you do not like this approach of adding the client-side dependency
    in the `bower.json` file, right-click on the `bower.json` file and click on Manage
    Bower Packages. This has a very similar user interface to the NuGet package manager
    and can be used in the same way. Just search the package and click Install. The
    following image shows the installed Bower packages in the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b642db67-7851-48a4-9db6-19bcdc9d58f4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`bundleconfig.json`: This JSON file used to store the project bundling and
    minification configuration for the static content of the site, that is, scripts
    and styles. The following is what the default MVC project template, `bundleconfig.json`,
    looks like. The names and comments are intuitive to understand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Bundling and minification are techniques to improve request load time:'
  prefs: []
  type: TYPE_NORMAL
- en: Bundling improves load time by reducing the number of requests sent to the server
    by the client to fetch static content; that is, CSS, JavaScript. Most major modern
    browsers limit the number of simultaneous connections for each hostname to six;
    that is to say, if six requests are being processed, any additional requests from
    the client for assets on the same hostname would be queued by the browser. With
    bundling, this issue is avoided, as all CSS files can be bundled as one file and,
    likewise, one file for JavaScript. This improves the first-time load performance.
    For subsequent requests, it's not much of an improvement, as the browser caches
    the files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minification improves performance by reducing the size of  the requested assets,
    that is, CSS and JavaScript, by removing unnecessary white spaces and comments,
    and  shortening the variable names to one character. We have all seen the `jquery.min.js`
    file while doing web development. The `min` in the name is to help the user identify
    that it is the minified version of the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Program.cs`: This is the main entry point to the ASP.NET Core 2.0 app. It
    has the minimum code needed to get the app up and running with the default configurations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, this looks more like a console application and, actually, that
    is what it is—a console app. In its entry point `Main` method, it creates a web
    server, hosts the application, and starts listening to HTTP requests. Notice here
    that `BuildWebHost` is a method which returns an object that implements `IWebHost`,
    accepting a string array argument. This method is implemented as an expression
    bodied member, just to make the developers aware that the sole purpose of this
    method is to build the web host and no other code should be put here. The method
    follows the builder pattern to build the host. There are several methods that
    we can hook up, one after another, as needed, and they would be added to the object
    incrementally, one after the other. The `CreateDefaultBuilder` method builds the
    web host with the default configuration wired up from various configuration providers
    (such as JSON and environment variables, to name a few), sets the logging configuration,
    and sets up a Kestrel web server with IIS integration, which is good enough for
    the app to run. The `Build` method builds the object and returns. Notice the `UseStartup<Startup>`
    method call, which actually specifies the `Startup` class for the app. We will
    discuss this class next.
  prefs: []
  type: TYPE_NORMAL
- en: The **Builder pattern** is an object creation design pattern. It is one of the
    23 well-known **Gang of Four** (**GoF**) design patterns. The intent behind this
    pattern is to separate the construction of a complex object from its representation,
    so that the same construction process can create different representations. To
    do so, this pattern builds a complex object using simple objects in a step-by-step
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: '`Startup.cs`: This is the class, where we define the request handling pipeline
    and configure the services needed by the application. Let''s look at the code
    and then discuss it in depth:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The key takeaways from the class code are:'
  prefs: []
  type: TYPE_NORMAL
- en: The class should be `public`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constructor has a dependency on `IConfiguration`, which is injected as the
    core service and assigned to the `public` property `Configuration` of type `IConfiguration`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This makes `Configuration` a first class citizen of the ASP.NET Core application
    and can be easily used to read the `appSettings` value just by using this code: `Configuration["<KeyName>"]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are only two public methods in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ConfigureServices`: This method is called by the runtime. This method is the
    place to add services to the container, such as MVC, antiforgery, application
    insight telemetry, authentication, authorization, localization, identity, and
    so on. There is a huge list of services available, which can be seen through IntelliSense.
    In the preceding code, we are c files, such as css, js, images, HTjust adding
    the MVC service, so that we can leverage all the MVC goodness in our app.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Configure`: As the comment in the code explains, this method is called by
    the runtime and is used to configure the HTTP request pipeline. In this method,
    we have access to the application builder and the hosting environment, which is
    another first class citizen of the .NET Core 2.0 app and is available in the container
    for injection into the objects that we construct. In the preceding code, which
    comes with the default MVC template, we can see the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: First, it checks whether the environment is for development or not. This is
    determined by the environment variable, `ASPNETCORE_ENVIRONMENT`. If its value
    is `Development`, it will detect the host environment to be `Development`; otherwise,
    it will be `Production`. If this environment variable is not available, it defaults
    the environment to `Production`. The variable can be set in the project properties
    page in the Debug section. The screenshot of the preceding properties section
    displays the Environment variable clearly.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the environment is `Development`, it tells the app to use the developer exception
    page by calling the `UseDeveloperExceptionPage()` method. The developer exception
    page gives a detailed error message with the exception stack trace to help the
    developer pinpoint the issue and resolve it. This should not be used in `Production`,
    as the exception information may be used by a hacker to attack your site. Also,
    your end user may not be a technical person, and may prefer to see a more user-friendly
    message than a .NET stack trace, so in production we use a custom error page,
    which is specified by calling the `UseExceptionHandler("/Home/Error");` method.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: During the development phase, you may want to test your web app against multiple
    browsers, and hence may want to open multiple browsers and browse the page to
    check for compatibility issues and refresh them when you make a fix. The `UseBrowserLink()` method
    helps you do just that. **Browser Link** is a feature in Visual Studio that creates
    a communication channel between the `Development` environment and one or more
    web browsers. We can use Browser Link to refresh the web application in several
    browsers at once.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Static files, such as `css`, `js`, `images`, HTML, and so on, which are placed
    in the `wwwroot` folder, are not servable by default. To make them servable, we
    need to call the `UseStaticFiles()` method.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the last piece of the code configures the MVC service (added in the `Configure`
    method) by specifying the default route.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To sum up, in this method we just configure the HTTP request pipeline using
    middleware. We will look at middleware in the next chapter, but for the time being,
    just think of them as HTTP modules in the earlier versions of ASP.NET. We added
    the services and then configured them as per our requirements using middleware.
    We will find three types of middleware configuration in the code samples:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`app.Run()`: The first `app.Run`  delegate terminates the HTTP request pipeline.
    If you use `Run`, it expects the handler and hence the request is served back
    to the client. No further middleware will be called in the request path.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.Map*`: This extension is used as a convention for branching the pipeline.
    `Map` branches the request pipeline based on matches of the given request path.
    If the request path starts with the given path, the branch is executed.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.Use[Middleware]`: `Use` can be used to chain the middleware; that is,
    we can arrange them to execute one after another. `Use` can also be used to short-circuit
    the request pipeline as needed.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If this sounds scary, don't worry! We will discuss middleware, dependency injection,
    and containers in detail in the next chapter while developing our Let's Chat application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, the `.csproj` file has major and long-anticipated enhancements.
    The `.xproj` from .NET Core 1.0 is now gone and we have our familiar `.csproj`
    back in business with ASP.NET Core 2.0\. It''s better than earlier, as it is lightweight
    and easier to manage. Visual Studio 2017 also has a tooling update, which enables
    us to edit the `.csproj` file without having to unload the project and edit. This
    is super awesome. Just right-click on the project in Solution Explorer and then
    click `Edit <Project Name>.csproj`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa59f1c0-179b-43b8-8c3e-521d18fdf703.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will have the `.csproj` file opened as an XML file in the code editor, with
    the entire project still loaded. The following is the `.csproj` file code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It's very lean, with just `TargetFramework`, which is `netcoreapp2.0`; `PackageReference`,
    which has just one metapackage, `Microsoft.AspNetCore.All`; and `DotNetCliToolReference`
    included as part of `ItemGroup`. This is much better than the conventional `.csproj`
    file, where we had different build configurations, property groups, all the projects,
    DLL, NuGet package references, and all the files and folders that need to be included
    in the project, making it really hard to manage.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our basic anatomy of an ASP.NET Core 2.0 app. Let's get started
    with our game development in ASP.NET Core 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Tic-Tac-Toe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tic-Tac-Toe is a simple two-player game, traditionally with its marks as *X*
    and *O*. Each player places his/her mark in a space and alternate turns in a 3×3
    grid. The player who succeeds in placing three of their marks in a horizontal,
    vertical, or diagonal row wins the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the pen and pencil game board looks like. In the following illustration,
    the player with the **X** marker is the winner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f525bff-8039-4463-aea2-65fbbb187873.png)'
  prefs: []
  type: TYPE_IMG
- en: Requirement specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will create a two-player Tic-Tac-Toe game with the following
    basic requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: As a player, I should be able to register with my name and display a picture
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a player, I should be able to find an opponent, that is, the second player
    to play against
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first two players to find opponents should be paired as opponents in the
    game
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The decision as to which player gets the chance to make the first move should
    be fair
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a player, I should be able to use my display picture as my mark, rather than
    the conventional *X* and *O*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The decision as to who wins should be made fairly
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In future, we want multiple players playing online simultaneously
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have the requirement specifications in place, let''s see the activity
    flow of the game and come up with a flowchart. The following is a rough flowchart
    of the game workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/284e8ca3-199a-4d6f-90ae-7fc433220db8.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Start**: This is the start of the flow. The player browses the game site
    URL. It is being conceptualized as a site, since in future we want to allow multiple
    players to play simultaneously online (requirement *Step 7*)*.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Register with name and display picture**: The player registers himself/herself
    with a name and display picture (requirement *Step 1*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Is Opponent available?:** The player finds an opponent to play against. If
    an opponent is found, the game can start with a toss; otherwise, the player needs
    to wait for the opponent (requirement *Steps 2* and* 3*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Wait for opponent**: There may be a scenario where the player is alone and
    registered with no one to play against, so the player needs to wait until another
    player registers and looks for an opponent (requirement *Steps 2* and *3*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Won toss?**: Once the players are paired as opponents, the game starts and
    one of the players gets the opportunity to make the first move. To keep this fair,
    we will have a toss. The player may either win the toss or lose the toss (requirement
    *Step 4*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Make a move/Wait for opponent to make a move**: The player winning the toss
    gets the first move, while their opponent would waits for the first player to
    make their move.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Do we have a winner?**: After every move, we check whether the win/draw criteria
    have been met and check whether we have a winner. If not, then the game continues
    with each player moving alternately until the game ends (requirement *Step 6*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Game Over**: Finally, the players will either run out of moves or a player
    will win the game.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we can see, the game will be played only in *Steps 6* and *7* of the flowchart.
    The other steps are required only for setting up the game. Also, notice that this
    flow covers all our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Looking at the preceding flow chart, which meets our requirements, we know
    we need to develop the following in the ASP.NET Core 2.0 application to constitute
    a basic two-player Tic-Tac-Toe game:'
  prefs: []
  type: TYPE_NORMAL
- en: A web page where players can go and register themselves with their name and
    display a picture
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A module to find an opponent to play against
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A module to simulate a coin toss to ensure fairness in giving players the option
    of making the first move
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The UI for the Tic-Tac-Toe game board in the web page, that is, a 3×3 grid where
    players can place their image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Logic to indicate to the player whether it's their turn or the opponent's turn
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A module to show the opponent and player the move that was made
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A mechanism to ensure that the player and opponent's board are in sync with
    their moves
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Logic to check whether the game is over
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Logic to determine the winner
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sounds simple enough! Let''s see how we can design and implement each of the
    preceding points by using ASP.NET Core 2.0 goodness:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web page for registration:** We have multiple options available to code this.
    We can either use a static HTML page, or a regular `.cshtml` view of MVC, or the
    new Razor Pages introduced by ASP.NET Core 2.0\. Since we will be working extensively
    with Razor Pages in the next chapter, we will use the `.cshtml` Razor view to
    create the UI of the game.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Opponent-finding module:** When a player registers, we can store his details
    somewhere on the server so the server knows how many players are registered to
    play. When a player finds an opponent, we can pair them as opponents based on
    their registration time. The problem with just relying on registered users, though,
    is when a player registers and closes the browser window knowingly or unknowingly,
    or decides not to play the game after registering. So, we need to ensure that
    we pair up only those players who are registered, are actively connected to the
    server, and are looking for an opponent to play the game with. If a player disconnects
    in the middle of the game, award the game to the opponent and inform them that
    the opponent has disconnected. We will need to do additional housekeeping to refresh
    the registered players in the server as new players join and existing players
    disconnect. To check whether a user is connected or not, we may need to perform
    additional housekeeping by writing additional code or making use of sessions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Simulate coin toss:** There are many ways to simulate a coin toss, such as
    generating a random number between two numbers and seeing whether it''s even or
    odd. In our case, to keep things simple, we will generate a random number, either
    `0` or `1`. If it''s `0`, it''s heads; otherwise, it''s tails.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**UI for game board:** As already discussed, we will be using the standard
    MVC Razor view to create the registration form as well as the Tic-Tac-Toe game
    board user interface. Designing the game board for Tic-Tac-Toe is rather simple
    with CSS; we just need to get the correct box style and arrange the boxes in a
    3×3 grid. To place the player''s image on the board, we pass the player image
    to each of the players and update the box background style to the image when the
    user clicks on that grid box. The challenge we can see here is how we will keep
    the game board of both the players in sync at any given time. Although the individual
    player and server know which player has a marker placed at which position, the
    opponent needs to have the same picture of the game board. This is something that
    the server needs to inform both players of after every turn.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Logic to indicate whose turn it is:** Although the server knows the toss
    result, it needs to inform one player to make a move and the other to wait for
    the other player to make a move. And after each turn, the server needs to inform
    both players (clients) about the turn, so the server has to push data to the clients
    after every move.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Module to show the players the move that was made:** Like the preceding point,
    it is again the server''s responsibility to update the players about the last
    move and ensure both players have a game board view after each move.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last two modules are straightforward. We need to check whether the game
    is over and we have a winner. The interesting part of our discussion is that in
    *Steps 2*, *4*, *5*, and *6*, we came across scenarios where the server needs
    to push data to the client. This is something that has already been made incredibly
    easy by the ASP.NET team who developed a library called SignalR. So, we will use
    SignalR to cover these scenarios. Before we dive into coding, let's understand
    what SignalR is, how it works, and how it saves us from writing all this stuff
    ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: SignalR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SignalR is a library for ASP.NET developers for developing real-time web experiences.
    In traditional web applications, the client makes requests and the server responds.
    With SignalR, we have the ability to push the content from the  server to the
    connected clients in real time. SignalR provides a simple API for creating server-to-client
    remote procedure calls that call JavaScript functions in client browsers (and
    other client platforms) from server-side .NET code. Anywhere in an application,
    if we need to refresh the browser for fresh data or have polling code wriiten
    to refresh the data, SignalR may be a good candidate for this. Some real-world
    applications of SignalR are chat applications where multiple users can chat, dashboards
    for monitoring, stock ticker applications that update a stock price as and when
    it changes, and multiplayer games. Basically, for any app that needs to display
    live data, SignalR makes it incredibly simple to broadcast a message to all clients,
    a group of clients, or a specific client as needed.
  prefs: []
  type: TYPE_NORMAL
- en: SignalR transport mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SignalR connects through WebSockets, Server-Sent Events, Forever Frames, and
    long polling. The following is a short description of each of these transport
    mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WebSockets**: WebSockets is an advanced computer communication protocol that
    enables you to open an interactive communication session between the user''s browser
    and a server with a lower overhead. With the advent of HTML5, WebSockets is supported
    by the latest version of all major browsers, such as Microsoft Edge, Microsoft
    Internet Explorer, Google Chrome, Firefox, Safari, and Opera. With WebSockets,
    we can send messages to a server and receive event-driven responses without having
    to poll the server for a reply. This is full-duplex communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server-Sent Eevents**: Server-Sent Events are a technology that enables web
    pages to receive automatic updates from the server through a HTTP connection.
    The server can initiate the data transmission toward a client after an initial
    connection has been established. This is not supported by the current version
    of Microsoft Edge and Microsoft Internet Explorer, but is available in Google
    Chrome, Mozilla Firefox, Safari, Opera, and others. This is simplex communication,
    as the server pushes the data to the client. This is part of the HTML5 specification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forever Frame**: Forever Frame is a Microsoft Internet Explorer concept and
    is not supported by any other browser. When a connection is established between
    a client web page and a server through Forever Frame, it creates a hidden IFrame
    in the client page. This IFrame makes a request to the server endpoint, which
    never completes; that is, it keeps the connection alive forever (hence the name,
    Forever Frame). Since the connection remains open, the server can use this connection
    to push scripts to the client, which are loaded and executed immediately in the
    client page, thus providing a real-time one-way communication from the server
    to the client. This is supported in old SignalR but removed from SignalR Core.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long polling**: Long polling is something that most web developers do in
    their regular web development without realizing it is actually long polling. Long
    polling does not create a persistent connection, but instead polls the server
    with a request that stays open until the server responds. This may introduce some
    latency while the connection resets. Long polling is basically an approach used
    for backward compatibility with old browsers and is definitely not a preferred
    method for client-server communication for the modern web.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SignalR Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SignalR Core is the complete rewrite of SignalR for ASP.NET Core 2.0 and, at
    the time of writing this chapter, is available as an alpha release for ASP.NET
    Core 2.0\. As per the road-map, it is scheduled to be released in the fourth quarter
    of 2017 and will be shipped with ASP.NET Core 2.1\. The current alpha release
    consists of a server component, .NET client, and JavaScript/TypeScript client.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using SignalR Core for our game development as it will take care
    of all the heavy duty stuff needed to push the content from the server to the
    client and let us concentrate on the problem at hand. With the ASP.NET Core 2.0
    and SignalR Core basics in place, and the design and approach finalized, let's
    get started with our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will develop the Tic-Tac-Toe game in the ASP.NET Core 2.0
    web app, using SignalR Core. We will follow a step-by-step approach and use Visual
    Studio 2017 as the primary IDE, but will list the steps needed while using the
    Visual Studio Code editor as well. Let's do the project setup first and then we
    will dive into the coding.
  prefs: []
  type: TYPE_NORMAL
- en: Project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new ASP.NET Core 2.0 MVC app named `TicTacToeGame`, like we did in
    the *Creating a simple running code* section in [Chapter 1](ch01.html), *Getting
    Started*.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we will have a basic working ASP.NET Core 2.0 MVC app in place. However,
    to leverage SignalR Core in our app, we need to install SignalR Core NuGet and
    the client packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the SignalR Core NuGet package, we can perform one of the following
    two approaches in the Visual Studio IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context menu of the `TicTacToeGame` project, click on Manage NuGet Packages.
    It will open the NuGet Package Manager for the project. In the Browse section,
    search for the `Microsoft.AspNetCore.SignalR` package and click Install. This
    will install SignalR Core in the app. Please note that currently the package is
    in the preview stage and hence the pre-release checkbox has to be ticked:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/6a1ddd74-b570-4f6f-a64d-14735f0b2743.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Edit the `TicTacToeGame.csproj` file, add the following code snippet in the
    `ItemGroup` code containing package references, and click Save. As soon as the
    file is saved, the tooling will take care of restoring the packages and in a while,
    the SignalR package will be installed. This approach can be used with Visual Studio
    Code as well. Although Visual Studio Code detects the unresolved dependencies
    and may prompt you to restore the package, it is recommended that immediately
    after editing and saving the file, you run the `dotnet restore` command in the
    terminal window at the location of the project:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now we have server-side packages installed. We still need to install the client-side
    package of SignalR, which is available through npm. To do so, we need to first
    ascertain whether we have npm installed on the machine or not. If not, we need
    to install it. npm is distributed with Node.js, so we need to download and install
    Node.js from [https://nodejs.org/en/](https://nodejs.org/en/). The installation
    is quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this installation is done, open a Command Prompt at the project location
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will install the SignalR client package. Just go to the package location
    (npm creates a `node_modules` folder in the project directory). The relative path
    from the project directory would be `\node_modules\@aspnet\signalr-client\dist\browser`.
  prefs: []
  type: TYPE_NORMAL
- en: From this location, copy the `signalr-client-1.0.0-alpha1-final.js` file into
    the `wwwroot\js` folder. In the current version, the name is `signalr-client-1.0.0-alpha1-final.js`.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we are done with the project setup and we are ready to use SignalR
    goodness as well. So let's dive into the coding.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will implement our gaming solution. The end output will
    be the working two-player Tic-Tac-Toe game. We will do the coding in steps for
    ease of understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Startup` class, we modify the `ConfigureServices` method to add SignalR
    to the container, by writing the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Configure` method of the same class, we configure the pipeline to use
    SignalR and intercept and wire up the request containing `gameHub` to our SignalR
    hub that we will be creating with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code for both methods, for the sake of clarity and completion.
    Other methods and properties are removed for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous two steps set up SignalR for us. Now, let''s start with the coding
    of the player registration form. We want the player to be registered with a name
    and display the picture. Later, the server will also need to know whether the
    player is playing, waiting for a move, searching for an opponent, and so on. Let''s
    create the `Player` model in the `Models` folder in the app. The code comments
    are self-explanatory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to have a UI in place so that the player can fill in the form
    and register. We also need to show the image preview to the player when he/she
    browses the image. To do so, we will use the `Index.cshtml` view of the `HomeController` class
    that comes with the default MVC template. We will refer to the following two `.js`
    files in the `_Layout.cshtml` partial view so that they are available to all the
    views. Alternatively, you could add these in the `Index.cshtml` view as well,
    but its highly recommended that common scripts should be added in `_Layout.cshtml`.
    The version of the script file may be different in your case. These are the currently
    available latest versions. Although jQuery is not required to be the library of
    choice for us, we will use jQuery to keep the code clean, simple, and compact.
    With these references, we have jQuery and SignalR available to us on the client
    side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding these references, create the simple HTML UI for the image preview
    and registration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When the player registers by clicking the `Register` button, the player''s
    details need to be sent to the server. To do this, we will write the JavaScript
    to send details to our `gameHub`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The player now has a UI to input the name and image, see the preview image,
    and click `Register`. On clicking the `Register` button, we are sending the concatenated
    name and image to the `gameHub` on the server through `hubConnection.invoke(''RegisterPlayer'',
    data);`  So, it''s quite simple for the client to make a call to the server. Initialize
    the `hubConnection` by specifying hub name as we did in the first three lines
    of the preceding code snippet. Start the connection by `hubConnection.start();`,
    and then invoke the server hub method by calling the `invoke` method, specifying
    the hub method name and the parameter it expects. We have not yet created the
    hub, so let''s create the `GameHub` class on the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The code comments make it self-explanatory. The class should derive from the
    SignalR `Hub` class for it to be recognized as `Hub.`
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two methods of interest which can be overridden. Notice that both
    the methods follow the async pattern and hence return `Task`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Task OnConnectedAsync()`: This method fires when a client/player connects
    to the hub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task OnDisconnectedAsync(Exception exception)`: This method fires when a client/player
    disconnects or looses the connection. We will override this method to handle the
    scenario where the player disconnects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also a few properties that the hub class exposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Context`: This property is of type `HubCallerContext` and gives us access
    to the following properties:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Connection`: Gives access to the current connection'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`User`: Gives access to the `ClaimsPrincipal` of the user who is currently
    connected'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConnectionId`: Gives the current connection ID string'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clients`: This property is of type `IHubClients` and gives us the way to communicate
    to all the clients via the client proxy'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Groups`: This property is of type `IGroupManager` and provides a way to add
    and remove connections to the group asynchronously'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To keep the things simple, we are not using a database to keep track of our
    registered players. Rather we will use an in-memory collection to keep the registered
    players. We could have used a normal list of players, such as `List<Player>`,
    but then we would need all the thread safety and use one of the thread safety
    primitives, such as `lock`, `monitor`, and so on, so we are going with `ConcurrentBag<Player>`,
    which is thread safe and reasonable for our game development. That explains the
    declaration of the players collection in the class. We will need to do some housekeeping
    to add players to this collection when they resister and remove them when they
    disconnect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw in previous step that the client invoked the `RegisterPlayer` method
    of the hub on the server, passing in the name and image data. So we defined a
    `public` method in our hub, named `RegisterPlayer,` accepting the name and image
    data string concatenated through `#`. This is just one of the simple ways of accepting
    the client data for demonstration purposes, we can also use strongly typed parameters.
    In this method, we split the string on `#` and extract the name as the first part
    and the image as the second part. We then check if the player with the current
    connection ID already exists in our players collection. If it doesn''t, we create
    a `Player` object with default values and add them to our players collection.
    We are distinguishing the player based on the name for demonstration purposes,
    but we can add an `Id` property in the `Player` class and make different players
    have the same name also. After the registration is complete, the server needs
    to update the player, that the registration is complete and the player can then
    look for the opponent. To do so, we make a call to the `OnRegistrationComplete`
    method which invokes a method called  `registrationComplete` on the client with
    the current connection ID. Let''s understand the code to invoke the method on
    the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: On the `Clients` property, we can choose a client having a specific connection
    ID (in this case, the current connection ID from the `Context`) and then call
    `InvokeAsync` to invoke a method on the client specifying the method name and
    parameters as required. In the preceding case method, the name is `registrationComplete`
    with no parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know how to invoke a server method from the client and also how to invoke
    the client method from the server. We also know how to select a specific client
    and invoke a method there. We can invoke the client method from the server, for
    all the clients, a group of clients, or a specific client, so rest of the coding
    stuff would be just a repetition of these two concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to implement the `registrationComplete` method on the client.
    On registration completion, the registration form should be hidden and the player
    should be able to find an opponent to play against. To do so, we would write JavaScript
    code to hide the registration form and show the UI for finding the opponent. On
    clicking the `Find Opponent` button, we need the server to pair us against an
    opponent, so we need to invoke a hub method on server to find opponent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The server can respond us with two outcomes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It finds an opponent player to play against. In this case, the game can start
    so we need to simulate the coin toss, determine the player who can make the first
    move, and start the game. This would be a game board in the client-user interface.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't find an opponent and asks the player to wait for another player to
    register and search for an opponent. This would be a no opponent found screen
    in the client.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In both the cases, the server would do some processing and invoke a method
    on the client. Since we need a lot of different user interfaces for different
    scenarios, let''s code the HTML markup inside `div` to make it easier to show
    and hide sections based on the server response. We will add the following code
    snippet in the body. The comments specify the purpose of each of the `div` elements
    and markup inside them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following client-side code would take care of *Steps 7* and *8*. Though
    the comments are self-explanatory, we will quickly see what all stuff is that
    is going on here. We handle the `registartionComplete` method and display the
    `Find Opponent Player` section. This section has a button to find an opponent
    player called `btnFindOpponentPlayer`. We define the event handler of the button
    to invoke the `FindOpponent` method on the hub. We will see the hub method implementation
    later, but we know that the hub method would either find an opponent or would
    not find an opponent, so we have defined the methods `opponentFound` and `opponentNotFound`,
    respectively, to handle these scenarios. In the `opponentNotFound` method, we
    just display a section in which we say, we do not have an opponent player. In
    the `opponentFound` method, we display the game section, game information section,
    opponent display picture section, and draw the Tic-Tac-Toe game board as a 3×3
    grid using CSS styling. All the other sections are hidden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'First we need to have a `Game` object to track a game, players involved, moves
    left, and check if there is a winner. We will have a `Game` class defined as per
    the following code. The comments detail the purpose of the methods and the properties
    defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the entire game mystery solved with the `Game` class. We know when
    the game is over, we have the method to place the player marker, and check the
    winner. The following server side-code on the `GameHub` will handle *Steps 7*
    and *8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have created a games collection to keep track of ongoing games and
    a `Random` field named toss to simulate the coin toss. How `FindOpponent` works
    is documented in the comments and is intuitive to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the game starts, each player has to make a move and then wait for the
    opponent to make a move, until the game ends. The move is made by clicking on
    the available grid cells. Here, we need to ensure that cell position that is already
    marked by one of the players is not changed or marked. So, as soon as a valid
    cell is marked, we set its CSS class to `notAvailable` so we know that the cell
    is taken. While clicking on a cell, we will check whether the cell has `notAvailablestyle`.
    If yes, it cannot be marked. If not, the cell can be marked and we then send the
    marked position to the server hub. We also see the `waitingForMove`, `moveMade`,
    `gameOver`, and `opponentDisconnected` events invoked by the server based on the
    game state. The code is commented and is pretty straightforward. The `moveMade`
    method in the following code makes use of the `MoveInformation` class, which we
    will define at the server for sharing move information with both players:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After every move, both players need to be updated by the server about the move
    made, so that both players'' game boards are in sync. So, on the server side we
    will need an additional model called `MoveInformation`, which will contain information
    on the latest move made by the player and the server will send this model to both
    the clients to keep them in sync:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will wire up the remaining methods in the `GameHub` class to complete
    the game coding. The `MakeAMove` method is called every time a player makes a
    move. Also, we have overidden the `OnDisconnectedAsync` method to inform a player
    when their opponent disconnects. In this method, we also keep our players and
    games list current. The comments in the code explain the workings of the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: With this, we are done with the coding of the game and are ready to run the
    game app. The detailed source code can be downloaded from [https://github.com/PacktPublishing/.NET-Core-2.0-By-Example](https://github.com/PacktPublishing/.NET-Core-2.0-By-Example).
  prefs: []
  type: TYPE_NORMAL
- en: Game demo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our app is ready, let's run it and enjoy the game. Press *F5* and the
    game should be launched in the browser. This will work for both Visual Studio
    2017 IDE and Visual Studio Code. Also, since we are running it in our local machine,
    both players will need to play it on the same machine for the time being. Once
    we deploy this game in Azure, players can browse the URL from their individual
    machines. We will see how we can publish an ASP.NET Core 2.0 app to Azure in a
    later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the game registration UI looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d7d77f3-fd57-4fac-ba66-85266a267634.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On clicking Register, the find opponent screen is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbb06037-597d-465c-a00c-ce70a3f9cb89.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On clicking the Find Opponent Player button, if a registered player exists,
    the game starts and this is what the two-player game looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2383980-13ac-4ca6-ad52-33186d658fc5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If a player is not available, or you are the lone warrior registered to play,
    the following screen will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/666153c2-cb46-449e-a440-9f2decb04729.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have developed a fully functional two-player Tic-Tac-Toe game, meeting all
    the requirement specifications. It's time to enjoy your very first ASP.NET Core
    2.0 game powered by SignalR Core!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the project structure of a typical ASP.NET
    Core 2.0 app and understood the importance and purpose of each and every file
    that comes with the default MVC template. We also learned about SignalR and SignalR
    Core, and developed our very first game, Tic-Tac-Toe, on ASP.NET Core 2.0 based
    on the given requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will deep dive into learning and coding the features
    of ASP.NET Core 2.0 while developing a real-time chat application for multiple
    clients called Let's Chat.
  prefs: []
  type: TYPE_NORMAL
