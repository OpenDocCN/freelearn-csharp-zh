- en: Chapter 11. The Asynchronous Programming Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be learning about the new `async` and `await` keywords
    provided in .NET 4.5, along with the **Asynchronous Programming Model** (**APM**).
    The `async` and `await` keywords are .NET's latest method for making asynchronous
    and multithreaded programming simple for the developer. These new keywords make
    using the `BackgroundWorker` component harder to justify. The `async` keyword
    makes it seamless to turn an ordinary method into an asynchronous method that
    runs on a separate thread. Then you can continue processing in the main thread.
    When you are ready to wait for the results of the asynchronous method, you can
    then use the `await` keyword in your main thread to block until the method returns.
  prefs: []
  type: TYPE_NORMAL
- en: The Asynchronous Programming Model uses the `IAsyncResult` interface to accomplish
    the same type of design. In this design pattern, you create a delegate and then
    use the `BeginInvoke` and `EndInvoke` methods of the delegate to start the method
    and wait on it to complete. You can also use the `IAsyncResult` interface that
    is returned by the `BeginInvoke` method to poll to see if the asynchronous method
    has completed, or set a `wait` handle for the asynchronous method to complete.
  prefs: []
  type: TYPE_NORMAL
- en: These two methods give us easy ways to implement functionality similar to the
    `BackgroundWorker` component that is used so heavily in Windows Forms applications
    and earlier versions of .NET. This functionality is especially useful in desktop
    applications when we do not want the main thread of the application to block.
    There are few things worse in desktop application design than having a user click
    on a button and the whole user interface freezes while some function is being
    performed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at the Asynchronous Programming Model and how to use
    this design pattern to run a method in a thread separate from the main thread.
    Then we will have the main thread wait on its results.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Asynchronous Programming Model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an `AsyncCallback` delegate method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `async` and `await` keywords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the Asynchronous Programming Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Asynchronous Programming Model is used by .NET classes to implement asynchronous
    designs. One example is the `BeginRead` and `EndRead` methods of `FileStream`.
    This allows the `FileStream` class to implement an asynchronous file read. The
    `StreamReader` and `StreamWriter` classes also have asynchronous methods. They
    implement this functionality using the `IAsyncResult` interface. In your customer
    classes, you can also implement this interface to allow you to have asynchronous
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The naming convention when using this interface is to prefix your method names
    with `Begin` and `End`. So, you would name one `BeginMyMethod` and the other `EndMyMethod`.
    The first method is the one you execute asynchronously. The second method is what
    you call to block your main thread when you want to wait on the `Begin` method
    to end and have it also return the results.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at an example using the `BeginRead` and `EndRead` methods of
    the `FileStream` class. This same technique can be implemented using your own
    classes and implementing the `IAsyncResult` interface. You do not have to prefix
    your method names with `Begin` and `End`, but it is a good programming practice
    to follow the naming convention so that future developers using your classes will
    intuitively understand how they operate.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s open up Visual Studio and create a new console project called
    `FileReadAsync`. Then, let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two `using` statements for the `IO` and `Threading` classes, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s add the following code to the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, finally, we need to add a file called `InputData.txt` to `C:\projects`.
    This will be the file that we read asynchronously. It can contain any text that
    you would like; for our example, the `InputData.txt` file looks like the following
    screenshot:![How to do it](img/8321EN_11_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s build and run our application. You should see a screen like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The program is waiting on the user to click on the return button; once the
    button is clicked, it will execute the asynchronous read of the data file. Once
    you click on return, you should see the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you click return again, the application will finish and exit. So, let's look
    at how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a very simple example of an existing .NET class, `FileStream`, that
    implements the Asynchronous Programming Model with the two methods, `BeginRead`
    and `EndRead`. If you look at the method definition for the `BeginRead` method,
    you will see that it implements the `IAsyncResult` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also view the method definition for the `EndRead` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at your example project. In the following lines of code, we
    set up the `FileStream` object called `FS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here we are declaring a new `FileStream` object with parameters that define
    the file to stream, the mode to open, the access to read, and the option to read
    asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we initiate the read operation asynchronously with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We then do some other work while the read operation is happening asynchronously
    on another thread. This "other" work is represented by the following three `Console.WriteLine`
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we block the main thread and wait on the `async` write to complete using
    this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This statement will complete when the read is complete and return the `IAsyncResult`
    object and the number of bytes read. We then write these results to the console
    using the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We examine the `IsCompleted` method of `IAsyncResult` to make sure the read
    has completed even though we know it has because we blocked waiting on the `EndRead`
    method. We did this to preview another design pattern for the Asynchronous Programming
    Model, which we will not demonstrate in this chapter—the polling method. Instead
    of calling the `EndRead` method to block the main thread waiting on the `Main`
    method to complete, we can create a loop and periodically check the `IsCompleted`
    property of the `IAsyncResult` object returned by the `BeginRead` method. This
    is handy if we want to show a progress update throughout the read operation.
  prefs: []
  type: TYPE_NORMAL
- en: A third way to implement the Asynchronous Programming Model involves using a
    delegate method for processing when the read operation has completed.
  prefs: []
  type: TYPE_NORMAL
- en: Using an AsyncCallback delegate method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how we can use the APM design pattern that is implemented in the
    `FileStream` class to perform an asynchronous read and then wait on the results.
    We also mentioned how we can poll to see if the asynchronous read has completed
    instead of blocking the main thread. Now, we will see how we can execute a delegate
    method when the asynchronous read has completed.
  prefs: []
  type: TYPE_NORMAL
- en: Using this method, we do not have to block the main thread waiting or perform
    the work of polling the `IsCompleted` property to see when the read has completed.
    We simply execute the `BeginRead` method and pass it a delegate method. We then
    go on our way and, when the read completes, the delegate method will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the method header for the `BeginRead` method of the `FileStream`
    class. The following is the method definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You will see that the fourth parameter passed to this method is an `AsyncCallback`
    delegate. In our previous example, we passed a null value for this parameter when
    we called this method. This time let's use a delegate method.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s open Visual Studio and create a new console application called `FileReadAsyncWithDelegate`.
    Once this has been created, we will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two `using` statements for the `IO` and `Threading` classes, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s add the following code to the `Main` method of our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before the `Main` method, we need to declare a static byte array so that it
    is available to both the `Main` method and our new delegate method. Add the following
    statement before the `Main` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to add our delegate method. Add the following code for our delegate
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That is all the code we will need for this example. We do still need our `InputData.txt`
    file in `C:\projects`. It should still be there from when we created it in the
    last exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, build and run the application and you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then press return and the application should display the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will see that the results look almost identical to the results from the
    previous exercise. This is true. But how we achieve them is very different. This
    time, instead of blocking the main thread that is waiting on the read to complete,
    we initiated a delegate method on a separate thread and waited there for the read
    to complete and then display the results. Let's look at how we did it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s look at our `Main` method. This time it is more streamlined and
    does less work. It essentially just creates the `FileStream` object and calls
    the `BeginRead` method and passes it a delegate method. That is it. Then it goes
    about its business. It does not wait on the read to complete, does not process
    the results, and does not close the `FileStream` object. The following code shows
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The key here is the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, instead of the fourth and fifth parameters being `null`, we pass a delegate
    method and the `FileStream` object to this method. This allows the `Main` method
    to then go about its business.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at where the work is now being done—the delegate method, `ReadComplete`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first thing you will notice is that the `AsyncCallback` delegate definition
    requires a method that returns no value and receives an `IAsyncResult` parameter
    as input.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then get the `FileStream` object state using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we wait on the read to complete and get the results using this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we process the results using these statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'That is all there is to it. We have spent the last two sections of this chapter
    looking at three ways to implement the APM:'
  prefs: []
  type: TYPE_NORMAL
- en: Call the `Begin` method name, perform some action, and then block using the
    `End` method name until the asynchronous action is finished
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the `Begin` method name, continue processing, and periodically check the
    `IsCompleted` property of the `IAsyncResult` object to know when the asynchronous
    operation is completed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the `Begin` method name to initiate the asynchronous operation and then
    implement a delegate method on a separate thread to wait on the asynchronous operation
    and process the results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the rest of the chapter, we will explore the new `async` and `await` keywords
    that were introduced in .NET Version 4.5.1.
  prefs: []
  type: TYPE_NORMAL
- en: The async and await keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In .NET 4.5, Microsoft introduced the `async` and `await` keywords that made
    it very easy for developers to implement asynchronous functionality in their methods.
    Adding the `async` keyword to the method header tells .NET''s CLR to run this
    method in a separate thread in the threadpool if it determines that the following
    two conditions are met: first, that running it in a separate thread will increase
    performance, and second, the `await` keyword is used in the method. An `async`
    method will either return void, `Task`, or `Task<TResult>`. Also, the naming convention
    is to postfix any methods that use the `async` keyword with `Async`. So, the method
    name should be `MyMethodAsync`. That is all there is to it. The implementation
    is similar to the APM but does not use the `IAsyncResult` interface or implement
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: The design pattern for using this method is for your program to run a method
    that uses the `async` keyword by running it in a separate task. It is then free
    to continue on. If the `async` method does not have a return value, then the main
    thread can just continue on. If there is a return value that the `Main` method
    cares about or wants to know when the asynchronous operation has completed, it
    can wait on the asynchronous task to complete and view the results. In the asynchronous
    task, the method will perform functions on its own thread and then call the `await`
    keyword when it wants to wait on some action to complete.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the use of these two new keywords, we will rewrite our previous
    application to read a file asynchronously using the `async` and `await` keywords.
    Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s open Visual Studio and create a new console application called
    `FileReadUsingAsync`. Once we have this project created, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two `using` statements for the `IO` and `Threading` classes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s add the following statements to the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create the `ProcessFileAsync` method that will run inside the
    task we created in the `Main` method. This method will implement the `async` keyword
    and run asynchronously. Add the following code to create this method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, this method will call another `async` method that will actually open the
    file and read the contents. This method, `ReadFileAsync`, will have the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That is all there is to it. Let''s build our application and run it. We should
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, the application is waiting for us, so we need to press return.
    Then we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we have initiated the asynchronous reading of the file, performed some
    other work, and are waiting on the file reading to complete. Once it has completed,
    we should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we press return again we will see the results of the read operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, if we press return one last time, the application will finish and exit.
    So, how did this all work?
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s examine how this program works. First, take a look at the `Main`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple method that creates a new task that executes an `async` method
    called `ProcessFileAsync`. It then starts the task and waits for it to finish.
    That is all. So, the `Main` method just spawns a task to do the work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `async` method `ProcessFileAsync` is executed in a separate thread
    from the `Main` method. This is shown by displaying the thread ID number. You
    will notice from the console output that the `Main` thread ID is different from
    the thread ID of the task running the `ProcessFileAsync` method. Let''s examine
    this method. The following is the code for us to dissect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This method''s main objective is to run the `async` method, `ReadFileAsync`.
    This is done with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We then await this task with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding statement tells the method to start an `async` task and then wait
    on it to complete. Since the method it is calling has a return value of `Task<String>`,
    the `await task` statement returns a string value. The `ReadFileAsync` method
    takes a filename as the input and then returns a string that contains the contents
    of the file as a string. This method reads the file asynchronously on a separate
    thread from the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'The heart of the work is done in the `ReadFileAsync` method. Let''s look at
    this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use the `async` keyword to designate this as an asynchronous method.
    This method creates a `FileStream` for the filename passed in and then calls the
    `StreamReader.ReadToEndAsync` method to asynchronously read the file. It uses
    the `await` keyword in this statement to signal .NET that this is an asynchronous
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'By putting in the `wait` statement to slow down the processing a little, you
    can see the delay in execution between the following write statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This allows you to see that the main thread is available while the file is being
    read on a separate thread.
  prefs: []
  type: TYPE_NORMAL
- en: Another point to note is that by using the `async`/`await` programming method
    or the APM design pattern, we do not have to deal with the underlying code of
    starting, stopping, and managing threads. This is handled for us by .NET. We just
    have to write the logic and use the appropriate design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: This is a generic way to easily implement any asynchronous operation that can
    benefit an application's performance without having to design the entire application
    for parallelism or concurrency like we did with the producer-consumer or Pipelining
    design patterns. We can simply code a single task to run asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned two very important ways to make a particular
    piece of functionality in an application run asynchronously from the main thread
    of the application. These two ways are the Application Programming Model and the
    `async`/`await` keywords. These two design techniques allow you to take advantage
    of the asynchronous execution of a task without designing an application around
    concurrency. This is especially useful for long-running tasks or tasks that access
    outside resources. In this way, we do not tie up the main thread of an application
    while we are waiting for something like a file read, an HTTP GET request, or a
    database read. These are all tasks whose duration is outside our control and not
    predictable. It therefore makes sense to perform these kinds of functions asynchronously
    so that our application's main thread can continue running.
  prefs: []
  type: TYPE_NORMAL
- en: These techniques are very useful when we do not have enough concurrent functionality
    to design a complete parallel application but have a particular task that can
    take a long time. These two methods are used in much the way the `BackgroundWorker`
    component is used and continues to make it obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: The Application Programming Model is a design technique used when you create
    a class. You can create two methods and name them `BeginMethodName` and `EndMethodName`
    that implement the `IAsyncResult` interface. Then you can use them to start an
    asynchronous operation and, if needed, block the main thread waiting on the asynchronous
    operation to complete. This technique is used in many .NET classes such as the
    `FileStream`, `StreamReader`, and `StreamWriter`. But it can also be used by you
    when designing your classes.
  prefs: []
  type: TYPE_NORMAL
- en: The `async` and `await` keywords are a simple way to designate in a method's
    signature that it is meant to be performed as an asynchronous operation. The `async`
    keyword designates the method as an asynchronous method and the `await` keyword
    is used within the method to wait on a statement to complete before its method
    completes. This technique can be implemented within a class or as static methods
    within an application or helper class. These two techniques give the .NET developer
    two more tools in their toolbox to implement concurrent functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we have explored many ways to implement concurrent and
    asynchronous functionality in .NET. This includes techniques that have been around
    from .NET 1.0 to techniques introduced in the latest .NET 4.5\. They range from
    simple asynchronous methods that do not allow blocking a main UI thread to objects
    for designing complete concurrent applications, to objects for processing sets
    of data concurrently. There are many ways and techniques to perform multithreaded
    functionality in .NET depending on the requirements of your specific application
    or task.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know all of what .NET has to offer, never waste an opportunity
    in your development to maximize the use of your computing hardware or its responsiveness
    by sticking to a single-threaded approach.
  prefs: []
  type: TYPE_NORMAL
