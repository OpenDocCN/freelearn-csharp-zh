- en: Chapter 3. Code Sharing between iOS and Android
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章. iOS 和 Android 之间的代码共享
- en: Xamarin's tools promise to share a good portion of your code between iOS and
    Android while taking advantage of the native APIs on each platform where possible.
    Doing so is an exercise in software engineering more than a programming skill
    or having the knowledge of each platform. To architect a Xamarin application to
    enable code sharing, it is a must to separate your application into distinct layers.
    We'll cover the basics of this in this chapter as well as specific options to
    consider in certain situations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin 的工具承诺在尽可能利用每个平台的本地 API 的同时，在 iOS 和 Android 之间共享大量代码。这样做更多的是一项软件工程练习，而不是编程技能或对每个平台的知识。为了构建一个支持代码共享的
    Xamarin 应用程序，必须将应用程序分成不同的层。在本章中，我们将介绍这一基本概念，以及在特定情况下需要考虑的特定选项。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: The MVVM design pattern for code sharing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM 设计模式用于代码共享
- en: Project and solution organization strategies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目和解决方案组织策略
- en: Portable Class Libraries (PCLs)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可移植类库 (PCLs)
- en: Preprocessor statements for platform-specific code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台特定代码的预处理器语句
- en: Dependency injection (DI) simplified
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入 (DI) 简化版
- en: Inversion of Control (IoC)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制反转 (IoC)
- en: Learning the MVVM design pattern
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 MVVM 设计模式
- en: The **Model-View-ViewModel** (**MVVM**) design pattern was originally invented
    for **Windows Presentation Foundation** (**WPF**) applications using **XAML**
    for separating the UI from business logic and taking full advantage of **data
    binding**. Applications architected in this way have a distinct ViewModel layer
    that has no dependencies on its user interface. This architecture in itself is
    optimized for unit testing as well as cross-platform development. Since an application's
    ViewModel classes have no dependencies on the UI layer, you can easily swap an
    iOS user interface for an Android one and write tests against the ViewModellayer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-视图模型**（**MVVM**）设计模式最初是为使用 **XAML** 将 UI 与业务逻辑分离并充分利用 **数据绑定** 的 **Windows
    Presentation Foundation**（**WPF**）应用程序发明的。以这种方式构建的应用程序具有一个独立的 ViewModel 层，该层不依赖于其用户界面。这种架构本身优化了单元测试以及跨平台开发。由于应用程序的
    ViewModel 类不依赖于 UI 层，因此可以轻松地将 iOS 用户界面替换为 Android 用户界面，并对 ViewModel 层进行测试。'
- en: The MVVM design pattern is also very similar to the MVC design pattern discussed
    in the previous chapters.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 设计模式与之前章节中讨论的 MVC 设计模式也非常相似。
- en: 'The MVVM design pattern includes the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 设计模式包括以下内容：
- en: '**Model**: The Model layer is the backend business logic that drives the application
    and any business objects to go along with it. This can be anything from making
    web requests to a server to using a backend database.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：模型层是驱动应用程序及其相关业务对象的底层业务逻辑。这可以是从服务器发送网络请求到使用后端数据库的任何操作。'
- en: '**View**: This layer is the actual user interface seen on the screen. In the
    case of cross-platform development, it includes any platform-specific code for
    driving the user interface of the application. On iOS, this includes controllers
    used throughout an application, and on Android, an application''s activities.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这一层是屏幕上实际看到的用户界面。在跨平台开发的情况下，它包括驱动应用程序用户界面的任何平台特定代码。在 iOS 上，这包括应用程序中使用的控制器，在
    Android 上，则是应用程序的活动。'
- en: '**ViewModel**: This layer acts as the glue in MVVM applications. The ViewModel
    layerscoordinate operations between the View and Model layers. A ViewModel layer
    will contain properties that the View will get or set, and functions for each
    operation that can be made by the user on each View. The ViewModel layer will
    also invoke operations on the Model layer if needed.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图模型**：这一层在 MVVM 应用程序中充当粘合剂。ViewModel 层协调视图和模型层之间的操作。ViewModel 层将包含视图将获取或设置的属性，以及用户可以对每个视图执行的操作的函数。如果需要，ViewModel
    层还将调用模型层的操作。'
- en: 'The following figure shows you the MVVM design pattern:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 MVVM 设计模式：
- en: '![Learning the MVVM design pattern](img/00024.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![学习 MVVM 设计模式](img/00024.jpeg)'
- en: It is important to note that the interaction between the View and ViewModel
    layers is traditionally created by data binding with WPF. However, iOS and Android
    do not have built-in data binding mechanisms, so our general approach throughout
    the book will be to manually call the ViewModel layer from the View layer. There
    are a few frameworks out there that provide data binding functionality such as
    **MVVMCross** (not covered in this book) and **Xamarin.Forms**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，传统上，视图和视图模型层之间的交互是通过WPF的数据绑定创建的。然而，iOS和Android没有内置的数据绑定机制，所以本书中的一般方法将是手动从视图层调用视图模型层。有一些框架提供了数据绑定功能，例如**MVVMCross**（本书未涉及）和**Xamarin.Forms**。
- en: Implementing MVVM in an example
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在示例中实现MVVM
- en: To understand this pattern better, let's implement a common scenario. Let's
    say we have a search box on the screen and a search button. When the user enters
    some text and clicks on the button, a list of products and prices will be displayed
    to the user. In our example, we use the **async** and **await** keywords that
    are available in C# 5 to simplify asynchronous programming.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个模式，让我们实现一个常见的场景。假设我们在屏幕上有一个搜索框和一个搜索按钮。当用户输入一些文本并点击按钮时，将向用户显示产品列表和价格。在我们的示例中，我们使用了C#
    5中可用的**async**和**await**关键字来简化异步编程。
- en: 'To implement this feature, we will start with a simple `model` class (also
    called a **business object**) as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个功能，我们将从一个简单的`model`类（也称为**业务对象**）开始，如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we will implement our Model layer to retrieve products based on the searched
    term. This is where the business logic is performed, expressing how the search
    needs to actually work. This is seen in the following lines of code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现我们的模型层，根据搜索词检索产品。这是执行业务逻辑的地方，表示搜索实际上应该如何工作。这体现在以下代码行中：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is important to note here that the `Product` and `ProductRepository` classes
    are both considered as a part of the Model layer of a cross-platform application.
    Some might consider `ProductRepository` as a **service** that is generally a self-contained
    class to retrieve data. It is a good idea to separate this functionality into
    two classes. The `Product` class's job is to hold information about a product,
    while the `ProductRepository` class is in charge of retrieving products. This
    is the basis for the **single responsibility principle**, which states that each
    class should only have one job or concern.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，`Product`和`ProductRepository`类都被视为跨平台应用程序模型层的一部分。有些人可能会将`ProductRepository`视为一个**服务**，它通常是一个自包含的类，用于检索数据。将这个功能分离成两个类是一个好主意。`Product`类的任务是保存有关产品的信息，而`ProductRepository`类负责检索产品。这是**单一职责原则**的基础，该原则指出每个类应该只做一项工作或关注一个方面。
- en: 'Next, we will implement a `ViewModel` class as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现一个`ViewModel`类，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From here, your platform-specific code starts. Each platform will handle managing
    an instance of a `ViewModel` class, setting the `SearchTerm` property, and calling
    `Search` when the button is clicked. When the task completes, the user interface
    layer will update a list displayed on the screen.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，你的平台特定代码开始了。每个平台将处理管理`ViewModel`类的实例，设置`SearchTerm`属性，并在按钮点击时调用`Search`。当任务完成时，用户界面层将更新屏幕上显示的列表。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are familiar with the MVVM design pattern used with WPF, you might notice
    that we are not implementing `INotifyPropertyChanged` for data binding. Since
    iOS and Android don't have the concept of data binding, we omitted this functionality.
    If you plan on having a WPF or Windows 8 version of your mobile application or
    are using a framework that provides data binding, you should implement support
    for it where needed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉在WPF中使用的MVVM设计模式，你可能会注意到我们没有为数据绑定实现`INotifyPropertyChanged`。由于iOS和Android没有数据绑定的概念，我们省略了这一功能。如果你计划为你的移动应用程序创建WPF或Windows
    8版本，或者使用提供数据绑定功能的框架，你应该在需要的地方实现对其的支持。
- en: Comparing project organization strategies
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较项目组织策略
- en: You might be asking yourself at this point, how do I set up my solution in Xamarin
    Studio to handle shared code and also have platform-specific projects? Xamarin.iOS
    applications can only reference Xamarin.iOS class libraries, so setting up a solution
    can be problematic. There are several strategies for setting up a cross-platform
    solution, each with its own advantages and disadvantages.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能正在问自己，我如何在Xamarin Studio中设置解决方案以处理共享代码，并且还要有特定平台的项目？Xamarin.iOS应用程序只能引用Xamarin.iOS类库，因此设置解决方案可能会出现问题。有几种设置跨平台解决方案的策略，每种策略都有其自身的优缺点。
- en: 'Options for cross-platform solutions are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 跨平台解决方案的选项如下：
- en: '**File Linking**: For this option, you will start with either a plain .NET
    4.0 or .NET 4.5 class library that contains all the shared code. You would then
    have a new project for each platform you want your app to run on. Each platform-specific
    project will have a subdirectory with all of the files linked in from the first
    class library. To set this up, add the existing files to the project and select
    the **Add a link to the file** option. Any unit tests can run against the original
    class library. The advantages and disadvantages of file linking are as follows:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件链接**：对于这个选项，你将从一个包含所有共享代码的普通.NET 4.0或.NET 4.5类库开始。然后，你将为想要应用运行的平台创建一个新的项目。每个特定平台的项目将有一个子目录，其中包含从第一个类库链接的所有文件。要设置此环境，将现有文件添加到项目中，并选择**添加文件链接**选项。任何单元测试都可以针对原始类库运行。文件链接的优点和缺点如下：'
- en: '**Advantages**: This approach is very flexible. You can choose to link or not
    link certain files and can also use preprocessor directives such as `#if IPHONE`.
    You can also reference different libraries on Android versus iOS.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：这种方法非常灵活。你可以选择是否链接某些文件，也可以使用预处理器指令，如`#if IPHONE`。你还可以在Android和iOS之间引用不同的库。'
- en: '**Disadvantages**: You have to manage a file''s existence in three projects:
    core library, iOS, and Android. This can be a hassle if it is a large application
    or if many people are working on it. This option is also a bit outdated since
    the arrival of shared projects.'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：你必须在三个项目中管理一个文件的存在：核心库、iOS和Android。如果这是一个大型应用程序或者许多人正在工作，这可能会很麻烦。这个选项也有些过时，因为共享项目的出现。'
- en: '**Cloned Project Files**: This is very similar to file linking. The main difference
    being that you have a class library for each platform in addition to the main
    project. By placing the iOS and Android projects in the same directory as the
    main project, the files can be added without linking. You can easily add files
    by right-clicking on the solution and navigating to **Display Options** | **Show
    All Files**. Unit tests can run against the original class library or the platform-specific
    versions:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**克隆项目文件**：这与文件链接非常相似。主要区别在于，除了主项目外，你还有每个平台的类库。通过将iOS和Android项目放置在主项目的同一目录下，可以添加文件而不需要链接。你可以通过右键单击解决方案并导航到**显示选项**
    | **显示所有文件**来轻松添加文件。单元测试可以针对原始类库或平台特定版本运行：'
- en: '**Advantages**: This approach is just as flexible as file linking, but you
    don''t have to manually link any files. You can still use preprocessor directives
    and reference different libraries on each platform.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：这种方法与文件链接一样灵活，但你不需要手动链接任何文件。你仍然可以使用预处理器指令并在每个平台上引用不同的库。'
- en: '**Disadvantages**: You still have to manage a file''s existence in three projects.
    There is additionally some manual file arranging required to set this up. You
    also end up with an extra project to manage on each platform. This option is also
    a bit outdated since the arrival of shared projects.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：你仍然需要在三个项目中管理一个文件的存在。此外，还需要一些手动文件排列来设置此环境。你最终在每个平台上还要管理一个额外的项目。这个选项也有些过时，因为共享项目的出现。'
- en: '**Shared Projects**: Starting with Visual Studio 2013 Update 2, Microsoft created
    the concept of shared projects to enable code sharing between Windows 8 and Windows
    Phone apps. Xamarin has also implemented shared projects in Xamarin Studio as
    another option to enable code sharing. Shared projects are virtually the same
    as file linking, since adding a reference to a shared project effectively adds
    its files to your project:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享项目**：从Visual Studio 2013 Update 2开始，微软创建了共享项目的概念，以实现Windows 8和Windows Phone应用之间的代码共享。Xamarin也在Xamarin
    Studio中实现了共享项目，作为另一个选项来启用代码共享。共享项目在本质上与文件链接相同，因为向共享项目添加引用实际上是将它的文件添加到你的项目中：'
- en: '**Advantages**: This approach is the same as file linking, but a lot cleaner
    since your shared code is in a single project. Xamarin Studio also provides a
    dropdown to toggle between each referencing project, so that you can see the effect
    of preprocessor statements in your code.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：这种方法与文件链接相同，但更干净，因为你的共享代码在一个单独的项目中。Xamarin Studio 还提供了一个下拉菜单来切换到每个引用项目，这样你可以看到预处理器语句在代码中的效果。'
- en: '**Disadvantages**: Since all the files in a shared project get added to each
    platform''s main project, it can get ugly to include platform-specific code in
    a shared project. Preprocessor statements can quickly get out of hand if you have
    a large team or have team members that do not have a lot of experience. A shared
    project also doesn''t compile to a DLL, so there is no way to share this kind
    of project without the source code.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：由于共享项目中的所有文件都会添加到每个平台的主项目中，因此在共享项目中包含特定平台的代码可能会变得很丑陋。如果你有一个大型团队或者团队成员经验不足，预处理器语句可能会迅速失控。共享项目也无法编译成
    DLL，因此没有不带源代码共享此类项目的方法。'
- en: '**Portable Class Libraries**: This is the most optimal option; you begin the
    solution by making a **Portable Class Library** (**PCL**) project for all your
    shared code. This is a special project type that allows multiple platforms to
    reference the same project, allowing you to use the smallest subset of C# and
    the .NET framework available in each platform. Each platform-specific project
    will reference this library directly as well as any unit test projects:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植类库**：这是最佳选项；你开始解决方案时，为所有共享代码创建一个 **可移植类库**（**PCL**）项目。这是一个特殊的项目类型，允许多个平台引用同一个项目，让你可以使用每个平台可用的最小
    C# 和 .NET 框架子集。每个特定平台的项⽬也将直接引用这个库以及任何单元测试项目：'
- en: '**Advantages**: All your shared code is in one project, and all platforms use
    the same library. Since preprocessor statements aren''t possible, PCL libraries
    generally have cleaner code. Platform-specific code is generally abstracted away
    by interfaces or abstract classes.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：所有共享代码都在一个项目中，所有平台使用相同的库。由于预处理器语句不可用，PCL 库通常有更干净的代码。特定平台的代码通常通过接口或抽象类来抽象化。'
- en: '**Disadvantages**: You are limited to a subset of .NET depending on how many
    platforms you are targeting. Platform-specific code requires use of **dependency
    injection**, which can be a more advanced topic for developers not familiar with
    it.'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：你受限于你目标平台数量的 .NET 子集。特定平台的代码需要使用 **依赖注入**，这可能对于不熟悉它的开发者来说是一个更高级的话题。'
- en: Setting up a cross-platform solution
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置跨平台解决方案
- en: To understand each option completely and what different situations call for,
    let's define a solution structure for each cross-platform solution. Let's use
    the product search example used earlier in the chapter and set up a solution for
    each approach.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全理解每个选项以及不同情况需要什么，让我们为每个跨平台解决方案定义一个解决方案结构。让我们使用本章前面使用的商品搜索示例，并为每种方法设置一个解决方案。
- en: 'To set up file linking, perform the following steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置文件链接，请执行以下步骤：
- en: Open Xamarin Studio and start a new solution.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Xamarin Studio 并启动一个新的解决方案。
- en: Select a new **Library** project under the general **C#** section.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在通用 **C#** 部分，选择一个新的 **库** 项目。
- en: Name the project `ProductSearch.Core`, and name the solution `ProductSearch`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为 `ProductSearch.Core`，将解决方案命名为 `ProductSearch`。
- en: Right-click on the newly created project and select **Options**.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击新创建的项目，并选择 **选项**。
- en: Navigate to **Build** | **General**, and set the **Target Framework** option
    to **.NET Framework 4.5**.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **构建** | **常规**，并将 **目标框架** 选项设置为 **.NET Framework 4.5**。
- en: Add the `Product`, `ProductRepository`, and`ProductViewModel` classes to the
    project used earlier in the chapter. You will need to add `using System.Threading.Tasks;`
    and `using System.Linq;` where needed.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Product`、`ProductRepository` 和 `ProductViewModel` 类添加到本章前面使用的项目中。你需要在需要的地方添加
    `using System.Threading.Tasks;` 和 `using System.Linq;`。
- en: Navigate to **Build** | **Build All** from the menu at the top to be sure that
    everything builds properly.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从顶部菜单导航到 **构建** | **构建全部**，以确保一切构建正确。
- en: Now, let's create a new iOS project by right-clicking on the solution and navigating
    to **Add** | **Add New Project**. Then, navigate to **iOS** | **iPhone** | **Single
    View Application** and name the project `ProductSearch.iOS`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过右键单击解决方案并导航到 **添加** | **添加新项目** 来创建一个新的 iOS 项目。然后，导航到 **iOS** | **iPhone**
    | **单视图应用程序** 并将项目命名为 `ProductSearch.iOS`。
- en: Create a new Android project by right-clicking on the solution and navigating
    to **Add** | **Add New Project**. Create a new project by navigating to **Android**
    | **Android Application** and name it `ProductSearch.Droid`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击解决方案并导航到**添加** | **添加新项目**创建一个新的 Android 项目。通过导航到**Android** | **Android
    应用**创建一个新的项目，并将其命名为 `ProductSearch.Droid`。
- en: Add a new folder named `Core` to both the iOS and Android projects.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 iOS 和 Android 项目中添加一个名为 `Core` 的新文件夹。
- en: Right-click on the new folder for the iOS project and navigate to **Add** |
    **Add Files from Folder**. Select the root directory for the `ProductSearch.Core`
    project.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 iOS 项目的新的文件夹，导航到**添加** | **从文件夹添加文件**。选择 `ProductSearch.Core` 项目的根目录。
- en: Check the three C# files in the root of the project. An **Add File to Folder**
    dialog will appear.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查项目根目录下的三个 C# 文件。会出现一个**添加文件到文件夹**的对话框。
- en: Select **Add a link to the file** and make sure that the **Use the same action
    for all selected files** checkbox is selected.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**添加文件链接**并确保选中了**为所有选定的文件使用相同的操作**复选框。
- en: Repeat this process for the Android project.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 Android 项目，重复此过程。
- en: Navigate to **Build** | **Build All** from the menu at the top to double-check
    everything. You have successfully set up a cross-platform solution with file linking.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单栏的**构建** | **构建所有**导航到**构建**，以双重检查一切。你已经成功使用文件链接设置了一个跨平台解决方案。
- en: 'When all is done, you will have a solution tree that looks something like what
    you can see in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切完成后，你将有一个类似于以下截图的解决方案树：
- en: '![Setting up a cross-platform solution](img/00025.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![设置跨平台解决方案](img/00025.jpeg)'
- en: You should consider using this technique when you have to reference different
    libraries on each platform. You might consider using this option if you are using
    `MonoGame`, or other frameworks that require you to reference a different library
    on iOS versus Android.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要在每个平台上引用不同的库时，你应该考虑使用这项技术。如果你正在使用 `MonoGame` 或其他需要在 iOS 和 Android 上引用不同库的框架，你可能需要考虑使用这个选项。
- en: Setting up a solution with the cloned project files approach is similar to file
    linking, except that you will have to create an additional class library for each
    platform. To do this, create an Android library project and an iOS library project
    in the same `ProductSearch.Core` directory. You will have to create the projects
    and move them to the proper folder manually, then re-add them to the solution.
    Right-click on the solution and navigate to **Display Options** | **Show All Files**
    to add the required C# files to these two projects. Your main iOS and Android
    projects can reference these projects directly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用克隆项目文件的方法设置解决方案与文件链接类似，但你将不得不为每个平台创建一个额外的类库。为此，在同一个 `ProductSearch.Core` 目录下创建一个
    Android 库项目和 iOS 库项目。你必须手动创建项目并将它们移动到正确的文件夹，然后重新将它们添加到解决方案中。右键点击解决方案并导航到**显示选项**
    | **显示所有文件**，将这些所需的 C# 文件添加到这两个项目中。你的主要 iOS 和 Android 项目可以直接引用这些项目。
- en: 'Your project will look like what is shown in the following screenshot, with
    `ProductSearch.iOS` referencing `ProductSearch.Core.iOS` and `ProductSearch.Droid`
    referencing `ProductSearch.Core.Droid`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你的项目将看起来像以下截图所示，其中 `ProductSearch.iOS` 引用了 `ProductSearch.Core.iOS`，而 `ProductSearch.Droid`
    引用了 `ProductSearch.Core.Droid`：
- en: '![Setting up a cross-platform solution](img/00026.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![设置跨平台解决方案](img/00026.jpeg)'
- en: Working with Portable Class Libraries
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与可移植类库一起工作
- en: A **Portable Class Library** (**PCL**) is a C# library project that can be supported
    on multiple platforms, including iOS, Android, Windows, Windows Store apps, Windows
    Phone, Silverlight, and Xbox 360\. PCLs have been an effort by Microsoft to simplify
    development across different versions of the .NET framework. Xamarin has also
    added support for iOS and Android for PCLs. Many popular cross-platform frameworks
    and open source libraries are starting to develop PCL versions such as Json.NET
    and MVVMCross.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**可移植类库**（**PCL**）是一个可以在多个平台上支持，包括 iOS、Android、Windows、Windows Store 应用、Windows
    Phone、Silverlight 和 Xbox 360 的 C# 库项目。PCLs 是微软为了简化跨不同版本的 .NET 框架的开发而做出的努力。Xamarin
    也为 PCLs 添加了对 iOS 和 Android 的支持。许多流行的跨平台框架和开源库开始开发 PCL 版本，例如 Json.NET 和 MVVMCross。'
- en: Using PCLs in Xamarin
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PCLs 在 Xamarin 中
- en: 'Let''s create our first portable class library:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个可移植类库：
- en: Open Xamarin Studio and start a new solution.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Xamarin Studio 并启动一个新的解决方案。
- en: Select a new **Portable Library** project under the general **C#** section.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**通用** | **C#**部分下选择一个新的**可移植库**项目。
- en: Name the project `ProductSearch.Core` and name the solution `ProductSearch`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Product`, `ProductRepository`, and `ProductViewModel` classes to the
    project used earlier in the chapter. You will need to add `using System.Threading.Tasks;`
    and `using System.Linq;` where needed.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Build** | **Build All** from the menu at the top to be sure that
    everything builds properly.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's create a new iOS project by right-clicking on the solution and navigating
    to **Add** | **Add New Project**. Create a new project by navigating to **iOS**
    | **iPhone** | **Single View Application** and name it `ProductSearch.iOS`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Android project by right-clicking on the solution and navigating
    to **Add** | **Add New Project**. Then, navigate to **Android** | **Android Application**
    and name the project `ProductSearch.Droid`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simply add a reference to the portable class library from the iOS and Android
    projects.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Build** | **Build All** from the top menu and you have successfully
    set up a simple solution with a portable library.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each solution type has its distinct advantages and disadvantages. PCLs are generally
    better, but there are certain cases where they can't be used. For example, if
    you were using a library such as `MonoGame`, which is a different library for
    each platform, you would be much better off using a shared project or file linking.
    Similar issues would arise if you needed to use a preprocessor statement such
    as `#if IPHONE` or a native library such as the Facebook SDK on iOS or Android.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting up a shared project is almost the same as setting up a portable class
    library. In step 2, just select **Shared Project** under the general **C#** section
    and complete the remaining steps as stated.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Using preprocessor statements
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using shared projects, file linking, or cloned project files, one of your
    most powerful tools is the use of preprocessor statements. If you are unfamiliar
    with them, C# has the ability to define preprocessor variables such as `#define
    IPHONE` , allowing you to use `#if IPHONE` or `#if !IPHONE`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple example of using this technique:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In Xamarin Studio, you can define preprocessor variables in your project's options
    by navigating to **Build** | **Compiler** | **Define Symbols**, delimited with
    semicolons. These will be applied to the entire project. Be warned that you must
    set up these variables for each configuration setting in your solution (**Debug**
    and **Release**); this can be an easy step to miss. You can also define these
    variables at the top of any C# file by declaring `#define IPHONE`, but they will
    only be applied within the C# file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go over another example, assuming that we want to implement a class
    to open URLs on each platform:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding example is a perfect candidate for using preprocessor statements,
    since it is very specific to each platform and is a fairly simple function. To
    implement the method on iOS and Android, we will need to take advantage of some
    native APIs. Refactor the class to look as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子非常适合使用预处理器语句，因为它非常特定于每个平台，并且是一个相当简单的函数。为了在iOS和Android上实现这个方法，我们需要利用一些本地API。重构后的类如下所示：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding class supports three different types of projects: Android, iOS,
    and a standard Mono or .NET framework class library. In the case of iOS, we can
    perform the functionality with static classes available in Apple''s APIs. Android
    is a little more problematic and requires an `Activity` object to launch a browser
    natively. We get around this by modifying the input parameters on Android. Lastly,
    we have a plain .NET version that uses `Process.Start()` to launch a URL. It is
    important to note that using the third option would not work on iOS or Android
    natively, which necessitates our use of preprocessor statements.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类支持三种不同类型的项目：Android、iOS和标准的Mono或.NET框架类库。在iOS的情况下，我们可以使用苹果API中可用的静态类来执行功能。Android稍微有些问题，需要`Activity`对象来原生地启动浏览器。我们通过修改Android上的输入参数来解决这个问题。最后，我们有一个普通的.NET版本，它使用`Process.Start()`来启动URL。重要的是要注意，使用第三个选项在iOS或Android上不会原生工作，这迫使我们使用预处理器语句。
- en: Using preprocessor statements is not normally the cleanest or the best solution
    for cross-platform development. They are generally best used in a tight spot or
    for very simple functions. Code can easily get out of hand and can become very
    difficult to read with many `#if` statements, so it is always better to use it
    in moderation. Using inheritance or interfaces is generally a better solution
    when a class is mostly platform specific.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预处理器语句通常不是跨平台开发的最佳或最干净的方法。它们通常在狭窄的空间或非常简单的函数中使用得最好。代码很容易失控，并且随着许多`#if`语句的出现，代码的可读性会变得非常困难，因此总是最好适度使用。当类主要针对特定平台时，使用继承或接口通常是更好的解决方案。
- en: Simplifying dependency injection
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化依赖注入
- en: '**Dependency injection** at first seems like a complex topic, but for the most
    part it is a simple concept. It is a design pattern aimed at making your code
    within your applications more flexible so that you can swap out certain functionality
    when needed. The idea builds around setting up dependencies between classes in
    an application so that each class only interacts with an interface or base/abstract
    class. This gives you the freedom to override different methods on each platform
    when you need to fill in native functionality.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**最初看起来像是一个复杂的话题，但实际上它是一个简单的概念。它是一种设计模式，旨在使你应用程序中的代码更加灵活，以便在需要时可以替换某些功能。这个想法围绕在应用程序中设置类之间的依赖关系，使得每个类只与接口或基类/抽象类交互。这给了你在需要填充本地功能时，在每个平台上自由覆盖不同方法的自由。'
- en: The concept originated from the **SOLID** object-oriented design principles,
    which is a set of rules you might want to research if you are interested in software
    architecture. There is a good article about SOLID on Wikipedia, ([http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29](http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29))
    if you would like to learn more. The **D** in SOLID, which we are interested in,
    stands for **dependencies**. Specifically, the principle declares that a program
    should depend on abstractions, not concretions (concrete types).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念起源于**SOLID**面向对象设计原则，如果你对软件架构感兴趣，你可能想要研究一下这组规则。如果你想要了解更多关于SOLID的信息，维基百科上有一篇很好的文章，([http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29](http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29))。在SOLID中，我们感兴趣的是**D**，它代表**依赖**。具体来说，这个原则声明，一个程序应该依赖于抽象，而不是具体实现（具体类型）。
- en: 'To build upon this concept, let''s walk you through the following example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展这个概念，让我们通过以下例子来讲解：
- en: Let's assume that we need to store a setting in an application that determines
    whether the sound is on or off.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们需要在一个应用程序中存储一个设置，这个设置用来确定声音是开启还是关闭。
- en: 'Now let''s declare a simple interface for the setting: `interface ISettings
    { bool IsSoundOn { get; set; } }`.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们声明一个简单的设置接口：`interface ISettings { bool IsSoundOn { get; set; } }`。
- en: On iOS, we'd want to implement this interface using the `NSUserDefaults` class.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在iOS上，我们希望使用`NSUserDefaults`类来实现这个接口。
- en: Likewise, on Android, we will implement this using `SharedPreferences`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在Android上，我们将使用`SharedPreferences`来实现。
- en: Finally, any class that needs to interact with this setting will only reference
    `ISettings` so that the implementation can be replaced on each platform.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，任何需要与此设置交互的类都只会引用`ISettings`，这样就可以在每个平台上替换实现。
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有Packt书籍的账户中下载你购买的示例代码文件。[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)，并注册以直接将文件通过电子邮件发送给你。
- en: 'For reference, the full implementation of this example will look like the following
    snippet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，此示例的完整实现将如下所示：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now you will potentially have a `ViewModel` class that will only reference
    `ISettings` when following the MVVM pattern. It can be seen in the following snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会有一个`ViewModel`类，它将只引用`ISettings`以遵循MVVM模式。以下是一个示例片段：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using a ViewModel layer for such a simple example is not necessarily needed,
    but you can see it would be useful if you needed to perform other tasks such as
    input validation. A complete application might have a lot more settings and might
    need to present the user with a loading indicator. Abstracting out your setting's
    implementation has other benefits that add flexibility to your application. Let's
    say you suddenly need to replace `NSUserDefaults` on iOS with the iCloud instead;
    you can easily do so by implementing a new `ISettings` class and the remainder
    of your code will remain unchanged. This will also help you target new platforms
    such as Windows Phone, where you might choose to implement `ISettings` in a platform-specific
    way.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个简单的示例，使用ViewModel层可能不是必需的，但你可以看到，如果你需要执行其他任务，如输入验证，它将非常有用。一个完整的应用程序可能有很多设置，可能需要向用户显示加载指示器。抽象出你的设置实现还有其他好处，这些好处可以为你的应用程序增加灵活性。假设你突然需要用iCloud替换iOS上的`NSUserDefaults`；你可以通过实现一个新的`ISettings`类轻松地做到这一点，而你的其余代码将保持不变。这也有助于你针对新的平台，如Windows
    Phone，在那里你可能选择以平台特定的方式实现`ISettings`。
- en: Implementing Inversion of Control
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现控制反转
- en: You might be asking yourself at this point in time, how do I switch out different
    classes such as the `ISettings` example? **Inversion of Control** (**IoC**) is
    a design pattern meant to complement dependency injection and solve this problem.
    The basic principle is that many of the objects created throughout your application
    are managed and created by a single class. Instead of using the standard C# constructors
    for your `ViewModel` or `Model` classes, a service locator or factory class will
    manage them throughout the application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在这个时候问自己，我如何切换不同的类，比如`ISettings`示例？**控制反转**（**IoC**）是一种设计模式，旨在补充依赖注入并解决此问题。基本原理是，你应用程序中创建的许多对象都由一个单独的类管理和创建。而不是使用你的`ViewModel`或`Model`类的标准C#构造函数，服务定位器或工厂类将管理它们在整个应用程序中。
- en: 'There are many different implementations and styles of IoC, so let''s implement
    a simple service locator class to use through the remainder of this book as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: IoC（控制反转）有许多不同的实现和风格，因此让我们实现一个简单的服务定位器类，以便在本书的剩余部分使用，如下所示：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This class is inspired by the simplicity of XNA/MonoGame's `GameServiceContainer`
    class and follows the **service locator** pattern. The main differences are the
    heavy use of generics and the fact that it is a static class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类受到了XNA/MonoGame的`GameServiceContainer`类简洁性的启发，并遵循**服务定位器**模式。主要区别在于大量使用泛型和它是一个静态类。
- en: 'To use our `ServiceContainer` class, we will declare the version of `ISettings`
    or other interfaces that we want to use throughout our application by calling
    `Register`, as seen in the following lines of code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的`ServiceContainer`类，我们将通过调用`Register`来声明我们想要在应用程序中使用的`ISettings`或其他接口的版本，如下面的代码行所示：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: On iOS, you can place this registration code in either your `static void Main()`
    method or in the `FinishedLaunching` method of your `AppDelegate` class. These
    methods are always called before the application is started.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上，你可以将此注册代码放在你的`static void Main()`方法中，或者放在你的`AppDelegate`类的`FinishedLaunching`方法中。这些方法总是在应用程序启动之前被调用。
- en: 'On Android, it is a little more complicated. You cannot put this code in the
    `OnCreate` method of your activity that acts as the main launcher. In some situations,
    the Android OS can close your application but restart it later in another activity.
    This situation is likely to cause an exception somewhere. The guaranteed safe
    place to put this is in a custom Android `Application` class which has an `OnCreate`
    method that is called prior to any activities being created in your application.
    The following lines of code show you the use of the `Application` class:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，这要复杂一些。您不能将此代码放在充当主启动器的活动`OnCreate`方法中。在某些情况下，Android操作系统可能会关闭您的应用程序，但稍后会在另一个活动中重新启动它。这种情况可能会在某个地方引发异常。确保安全的地方是将此代码放在具有在创建应用程序中的任何活动之前被调用的`OnCreate`方法的自定义Android
    `Application`类中。以下代码行展示了`Application`类的使用：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To pull a service out of the `ServiceContainer` class, we can rewrite the constructor
    of the `SettingsViewModel` class so that it is similar to the following lines
    of code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`ServiceContainer`类中提取服务，我们可以重写`SettingsViewModel`类的构造函数，使其类似于以下代码行：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Likewise, you will use the generic `Resolve` method to pull out any `ViewModel`
    classes you would need to call from within controllers on iOS or activities on
    Android. This is a great, simple way to manage dependencies within your application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您将使用通用的`Resolve`方法来提取您需要在iOS控制器或Android活动内部调用的任何`ViewModel`类。这是一种管理应用程序内依赖关系的好方法，简单易行。
- en: There are, of course, some great open source libraries out there that implement
    IoC for C# applications. You might consider switching to one of them if you need
    more advanced features for service location or just want to graduate to a more
    complicated IoC container.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有一些优秀的开源库实现了C#应用程序的IoC。如果您需要更高级的功能来处理服务定位，或者只是想升级到一个更复杂的IoC容器，您可以考虑切换到其中之一。
- en: 'Here are a few libraries that have been used with Xamarin projects:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些与Xamarin项目一起使用的库：
- en: '**TinyIoC**: [https://github.com/grumpydev/TinyIoC](https://github.com/grumpydev/TinyIoC)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TinyIoC**：[https://github.com/grumpydev/TinyIoC](https://github.com/grumpydev/TinyIoC)'
- en: '**Ninject**: [http://www.ninject.org/](http://www.ninject.org/)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ninject**：[http://www.ninject.org/](http://www.ninject.org/)'
- en: '**MvvmCross**: [https://github.com/slodge/MvvmCross](https://github.com/slodge/MvvmCross)
    includes a full MVVM framework as well as IoC'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MvvmCross**：[https://github.com/slodge/MvvmCross](https://github.com/slodge/MvvmCross)
    包含完整的MVVM框架以及IoC'
- en: '**Simple** **Injector**: [http://simpleinjector.codeplex.com](http://simpleinjector.codeplex.com)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Simple Injector**：[http://simpleinjector.codeplex.com](http://simpleinjector.codeplex.com)'
- en: '**OpenNETCF.IoC**: [http://ioc.codeplex.com](http://ioc.codeplex.com)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenNETCF.IoC**：[http://ioc.codeplex.com](http://ioc.codeplex.com)'
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the MVVM design pattern and how it can be
    used to better architect cross-platform applications. We compared several project
    organization strategies for managing a Xamarin Studio solution that contains both
    iOS and Android projects. We went over portable class libraries as the preferred
    option for sharing code and how to use preprocessor statements as a quick and
    dirty way to implement platform-specific code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了MVVM设计模式以及如何用它来更好地构建跨平台应用程序。我们比较了几种项目管理策略，用于管理包含iOS和Android项目的Xamarin
    Studio解决方案。我们讨论了可移植类库作为共享代码的首选选项，以及如何使用预处理器语句作为实现平台特定代码的快速且简单的方法。
- en: After completing this chapter, you should be able to speed up with several techniques
    for sharing code between iOS and Android applications using Xamarin Studio. Using
    the MVVM design pattern will help you divide your shared code and code that is
    platform specific. We also covered several options for setting up cross-platform
    Xamarin solutions. You should also have a firm understanding of using dependency
    injection and Inversion of Control to give your shared code access to the native
    APIs on each platform. In our next chapter, we will begin with writing a cross-platform
    application and dive into using these techniques.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '完成本章后，您应该能够使用Xamarin Studio中的几种技术来加快iOS和Android应用程序之间共享代码的速度。使用MVVM设计模式将帮助您区分共享代码和平台特定代码。我们还讨论了设置跨平台Xamarin解决方案的几个选项。您还应该对使用依赖注入和反转控制来使共享代码访问每个平台的本地API有牢固的理解。在我们下一章中，我们将从编写跨平台应用程序开始，深入探讨使用这些技术。 '
