- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: The One with the Thread Tangles
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程缠结的问题
- en: '*Concurrency* *and threading*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*并发* *和线程*'
- en: '**Threading** and **concurrency** are things that most developers think they
    know all about. The theory sounds so simple, yet in practice, threading is where
    a lot of mistakes are made and where all those frustrating bugs originate. Threading
    can be quite complex, but the people of the BCL and CLR teams have done their
    best to help us as much as they can to make things simpler.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程**和**并发**是大多数开发者认为他们已经全部了解的东西。理论听起来很简单，但在实践中，线程是许多错误发生的地方，也是所有那些令人沮丧的bug的起源。线程可能相当复杂，但BCL和CLR团队的人们已经尽他们所能帮助我们，使事情尽可能简单。'
- en: Once you get the hang of it, threading is a great addition to your skills and
    can make a major difference in your systems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了它，线程就是你技能的一个很好的补充，并且可以在你的系统中产生重大影响。
- en: 'We will look at the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: What is concurrency and threading?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发和线程是什么？
- en: How do threads work internally in .NET and Windows?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程在.NET和Windows内部是如何工作的？
- en: How does the CLR help us?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLR是如何帮助我们的？
- en: What is async/await?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: async/await是什么？
- en: How do we synchronize threads and make them work together?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何同步线程并使它们协同工作？
- en: How can I make sure my code behaves nicely when working with threads?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何确保我的代码在处理线程时表现良好？
- en: How can I use collections over threads?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何使用线程上的集合？
- en: Let’s look into this fascinating topic!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解这个迷人的主题！
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the source code and samples in this chapter can be downloaded from this
    book’s GitHub repository at [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter04](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter04).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有的源代码和示例都可以从本书的GitHub仓库下载，网址为[https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter04](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter04)。
- en: Concurrency and threading – the basics
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发和线程——基础知识
- en: This morning, I woke up as I do every day. I got out of bed, took a shower,
    and got dressed. Then I walked the dog for 30 minutes (it’s a Sunday today). I
    returned home, made some coffee, and then sat down to write this.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 今天早上，我像往常一样醒来。我起床，洗了个澡，然后穿好衣服。然后我遛狗30分钟（今天是星期天）。我回到家，泡了些咖啡，然后坐下来写这篇文档。
- en: I am sure that your day looks the same in general. You do something, then you
    do the next thing. Things are done in order. Sometimes, I make a phone call to
    people in other time zones when I walk the dog, but most of the time, I do the
    things I do one at a time. It is more efficient that way. If I were to sit down
    to write this chapter but stop to walk the dog a bit after five minutes, then
    leave him standing near a tree while I run back to the house to write for five
    more minutes, followed by me running back to the dog to walk another 500 meters,
    things would never get done. I would get a workout with all the running back and
    forth, but it would be inefficient.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢肯定，你的日常活动在总体上看起来是一样的。你做一件事，然后做下一件事。事情按顺序完成。有时，当我遛狗时，我会给其他时区的人打电话，但大多数时候，我一次只做一件事。这样更有效率。如果我坐下来写这一章，但五分钟后停下来遛狗，然后让我跑回家写五分钟，再跑回去接狗再走500米，事情永远也完成不了。我会因为来回跑而得到锻炼，但这会很低效。
- en: That is a silly way to lead your life (no judgment; if this is what you do,
    I am okay with it, it just doesn’t work for me).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种愚蠢的生活方式（没有评判；如果你这样做，我对此表示理解，但这对我来说不起作用）。
- en: However, in the case of computers, we tend to assume that this way of working
    enables work to get done quicker. Why do we think that?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在计算机的情况下，我们倾向于认为这种工作方式可以使工作更快地完成。我们为什么这么想？
- en: Computers cannot do two things at the same time. No, wait. Let me rephrase that.
    CPU cores cannot do two things at the same time. In the old days, before AMD released
    the **Athlon 64 X2 processor** in 2005 and before Intel released the Pentium D
    in the same year, regular computers were all single-core. That means that computers,
    before 2005, could generally only do one thing at a time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机不能同时做两件事。不，等等。让我换个说法。CPU核心不能同时做两件事。在2005年AMD发布了**Athlon 64 X2处理器**之前，以及同一年Intel发布了Pentium
    D之前，普通的计算机都是单核的。这意味着在2005年之前，计算机通常一次只能做一件事。
- en: 'These days, most devices have multiple cores. Your computer, laptop, and phone
    all have a multi-core processor. However, as a system programmer, you might encounter
    devices with only one core. Think of IoT devices: they need to be cheap and very
    low in power consumption. Those systems often have a single core. Systems programmers
    run into single-core devices more often than people writing other software.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数设备都有多个核心。你的电脑、笔记本电脑和手机都有多核处理器。然而，作为系统程序员，你可能会遇到只有单个核心的设备。想想物联网设备：它们需要便宜且功耗非常低。这些系统通常只有一个核心。系统程序员遇到单核设备比编写其他软件的人更常见。
- en: However, in the end, that doesn’t really matter. My primary development machine
    has 16 cores. That sounds like a lot. However, if I look at my Task Manager, I
    can see many things running simultaneously, much more than those 16 cores can
    handle. So, even in a multi-core environment, machines must do something to enable
    all those tasks. As systems programmers, we have to be aware of how to write our
    software to get the most benefit out of those cores.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最终，这并不重要。我的主要开发机器有16个核心。这听起来很多。然而，如果我看我的任务管理器，我可以看到许多事情同时运行，远超过这16个核心可以处理的。所以，即使在多核环境中，机器也必须做些事情来使所有这些任务得以运行。作为系统程序员，我们必须意识到如何编写我们的软件，以从这些核心中获得最大利益。
- en: We are thus dealing with two separate topics here. One is concurrency; the other
    is threading.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这里处理两个独立的话题。一个是并发；另一个是线程。
- en: Concurrency is the concept whereby the system executes several sequences of
    operations in overlapping periods. It is not really simultaneous execution; that
    is called parallelism. It is all about tasks running at what seems to be the same
    time without waiting for other tasks. It is a concept, not a programming technique.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是一种概念，即系统在重叠的时段内执行多个操作序列。这并不是真正的同时执行；那被称为并行。它完全是关于任务在看似相同的时间运行，而不需要等待其他任务。这是一个概念，而不是一种编程技术。
- en: Threads, on the other hand, are a programmer’s construct. Threading is one of
    the ways to achieve concurrency.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，线程是程序员的结构。线程是实现并发的一种方式。
- en: Nice to know
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 值得了解
- en: Threads can be hardware threads or software threads. The CPU handles the first
    type; the second is handled in our software. The **Operating System** (**OS**)
    can assign threads to actual hardware threads, but as a developer, you are almost
    always going to be working with software threads. I will mostly be talking about
    software threads here, but I will point it out when I mean hardware threads instead.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可以是硬件线程或软件线程。CPU处理第一种类型；第二种类型在我们的软件中处理。**操作系统**（**OS**）可以将线程分配给实际的硬件线程，但作为开发者，你几乎总是要处理软件线程。在这里，我主要会谈论软件线程，但当我指的是硬件线程时，我会指出这一点。
- en: The beginnings of concurrency – the IRQ
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发的起源——中断请求（IRQ）
- en: For now, let us ignore the fact that computers cannot multitask aside from spreading
    the load across the physical cores a CPU might have. To make life easier, we will
    assume that a computer can do two things at once.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，让我们忽略这样一个事实：除了将负载分散到CPU可能拥有的物理核心之外，计算机无法进行多任务处理。为了简化问题，我们将假设计算机可以同时做两件事。
- en: This has not always been the case. In the early days, a computer did one thing
    at a time. That meant that if you wrote some software for a computer, you had
    complete control over all available hardware. Everything was yours and yours alone.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不总是如此。在早期，计算机一次只做一件事。这意味着如果你为计算机编写了一些软件，你就完全控制了所有可用的硬件。一切都是你的，而且是你的独有。
- en: 'Well, when I say that it was yours, I mean that it was mainly yours. Sometimes,
    something would happen that would need the attention of the CPU. In those days,
    we had something called an **Interrupt Request** (**IRQ**). An IRQ is a hardware
    feature that is usually tied to other hardware. An external device, such as a
    floppy disk drive or a modem, could signal the CPU (by putting a voltage on a
    particular connection to the CPU). When this happened, the CPU finished the instruction
    it was doing, stored all of its state in memory, looked up the address belonging
    to that IRQ (there could be more than one), and started the code in that address.
    When that function finished, the whole thing would be reversed: the CPU would
    load the previous stored state and continue executing the original code as if
    nothing had happened.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，当我说那是你的，我的意思是那主要是你的。有时，会发生一些需要CPU注意的事情。在那些日子里，我们有一种叫做**中断请求**（**IRQ**）的东西。中断请求是一种通常与硬件相关的硬件功能。一个外部设备，如软盘驱动器或调制解调器，可以通过在CPU的特定连接上施加电压来向CPU发出信号。当发生这种情况时，CPU会完成它正在执行的指令，将所有状态存储在内存中，查找属于那个中断请求的地址（可能有多个），然后在该地址处启动代码。当该功能完成时，整个过程会逆转：CPU将加载之前存储的状态，并继续执行原始代码，就像什么都没发生一样。
- en: This mechanism worked reasonably well, but there were a lot of potential issues.
    For instance, there were only a handful of IRQ lines available. If your code overwrote
    the registration of another piece of code attached to some hardware, that hardware
    would fail to work.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制工作得相当不错，但存在许多潜在问题。例如，只有少数几个中断请求线路可用。如果你的代码覆盖了附加到某些硬件的另一段代码的注册，那么该硬件将无法正常工作。
- en: To make things worse, if you made a silly mistake and your code never returned
    from the IRQ, you could bring the whole machine to a halt. It would simply never
    return from your code and the running program would be on hold indefinitely. So
    you had to be very careful to ensure that you had no such bugs in your code!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，如果你犯了一个愚蠢的错误，你的代码从未从中断请求中返回，你可能会使整个机器停止运行。它将简单地永远不会从你的代码中返回，并且正在运行的程序将无限期地挂起。因此，你必须非常小心，确保你的代码中没有这样的错误！
- en: IRQs are still used today, especially in low-power devices such as Raspberry
    Pi. We will encounter those later in this book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 中断请求（IRQs）今天仍在使用，尤其是在像Raspberry Pi这样的低功耗设备中。我们将在本书的后面遇到它们。
- en: Cooperative and preemptive multitasking
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作式和抢占式多任务处理
- en: IRQs work okay, but they should be used by hardware devices. Since there aren’t
    that many IRQs, and since they have the potential to kill running processes, we
    have moved away from using them in normal software.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 中断请求（IRQs）工作得还可以，但它们应该由硬件设备使用。由于中断请求的数量并不多，并且它们有杀死正在运行进程的潜在能力，所以我们已经不再在常规软件中使用它们。
- en: However, having a computer and only being able to do one thing at a time with
    it seemed like a waste of resources. Computers became more and more powerful.
    They could soon do more things than we asked them to do. That was when multitasking
    OSs came into play.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，拥有计算机却只能用它做一件事情，这似乎是一种资源的浪费。计算机变得越来越强大。它们很快就能做比我们要求它们做的事情更多的事情。那时，多任务操作系统就出现了。
- en: 'For instance, the versions of Windows before Windows 95, such as Windows 3.1,
    used something called **cooperative multitasking**. The principle was reasonably
    straightforward. A piece of code would do something, and when it thought it could
    use a break, it would just tell the OS: “Hey, I am on a break; if you need me
    to do something, just let me know.” It would then halt execution. This meant that
    the OS could allocate CPU time to another process.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Windows 95之前的Windows版本，如Windows 3.1，使用了一种叫做**协作式多任务处理**的东西。原理相当简单。一段代码会做某事，当它认为可以休息一下时，它就会告诉操作系统：“嘿，我在休息；如果你需要我做些什么，请告诉我。”然后它会停止执行。这意味着操作系统可以将CPU时间分配给另一个进程。
- en: We called this cooperative multitasking because we expected the software to
    cooperate and share the resources fairly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称之为协作式多任务处理，因为我们期望软件能够合作并公平地共享资源。
- en: Of course, if a program misbehaved, it could still claim all the CPU time, thus
    stopping other software from running as intended.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果一个程序行为不当，它仍然可以声称所有的CPU时间，从而阻止其他软件按预期运行。
- en: 'A better way was needed. Windows NT 3.1 and later Windows 95 did much better:
    they introduced **preemptive multitasking**.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一种更好的方法。Windows NT 3.1以及后来的Windows 95做得更好：它们引入了**抢占式多任务处理**。
- en: 'The idea is straightforward: allocate some time for a process to run, and when
    that time is out, store the state of that process, park it somewhere, and move
    on to the next process. When the time comes for the original process to do something
    again, the OS loads the program back into memory and restores the state, then
    the process can continue. The process was utterly oblivious to the time it had
    been dormant unless it kept track of the clock.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法很简单：为进程分配一些运行时间，当时间到了，就存储该进程的状态，将其停放某处，然后继续下一个进程。当原始进程再次需要做某事时，操作系统将程序重新加载到内存中，并恢复状态，然后进程可以继续。除非进程跟踪时钟，否则进程对它休眠的时间一无所知。
- en: Processes could no longer claim all of the available CPU time. The OS would
    pause the process if its time had run out.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 进程不能再声称所有可用的CPU时间。如果其时间已用完，操作系统将暂停该进程。
- en: Preemptive multitasking is still the way modern OSs work today.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 预先多任务处理仍然是现代操作系统今天的工作方式。
- en: However, all of this deals with multiple processes on a computer running simultaneously.
    How can we have one process doing multiple things at the same time? Well, one
    solution would be to use threads.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有这些都涉及在计算机上同时运行的多个进程。我们如何让一个进程同时做多件事情呢？好吧，一个解决方案就是使用线程。
- en: Threads in C#
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#中的线程
- en: 'Threads are a concept that allows computers to seem to be doing more than one
    thing at once in your program. Just as an OS allows multiple programs to run simultaneously,
    threads allow your program to run multiple flows in your application concurrently.
    A thread is nothing more than an **execution flow** in your program. You always
    have at least one thread: the one that got started when the program began its
    execution. We call this the main thread. The runtime manages this thread and you
    have little control over it. All the other threads, however, are yours, and you
    can do whatever you want with them.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是一个概念，它允许计算机在您的程序中同时做更多的事情。就像操作系统允许多个程序同时运行一样，线程允许您的程序在应用程序中并发运行多个流程。线程不过是您程序中的一个**执行流程**。您始终至少有一个线程：当程序开始执行时启动的那个线程。我们称之为主线程。运行时管理这个线程，您对其控制很少。然而，所有其他的线程都是您的，您可以随意对它们进行操作。
- en: 'Threads are nothing magical. The basic principle is quite easy:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 线程并不是什么神奇的东西。基本原理很简单：
- en: Create a method, function, or any other piece of code you want to run.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个您想要运行的方法、函数或任何其他代码片段。
- en: Create a thread, giving it the address of the method.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个线程，给它传递方法的地址。
- en: Start the thread.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动线程。
- en: The OS or runtime executes that method or function while running the main thread
    simultaneously.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作系统或运行时在运行主线程的同时执行那个方法或函数。
- en: You can monitor the progress of that thread. You can wait for it to end, or
    you can use a fire-and-forget strategy by just letting it do its work.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以监控那个线程的进度。您可以等待它结束，或者您可以使用一种“发射后不管”的策略，只需让它完成其工作即可。
- en: How you do these steps depends on which version you want to use. Do you choose
    the .NET way or go down the rabbit hole we know as the Win32 API?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何执行这些步骤取决于您想使用哪个版本。您是选择.NET方式还是选择我们熟知的Win32 API的兔子洞？
- en: In .NET, threads are represented by an actual class (or, more precisely, an
    instance of a class). In Win32, they are just something created by the Win32 API.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，线程由一个实际的类（或者更准确地说，是一个类的实例）表示。在Win32中，它们只是由Win32 API创建的东西。
- en: Win32 threads
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Win32线程
- en: 'In Win32, you use the `CreateThread` API to create a thread. I want to show
    you how this works, but I must be honest: you will probably never do this in your
    code. There are better ways to create threads than using the Win32 API. Still,
    there might be circumstances when having complete control of the Win32 threads
    might be necessary.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Win32中，您使用`CreateThread` API创建线程。我想向您展示它是如何工作的，但我要坦白：您可能永远不会在您的代码中这样做。使用Win32
    API创建线程的方法有很多更好的选择。尽管如此，在某些情况下，完全控制Win32线程可能是必要的。
- en: Let me show you how to do this in the Win32 API.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我向您展示如何在Win32 API中完成这个操作。
- en: 'We will begin by declaring a `delegate`. This `delegate` is the form of the
    function that contains the work that the thread executes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先声明一个`delegate`。这个`delegate`是包含线程执行的工作的函数的形式：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since we are calling Win32 APIs, we need to import them:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在调用Win32 API，我们需要导入它们：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will import three APIs: `CreateThread`, `CloseHandle`, and `WaitForSingleObject`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入三个API：`CreateThread`、`CloseHandle`和`WaitForSingleObject`。
- en: 'Before we can use these APIs, we have to write the code that does something
    useful. In this case, it is not really useful, but this is the code that will
    be executed in the thread:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用这些API之前，我们必须编写执行有用操作的代码。在这种情况下，这并不是真正有用的代码，但这是将在线程中执行的代码：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This `MyThreadFunction` function matches the delegate that we defined earlier.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `MyThreadFunction` 函数与之前定义的委托相匹配。
- en: 'With all of that out of our way, we can create the threads and have our program
    do something. Or rather, it can do lots of somethings simultaneously. Here we
    go:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在清除所有这些之后，我们可以创建线程，并让我们的程序执行某些操作。或者更确切地说，它可以同时执行许多操作。下面是操作步骤：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `DoWork()` method creates a thread by calling the `CreateThread` Win32
    API. This API has some parameters. Let me explain what they do with the help of
    *Table 4.1*:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoWork()` 方法通过调用 `CreateThread` Win32 API 创建线程。此API有一些参数。让我借助 *表4.1* 来解释它们的作用：'
- en: '| **Parameter** | **Description** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **描述** |'
- en: '| --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| IntPtr lpThreadAttributes | A pointer to the security attributes struct |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| IntPtr lpThreadAttributes | 安全属性结构的指针 |'
- en: '| uint dwStackSize | The size of the stack required for this thread |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| uint dwStackSize | 此线程所需的堆栈大小 |'
- en: '| ThreadProc lpStartAddress | A pointer to the function that the thread runs
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| ThreadProc lpStartAddress | 线程运行的函数的指针 |'
- en: '| IntPtr lpParameter | A pointer to a variable that is passed to the thread
    |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| IntPtr lpParameter | 指向传递给线程的变量的指针 |'
- en: '| uint dwCreationFlags | Additional flags determining how the thread is created
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| uint dwCreationFlags | 确定线程创建方式的附加标志 |'
- en: '| out uint lpThreadId | An out parameter with the ID of the thread |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| out uint lpThreadId | 一个输出参数，包含线程的ID |'
- en: 'Table 4.1: Parameters for the CreateThread Win32 API'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1：CreateThread Win32 API的参数
- en: The security attributes define who or what has access to the thread and what
    this thread can use. The security attributes are rather complex. I will not be
    diving into them here, mainly because with threads they are not often used. Here,
    we have set the security attribute to `IntPtr.Zero`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 安全属性定义了谁或什么可以访问线程以及此线程可以使用什么。安全属性相当复杂。在这里，我们不会深入探讨它们，主要是因为在处理线程时它们并不常用。在这里，我们将安全属性设置为
    `IntPtr.Zero`。
- en: The `dwStackSize` parameter defines the stack size that the thread uses. As
    discussed before, each thread gets its own stack, where it can store its value
    types. This stack is reclaimed when the thread is done.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`dwStackSize` 参数定义了线程使用的堆栈大小。如前所述，每个线程都有自己的堆栈，可以在其中存储其值类型。当线程完成后，此堆栈将被回收。'
- en: Then, we get the function pointer that the thread will execute as soon as that
    thread starts. In C#, we can pass the method’s name and let the compiler do the
    hard work of figuring out the memory address.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们获取线程启动时将执行的函数指针。在C#中，我们可以传递方法的名称，让编译器完成找出内存地址的繁琐工作。
- en: 'After supplying the start address of the method, we get something more interesting:
    we can pass data into the thread method. The `lpParameter` parameter is a pointer
    to the memory where that data is located. To get data into the thread is quite
    a lot of work unless you want to use a simple `Int32`. After all, an `IntPtr`
    is a 32-bit value, so you can take an int and cast it back and forth to get that
    data in the thread function. I am not passing anything here, but will I show you
    how to do that a little later in this chapter.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供方法启动地址后，我们得到一些更有趣的东西：我们可以将数据传递到线程方法中。`lpParameter` 参数是指向数据所在内存的指针。除非你想使用简单的
    `Int32`，否则将数据放入线程中相当繁琐。毕竟，`IntPtr` 是一个32位值，所以你可以将一个int转换回转换以获取线程函数中的数据。这里我没有传递任何东西，但稍后在本章中我会向你展示如何做到这一点。
- en: Next are the flags that define how the system creates the thread. There are
    two flags that we can use, not counting the default `0`, which means “do nothing
    special.” These flags are explained in *Table 4.2*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是定义系统如何创建线程的标志。除了默认的 `0`，表示“不执行特殊操作”之外，我们可以使用两个标志。这些标志在 *表4.2* 中解释。
- en: '| **Flag** | **Value** | **Meaning** |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **标志** | **值** | **含义** |'
- en: '| --- | --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0x00000000 | Do nothing special |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0x00000000 | 不执行特殊操作 |'
- en: '| `CREATE_SUSPENDED` | 0x00000004 | Create the thread, but suspend it immediately
    instead of starting it. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `CREATE_SUSPENDED` | 0x00000004 | 创建线程，但立即挂起而不是启动。 |'
- en: '| `STACK_SIZE_PARAM_IS_A_RESERVATION` | 0x00010000 | If this is set, the stack
    size is a reservation. If not, the stack size is committed. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `STACK_SIZE_PARAM_IS_A_RESERVATION` | 0x00010000 | 如果设置此标志，则堆栈大小是预留的。如果没有设置，则堆栈大小是已提交的。
    |'
- en: 'Table 4.2: Thread creation options'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2：线程创建选项
- en: '`CREATE_SUSPENDED` creates the thread but puts it in a suspended state when
    it is created. The default behavior is to run the code that `lpStartAddress` points
    to immediately.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATE_SUSPENDED`创建线程，但在创建时将其置于挂起状态。默认行为是立即运行`lpStartAddress`指向的代码。'
- en: '`STACK_SIZE_PARAM_IS_A_RESERVATION` is an interesting one. This flag is one
    of the main reasons you might want to use the Win32 version of creating threads
    instead of the .NET one. Each thread has its own stack. You can specify how big
    that stack should be, but when you do that, all that happens is that the system
    reserves that memory. This reserving is a quick operation. Reservation only tells
    the system that you want to use this amount of memory at some point. You will
    get an error if the system doesn’t have enough memory to fulfill your request.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`STACK_SIZE_PARAM_IS_A_RESERVATION`是一个有趣的标志。这个标志是您可能想要使用Win32线程创建版本而不是.NET版本的主要原因之一。每个线程都有自己的栈。您可以指定该栈应该有多大，但当你这样做时，发生的所有事情只是系统保留该内存。这种保留是一个快速操作。保留只是告诉系统您希望在某个时候使用这么多内存。如果系统没有足够的内存来满足您的请求，您将收到错误。'
- en: However, the memory is not yet committed. Committed means that the OS reserves
    the memory you requested and marks it as being used by a process. Reservation
    is just telling it that you want the memory to be available later.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，内存尚未提交。提交意味着操作系统为您请求的内存保留，并将其标记为被进程使用。保留只是告诉它您希望在以后使用该内存。
- en: Page faults
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 页面错误
- en: When your application requests memory or tries to access memory from the system,
    certain things can happen.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用程序请求内存或尝试从系统访问内存时，可能会发生某些事情。
- en: The first instance happens when the memory is available in your stack or heap.
    You get the pointer to that memory; it’s all yours now.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况发生在内存已在您的栈或堆中可用时。您获得了该内存的指针；现在它完全属于您了。
- en: The next happens if the memory is *not* in your stack or heap yet but it is
    available on the system. This results in a soft page fault. The system will add
    the new memory to the current stack or heap.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内存尚未在您的栈或堆中，但系统上可用，接下来会发生什么。这会导致软页面错误。系统会将新内存添加到当前的栈或堆中。
- en: Next, it’s possible that the memory you want to reach is not in your computer’s
    memory chips. In this case, it has probably been swapped to disk. This is a hard
    page fault. The OS will load the memory from the disk and add it to your working
    set.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，可能您想要访问的内存不在您计算机的内存芯片中。在这种情况下，它可能已经被交换到磁盘上。这是一个硬页面错误。操作系统将从磁盘加载内存并将其添加到您的工作集。
- en: Page faults are great for adding flexibility to the system. However, they come
    with a big performance hit.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 页面错误对于增加系统的灵活性非常有用。然而，它们会带来很大的性能损失。
- en: A page fault might occur when you reserve memory and want to access it. When
    this happens, your application’s performance will degrade.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当您保留内存并想要访问它时，可能会发生页面错误。当这种情况发生时，您的应用程序性能将下降。
- en: If you commit memory, it is guaranteed to be available when it is needed. This
    makes your memory footprint larger and faster since you will not get a page fault.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您提交内存，则它在需要时保证可用。这使得您的内存占用更大、速度更快，因为您不会遇到页面错误。
- en: 'You must choose here: which of the two scenarios do you prefer? You can control
    that for the stack with the `STACK_SIZE_PARAM_IS_A_RESERVATION` flag.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须在这里做出选择：您更喜欢两种场景中的哪一种？您可以通过`STACK_SIZE_PARAM_IS_A_RESERVATION`标志来控制栈。
- en: 'The code sample ends with two statements: `WaitForSingleObject()` and `CloseHandle()`.
    The *Synchronizing threads* section in this chapter explains `WaitForSingleObject()`
    in much more detail. Still, the short description is as follows: wait for the
    thread to finish before continuing on the main thread.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例以两个语句结束：`WaitForSingleObject()`和`CloseHandle()`。本章中的*同步线程*部分更详细地解释了`WaitForSingleObject()`。不过，简短的描述如下：在主线程继续之前等待线程完成。
- en: '`CloseHandle` clears up all used resources. Yes, this is an unmanaged resource.
    This would be a great place to use the `IDisposable` pattern.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`CloseHandle`清理所有已使用的资源。是的，这是一个未管理资源。这是一个使用`IDisposable`模式的好地方。'
- en: .NET threads
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET线程
- en: Threads in the .NET BCL are much simpler to use. Of course, when something is
    simplified, you usually sacrifice flexibility as a result.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: .NET BCL中的线程使用起来要简单得多。当然，当某件事被简化时，您通常会因此牺牲灵活性。
- en: The following sample shows how to do the same work as we did with the Win32
    thread using the .NET constructs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何使用.NET结构执行与Win32线程相同的工作。
- en: 'We will begin with the thread function, which runs on the new thread. It is
    almost the same as the Win32 sample. The following snippet shows the code that
    we want to run inside the thread:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从线程函数开始，它在新的线程上运行。它几乎与Win32示例相同。以下代码片段显示了我们要在线程内运行的代码：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the main body of our code, we create the thread, give it the function to
    run, and start it:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码的主体中，我们创建线程，给它运行的功能，然后启动它：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We create a new instance of the `Thread` class and pass the method we want to
    use in the constructor. Then we start it. Then, we use `Join()` to wait for it,
    effectively pausing the main thread until our new thread is done doing whatever
    it is doing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建`Thread`类的新实例，并在构造函数中传递我们想要使用的方法。然后我们启动它。然后，我们使用`Join()`等待它，实际上暂停了主线程，直到我们的新线程完成它正在做的事情。
- en: That’s it. If you compare this with the Win32 version, I am sure that you will
    appreciate this simplicity.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。如果你与Win32版本进行比较，我确信你会欣赏这种简单性。
- en: 'However, do not be fooled: this simplicity does not mean that you cannot control
    your threads. You can control them and you can do much more than what I have just
    shown you. For instance, you can also specify the stack size you want to use for
    your thread:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不要被这种简单性欺骗：这并不意味着你不能控制你的线程。你可以控制它们，并且你可以做比我所展示的更多的事情。例如，你也可以指定你想要为你的线程使用的堆栈大小：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we allocate 8 MB for the stack for our new thread.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为新线程分配了8 MB的堆栈。
- en: Nice to know
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 很高兴了解
- en: The default stack size for a 32-bit application is 1 MB; for a 64-bit application,
    it is 4 MB. You will rarely need more than that. Requesting a big stack should
    only be done if you have tested your application and found that you really need
    it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 32位应用程序的默认堆栈大小为1 MB；对于64位应用程序，为4 MB。你很少需要超过这个大小。只有在测试了你的应用程序并发现你确实需要它时，才应该请求大堆栈。
- en: In the Win32 sample, we had to explicitly state that we wanted to create a thread
    in a suspended state. If we did not do that, it would have started immediately.
    In .NET, things work differently. A newly created thread in .NET is considered
    *unstarted*. This means that it will not be starting immediately. It is also not
    yet suspended; there is quite a difference in behavior.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Win32示例中，我们必须明确指出我们想要创建一个处于挂起状态的线程。如果我们没有这样做，它将立即启动。在.NET中，情况不同。在.NET中创建的新线程被认为是*未启动*。这意味着它不会立即启动。它也还没有挂起；在行为上存在相当大的差异。
- en: A suspended thread is fully formed and placed on the OS’s scheduler list. Its
    stack is allocated and all resources are present.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个挂起的线程已经完全形成，并被放置在操作系统的调度器列表中。它的堆栈已分配，所有资源都存在。
- en: An `Thread` class. The stack is not yet allocated and it has not yet been given
    to the OS, so it is not yet on the scheduler, and so on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Thread`类。堆栈尚未分配，它还没有被分配给操作系统，因此它还没有在调度器上，等等。
- en: When we call `Start()` on that .NET thread, the runtime does all that work.
    Creating a thread is much faster than the `CreateThread()` call in Win32, but
    that performance gain is lost when you start the thread. Think of it as lazy initialization.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在.NET线程上调用`Start()`时，运行时会做所有这些工作。创建线程比Win32中的`CreateThread()`调用要快得多，但当你启动线程时，这种性能提升就丢失了。把它想象成懒加载初始化。
- en: The designers of the CLR took advantage of this. If it is relatively cheap to
    create threads and only becomes expensive when we use them, why not move that
    burden of creation to the beginning of the program? Starting an application takes
    time; if we extend that a bit, it does not matter. However, that would mean that
    we have a faster system when it is in use. We can have a pool of threads available
    when we need one or two. That is precisely what they did.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: CLR的设计者利用了这一点。如果创建线程相对便宜，而只有在使用它们时才变得昂贵，为什么不将创建的负担移到程序开始时呢？启动应用程序需要时间；如果我们稍微延长这一点，那就没关系了。然而，这意味着当它在使用时，我们有一个更快的系统。当我们需要一两个线程时，我们可以有一个线程池可用。这正是他们所做的事情。
- en: An example will probably make this clearer. However, before I can show you that,
    we must make some modifications. We want to create many threads that run simultaneously.
    To distinguish the output from each thread, we need to pass some data to that
    thread so that it can display it. Thus, we need to have something to store data
    in.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可能会使这更清晰。然而，在我能向你展示那之前，我们必须做一些修改。我们想要创建许多同时运行的线程。为了区分每个线程的输出，我们需要向那个线程传递一些数据，以便它可以显示它。因此，我们需要有存储数据的地方。
- en: 'We need immutable data for reasons that will become clear when we discuss thread
    safety later in this chapter. The `record`, which was added to C# 9, is a great
    way to do this::'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要不可变数据，原因将在本章后面讨论线程安全性时变得清晰。C# 9中添加的`record`是一个实现这一点的绝佳方式：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can now work on our method that executes in that thread:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始编写在特定线程中执行的方法：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The thread gets a parameter of the `Nullable<object>` type. We cannot declare
    it as any other type, as this is what the runtime expects.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 线程获取一个`Nullable<object>`类型的参数。我们不能将其声明为其他类型，因为这是运行时所期望的。
- en: To use this data, we need to cast it to the right type.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些数据，我们需要将其转换为正确的类型。
- en: Then, we will get the ID of the current thread. Each thread has a unique ID,
    so we can interact with it, although we will only display it here.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将获取当前线程的ID。每个线程都有一个唯一的ID，因此我们可以与之交互，尽管我们在这里只会显示它。
- en: 'Let us create some threads:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些线程：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We will create one hundred threads and start them immediately after creation.
    We will give them some data to see where in the loop we are.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一百个线程，并在创建后立即启动它们。我们将给它们一些数据，以查看我们在循环中的位置。
- en: 'After the loop, I added the `Console.ReadKey()` so the program does not exit
    before all threads are done. The main thread that starts when running your program
    is special: if that ends, the CLR ends the whole program and unloads all memory.
    So, keeping your main thread alive is crucial until you are sure that all work
    is done. In a real-world scenario, you wouldn’t use `Console.ReadLine()` for this,
    but for this demo, it works just fine.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环之后，我添加了`Console.ReadKey()`，以确保在所有线程完成之前程序不会退出。当你运行程序时启动的主线程是特殊的：如果它结束，CLR将结束整个程序并卸载所有内存。所以，保持你的主线程活跃直到你确信所有工作都完成是至关重要的。在实际场景中，你不会使用`Console.ReadLine()`来做这件事，但在这个演示中，它工作得很好。
- en: If you run this, you will probably see the thread ID increasing in line with
    the loop counter. They are not equal. The CLR already created a dozen or so threads
    before you ran your loop.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，你可能会看到线程ID随着循环计数器的增加而增加。它们并不相等。CLR在你运行循环之前已经创建了一打或更多的线程。
- en: If you increase the loop to do a much higher number of iterations, you will
    eventually see the same thread ID now and then. The CLR reuses threads to avoid
    thread starvation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将循环增加到执行更多的迭代次数，你最终会看到线程ID偶尔相同。CLR会重用线程以避免线程饥饿。
- en: 'However, I promised to show you the thread pool. Replace the part of the code
    where we had the for-loop with the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我承诺要向你展示线程池。将代码中我们原本的for循环部分替换为以下代码：
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will use the thread pool here to pull threads out of the pool when needed.
    If you run this, you repeatedly see the same thread IDs. Threads are pulled out
    of the pool and started with the correct data. When the thread is done, it is
    winded down, its resources are de-allocated, and it is placed back in the pool,
    ready to be used again if needed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里使用线程池，在需要时从池中取出线程。如果你运行这个程序，你会反复看到相同的线程ID。线程从池中被取出并使用正确的数据启动。当线程完成时，它会关闭，其资源会被释放，然后被放回池中，以便在需要时再次使用。
- en: The overhead is minimal and the advantages are enormous. Systems using this
    are much more efficient.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 负载很小，优势巨大。使用这种系统的系统效率更高。
- en: '`ThreadPool` hides many more secrets and tricks that you can use, but its usage
    has largely been replaced by the **Task Parallel Library** (**TPL**), which handles
    most of this for you. Let us have a look.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPool`隐藏了许多你可以使用的秘密和技巧，但它的使用在很大程度上已经被**任务并行库**（**TPL**）所取代，它为你处理了大部分工作。让我们看看。'
- en: Tasks and Parallel Library – the TPL
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务和并行库 – TPL
- en: The TPL has been around for quite some time. It was introduced back in 2010
    with the release of .NET 4.0.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: TPL已经存在了一段时间。它是在2010年随着.NET 4.0的发布而引入的。
- en: The TPL simplifies many of the things we used to do with threads. Threads still
    have their place, especially when dealing with third-party libraries. However,
    in most cases, we can let the TPL figure things out.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: TPL简化了我们过去用线程做的许多事情。线程仍然有其位置，尤其是在处理第三方库时。然而，在大多数情况下，我们可以让TPL来处理这些事情。
- en: In the TPL, the `Task` class is the main class to work with. `Task` is a class
    that handles the instantiation of threads when needed. It does much more, but
    we will deal with that later.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在TPL中，`Task`类是主要的操作类。`Task`是一个在需要时处理线程实例化的类。它做得多得多，但我们稍后再讨论。
- en: I said “when needed” because it is smart enough to determine when a new thread
    is needed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我说“当需要时”，因为它是足够智能的，能够确定何时需要一个新的线程。
- en: 'Let us begin with a straightforward example and then work from there:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始，然后逐步深入：
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`Task` is just another C# class that handles much of the concurrency for us.
    In this case, we call `static method Run()`, which takes a delegate that it performs.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task`只是另一个C#类，它为我们处理了大部分并发。在这种情况下，我们调用`static method Run()`，它接受一个委托来执行。'
- en: 'We can rewrite this as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其重写如下：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code snippet does the same, but we call the method instead of using the
    lambda expression.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段做的是同样的事情，但我们调用方法而不是使用lambda表达式。
- en: 'We can more or less do the same thing in a slightly different way:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用稍微不同的方式做到同样的事情：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: I have omitted the `Console` stuff and the actual method; they will remain the
    same (until I say that I have changed them).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我省略了`Console`相关的内容和实际的方法；它们将保持不变（直到我说我已经改变了它们）。
- en: This code does more or less the same thing as the previous sample. The difference
    is that the `Task` does not start unless we explicitly call `Start()`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码基本上与上一个示例做的是同样的事情。区别在于`Task`不会启动，除非我们明确调用`Start()`。
- en: The second example gives you more control over the `Task`. You can set properties
    and change the task’s behavior before starting it. `Task.Run()` is mostly designed
    for fire-and-forget scenarios. `Start()` is more flexible; it allows us to change
    the scheduling and, for instance, tell it to run on a specific thread. You can
    also specify the priority of the `Task` this way.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例为你提供了对`任务`更多的控制。你可以在启动任务之前设置属性和改变任务的行为。`Task.Run()`主要设计用于“发射后不管”的场景。`Start()`更加灵活；它允许我们改变调度，例如，指定它在一个特定的线程上运行。你也可以这样指定`Task`的优先级。
- en: 'This example is not very exciting. Let us try to make it a bit more exhilarating.
    We can change our method to the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子并不非常吸引人。让我们尝试让它变得更有趣。我们可以将我们的方法改为以下内容：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We will add a parameter to our method to identify who calls the method. Since
    we now have a parameter, we must also change how we pass this to the `Task` constructor.
    Let’s not stop there. Imagine that we want to chain method calls. After the `Task`
    has finished with `DoWork` with `Id 1`, we want it to call that method again but
    with `Id 2` this time. In real life, you would probably chain two completely different
    methods, but the way of working is the same.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的方法中添加一个参数来识别调用者。由于我们现在有一个参数，我们必须也改变如何将这个参数传递给`Task`构造函数。让我们不要止步于此。想象一下，我们想要链式调用方法。在`Task`完成使用`Id
    1`的`DoWork`之后，我们希望它再次调用那个方法，但这次使用`Id 2`。在现实生活中，你可能会链式调用两个完全不同的方法，但工作方式是相同的。
- en: 'The code looks like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来是这样的：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We have changed the parameter in the constructor so that we can pass that `1`
    integer to the method. The following line is more interesting. It says: “When
    you finish the first step, call `DoWork` again, but this time with `Id 2`.” The
    `prevTask` parameter is the previous `Task` that has finished its work. This triggered
    the start of the second `Task`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更改了构造函数中的参数，以便我们可以将那个`1`整数传递给方法。下一行更有趣。它说：“当你完成第一步后，再次调用`DoWork`，但这次使用`Id
    2`。”`prevTask`参数是已经完成工作的前一个`Task`。这触发了第二个`Task`的开始。
- en: If you run this, you will see the lines printed to the console in the correct
    order.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，你会看到控制台按正确顺序打印的行。
- en: 'Let us rewrite the method that gets called one more time:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写一次被调用的方法：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We added the `id` of the thread this method runs on to the output. I also want
    to see that `id` thread before we start the tasks. Our calling code now looks
    like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个方法运行的线程的`id`添加到输出中。我还想在开始任务之前看到这个`id`线程。我们的调用代码现在看起来是这样的：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you run this, you will probably see that the tasks run on a different thread
    rather than the main one. If you repeat this a few times, it might even happen
    that the second task runs on a different thread from the first one. It is impossible
    to predict when this will happen; the scheduler picks whatever works best given
    the current conditions. We do not have to worry about this. It just works. Neat,
    isn’t it?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，你可能会看到任务在不同的线程上运行，而不是主线程。如果你重复几次，甚至可能发生第二个任务在第一个任务不同的线程上运行的情况。这种情况何时发生是不可预测的；调度器会根据当前条件选择最佳方案。我们不必担心这个问题。它只是正常工作。这不是很酷吗？
- en: Another nice class that is available in the TPL is the `Parallel` class. It
    allows us to do stuff in parallel. Let’s see that
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: TPL中另一个很棒的类是`Parallel`类。它允许我们并行执行操作。让我们看看这个：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, we will print the `id` of the current thread. Then we will create an
    array of integers from `1` to `10`; nothing special here. After that, we will
    call the static `ForEach` method on the `Parallel` class and give it the array
    and the lambda to call. The method iterates through the array and calls the lambda
    with the correct parameter. It does that in parallel, not sequentially, as with
    a standard `ForEach` loop.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将打印当前线程的 `id`。然后，我们将创建一个从 `1` 到 `10` 的整数数组；这里没有什么特别的。之后，我们将调用 `Parallel`
    类的静态 `ForEach` 方法，并给它提供数组和要调用的 lambda 表达式。该方法并行地遍历数组，并使用正确的参数调用 lambda 表达式。它这样做的方式不是顺序的，而是与标准的
    `ForEach` 循环不同。
- en: When you run this, you will see some exciting results. The order in which the
    program prints the IDs is entirely random. You will see that the runtime uses
    multiple threads, but sometimes it reuses some of these threads.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你会看到一些令人兴奋的结果。程序打印 ID 的顺序完全是随机的。你会看到运行时使用了多个线程，但有时它会重用其中的一些线程。
- en: Again, the TPL determines the best way to do this and handles all the threads’
    creation and scheduling for you.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，TPL 确定最佳做法，并为你处理所有线程的创建和调度。
- en: TPL is extremely powerful. It is also the backbone of the async await pattern.
    This is a pattern that simplifies working with concurrency so much that most users
    do not realize what is happening behind the scenes. With your newfound knowledge,
    you should have no problem following what is happening. So, let’s have a look
    at async/await.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: TPL 非常强大。它也是 async/await 模式的支柱。这是一个简化并发工作的模式，以至于大多数用户都没有意识到幕后发生了什么。凭借你新获得的知识，你应该没有问题跟踪正在发生的事情。那么，让我们来看看
    async/await。
- en: Async/await
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Async/await
- en: Software hardly ever runs in isolation. Most software needs to reach outside
    of its boundaries and access something that is not part of the code block at some
    point. Examples include reading and writing files, reading data from a network,
    sending something to a printer, and so on. Suppose that a typical machine can
    access a byte in memory in about 10 nanoseconds. Reading that same byte from an
    SSD takes approximately 1,000,000 nanoseconds or even longer. Reading data from
    external devices is usually about 100,000 to 1,000,0000 times slower than reading
    local data from memory. Think about that when you try to optimize your code if
    you know that your software transfers data to and from external hardware.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 软件几乎从不孤立运行。大多数软件需要在某个时刻超出其边界并访问代码块之外的东西。例如，读取和写入文件、从网络读取数据、向打印机发送数据等等。假设一台典型的机器可以在大约
    10 纳秒内访问内存中的一个字节。从 SSD 读取相同的字节大约需要 1,000,000 纳秒或更长。从外部设备读取数据通常比从内存中读取本地数据慢 100,000
    到 1,000,000 倍。当你尝试优化代码时，如果你知道你的软件在将数据传输到外部硬件和从外部硬件传输数据时，请考虑这一点。
- en: Let’s take this one step further. Let us assume that you have a decent machine
    that can quickly process data. You need to read data from an external website.
    Your program must wait very long before that data is available. It can take milliseconds
    before that data reaches us. For us mere humans, that is pretty fast, but the
    computer could have done a million other tasks in the meantime. That seems like
    a colossal waste of our expensive resources, right?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步。让我们假设你有一台处理数据速度相当快的机器。你需要从外部网站读取数据。你的程序必须等待很长时间，数据才可用。数据到达我们这里可能需要毫秒。对我们这些普通人来说，这已经很快了，但计算机在这段时间内本可以做一百万件其他任务。这似乎是对我们昂贵的资源的巨大浪费，对吧？
- en: Threading can help, of course. You can create a thread to call the external
    website and wait for that to finish, doing other things in the meantime. However,
    as we have seen, threads can be quite cumbersome. The TPL helps, but still, things
    can get complicated. Reading data from external sources or writing data to external
    targets is so common that the CLR designers decided to help us by introducing
    async/await.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 线程当然可以帮助我们。你可以创建一个线程来调用外部网站，并等待它完成，同时做其他事情。然而，正如我们所看到的，线程可能会相当繁琐。TPL 有所帮助，但事情仍然可能变得复杂。从外部源读取数据或将数据写入外部目标如此常见，以至于
    CLR 设计者决定通过引入 async/await 来帮助我们。
- en: 'The top-down approach is simple: anything that takes more time than simple
    operations should be done asynchronously. However, we do not want to deal with
    the threads themselves. Async/await, which uses the TPL internally, is a pattern
    that can help.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 自顶向下的方法很简单：任何耗时超过简单操作的事情都应该异步执行。然而，我们不想直接处理线程本身。Async/await，它内部使用 TPL，是一种可以帮助我们的模式。
- en: 'What it does is this: as soon as you have code that needs to be run asynchronously,
    the compiler injects code that wraps our code into a state machine. This state
    machine tracks the threads and the progress of our code and switches back and
    forth between the blocks of code that need attention.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 它所做的是这样：一旦你有需要异步运行的代码，编译器就会注入代码，将我们的代码包装到一个状态机中。这个状态机跟踪线程和我们的代码的进度，并在需要关注的代码块之间来回切换。
- en: 'Does that sound complicated? Well, it is. The usage, however, is straightforward.
    However, before I show it to you, I want to introduce a little piece of helper
    code I often use when discussing async/await. This code is just an extension method
    on the `string` class and outputs a `string` to the console and adds the `ManagedThreadId`.
    It even allows for coloring the output, making it easier to distinguish between
    the different threads. If you want to use this, go ahead. If you would rather
    use `Console.WriteLine()` everywhere yourself instead, be my guest. However, using
    this makes the critical part of the code more readable. Here is my extension method:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很复杂吗？嗯，确实是。然而，使用方法是直接的。然而，在我向你展示它之前，我想先介绍一个小小的辅助代码，我经常在讨论 async/await 时使用。这段代码只是对
    `string` 类的一个扩展方法，并将一个 `string` 输出到控制台，并添加 `ManagedThreadId`。它甚至允许对输出进行着色，使得区分不同的线程更容易。如果你想使用这个，请随意。如果你宁愿在所有地方都使用
    `Console.WriteLine()`，那也请随意。然而，使用这个可以使代码的关键部分更容易阅读。以下是我的扩展方法：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can also find this code in the GitHub repository.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在GitHub仓库中找到这段代码。
- en: 'First, I want to show you the most simple example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我想给你展示一个最简单的例子：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Imagine that we want do something that takes a long time, such as reading a
    file from storage, in our `DoWork()` method. I have simulated that here by pausing
    the current thread for a second. Our entire program is paused while we call this
    in our main method. Our costly and powerful CPU is left to do nothing (at least
    not for our program). That seems wasteful! We’ve seen that we can use threads
    or the TPL to improve that. However, that code is also wrapped in the async/await
    pattern, so why not use this?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们想在 `DoWork()` 方法中做一件需要很长时间的事情，比如从存储中读取文件。我在这里通过暂停当前线程一秒钟来模拟这一点。当我们在这个主方法中调用它时，整个程序都会暂停。我们昂贵的强大CPU被闲置（至少不是为我们程序）。这似乎很浪费！我们已经看到我们可以使用线程或TPL来改进这一点。然而，这段代码也被包装在
    async/await 模式之中，所以为什么不使用这个呢？
- en: 'To do this, I replaced `Thread.Sleep()` with a call to `Task.Delay()`. That
    more or less does the same thing but allows us to improve on our code. Remember:
    this `Thread.Sleep()` and the new `Task.Delay()` method are just a stand-in for
    the real work your application should be doing. Having a `Sleep()` or `Delay()`
    method in your code is usually a bad idea.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我将 `Thread.Sleep()` 替换为对 `Task.Delay()` 的调用。这基本上做了同样的事情，但允许我们改进我们的代码。记住：这个
    `Thread.Sleep()` 和新的 `Task.Delay()` 方法只是我们应用程序应该做的实际工作的替代品。在代码中有一个 `Sleep()` 或
    `Delay()` 方法通常是一个坏主意。
- en: If you have to call an async method, you must wait for it. So, we will add the
    `await` keyword before the call to `Task.Delay()`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须调用一个异步方法，你必须等待它。所以，我们在调用 `Task.Delay()` 之前添加了 `await` 关键字。
- en: 'Once we have done that replacement, I will also prefix our method with the
    `async` keyword. This keyword tells the compiler that it should wrap this method
    in the state machine I mentioned earlier. However, any async method should never
    return void for reasons that will become clear later. We need to return a `Task`
    or a `Task<>` if you actually return something. So, we changed our void to `Task`.
    Again, any async method needs to be called with the `await` keyword. So, the result
    looks like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了替换，我还会在方法前加上 `async` 关键字。这个关键字告诉编译器应该将这个方法包装在我之前提到的状态机中。然而，任何异步方法都不应该返回
    void，原因将在稍后变得清楚。我们需要返回一个 `Task` 或 `Task<>`，如果你实际上返回了某些内容。所以，我们将我们的 void 改为 `Task`。同样，任何异步方法都需要用
    `await` 关键字来调用。所以，结果看起来像这样：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Run this and see what happens.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个看看会发生什么。
- en: 'You will probably see that the program starts on one thread and then carries
    out the `DoWork()` method on that same thread, but that it switches to a new thread
    when that is done. That is because the compiler sees our `Task.Delay()` await
    and decides to free up the CPU to do other things. The runtime puts our current
    thread on hold and stores its state in memory, leaving our main code free to do
    other things. Only when `Task.Delay()` finishes is our main thread revived. However,
    since the main thread is no longer associated with our code here, we need a new
    thread. That one is pulled from the `ThreadPool` (remember: that is fast since
    the threads there were created at startup) and populated with the state we had.
    Then the system can continue on that thread. The program ends on that new thread
    as well!'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到程序从一个线程开始，然后在同一个线程上执行 `DoWork()` 方法，但完成之后会切换到新的线程。这是因为编译器看到了我们的 `Task.Delay()`
    等待操作，并决定释放 CPU 去做其他事情。运行时将我们的当前线程挂起，并将其状态存储在内存中，这样我们的主代码就可以自由地做其他事情。只有当 `Task.Delay()`
    完成后，我们的主线程才会被恢复。然而，由于主线程不再与我们的代码相关联，我们需要一个新的线程。这个线程是从 `ThreadPool` 中拉取的（记住：那里很快，因为线程是在启动时创建的），并填充了我们之前的状态。然后系统可以继续在这个线程上运行。程序也是在那个新线程上结束的！
- en: I mentioned that all async methods need the async modifier and should return
    a `Task` instead of a void. There is a simple reason for this. If you do not do
    this, your code will work but not as expected. The **Async all the way to the
    top** rule is simple but very important.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到所有异步方法都需要 `async` 修饰符，并应该返回一个 `Task` 而不是 `void`。这样做有一个简单的理由。如果你不这样做，你的代码会工作，但不会像预期的那样。**异步一直到底**规则很简单，但非常重要。
- en: Async all the way to the top!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 异步一直到底！
- en: 'If you have a method containing an `await` keyword, the method needs to be
    async and return a `Task`. However, since you will probably call that method yourself
    somewhere, the calling code must also be async and return some form of `Task`
    or `Task<>`. Since that method is also called… well, you get the idea. The rule
    is: async all the way to the top! Every method in that chain needs to have that
    async!'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个包含 `await` 关键字的方法，那么这个方法必须是异步的，并返回一个 `Task`。然而，由于你可能会在某个地方自己调用这个方法，所以调用代码也必须是异步的，并返回某种形式的
    `Task` 或 `Task<>`。因为这个方法也会被调用……嗯，你明白这个意思。规则是：异步一直到底！链中的每个方法都需要有异步！
- en: Another rule, which is not as strict as the “Async all the way to the top” rule,
    is that all async methods should be named as such. Our `DoWork()` method should
    be renamed to `DoWorkAsync()`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一条规则，它不像“异步一直到底”规则那样严格，是所有异步方法都应该这样命名。我们的 `DoWork()` 方法应该重命名为 `DoWorkAsync()`。
- en: 'However, before we do that, let us see what happens if we are sloppy and do
    not return a `Task`. Try it yourself: replace the `Task` return type with a void
    and remove the await before `DoWork()` (you cannot await a void, so you will get
    an error if you do not remove that).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们这样做之前，让我们看看如果我们粗心大意，没有返回一个 `Task` 会发生什么。试试看：将 `Task` 返回类型替换为 `void`，并在
    `DoWork()` 之前移除 `await`（你不能等待 `void`，所以如果你不移除它，你会得到一个错误）。
- en: Run it. It works just fine, right? Okay, there is no new thread created, but
    who cares? The software does what it needs to do.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它。它运行得很好，对吧？好吧，没有创建新的线程，但谁在乎呢？软件做了它需要做的事情。
- en: 'Now, let’s change our `DoWork()` method a bit:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们稍微修改一下我们的 `DoWork()` 方法：
- en: '[PRE22]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I also temporarily removed the `ReadLine()` to make the program more lifelike.
    The main thread finishes when everything is done.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我也暂时移除了 `ReadLine()`，使程序更贴近现实。主线程在一切完成后结束。
- en: Run it. See that we do not get the `“We’re done with the hard work”` message.
    That makes sense; there is an exception in front of it. However, please notice
    that we also do not see that exception.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它。看到我们没有得到 “我们已经完成了艰苦的工作” 的消息。这是有道理的；它前面有一个异常。然而，请注意，我们也没有看到那个异常。
- en: Why is this? It’s complicated, but the simplified explanation is that the state
    machine is still created since `DoWork` is still an async method. The exception
    is raised on a different thread (after the `Task.Delay()` await). However, since
    the state machine is not configured to wait for all results (because we omitted
    the `await` keywords), it just ignores that thread. If you move that “We’re done
    with the hard work” `Dump()` line to the line before the exception, you will see
    that it is not called. In reality, it *is* called; you just don’t see it. This
    thread has become a fire-and-forget thread. You lost all control over it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会这样？这很复杂，但简化的解释是，由于`DoWork`仍然是一个异步方法，状态机仍然被创建。异常是在不同的线程上抛出的（在`Task.Delay()`等待之后）。然而，由于状态机没有配置为等待所有结果（因为我们省略了`await`关键字），它只是忽略了那个线程。如果你将那个“我们已经完成了艰苦的工作”的`Dump()`行移动到异常之前的行，你会看到它没有被调用。实际上，它*确实*被调用了；你只是没有看到它。这个线程已经变成了一个“发射并遗忘”的线程。你失去了对它的所有控制。
- en: Can you imagine a complex piece of software where something goes wrong deep
    in the bowels of your code? Can you imagine not getting the exception? Can you
    imagine the horror of debugging that?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想象一个复杂的软件，其中在代码深处出了问题吗？你能想象没有获取到异常吗？你能想象调试那个的恐怖吗？
- en: You will get that exception if you use async/await all the way up.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一路使用async/await，你会得到那个异常。
- en: 'Oh, before I forget: the reason that I removed the `Console.ReadKey()` line
    is that by doing so, I forced the main thread to quit as soon as possible, resulting
    in unloading the application from memory. If you restore that line, you will see
    the exception, since the main thread is paused there. Now other things will be
    allowed to happen.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，在我忘记之前：我移除`Console.ReadKey()`行的原因是我这样做迫使主线程尽快退出，从而卸载应用程序从内存中。如果你恢复那行代码，你会看到异常，因为主线程在那里暂停。现在其他事情将被允许发生。
- en: However, that is not really a solution to our problem. You do not want to wait
    for the main thread to become idle before you get exceptions. It could take ages
    for that to happen.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是我们问题的真正解决方案。你不想在获取异常之前等待主线程空闲。这可能需要很长时间才能发生。
- en: Please restore the async/await keywords, replace the void in `DoWork()` with
    `Task`, and run it. The exception is thrown precisely where you would expect it
    to be.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请恢复async/await关键字，将`DoWork()`中的void替换为`Task`，然后运行它。异常正是在你预期的地方抛出的。
- en: 'This is really important, so I like to repeat it once more: async all the way
    to the top!'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的很重要，所以我喜欢重复一遍：从上到下都是异步的！
- en: Task.Wait() and Task.Result
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Task.Wait()和Task.Result
- en: 'There are many blog posts and articles about why you should not use `Task.Wait()`
    or `Task.Result`. The reason for this is pretty simple: these calls block the
    current thread. Using them removes the scheduler’s ability to resume work on the
    calling thread and return to the execution flow when the `Task` is done. If you
    do this, why use async/await in the first place? Async/await also allows for thread
    synchronization, so there is no need to use `Wait()` and `Result`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 关于为什么不应该使用`Task.Wait()`或`Task.Result`有很多博客文章和文章。这个原因很简单：这些调用会阻塞当前线程。使用它们会移除调度器在`Task`完成时恢复调用线程工作并返回执行流程的能力。如果你这样做，为什么还要使用async/await呢？Async/await还允许线程同步，因此不需要使用`Wait()`和`Result`。
- en: 'Hold on. There are some situations where you might decide to use them anyway:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下。有些情况下，你可能会决定仍然使用它们：
- en: You may want to use them if you are working on legacy code that you are modernizing.
    The rule is “Async all the way to the top,” which might require extensive code
    refactoring. That is not always feasible. In those cases, you might use `Wait()`
    and `Result` instead.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在对正在现代化的遗留代码进行工作，你可能想使用它们。规则是“从上到下都是异步的”，这可能需要大量的代码重构。这并不总是可行的。在这些情况下，你可能使用`Wait()`和`Result`代替。
- en: In unit tests, you can mock or stub async methods. However, sometimes it might
    be better for the unit test to use `Wait()` and `Result`.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单元测试中，你可以模拟或存根异步方法。然而，有时单元测试使用`Wait()`和`Result`可能更好。
- en: You might not care about the main thread staying responsive in systems programming.
    There is no user interface, after all. So, blocking the main thread may not be
    a big problem. I still think that it is bad form not to use async/await, but in
    these cases, you can get away with using `Wait()` and `Result`.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在系统编程中，你可能不关心主线程保持响应。毕竟，没有用户界面。所以，阻塞主线程可能不是一个大问题。我仍然认为不使用async/await是不好的做法，但在这种情况下，你可以用`Wait()`和`Result`来解决问题。
- en: As with all rules in software development, be vigilant about these rules and
    apply them as much as possible, only breaking them if you have a good reason and
    have thought about it well. Also, please do your future self a favor and document
    why you chose to deviate from the usual way of working in the source code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 就像软件开发中的所有规则一样，对这些规则保持警惕，尽可能多地应用它们，只有在你有充分的理由并且深思熟虑之后才打破这些规则。此外，请为你未来的自己行个方便，在源代码中记录你选择偏离常规工作方式的原因。
- en: So, now you know how to use async/await. Although they do not always result
    in multiple threads, they are a great way to balance the load in your application.
    They help tremendously in keeping your code organized. You are relieved of the
    burden to do all synchronization between threads. However, that doesn’t mean that
    you never have to care about synchronization at all. There is no avoiding that,
    so I think we should talk about it right now.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在你知道如何使用 async/await。尽管它们并不总是导致多线程，但它们是平衡应用程序负载的绝佳方式。它们在保持代码组织方面大有裨益。你无需再承担在线程之间进行所有同步的负担。然而，这并不意味着你永远不需要关心同步。这是不可避免的，所以我认为我们现在应该讨论一下。
- en: Synchronizing threads
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程同步
- en: 'The async/await pattern has made life easier for us developers. If you have
    a long-running task (and remember: anything that uses devices outside the CPU
    is long-running), you can call that method asynchronously. Then you can sit back
    and wait for it to finish without blocking the execution of your app in other
    places. The TPL takes care of the thread management.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: async/await 模式让我们的开发者生活变得更加容易。如果你有一个长时间运行的任务（记住：任何使用 CPU 之外的设备的事情都是长时间运行的），你可以异步调用该方法。然后你可以坐下来等待它完成，而不会阻塞应用程序其他地方的执行。TPL
    负责线程管理。
- en: However, sometimes you may want to have a bit more control. You might have a
    situation where you must wait for a method to finish before you can continue.
    Imagine that you have your main thread and call the `A()` method. That method
    is long-running, so you make it async (rename it to something ending with ‘async’)
    and change the return type to `Task` or `Task<>`. Now you can wait for it. However,
    another thread might have to wait until your `Aasync()` method is finished. How
    do you do that?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你可能想要有更多的控制权。你可能遇到这样的情况，你必须等待一个方法完成才能继续。想象一下，你有一个主线程并调用 `A()` 方法。该方法运行时间较长，因此你将其改为异步（将其重命名为以“async”结尾的名称）并更改返回类型为
    `Task` 或 `Task<>`。现在你可以等待它。然而，另一个线程可能必须等待你的 `Aasync()` 方法完成。你如何做到这一点？
- en: Welcome to the wonderful world of thread synchronization.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到线程同步的奇妙世界。
- en: Synchronization – how do we do that?
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步——我们如何做到这一点？
- en: In the old days, when we still used threads and the `ThreadPool`, synchronization
    could be a hassle. However, with `Task` and async/await, things have become much
    easier without having real downsides. Before I show you that, I want to show you
    how to synchronize threads instead of tasks.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，当我们仍然使用线程和 `ThreadPool` 时，同步可能会很麻烦。然而，随着 `Task` 和 async/await 的出现，事情变得容易多了，而且没有真正的缺点。在我向你展示这一点之前，我想先展示如何同步线程而不是任务。
- en: 'Let me start with the base program:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我从基础程序开始：
- en: '[PRE23]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This sample should be obvious now. I have two methods that do something that
    takes a long time to finish. I pull some threads out of the `ThreadPool` and run
    all of this simultaneously.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例现在应该很清楚。我有两个方法，它们执行一些需要很长时间才能完成的事情。我从 `ThreadPool` 中拉出一些线程，并使所有这些同时运行。
- en: If you run this, the `Console.ReadKey()` in place. What could we do if we want
    to wait for the two methods to be finished before we move on?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个，在 `Console.ReadKey()` 位置。如果我们想在继续之前等待两个方法完成，我们能做什么？
- en: The answer is to use a synchronization mechanism. This means that we have an
    object that we can use to flag certain states. We can write it ourselves, but
    we must take care of a lot of synchronization and thread safety. Luckily, we do
    not have to. The Win32 API provides tools that are neatly wrapped in BCL classes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是使用同步机制。这意味着我们有一个对象，我们可以用它来标记某些状态。我们可以自己编写它，但我们必须注意很多同步和线程安全问题。幸运的是，我们不必这样做。Win32
    API 提供了一些工具，它们被巧妙地封装在 BCL 类中。
- en: One of these is the `CountdownEvent` class. As the name suggests, it allows
    us to count down events.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一是 `CountdownEvent` 类。正如其名所示，它允许我们进行事件倒计时。
- en: 'Change your main method to look like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的主方法修改如下：
- en: '[PRE24]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We will create a new instance of the `CountdownEvent` class and initialize it
    to `2`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 `CountdownEvent` 类的新实例并将其初始化为 `2`。
- en: Then, we will get the threads and allow them to do their work.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将获取线程并允许它们完成工作。
- en: 'In the code in the methods, I have added one line:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法中的代码，我添加了一行：
- en: '[PRE25]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At the bottom of the method, you will see the `.Signal()` countdown. Since that
    instance is reachable in this method, I can use it. `Signal()` tells the countdown
    to decrease the number of events to wait for.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法底部，你会看到 `.Signal()` 倒计时。由于这个实例在这个方法中是可访问的，我可以使用它。`Signal()` 告诉倒计时减少等待事件的数量。
- en: I did the same to the `DoSomethingForTwoSeconds()` method.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我对 `DoSomethingForTwoSeconds()` 方法也做了同样的处理。
- en: That means that when both methods are done, they call `Signal()` on the countdown.
    In the main method, I added `countdown.Wait()` after the `ThreadPool` code, telling
    the main thread to pause until the countdown reaches zero.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当两个方法都完成后，它们会在倒计时上调用 `Signal()`。在主方法中，我在 `ThreadPool` 代码之后添加了 `countdown.Wait()`，告诉主线程暂停，直到倒计时达到零。
- en: If you run this, you will see it works wonderfully and that the rest of the
    main thread is perfectly synchronized with the threads.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，你会看到它运行得非常出色，并且主线程的其他部分与线程完美同步。
- en: However, what if I want the `DoSomethingForTwoSeconds` method to start when
    `DoSomethingForOneSecond` is finished?
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我想在 `DoSomethingForOneSecond` 完成后启动 `DoSomethingForTwoSeconds` 方法呢？
- en: That is almost as easy. We can use one of the other synchronization classes
    to help us out. Let me show you how to do this using the `ManualResetEvent`. This
    class does more or less the same as the `CountdownEvent`. The difference is that
    the `ManualResetEvent` class does not count; it just waits for a signal.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎同样简单。我们可以使用其他同步类之一来帮助我们。让我展示如何使用 `ManualResetEvent` 来完成这个操作。这个类或多或少与 `CountdownEvent`
    类似。区别在于 `ManualResetEvent` 类不计数，它只是等待信号。
- en: 'In the main method, before calling the `ThreadPool`, I have added this line:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在主方法中，在调用 `ThreadPool` 之前，我添加了这一行：
- en: '[PRE26]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: I have set it in the initial `False` state. Doing so results in any thread waiting
    for the event to be set.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我将其设置为初始的 `False` 状态。这样做会导致任何线程等待事件被设置。
- en: 'In `DoSomethingForOneSecond()`, I have added one line right at the end:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DoSomethingForOneSecond()` 中，我在最后添加了一行：
- en: '[PRE27]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The call to `Set` tells the `ManalResetEvent` that any waiting thread can continue.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `Set` 的调用告诉 `ManualResetEvent` 任何等待的线程都可以继续。
- en: 'In `DoSomethingForTwoSeconds()`, I have added the following to the beginning
    of the method:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DoSomethingForTwoSeconds()` 中，我在方法的开头添加了以下内容：
- en: '[PRE28]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`WaitOne()` tells the code to pause the thread until the `mre` gets a signal
    (which happens at the end of `DoSomethingForOneSecond()`).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`WaitOne()` 告诉代码暂停线程，直到 `mre` 收到信号（这发生在 `DoSomethingForOneSecond()` 的末尾）。'
- en: If you run your program now, you will notice that everything is nicely synchronized
    and waiting for other stuff to finish.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行你的程序，你会注意到一切都很完美地同步，等待其他任务完成。
- en: 'Of course, you might have achieved precisely the same result by not using threads.
    We have basically removed all multitasking from our application. If you need to
    synchronize threads, now you know how. However, be careful: you might introduce
    weird errors if you make mistakes. Trust me: debugging multithreaded applications
    is no walk in the park.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能通过不使用线程就达到了完全相同的结果。我们基本上从我们的应用程序中移除了所有多任务。如果你需要同步线程，现在你知道如何做了。然而，要小心：如果你出错，可能会引入奇怪的错误。相信我：调试多线程应用程序可不是件轻松的事。
- en: Synchronization with async/await
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 async/await 进行同步
- en: You might have guessed by now that using async/await dramatically reduces the
    complexity of working with threads and synchronizing between them.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经猜到了，使用 async/await 可以显著降低处理线程和它们之间同步的复杂性。
- en: Let us return to our example of the `DoSomethingForOneSecond` and `DoSomethingForTwoSeconds`
    methods. This time, we will rewrite them to use async/await.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `DoSomethingForOneSecond` 和 `DoSomethingForTwoSeconds` 方法的例子。这次，我们将重新编写它们以使用
    async/await。
- en: 'Your `DoSomethingForOneSecond` should be like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `DoSomethingForOneSecond` 应该是这样的：
- en: '[PRE29]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: I renamed the function to end with async, as I should have done much earlier.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我将函数重命名，以异步结尾，因为我应该早就这样做。
- en: The `DoSomethingForTwoSecondsAsync()` should get the same treatment.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoSomethingForTwoSecondsAsync()` 应该得到同样的处理。'
- en: 'Calling the methods in the main method now looks like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在主方法中调用这些方法现在看起来是这样的：
- en: '[PRE30]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The results are identical to those from the example where we did all the synchronization
    ourselves, with the only difference being that we have no blocking threads anymore.
    So this is not only easier to do but it is also much better.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与我们在自己进行所有同步的示例中得到的相同，唯一的区别是我们不再有阻塞的线程。所以这不仅更容易做，而且也更好。
- en: However, what happens if we do not want to do the methods sequentially? What
    if we want them to run simultaneously?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们不想按顺序执行这些方法，而是想让它们同时运行会怎样？如果我们想让它们同时运行会怎样？
- en: 'Well, that is easy enough. Since our methods return a `Task`, we can work with
    that. Instead of waiting for them individually, we can simultaneously wait for
    them. Let me show you:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这很简单。由于我们的方法返回一个 `Task`，我们可以处理它。我们不是逐个等待它们，而是可以同时等待它们。让我给你展示一下：
- en: '[PRE31]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We will take advantage of the fact that we get tasks back. The `Task` class
    has a static method called `WaitAll()` that only returns when all tasks are finished.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用我们获取任务的事实。`Task` 类有一个名为 `WaitAll()` 的静态方法，它只有在所有任务都完成时才返回。
- en: There are other methods, such as `WaitAny` (only continue when any of the tasks
    finish), WhenAll (do something when they are all done), and WhenAny (you can figure
    this out by yourself).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法，例如 `WaitAny`（只有当任何任务完成时才继续），`WhenAll`（当它们都完成时执行某些操作），以及 `WhenAny`（你可以自己弄清楚）。
- en: The difference between `WaitAll` or `WaitAny` and `WhenAll` or `WhenAny` is
    that `WaitXXX` is a blocking call. It blocks the current thread until the condition
    has been met`. WhenXXX` returns a Task itself that you can await and thus does
    not block the thread.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`WaitAll` 或 `WaitAny` 与 `WhenAll` 或 `WhenAny` 之间的区别在于 `WaitXXX` 是一个阻塞调用。它会阻塞当前线程，直到条件满足。`WhenXXX`
    返回一个 Task 本身，你可以 await 它，因此不会阻塞线程。'
- en: 'However, there is a bigger difference: `WhenAll` allows you to capture the
    return result. If any tasks that you want to wait for return a result, you can
    get that with `WhenAll`. `WhenAll` returns the results to you in an array. You
    can get at them, which is something you cannot do with `WaitAll` or `WaitAny`.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个更大的区别：`WhenAll` 允许你捕获返回的结果。如果你想要等待完成的任何任务返回一个结果，你可以通过 `WhenAll` 获取它。`WhenAll`
    将结果以数组的形式返回给你。你可以访问它们，这是 `WaitAll` 或 `WaitAny` 无法做到的。
- en: In case you were wondering, `WhenAny` returns a `Task<T>`. That `Task<T>` has
    a property called `Result`; you can read that property to get access to the result
    of that Task. This is one example when using `Result` is actually a good thing!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有所怀疑，`WhenAny` 返回一个 `Task<T>`。这个 `Task<T>` 有一个名为 `Result` 的属性；你可以读取这个属性来获取对那个
    Task 结果的访问。这是一个使用 `Result` 实际上是一件好事的例子！
- en: Canceling a thread
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消线程
- en: 'Sometimes, you want to stop a thread from running. There might be several good
    reasons to do this, but whatever your reason, be sure to clean up after yourself.
    Threads are expensive to use and leaving them in an unknown state is a horrible
    practice: you shoot yourself in the foot one day.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能想要停止一个线程的运行。这样做可能有几个很好的理由，但无论你的理由是什么，一定要清理自己的“战场”。线程使用起来成本很高，将它们留在未知状态是一种糟糕的做法：你有一天会自食其果。
- en: In the days of.NET Framework, the `Thread` class had a method called `Abort()`.
    However, it turned out that the method did more harm than good, so the BCL and
    CLR people decided to get rid of it. If you try to abort a thread, you will get
    a `PlatformNotSupportedException`. I guess they really do not want us to use that
    anymore.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET Framework 的日子里，`Thread` 类有一个名为 `Abort()` 的方法。然而，结果证明这个方法弊大于利，因此 BCL 和
    CLR 的人决定废除它。如果你尝试中止一个线程，你会得到一个 `PlatformNotSupportedException`。我想他们真的不希望我们再使用它了。
- en: 'The best way to stop a running thread is the same way you should stop a running
    `Task`: using something we call **cooperative cancellation**. A calling thread
    can request another thread to stop. It is up to that second thread to honor that
    request – or not. There is no guarantee.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 停止正在运行的线程的最佳方式与停止正在运行的 `Task` 的方式相同：使用我们称之为**协作取消**的东西。调用线程可以请求另一个线程停止。这取决于第二个线程是否遵守那个请求——或者不遵守。没有保证。
- en: The standard way of doing this is by using a `CancellationToken`. A `CancellationToken`
    is an object we use to signal that we want to cancel something.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的标准方式是使用一个 `CancellationToken`。`CancellationToken` 是我们用来表示我们想要取消某事的信号的对象。
- en: Of course, you can write this class yourself. There is not much going on besides
    some thread safety. However, having a `CancellationToken` in your threads or tasks
    makes it clear to the user that it can be canceled.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以自己编写这个类。除了线程安全之外，没有太多的事情发生。然而，在你的线程或任务中包含一个 `CancellationToken` 可以清楚地让用户知道它可以被取消。
- en: 'I am going to rewrite our `DoSomethingForOneSecondAsyncMethod()` a bit:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我将稍微重写我们的 `DoSomethingForOneSecondAsyncMethod()`：
- en: '[PRE32]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Instead of having the `Task.Delay(1000)` call, I do `1000` await `Task.Delay1)`.
    In theory, that would result in a one-second delay. However, when you run this,
    it takes considerably longer. The await call itself takes up some time as well.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 代替使用`Task.Delay(1000)`调用，我使用`1000` await `Task.Delay1)`。从理论上讲，这将导致一秒的延迟。然而，当你运行这个时，它实际上会花费更长的时间。await调用本身也会占用一些时间。
- en: I could measure how long it takes and then recalculate the number of iterations,
    or I could simply rename the method to `DoSomethingForSomeUnderterminedAmountOfTimeAsync()`.
    I will leave that decision up to you.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以测量它花费的时间然后重新计算迭代次数，或者我可以简单地将方法重命名为`DoSomethingForSomeUnderterminedAmountOfTimeAsync()`。我将把这个决定留给你。
- en: Assume that we get bored after 500 milliseconds after waiting in our main method
    and decide to stop this thread. How would we achieve that?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在主方法中等待了500毫秒后感到无聊，并决定停止这个线程。我们该如何实现这一点？
- en: This is where the `CancellationToken` steps in. Again, a `CancellationToken`
    is a simple class. You can create one if you want to, but it is better to use
    a specialized class. This `CancellationTokenSource` class is created specifically
    for this and works in all sorts of weird conditions. It is inherently thread-safe.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`CancellationToken`发挥作用的地方。再次强调，`CancellationToken`是一个简单的类。如果你想创建一个，当然可以，但最好使用一个专门的类。这个`CancellationTokenSource`类就是为此而创建的，并且能在各种奇怪的情况下工作。它是线程安全的。
- en: 'Let us create one right at the beginning of the main method:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在主方法的开始处创建一个：
- en: '[PRE33]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: I use `WaitAny` here because we want to cancel that task after the moment when
    we create it and before it has finished. Also, note the `using` statement. `CancellationTokenSource`
    implements `IDisposable`, so we must honor that.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用`WaitAny`是因为我们想在创建任务后和它完成前取消该任务。同时，注意`using`语句。`CancellationTokenSource`实现了`IDisposable`接口，因此我们必须遵守这一点。
- en: 'Canceling is simple. Between the `var task1` and `Task.WaitAny()` lines, add
    the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 取消很简单。在`var task1`和`Task.WaitAny()`行之间，添加以下内容：
- en: '[PRE34]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We will wait a bit, then get bored and call `cts.Cancel()`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会等待一会儿，然后感到无聊并调用`cts.Cancel()`。
- en: However, if you run this, nothing will happen. That’s not entirely true; many
    things will happen. To be precise, the entire loop in `DoSomethingForOneSecondAsync`
    happens.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你运行这个，什么都不会发生。这并不完全正确；会有很多事情发生。更准确地说，`DoSomethingForOneSecondAsync`中的整个循环都会发生。
- en: '`CancellationToken` is not a magic way to cancel running tasks. You have to
    check for that token yourself.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`CancellationToken`并不是取消正在运行的任务的魔法方法。你必须自己检查这个令牌。'
- en: 'We have to add a parameter to our method of the `CancellationToken` type. The
    method signature will now look like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须给我们的方法添加一个`CancellationToken`类型的参数。现在方法签名将看起来像这样：
- en: '[PRE35]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We have to pass in that token when we call it. In our main method, change the
    line calling this method to this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在调用它时必须传入这个令牌。在我们的主方法中，将调用此方法的行更改为以下内容：
- en: '[PRE36]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We will take our `CancellationTokenSource` and get its token. That is what we
    will pass on to our method.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获取我们的`CancellationTokenSource`并获取它的令牌。这就是我们将传递给我们的方法的。
- en: 'Inside our method, we must check to see whether we need to cancel. Yes, that
    is why I added the loop around the `Delay`. The full method will now look like
    this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的方法内部，我们必须检查是否需要取消。是的，这就是为什么我在`Delay`周围添加了循环。现在完整的方法将看起来像这样：
- en: '[PRE37]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If someone calls `Cancel` on the `CancellationTokenSource`, the `IsCancellationRequested`
    flag on the token will be set to `True`. We have to honor that. I do that by breaking
    out of the `for` loop. I have also set a `hasBeenCancelled` variable to `True`
    so I can inform our users that we have canceled this loop and tell them after
    how many iterations it was canceled.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人调用`CancellationTokenSource`的`Cancel`，令牌上的`IsCancellationRequested`标志将被设置为`True`。我们必须尊重这一点。我通过跳出`for`循环来实现这一点。我还设置了一个`hasBeenCancelled`变量，这样我就可以通知我们的用户我们已经取消了循环，并告诉他们是在多少次迭代后取消的。
- en: We could have skipped this boolean and used `IsCancellationRequested` again.
    However, there might have been a risk of the request coming in right after the
    loop was done but before the printing of the message. In that case, the loop was
    not interrupted. But we said it was anyway, which is incorrect. This way we avoid
    printing the wrong message.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以跳过这个布尔值并再次使用`IsCancellationRequested`。然而，可能存在这样的风险：请求是在循环完成后、打印消息之前到达的。在这种情况下，循环没有被中断。但我们还是说它被中断了，这是不正确的。这样我们就可以避免打印错误的消息。
- en: Run it and see what happens. On my machine, I get about 40 iterations before
    it cancels.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它并看看会发生什么。在我的机器上，它大约迭代了40次后就会取消。
- en: There is one bug in this code. It is good practice to pass on the `CancellationToken`
    to any method that accepts it. In our case, that would be `Task.Delay()`. There
    is an overload that accepts a `CancellationToken`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中有一个错误。将`CancellationToken`传递给任何接受它的方法是一种良好的实践。在我们的例子中，那就是`Task.Delay()`。它有一个接受`CancellationToken`的重载。
- en: 'I deliberately left that out here. Since the code would be in that line almost
    100% of the time, awaiting the Delay, we would cancel that and never see any printed
    messages. However, let’s now add it:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意在这里省略了它。因为代码几乎100%的时间都会在那个行上，等待Delay，我们会取消它，永远不会看到任何打印的消息。然而，现在让我们添加它：
- en: '[PRE38]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Rerun it and see what happens.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行它并看看会发生什么。
- en: You might notice that we are missing a lot of screen output. The reason is simple.
    `Task.Delay()` throws an `OperationCancelledException` when it is canceled. However,
    we are not using `await` on our `Task` in the main method, so we will miss the
    exception. Remember when I said it was all too easy to miss exceptions when not
    everything is done right?
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们缺少了很多屏幕输出。原因很简单。`Task.Delay()`在取消时抛出`OperationCancelledException`。然而，我们在主方法中没有在`Task`上使用`await`，所以我们会错过这个异常。记得我之前说过，当一切没有做对的时候，错过异常是多么容易吗？
- en: Synchronization helps to prevent errors from happening. However, there are a
    lot of techniques to make sure our code is thread-safe. Let’s dive into those
    now.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 同步有助于防止错误发生。然而，有许多技术可以确保我们的代码是线程安全的。现在让我们深入探讨这些技术。
- en: Thread-safe programming techniques
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程安全编程技术
- en: 'Look at this piece of code. Run it and see what happens:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这段代码。运行它并看看会发生什么：
- en: '[PRE39]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We have a `Task` that counts down from 100 to 0\. Since we `await` this, the
    main part of the code waits nicely for this to finish before continuing. However,
    we also have a second thread that waits for 500 milliseconds and then sets the
    counter to `0`. The result is that the loop finishes prematurely.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个从100倒数到0的`Task`。由于我们在这里`await`它，代码的主要部分会优雅地等待这个操作完成后再继续。然而，我们还有一个等待500毫秒后设置计数器为`0`的第二个线程。结果是循环提前结束。
- en: What we see here is easy to debug. Every line of code is one screen, so I imagine
    that you will be able to spot the bug quite easily.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的是容易调试的。每一行代码都在一个屏幕上，所以我猜想你将能够很容易地找到这个错误。
- en: However, what if the integer used here is a member of a class? As you know,
    instances of classes are reference types. Reference types get passed on by reference,
    not by value. So if the Task has access to that instance, it can alter the members
    in that instance. However, every other task, thread, or piece of code sees the
    effects of that.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果这里使用的整数是类的一个成员呢？正如你所知，类的实例是引用类型。引用类型是通过引用传递的，而不是通过值。所以如果Task可以访问那个实例，它可以改变那个实例的成员。然而，其他任何任务、线程或代码都会看到这些变化的效果。
- en: Thread safety is all about avoiding these kinds of things.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 线程安全就是避免这些情况。
- en: Value types are inherently safe. You will have no issues if you pass a value
    type such as integer to your `Task`. The value of the integer is copied and you
    are not changing the original value.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型本质上是安全的。如果你将一个整数值类型等值类型传递给`Task`，你将不会有任何问题。整数的值被复制，你并没有改变原始值。
- en: However, if you need to access more complex types, you will need to think about
    this. The good news is that the runtime offers us several tools to mitigate this
    issue.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你需要访问更复杂的数据类型，你需要考虑这一点。好消息是运行时为我们提供了几个工具来减轻这个问题。
- en: One of the tools you get is the `Lock()` keyword.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到的一个工具是`Lock()`关键字。
- en: Lock()
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lock()
- en: 'The simplest way to safeguard your data is to have a lock around it. A lock
    is an object that more or less works as a moat around a piece of code. A lock
    ensures that only one thread can simultaneously be in that code block. The syntax
    is straightforward:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 保护你的数据最简单的方法是在它周围使用锁。锁是一个对象，它在一定程度上就像是一段代码的护城河。锁确保只有一个线程可以同时进入那个代码块。语法很简单：
- en: '[PRE40]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The lock takes one argument. It uses this to identify the area to lock. It doesn’t
    do anything with this object; this is just something to hook the lock to. So,
    having a new `object()` will suffice.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 锁接受一个参数。它使用这个参数来识别要锁定的区域。它对这个对象不做任何事情；这只是为了将锁钩到某个地方。所以，有一个新的`object()`就足够了。
- en: Any code in this code block is safe, meaning that only one thread can decrement
    the `iterationCount` simultaneously. When another thread tries to do the same
    thing simultaneously, it blocks as soon as it reaches the lock statement. That
    thread remains blocked until the previous threat exits the code block.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块中的任何代码都是安全的，这意味着只有一个线程可以同时递减`iterationCount`。当另一个线程尝试同时执行相同的操作时，它会在到达锁语句时立即阻塞。那个线程会一直阻塞，直到之前的线程退出代码块。
- en: 'Yes, this means that if the other thread crashes in that code (not very likely
    in this example: crashing on a `--` operator happens very infrequently), the rest
    of the system can never enter that code block.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这意味着如果其他线程在那个代码中崩溃（在这个例子中不太可能：在`--`运算符上崩溃非常罕见），整个系统永远无法进入那个代码块。
- en: '`Lock()` is syntactic sugar around a monitor object. The compiler actually
    uses `Monitor`s. So, the following code results in the same IL (Intermediate language):'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lock()`是围绕监视器对象的一种语法糖。编译器实际上使用`Monitor`s。所以，以下代码会产生相同的中间语言（IL）：'
- en: '[PRE41]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: I do not know about you, but the `lock()` statement looks much more effortless
    to me.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你，但对我来说，`lock()`语句看起来要轻松得多。
- en: Records
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录
- en: The best way to ensure that data is not accidentally overridden is to ensure
    that the data cannot be altered. Immutable types are designed to do just that.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 确保数据不会意外覆盖的最佳方式是确保数据不能被更改。不可变类型正是为此而设计的。
- en: 'Let me create a record first:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我先创建一个记录：
- en: '[PRE42]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: A record is a reference type, so its memory is allocated on the heap. However,
    records are meant to be immutable. You can create records that are not immutable,
    but that does not help us here.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 记录是一种引用类型，所以它的内存是在堆上分配的。然而，记录旨在是不可变的。你可以创建不可变的记录，但这在这里没有帮助。
- en: Right now, I have a record with one member, `InitialValue`. I have to set the
    value for that when constructing the `Counter`, but I can never change it after
    that. So, no thread can come along and mess with that value anymore.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我有一个只有一个成员`InitialValue`的记录。在构建`Counter`时，我必须设置该值，但之后我永远不能更改它。所以，没有线程可以再来修改这个值了。
- en: 'However, since I cannot change it anywhere, I also have to change the code
    in the `Task`. It will now look like this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我无法在任何地方更改它，我也必须在`Task`中的代码进行更改。现在它看起来是这样的：
- en: '[PRE43]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: I have made a copy of the value to decrement that in the loop. If you are a
    bit like me, you might say, “Wait a minute. Why didn’t I just copy that original
    `iterationCount` to a local variable and use that instead of this record?”
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经复制了值并在循环中递减它。如果你和我有点相似，你可能会说，“等等。为什么我没有只是将原始的`iterationCount`复制到一个局部变量中，并使用它而不是这个记录？”
- en: I see many people doing that. However, that is not guaranteed to work. What
    if a separate thread changes the value of `iterationCount` before you can make
    a copy? You would start with the wrong initial value.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到很多人这样做。然而，这并不保证能行得通。如果你在复制之前另一个线程改变了`iterationCount`的值怎么办？你将从一个错误的初始值开始。
- en: Immutable records guarantee that the values inside it do not change, ever. Period.
    You are safe.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变记录保证其内部值永远不会改变，永远如此。你很安全。
- en: Avoid static members and classes
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用静态成员和类
- en: 'I know that it can be a nuisance to create instances of classes. Sometimes,
    it seems easier to create a static class filled with static members and use those
    instead. They certainly do have some use cases. However, remember this: static
    classes are not thread-safe out of the box. Static members are shared across threads
    so that anybody can change them.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道创建类的实例可能会很麻烦。有时，似乎更容易创建一个静态类，其中包含静态成员，并使用它们代替。它们确实有一些用例。然而，请记住这一点：静态类默认不是线程安全的。静态成员在多个线程之间共享，因此任何人都可以更改它们。
- en: Using the volatile keyword
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`volatile`关键字
- en: 'Sometimes, code seems straightforward, but it might not be. Look at this line:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，代码看起来很简单，但可能并非如此。看看这一行：
- en: '[PRE44]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We know how this works. This integer is on the stack. If we change the value,
    the value at that memory address changes. Simple, right? Wrong. The compiler does
    all sorts of tricks to optimize our code, especially when you build it in Release
    mode. Building in Release mode means that the compiler might cache the value of
    even a simple integer to speed things up. It might even decide to move that line
    to another place in the code if it thinks it will not make a difference in the
    execution.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这是如何工作的。这个整数位于栈上。如果我们更改其值，该内存地址的值也会改变。简单，对吧？错了。编译器会使用各种技巧来优化我们的代码，尤其是在你以发布模式构建时。以发布模式构建意味着编译器可能会缓存简单整数的值以加快速度。它甚至可能决定将这一行移动到代码的另一个位置，如果它认为这不会影响执行。
- en: That is not a problem until multiple threads or tasks deal with that code. The
    compiler might make mistakes. It cannot determine which tasks can access that
    variable simultaneously.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是问题，直到多个线程或任务处理这段代码。编译器可能会出错。它无法确定哪些任务可以同时访问该变量。
- en: Yes, even simple writing to an integer can go wrong in a multithreaded system.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，即使在多线程系统中简单地写入一个整数也可能出错。
- en: If we use `lock()`, we can guarantee that only one thread can access that code
    block, but that still does not mitigate the issue of the compiler optimizations.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`lock()`，我们可以保证只有一个线程可以访问那个代码块，但这仍然不能减轻编译器优化的影响。
- en: 'To solve this problem, we can use the `volatile` keyword. It looks like this:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以使用`volatile`关键字。它看起来是这样的：
- en: '[PRE45]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Instead of using a cached value, the compiler ensures that we always go directly
    to the memory address and stored value. That means that all threads will go to
    the same place and work with the same integer, thus eliminating the risk of working
    on old, stale, or cached data.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用缓存值不同，编译器确保我们始终直接访问内存地址和存储的值。这意味着所有线程都将前往同一位置并使用相同的整数，从而消除了在旧、过时或缓存数据上工作的风险。
- en: You might be tempted to add that `volatile` keyword everywhere, but I suggest
    that you refrain. It does mess with the compiler’s optimization techniques. You
    should only use it if you suspect that there might be an issue with that particular
    piece of code.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想将`volatile`关键字添加到每个地方，但我建议你避免这样做。它会干扰编译器的优化技术。你应该只在怀疑特定代码片段可能存在问题时使用它。
- en: 'So, now you know how to be more safe when dealing with threads. This is very
    important: if you mess things up you can get horrible and hard-to-debug bugs in
    your code. This is especially true if you are dealing with collections in multiple
    threads. How do you keep them synchronized? We’re in luck though; the BCL has
    got us covered there. Let’s talk about concurrent collections.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在你知道如何在与线程打交道时更加安全。这非常重要：如果你搞砸了，你可能会在代码中遇到可怕且难以调试的错误。这尤其适用于你在多个线程中处理集合的情况。你是如何保持它们同步的？幸运的是，BCL已经为我们解决了这个问题。让我们来谈谈并发集合。
- en: Concurrent collections in .NET
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET中的并发集合
- en: 'Collections are the backbone of many programs. Arrays, lists, dictionaries
    – we use them all the time. However, are they thread-safe? Let us find out:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是许多程序的核心。数组、列表、字典——我们经常使用它们。然而，它们是线程安全的吗？让我们来了解一下：
- en: '[PRE46]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We have a `List<string>`. Then we added 1000 strings to that list We have a
    task that iterates through them, displays them on the screen, and waits a bit.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`List<string>`。然后我们向该列表中添加了1000个字符串。我们有一个任务会遍历它们，将它们显示在屏幕上，并稍作等待。
- en: We also have a separate thread that clears the list after waiting for a second.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个单独的线程在等待一秒后清除列表。
- en: If you have read the previous section in this chapter, you might expect the
    loop in the task to abort prematurely. It should not print all items, since the
    list is suddenly empty and thus the `ForEach()` stops.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了本章前面的部分，你可能会预期任务中的循环会提前终止。它不应该打印所有项目，因为列表突然为空，因此`ForEach()`停止。
- en: However, if you run it, you will see a different result. You will get a nice
    `InvalidOperationException` telling you that the collection was modified, which
    messed up the `ForEach` code.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你运行它，你会看到不同的结果。你会得到一个友好的`InvalidOperationException`，告诉你集合已被修改，这破坏了`ForEach`代码。
- en: Collections in the BCL are not thread-safe. If one thread works with them and
    another decides it needs to deal with that collection, things go wrong.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: BCL中的集合不是线程安全的。如果一个线程正在处理它们，而另一个线程决定需要处理那个集合，事情就会出错。
- en: 'The following collections are not thread-safe and should be avoided when working
    with tasks:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 以下集合不是线程安全的，在处理任务时应避免使用：
- en: '`List<T>`'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<T>`'
- en: '`Dictionary<TKey` and `TValue>`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dictionary<TKey` 和 `TValue>`'
- en: '`Queue<T>`'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Queue<T>`'
- en: '`Stack<T>`'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stack<T>`'
- en: '`HashSet<T>`'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HashSet<T>`'
- en: '`ArrayList`'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayList`'
- en: '`HashTable`'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HashTable`'
- en: '`SortedList<TKey`, `TValue>`, and `TSortedList`'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SortedList<TKey`, `TValue>`, 和 `TSortedList`'
- en: Do not use these in multiple threads or tasks simultaneously.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在多个线程或任务中同时使用这些。
- en: 'Some collections are thread-safe. This is what they are and what they do:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 一些集合是线程安全的。以下是它们的用途：
- en: '| **Collection name** | **Description** |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| **集合名称** | **描述** |'
- en: '| --- | --- |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ConcurrentDictionary<TKey, TValue>` | A thread-safe collection of key-value
    pairs. It allows for concurrent adds, updates, and removals. |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `ConcurrentDictionary<TKey, TValue>` | 一个线程安全的键值对集合。它允许并发添加、更新和删除。|'
- en: '| `ConcurrentQueue<T>` | A thread-safe version of a **First-in, First-out**
    (**FIFO**) collection. |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `ConcurrentQueue<T>` | 一个线程安全的**先进先出**（FIFO）集合版本。|'
- en: '| `ConcurrentStack<T>` | A thread-safe version of a **Last-in, First-out**
    (**LIFO**) collection. |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `ConcurrentStack<T>` | 一个线程安全的**后进先出**（LIFO）集合版本。|'
- en: '| `ConcurrentBag<T>` | A thread-safe, unordered collection of objects. It is
    suitable for scenarios where the order is not important. |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `ConcurrentBag<T>` | 一个线程安全、无序的对象集合。适用于顺序不重要的场景。|'
- en: '| `BlockingCollection<T>` | Represents a thread-safe collection that can be
    bounded in size. It provides blocking and non-blocking `add` and `take` operations.
    |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `BlockingCollection<T>` | 表示一个可以限制大小的线程安全集合。它提供阻塞和非阻塞的`add`和`take`操作。|'
- en: 'Table 4.3: Thread-safe collections'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.3：线程安全集合
- en: 'The first four collections are just thread-safe versions of the collections
    that we already know. Most people, however, would not recognize the last one:
    the `BlockingCollection<T>` collection.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个集合只是我们已知的集合的线程安全版本。然而，大多数人可能不会认出最后一个：`BlockingCollection<T>`集合。
- en: 'This collection is, first of all, thread-safe. It also allows for blocking.
    Let me give you an example:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集合首先是一个线程安全的集合。它还允许阻塞。让我给你举个例子：
- en: '[PRE47]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: A lot is happening here, so let me walk you through it.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，让我带你了解一下。
- en: First, we created an instance of the `BlockingCollection`. This class has a
    nice overloaded constructor that only allows this number of items to be added.
    If there are more, block the thread. I do not need that functionality here, but
    I found adding it funny.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个`BlockingCollection`的实例。这个类有一个很好的重载构造函数，它只允许添加这个数量的项目。如果有更多，则阻塞线程。我这里不需要这个功能，但我发现添加它很有趣。
- en: Then we spun up a new thread that adds items to this collection. We can try
    to add 10, but again, it only allows five items. So, when the fifth item is added,
    this thread blocks until we have removed one of those items.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们启动了一个新线程，向这个集合添加项目。我们可以尝试添加10个，但同样，它只允许五个项目。所以，当第五个项目被添加时，这个线程会阻塞，直到我们移除其中一个项目。
- en: At the end of the loop, we told the collection that we had nothing left to add.
    We did this by calling `CompleteAdding()`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环结束时，我们告诉集合我们没有剩下要添加的内容。我们通过调用`CompleteAdding()`来完成这个操作。
- en: Before we read the data in the second thread, we waited for a few seconds so
    the first one had time to fill the collection.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们读取第二个线程中的数据之前，我们等待了几秒钟，以便第一个线程有时间填充集合。
- en: The second thread (third if you also count the main thread) took that collection
    and took an item from it. It is a FIFO collection, so the first item we could
    take was the first item added to the list. We displayed what we took and waited
    a bit. We needed to catch the `InvalidOperationException`. If the `CompleteAdding`
    was called due to timings by the time we had already taken all the items from
    the collection, an exception would have occurred. We need to catch that.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个线程（如果你也计算主线程的话是第三个）从这个集合中取出了一个项目。它是一个先进先出（FIFO）的集合，所以我们可以取出的第一个项目是列表中第一个添加的项目。我们展示了我们取出的内容，并等待了一段时间。我们需要捕获`InvalidOperationException`。如果在我们已经从集合中取出所有项目之后，由于时间原因调用了`CompleteAdding`，将会发生异常。我们需要捕获这个异常。
- en: Due to our timings and `Thread.Sleep()` calls, we will see a fascinating effect.
    The first thread fills up the collection with five items. Then it waits. This
    operation takes five seconds in total. Six seconds after the start of the program,
    we will start taking items. Since there are plenty of them (five to be exact),
    the program will print these items on the screen quickly. When we take one item,
    the first thread gets permission to add a new item. However, since it takes a
    second to add an item, the second thread has to wait until it has been added.
    `Take()` will also block if there is nothing to take yet.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的时间安排和`Thread.Sleep()`调用，我们将看到一个迷人的效果。第一个线程用五个项目填充集合。然后它等待。这个操作总共需要五秒钟。程序开始后的六秒钟，我们将开始取项目。由于项目很多（确切地说有五个），程序将快速将这些项目打印到屏幕上。当我们取一个项目时，第一个线程获得添加新项目的权限。然而，由于添加一个项目需要一秒钟，第二个线程必须等待直到项目被添加。如果还没有可取的项目，`Take()`也会阻塞。
- en: Only when the first thread calls the `CompleteAdding()` method does the second
    thread know it is done (since we checked the `IsCompleted` property). Then, we
    can exit the threads.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当第一个线程调用`CompleteAdding()`方法时，第二个线程才知道它已经完成（因为我们检查了`IsCompleted`属性）。然后，我们可以退出线程。
- en: There is much synchronization behind the scenes, but it works amazingly well.
    This is undoubtedly an excellent addition to your toolbox!
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后有许多同步操作，但它工作得非常出色。这无疑是您工具箱中的一个优秀补充！
- en: Next steps
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: That was quite a ride. Threading can be complicated, but we got through it all
    right.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是一次相当刺激的经历。线程编程可能很复杂，但我们成功地完成了所有这些。
- en: We looked at many different things in this chapter. We described what multitasking
    is, starting with old-fashioned IRQs, walking through cooperative multitasking,
    and arriving at the modern style of pre-emptive multitasking.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了众多不同的事情。我们描述了多任务是什么，从老式的中断请求（IRQs）开始，经过协作多任务，最终到达现代的抢占式多任务。
- en: Then, we investigated Win32 threads and their .NET counterparts. We saw how
    to create threads but quickly found that the `Threadpool` offers a better way
    of doing so in most cases. However, we learned that most of that is moot, since
    the TPL handles many details for us.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们研究了Win32线程及其.NET对应物。我们看到了如何创建线程，但很快发现`Threadpool`在大多数情况下提供了更好的方法。然而，我们了解到大多数这些都是多余的，因为TPL为我们处理了很多细节。
- en: In particular, we learned that async/await hides much complexity and makes writing
    multithreaded code a breeze. As with all tools, we learned that async/await comes
    with risks. You have to know what happens and where bad things can happen. Luckily,
    we covered those situations as well.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们了解到async/await隐藏了很多复杂性，使得编写多线程代码变得轻而易举。就像所有工具一样，我们也了解到async/await伴随着风险。您必须知道会发生什么，以及坏事情可能发生在哪里。幸运的是，我们也涵盖了那些情况。
- en: 'We looked at collections and how to make your code thread-safe. We also learned
    something fundamental regarding async/await: async all the way to the top!'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了集合以及如何使您的代码线程安全。我们还学习了一些关于async/await的基本知识：从底层到顶层的async！
- en: Asynchronous programming is imperative when dealing with devices outside the
    CPU. One of the areas where we need to use these techniques extensively is in
    the file system. However, file systems have a lot of other things that you need
    to know about. So, it’s great that the next chapter deals with that topic!
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程在处理CPU外部的设备时是必不可少的。我们需要广泛使用这些技术的领域之一是文件系统。然而，文件系统还有很多其他您需要了解的事情。所以，下一章处理这个主题真是太好了！
