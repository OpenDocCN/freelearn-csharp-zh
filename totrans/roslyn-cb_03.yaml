- en: Writing IDE Code Fixes, Refactorings, and Intellisense Completion Providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating, debugging, and executing a `CodeFixProvider` to fix a compiler warning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Applying batch code fixes (FixAll) across different scopes: document, project,
    and solution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom `FixAllProvider` to fix all occurrences of an issue across
    a scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `CodeRefactoringProvider` to refactor source code to recommend using
    C# 7.0 tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `CompletionProvider` to provide additional intellisense items while
    editing code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing unit tests for a `` `CodeFixProvider` ``
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code fix providers and code refactoring providers are extensions to the Visual
    Studio IDE to edit the user source code to fix issues and refactor it without
    introducing functional changes respectively. Users see a light bulb in the code
    editor to invoke the code action (fix/refactoring) to automatically edit their
    code. Additionally, code fixes can provide FixAll support, which allows fixing
    multiple similar issues across a document, project, or solution with a single
    code action.
  prefs: []
  type: TYPE_NORMAL
- en: Completion providers are extensions to the Visual Studio IDE to show additional
    completion items in the intellisense completion list when a user is editing source
    code, and to auto-generate code when a user commits a specific completion item.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter enables C# developers to write, debug, execute, and test these
    IDE extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating, debugging, and executing a CodeFixProvider to fix a compiler warning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code fix providers are IDE extensions to fix diagnostics in source code, which
    are reported by compilers and/or analyzers. These are built on top of Roslyn's
    Workspaces layer and operate on the current document being edited. When the user
    invokes a command such as *Ctrl* + dot in Visual Studio editor, the IDE code fix
    engine computes all the diagnostics in the current line span and identifies all
    the code fix providers that have registered to fix one or more of the reported
    diagnostics. Each of these code fix providers are then invoked with a code fix
    context containing the current document, diagnostics, and span. Fixers operate
    on the underlying syntax tree associated with the document by adding, removing,
    or editing the syntax nodes within the tree, and returning the new document with
    the fixed code. They might also alter the contents of the containing project or
    solution to fix the diagnostic. When the user commits the fix by pressing the
    *Enter* key, the code fix engine applies this code fix to the user code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will write a `CodeFixProvider` to fix the compiler warning
    *CS0219* ([https://docs.microsoft.com/en-us/dotnet/csharp/misc/cs0219](https://docs.microsoft.com/en-us/dotnet/csharp/misc/cs0219))
    (the variable `variable` is assigned but its value is never used). For example,
    the following code sample contains two unused variables `a` and `b` and the code
    fix will remove the local declaration statement with unused variable `a` and remove
    the declaration `b = 1` in the next declaration statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have Visual Studio 2017 installed on your machine to execute
    the recipes in this chapter. You can install a free community version of Visual
    Studio 2017 from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you can refer to the recipe, *Creating, debugging, and executing
    an analyzer project in Visual Studio,* from [Chapter 1](9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml),
    *Writing Diagnostic Analyzers,* to install the analyzer + code fix project templates
    and create a default project from the template, say `CSharpAnalyzers`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open `CSharpAnalyzers.sln` in Visual Studio and open source file `CodeFixProvider.cs`
    in the project `CSharpAnalyzers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the `title` of the code fix provider from `"Make Uppercase"` to `"Remove
    unused local"` and change `FixableDiagnosticIds` property to return `"CS0219"`
    instead of `CSharpAnalyzersAnalyzer.DiagnosticId`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b14ad973-4d84-4f17-ba87-3c8d3ed90745.png)'
  prefs: []
  type: TYPE_IMG
- en: Replace the implementation of the `RegisterCodeFixesAsync` method with the code
    from `CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/CodeFixProvider.cs/` method
    named `RegisterCodeFixesAsync`***.***
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the helper methods `GetSyntaxNodeToRemoveAsync` and `RemoveDeclarationAsync`
    to the source file with the code from `CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/CodeFixProvider.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set breakpoints at the first line of the newly added methods `RegisterCodeFixesAsync`
    and `RemoveDeclarationAsync`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `CSharpAnalyzers.Vsix` as the startup project and press *F5* to start a
    new VS instance with the code fix provider enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the new VS instance, create a new C# class library project, say `ClassLibrary`,
    and replace the existing code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Put the cursor on the line `int a = 0;` and verify the breakpoint in `RegisterCodeFixesAsync`
    is hit. Remove this breakpoint and then you can either step through the method
    with *F10* or hit *F5* to continue execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify that the light bulb shows up with a hyperlink to `Show potential fixes`
    under the source line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/928633a8-24e6-4b64-93d8-7c20f4b70d45.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Click on the light bulb and verify the breakpoint in `RemoveDeclarationAsync`
    is hit. Remove this breakpoint and then you can either step through the method
    with *F10* or hit *F5* to continue execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the light bulb again and verify the Remove unused local code fix is
    offered with a preview of code change by the fix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bbfa27ab-026c-4464-b5f7-76ce55936776.png)'
  prefs: []
  type: TYPE_IMG
- en: Hit enter to apply the code fix and verify that the unused local declaration
    statement is removed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Move the cursor to unused local `b` and press keys *Ctrl* + dot and verify
    the same code fix is offered, and applying the fix removes the declaration `b
    = 1`*,* but retains the local declaration for `c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8c2aa0d1-a42b-4644-95ef-24269c67e304.png)'
  prefs: []
  type: TYPE_IMG
- en: Verify that no code fixes are offered for a local `d` with a non-constant initializer
    and local `e` with a different compiler error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Code fix providers are VS IDE extensions that can register code actions for
    fixing compiler or analyzer diagnostics of specified diagnostic IDs. The primary
    APIs on `CodeFixProvider` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FixableDiagnosticIds` property (abstract): An immutable array of diagnostics
    IDs that the code fix provider can fix. Any compiler or analyzer diagnostic that
    is reported with one of the specified diagnostic IDs is a candidate for a code
    fix from the provider, and `RegisterCodeFixesAsync` is called with each such diagnostic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegisterCodeFixesAsync` method (abstract): This is the method to register
    code actions for fixable diagnostics. This method is invoked by the code fix engine
    whenever it needs to compute the code actions for diagnostics reported on a current
    source line in the VS IDE. This method takes a `CodeFixContext` argument, which
    contains a set of one or more diagnostics to be fixed for a given diagnostic span
    and document. All the diagnostics in the context have a fixable diagnostic ID.
    The `CodeFixProvider` can map the diagnostic span to the syntax node in the document
    and analyze it to register one or more code actions to fix one or more diagnostics
    in the context. `CodeAction` contains the following primary members:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Title` property: This is the string that shows up with the light bulb when
    the code fix is offered.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Callback` method: This is the delegate to be called back when the user applies
    a registered code action. This method returns the changed document or solution
    and the code fix engine applies the changes to the workspace.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EquivalenceKey` property: This is the string representing the equivalence
    class of code actions that this code action belongs to. If the code fix provider
    supports `FixAllProvider`, then a FixAll code fix batches all code actions in
    the equivalence class of the invoked code action and fixes all of them simultaneously.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetFixAllProviderAsync` method (virtual): Code fix providers can optionally
    override this method and return a non-null `FixAllProvider` if they want FixAll
    support for their code actions. We will discuss this in more detail in the next
    recipe.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CodeFixProvider` implemented in this recipe has a single fixable diagnostic
    ID: `CS0219`, a compiler diagnostic flagging unused local variable declarations.
    Let''s expand on the implementation details of `RegisterCodeFixesAsync` override
    and its helpers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `RegisterCodeFixesAsync` computes a syntax node to remove
    for the variable that was flagged by invoking `GetNodeToRemoveAsync`*,* and bails
    out if we get a null node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial part of `GetNodeToRemoveAsync` computes the syntax node that was
    flagged by the diagnostic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We first get the syntax root of the document being fixed. We then find the
    syntax token in the root at the start of the diagnostic span and find the first
    ancestor node of type `VariableDeclaratorSyntax`. For example, consider the following
    local declaration statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The entire statement is a `LocalDeclarationStatementSyntax` node. It has a child
    syntax node `VariableDeclarationSyntax`, which represents `int b = 1, c = 2`,
    and the syntax token for the semicolon. The variable declaration syntax node contains
    two variable declarator nodes, each of type `VariableDeclaratorSyntax`, and text
    `b = 1` and `c = 2`, respectively. The `VariableDeclaratorSyntax` node contains
    a token for the `IdentifierName` and a syntax node for the initializer of type
    `EqualsValueClauseSyntax`. `CS0219` is reported on the `IdentifierName` token
    for the unused variable declarator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the Roslyn [SyntaxVisualizer](https://blogs.msdn.microsoft.com/csharpfaq/2014/04/17/visualizing-roslyn-syntax-trees/)
    to understand the parsed syntax node/tokens for a given C# or VB source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d66f9e4e-ad4e-4532-a35e-cf651484d56f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next part of `GetNodeToRemoveAsync` implements certain defensive checks
    to bail out early without registering any code action as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We first bail out if the diagnostic was reported on a token which does not have
    a **`VariableDeclaratorSyntax`** ancestor. We also bail out if the variable initializer
    is a non-constant, as removing it with the code fix can cause functional change
    by not executing the initializer code. Finally, we check if the variable declarator
    has a `VariableDeclarationSyntax` parent, which has a `LocalDeclarationStatementSyntax`
    parent.
  prefs: []
  type: TYPE_NORMAL
- en: Defensive checks in the code fix provider are very important checks to protect
    us against an unexpected third-party analyzer reporting diagnostic with same diagnostic
    ID, but on a different syntax node kind to what our fixer expects. We should ensure
    that we gracefully bail out instead of crashing unexpectedly or registering an
    incorrect code fix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the method computes and returns the syntax node to be removed by the
    code fix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two cases to cover:'
  prefs: []
  type: TYPE_NORMAL
- en: If the local declaration statement declares only a single variable, then we
    can remove the entire statement. We also cover an additional bail out case where
    a local declaration is not parented by a block statement, in which case, removing
    the local declaration statement will cause a syntax error. Given that the compiler
    already reports a diagnostic *CS1023* (embedded statement cannot be a declaration
    or labeled statement) for this case, we just bail out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, if the local declaration statement declares multiple variables, we
    can remove just the variable declarator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we have a non-null syntax node to remove, we register a code fix to remove
    the declaration node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a standard CodeAction, using the `CodeAction.Create` API, with the
    title `Remove unused local`, and use the same equivalance key. We register `RemoveDeclarationAsync`
    as the callback method to be invoked when the user applies the code fix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This method uses the `SyntaxGenerator` helper utility to remove the declaration
    node from the original syntax root and returns the new document created with the
    new syntax root.
  prefs: []
  type: TYPE_NORMAL
- en: '`SyntaxGenerator` is a powerful syntax factory with APIs to add, remove, or
    edit syntax nodes in a language agnostic way. It works for both VB and C# syntax
    nodes, and enables writing code fix providers that fix issues across both languages,
    without requiring language-specific implementations. See [http://source.roslyn.io/#q=SyntaxGenerator](http://source.roslyn.io/#q=SyntaxGenerator)
    for `SyntaxGenerator` reference source.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying batch code fixes (FixAll) across different scopes: document, project,
    and solution'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to apply batch code fixes to fix multiple
    instances of similar diagnostics across different scopes. We will apply the FixAll
    code fix for the Make uppercase code fix in the default analyzer + code fix template
    project and fix multiple type names across the document, project, and solution
    scopes so they all contain upper case letters only. We will show you how to invoke
    a FixAll code fix from the editor light bulb, and then use the FixAll preview
    changes dialog to selectively choose the fixes to apply to your solution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have Visual Studio 2017 installed on your machine to execute
    the recipes in this chapter. You can install a free community version of Visual
    Studio 2017 from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)***.***
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you should execute the recipe *Creating, debugging, and executing
    an analyzer project in Visual Studio*, from the first [chapter 1](9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml),
    *Writing Diagnostic Analyzers* to install the Analyzer + Code fix project templates
    and create a default project from the template, say `CSharpAnalyzers`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open `CSharpAnalyzers.sln` in Visual Studio. Set `CSharpAnalyzers.Vsix` as the
    start-up project and press *F5* to start a new VS instance with the code fix provider
    enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the new VS instance, create a new C# class library project, say `ClassLibrary`,
    and replace the existing code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new source file, say `Class4.cs`, to the project with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new C# class library project to the solution, say `ClassLibrary2.csproj`,
    rename the source file to `Class5.cs`**,** and replace its source with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify five diagnostics in the error list, one for each class: Type name ''XXX''
    contains lower case letters*.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the cursor on `Class1`, and hit *Ctrl* + dot to bring up the light bulb
    for code fix Make uppercase**.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/95a7bcd7-2119-4d85-bb71-7c1172203f81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the hyperlink Fix all occurrences in Document to bring up the Preview
    Changes - Fix All Occurrences dialog. Click on the Apply button to apply the Make
    uppercase fix to all types in `Class1.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/be660758-6948-4031-9e2b-71ffcf68fb4f.png)'
  prefs: []
  type: TYPE_IMG
- en: Verify that `Class1`, `Class2`*,* and `Class3` are changed to `CLASS1`, `CLASS2`
    and `CLASS3`*,* respectively, but `Class4` and `Class5` are unchanged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* + *Z* to undo the batch code fix and verify the solution returns
    to the same state as before applying the fix all code fix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again press *Ctrl* + dot, but this time click on Fix all occurrences in Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Uncheck the checkbox next to `public class CLASS2` and verify that `CLASS2`
    is switched back to `Class2` in the preview changes dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f5a86fa7-034e-4577-81aa-493cec472ed8.png)'
  prefs: []
  type: TYPE_IMG
- en: Apply the fix and verify that `Class1`, `Class3`, and `Class4` are changed to
    `CLASS1`, `CLASS3`, and `CLASS4`, respectively, but `Class2` and `Class5` are
    unchanged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* + *Z* to undo the project level code fix and verify changes to
    both source files `Class1.cs` and `Class4.cs` are reverted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again press *Ctrl* + dot, and this time click on Fix all occurrences in Solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the code fix and verify all five classes are changed to upper case, and
    *Ctrl* + *Z* reverts the changes to all types in the solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a custom FixAllProvider to fix all occurrences of an issue across a
    scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will show you how to a write a custom FixAll code fix provider
    to batch fix diagnostics. We will use the code fix implemented in the first recipe
    of this chapter to `Remove unused local`*.* As shown in that recipe, removal of
    an unused local might have different code fixes based on whether the enclosing
    local declaration statement declares a single or multiple variables. Additionally,
    we might have multiple unused locals declared in the single statement, and if
    all the locals declared in a statement are unused, the batch fix should remove
    the entire statement. Hence, we cannot use the well-known batch fixer. For example,
    for the following code, the batch fix should delete the entire first two local
    declaration statements, but only the declarator for `d` in the third declaration
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The default well-known `BatchFixer` used by code fixers only works well for
    simple code fixes. For other scenarios, we need to write a custom fix all provider.
    See ([https://github.com/dotnet/roslyn/blob/master/docs/analyzers/FixAllProvider.md](https://github.com/dotnet/roslyn/blob/master/docs/analyzers/FixAllProvider.md))
    for documentation on FixAll providers and limitations of the well-known BatchFixer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should execute the first recipe in this chapter, *Creating, debugging and
    executing a code fix provider to fix a compiler warning* to implement a code fix
    provider to `Remove unused local`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open `CSharpAnalyzers.sln` in Visual Studio and add two new source files to
    the project `CSharpAnalyzers`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CustomFixAllProvider.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CustomFixAllCodeAction.cs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add code to `CustomFixAllProvider.cs` to implement a custom fix all provider
    from `CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/CustomFixAllProvider.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add code to `CustomFixAllCodeAction.cs` from `CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/CustomFixAllCodeAction.cs`
    to implement a custom `CodeAction`, which is returned by `CustomFixAllProvider.GetFixAsync`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following edits to `CodeFixProvider.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change `GetNodeToRemoveAsync` to be an internal static method
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Change `GetFixAllProviderAsync` to return a `new CustomFixAllProvider()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `CSharpAnalyzers.Vsix` as the start-up project and press *F5* to start a
    new VS instance with the code fix provider enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the new VS instance, create a new C# class library project, say `ClassLibrary`,
    and replace the existing code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new source file, say `Class2.cs` to the project with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new C# class library project to the solution, say `ClassLibrary2.csproj`,
    rename the source file to `Class3.cs`**,** and replace its source with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Verify 12 diagnostics in the error list, one for each unused variable across
    the three classes*.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the cursor on local *'a'* in `Class1.cs`, and hit *Ctrl* + dot to bring
    up the light bulb for code fix `Remove unused local`**.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the hyperlink Fix all occurrences in Document to bring up the Preview
    Changes - Fix All Occurrences dialog. Click on the Apply button to apply the Remove
    unused local to remove all four unused locals (*''*`a`*'', ''*`b`*'', ''*`c`*''*
    and *''*`d`*''*) in the `Class1.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ddcdc30c-56a6-4ede-a0e4-c0864b8ff700.png)'
  prefs: []
  type: TYPE_IMG
- en: Switch to unused local declarations in `Class2.cs` and attempt to Fix All Occurences
    in the solution/project scope and verify all unused locals are remove in the selected
    scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'FixAll providers are VS IDE extensions that register code actions for batch
    fixes corresponding to code actions registered by a specific code fix provider.
    The primary APIs on `FixAllProvider` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetSupportedFixAllScopes` property (virtual): This gets the supported scopes
    for fixing all occurrences of a diagnostic. By default, it returns document, project,
    and solution scopes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetSupportedFixAllDiagnosticIds` method (virtual): This gets the diagnostic
    IDs for which fix all occurrences is supported. By default, it returns the `FixableDiagnosticIds`
    of the corresponding code fix provider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetFixAsync` method (abstract): This is the primary method that takes a `FixAllContext`
    argument and returns a code action for a batch fix corresponding to `FixAllContext`
    parameters: `CodeFixProvider`, `DiagnosticIds` to fix, `FixAllScope` and `EquivalenceKey`
    for the origin code action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code fix engine invokes the `CodeFixProvider.GetFixAllProviderAsync` method
    to get the optional FixAll provider supported by the code fixer. In our implementation,
    we ensure that we return `CustomFixAllProvider` for this method. Let's expand
    on the implementation details of `CustomFixAllProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: '`CustomFixAllProvider` only overrides the `GetFixAsync` method. The first part
    of `GetFixAsync` computes fix title and the documents to fix for the current `FixAllScope`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we iterate through all the computed documents and compute the diagnostics
    to fix for each document and store them in a map. We return our `CustomFixAllCodeAction`
    with the computed title and diagnostics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let's go through the implementation details for `CustomFixAllCodeAction`*.*
    The primary method that the custom code action overrides is `GetChangedSolutionAsync`.
    This method gets the new solution with edits from the batch fix. The code fix
    engine invokes this method when the user attempts to apply the batch fix .
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial part of `GetChangedSolutionAsync` computes all local declaration
    and variable declarator syntax nodes to remove for each document, in a map named
    `nodesToRemove`, carrying out very basic batching of syntax nodes to fix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part tries to identify local declaration statements with multiple
    variable declarations, where all the declared locals are unused, and hence the
    entire statement can be removed. For such cases, we add the local declaration
    statement to `nodesToRemove` and remove all the individual unused variable declarators
    in the local declaration statement from `nodeToRemove` map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we iterate through all the `{Document, HashSet<SyntaxNode>}` pairs
    and for each document compute the new root with all the unused locals removed
    from the entire tree. We create a new document with the new root and apply the
    document change to the latest solution, which is tracked as `newSolution`. At
    the end of the loop, `newSolution` represents the current solution with all document
    changes applied, and is returned by the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Creating a CodeRefactoringProvider to refactor source code to recommend using
    C# 7.0 tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code refactoring providers are IDE extensions to refactor source code for better
    code structuring, without affecting the functional or semantic behavior of the
    code. These are built on top of Roslyn's Workspaces layer and operate on the current
    document being edited. When a user invokes a command such as *Ctrl* + dot in Visual
    Studio editor, the IDE code refactoring engine computes all the refactorings that
    can refactor the code in the currently selected text span in the editor. Each
    of these providers are then invoked with a code refactoring context containing
    the current document and span. Refactorings operate on the underlying syntax tree
    associated with the document by adding, removing, or editing the syntax nodes
    within the tree and returning the new document with the refactored code. They
    might also alter the contents of the containing project or solution. When the
    user commits the refactoring by pressing the *Enter* key, the code refactoring
    engine applies this refactoring to the user code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will write a `CodeRefactoringProvider` to propose the usage
    of tuple expressions*,* a C# 7.0 feature, in methods returning more than one value.
    Prior to C# 7.0, methods that wanted to return more than one value had the following
    possible implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare a non-void return type of one of the return values and `out` parameters
    for the remaining returned values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare a void return type and *out* parameters for each of the returned values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare a new type wrapping these values as fields, and return an instance of
    that type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With C# 7.0, the recommended implementation is to declare a tuple return type
    with elements defined for types of each of the returned values and have no out
    parameters. We will write a refactoring to identify the existing code with pattern
    1 earlier and recommend a refactoring to use tuples. For example, consider the
    following methods returning multiple return values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Our code refactoring will offer to convert these methods to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have Visual Studio 2017 installed on your machine to execute
    the recipes in this chapter. You can install a free community version of Visual
    Studio 2017 from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)***.***
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you should have installed the .NET Compiler Platform SDK to get
    the `CodeRefactoring` project template. For reference, see the recipe, *Creating,
    debugging, and executing an analyzer project in Visual Studio*, in [Chapter 1](9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml),
    *Writing Diagnostic Analyzers.*
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `CodeRefactoring` project template targets *.NET Portable v4.5*
    and references version *1.0.1* of `Microsoft.CodeAnalysis` packages. As we intend
    to use the C# 7.0 syntax, we need to upgrade the `CodeAnalysis` packages to version
    2.0.0 or later, which are based on .NET Standard and hence require the referencing
    project to be based on .NET standard templates or target .NET Framework v4.6 or
    higher. For this recipe, we change the project to target .NET Framework v4.6.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start Visual Studio and click on File | New | Project...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the project target framework combo box to the .NET Framework 4.6 (or
    above). Under Visual C# | Extensibility, choose Code Refactoring (VSIX), name
    your project `CodeRefactoring`**,** and click on OK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9a36cd4d-e003-4c0b-83b5-f1115f77ba1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You should now have a solution with two projects: `CodeRefactoring` and `CodeRefactoring.Vsix`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the `CodeRefactoring` project to target *.NET Framework v4.6* using
    the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unload the project and edit `csproj` in Visual Studio
  prefs:
  - PREF_IND
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the properties `ProjectTypeGuids` and `TargetFrameworkProfile`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the property `TargetFrameworkVersion` from *v4.5* to *v4.6.*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace the last Imports element in the file from portable targets to non-portable
    targets, that is, replace the line `<Import Project="$(MSBuildExtensionsPath32)\Microsoft\Portable\$(TargetFrameworkVersion)\Microsoft.Portable.CSharp.targets"
    />` with `<Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Save changes and reload the project
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Right-click on project in solution explorer, click on Manage NuGet Packages,
    and update `Microsoft.CodeAnalysis.CSharp.Workspaces` to *2.0.0*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b0d6778e-6938-40d1-8ee1-90f643271039.png)'
  prefs: []
  type: TYPE_IMG
- en: Open `CodeRefactoringProvider.cs` in the `CodeRefactoringProvider` project and
    replace the existing implementation of the `ComputeRefactoringAsync` method with
    the code at `CodeRefactoring/CodeRefactoring/CodeRefactoringProvider.cs/` Method
    named `ComputeRefactoringAsync`*****.*****
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following helper to compute *out* parameters from a parameter list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the existing method `ReverseTypeNameAsync` and replace it with `UseValueTupleAsync`
    and a couple of helper methods, `GenerateTupleType` and `GenerateTupleExpression`,
    from code at `CodeRefactoring/CodeRefactoring/CodeRefactoringProvider.cs/` Methods
    named `GenerateTupleType and GenerateTupleExpression`. Additionally, also add
    a new using statement at the top of the file: `using Microsoft.CodeAnalysis.Formatting;`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `CodeRefactoring.Vsix` as the Startup project and click on *F5* to build
    the refactoring and start debugging a new instance of Visual Studio with the refactoring
    enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the new Visual Studio instance, create a new C# class library project, say
    `ClassLibrary` and add the following two methods to `Class1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Right-click on the project node | Manage Nuget Packages and add NuGet package
    reference to `System.ValueTuple`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put the caret on `MethodReturningTwoValues` and hit *Ctrl* + dot and verify
    that we are offered a refactoring to Use ValueTuple return type*:*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3dd67329-3a00-4a5b-a926-115c7efb7219.png)'
  prefs: []
  type: TYPE_IMG
- en: Apply the refactoring and verify that the method signature changes to return
    value tuple.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similarly, put the caret on `MethodReturningThreeValues` and hit *Ctrl* + dot
    and verify we are offered a refactoring to Use ValueTuple return type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cbcf251c-0e8c-47e3-8e87-86e606b3d586.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Code refactoring providers are VS IDE extensions that can register code actions
    for refactoring code to a recommended pattern without introducing any functional
    changes. The primary API on `CodeRefactoringProvider` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ComputeRefactoringsAsync` method (abstract): This is a method to register
    code actions for refactorings. This method is invoked by the code refactoring
    engine whenever it needs to compute the refactorings to offer on the current source
    line in the VS IDE. This method takes a `CodeRefactoringContext` argument, which
    contains the current span and document. `CodeRefactoringProvider` can map the
    span to syntax node in the document and analyze it to register one more code actions
    in the context. **CodeAction** contains the following primary members:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`Title`** property: String that shows up with the light bulb when the code
    refactoring is offered.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Callback` method: Delegate to be called back when the user applies a registered
    code action. This method returns the changed document or solution and the code
    refactoring engine applies the changes to the workspace.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's expand on the implementation details of `ComputeRefactoringsAsync` and
    its helpers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `ComputeRefactoringsAsync` computes syntax node for the current
    span:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part of the method implements certain defensive checks to bail out
    early without registering any code action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We first check if we are currently operating on a `MethodDeclarationSyntax`
    node with non-void return type and at least one out parameter. We also bail out
    if the analyzed compilation doesn't define a type named `System.ValueTuple` in
    `System.ValueTuple` assembly reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the method registers a code action with the title to display in the
    light bulb and a callback*,* `UseValueTupleAsync`*,* to compute the refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`UseValueTupleAsync` uses the C# `SyntaxFactory` helper utility to edit the
    signature and body of the method declaration from the original syntax root, and
    returns the new document created with the new syntax root.'
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the method computes the new parameter list for refactored
    code. We remove all the *out* parameters from the parameter list and change the
    return type to be a tuple type. For example, for a method returning type T, and
    having parameters, A a, out B b, out C c, we return a `TupleTypeSyntax` (T, B,
    C) and change the method parameter list to contain just <q>A a</q>**:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part of the method adds local declaration statements at the top of
    the method body block for each *out* parameter in the original parameter list.
    For the preceding example, we will add local declaration statements `B b;` and
    `C c;`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we gather all the `ReturnStatementSyntax` nodes in the original method
    implementation and replace their expression with a tuple expression created by
    concatenating the original return expression with the identifier names of the
    newly declared locals. For our example, this will replace statements of the form
    `return x;` with `return (x, b, c);`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we apply the formatter annotation on the method `decl` to ensure that
    formatting is done by the formatter engine. We then replace the updated `methodDecl`
    node in the original root and return the updated document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There s more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our current implementation of the refactoring is incomplete -- we change the
    method signature to return tuple types, but do not update the call sites to consume
    them. For example, the highlighted callsite here will be broken by our refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We leave it as an exercise for the reader to enhance this refactoring to use
    the `FindReferences` API ([http://source.roslyn.io/#q=FindReferencesSearchEngine.FindReferencesAsyn](http://source.roslyn.io/#q=FindReferencesSearchEngine.FindReferencesAsyn))
    to find callsites of the method and edit the code to fix the callsite. For the
    preceding example, we need to replace the `MethodReturningTwoValues` invocation
    with the highlighted code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Creating a CompletionProvider to provide additional intellisense items while
    editing code.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CompletionProviders` are IDE extensions that provide completion items in the
    intellisense list when user is editing code in the Visual Studio IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e910df99-d4d7-4e0f-8ca6-076fd9e29d59.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows a completion list with all the accessible instance
    members from the current type and base types, and is generally shown when the
    user types `this.` inside executable code. Users can hit a commit character, such
    as *Enter* key, to invoke auto-complete with the chosen member.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will write a `CompletionProvider` to provide the same *accessible
    members* completion items, but without requiring the user to have typed a `this`
    before a `.` character (yay! from all the lazy folks like me). Additionally, when
    invoked within a static method, the completion provider will provide only *static*
    accessible members in the completion list.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a743a1b-8549-4d16-992a-c4c953bc46cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have Visual Studio 2017 installed on your machine to execute
    the recipes in this chapter. You can install a free community version of Visual
    Studio 2017 from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)***.***
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open Visual Studio, click on File | New Project | Visual C# | Class library,
    ensure the .NET framework combo box is set to *v4.6.2,* and create a project named
    `CompletionProvider`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In solution explorer, right-click on the project node and execute the `Manage
    NuGet Packages` command to bring up the NuGet Package Manager. Add NuGet package
    references to `Microsoft.CodeAnalysis` and `Microsoft.CodeAnalysis.Features`,
    both version *2.0.0.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the source file `Class1.cs` to `CustomCompletionProvider.cs` and add
    source code for `CustomCompletionProvider` from the code sample at `CompletionProvider/CompletionProvider/CustomCompletionProvider.cs/Type`
    named `CustomCompletionProvider`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a C# VSIX project named `CompletionProvider.Vsix` to the solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the content of `source.extension.vsixmanifest` in the VSIX project
    with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Add a project-to-project reference from `CompletionProvider.Vsix` to `CompletionProvider`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `CompletionProvider.Vsix` as the start-up project and click on *F5* to build
    the completion provider and start debugging a new instance of Visual Studio with
    the provider enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the new Visual Studio instance, create a new C# class library project, say
    `ClassLibrary` and add the following code to the source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Put the caret after the `.` in `InstanceMethod` and hit *Ctrl* + *SpaceBar*
    to bring up our custom completion list. Verify all the instance members of type
    `Derived`, and accessible instance members of base type `Base` and `System.Object`
    are shown in the completion list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a member, say `InstanceMemberDerived`, and hit the *Enter* key and verify
    that the `.` is replaced with `this.InstanceMemberDerived`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put the caret after the `.` in `StaticMethod` and hit *Ctrl* + *Spacebar* to
    bring up the completion list. Verify all the static members of type *Derived*
    and accessible static members of base type `Base` and `System.Object` are shown
    in the completion list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a member, say `StaticMemberBase`, and hit the *Enter* key, and verify
    that the `.` is replaced with `Base.StaticMemberBase`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Completion providers are VS IDE extensions that can register completion items
    to be shown in the Visual Studio IDE when the user is editing source code. The
    primary APIs on `CompletionProvider` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ShouldTriggerCompletion` method (virtual): This is the method to decide if
    completion should be invoked for the given editing context. This method takes
    the following arguments: `SourceText` of the document being edited, `caretPosition`
    at which completion was invoked, `CompletionTrigger` (which contains the trigger
    kind - insertion, deletion, and so on, and the trigger character), and `OptionSet`
    for completion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProvideCompletionsAsync` method (abstract): This is the method to register
    completion items. This method is invoked by the completion engine whenever it
    needs to compute the completions to offer on the current completion trigger in
    the VS IDE. This method takes a `CompletionContext` argument, which contains the
    current caret position, document, completion trigger and options. `CompletionContext`
    exposes methods to add one or more completion items. `CompletionItem` contains
    the following primary components: `DisplayText` to be shown in the completion
    list, optional `FilterText` and `SortText` to modify the default filtering and
    sorting, respectively, the text `Span` of the syntax element is associated with
    the completion, a dictionary of `<string, string> Properties`, an array of `Tags`,
    and set of `CompletionRules` for how the completion items are handled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetDescriptionAsync` method (virtual): This method gets the description to
    show in the quick info for each completion item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetChangeAsync` method (virtual): This method gets the `CompletionChange`
    to be applied when the user commits a specific completion item. `CompletionChange`
    contains the set of one or more text changes to apply to the document and new
    caret position after committing the completion item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's expand on the implementation details of each of the preceding overrides
    in our `CustomCompletionProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our implementation of `ShouldTriggerCompletion` first checks whether completion
    is invoked for the insertion trigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The helper method `ShouldTriggerCompletion` checks if the current character
    is `.` and the previous character is either a whitespace, tab, or new line character.
    If so, we return true; otherwise we return false.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`ProvideCompletionsAsync` implementation checks up front if we should register
    any completion items, and bails out if we are not in the supported completion
    context. We also bail out if we are not editing inside a method body.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We then compute all the accessible members in the current context using the
    helper methods `GetAccessibleMembersInThisAndBaseTypes` and `GetBaseTypesAndThis`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We then iterate through all the members to suggest, ignoring constructors,
    and create and register a completion item for each member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We use the member's `Name` property as the `DisplayText` value for the completion
    item.
  prefs: []
  type: TYPE_NORMAL
- en: 'We compute a couple of strings, namely, `Receiver` and `Description`, and store
    them as string properties on the completion item. These properties are used in
    `GetChangeAsync` and `GetDescriptionAsync` method overrides, respectively. `Receiver`
    is essentially the string to add to the left of the `.` character when user commits
    a completion item: `this` for instance members, and containing type''s `name`
    for static members. `Description` is the text to show in the quick info for each
    completion item. We use the symbol''s minimal display string as the description,
    but this can be enhanced to show colored tokens and use content from the XML documentation
    comments on the symbol.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also compute and attach a set of string `Tags` to the completion items.
    These tags determine the glyphs to show for the completion items. Examples are
    symbol glyph: field, method, property, and so on, and accessibility glyph: private,
    protected, internal, public, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetDescriptionAsync` override directly uses the Description property stored
    on the completion item to compute the `CompletionDescription`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`GetChangeAsync` override uses the computed *Receiver* property and the item''s
    `DisplayText` to form the `newText "{receiver}.{item.DisplayText}"` to be used
    in the text change when the user commits the completion item. The `TextSpan` of
    the text change uses `item.Span.Start - 1` as the start value and `1` as the length
    to account for the existing `.` character to be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Writing unit tests for a CodeFixProvider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will show you how to write and execute unit tests for a
    `CodeFixProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have created and opened an analyzer + code fixer project, say
    `CSharpAnalyzers` in Visual Studio 2017\. Refer to the recipe, *Creating, debugging,
    and executing an analyzer project in Visual Studio*, in [Chapter 1](9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml),
    *Writing Diagnostic Analyzers* for guidance.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the template unit test project contains unit tests for both the `DiagnosticAnalyzer`
    and `CodeFixProvider`. This chapter deals with `CodeFixProvider` testing only.
    Refer to the recipe, *Writing unit tests for an analyzer project* in [Chapter
    1](9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml), *Writing Diagnostic Analyzers*
    for diagnostic analyzer unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open `UnitTests.cs` in the `CSharpAnalyzers.Test` project in the solution explorer
    to view the default unit tests created for the default symbol analyzer and code
    fix provider in the project (Type names should not contain lower case letters):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/46d1c8ea-ca5c-49a2-89fd-916547876e95.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Test | Windows | Test Window to open the Test Explorer window to view
    the unit tests in the project. The default project has two unit tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TestMethod1`: This tests the scenario where analyzer diagnostic does not fire
    on the test code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestMethod2`: This tests the scenario where analyzer diagnostic does fire
    on the test code and the code fix provider fixes the diagnostic.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete `TestMethod1` as we only care about `CodeFixProvider` tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the unit tests for the project by right-clicking on Not Run tests node
    in the Test Explorer and execute `Run selected tests` context menu command and
    verify that the `TestMethod2` passes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c0dd4466-6188-4633-8618-1fd8f8360be6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Edit the test source to remove all the usings and add a new nested type `TypeName2`
    inside `TypeName` in both the test string and `fixTest` string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit `TestMethod1` to fix the expected line number of the original expected
    diagnostic add a new excepted diagnostic for the new test code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on `TestMethod2` in the editor and execute Run tests context menu
    command, and verify the test now fails with the diagnostic mismatch assert - expected
    1, actual 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Fix the expected `fixTest` code to contain `TYPENAME2` and verify that the test
    passes now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the unit test again and note that the test still fails, but now it fails
    due to a difference in the fixed test code - `fixTest` has class `TypeName2` with
    lowercase letters, but the actual test code has `TYPENAME2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An analyzer + code fix unit test project allows us to write unit tests for the
    execution of our analyzer/code fix provider on different code samples. Each unit
    test is marked with a `TestMethod` attribute and defines sample test code, expected
    diagnostics reported by the analyzer on that code (if any), expected fixed test
    code after executing the code fix provider on the sample test code, and invocation
    of test helper methods, here `VerifyCSharpFix`*,* to verify code fix.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the basics of unit tests and the test framework for our unit test
    framework, refer to the *How it works... section* of the recipe, *Writing unit
    tests for an analyzer project* in [Chapter 1](9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml),
    *Writing Diagnostic Analyzers* for diagnostic analyzer unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will give a brief explanation of the abstract type that
    our unit test container derives from: `CodeFixVerifier`. This type contains the
    `VerifyCSharpFix` and `VerifyBasicFix` helper methods for running C# and VB `CodeFixProvider`
    unit tests, respectively. These methods call into a common helper method `VerifyFix`,
    which works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This method takes the original and expected sample test code as inputs - the
    original code on which to apply the code fixes, and the expected code after the
    code fixes have been applied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It also takes the language name, analyzer, and code fix provider, along with
    the index of the code action to apply, in case the fixer registers multiple code
    actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It runs the analyzer on the original test code to get the analyzer diagnostics.
    It also computes the compiler diagnostics on the test code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It uses the first analyzer diagnostic to create a `CodeFixContext` and invokes
    the code fix provider's `RegisterCodeFixesAsync` method with this context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it applies the registered code action at the given code fix index to compute
    the new document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It re-executes the analyzer on the new document to get new analyzer diagnostics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Until there is at least one new analyzer diagnostic, it repeats the steps 4-6
    to apply the code fix on the new document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it verifies the contents of the new document against the expected fixed
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
