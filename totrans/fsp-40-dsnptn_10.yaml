- en: Chapter 10. Type Augmentation and Generic Computations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。类型扩展和泛型计算
- en: To this point in the book, it was easy to notice the direct link between the
    use pattern and the correspondent language feature. For example, [Chapter 5](text00049.html#page
    "Chapter 5.  Algebraic Data Types") , *Algebraic Data Types* , clearly showed
    that the native F# algebraic types are substitutes for custom classes. Increased
    quality and speed of implementations based on algebraic data types reflect the
    payoff for the feature use.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书的这一部分，很容易注意到使用模式和相应语言特征之间的直接联系。例如，[第5章](text00049.html#page "第5章. 代数数据类型")，*代数数据类型*，清楚地表明了F#的本地代数类型是自定义类的替代品。基于代数数据类型的实现质量和速度的提高反映了该功能使用的回报。
- en: In this chapter, I will consider a certain language features that do not make
    the payoff from their use obvious. Nevertheless, these features are ubiquitous
    in F#. I mean the ambivalent pair of code generalization against the code specialization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将考虑某些语言特性，它们的使用回报并不明显。尽管如此，这些特性在F#中无处不在。我的意思是代码泛化与代码特殊化的矛盾。
- en: 'We are going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要涵盖以下主题：
- en: Code generalization techniques, or making the same functional code applicable
    to multiple function argument types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码泛化技术，或使相同的函数代码适用于多个函数参数类型
- en: Code specialization techniques, or making the functional code more specific
    than usually may be achieved by using standard features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码特殊化技术，或通过使用标准功能使函数代码比通常更具体
- en: 'Each of the preceding patterns carries promises of certain benefits: improved
    performance, more succinctness, and better static type control. The goal of this
    chapter is to show you how to recognize the situations when these patterns are
    applicable and apply them, achieving the expected benefits.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 上述每个模式都承诺带来某些好处：改进的性能、更简洁的代码和更好的静态类型控制。本章的目标是向您展示如何识别这些模式适用的场景，并应用它们，以实现预期的收益。
- en: Code generalization
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码泛化
- en: Let me begin by stating that F# **automatically generalizes** ([https://msdn.microsoft.com/visualfsharpdocs/conceptual/automatic-generalization-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/automatic-generalization-%5bfsharp%5d)
    ) arguments of functions where it is possible to deal with the multiplicity of
    types.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我先声明一下，F# **自动泛化**([https://msdn.microsoft.com/visualfsharpdocs/conceptual/automatic-generalization-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/automatic-generalization-%5bfsharp%5d))函数的参数，在可能处理多种类型的多重性时。
- en: So far, we have mostly been dealing with the generalization of data collections.
    That is, a sequence is agnostic to the type of its elements. That's why we were
    able to write functions that operate on sequences of arbitrary generic type. And
    F# type inference spots and carries this property on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要处理的是数据集合的泛化。也就是说，序列对其元素类型一无所知。这就是为什么我们能够编写操作任意泛型类型序列的函数。F#的类型推断发现并携带了这一属性。
- en: 'Suppose that we proudly implement our own function of reversing a list as follows
    (`Ch10_1.fsx` ):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '假设我们自豪地实现了自己的列表反转函数，如下所示(`Ch10_1.fsx`):'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we may notice that the F# compiler infers the `reverse : ls:''a list
    -> ''alist` signature for it, where `''a` indicates that the function can be applied
    to any type of list elements. And if we decide to check out how exactly our `reverse`
    function would behave with different argument types, we may observe its behavior
    is consistent for the following arguments (`Ch10_1.fsx` ):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '那么，我们可能会注意到F#编译器推断出它的`reverse : ls:''a list -> ''alist`签名，其中`''a`表示该函数可以应用于任何类型的列表元素。如果我们决定检查`reverse`函数与不同参数类型的确切行为，我们可能会观察到其行为对于以下参数是一致的(`Ch10_1.fsx`):'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And even if we try to slightly abuse type system and mix different boxed types
    (`Ch10_1.fsx` ):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '即使我们要稍微滥用类型系统并混合不同的装箱类型(`Ch10_1.fsx`):'
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `reverse` function behaves as genuinely generic with regard to the type
    of argument list elements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse`函数在参数列表元素类型方面表现得真正通用。'
- en: 'Fine, now let''s do something seemingly similar and also utterly simple, such
    as shifting the argument to the left by a single bit (`Ch10_1.fsx` ):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '好的，现在让我们做一些看似相似但实际上非常简单的事情，比如将参数左移一位(`Ch10_1.fsx`):'
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All of a sudden, the F# compiler infers the very specific `twice : x:int ->
    int` function signature. What''s going on? Apparently, there are some types that
    allow this geeky way of making the value twice as big, for example, `int64` .
    Interestingly, let''s look at what happens when we follow the function definition
    by the usage, as following (`Ch10_1.fsx` ):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '突然，F#编译器推断出非常具体的`twice : x:int -> int`函数签名。发生了什么？显然，有一些类型允许这种将值加倍的特殊方式，例如`int64`。有趣的是，让我们看看当我们跟随函数定义使用它时会发生什么，如下所示（`Ch10_1.fsx`）：'
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now the F# compiler has seemingly changed its mind about the signature of the
    `twice`  function, this time inferring the argument and result types as `int64`
    . This action is irreversible, which means that trying to follow the preceding
    evaluation with `twice 10` will be now rejected with this diagnostics: *this expression
    was expected to have type* `int64`   *but it has type* `int`   *here* .'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在F#编译器似乎改变了关于`twice`函数签名的看法，这次推断出参数和结果类型为`int64`。这个操作是不可逆的，这意味着尝试跟随前面的评估使用`twice
    10`现在会被这个诊断拒绝：*这个表达式预期具有类型* `int64` *但在这里它具有类型* `int` 。
- en: What's going on? Why does the generalization seemingly fail?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？为什么泛化似乎失败了？
- en: Statically resolved type parameters
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态解析的类型参数
- en: As we just noticed, the F# compiler inferred a monomorphic type for the (`<<<`
    ) operator. A step toward polymorphism would assume the ability to express it
    somehow - while staying within the .NET type system that only such types are fine
    to be `twice` argument that work with the operator (`<<<` ). In other words, the
    compiler should deal with a **type constraint** .
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才注意到的，F#编译器为（`<<<`）运算符推断了一个单态类型。向多态迈进的一步是假设能够以某种方式表达它 - 同时保持在只允许这种类型作为`twice`参数与运算符（`<<<`）一起工作的.NET类型系统中。换句话说，编译器应该处理一个**类型约束**。
- en: The problem is that this kind of constraint cannot be expressed within the F#
    compilation target language **MSIL** . That is, the latest **.NET CLI standard**
    ([http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf)
    ) in the *II.10.1.7 Generic Parameters* section constraints a type either by being
    a **value type** or a **reference type** for a concrete reference type that has
    the **default constructor** . This is the problem of the .NET type system rather
    than the F# language or compiler.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于这种约束不能在F#编译目标语言**MSIL**中表达。也就是说，最新的**.NET CLI标准** ([http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf)
    )在 *II.10.1.7泛型参数* 节中通过是一个**值类型**或**引用类型**来约束类型，对于具有**默认构造函数**的具体引用类型。这是.NET类型系统的问题，而不是F#语言或编译器的问题。
- en: '**F# 4.0 Language Specification** ([http://fsharp.org/specs/language-spec/4.0/FSharpSpec-4.0-latest.pdf](http://fsharp.org/specs/language-spec/4.0/FSharpSpec-4.0-latest.pdf)
    ) hints at the observed compiler behavior in section *5.2.3* :'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**F# 4.0语言规范** ([http://fsharp.org/specs/language-spec/4.0/FSharpSpec-4.0-latest.pdf](http://fsharp.org/specs/language-spec/4.0/FSharpSpec-4.0-latest.pdf)
    )在第 *5.2.3* 节中暗示了编译器的观察行为：'
- en: '*Uses of overloaded operators do not result in generalized code unless definitions
    are marked as inline. For example, take a look at the function as shown here:*
    `let f x = x + x`'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*重载运算符的使用不会产生泛化代码，除非定义被标记为内联。例如，看看下面的函数：* `let f x = x + x`'
- en: ''
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*It results in an f function, which can be used only to add one type of value,
    such as int or float. The exact type is determined by later constraints* .'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*它产生了一个f函数，只能用来添加一种类型的值，例如int或float。确切类型由后续约束决定*。'
- en: Fortunately, the F# compiler may enforce these (and some other) type of constraints
    at compile-time using the mechanism of **statically resolved type parameters**
    . This type parameter for our (`<<<` ) operator will have the special "hat" prefix
    `^a` , assuming that the type is statically known at the point of compilation
    (compared to `'a` , assuming that the type can be anything). As this kind of statically
    polymorphic function would require a specific manner of compilation depending
    on the concrete statically resolved type that is aligned with constraints, the
    F# compiler achieves this goal with the help of **inlining** , as the language
    specification has hinted.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，F#编译器可以使用**静态解析类型参数**的机制在编译时强制执行这些（以及一些其他）类型的约束。对于我们的(`<<<`)操作符，这个类型参数将具有特殊的“帽子”前缀`^a`，假设在编译点类型是静态已知的（与`'a`相对，假设类型可以是任何东西）。由于这种静态多态函数需要根据与约束相匹配的特定静态解析类型进行特定的编译方式，F#编译器通过**内联**来实现这一目标，正如语言规范所暗示的。
- en: Function inlining
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数内联
- en: 'Let me apply the inlining mechanism to this failing `twice` function as shown
    here (`Ch10_1.fsx` ):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我将内联机制应用于这个失败的`twice`函数，如下所示（`Ch10_1.fsx`）：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note how the automatically inferred signature of the inlined `twice''` function
    carries the **hat** type `^a` along with the sought-for constraint regarding the
    type parameter statically resolved at compile-time: type `^a` must have an operator
    (`<<<` ) with the `^a * int32 -> ^a` signature.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意自动推断的内联`twice`函数签名如何携带所需的类型参数`^a`的约束，该约束在编译时静态解析：类型`^a`必须有一个操作符(`<<<`)，其签名是`^a
    * int32 -> ^a`。
- en: 'Great, now `twice''` begins to look like a polymorphic function, allowing,
    for example, the following evaluations (`Ch10_1.fsx` ):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在`twice`看起来像是一个多态函数，允许例如以下评估（`Ch10_1.fsx`）：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At the same time, it disallows the following evaluations (`Ch10_1.fsx` ):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，它禁止以下评估（`Ch10_1.fsx`）：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The compiler has provided all the above niceties after we merely added the `inline`
    qualifier to the function definition. But you should realize that the compiler
    literally injects the inlined function implementation into MSIL adjusting it for
    argument(s) having statically resolved concrete types. Inlining is the compilation
    method that allows to alleviate .NET CLR limitations.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们仅仅给函数定义添加了`inline`限定符之后，编译器就提供了所有上述的便利。但你应该意识到，编译器实际上将内联函数的实现注入到MSIL中，并对其进行调整以适应具有静态解析的具体类型的参数。内联是一种编译方法，允许减轻.NET
    CLR的限制。
- en: Static constraints
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态约束
- en: 'As it was inferred by the F# compiler for the `twice''` function earlier, the
    argument `x` can be any type `^a` as long as `^a : (static member (<<<) : ^a *
    int32 -> ^a).` This condition, either inferred by the F# compiler or, perhaps,
    intentionally imposed by the programmer is named a **static constraint** ([https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/constraints-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/constraints-%5Bfsharp%5D)
    ). There are about a dozen of argument type constraint kinds. You may check the
    **documentation** ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/constraints](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/constraints)
    ) for their complete list.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '如同之前F#编译器对`twice`函数的推断，参数`x`可以是任何类型`^a`，只要`^a : (static member (<<<) : ^a *
    int32 -> ^a).`这个条件，要么由F#编译器推断，或许，也可能是程序员有意施加的，被称为**静态约束**([https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/constraints-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/constraints-%5Bfsharp%5D)）。大约有十几种参数类型约束种类。你可以查看**文档**([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/constraints](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/constraints)）以获取它们的完整列表。'
- en: 'Constraints can be combined together with the help of the `and` construction,
    as shown in the following code snippet (`Ch10_2.fsx` ):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`and`构造来组合约束，如下面的代码片段所示（`Ch10_2.fsx`）：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have two discriminated unions here: `Good` , which is **equitable** and
    **comparable** by default, and `Bad` , which is also normally equitable and comparable,
    but here it is decorated with `[<NoEquality; NoComparison>]` attributes. As the
    `constrained` function requires its generic `param` argument to be of both equitable
    and comparable types, `constrained Good` gets compiled, while `constrained Bad`
    does not.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两种区分联合：`Good`，默认情况下是**公平的**和**可比较的**，而`Bad`，通常也是公平的且可比较的，但在这里它被装饰了`[<NoEquality;
    NoComparison>]`属性。由于`constrained`函数要求其泛型`param`参数既是公平的又是可比较的类型，因此`constrained
    Good`可以编译，而`constrained Bad`则不能。
- en: Explicit or inferred constraining?
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式或推断约束？
- en: 'A few years ago, I was tinkering with creating F# generic code. At that time,
    my thinking was along these lines: if I need to create a generic function that
    can deal with a restricted handful of argument types, the right approach would
    be to appropriately and explicitly constrain the latter. I even asked on **StackOverflow**
    ([http://stackoverflow.com/q/16737675/917053](http://stackoverflow.com/q/16737675/917053)
    ) what the idiomatic approach would be. **One of the answers** ([http://stackoverflow.com/a/16738811/917053](http://stackoverflow.com/a/16738811/917053)
    ) I want to quote here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，我尝试创建 F# 泛型代码。当时，我的思路是这样的：如果需要创建一个可以处理有限几种参数类型的泛型函数，正确的做法是对后者进行适当的显式约束。我甚至在
    **StackOverflow** ([http://stackoverflow.com/q/16737675/917053](http://stackoverflow.com/q/16737675/917053)
    ) 上询问了惯用的方法。以下是我想要引用的**其中一个答案**([http://stackoverflow.com/a/16738811/917053](http://stackoverflow.com/a/16738811/917053)
    )：
- en: '*Explicit constraints are a way of stating *what you want to do* . What could
    be better than *doing it* and having the compiler statically prove that the argument
    is valid for the operations?*'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*显式约束是一种表达*你想做什么*的方式。还有什么比*做它*并且让编译器静态证明该参数对于操作是有效的更好的方法吗？*'
- en: Enlightening observation, isn't it?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个启发性的观察，不是吗？
- en: 'Nevertheless, what if you still want to explicitly limit the list of generic
    functions'' valid argument types based on some external considerations? Then,
    you may use the following approach I was hinted at in **the other answer** ([http://stackoverflow.com/a/16739483/917053](http://stackoverflow.com/a/16739483/917053)
    ) to my StackOverflow question, which is based on overloading static methods of
    the auxiliary type (`Ch10_2.fsx` ):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你仍然想根据某些外部考虑因素显式限制泛型函数的有效参数类型列表，那么你可以使用以下方法，这是我在**另一个答案**([http://stackoverflow.com/a/16739483/917053](http://stackoverflow.com/a/16739483/917053)
    )中提到的，该方法基于辅助类型的重载静态方法（`Ch10_2.fsx`）：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are three components in the preceding snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段中有三个组件：
- en: The **private** function, `impl` , which performs a required action on a generic
    restricted argument of type `'a` ; in other words, upon an argument that's not
    constrained whatsoever
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**函数`impl`，它对一个泛型受限参数类型`''a`执行所需操作；换句话说，对没有任何约束的参数执行操作'
- en: The auxiliary type `Restricting` , which has a single discriminated union case,
    `Restrict` , augmented by the overloaded static member `$` upon the required set
    of types (`byte` , `sbyte` , `int` , `uint32` , `bigint` picked just for the sake
    of illustration)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 辅助类型`Restricting`，它有一个单一的区分联合情况`Restrict`，通过在所需的类型集合（`byte`、`sbyte`、`int`、`uint32`、`bigint`仅为了说明）上重载的静态成员`$`来增强
- en: The user-facing function `doit` , whose restricted argument has been statically
    constrained by the other two pieces
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面函数`doit`，其受限参数已被其他两个部分静态约束
- en: 'Let''s look at the workings of the preceding in the following script (`Ch10_2.fsx`
    ):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下脚本（`Ch10_2.fsx`）中前面代码的工作原理：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first five use cases matching the restricted types compile just fine; the
    last four do not compile with the same diagnostics as expected:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前五个与受限类型匹配的用例可以正常编译；最后四个用例没有按照预期的诊断编译：
- en: '*no overloads match the `op_Dollar"` method*'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*没有重载匹配`op_Dollar"`方法*'
- en: 'The successful execution of the first five use cases is presented in the following
    screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了前五个用例的成功执行：
- en: '![Explicit or inferred constraining?](img/Image00048.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![显式或推断约束？](img/Image00048.jpg)'
- en: Executing explicitly constrained generic code
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 显式约束泛型代码的执行
- en: Inlining scope
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联作用域
- en: 'Inlining in F# is not limited to just module-level functions. It is perfectly
    fine to use inlining for static and instance methods of F# types. For example,
    in the following snippet, where we have type `Bar` with a static method `doIt`
    and `type Foo` on any generic type `^T` that has static member `doIt` with the
    matching signature and the `inline` member `Invoke` calling the `doIt` method
    of `^T` as shown here (`Ch10_2.fsx` ):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中的内联不仅限于模块级别的函数。使用内联静态和实例方法完全没问题。例如，在下面的代码片段中，我们有类型 `Bar`，它有一个静态方法 `doIt`
    和类型 `Foo`，它是在任何泛型类型 `^T` 上定义的，该类型有一个静态成员 `doIt`，具有匹配的签名，并且 `inline` 成员 `Invoke`
    调用 `^T` 的 `doIt` 方法，如下所示（`Ch10_2.fsx`）：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: An intricate matter that the preceding sample illustrates is accessing static
    or instance `inline` methods from outside of F# using, for example, a plain C#
    -> F# interoperability scenario. Remember that normal MSIL cannot support such
    constraints.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例所展示的一个复杂问题是，从 F# 外部访问静态或实例 `inline` 方法，例如，使用普通的 C# -> F# 互操作性场景。记住，正常的
    MSIL 无法支持这样的约束。
- en: To address this subtlety the compiled MSIL for `Invoke` method implementation
    above that C# may access just throws an exception. The actual inlined body of
    the function is kept accessible only from F# in its assembly's metadata.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个微妙的问题，上面 `Invoke` 方法实现的编译后的 MSIL 只会抛出异常。函数的实际内联体仅从 F# 在其程序集元数据中保持可访问。
- en: Inline optimizations
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联优化
- en: The relationship between inlining and code optimization is quite subtle. Usually,
    it is difficult to predict what consequences of generalization via inlining would
    be.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 内联与代码优化之间的关系相当微妙。通常，很难预测通过内联泛化的后果。
- en: 'However, sometimes, it is possible to achieve tremendous performance improvements
    via inlining. A notorious example is the F# handling of the `System.DateTime`
    equality, where the compilation of the `datetime1 = datetime2` expression involves
    boxing. Take a look at the following snippet (`Ch10_2.fsx` ):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时，通过内联可以实现巨大的性能提升。一个臭名昭著的例子是 F# 处理 `System.DateTime` 的相等性，其中 `datetime1
    = datetime2` 表达式的编译涉及到装箱。看看下面的代码片段（`Ch10_2.fsx`）：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, using just the `=` operator, we observe a certain garbage collection activity.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，仅使用 `=` 运算符，我们可以观察到一定的垃圾回收活动。
- en: 'However, suppose we just inline the redefined equality operator, `==` , as
    shown in the following snippet (`Ch10_2.fsx` ):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设我们只是内联重新定义的相等运算符 `==`，如下面的代码片段所示（`Ch10_2.fsx`）：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Then, we achieve no garbage collection activity whatsoever and an impressive
    *19(!)* times better performance.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现了完全没有垃圾回收活动，并且性能提高了令人印象深刻的 *19(!)* 倍。
- en: Writing generic code
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写泛型代码
- en: 'I would like to wrap up the theme of writing generic code with just another
    example of a non-trivial generic function that I have implemented as a **sample
    for a "functional programming" interview** ([https://infsharpmajor.wordpress.com/2013/05/03/if-google-would-be-looking-to-hire-f-programmers-part-4/](https://infsharpmajor.wordpress.com/2013/05/03/if-google-would-be-looking-to-hire-f-programmers-part-4/)
    ): given an arbitrary positive number, find a next higher number consisting of
    the same digits. If that does not exist, then return the original number.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望通过另一个非平凡泛型函数的例子来总结编写泛型代码的主题，这个函数是我作为一个“函数式编程”面试**样本**实现的（[https://infsharpmajor.wordpress.com/2013/05/03/if-google-would-be-looking-to-hire-f-programmers-part-4/](https://infsharpmajor.wordpress.com/2013/05/03/if-google-would-be-looking-to-hire-f-programmers-part-4/)）：给定一个任意正数，找到一个由相同数字组成的下一个更大的数。如果不存在这样的数，则返回原始数字。
- en: We will approach the solution as a generic function, allowing the argument to
    be of any integral type, or anything consisting of just digits, be it `byte` ,
    `BigInteger` , or `nativeint` .
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解决方案作为一个泛型函数来处理，允许参数为任何整型，或者仅由数字组成的任何东西，无论是 `byte`、`BigInteger` 还是 `nativeint`。
- en: 'The base line approach would be to split the number into a list of digits,
    making the list of all digit permutations, assembling digits back into numbers,
    sorting the list of numbers, and finally, picking the element next to the given
    argument. Apparently, the time and space complexities of this "solution" are awful,
    so let''s improve it:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 基线方法是将数字拆分为数字列表，生成所有数字排列的列表，将数字重新组合成数字，对数字列表进行排序，最后选择给定参数的下一个元素。显然，这个“解决方案”的时间和空间复杂度都很糟糕，所以让我们改进它：
- en: The first useful observation of the optimized solution would be that the solution
    exists if a pair of adjacent digits exists in the given number, where the left-hand
    side is strictly less than the right-hand side.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化解决方案的第一个有用观察是，如果给定数字中存在一对相邻的数字，其中左侧的数字严格小于右侧的数字，则解决方案存在。
- en: The next useful observation would be that if we scan the list of digits of the
    given number from right to left by a sliding window of width 2, then the first
    pair that matches the first observation would be the place of change. Everything
    to the left of it (if any exists) must stay intact.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个有用的观察是，如果我们从右到左以宽度为2的滑动窗口扫描给定数字的数字列表，那么第一个与第一个观察结果匹配的数字对将是变化的位置。它左边的所有内容（如果有的话）必须保持不变。
- en: The final useful observation is to take the pair that matches the second observation.
    The sublist to the right including the right element of the pair is sorted from
    right to left. The digit that must substitute the left element of the pair must
    be the minimally greater digit from the sublist. The left element that we just
    substituted should be placed some place to the right, preserving the sublist order.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个有用的观察是取与第二个观察结果匹配的数字对。包括对数字对的右侧元素在内的右侧子列表是从右到左排序的。必须替换数字对的左侧元素的数字必须是子列表中的最小较大数字。我们刚刚替换的左侧元素应该放置在某个位置，以保持子列表的顺序。
- en: 'Now, if we concatenate (if nonempty) the sublist to the left of the changing
    digit, followed by the substituting digit, followed by the reversed sublist after
    accommodating the changing digit and convert the resulting digit list to the number,
    this would yield the solution with a surprisingly good time complexity of `O(n)`
    and a space complexity of `O(n)` , where n is the number of digits in the original
    number. The solution snippet is as follows (`Ch10_3.fsx` ):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们连接（如果非空）变化数字左侧的子列表，然后是替换数字，然后是适应变化数字后的反转子列表，并将结果数字列表转换为数字，这将产生一个具有出奇好的时间复杂度`O(n)`和空间复杂度`O(n)`的解决方案，其中n是原始数字中的数字数量。解决方案代码片段如下（`Ch10_3.fsx`）：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s see this in action by running some usage cases via FSI as shown in the
    following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下截图中的FSI运行一些使用案例来观察这个效果：
- en: '![Writing generic code](img/Image00049.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![编写泛型代码](img/Image00049.jpg)'
- en: Generic implementation of non-trivial function
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 非平凡函数的泛型实现
- en: Take into account the complexity of the static constraint expression that the
    F# compiler has inferred for `nextHigher` , as shown in the preceding screenshot.
    It would be really challenging to come up with an expression that complicated
    from the top of your head. Let the compiler do its job indeed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到F#编译器为`nextHigher`推断的静态约束表达式的复杂性，如前一个截图所示。从您脑海中想出一个如此复杂的表达式确实是一项挑战。让编译器真正地做它的工作吧。
- en: Type augmentation
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型增强
- en: The opposite of generalization is specialization, and it is associated with
    **type augmentation** in F#. It is worth noting that the official **F# 4.0 Language
    Specification** ([http://fsharp.org/specs/language-spec/4.0/FSharpSpec-4.0-latest.pdf](http://fsharp.org/specs/language-spec/4.0/FSharpSpec-4.0-latest.pdf)
    ) does not introduce this terminology using **type extension** instead. Nevertheless,
    the *type augmentation* expression is de-facto ubiquitous and used interchangeably
    with *type extension* . Personally, I believe that *augmentation* is free of the
    undesired connotation that *extension* carries as something that's *added* to
    an existing matter. Augmentation is a better synonym for the *specialization*
    of an existing matter by adding, customizing, or even removing features. So we
    will stick to it here.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一般化的对立面是专业化，它与F#中的**类型增强**相关联。值得注意的是，官方的**F# 4.0语言规范**([http://fsharp.org/specs/language-spec/4.0/FSharpSpec-4.0-latest.pdf](http://fsharp.org/specs/language-spec/4.0/FSharpSpec-4.0-latest.pdf)
    )没有使用**类型扩展**来引入这个术语。尽管如此，*类型增强*表达式实际上是普遍存在的，并且与*类型扩展*可以互换使用。我个人认为，*增强*是一个更好的同义词，因为它表示通过添加、定制甚至删除功能来对现有事物进行专业化。因此，我们将坚持使用它。
- en: 'The following figure shows two flavors of type augmentation available in F#.
    Both use the same syntax but represent different use cases. Intrinsic augmentation
    customizes your own code, while optional augmentation may customize types outside
    of your code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了F#中可用的两种类型增强方式。它们使用相同的语法，但表示不同的用例。内省增强定制您的代码，而可选增强可能定制代码之外的类型：
- en: '![Type augmentation](img/Image00050.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: F# flavors of type augmentation
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'But why would you need to customize your own code in the first place? This
    is where certain F#-specific patterns of usage kick in. They can be spotted time
    and again both inside the F# core libraries and outside in third-party extensions.
    They explain how a bare type gets created first and then acquires an associated
    module that carries some helper functions and finally, how the type gets extended
    by some static methods. We can consider the **definition of complex type** ([https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs](https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs)
    ) as a manifestation of this pattern:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: On `complex.fs`   **source line 13** ([https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs#L13](https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs#L13)
    ), the bare type `Complex` is defined as having custom `equality` and `comparison`
    properties and being the value type
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On `complex.fs`   **source line 39** ([https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs#L39](https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs#L39)
    ), the module `Complex` is defined as carrying the entire slew of helper functions
    covering, in particular, all math operations in complex numbers
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, on `complex.fs`   **source line 99** ([https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs#L99](https://github.com/fsprojects/powerpack-archive/blob/master/src/FSharp.PowerPack/math/complex.fs#L99)
    ), type `Complex` is supplied by static operators for complex math numbers expressed
    via previously defined helper functions
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding definition may be considered as a very neat template of idiomatic
    intrinsic augmentation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Let me walk you through some typical use cases of augmenting types.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Augment by removing
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At first glance, augment by removing may sound like an oxymoron. However, it
    is not; just bear with me. Take a look at the following code snippet (`Ch10_4.fsx`
    ):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, my intent was to hide the pattern matching behind properties of the discriminated
    union type `Outcome` . However, suddenly, this seemingly innocuous piece of code
    does not compile, as the following screenshot shows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![Augment by removing](img/Image00051.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: F# DU implementation detail leaks out
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The F# compiler accompanies the red squiggle line under the `IsFailure` property
    name with a surprise message (refer to the preceding screenshot), prompting that
    the compiler also augments each `<Name>` use case of discriminated unions with
    the `Is<Name>` private property by default, and by defining the identically named
    property, we made this detail leak out.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we effectively remove default compiler-generated augmentation from the
    `Outcome` definition? It so happens that we can do that using the .NET attribute
    especially designated for this purpose: **DefaultAugmentation** ([https://msdn.microsoft.com/visualfsharpdocs/conceptual/core.defaultaugmentationattribute-class-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/core.defaultaugmentationattribute-class-%5bfsharp%5d)
    ).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否有效地从`Outcome`定义中移除默认的编译器生成的增强？恰好我们可以使用.NET属性来实现这一点，这个属性专门为此目的而设计：**DefaultAugmentation**
    ([https://msdn.microsoft.com/visualfsharpdocs/conceptual/core.defaultaugmentationattribute-class-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/core.defaultaugmentationattribute-class-%5bfsharp%5d)
    )。
- en: If we just decorate the `Outcome` type definition with the `[<DefaultAugmentation(false)>]`
    attribute, then everything gets back to the intuitively expected behavior, and
    the property name clash shown above vanishes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是用`[<DefaultAugmentation(false)>]`属性装饰`Outcome`类型定义，那么一切都会回到直观预期的行为，并且上述属性名冲突就会消失。
- en: Augment by adding
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过添加来增强
- en: Now let me do quite the opposite and augment types by adding features. I'm going
    to use a real (simplified, of course) case from Jet.com technology practices.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我来做完全相反的事情，通过添加特性来增强类型。我将使用来自Jet.com技术实践的真实的（当然，简化后的）案例。
- en: 'Imagine that Jet''s e-commerce platform supports the following transaction
    kinds (`Ch10_4.fsx` ):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下Jet的电子商务平台支持以下交易类型（`Ch10_4.fsx`）：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When we aggregate these transactions for payment or analytics purposes, it is
    highly desired that you operate upon collections that represent any mix of valid
    transactions. But we cannot mix different types in a typed collection, can we?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为了支付或分析目的而汇总这些交易时，非常希望您能够操作代表任何有效交易混合的集合。但是，我们能否在类型化集合中混合不同的类型呢？
- en: 'The naive brute-force approach might be exploiting the fact that any .NET type
    is a subtype of `System.Object.` So, the following collection might be perfectly
    OK (`Ch10_4.fsx` ):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 傻瓜式的暴力方法可能会利用任何.NET类型都是`System.Object`子类型的事实。因此，以下集合可能是完全可行的（`Ch10_4.fsx`）：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, this approach wipes out one of the major benefits of F#, namely static
    type safety, which means that unfortunately, having the following collection is
    also perfectly OK from the standpoint of the F# compiler:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法抹去了F#的一个主要优势，即静态类型安全，这意味着不幸的是，从F#编译器的角度来看，以下集合也是完全可行的：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A hardcore OOP developer would continue to lean on inheritance, introducing
    something like the `Transaction` superclass as shown here (`Ch10_4.fsx` ):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一个核心的面向对象开发者会继续依赖继承，引入类似于这里所示的`Transaction`超类（`Ch10_4.fsx`）：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is an acceptable approach, but it's not flexible from the standpoint of
    potential future extensions. Also it is awkward overall.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可接受的方法，但从潜在的未来扩展的角度来看，它不够灵活。而且总体来说也很尴尬。
- en: Any other ideas? Yes, type augmentation comes to the rescue! Well, in a sense.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他想法吗？是的，类型增强来拯救！好吧，从某种意义上说。
- en: 'Let me define a dummy **marker interface ** `ITransaction` , as following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我定义一个虚拟的**标记接口** `ITransaction`，如下所示：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, unfortunately, F# does not allow you to add an interface to an already
    defined type later. But we can still define our transactions, augmenting the standard
    DU as following (`Ch10_4.fsx` ):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不幸的是，F#不允许您在已定义的类型之后添加接口。但我们可以仍然定义我们的交易，按照以下方式增强标准的DU（`Ch10_4.fsx`）：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Furthermore, we can use the idiomatic trick with F# supporting function contravariant
    arguments:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用F#支持函数逆变参数的惯用技巧：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we can represent the sought-for collection as following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以按照以下方式表示所寻求的集合：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So far, so good. Now `ll` is strongly typed `ITransaction` list, but it can
    carry any current (and future, if required) transaction kinds. Having the latter
    mixed together is not a big deal if a disassembly back to concrete transactions
    is needed, as following (`Ch10_4.fsx` ):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。现在`ll`是强类型的`ITransaction`列表，但它可以携带任何当前（以及如果需要的话，未来）的交易类型。如果需要将它们解装回具体的交易，混合在一起并不是一个大问题，如下所示（`Ch10_4.fsx`）：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: (The cryptic turning off the compiler warning "25" in the beginning of the above
    script addresses the manner the matching by type works. The F# compiler assumes
    that it may be more types "implementing" `ITransaction` than are included into
    preceding `match` expression. I know that I covered all cases there, so the warning
    would be just a noise.)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: （在上面的脚本开头神秘地关闭编译器警告“25”是为了说明类型匹配的方式。F#编译器假设可能有比前面`match`表达式包含的更多“实现”`ITransaction`的类型。我知道我已经涵盖了那里所有的案例，所以这个警告只是一个噪音。）
- en: 'Equipped with this machinery, it is easy to perform, for example, an aggregation
    of a list of concrete transactions in a single payment (`Ch10_4.fsx` ):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '配备了这些工具，执行例如将具体交易列表聚合到单一付款中的操作就变得容易了 (`Ch10_4.fsx` ):'
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Running the preceding script in FSI will produce the results shown in the following
    screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FSI 中运行前面的脚本将产生以下截图所示的结果：
- en: '![Augment by adding](img/Image00052.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![通过添加增强](img/Image00052.jpg)'
- en: Augmenting DU with the marker interface
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标记接口增强 DU
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter demonstrated how to approach matters of code generalization and/or
    specialization in situations when such adjustments are appropriate.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了在适当的情况下如何处理代码泛化与/或特殊化的问题。
- en: In the next chapter, we will just scratch the surface of the advanced F# patterns,
    as their detailed coverage may require another book.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们仅仅会触及到高级 F# 模式的表面，因为它们的详细覆盖可能需要另一本书来阐述。
