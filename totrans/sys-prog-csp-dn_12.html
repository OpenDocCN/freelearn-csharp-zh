<html><head></head><body>
		<div id="_idContainer065">
			<h1 class="chapter-number" id="_idParaDest-259"><a id="_idTextAnchor260"/>12</h1>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor261"/>The One with the Security Safeguards</h1>
			<p><em class="italic">Security essentials for </em><span class="No-Break"><em class="italic">systems programming</em></span></p>
			<p>Security is<a id="_idIndexMarker980"/> more critical these days than ever. Software never stands alone; it always works with hardware and other software packages. Attackers do whatever they can to find the weakest link in the chain. As developers, we must ensure our software is not the <span class="No-Break">weakest link.</span></p>
			<p>Security is not a “thing” but a mindset and a process. It is a never-ending quest to find the best solution, keeping in mind maintainability and useability. As system programmers, we have to trade off security against performance and <span class="No-Break">memory usage.</span></p>
			<p>This makes building secure software a challenge. But let’s be honest – isn’t that sort of challenge the reason we chose <span class="No-Break">this profession?</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Why do we need to care about security as <span class="No-Break">system programmers?</span></li>
				<li>How to work with <span class="No-Break">strings securely</span></li>
				<li>How to handle keys in <span class="No-Break">your systems</span></li>
				<li>What are the requirements around credentials <span class="No-Break">and privileges?</span></li>
				<li>How do you transfer data safely across <span class="No-Break">a network?</span></li>
			</ul>
			<p>Security is an important but complicated topic. I will not cover everything there is to say about security. Still, as a system programmer, I will touch upon the most important things you should know. But let’s not talk too loudly – we must keep our secrets to ourselves! So, make sure nobody is listening in, and then <span class="No-Break">follow me.</span></p>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor262"/>Technical requirements</h1>
			<p>You will find all the code in this chapter at this <span class="No-Break">URL: </span><a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter12"><span class="No-Break">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter12</span></a><span class="No-Break">.</span></p>
			<p>If you want to follow along when I discuss Azure Key Vault, you need a subscription to Azure. You can create one <span class="No-Break">here: </span><a href="https://azure.microsoft.com/en-us/free"><span class="No-Break">https://azure.microsoft.com/en-us/free</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor263"/>Security for system programmers</h1>
			<p>When I <a id="_idIndexMarker981"/>started programming, security was not an issue. Imagine this – my computer had one connection, the one to the power outlet on the wall. And, of course, the computer was attached to a television to display whatever it needed to show. Yes, a TV. I did not have a monitor; I could not afford one back then. I started the machine up, and it would load the OS and the basic programming environment from ROM. And that was it. This setup was extremely secure – there were no attachments to anything that could interfere with my machine and data. I kept the computer in my bedroom, so physical security was also taken care of (no one goes into a teenager’s bedroom voluntarily; the mess <span class="No-Break">was unbelievable).</span></p>
			<p>Fast-forward to today. My desktop computer is always on and always connected to the internet. Some systems I have written run on a virtual machine with a cloud provider; others are serverless and waiting <span class="No-Break">for connections.</span></p>
			<p>My firewalls and application gateways inform me that other systems constantly try to connect to all those environments and machines. I have the feeling that all of those machines are under <span class="No-Break">constant threat.</span></p>
			<p>Security is something everybody in the software industry needs to be aware of all the time. Only adding security measures at the end of the development cycle is the best way to ensure attackers have access to your system. You are bound to forget something. Security must be considered at every step, from the initial design to maintaining a <span class="No-Break">running system.</span></p>
			<p>As I said in the second paragraph of this chapter, security is a mindset. You need to ask yourself continuously, “Can someone take advantage of the things I <span class="No-Break">am doing?”</span></p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor264"/>What could happen if we have a vulnerability?</h2>
			<p>I can<a id="_idIndexMarker982"/> almost hear you say, “Hey, I write low-level code, not some fancy customer-facing website. Why should I be bothered with all this?” That is a reasonable response, but there are ways you, as a system programmer, should be very aware of the risks. If you aren’t, the results could be catastrophic. Let me outline some of the things that <span class="No-Break">could happen:</span></p>
			<ul>
				<li><strong class="bold">Privilege escalation</strong>: A lot of the code we write runs with elevated privileges. Hackers who exploit a vulnerability can escalate their privilege from regular users to administrators, giving them extensive control over <span class="No-Break">a system.</span></li>
				<li><strong class="bold">Data theft</strong>: Hackers who gain access to your system can use that to steal sensitive information, such as <span class="No-Break">the following:</span><ul><li>User data, such as personal information and credit <span class="No-Break">card information</span></li><li>Confidential business data, including trade secrets, intellectual property, and <span class="No-Break">internal communications</span></li><li>System logs and configurations that might contain information about other systems, so they can be targeted <span class="No-Break">as well</span></li></ul></li>
				<li><strong class="bold">Code injection</strong>: Hackers might exploit vulnerabilities such as buffer overflows or inadequate input validation to inject malicious code into a process. This action might enable them to do <span class="No-Break">the following:</span><ul><li><strong class="bold">Execute arbitrary commands</strong>: They can run any code, potentially installing malware, ransomware, or other <span class="No-Break">malicious software</span></li><li><strong class="bold">Alter system behavior</strong>: Change how a system behaves, causing instability or hiding <span class="No-Break">their activities</span></li></ul></li>
				<li><strong class="bold">Denial of service or distributed denial of service</strong>: Attackers can disrupt the normal operation of a system by doing <span class="No-Break">the following:</span><ul><li><strong class="bold">Overloading a process</strong>: Sending excessive requests or data, causing a system to crash or <span class="No-Break">become unresponsive.</span></li><li><strong class="bold">Resource exhaustion</strong>. Consuming system resources such as CPU, memory, or disk space, leading to performance degradation or <span class="No-Break">system crashes</span></li></ul></li>
				<li><strong class="bold">Backdoors and persistent access</strong>: Once they have control over a background <a id="_idIndexMarker983"/>process, hackers can do <span class="No-Break">the following:</span><ul><li><strong class="bold">Install backdoors</strong>: Create hidden entry points to re-access a system even if the initial vulnerability <span class="No-Break">is patched</span></li><li><strong class="bold">Establish persistence</strong>: Modify a process to restart or maintain their presence on the system, even after a reboot <span class="No-Break">or restart</span></li></ul></li>
				<li><strong class="bold">Spying and surveillance</strong>: Hackers can use compromised systems to monitor and collect data over an <span class="No-Break">extended period:</span><ul><li><strong class="bold">Keystroke logging</strong>: Capture what users type, potentially stealing passwords and other <span class="No-Break">sensitive information</span></li><li><strong class="bold">Screen capture</strong>: Periodically take screenshots to monitor <span class="No-Break">users’ activity</span></li><li><strong class="bold">Network traffic monitoring</strong>: Capture data being sent to and received from <span class="No-Break">other systems</span></li></ul></li>
				<li><strong class="bold">Spreading malware</strong>: A compromised system can be used as a launchpad for <span class="No-Break">further attacks:</span><ul><li><strong class="bold">Lateral movement</strong>: Use a compromised system to move to other systems within <span class="No-Break">a network</span></li><li><strong class="bold">Propagation</strong>: Spread malware to other devices or processes, creating a larger <span class="No-Break">attack surface</span></li></ul></li>
				<li><strong class="bold">Manipulating data</strong>: Hackers can alter data processed by a <span class="No-Break">background process:</span><ul><li><strong class="bold">Data corruption</strong>: Introduce errors or malicious modifications <span class="No-Break">to data</span></li><li><strong class="bold">Tampering with logs</strong>: Modifying or deleting log entries to cover their tracks makes detecting a <span class="No-Break">breach harder.</span></li></ul></li>
			</ul>
			<p>As you can see, there <a id="_idIndexMarker984"/>are a lot of things that can go wrong if we leave our systems vulnerable. To hammer the point home, imagine a background process that monitors a serial port and handles data from an external device. That process runs 24/7, and since it deals with the lower-level Win32, we run it as an administrator. But we made a mistake somewhere, and a hacker accessed our process. The following is a potential scenario that <span class="No-Break">might happen:</span></p>
			<ol>
				<li><strong class="bold">Exploiting the vulnerability</strong>: The hacker finds and exploits a buffer overflow vulnerability in <span class="No-Break">the process.</span></li>
				<li><strong class="bold">Privilege escalation</strong>: They escalate their privilege to gain <span class="No-Break">administrative rights.</span></li>
				<li><strong class="bold">Data theft</strong>: They extract the entire database of user credentials and <span class="No-Break">personal information.</span></li>
				<li><strong class="bold">Installing a backdoor</strong>: They install a backdoor to maintain access and monitor <span class="No-Break">user activities.</span></li>
				<li><strong class="bold">Data manipulation</strong>: They alter account balances and change bank information for <span class="No-Break">accounts payable.</span></li>
				<li><strong class="bold">Disruption</strong>: Finally, they launch a DDOS attack, bringing your whole <span class="No-Break">company down.</span></li>
			</ol>
			<p>If you think this is exaggerated, I suggest you go online and find articles about security hacks. If you look hard enough, you will find many examples. Most companies are reluctant to share their experiences, but the data <span class="No-Break">is there.</span></p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor265"/>How to protect yourself</h2>
			<p>If I have<a id="_idIndexMarker985"/> scared you a little bit, good. It can be scary. But do not worry too much – following some good security practices can avert many of these risks. In fact, the rest of this chapter is all about what you, as a developer, should do to protect your systems. However, besides the coding aspect of security, there are several other things you should <span class="No-Break">be doing:</span></p>
			<ul>
				<li><strong class="bold">Holding regular security audits</strong>: Continuously review and audit your code and systems for vulnerabilities. I really would suggest hiring an external party for this. They have a lot more experience, and they are not likely to have the same blind spots as the people who developed <span class="No-Break">the systems.</span></li>
				<li><strong class="bold">Input validation</strong>: Ensure all inputs are properly validated and sanitized. Just do not trust anything coming in from an <span class="No-Break">external source.</span></li>
				<li><strong class="bold">Least privilege principle</strong>: Run processes with the minimum necessary privileges to limit <span class="No-Break">potential damages.</span></li>
				<li><strong class="bold">User modern security practices</strong>: Employ encryption, secure coding practices, and up-to-date <span class="No-Break">third-party libraries.</span></li>
				<li><strong class="bold">Monitoring and logging activities</strong>: Keep detailed logs and monitor for suspicious activities to quickly detect and respond <span class="No-Break">to breaches.</span></li>
			</ul>
			<p>So, now you <a id="_idIndexMarker986"/>know why security is important. Now, let’s investigate how to do that in <span class="No-Break">our code.</span></p>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor266"/>Working with strings</h1>
			<p>Your <a id="_idIndexMarker987"/>application likely has <strong class="bold">strings</strong>. Most of them are irrelevant to the outside world; if you write “Hello World” to a console, an attacker probably couldn’t care less about that. But other strings are a lot more interesting to these people. Consider connection strings to a database, for instance. They can be an excellent resource for a hacker. Then, there are other data, such as user information, passwords, and credit <span class="No-Break">card information.</span></p>
			<p>We can distinguish between two types <span class="No-Break">of strings:</span></p>
			<ul>
				<li>Strings that are part of your code and thus are compiled in <span class="No-Break">the binaries</span></li>
				<li>Strings that are handled in your code and originate from an outside process or go to an <span class="No-Break">outside process</span></li>
			</ul>
			<p>Let’s see whether we can protect this <span class="No-Break">sensitive data.</span></p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor267"/>Protecting settings</h2>
			<p>First, we <a id="_idIndexMarker988"/>deal with the strings in your application that are part of your code base. Think of things such as passwords and connection strings. In an ideal world, you store this information in an external file. The reason for this is that by not having them in your source code, you can change them without recompiling <span class="No-Break">your code.</span></p>
			<p>Imagine that a breach has been detected somewhere in your organization. The security department tells everybody to update their passwords. In your case, that would mean opening Visual Studio, loading the solution, changing the password to the database server, recompiling, and finally, redeploying the system. Or, on second thought, you could just change the password in the config file. I know what I would prefer <span class="No-Break">to do!</span></p>
			<p>Still, having a password in a config file is a pretty bad idea. If you have the password as part of your code, an attacker must decompile your assembly to find it. If we store the password in a text file, all the attacker has to do is open that file and read the password. To counter that, we encrypt <span class="No-Break">the password.</span></p>
			<p>We have discussed encryption several times before, so I am sure you can figure out how to do this. But all the techniques we have looked at so far require a password to be part of the source code, and we just determined that that is a bad idea. Storing a password in a config file to enable decrypting the rest of the file sounds even worse. There must be a better way. <span class="No-Break">There is.</span></p>
			<p>Let’s <span class="No-Break">investigate this.</span></p>
			<p>I have a sample application that has some sensitive information. I have this information in a file called <strong class="source-inline">appsettings.json</strong>. You know – a typical .NET-based configuration file. It looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
{
  "MyPublicSettings": {
    "Setting1": "Value1",
    "Setting2": "Value2",
    "Setting3": "Value3"
  },
  "MySecretSettings": {
    "MySecretSetting1": "SecretValue1",
    "MySecretSetting2": "SecretValue2"
  }
}</pre>			<p>We <a id="_idIndexMarker989"/>have two sections – insensitive data and data we do not want others to read. We need to protect the latter. Now, the way we handle this is a bit inconvenient. We must write a separate program to encrypt the data before writing the code that uses <span class="No-Break">this file.</span></p>
			<p>Start a<a id="_idIndexMarker990"/> new <strong class="bold">console application</strong> and add the following <span class="No-Break">NuGet packages:</span></p>
			<p><span class="No-Break"><strong class="source-inline">Microsoft.Extensions.Configuration</strong></span></p>
			<p><span class="No-Break"><strong class="source-inline">Microsoft.Extensions.Configuration.FileExtensions</strong></span></p>
			<p><span class="No-Break"><strong class="source-inline">Microsoft.Extensions.Configuration.Json</strong></span></p>
			<p><span class="No-Break"><strong class="source-inline">Microsoft.Extensions.DependencyInjection</strong></span></p>
			<p><span class="No-Break"><strong class="source-inline">Microsoft.AspNetCore.DataProtection</strong></span></p>
			<p>These packages are needed to read and use configuration files, and <strong class="source-inline">Microsoft.AspNetCore.DataProtection</strong> is there to protect <span class="No-Break">our data.</span></p>
			<p>To begin, we have to set up the dependency injection infrastructure. The data protection tools use this; they require packages to be injected when required. So, the first lines of our code look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
var serviceCollection = new ServiceCollection();
serviceCollection.AddDataProtection();
var serviceProvider = serviceCollection.BuildServiceProvider();
var dataProtector = serviceProvider.GetDataProtector("MySecureData");</pre>			<p>We first create a <strong class="source-inline">ServiceCollection</strong> instance. Then, we call <strong class="source-inline">AddDataProtection()</strong> to that collection so that all required packages are loaded and ready to use. After getting <strong class="source-inline">serviceProvider</strong>, we get an instance of an <strong class="source-inline">IDataProtector</strong> interface by calling <strong class="source-inline">GetDataProtector()</strong>. This method expects a parameter – a string describing the purpose. This string can be anything you want; it acts as a label so that you can group items. Think of it as labeling your encrypted data so<a id="_idIndexMarker991"/> that you can later track what belongs <span class="No-Break">to what.</span></p>
			<p>Then, we read the config file into the <span class="No-Break">configuration infrastructure:</span></p>
			<pre class="source-code">
var configuration = new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile("appsettings.json")
    .Build();</pre>			<p>Do not forget to mark your <strong class="source-inline">appsettings.json</strong> file as <strong class="source-inline">Copy when newer</strong> in Solution Explorer; otherwise, your code will not <span class="No-Break">load it.</span></p>
			<p>OK, now for the funny part – we reread the configuration file, but this time as text. We do this because we will replace the sensitive strings with encrypted versions. This is the code to <span class="No-Break">read it:</span></p>
			<pre class="source-code">
var json = File.ReadAllText("appsettings.json");</pre>			<p>The <strong class="source-inline">json</strong> string now holds our complete settings file. It’s time to <span class="No-Break">start encrypting!</span></p>
			<p>First, we read the section we want to protect, iterate through all the items in that section, encrypt the values, and then change the strings in the <strong class="source-inline">json</strong> variable. Finally, we write the new string to the configuration file. This is what that <span class="No-Break">looks like:</span></p>
			<pre class="source-code">
var secretSection = configuration.GetSection("MySecretSettings");
foreach (var key in secretSection.GetChildren())
{
    var originalValue = key.Value;
    var encryptedValue = dataProtector.Protect(originalValue);
    var oldValue = $"\"{key.Key}\": \"{originalValue}\"";
    var newValue = $"\"{key.Key}\": \"{encryptedValue}\"";
    json = json.Replace(oldValue, newValue);
}
File.WriteAllText("appsettings.json", json);</pre>			<p>The <a id="_idIndexMarker992"/>call to <strong class="source-inline">dataProtector.Protect()</strong> does all the hard work for us. It takes a string and encrypts it. We replace the old value with the new one and write it in <span class="No-Break">the file.</span></p>
			<p>If you open the <strong class="source-inline">appsettings.json</strong> file (the one in the folder with the debug build, not the original one!), you will see that the secret strings are not human-readable anymore. So, anyone opening that file will not have access to <span class="No-Break">our secrets!</span></p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor268"/>Reading encrypted data</h2>
			<p>In an <a id="_idIndexMarker993"/>application where you intend to use secret strings, you can simply read the data from the configuration file and decrypt them. That goes <span class="No-Break">like this:</span></p>
			<pre class="source-code">
configuration.Reload();
var encryptedSection = configuration.GetSection("MySecretSettings");
var someSecretValue = encryptedSection["MySecretSetting1"];
var decryptedValue = dataProtector.Unprotect(someSecretValue);
$"Encrypted value was: {someSecretValue}\nDecrypted this becomes: {decryptedValue}".Dump();</pre>			<p>First, I reload the configuration to ensure the object has the encrypted strings. Then, I get the section and read the first setting and its value. Finally, I use <strong class="source-inline">dataProtector</strong> to decrypt the string. The result is a lovely, unencrypted, <span class="No-Break">readable string.</span></p>
			<p>Of course, you should not do encryption and decryption in production systems using the same program. You need to split them up. When you do, remember to use the same string for the purpose. If you do not do that, you will get an exception telling you that the decryption did not work. <span class="No-Break">Try this:</span></p>
			<pre class="source-code">
var secondProtector = serviceProvider.GetDataProtector("AnotherSection");
var decryptedValue = secondProtector.Unprotect(someSecretValue);</pre>			<p>I call <strong class="source-inline">GetDataProtector()</strong> with a new purpose string, and I use that to unprotect the string. That <a id="_idIndexMarker994"/>will not work. If I use <strong class="source-inline">"MySecureString"</strong> instead of <strong class="source-inline">"AnotherSection"</strong>, it works again, even though I have a <span class="No-Break">new </span><span class="No-Break"><strong class="source-inline">DataProtector</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor269"/>Where are the keys?</h2>
			<p>You may<a id="_idIndexMarker995"/> wonder why I never specified a password to encrypt and decrypt. The answer is that the framework generates one for me. It is more or less hidden in the <strong class="source-inline">"%LocalAppData%\ASP.NET\DataProtection-Keys"</strong> folder. This special folder is where the runtime stores and reads the keys. Open that folder, pick one of the XML files, and open it to see what <span class="No-Break">it contains.</span></p>
			<p>You can specify another folder where the system stores the keys. Change the start of the program, where we call <strong class="source-inline">AddDataProtection()</strong> to add the data protection classes to <strong class="source-inline">serviceCollection</strong>, to look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
serviceCollection
    .AddDataProtection()
    .PersistKeysToFileSystem(new DirectoryInfo(myKeyFolder));</pre>			<p>This line of code tells the system to use the folder specified in <strong class="source-inline">myKeyFolder</strong> to store <span class="No-Break">the keys.</span></p>
			<p>In a production system, you can distribute the key file and store it in a known location. Of course, any attacker with access to your <strong class="source-inline">appsettings.json</strong> file probably has no problem finding the key file. There must be better ways to deal with this. And there are, but I will deal with that in the next part. First, I want to talk about the strings that are in memory. Those can be hardcoded strings in your code or decrypted strings from your settings file. Are those a potential security risk? Let’s <span class="No-Break">find out!</span></p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor270"/>Handling strings in memory</h2>
			<p>You might<a id="_idIndexMarker996"/> think encrypted strings in a configuration file are safe. After all, nobody can read them. Only your program can access them, provided it can access the key file. The program can read and decrypt the settings in memory, making everything safe and secure. Unfortunately, that is not the case. Finding that kind of information in a running program is <span class="No-Break">not hard.</span></p>
			<h3>Disclosing strings in your application</h3>
			<p>Let’s<a id="_idIndexMarker997"/> assume we have the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
var myOpenString = "This is my Open String";
Console.ReadLine();</pre>			<p>I agree. This isn’t the most exciting piece of code you have ever seen, but it does what it needs to do. It loads a string in memory and then waits for the user to press a key to abort <span class="No-Break">the program.</span></p>
			<p>Suppose I compile this in <a id="_idIndexMarker998"/>release mode and start the handy <strong class="bold">WinDbg</strong> tool (you can install that by going to the Microsoft Store and searching for it). In that case, I can do all sorts of inspections on a running program. With some digging around, I finally found <span class="No-Break">this result:</span></p>
			<pre class="source-code">
Name:        System.String
MethodTable: 00007ffaf832ec08
EEClass:     00007ffaf830a500
Tracked Type: false
Size:        66(0x42) bytes
File:        C:\Program Files\dotnet\shared\Microsoft.NETCore.App\8.0.5\System.Private.CoreLib.dll
String:      This is my Open String
Fields:
              MT    Field   Offset                 Type VT
Attr            Value Name
00007ffaf82b1188  400033b        8         System.Int32  1 instance               22 _stringLength
00007ffaf82bb538  400033c        c          System.Char  1 instance               54 _firstChar
00007ffaf832ec08  400033a       c8        System.String  0   static 000001ee80000008 Empty</pre>			<p>WinDbg gives <a id="_idIndexMarker999"/>me all sorts of information about the <strong class="source-inline">System.String</strong> object found at a specific memory location. Part of that information is the contents of that string – <strong class="source-inline">"This is my </strong><span class="No-Break"><strong class="source-inline">Open String"</strong></span><span class="No-Break">.</span></p>
			<p>My sample program is straightforward, so finding the information wasn’t hard. But the fact that I can actually do this by just attaching it to a running program shows you what a hacker can do. If your program takes encrypted data from an <strong class="source-inline">appsettings.json</strong> file and keeps that string in memory, you might as well not encrypt your data <span class="No-Break">at all.</span></p>
			<p>There must be a better way.  And guess what – <span class="No-Break">there is!</span></p>
			<h3>Using SecureStrings</h3>
			<p>We’ve <a id="_idIndexMarker1000"/>discovered that strings in memory are not secure. The people behind the BCL thought of this as well and gave us an alternative – <span class="No-Break"><strong class="source-inline">SecureString</strong></span><span class="No-Break">.</span></p>
			<p>That sounds like a <a id="_idIndexMarker1001"/>beautiful idea, but <strong class="source-inline">SecureString</strong> is less convenient than a “real” string. Not by far. However, it does have one advantage – the data in it <span class="No-Break">is encrypted.</span></p>
			<p>Creating <strong class="source-inline">SecureString</strong> is <span class="No-Break">easy enough:</span></p>
			<pre class="source-code">
using var secureString = new SecureString();</pre>			<p>But that doesn’t really help us. We want some data in it. That’s not hard, but you must copy the data one character at <span class="No-Break">a time:</span></p>
			<pre class="source-code">
var sourceString = "This is a big secret";
foreach (var c in sourceString)
{
    secureString.AppendChar(c);
}
secureString.MakeReadOnly();</pre>			<p>Now, <strong class="source-inline">secureString</strong> contains some data. The nice thing is that the data is encrypted and not <a id="_idIndexMarker1002"/>readable anymore. The call to <strong class="source-inline">MakeReadOnly()</strong> is important. By making it read-only, you ensure that the string is not changeable anymore, which helps <span class="No-Break">in performance.</span></p>
			<p><strong class="source-inline">SecureString</strong> is <a id="_idIndexMarker1003"/>mainly used to store passwords. A lot of classes in the BCL that need passwords accept <strong class="source-inline">SecureString</strong> as their parameter. For instance, these are some of the classes that can work with <span class="No-Break"><strong class="source-inline">SecureString</strong></span><span class="No-Break"> instances:</span></p>
			<ul>
				<li><strong class="source-inline">ProcessStartInfo</strong>: When starting a new process, you can provide a password as <strong class="source-inline">SecureString</strong> using the <strong class="source-inline">ProcessStartInfo</strong> struct, or by calling an overload of <strong class="source-inline">Process.Start()</strong> that <span class="No-Break">accepts </span><span class="No-Break"><strong class="source-inline">SecureString</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">NetworkCredential</strong>: When you need to identify a resource with a network resource, you can use <strong class="source-inline">NetworkCredential</strong> to pass along the required parameters, such as the username, password, and domain. The password can be an instance of the <span class="No-Break"><strong class="source-inline">SecureString</strong></span><span class="No-Break"> class.</span></li>
				<li><strong class="source-inline">CspParameters</strong> and <strong class="source-inline">X509Certificate</strong>: These are important if you are dealing with certificates, and they also allow <span class="No-Break"><strong class="source-inline">SecureString</strong></span><span class="No-Break"> instances.</span></li>
			</ul>
			<p>So, now we have a secure string. Great. But we still have an issue. Can you spot it? I will give you a minute while you look at the code that we <span class="No-Break">last discussed.</span></p>
			<p>The problem, of course, is where we seed the secure string. We create a string in memory with the <strong class="source-inline">"This is a big secret"</strong> contents and transfer it to the secure string. But the original string is still <span class="No-Break">in memory.</span></p>
			<p>We would have had the same issue if we had read an encrypted string from a configuration file, decrypted it, and copied it to the secure string. The original, decrypted string is still in memory and can be <span class="No-Break">read externally.</span></p>
			<p>The only way to circumvent it is to erase that provisional string as soon as you finish it. The unencrypted strings should be in memory for as long as possible. Technically, it is still vulnerable, but the attacker has to break the running application exactly when the strings are in memory. The attack window is still there, but it is very, <span class="No-Break">very small.</span></p>
			<p>Erasing a <a id="_idIndexMarker1004"/>string is not the same as assigning a new value – strings are<a id="_idIndexMarker1005"/> immutable. When you try to change the string, you get a new instance, and the old data is still readable. The only way to completely eradicate it from memory is to erase the chars that form the string. You can erase a string from memory with something similar to <span class="No-Break">this code:</span></p>
			<pre class="source-code">
void OverwriteAndClearString(ref string str)
{
    if (str == null) return;
    unsafe
    {
        fixed (char* ptr = str)
        {
            for (int i = 0; i &lt; str.Length; i++)
            {
                ptr[i] = '\0'; // Overwrite with null characters
            }
        }
    }
    str = null; // Dereference the string
}</pre>			<p>You have to set the <strong class="bold">Allow unsafe</strong> flag to compile this, but once you have done this,  you have another tool on your toolbelt. This code goes through the characters in the string and replaces them with <strong class="source-inline">'0'</strong>. Since <strong class="source-inline">0</strong> denotes the end of the string, it is harder to see the original length of <span class="No-Break">the string.</span></p>
			<p>I am not saying you need to call this method for every string. But suppose you are dealing with strings that you absolutely do not want to leak. In that case, this might solve the intermediate problem of copying data to a <span class="No-Break">secure string.</span></p>
			<p>But where <a id="_idIndexMarker1006"/>do we get the decryption keys from? We can distribute <a id="_idIndexMarker1007"/>them as shown previously, but there are other ways. Let’s discuss those! However, before doing that, let’s think about what we have learned. This was a complicated topic; dealing with strings in memory is not something many C# developers think about. But therein lies the problem – since people do not think about it, they are unaware of <span class="No-Break">any risks.</span></p>
			<p>Conversely, you now know about the risks and are ready to deal with them if you encounter the need for this level <span class="No-Break">of security.</span></p>
			<h1 id="_idParaDest-270"><a id="_idTextAnchor271"/>Using key management</h1>
			<p>Keys are the <a id="_idIndexMarker1008"/>best-kept secrets of your application. Keys are used to encrypt and decrypt a lot of sensitive data. This means the keys themselves are even more sensitive; they hold the power to unlock all your secrets. Storing a key in a text file next to an executable might not be the best way to treat this valuable piece <span class="No-Break">of data.</span></p>
			<p>How and where you store the keys depends on where you run your program. If your application lives in the cloud, you should use a cloud-based key management system. If you run your systems on a machine you can touch, you need <span class="No-Break">another solution.</span></p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor272"/>Using the Azure Key Vault</h2>
			<p>The <strong class="bold">Azure Key Vault</strong> is a<a id="_idIndexMarker1009"/> centralized, cloud-based secret and key management solution. It is straightforward to set up and easy to use. Its main<a id="_idIndexMarker1010"/> purpose is to guard secrets and keys for Azure-based applications. However, it can also be used by applications <span class="No-Break">running on-premise.</span></p>
			<p>I will not teach you how to create a key vault here; plenty of resources can help you. For instance, this is a good resource from Microsoft <span class="No-Break">itself: </span><a href="https://learn.microsoft.com/en-us/azure/key-vault/general/quick-create-portal"><span class="No-Break">https://learn.microsoft.com/en-us/azure/key-vault/general/quick-create-portal</span></a><span class="No-Break">.</span></p>
			<p>Once you have a key vault deployed and have added a secret, retrieving that secret is simple. But before we look at the code to get that secret, we must ensure access to the resource. That <a id="_idIndexMarker1011"/>means we make notes of the <span class="No-Break">following items:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-11">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Item name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Value</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Key <span class="No-Break">vault name</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">mykeyvault</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>The name of the key vault you specified when you <span class="No-Break">created it</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Secret name</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">MySecretValue</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>The name of <span class="No-Break">the secret</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 12.1: Values to find the Azure Key Vault secret</p>
			<p>Obviously, you <a id="_idIndexMarker1012"/>should change these values to match <span class="No-Break">your setup.</span></p>
			<p>In the C# application, we need to add a couple of <span class="No-Break">NuGet packages:</span></p>
			<ul>
				<li><strong class="source-inline">Azure.Identity</strong> to <span class="No-Break">enable authentication</span></li>
				<li><span class="No-Break"><strong class="source-inline">Azure.Security.KeyvaultSecrets</strong></span></li>
			</ul>
			<p>Once you have installed those packages, the code to get the secrets out of the key vault is very straightforward. For instance, you can use this <span class="No-Break">helper method:</span></p>
			<pre class="source-code">
public async Task&lt;string&gt; GetSecretAsync(string keyVaultUrl, string secretName)
{
    var client =
        new SecretClient(
            new Uri(keyVaultUrl),
            new DefaultAzureCredential());
    var secret =
        await client.GetSecretAsync(secretName);
    return secret.Value.Value;
}</pre>			<p>This code snippet shows how to use the <strong class="source-inline">SecretClient</strong> class from the previously installed package to access the secrets in the key vault. To authenticate this request, I use the <strong class="source-inline">DefaultAzureCredential</strong> class. Using this class means I authenticate against the Azure URL with the current <span class="No-Break">user’s credentials.</span></p>
			<p>In a <a id="_idIndexMarker1013"/>production<a id="_idIndexMarker1014"/> system, you would not do that. Instead, you should probably create a registration for your system and use that to authenticate. Authentication in Azure is a topic that deserves its own book, but the following URL should get you on your <span class="No-Break">way: </span><a href="https://learn.microsoft.com/en-us/dotnet/azure/sdk/authentication/?tabs=command-line"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/azure/sdk/authentication/?tabs=command-line</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor273"/>Using environment variables</h2>
			<p>Even when <a id="_idIndexMarker1015"/>using Azure (and not using the default credentials), you <a id="_idIndexMarker1016"/>need to store some sort of access key, secret ID, or user ID and password before you can use the resources. The same applies when you store data encrypted in your <strong class="source-inline">appsettings.json</strong> file – you need a key to decrypt. As we saw in a previous sample, you can ask the .NET runtime to create a key for you and store it in a known place. That is one way of solving this issue, but there is also a much simpler way. We can use <span class="No-Break">environment variables.</span></p>
			<p class="callout-heading">Warning</p>
			<p class="callout">Environment variables are convenient, but they are not secure – not by a long shot. Everybody can look up their values if they have physical access to the machine. Never store sensitive information in environment variables unless you can be confident the virtual or physical machine <span class="No-Break">is secure.</span></p>
			<p>An environment variable is simply a key-value pair that lives in Windows. It is usually used to contain settings from outside of the process. This is why they can be useful for holding data we need to identify resources; they can change on the fly without changing or restarting <span class="No-Break">our application.</span></p>
			<h3>Environment variable scopes</h3>
			<p>Where precisely <a id="_idIndexMarker1017"/>these variables live and how long they persist depends on the kind of environment variable. The variables<a id="_idIndexMarker1018"/> can have a scope that affects where they persist (and how long they do so). These are the options <span class="No-Break">we have:</span></p>
			<ul>
				<li><strong class="bold">Process scope</strong>: These <a id="_idIndexMarker1019"/>variables are only available to the process that defined them, or any child processes that the main process spawns. They can be useful for temporary values that can be discarded if the process goes out <span class="No-Break">of memory.</span></li>
				<li><strong class="bold">User scope</strong>: They <a id="_idIndexMarker1020"/>are specific to the currently logged-in user. They are available to all processes that run under that user’s credentials. These variables persist <span class="No-Break">across logins.</span></li>
				<li><strong class="bold">Machine scope (or system scope)</strong>: These<a id="_idIndexMarker1021"/> variables are available to all users and processes on a machine. They require administrative privileges to set and modify but not <span class="No-Break">to read.</span></li>
				<li><strong class="bold">Session scope</strong>: These<a id="_idIndexMarker1022"/> variables are scoped to a user session. This scope is more or less the same as the user scope, but the variables are discarded as the session ends. That happens, for instance, if the user <span class="No-Break">logs off.</span></li>
				<li><strong class="bold">Volatile environment variables</strong>: This<a id="_idIndexMarker1023"/> is a special category mainly used by a system. They are intended to be temporary. Users typically do not handle or even access these. An example is the settings set during boot time that can be removed once the login <span class="No-Break">process ends.</span></li>
			</ul>
			<p>As you can see, there are a lot of different scopes, some of which most users have never even heard of before. Make sure you pick the <span class="No-Break">correct one!</span></p>
			<h3>Setting environment variables</h3>
			<p>Of course, we <a id="_idIndexMarker1024"/>can use our C# code to set variables. However, we usually do not do that; in our case, we want to set some secret data outside our application and then use it in our code. This means we have to set the data from the outside. Setting the values is typically done during the installation of our software. However, during development, you have to do <span class="No-Break">it manually.</span></p>
			<p>Setting these variables is very easily done from a PowerShell session, and the exact syntax depends on the scope you want <span class="No-Break">to achieve.</span></p>
			<h4>Process scope</h4>
			<p>I only<a id="_idIndexMarker1025"/> add this here for completeness. After all, if we set a variable so that we can read it in our application, using the <strong class="bold">process scope</strong> does not make sense. The variable is set in the scope of the PowerShell session and thus is not readable in our application. But anyway, here is how you do it. In PowerShell, enter <span class="No-Break">this command:</span></p>
			<pre class="console">
$env:MY_SECRET_ID = 12345678</pre>			<p>This command creates a new variable named <strong class="source-inline">"MY_SECRET_ID"</strong> in memory and assigns it the <span class="No-Break"><strong class="source-inline">12345678</strong></span><span class="No-Break"> value.</span></p>
			<p>If you read the data, you’ll be surprised to see that it is almost as simple as <span class="No-Break">setting it:</span></p>
			<pre class="source-code">
Write-Host $env:MY_SECRET_ID</pre>			<p>This command should return the <span class="No-Break"><strong class="source-inline">12345678</strong></span><span class="No-Break"> string.</span></p>
			<p>After setting and reading the data, you might want to erase it. Again, this is very easy <span class="No-Break">to do:</span></p>
			<pre class="console">
$env:MY_SECRED_ID = $null</pre>			<p>Note that that last command happens automatically if you close the <span class="No-Break">PowerShell session.</span></p>
			<h4>User scope</h4>
			<p><strong class="bold">User scope</strong> is the<a id="_idIndexMarker1026"/> first useable scope for our purposes. Setting this variable goes like this <span class="No-Break">in PowerShell:</span></p>
			<pre class="console">
setx MY_SECRET_ID 87654321</pre>			<p>This command creates a new variable and sets the data. The variable is stored in the Windows Registry under the <strong class="source-inline">HKEY_CURRENT_USER\Environment</strong> key. Windows keeps this value across reboots. Since the data is stored in <strong class="source-inline">HKEY_CURRENT_USER</strong>, you can only read the data in processes belonging to that user. That means you can read it during debugging<a id="_idIndexMarker1027"/> in <strong class="bold">Visual Studio</strong> (<strong class="bold">VS</strong>), but only if you run VS under the <span class="No-Break">same credentials.</span></p>
			<h4>Machine scope</h4>
			<p>The broadest scope<a id="_idIndexMarker1028"/> is the <strong class="bold">machine scope</strong>. Setting data is just as simple as using the user scope, with one <span class="No-Break">tiny addition:</span></p>
			<pre class="console">
setx MY_GLOBAL_SECRET_ID 87654321 /m</pre>			<p>The use of <strong class="source-inline">/m</strong> at the end makes this variable a machine-scoped one. This means it is stored in a different location as well; you can now find this variable in the Windows Registry under the <strong class="source-inline">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment</strong> key. This variable is persisted across reboots and is accessible to all users and processes on <span class="No-Break">that machine.</span></p>
			<h3>Reading the variables in your code</h3>
			<p>There is little use<a id="_idIndexMarker1029"/> in storing data somewhere if it is impossible to read. So, let’s investigate how we can use that data in our <span class="No-Break">C# application.</span></p>
			<p>To read the data, you only need one line of code, which <span class="No-Break">is this:</span></p>
			<pre class="source-code">
string mySecretdId =
   Environment.GetEnvironmentVariable("MY_SECRET_ID");</pre>			<p>However, remember that <strong class="source-inline">MY_SECRET_ID</strong> was set using the user scope. So, if you run your PowerShell command as an administrator, you must also run VS as an administrator. Otherwise, the code returns an <span class="No-Break">empty string.</span></p>
			<p>Do you want to see how to read the machine-scoped variable? I thought you might. This <span class="No-Break">is how:</span></p>
			<pre class="source-code">
var mySecretdId =
 Environment.GetEnvironmentVariable("MY_GLOBAL_SECRET_ID");</pre>			<p>Yes, that is the same code, with the only change being the variable name we are looking for. Not all code in this book is hard <span class="No-Break">to understand!</span></p>
			<p>There are <a id="_idIndexMarker1030"/>many more ways to handle keys, but you have now seen two of the most used ones. You now know how to use Azure Key Vault and have learned a lot about environmental variables. Let’s <span class="No-Break">move on!</span></p>
			<h1 id="_idParaDest-273"><a id="_idTextAnchor274"/>Using the right privilege level</h1>
			<p>Most systems<a id="_idIndexMarker1031"/> do not need to run as admin. Requiring your application to have admin rights is a potential security risk. It would be best to ensure your application runs on the lowest security level possible to avoid <span class="No-Break">potential leaks.</span></p>
			<p>However, sometimes you have no choice. There are certain cases where admin-level privilege is needed. The bad news is that this happens often in the world where we, system programmers, live. Our systems need an admin level more than a regular <span class="No-Break">program does.</span></p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor275"/>Admin-level scenarios</h2>
			<p>Let’s <a id="_idIndexMarker1032"/>investigate some areas where elevated privileges are needed if we <a id="_idIndexMarker1033"/>want our system to do what it needs <span class="No-Break">to do:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Filesystem operations</strong></span><span class="No-Break">:</span><p class="list-inset">Accessing <a id="_idIndexMarker1034"/>or modifying system files, such as updating or reading configuration files stored in protected directories. For instance, the <strong class="source-inline">C:\Windows\System32</strong> directory is a good example of a protected directory. You need elevated rights if you want to read something from <span class="No-Break">that folder.</span></p></li>
				<li><span class="No-Break"><strong class="bold">Registry operations</strong></span><span class="No-Break">:</span><p class="list-inset">Reading and <a id="_idIndexMarker1035"/>writing operations in the registry do not require administrative rights, unless you want to do something with secured areas. One of those areas is the <strong class="source-inline">HKEY_LOCAL_MACHINE</strong> key. That area cannot be reached without the proper <span class="No-Break">security level.</span></p></li>
				<li><span class="No-Break"><strong class="bold">Service management</strong></span><span class="No-Break">:</span><p class="list-inset">Starting, stopping, or configuring Windows services is another nice example of requiring <a id="_idIndexMarker1036"/>admin-level privileges. Also, installing and uninstalling these services need that level of trust. Since we work a lot with background processes, we can imagine scenarios where we need to control those processes from other processes. That means elevating the <span class="No-Break">level again.</span></p></li>
				<li><span class="No-Break"><strong class="bold">Network configuration</strong></span><span class="No-Break">:</span><p class="list-inset">Modifying network <a id="_idIndexMarker1037"/>settings is also a reason you might need elevated privileges. These tasks include changing an IP address, configuring network adapters, and adjusting <span class="No-Break">firewall rules.</span></p></li>
				<li><strong class="bold">System monitoring </strong><span class="No-Break"><strong class="bold">and diagnostics</strong></span><span class="No-Break">:</span><p class="list-inset">Some of <a id="_idIndexMarker1038"/>the performance counters or diagnostics tools require elevated privileges. Also, reading system logs in an event or other logs requires <span class="No-Break">admin access.</span></p></li>
			</ul>
			<p>This is not an <a id="_idIndexMarker1039"/>exhaustive list; there are other areas as well. If you run into one of those, you will find out soon enough – your system won’t work and crash with a <span class="No-Break">nice exception.</span></p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor276"/>Impersonating as an admin</h2>
			<p>If your system<a id="_idIndexMarker1040"/> does something from the preceding list, you might be tempted to install your system with admin credentials. That way, you are sure it always works. But as we have discussed before, that is not necessarily a good idea. It would be much better to go to the administrator level only when needed. When done, revert to the regular, less privileged <span class="No-Break">user account.</span></p>
			<p>How can we do that? First, we must create an account with admin-level rights on the machine where our software will run. I would not use the generic administrator account found on machines; you are better off using a <span class="No-Break">dedicated account.</span></p>
			<p>On my machine, I created an account named <strong class="source-inline">MySecureAdmin</strong>. I gave it the extremely safe password <strong class="source-inline">P@ssw0rd!</strong>. No, that’s not a password I would use in real life, but for this demonstration, it will suffice. This account is a local admin. And finally, my machine has the name <strong class="source-inline">DennisMachine</strong>. This is all the information you would need if you wanted to log in as <span class="No-Break">an administrator.</span></p>
			<p>The<a id="_idIndexMarker1041"/> technique to temporarily act as another user in your application is called impersonating. Let me show you how that <span class="No-Break">is done.</span></p>
			<p>I have created a console application and added a new class called <strong class="source-inline">ImpersonationHelper</strong>. The class imports two methods from the Win32 API – <strong class="source-inline">LogonUser</strong> and <strong class="source-inline">CloseHandle</strong>. This is <span class="No-Break">their signature:</span></p>
			<pre class="source-code">
[DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Auto)]
public static extern bool LogonUser(
    string lpszUsername,
    string lpszDomain,
    string lpszPassword,
    int dwLogonType,
    int dwLogonProvider,
    out SafeAccessTokenHandle phToken);
[DllImport("kernel32.dll", CharSet = CharSet.Auto)]
public static extern bool CloseHandle(IntPtr handle);</pre>			<p>The <strong class="source-inline">LogonUser</strong> API resides in the “<strong class="source-inline">advapi32.dll"</strong> DLL, while the <strong class="source-inline">CloseHandle</strong> API can be found <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">"kernel32.dll"</strong></span><span class="No-Break">.</span></p>
			<p>Next, I declare two constants that we will need <span class="No-Break">later on:</span></p>
			<pre class="source-code">
private const int LOGON32_LOGON_BATCH = 4;
private const int LOGON32_PROVIDER_DEFAULT = 0;</pre>			<p>That is all we <a id="_idIndexMarker1042"/>need to start impersonating. This is the code that <span class="No-Break">does that:</span></p>
			<pre class="source-code">
public static void RunAsAdmin(
    string userName, string domain,
    string password, Action action)
{
    var returnValue = LogonUser(
        userName, domain,
        password, LOGON32_LOGON_BATCH,
        LOGON32_PROVIDER_DEFAULT,
        out var safeAccessTokenHandle);
    if (!returnValue)
    {
        var ret = Marshal.GetLastWin32Error();
        throw new Win32Exception(ret);
    }
    try
    {
        WindowsIdentity.RunImpersonated(safeAccessTokenHandle, () =&gt; {           action(); });
    }
    finally
    {
        safeAccessTokenHandle.Dispose();
    }
}</pre>			<p>Let me <a id="_idIndexMarker1043"/>explain what is going <span class="No-Break">on here.</span></p>
			<p>The method gets all the required information to log into Windows – the username, password, and domain. We also give it the code we want to run under these credentials in the form of <span class="No-Break">an </span><span class="No-Break"><strong class="source-inline">Action</strong></span><span class="No-Break">.</span></p>
			<p>We call <strong class="source-inline">LogonUser()</strong> and give it the username, domain, and password. Then, we specify the login type; we give it <strong class="source-inline">LOGON32_LOGON_BATCH</strong>. This type is used for batch servers. Batch servers execute code on behalf of a user without their intervention. In contrast, a standard login would use <strong class="source-inline">LOGON32_LOGON_INTERACTIVE</strong>. The <strong class="source-inline">BATCH</strong> option results in higher performance, which is very convenient for us. After this, we give it the login provider and instruct it to use the default provider by <span class="No-Break">passing </span><span class="No-Break"><strong class="source-inline">LOGON32_PROVIDER_DEFAULT</strong></span><span class="No-Break">.</span></p>
			<p>If all goes well, we will get a pointer in <strong class="source-inline">SafeAccessTokenHandle</strong>. If it does not work, we get <span class="No-Break">an error.</span></p>
			<p>With that handle, we can call <strong class="source-inline">WindowsIdentity.RunImpersonated()</strong>, which in turn calls <span class="No-Break">our action.</span></p>
			<p>Do not forget to call <strong class="source-inline">Dispose()</strong> on <span class="No-Break">the handle!</span></p>
			<p>Using this code <span class="No-Break">is straightforward:</span></p>
			<pre class="source-code">
var userName = Environment.UserName;
$"Current user: {userName}".Dump();
var adminUserName = "MySecureAdmin";
var domain = "dennismachine";
var password = "P@ssw0rd!";
ImpersonationHelper.RunAsAdmin(
    adminUserName, domain, password, () =&gt;
{
    var otherUserName = Environment.UserName;
    $"Username {otherUserName}".Dump();
});</pre>			<p>This code uses our new class to temporarily log in as another user. But before that, it shows the current username. I do the same in the <strong class="source-inline">Action</strong>, but the results will differ. We are now logged in as the new user, which should also be shown on <span class="No-Break">the screen.</span></p>
			<p>There is<a id="_idIndexMarker1044"/> no need to log out – the call to <strong class="source-inline">LogonUser()</strong> doesn’t alter the logged-in state of that user; it is just required to get the handle. The moment we dispose of the handle, the impersonation also terminates. This means we are now back operating under the standard credentials. Run this sample and see <span class="No-Break">what happens.</span></p>
			<p>Impersonation is another nice tool in your toolbelt, but use it sparingly. Only increase the trust level in your applications if you absolutely need it. Oh, and I am sure I do not need to remind you that storing usernames and passwords in plain code in your application is terrible, especially if they belong to admin-level <span class="No-Break">users. Right?</span></p>
			<p>Many developers, by default, assume their code needs admin-level privileges. After reading this section, you now know better. We discussed the situations where admin-level is required, but please remember that less is more, especially regarding privilege levels! And if you need admin-level privileges in your code, you know how to take care of that temporarily before returning to a <span class="No-Break">normal level.</span></p>
			<h1 id="_idParaDest-276"><a id="_idTextAnchor277"/>How to transmit network data securely</h1>
			<p>As we have seen, keeping <a id="_idIndexMarker1045"/>data sensitive on your machine is hard. But things get even more complicated once we leave the safe haven of the machine we control and venture into the wasteland <span class="No-Break">of networks.</span></p>
			<p>I probably do not have to remind you that you should never use a public website that uses an HTTP connection instead of an HTTPS connection. The “S,” after all, stands for “Secure.” That is what we want – we want our data to be encrypted, and we want to be confident that the server we talk to is secure and belongs to the party we think it <span class="No-Break">belongs to.</span></p>
			<p>The same applies to our code – if we talk to an outside system, we want to ensure that our data is not being tampered with or intercepted. That also applies to other systems when they connect to us – we want to give those users the same sense of security. How do we achieve that? The answer is simple – we do the same as those HTTPS servers. The next question is, how do we implement that? And that is slightly more complicated. But don’t worry – I will walk you through it step <span class="No-Break">by step.</span></p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor278"/>How HTTPS works</h2>
			<p>Let me ask you a <a id="_idIndexMarker1046"/>question. How do you know you can trust the website you visit? Just because it says HTTPS in the address bar? But what does that mean? How can that be a guarantee? To answer that, we need to look at what HTTPS <span class="No-Break">actually means.</span></p>
			<p><strong class="bold">HTTPS</strong> stands for <strong class="bold">Hyper Text Transport Protocol Secure</strong>. This is a variation of regular<a id="_idIndexMarker1047"/> HTTP traffic – it has added security. Let’s examine <span class="No-Break">the flow:</span></p>
			<ol>
				<li>In your browser, you enter a <span class="No-Break">URL: </span><a href="https://www.microsoft.com"><span class="No-Break">https://www.microsoft.com</span></a><span class="No-Break">.</span></li>
				<li>The browser resolves the domain name to an <span class="No-Break">IP address.</span></li>
				<li>The client initiates a TCP connection with the server using a three-way handshake (SYN, SYN-ACK, <span class="No-Break">and ACK).</span></li>
				<li>The client sends a <strong class="source-inline">"ClientHello"</strong> message to the server. This message includes <span class="No-Break">the following:</span><ul><li>Supported <span class="No-Break">TLS versions</span></li><li>Supported <span class="No-Break">cipher suites</span></li><li>Supported <span class="No-Break">compression methods</span></li><li>A randomly generated value (<span class="No-Break">client random)</span></li><li>Session IDs and <span class="No-Break">extensions (optional)</span></li></ul></li>
				<li>The server then responds with a <strong class="source-inline">"ServerHello"</strong> message, which includes <span class="No-Break">the following:</span><ul><li>The chosen <span class="No-Break">TLS version</span></li><li>The chosen <span class="No-Break">cipher suite</span></li><li>The chosen <span class="No-Break">compression method</span></li><li>A randomly generated value (<span class="No-Break">server random)</span></li><li>The session ID (if supported <span class="No-Break">and desired)</span></li></ul></li>
				<li>The<a id="_idIndexMarker1048"/> server sends its digital certificate, including its public key and a digital signature, from a trusted <span class="No-Break">certificate authority.</span></li>
				<li>Then, the server may (if required) send a <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">ServerKeyExchange"</strong></span><span class="No-Break"> message.</span></li>
				<li>After that, the server requests a client certificate for <span class="No-Break">mutual authentication.</span></li>
				<li>Finally, the server sends a <strong class="source-inline">"ServerHelloDone"</strong> message, indicating that this is the end of <span class="No-Break">the handshake.</span></li>
				<li>The client then optionally sends its own certificate (<span class="No-Break">if requested).</span></li>
				<li>The client sends a <strong class="source-inline">"ClientKeyExchange"</strong> message. The contents depend on the algorithm chosen. For instance, if RSA is chosen, the client encrypts a pre-master secret with the server’s public key and sends that to <span class="No-Break">the server.</span></li>
				<li>The client sends a <strong class="source-inline">"CertificateVerify"</strong> message to prove it owns the client certificate. This involves signing a hash of the handshake messages using the client’s <span class="No-Break">private key.</span></li>
				<li>Both parties then generate the session keys (symmetric keys) for encryption and authentication, using the pre-master secret and the random values <span class="No-Break">exchanged earlier.</span></li>
				<li>The client then sends a <strong class="source-inline">"ChangeCipherSpec"</strong> message to inform the server that, from now on, all messages will be encrypted using the negotiated keys <span class="No-Break">and algorithms.</span></li>
				<li>The server also sends a <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">ChangeCipherSpec"</strong></span><span class="No-Break"> message.</span></li>
				<li>The client sends a <strong class="source-inline">"Finished"</strong> message, which is a hash of all the handshake messages encrypted with the <span class="No-Break">session key.</span></li>
				<li>The server responds with its <strong class="source-inline">"Finished"</strong> key, with the same sort <span class="No-Break">of information.</span></li>
			</ol>
			<p>From now on, the<a id="_idIndexMarker1049"/> client and the server can use the keys and algorithms to encrypt and decrypt the <span class="No-Break">data flow.</span></p>
			<p>If you think this sounds complicated, you are right. The good news is that we do not have to worry about this. All of the classes in the BCL dealing with HTTP handle this for us. All you have to do is connect to a secure server, specify that you want to use SSL, and you are good <span class="No-Break">to go.</span></p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor279"/>Certificates and certificate authorities</h2>
			<p>The <a id="_idIndexMarker1050"/>preceding steps outline how the client and server exchange keys securely. However, a key question remains – how do they know they can trust <span class="No-Break">each other?</span></p>
			<p>The answer to that question lies in the use of certificates. A certificate is a digital document containing information about the certificate’s owner. It includes the <span class="No-Break">following information:</span></p>
			<ul>
				<li><strong class="bold">Subject</strong>: The entity that the certificate represents (for instance, the website’s <span class="No-Break">domain name)</span></li>
				<li><strong class="bold">Issuer</strong>: Who issued <span class="No-Break">the certificate</span></li>
				<li><strong class="bold">Public key</strong>: The public key of <span class="No-Break">the entity</span></li>
				<li><strong class="bold">Validity period</strong>: The date range in which the certificate <span class="No-Break">is valid</span></li>
				<li><strong class="bold">Serial number</strong>: A unique identifier for <span class="No-Break">the certificate</span></li>
				<li><strong class="bold">Signature</strong>: The digital signature of the issuer, verifying that the certificate is genuine and has not been <span class="No-Break">tampered with</span></li>
			</ul>
			<p>If you get a certificate from a website, you can use that to verify that the site you are connecting to is indeed the one it claims to be. If the information on the certificate doesn’t match what is expected, you had better not use <span class="No-Break">that site.</span></p>
			<p>But how can you be sure that the certificate is valid? This question leads us to the last part of the SSL infrastructure – <span class="No-Break">certificate authorities.</span></p>
			<p>A certificate has to be obtained from a third party. These companies sell certificates, but only after they have verified that the one requested a certificate is who they say they are. We call these<a id="_idIndexMarker1051"/> companies <strong class="bold">certificate authorities</strong> (<strong class="bold">CAs</strong>). These authorities are regularly audited to make sure they can be trusted. This starts a whole chain – a CA has its own certificate. However, that certificate is a root certificate; it is implicitly trusted. No organization guarantees the CA’s certificate is valid. But if we trust that root certificate, we can assume that all certificates signed with that root certificate are also safe. Then, we can use the secondary certificate to sign another certificate. We can build a whole tree of trusted certificates, all of which can be traced back to the CA that issued the <span class="No-Break">original certificate.</span></p>
			<p>Windows<a id="_idIndexMarker1052"/> keeps track of all the trusted root certificates and stores them on the local machine. That way, the software can compare the hashes with the data it receives from the HTTPS server and make sure the certificate <span class="No-Break">is secure.</span></p>
			<p>To see these root certificates, run the <strong class="source-inline">mmc.exe</strong> command on your machine. Then, press <em class="italic">CTRL</em> + <em class="italic">M</em> to add the <strong class="bold">Certificates</strong> snap-in. Open the tree on the left to see all the trusted root certificate authorities. This is what it looks like on <span class="No-Break">my machine:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer064">
					<img alt="Figure 1﻿2.1: Root certificates in Windows" src="image/B20924_13_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1: Root certificates in Windows</p>
			<p>Your list will undoubtedly differ from mine, but these are all trusted root certificates. Windows regularly updates this list to make sure it is <span class="No-Break">still valid.</span></p>
			<p>You must get a certificate from one of these CA organizations to set up a HTTPS server. They all have a slightly different process, so I suggest you investigate some of them to see if they are suitable for you. It doesn’t matter which CA you use; all certificates suit your purposes. Some <a id="_idIndexMarker1053"/>are faster than others, and others are cheaper than others. Just pick what you feel is the best option <span class="No-Break">for you.</span></p>
			<p class="callout-heading">Be aware of free certificates!</p>
			<p class="callout">I will be very clear about this – there are no free certificates to be had at the time of writing. A few CAs issued free certificates, but that doesn’t happen anymore. The demands for verification have significantly increased; the CA needs to be more thorough than ever to combat cybercrime. And that costs money. If you see a CA that offers a free certificate, do not fall for it. Remember that if something sounds too good to be true, it probably is. Some CA organizations provide a free certificate, but they have other demands. You have to build your software on their pipelines, or you have to host with them. Ultimately, you still pay <span class="No-Break">for it.</span></p>
			<p>So, now we know what a certificate is and how to get one. But let’s be honest – if you want to play around with certificates or are still in development, you might not be ready to purchase a certificate. If that is your situation, then I have good news. There is a free alternative – you can make your <span class="No-Break">own certificate!</span></p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor280"/>Creating a development certificate</h2>
			<p>Yes, you<a id="_idIndexMarker1054"/> can create your own certificate. But this is just for experimental or development purposes. You cannot use it in a production system; the verification will fail, since your certificate is not vouched for by <span class="No-Break">a CA.</span></p>
			<p>The tools to create a certificate are part of the SDK installed with VS. Let’s make <span class="No-Break">a certificate!</span></p>
			<p>In a developer command prompt or PowerShell terminal, enter the <span class="No-Break">following command:</span></p>
			<pre class="console">
MakeCert -r -pe -ss PrivateCertStore -n "CN=localhost" -sv testcer.pvk testcer.cer</pre>			<p><strong class="source-inline">MakeCert</strong>, part of the SDK, is the tool to create a certificate. There are many options, but we do not need most of them. I have given you the minimum we need for our purpose. Let’s <a id="_idIndexMarker1055"/>investigate what we did by looking at <span class="No-Break">the parameters:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-9">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Parameter</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-r</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>This means the certificate is self-signed and not signed by <span class="No-Break">a CA.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">pe</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>This marks the private key as exportable. The private and public keys are all part of the certificate, so you need this option if you want a copy of the <span class="No-Break">private key.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">ss PrivateCertStore</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>The specifies the certificate store where the generated certificate will be placed. In our case, we use <strong class="source-inline">PrivateCertStore</strong>, one of those entries in the Management console we looked <span class="No-Break">at earlier.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">n "CN=localhost"</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>This is the <strong class="bold">distinguished name</strong> (<strong class="bold">DN</strong>) of the certificate. We set it to <strong class="source-inline">localhost</strong> (<strong class="bold">CN</strong> means <strong class="bold">common name</strong>) so that the clients know which domain this certificate <span class="No-Break">belongs to.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">sv testcer.pvk</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>We marked the private key as exportable; this option does the export. The private key is stored in the <span class="No-Break"><strong class="source-inline">testcer.pvk</strong></span><span class="No-Break"> file.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">testcer.cer</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>The filename of <span class="No-Break">the certificate</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 12.2: Parameters for MakeCert</p>
			<p>If you run the <strong class="source-inline">MakeCert</strong> command, you will be asked to enter passwords. Make sure you remember them and store them <span class="No-Break">somewhere secure!</span></p>
			<p>This command results in two files – <strong class="source-inline">testcer.cer</strong> (the certificate) and <strong class="source-inline">testcer.pvk</strong> (the private key). Make sure you treat these files as confidential; they contain your <span class="No-Break">private keys.</span></p>
			<p>The certificate can now be used, but not for everything we want to use it for. Later, we will use the certificate to encrypt data streams, but that will require a different format. These tools need a <strong class="source-inline">pfx</strong> format. Luckily, converting a <strong class="source-inline">.cer</strong> file to a <strong class="source-inline">.pfx</strong> file is easy enough. Just enter <span class="No-Break">this command:</span></p>
			<pre class="console">
pvk2pfx -pvk .\testcer.pvk -spc .\testcer.cer -pfx testcer.pfx -po "password"</pre>			<p>The <strong class="source-inline">pvk2pfx</strong> tool takes the exported private key and the certificate and converts them into a <strong class="source-inline">.pfx</strong> file. The parameters speak <span class="No-Break">for themselves.</span></p>
			<p>The certificate we created<a id="_idIndexMarker1056"/> is now stored in the certificate store under the <strong class="source-inline">PrivateCertStore</strong> section. But we also need to store the newly generated <strong class="source-inline">.pfx</strong>  file in the certificate store for later use. To do this, enter the <span class="No-Break">following command:</span></p>
			<pre class="console">
certutil -importpfx testcer.pfx</pre>			<p>In this case, the <strong class="source-inline">certutil</strong> command invoked another handy tool to take the new <strong class="source-inline">testcer.pfx</strong> file and store it in the <span class="No-Break">right place.</span></p>
			<p>And that is all there is to it. We now have our own certificate, so let’s secure some <span class="No-Break">network traffic!</span></p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor281"/>Securing TCP streams</h2>
			<p>If you have a<a id="_idIndexMarker1057"/> web server, such as IIS, you can import the <strong class="source-inline">.pfx</strong> file there. That way, you can use HTTPS on your local network. Again, this is not SSL; other clients will not accept that self-signed certificate. It is for <span class="No-Break">development only.</span></p>
			<p>However, I am not currently interested in setting up a HTTPS server. I am more concerned about the other network communication types we discussed previously. For instance, how can we secure simple, straightforward TCP communications? If we want to use sockets, how do we secure that? The answer is to use SSL, as we have seen with HTTPS. Let’s build some <span class="No-Break">secure code!</span></p>
			<p>I have created two console applications. One is a server waiting for incoming TCP connections; the other is the client connecting to <span class="No-Break">that server.</span></p>
			<p>Let’s have a look at the server code first. I have created a new class called <strong class="source-inline">SecureServer</strong>. This class gets a constructor that takes the required information to set up the server. It looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
public SecureServer(int port,
    string certificatePath,
    string certificatePassword)
{
    _port = port;
    _serverCertificate = new X509Certificate2(
        certificatePath,
        certificatePassword);
}</pre>			<p>We pass the<a id="_idIndexMarker1058"/> file path to the certificate we just created and the password in the port that the TCP socket listens to (I told you to write that down, didn’t I?). We store the port number in a local variable and use the other two variables to create an instance of the <span class="No-Break"><strong class="source-inline">X509Certificate2</strong></span><span class="No-Break"> class.</span></p>
			<p>Next is the method that starts the server. We investigated that before (in <a href="B20924_09.xhtml#_idTextAnchor181"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">The One with the Network Navigation</em>), so there shouldn’t be any surprises here. Here <span class="No-Break">it is:</span></p>
			<pre class="source-code">
public async Task StartAsync()
{
    "Server is starting...".Dump();
    var listener = new TcpListener(IPAddress.Any, _port);
    listener.Start();
    $"Server is listening on port {_port}...".Dump();
    while (true)
    {
        var clientSocket = await listener.AcceptSocketAsync();
        _ = HandleClientConnection(clientSocket);
    }
}</pre>			<p>We create an<a id="_idIndexMarker1059"/> instance of <strong class="source-inline">TcpListener</strong>, tell it to use any IP address on the machine, and give it the correct port. Then, we call <strong class="source-inline">Start()</strong> to accept incoming connections. In a never-ending loop, we wait for a client to connect. If that happens, we accept the connection with a call to <strong class="source-inline">AcceptSocketAsync()</strong> and pass the handling of the connection to a method called <strong class="source-inline">HandleClientConnection()</strong>. Let’s look at that <span class="No-Break">one next.</span></p>
			<p>The first half of the method looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
private async Task HandleClientConnection(Socket clientSocket)
{
    try
    {
        await using var sslStream =
            new SslStream(
                new NetworkStream(clientSocket),
                false);
        await sslStream.AuthenticateAsServerAsync(
            _serverCertificate,
            false,
            SslProtocols.Tls12,
            true);
        $"Client connected: {clientSocket.RemoteEndPoint}".Dump();</pre>			<p>Instead of using a normal stream, we use a specialized one called <strong class="source-inline">SslStream</strong>. This takes <strong class="source-inline">NetworkStream</strong> and a parameter, indicating whether the stream should be kept open when we finish it (we don’t want that, so we give it <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">False</strong></span><span class="No-Break">).</span></p>
			<p>Then, we <a id="_idIndexMarker1060"/>call <strong class="source-inline">AuthenticateAsServerAsync()</strong> on that <strong class="source-inline">SslStream</strong>, giving it the certificate, tell it that we do not require a client certificate, also tell it that we want to use TLS version 1.2, and finally, inform the method that we want to check the certificate revocation (hence the <strong class="source-inline">True</strong>). This one line of code makes sure the server does all the steps needed for it to set up a <span class="No-Break">secure connection.</span></p>
			<p>The rest of the method is straightforward – we read data coming in and display it. This is the rest of <span class="No-Break">that method:</span></p>
			<pre class="source-code">
        var buffer = new byte[1024];
        var bytesRead =
            await sslStream.ReadAsync(
                buffer,
                0,
                buffer.Length);
        var receivedString =
            Encoding.UTF8.GetString(
                buffer,
                0,
                bytesRead);
        $"Received from client: {receivedString}".Dump();
    }
    catch (Exception ex)
    {
        ex.Message.Dump();
    }
}</pre>			<p>And that is all! Well, almost – we need to use this method as well. But that is even simpler. In the <strong class="source-inline">Main()</strong> method, use <span class="No-Break">this code:</span></p>
			<pre class="source-code">
var certificatePath = @"d:\Certificate\testcer.pfx";
var certificatePassword = "password";
var server = new SecureServer(
    8081,
    certificatePath,
    certificatePassword);
await server.StartAsync();</pre>			<p>With all this, we <a id="_idIndexMarker1061"/>have a working and secure <span class="No-Break">socket server!</span></p>
			<p>Next up, the client! For the client, I did a similar thing. I added a new class called <strong class="source-inline">SecureClient</strong> with the <span class="No-Break">following constructor:</span></p>
			<pre class="source-code">
public SecureClient(
    string server,
    int port)
{
    _server = server;
    _port = port;
}</pre>			<p>This constructor takes two parameters – the name of the server and the port it wants to <span class="No-Break">connect to.</span></p>
			<p>Next, we define a method called <strong class="source-inline">ConnectAsync()</strong> that allows the client <span class="No-Break">to connect:</span></p>
			<pre class="source-code">
public async Task ConnectAsync()
{
    using var clientSocket = new TcpClient(_server, _port);
    await using var networkStream = clientSocket.GetStream();
    await using var sslStream =
        new SslStream(
            networkStream,
            false,
            ValidateServerCertificate);
    try
    {
        await sslStream.AuthenticateAsClientAsync(_server);
        "SSL authentication successful".Dump();
        var message = $"Hello, server! {DateTime.Now.TimeOfDay}";
        var messageBytes = Encoding.UTF8.GetBytes(message);
        await sslStream.WriteAsync(messageBytes, 0, messageBytes.Length);
    }
    catch (Exception ex)
    {
        ex.Message.Dump(ConsoleColor.Red);
    }
}</pre>			<p>This method<a id="_idIndexMarker1062"/> starts with familiar code – we create an instance of <strong class="source-inline">TcpClient</strong> and give it the server and port. After that, we open <strong class="source-inline">NetworkStream</strong> from that <strong class="source-inline">TcpClient</strong>. But then things get more interesting – we create a new instance of the <strong class="source-inline">SslStream</strong> class, giving it <strong class="source-inline">NetworkStream</strong>, the same <strong class="source-inline">False</strong> that indicates that we do not want to keep the stream open when we are done with it, and a callback method called <strong class="source-inline">ValidateServerCertificate</strong>. After that, we call <strong class="source-inline">AuthenticateAsClientAsync()</strong> to make sure the client and the server exchange messages, as<a id="_idIndexMarker1063"/> <span class="No-Break">described previously.</span></p>
			<p>The rest of this method is nothing special – we just write the bytes to <span class="No-Break">the stream.</span></p>
			<p>Let’s look at the <strong class="source-inline">ValidateServerCertificate()</strong> callback <span class="No-Break">method next:</span></p>
			<pre class="source-code">
private static bool ValidateServerCertificate(
    object sender,
    X509Certificate certificate, X509Chain chain,
    SslPolicyErrors sslPolicyErrors)
{
    if (sslPolicyErrors == SslPolicyErrors.None)
    {
        "Server certificate is valid".Dump();
        return true;
    }
    "Server certificate is invalid".Dump(ConsoleColor.Red);
    return false;
}</pre>			<p>This method is called when we create <strong class="source-inline">SslStream</strong> and is part of validating the server’s certificate. The method itself is straightforward – we just check to see whether there are any errors in the <strong class="source-inline">SslPolicyErrors</strong> enum. If there are, we return <strong class="source-inline">false</strong>. This is picked up by the <strong class="source-inline">SslStream</strong> class, which will raise <span class="No-Break">an exception.</span></p>
			<p class="callout-heading">A developers’ trick – simplify your development</p>
			<p class="callout">If you are developing a solution like this but do not have a valid certificate, there is a quick hack you can use. Change the validation method to always return <strong class="source-inline">True</strong>. That way, your client will accept all sorts of certificates, regardless of their validity. Just do not use this technique in <span class="No-Break">production code!</span></p>
			<p>Using this <a id="_idIndexMarker1064"/>class is easy. This is <span class="No-Break">the code:</span></p>
			<pre class="source-code">
var secureClient = new SecureClient("localhost", 8081);
await secureClient.ConnectAsync();</pre>			<p>Just a word of warning – this is only for development purposes. The code itself is fine for any scenario, but the certificate we created is not. We signed it ourselves, so no real client should accept it. Next, we specified that the server’s name is <strong class="source-inline">"localhost</strong>”. This apparently only works on your machine, not across a network. You could change that when you create the certificate, <span class="No-Break">of course.</span></p>
			<p>And there you have it – a working TCP client using a secure channel. You have made it much harder, if not impossible, for a hacker to eavesdrop and listen in on <span class="No-Break">your communications!</span></p>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor282"/>Next steps</h1>
			<p>I have to be honest with you. We only touched briefly on the subject of security. There are hundreds, if not thousands, of books on this topic. But the information I gave you should help you get in the right mindset. Remember that a system is only as secure as the weakest link. And security is something that you should consider from the beginning, not added as <span class="No-Break">an afterthought.</span></p>
			<p>One final warning – do not try to reinvent the wheel and come up with your own algorithms. Your solutions are never as good as what teams of hundreds of crypto and security experts can come up with. Trust them to do their job so that you can focus <span class="No-Break">on yours.</span></p>
			<p>That being said, we did cover a lot of ground. We discussed <span class="No-Break">the following:</span></p>
			<ul>
				<li>The need for security in <span class="No-Break">modern applications</span></li>
				<li>How data is represented in memory and how to protect <span class="No-Break">against that</span></li>
				<li>How to handle keys in Azure Key Vault but also in simple things such as <span class="No-Break">environment variables</span></li>
				<li>How to deal with the proper <span class="No-Break">privilege level</span></li>
				<li>How to secure your <span class="No-Break">network communications</span></li>
			</ul>
			<p>However, there is one thing that we mentioned briefly but did not cover in detail – how to pass credentials securely from our development machine to a production environment. How do we ensure the environment variables are set when deploying our solutions? This and other questions are part of the deployment strategies we can use, which happens to be the topic of the <span class="No-Break">next chapter!</span></p>
		</div>
	</body></html>