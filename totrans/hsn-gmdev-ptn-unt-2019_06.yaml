- en: Prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of using the Prototype pattern is to assist in establishing a consistent
    way of making a copy of an object, based on a Prototype. This Prototype is usually
    an **archetypal object** that we need to create several times during the lifespan
    of our application. To avoid the potential performance costs of initializing new
    objects, we can use the Prototype pattern to set up a system that's very similar
    to a photocopying machine. By implementing the Prototype pattern, we will be able
    to make copies of archetypal objects on the fly while minimizing the impact on
    the overall performance of our application. In other words, the Prototype pattern
    is a handy tool to add to our programming toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We will review the Prototype pattern's core concepts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will implement a spawn system, using the Prototype pattern as our foundation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a hands-on chapter; you will need to have a basic understanding
    of Unity and C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following specific Unity engine and C# language concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are unfamiliar with these concepts, please review them before starting
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2WviTwe](http://bit.ly/2WviTwe)'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Prototype pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Prototype pattern is categorized as a **creational pattern**, meaning that
    its primary responsibility is to optimize the process of initializing objects.
    In the Unity scripting API, we usually don't use constructors; instead, we convert
    our classes to components and attach them to GameObjects. With this approach,
    the engine manages the initialization sequence of our objects into the memory.
  prefs: []
  type: TYPE_NORMAL
- en: In theory, the initialization overhead of objects is out of our control, because
    the engine manages this for us. This statement is true to a certain degree, but
    it doesn't take into account what happens during the lifespan of a scene. If we
    need to load a prefab dynamically during a specific moment in a scene, the engine
    will not be able to prevent a sudden drop in the framerate as it loads the entire
    entity into the memory.
  prefs: []
  type: TYPE_NORMAL
- en: A **prefab** is a prefabricated container of a collection of assembled GameObjects
    and components. For example, you can have a prefab for each type of character
    in your game. Prefabs are easy to load and copy into memory. They are often referred
    to as the building blocks of a game.
  prefs: []
  type: TYPE_NORMAL
- en: The Prototype pattern offers a simple solution to this technical hurdle; instead
    of loading up a new prefab, we copy one that's already in the memory. Similar
    to a photocopying machine, we can make any number of copies that we need from
    a single reference. This approach is valid for spawning both prefabs and individual
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following UML diagram is an example of a design for a spawn system that
    uses the Prototype pattern as a foundation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d2de532-49d8-4b16-9578-8add31aff2de.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the core element of the Prototype pattern is the interface class
    named `ICopyable`. As its name suggests, any class that implements `ICopyable` will
    need to be able to return a copy of itself. In the preceding diagram, the `Enemy`
    class implements the `ICopyable` interface. This relationship indicates that we
    will be able to request instances of **Drone** and **Tank** without having to
    create new ones every time.
  prefs: []
  type: TYPE_NORMAL
- en: Associating a design pattern to a real-world system can help you to remember
    the definition of a specific pattern. Personally, I always compare the Prototype
    pattern to a photocopier.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's review a short list of the benefits and potential drawbacks related to
    the implementation of the Prototype pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduction of initialization overhead**: In theory, copying an object that''s
    already in the memory is faster than initializing a new one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability of instances in the memory**: It''s possible to copy permutations
    of a prototype object while it is transferring from one state to another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: There are structural benefits to letting objects copy themselves;
    it''s safer, and it offers a standard interface for the duplication process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintenance of references**: If there''s a race condition in which we always
    destroy our prototype object before making a copy of it, we will end up nullifying
    any benefits of using this pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unsupported and circular references**: In some instances, objects have internal
    structures that don''t support cloning. In those cases, it might be difficult
    to use the objects in a system that implements the Prototype pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we will avoid using strict computer science terminology. With
    any programming concept, there's always a scientific and practical definition.
    We will focus on the practical definitions while still considering the theoretical
    interpretations of the patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Use case example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a general understanding of the Prototype pattern, let's implement
    an actual in-game system, using the pattern as the foundation of our architecture.
    A spawn system is a perfect use case for a creational pattern like the Prototype
    pattern. Spawning enemies at the right moment is key to designing a very immersive
    experience in a video game.
  prefs: []
  type: TYPE_NORMAL
- en: The most critical technical issue that we need to avoid is a dip in the framerate
    during the spawning process of the enemies. That is why we are going to use the
    Prototype pattern; we will copy existing instances of specific enemies, instead
    of creating new ones each time we need to spawn them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take the UML diagram that we reviewed at the beginning
    of the chapter and implement it in actual code.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement a bare-bones spawn system for a game that
    includes drones and snipers as its main enemy types. At this point, let's make
    sure that our spawn system can return copies of a specific enemy type to a client.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the term **client** in this book, we mean a class that uses the
    functionality of a pattern. In our context, it's usually a `Client` class that
    permits us to test our code examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this book, we will often use interfaces in our examples. They''re
    a powerful tool in object-oriented programming. They offer a simple way to declare
    an implementation contract. Refer to the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As our first step, let''s implement an interface called `ICopyable`. We are
    going to expose a function called `Copy()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice that our interface is named `ICopyable`; this is to avoid confusing it
    with C#'s native interface, called `ICloneable`, which is used to declare a class
    as being **cloneable**. We are not going to use this C# interface in our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our interface, let''s implement it in a concrete class named
    `Enemy`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Our `Enemy` parent class is now able to return a cloned instance of itself through
    the `Copy()` function. As we mentioned previously, we didn't use the C# native
    `ICloneable` interface because we are utilizing Unity's API by using its `Instantiate()`
    function. This API function is more suitable to our context because it can persist
    the hierarchical relationships of a native Unity GameObject or component during
    the cloning process. In other words, when cloning a GameObject with `Instantiate()`,
    you are copying (cloning) its children as well. This approach is essential in
    Unity because GameObjects are often composed of multiple objects and components,
    structured in a parent-child arrangement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step involves implementing our two main enemies; let''s start with `Drone`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our `Drone` class is now a child of the `Enemy` class, and because
    child objects inherit the properties of their parents in object-oriented environments,
    the `Drone` class obtains access to the `Copy()` function. This arrangement means
    that a client will be able to request a copy of a `Drone` by calling `Copy()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s do the same for our `Sniper`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all of our concrete `Enemy` type classes written down, let''s
    implement our `EnemySpawner`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our spawn system is quite simple; it spawns enemies by making copies of any
    object that he receives that corresponds to the `Enemy` type. It's like a Xerox
    machine; feed it the right document, and it will make copies of it. However, there's
    one core difference; our `EnemySpawner` doesn't do the copying. It just asks the
    object that it receives to make a copy of itself, and then returns the copy to
    the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our enemy spawn system implementation, let''s write a `Client` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Our `Client` class is quite simple; depending on whether the player presses
    *S* or *D* on their keyboard, it will request `EnemySpawner` to return a `Drone`
    or `Sniper` instance, and then it will place it beside the previously spawned
    entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we assume that the reader has basic Unity skills and already
    knows how to set up GameObjects and attach components to them. As a quick reminder,
    to make this code example compile and work in a Unity scene, you will need to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create two GameObjects with the Drone or Sniper scripts attached to them as
    components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create one GameObject with the Client (Script) attached to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector of the Client (Script) component, set the Drone and Sniper
    GameObjects as references in the corresponding fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot displays a typical Unity scene setup for testing our
    code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3306d86-bf00-403c-9460-40dfd82887a9.png)'
  prefs: []
  type: TYPE_IMG
- en: The source code and Unity project for this book are available in the GitHub
    repository at [https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018).
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully implemented the Prototype pattern while building a simple
    spawn system. This code is a solid foundation for developing a more advanced spawn
    system. The most important lesson to keep in mind is to always consider copying
    an object before creating it. This approach is a straightforward optimization
    strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started the practical section of this book with a flexible but simple pattern.
    The overall concept behind the Prototype pattern is straightforward; instead of
    initializing new objects, we merely clone them from instances that are already
    in the memory. To maintain consistency during the cloning process, we encapsulate
    the manner in which objects clone themselves, removing this responsibility from
    the client. As a benefit, we can gain performance and consistency in the way that
    we spawn entities in our game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the Prototype pattern's close cousin, the
    Factory pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every time you learn a new pattern and adapt it to Unity, you should validate
    whether it is beneficial beyond making your code look structured. Unlike in other
    domains, game programmers are judged not just by their ability to write clean
    code, but also by how fast it runs. You will notice that a lot of design patterns
    sacrifice performance for consistency in structure.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, I recommend that you compare the performance of using `Instantiate()`
    by copying an existing object in the memory to that of using `Resource.Load()`
    to load up an existing prefab of the same object.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this task, you can experiment with Unity's native profiling tools.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend reading Unity's Profiler documentation; you can view the link in
    the *Further reading* section of this chapter. It's a good practice to profile
    your code often, especially before attempting any optimization. This approach
    will help you to avoid spending hours optimizing code that's not even executed
    that often.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Game Programming Patterns* by Robert Nystrom: [http://gameprogrammingpatterns.com](http://gameprogrammingpatterns.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unity Manual – Profiler overview: *[https://docs.unity3d.com/Manual/Profiler.html](https://docs.unity3d.com/Manual/Profiler.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
