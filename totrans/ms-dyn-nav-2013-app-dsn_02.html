<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. A Sample Application</h1></div></div></div><p>Let's create a structure of our own in Microsoft Dynamics NAV. To do this, we must think of something that is not already available in the standard package but can be built on top of it.</p><p>For our example application, we will run a squash court. Running a squash court is simple to understand but something we cannot do without changing and expanding the product. In order to define our changes, we first need to make a fit-gap analysis.</p><p>After this chapter, you will have better understanding on how to reuse the framework of the Microsoft Dynamics NAV application. We will show how to reverse engineer the application and to study its functionality by going into the application code.</p><p>For this example, some new and changed objects are required. The <a class="link" href="apa.html" title="Appendix A. Installation Guide">Appendix</a>, <em>Installation Guide</em>, describes where to find the objects and how to install and activate them.</p><p>In the first part, we will look at how to reverse engineer the standard application to look at and learn how it works and how to reuse the structures in our own solutions.</p><p>In the second part of the chapter, we will learn how to use the journals and entries in a custom application.</p><p>Lastly, we will look at how to integrate our solution with the standard application; in our case, sales invoicing.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Fit-gap analysis</h1></div></div></div><p>When we <a class="indexterm" id="id157"/>do a fit-gap analysis, we <a class="indexterm" id="id158"/>look at the company's processes and define what we can and cannot do with the standard package. When a business process can be handled with the standard software we call this a <a class="indexterm" id="id159"/>
<strong>Fit</strong>. When this cannot be done it's called a <a class="indexterm" id="id160"/>
<strong>Gap</strong>. All gaps have to be either developed or we need to purchase an add-on.</p><p>However, even when something could be done with standard software features it does not necessarily mean that doing this is wise. The standard application should be used for what it is designed for. Using <a class="indexterm" id="id161"/>standard features for something else might work in the current version but if it changes in a new version it might no longer fit. For this reason it is better to design something new instead of wrongly using standard features.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec35"/>Designing a squash court application</h2></div></div></div><p>The <a class="indexterm" id="id162"/>basic process of a squash court company is renting the courts to squash players; both members and non-members. There is a <a class="indexterm" id="id163"/>reservation and invoicing process handling different rates for members and non-members.</p><p>Although this could be implemented using items as squash courts and customers as players, this would be a typical example of using standard features wrongly. Instead of doing this, we will look at how items and customers are designed and use this to create a new squash court application.</p><p>Designing a specific application using standard NAV features is a matter of <a class="indexterm" id="id164"/>
<strong>total cost of ownership</strong> (<strong>TCO</strong>). If only one customer would use this solution, it would be better to use the standard application in a creative way. However, if we deploy the design from this chapter on a multi-tenant architecture and let thousands of companies run it, it would be economically possible to make the best application for the job. Keep this in mind each time you make a decision to design.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec36"/>Look, learn, and love</h2></div></div></div><p>To determine the design for this application, we will first look at the parts of the standard application, which we can use to learn how they work. We will use this knowledge in our own design.</p><p>In Microsoft Dynamics NAV, customer and vendor master data are maintained using <a class="indexterm" id="id165"/>
<strong>relationship management</strong> (<strong>RM</strong>). For our solution, we will create a new master data for squash players being the business part of the application. This will also be integrated with RM.</p><p>To design the squash court, we will look at the design of items in the standard package. The squash court will be the product part of our application with a journal to create reservation entries, which we can invoice.</p><p>For this invoicing process, we will use and integrate with the sales part of Microsoft Dynamics NAV. </p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Drawing the table and posting schema</h3></div></div></div><p>After <a class="indexterm" id="id166"/>we have decided on the design of our application, we <a class="indexterm" id="id167"/>can draw the tables and post the routines as we did in the previous chapter. This will clarify the design for others and guide us through the development process.</p><div><img alt="Drawing the table and posting schema" src="img/0365EN_02_01.jpg"/></div><p>In the preceding diagram, the objects in <a class="indexterm" id="id168"/>
<strong>Relationship Management</strong> and <strong>Sales</strong> are standard objects that we will possibly need to modify. The objects for the <strong>Squash Application</strong>
<a class="indexterm" id="id169"/> are new objects but based on similar objects in the standard application.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec02"/>The project approach</h3></div></div></div><p>In order to<a class="indexterm" id="id170"/> keep track of our project, we'll cut the changes into smaller tasks. The first task will be to do the changes in relationship management to be able to create a squash player from a contact. The second part is to create squash courts. The reservation and invoice processes are part three and four.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Interfacing with the standard application</h3></div></div></div><p>In our schema, we <a class="indexterm" id="id171"/>can see that we have two processes where we need to work on the standard Microsoft Dynamics NAV processes, which are <strong>Relationship Management</strong> and <strong>Sales</strong>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec37"/>Design patterns</h2></div></div></div><p>To create <a class="indexterm" id="id172"/>the squash court application, we can use proven design patterns. This will limit the risk of our development's success and make it easy to communicate with others who are familiar with the patterns.</p><p>Examples of the patterns we will use are master data, number series, and journals.</p><p>Not everything that you need will be documented in patterns. Sometimes it is necessary to innovate. If you do this, it is important to still imagine your design as a pattern and document it for future use.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Getting started</h1></div></div></div><p>In the first part of the design process, we will look at how to reverse engineer the standard application in order to learn and reuse the knowledge in our own solution.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec38"/>Creating squash players</h2></div></div></div><p>For the administration of our<a class="indexterm" id="id173"/> squash players, we use <a class="indexterm" id="id174"/>the data from the contact table. In the standard product, it is possible to create a customer or vendor with the contact data. We require the same functionality to create squash players so let's have a look at how this is done by Microsoft.</p><p>Open <strong>Contact Card</strong> and try to find this function, as shown in the following screenshot:</p><div><img alt="Creating squash players" src="img/0365EN_02_02.jpg"/></div><p>We want a function like this for our squash players. So let's get in and see what it does. For this, we need <a class="indexterm" id="id175"/>to design the page and look at the actions. The page number in this case is <strong>5050</strong>, which we can find by clicking on <strong>About this Page</strong> in the top-right corner of the page, as shown in the following screenshot:</p><div><img alt="Creating squash players" src="img/0365EN_02_03.jpg"/></div><p>This option can <a class="indexterm" id="id176"/>be very useful to find information about the fields that are not on the page, the filters, or the source table.</p><div><img alt="Creating squash players" src="img/0365EN_02_04.jpg"/></div><p>To open the page, we <a class="indexterm" id="id177"/>need to open <strong>Object Designer</strong> in <strong>Development Environment</strong> (<em>Shift</em> + <em>F12</em>), as shown in the following screenshot:</p><div><img alt="Creating squash players" src="img/0365EN_02_05.jpg"/></div><p>Here, we <a class="indexterm" id="id178"/>can find <strong>5050 Contact Card</strong> in <strong>Page</strong>:</p><div><img alt="Creating squash players" src="img/0365EN_02_06.jpg"/></div><p>We are looking for <strong>Actions</strong> on this page. They are kind of difficult to find if you are unfamiliar with <strong>Page Designer</strong>. To open <strong>Actions</strong>, the cursor should be on the blank line below the last populated line. Then click on the right mouse button and <strong>Actions</strong> or select <strong>Actions</strong> from the <strong>View</strong> drop-down menu.</p><div><img alt="Creating squash players" src="img/0365EN_02_07.jpg"/></div><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>Alternatively, you can also use the <strong>Preview</strong> option from the <strong>View</strong> drop-down menu to find the action.</p></div></div><p>Now, we<a class="indexterm" id="id179"/> are<a class="indexterm" id="id180"/> in the <strong>Action Designer</strong> and we can search for the <strong>Create as</strong> option. To see what it does, we need to go into the C/AL code by pressing <em>F9</em> or by selecting <strong>C/AL Code</strong> from the <strong>View</strong> drop-down menu:</p><div><img alt="Creating squash players" src="img/0365EN_02_09.jpg"/></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec04"/>CreateVendor versus CreateCustomer</h3></div></div></div><p>In Microsoft Dynamics NAV, there<a class="indexterm" id="id181"/> is a small difference between creating a customer and a vendor from a contact. When creating a customer, the system will ask us to select a customer template. The <strong>Vendor</strong> option does not have that. To keep things simple, we will look at and learn from the <code class="literal">Vendor</code> function in this chapter.</p><p>The customer and vendor table are almost identical in structure and fields are numbered similarly in both tables. This is called transaction mirroring between sales and purchasing, which we will discuss further in <a class="link" href="ch06.html" title="Chapter 6. Trade">Chapter 6</a>, <em>Trade</em>. We will mirror our new table in a similar way to the other Microsoft Dynamics NAV tables.</p><p>The C/AL code in <strong>Action</strong> tells us that when clicking on the <strong>Menu</strong> option, the function <code class="literal">CreateVendor</code> in the contact table is started. To copy this feature, we need to create a new function, <code class="literal">CreateSquashPlayer</code>. Let's keep that in mind while we dive further in this code.</p><div><img alt="CreateVendor versus CreateCustomer" src="img/0365EN_02_10.jpg"/></div><p>Open the contact table (5050) and search for the function <code class="literal">CreateVendor</code>. You can find functions in a table by going into the C/AL code (<em>F9</em>) from anywhere in the table designer, and by using the <strong>Find [Ctrl+F]</strong> function, as shown in the following screenshot:</p><div><img alt="CreateVendor versus CreateCustomer" src="img/0365EN_02_11.jpg"/></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Reverse engineering</h3></div></div></div><p>We need to <a class="indexterm" id="id182"/>reverse engineer this code in order to see what we <a class="indexterm" id="id183"/>need to create for our <code class="literal">CreateSquashPlayer</code> function. We will look at each part of the C/AL code in order to decide whether we need it or not.</p><div><img alt="Reverse engineering" src="img/0365EN_02_12.jpg"/></div><p>What does the following piece of code do?</p><div><pre class="programlisting">TESTFIELD("Company No.");</pre></div><p>This tests the current record for a valid <code class="literal">Company No</code>. If this fails, we cannot continue and the end user gets a runtime error.</p><div><pre class="programlisting">RMSetup.GET;
RMSetup.TESTFIELD("Bus. Rel. Code for Vendors");</pre></div><p>This reads the <code class="literal">Marketing Setup</code> table from the system and tests whether the <code class="literal">Bus. Rel. Code for Vendors</code> is valid. We need a new code for squash players here, which will be added as a new field to the setup table:</p><div><pre class="programlisting">CLEAR(Vend);
Vend.SetInsertFromContact(TRUE);
Vend.INSERT(TRUE);
Vend.SetInsertFromContact(FALSE);</pre></div><p>Here, the <code class="literal">Vendor</code> table is cleared and a function is called within that table, then a new record is inserted in the database while activating the necessary business logic. Then the same function is called again with another parameter. Since the <code class="literal">Vendor</code> table is what we are copying, we will write down that we might need a similar function as <code class="literal">SetInsertFromContact</code>:</p><div><pre class="programlisting">IF Type = Type::Company THEN
  ContComp := Rec 
ELSE
  ContComp.GET("Company No.");</pre></div><p>This code<a class="indexterm" id="id184"/> checks <a class="indexterm" id="id185"/>whether the current contact is a company. If so, it populates the <code class="literal">ContComp</code> variable with this record. If not, it populates <code class="literal">ContComp</code> with the company our current contact is related to:</p><div><pre class="programlisting">ContBusRel."Contact No." := ContComp."No.";
ContBusRel."Business Relation Code" := RMSetup."Bus. Rel. Code for Vendors";
ContBusRel."Link to Table" := ContBusRel."Link to Table"::Vendor;
ContBusRel."No." := Vend."No.";
ContBusRel.INSERT(TRUE);</pre></div><p>The <code class="literal">ContBusRel</code> function<a class="indexterm" id="id186"/> refers to the table Contact Business Relation (5054) and is a linking table in the Microsoft Dynamics NAV data model. Technically, a contact can be connected to multiple customers and vendors although this does not make sense. This table is populated here. Let's write down that we need to look into this table and see if it needs changes:</p><div><pre class="programlisting">UpdateCustVendBank.UpdateVendor(ContComp,ContBusRel);</pre></div><p>
<code class="literal">UpdateCustVendBank</code>
<a class="indexterm" id="id187"/> is an external codeunit that is used with the function <code class="literal">UpdateVendor</code>. We might need a copy of this function for our Squash players.</p><div><pre class="programlisting">MESSAGE(Text009,Vend.TABLECAPTION,Vend."No.");</pre></div><p>The preceding code gives a message box for the end user that the record is created with the new number. Now, we have a number of things on our to-do list:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a master data table that looks like the <code class="literal">Vendor</code> table.</li><li class="listitem">We need to copy the <code class="literal">CreateVendor</code> function. </li><li class="listitem">Look at the <code class="literal">Contact Business Relation</code> table and the <code class="literal">CustVendBank-Update (5055)</code> codeunit.</li></ol></div><p>Let's look at the latter to learn something important before we start with the first:</p><div><pre class="programlisting">UpdateVendor()
WITH Vend DO BEGIN
  GET(ContBusRel."No.");
  xRecRef.GETTABLE(Vend);
  NoSerie := "No. Series";
  PurchaserCode :=  Vend."Purchaser Code";
  TRANSFERFIELDS(Cont);
  "No." := ContBusRel."No.";
  "No. Series" := NoSerie;
  Vend."Purchaser Code" := PurchaserCode;
  MODIFY;
  RecRef.GETTABLE(Vend);
  ChangeLogMgt.LogModification(RecRef,xRecRef);
END;</pre></div><p>This code synchronizes<a class="indexterm" id="id188"/> the contact table with the vendor table. It <a class="indexterm" id="id189"/>does that by <a class="indexterm" id="id190"/>using the <code class="literal">TRANSFERFIELDS</code> function. This function transfers all fields with the same number from one table to another. This means that we cannot be creative with our field numbering. For example, in the contact table, the <strong>Name</strong> field is number <strong>2</strong>. If we were to use a different number for the <strong>Name</strong> field, <code class="literal">TRANSFERFIELDS</code> would not copy the information.</p><p>Using this information, our table should look like this:</p><div><img alt="Reverse engineering" src="img/0365EN_02_13.jpg"/></div><p>Notice that we use field <strong>19</strong> for our <strong>Squash Player</strong> specific field. This is because field <strong>19</strong> was used for <strong>Budgeted Amount</strong> in the vendor table. We can therefore safely assume that Microsoft will not use field <strong>19</strong> in the contact table in future.</p><p>An alternative approach for this if we wanted to be even safer is to add the fields that are specific to our solution as fields in our add-on number series. In our case, it would be 123.456.700.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>You can copy and paste fields from one table to another table. Note that table relations and C/AL code in the <code class="literal">OnValidate</code> and <code class="literal">OnLookup</code> trigger is copied as well. If the table we want to create is similar to an existing table, we could also use the <strong>Save As</strong> option from the <strong>File</strong> drop-down menu.</p></div></div><p>The next step is <a class="indexterm" id="id191"/>to add some business logic to the table. We want this table to use number series functionality just like the vendor table. This requires some standard steps:</p><div><ol class="orderedlist arabic"><li class="listitem">First we create the setup table. A number series is defined in a setup table. As the <strong>Squash Court</strong> module will be quite sophisticated, we'll create our own.<div><img alt="Reverse engineering" src="img/0365EN_02_14.jpg"/></div><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>On MSDN, you can watch a video about the singleton pattern at <a class="ulink" href="http://msdn.microsoft.com/en-us/dynamics/nav/dn722393.aspx">http://msdn.microsoft.com/en-us/dynamics/nav/dn722393.aspx</a>.</p></div></div><p>A setup table always has a single <strong>Primary Key</strong> field, as shown in the preceding screenshot, and the necessary setup fields. This table is designed to only have one single record.</p></li><li class="listitem">Then, we create a link to the number series. Our <strong>Squash Player</strong> table is now required to have a link to the number series. We can copy this field from the vendor table and can make a table relation to the <strong>No. Series</strong> table, as shown in the following screenshot:<div><img alt="Reverse engineering" src="img/0365EN_02_15.jpg"/></div></li><li class="listitem">Now, we add<a class="indexterm" id="id192"/> the C/AL business logic to our table, but <a class="indexterm" id="id193"/>first we need to define the variables that are required. These are our new <strong>Squash Setup</strong> table and the <strong>Number Series Management</strong> codeunits.<div><img alt="Reverse engineering" src="img/0365EN_02_16.jpg"/></div><p>We can define the variables in the specially created <strong>C/AL Globals</strong> menu.</p><div><img alt="Reverse engineering" src="img/0365EN_02_17.jpg"/></div><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>It is highly recommended to use the Microsoft naming standard, which allows you to copy and paste a lot of code and makes it easier for others to read your code.</p></div></div></li></ol></div><p>Number Series<a class="indexterm" id="id194"/> require three places of code. This code makes sure<a class="indexterm" id="id195"/> that the business logic of the Number Series functionality is always followed:</p><div><ol class="orderedlist arabic"><li class="listitem">The following code goes into the <code class="literal">OnInsert</code> trigger. It populates the <code class="literal">No.</code> field with the next value of the Number Series:<div><pre class="programlisting">OnInsert()
IF "No." = '' THEN BEGIN
  SquashSetup.GET;
  SquashSetup.TESTFIELD("Squash Player Nos.");
  NoSeriesMgt.InitSeries(SquashSetup."Squash Player Nos.",
    xRec."No. Series",0D,"No.","No. Series");
END;</pre></div></li><li class="listitem">The <code class="literal">OnValidate</code> trigger of the <code class="literal">No.</code> field tests when a user manually enters a value if that is allowed:<div><pre class="programlisting">No. - OnValidate()
IF "No." &lt;&gt; xRec."No." THEN BEGIN
  SquashSetup.GET;
  NoSeriesMgt.TestManual(SquashSetup."Squash Player Nos.");
  "No. Series" := '';
END;</pre></div></li><li class="listitem">Lastly, we create a new <code class="literal">AssistEdit</code> function. This function is for readability and others reading your code afterwards. The code is used in the page or form and allows users to switch between linked number series:<div><pre class="programlisting">AssistEdit() : Boolean
SquashSetup.GET;
SquashSetup.TESTFIELD("Squash Player Nos.");
IF NoSeriesMgt.SelectSeries(SquashSetup."Squash Player Nos.",
  xRec."No. Series","No. Series") 
THEN BEGIN
  NoSeriesMgt.SetSeries("No.");
  EXIT(TRUE);
END;</pre></div></li></ol></div><p>When the Number Series<a class="indexterm" id="id196"/> are in place, we can make the necessary <a class="indexterm" id="id197"/>change in the Contact Business Relation table.</p><p>In this table, we need to add the possibility to link squash players to contacts. This is done in the <strong>Properties</strong> window of <strong>Table Designer</strong> that can be accessed by pressing (<em>Shift</em> + <em>F4</em>) or by using the <strong>Properties</strong> option from the <strong>View</strong> drop-down menu, as shown in the following screenshot:</p><div><img alt="Reverse engineering" src="img/0365EN_02_18.jpg"/></div><p>First, we add the <strong>Squash player</strong> option to the <strong>Link to Table</strong> field, as shown in the following screenshot:</p><div><img alt="Reverse engineering" src="img/0365EN_02_19.jpg"/></div><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>Options are converted to SQL Integer data types. Make sure to add some blank options so when Microsoft releases other functionality we are not impacted. Changing the integer value of an existing option field requires a lot of work.</p></div></div><p>Then, we create a table relation with our new table, as shown in the following screenshot:</p><div><img alt="Reverse engineering" src="img/0365EN_02_20.jpg"/></div><p>The next step is to <a class="indexterm" id="id198"/>expand<a class="indexterm" id="id199"/> the <strong>CustVendBank-Update</strong> codeunit with a new <code class="literal">UpdateSquashPlayer</code> function. This is a copy of the <code class="literal">UpdateVendor</code> function that we discussed before. We can add functions in the <strong>Globals</strong> menu.</p><p>There are two ways to copy a function. We can create a new function manually and copy the C/AL code and variables, or we can select a function from the list and use copy and paste and then rename the function.</p><div><img alt="Reverse engineering" src="img/0365EN_02_21.jpg"/></div><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>When you add the <code class="literal">---</code> line to the function, others can see that it is not a Microsoft function. You can also include the project name like <code class="literal">---Squash</code>. This also makes the code easier to upgrade or to merge with other code.</p></div></div><p>This code also <a class="indexterm" id="id200"/>requires a new global variable, <code class="literal">SquashPlayer</code>:</p><div><pre class="programlisting">
<strong>UpdateSquashPlayer()</strong>
WITH SquashPlayer DO BEGIN
  GET(ContBusRel."No.");
  xRecRef.GETTABLE(SquashPlayer);
  NoSerie := "No. Series";
  TRANSFERFIELDS(Cont);
  "No." := ContBusRel."No.";
  "No. Series" := NoSerie;
  MODIFY;
  RecRef.GETTABLE(SquashPlayer);
  ChangeLogMgt.LogModification(RecRef,xRecRef);
END;</pre></div><p>The final piece of preparation work is to add the <strong>Bus. Rel. Code for Squash Players</strong> field to the <strong>Marketing Setup</strong> table, as shown in the following screenshot:</p><div><img alt="Reverse engineering" src="img/0365EN_02_22.jpg"/></div><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>We use the same numbering in our fields as in our objects. This makes it easier in the future to see what belongs to what if more functionality is added.</p></div></div><p>With all this preparation work, we can now finally go ahead and make our function in the contact table (5050) that we can call from the user interface:</p><div><pre class="programlisting">
<strong>CreateSquashPlayer()</strong>
TESTFIELD(Type, Type::Person);

RMSetup.GET;
RMSetup.TESTFIELD("Bus. Rel. Code for Squash Pl.");

CLEAR(SquashPlayer);
SquashPlayer.INSERT(TRUE);

ContBusRel."Contact No." := Cont."No.";
ContBusRel."Business Relation Code" := 
  RMSetup."Bus. Rel. Code for Squash Pl.";
ContBusRel."Link to Table" := 
  ContBusRel."Link to Table"::"Squash Player";
ContBusRel."No." := SquashPlayer."No.";
ContBusRel.INSERT(TRUE);

UpdateCustVendBank.UpdateSquashPlayer(Cont,ContBusRel);

MESSAGE(Text009,SquashPlayer.TABLECAPTION,SquashPlayer."No.");</pre></div><p>Please note that we<a class="indexterm" id="id201"/> do not need the <code class="literal">SetInsertFromContact</code> function. This <a class="indexterm" id="id202"/>function enables users to create a new vendor first and create a contact using the vendor information. We do not want to support this method in our application.</p><p>Now, we can add the function to the page and test our functionality:</p><div><img alt="Reverse engineering" src="img/0365EN_02_23.jpg"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Designing a journal</h1></div></div></div><p>Now, it is<a class="indexterm" id="id203"/> time to start on the product part of the squash application. In this part, we will no longer reverse engineer in detail. We will learn how<a class="indexterm" id="id204"/> to search in the standard functionality and reuse parts in our own software.</p><p>For this part, we will look at resources in Microsoft Dynamics NAV. Resources are similar to using as products as items but far less complex making it easier to look and learn.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec39"/>Squash court master data</h2></div></div></div><p>Our <a class="indexterm" id="id205"/>company has 12 courts that we want to register in Microsoft Dynamics NAV. This master data is comparable to resources so we'll go ahead and copy this functionality. Resources are not attached to the contact table like the vendor/squash player tables. We need the number series again so we'll add a new number series to our Squash Setup table.</p><p>The <strong>Squash Court</strong> table should look like this after creation:</p><div><img alt="Squash court master data" src="img/0365EN_02_24.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec40"/>Chapter objects</h2></div></div></div><p>With this <a class="indexterm" id="id206"/>chapter some objects are required. A description of how to import these objects can be found in the <a class="link" href="apa.html" title="Appendix A. Installation Guide">Appendix</a>, <em>Installation Guide</em>.</p><div><img alt="Chapter objects" src="img/0365EN_02_25.jpg"/></div><p>After the import process is completed, make sure that your current database is the default database for the Role Tailored Client and run page 123456701, <strong>Squash Setup</strong>.</p><div><img alt="Chapter objects" src="img/0365EN_02_26.jpg"/></div><p>From this page, <a class="indexterm" id="id207"/>select the action <strong>Initialize Squash Application</strong>. This will execute the C/AL code in the <code class="literal">InitSquashApp</code> function of this page, which will prepare the demo data for us to play with. The objects are prepared and tested in a Microsoft Dynamics NAV 2013 R2 W1 database.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec41"/>Reservations</h2></div></div></div><p>When running a <a class="indexterm" id="id208"/>squash court, we want to be able to keep track of reservations. Looking at standard Dynamics NAV functionality, it might be a good idea to create a squash player journal. The journal can create entries for reservations that can be invoiced.</p><p>A journal needs the object structure. The journal is prepared in the objects delivered with this chapter. Creating a new journal from scratch is a lot of work and can easily lead to making mistakes. It is easier and safer to copy an existing journal structure from the standard application that is similar to the journal we need for our design.</p><p>In our example, we have copied the Resource Journals:</p><div><img alt="Reservations" src="img/0365EN_02_27.jpg"/></div><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>You can export these objects in text format and then rename and renumber the objects to be reused easily. The Squash Journal objects are renumbered and renamed from the Resource Journal.</p></div></div><p>As explained in <a class="link" href="ch01.html" title="Chapter 1. Introduction to Microsoft Dynamics NAV">Chapter 1</a>, <em>Introduction to Microsoft Dynamics NAV</em>, all journals have the same structure. The<a class="indexterm" id="id209"/> template, batch, and register tables are almost always the same whereas the journal line and ledger entry table contain function-specific fields. Let's have a look at all of them one by one.</p><p>The <strong>Journal Template</strong> has<a class="indexterm" id="id210"/> several fields, as shown in the following screenshot:</p><div><img alt="Reservations" src="img/0365EN_02_28.jpg"/></div><p>Let's discuss these fields<a class="indexterm" id="id211"/> in more detail:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Name</strong>: This is the unique name. It is possible to define as many templates as required but usually one template per form ID and one for recurring will do. If you want journals with different source codes, you need to have more templates.</li><li class="listitem" style="list-style-type: disc"><strong>Description</strong>: A readable and understandable description for its purpose.</li><li class="listitem" style="list-style-type: disc"><strong>Test Report ID</strong>: All templates have a test report that allows the user to check for posting errors.</li><li class="listitem" style="list-style-type: disc"><strong>Form ID</strong>: For some journals, more UI objects are required. For example, the General Journals have a special form for bank and cash.</li><li class="listitem" style="list-style-type: disc"><strong>Posting Report ID</strong>: This report is printed when a user selects <strong>Post</strong> and <strong>Print</strong>.</li><li class="listitem" style="list-style-type: disc"><strong>Force Posting Report</strong>: Use this option when a posting report is mandatory.</li><li class="listitem" style="list-style-type: disc"><strong>Source Code</strong>: Here you can enter a trail code for all the postings done via this journal.</li><li class="listitem" style="list-style-type: disc"><strong>Reason Code</strong>: This functionality is similar to <strong>Source Code</strong>.</li><li class="listitem" style="list-style-type: disc"><strong>Recurring</strong>: Whenever you post lines from a recurring journal, new lines are automatically created with a posting date defined in the recurring date formula.</li><li class="listitem" style="list-style-type: disc"><strong>No. Series</strong>: When you use this feature the <strong>Document No.</strong> in the journal line is automatically populated with a new number from this Number Series.</li><li class="listitem" style="list-style-type: disc"><strong>Posting No. Series</strong>: Use this feature for recurring journals.</li></ul></div><p>The <strong>Journal Batch</strong> has various fields, as <a class="indexterm" id="id212"/>shown in the following screenshot:</p><div><img alt="Reservations" src="img/0365EN_02_29.jpg"/></div><p>Let's discuss these fields in more detail:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Journal Template Name</strong>: The name of the journal template this batch refers to</li><li class="listitem" style="list-style-type: disc"><strong>Name</strong>: Each batch should have a unique code</li><li class="listitem" style="list-style-type: disc"><strong>Description</strong>: A readable and explaining description for this batch</li><li class="listitem" style="list-style-type: disc"><strong>Reason Code</strong>: When populated this <strong>Reason Code</strong> will overrule <strong>the Reason Code</strong> from the <strong>Journal Template</strong></li><li class="listitem" style="list-style-type: disc"><strong>No. Series</strong>: When populated this <strong>No. Series</strong> will overrule the <strong>No. Series</strong> from the <strong>Journal Template</strong></li><li class="listitem" style="list-style-type: disc"><strong>Posting No. Series</strong>: When populated this <strong>Posting No. Series</strong> will overrule the <strong>Posting No. Series</strong> from the <strong>Journal Template</strong></li></ul></div><p>The <strong>Register</strong> table<a class="indexterm" id="id213"/> has various fields, as shown in the following screenshot:</p><div><img alt="Reservations" src="img/0365EN_02_30.jpg"/></div><p>Terms <a class="indexterm" id="id214"/>from the <strong>Journal Register</strong> tab that you need to know would be:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>No.</strong>: This field is automatically and incrementally populated for each transaction with this journal and there are no gaps between the numbers</li><li class="listitem" style="list-style-type: disc"><strong>From Entry No.</strong>: A reference to the first ledger entry created is with this transaction</li><li class="listitem" style="list-style-type: disc"><strong>To Entry No.</strong>: A reference to the last ledger entry is created with this transaction</li><li class="listitem" style="list-style-type: disc"><strong>Creation Date</strong>: Always populated with the real date when the transaction was posted</li><li class="listitem" style="list-style-type: disc"><strong>User ID</strong>: The ID of the end user who has posted the transaction</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec42"/>The journal</h2></div></div></div><p>The journal line<a class="indexterm" id="id215"/> has a number of mandatory fields that are required for all journals and some fields that are required for their designed functionality.</p><p>In our case, the journal should create a reservation which then can be invoiced. This requires some information to be populated in the lines.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Reservation</h3></div></div></div><p>The reservation process<a class="indexterm" id="id216"/> is a logistical process that requires us to know the number of the squash court, the date, and the time of the reservation. We also need to know how long the players want to play. To check the reservation, it might also be useful to store the number of the squash player.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec07"/>Invoicing</h3></div></div></div><p>For the invoicing<a class="indexterm" id="id217"/> part, we need to know the price we need to invoice. It might also be useful to store the cost to see our profit. For the system to figure out the proper G/L Account for the turnover, we also need to define a General Product Posting Group. We will see more of how that works later in <a class="link" href="ch03.html" title="Chapter 3. Financial Management">Chapter 3</a>, <em>Financial Management</em>.</p><div><img alt="Invoicing" src="img/0365EN_02_31.jpg"/></div><p>Let's discuss<a class="indexterm" id="id218"/> these fields in more detail:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Journal Template Name</strong>: This is a reference to the current <strong>Journal Template</strong>.</li><li class="listitem" style="list-style-type: disc"><strong>Line No.</strong>: Each journal has a virtually unlimited number of lines; this number is automatically incremented by 10000 allowing lines to be created in between.</li><li class="listitem" style="list-style-type: disc"><strong>Entry Type</strong>: This is the reservation or invoice.</li><li class="listitem" style="list-style-type: disc"><strong>Document No.</strong>: This number can be used to give to the squash player as a reservation number. When the <strong>Entry Type</strong> is <strong>Invoice</strong>, it is the invoice number.</li><li class="listitem" style="list-style-type: disc"><strong>Posting Date</strong>: This is usually the reservation date but when the <strong>Entry Type</strong> is <strong>Invoice</strong>, it might be the date of the invoice, which might differ from the posting date in the general ledger.</li><li class="listitem" style="list-style-type: disc"><strong>Squash Player No.</strong>: This is a reference to the squash player who has made the reservation.</li><li class="listitem" style="list-style-type: disc"><strong>Squash Court No.</strong>: This is a reference to the squash court.</li><li class="listitem" style="list-style-type: disc"><strong>Description</strong>: This<a class="indexterm" id="id219"/> is automatically updated with the number of the squash court, reservation date, and times, but can be changed by the user.</li><li class="listitem" style="list-style-type: disc"><strong>Reservation Date</strong>: This is the actual date of the reservation.</li><li class="listitem" style="list-style-type: disc"><strong>From Time</strong>: This is the starting time of the reservation. We only allow whole and half hours.</li><li class="listitem" style="list-style-type: disc"><strong>To Time</strong>: This is the ending time of the reservation. We only allow whole and half hours. This is automatically populated when people enter a quantity.</li><li class="listitem" style="list-style-type: disc"><strong>Quantity</strong>: This is the number of hours' playing time. We only allow units of 0.5 to be entered here. This is automatically calculated when the times are populated.</li><li class="listitem" style="list-style-type: disc"><strong>Unit Cost</strong>: This is the cost to run a squash court for one hour.</li><li class="listitem" style="list-style-type: disc"><strong>Total Cost</strong>: This is the cost for this reservation.</li><li class="listitem" style="list-style-type: disc"><strong>Unit Price</strong>: This is the invoice price for this reservation per hour. This depends on whether or not the squash player is a member or not.</li><li class="listitem" style="list-style-type: disc"><strong>Total Price</strong>: This is the total invoice price for this reservation.</li><li class="listitem" style="list-style-type: disc"><strong>Shortcut Dimension Code 1 &amp; 2</strong>: This is a reference to the dimensions used for this transaction.</li><li class="listitem" style="list-style-type: disc"><strong>Applies-to Entry No.</strong>: When a reservation is invoiced, this is the reference to the <strong>Squash Entry No.</strong> of the reservation.</li><li class="listitem" style="list-style-type: disc"><strong>Source Code</strong>: This is inherited from the journal batch or template and used when posting the transaction.</li><li class="listitem" style="list-style-type: disc"><strong>Chargeable</strong>: When this option is used, there will not be an invoice for the reservation.</li><li class="listitem" style="list-style-type: disc"><strong>Journal Batch Name</strong>: This is a reference to the journal batch that is used for this transaction.</li><li class="listitem" style="list-style-type: disc"><strong>Reason Code</strong>: This is inherited from the journal batch or template and used when posting the transaction.</li><li class="listitem" style="list-style-type: disc"><strong>Recurring Method</strong>: When the journal is a recurring journal, you can use this field to determine if the <strong>Amount</strong> field is blanked after posting the lines.</li><li class="listitem" style="list-style-type: disc"><strong>Recurring Frequency</strong>: This field determines the new posting date after the recurring lines are posted.</li><li class="listitem" style="list-style-type: disc"><strong>Gen. Bus. Posting Group</strong>: The combination of general business and product posting group determines the G/L Account for turnover when we invoice the reservation. The <strong>Gen. Bus. Posting Group</strong> is inherited from the bill-to customer.</li><li class="listitem" style="list-style-type: disc"><strong>Gen. Prod. Posting Group</strong>: This will be inherited from the squash player.</li><li class="listitem" style="list-style-type: disc"><strong>External Document No.</strong>: When a squash player wants us to note a reference number, we can store it here.</li><li class="listitem" style="list-style-type: disc"><strong>Posting No. Series</strong>: When <a class="indexterm" id="id220"/>the <strong>Journal Template</strong> has a <strong>Posting No. Series</strong>, it is populated here to be used when posting.</li><li class="listitem" style="list-style-type: disc"><strong>Bill-to Customer No.</strong>: This determines who is paying for the reservation. We will inherit this from the squash player.</li></ul></div><p>So now we have a place to enter reservations but we have something to do before we can start doing this. Some fields were determined to be inherited and calculated:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The time field needs calculation to avoid people entering wrong values</li><li class="listitem" style="list-style-type: disc">The <strong>Unit Price</strong> should be calculated</li><li class="listitem" style="list-style-type: disc">The <strong>Unit Cost</strong>, <strong>Posting groups</strong>, and <strong>Bill-to Customer No.</strong> need to be inherited</li><li class="listitem" style="list-style-type: disc">As the final cherry on top, we will look at implementing dimensions</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec43"/>Time calculation</h2></div></div></div><p>When it comes <a class="indexterm" id="id221"/>to the time, we want only to allow specific start and end times. Our squash court can be used in blocks of half an hour. The <strong>Quantity</strong> field should be calculated based on the entered times and vice versa.</p><p>To have the <a class="indexterm" id="id222"/>most flexible solution possible, we will create a new table with allowed starting and ending times. This table will have two fields: <strong>Reservation Time</strong> and <strong>Duration</strong>.</p><p>The <strong>Duration</strong> field will be a decimal field that we will promote to a <strong>SumIndexField</strong>. This will enable us to use SIFT to calculate the quantity.</p><div><img alt="Time calculation" src="img/0365EN_02_32.jpg"/></div><p>When<a class="indexterm" id="id223"/> populated the table will look like this:</p><div><img alt="Time calculation" src="img/0365EN_02_33.jpg"/></div><p>The time fields in the squash journal table will now get a table relation with this table. This prevents<a class="indexterm" id="id224"/> a user entering values that are not in the table, thus entering only valid starting and ending times. This is all done without any C/AL code and is flexible when times change later.</p><div><img alt="Time calculation" src="img/0365EN_02_34.jpg"/></div><p>Now, we <a class="indexterm" id="id225"/>need some code that calculates the quantity based on the input:</p><div><pre class="programlisting">
<strong>From Time - OnValidate()</strong>
CalcQty;

<strong>To Time - OnValidate()</strong>
CalcQty;

<strong>CalcQty()</strong>
IF ("From Time" &lt;&gt; 0T) AND ("To Time" &lt;&gt; 0T) THEN BEGIN
  IF "To Time" &lt;= "From Time" THEN
    FIELDERROR("To Time");
  ResTime.SETRANGE("Reservation Time", "From Time", 
    "To Time");
  ResTime.FIND('+');
  ResTime.NEXT(-1);
  ResTime.SETRANGE("Reservation Time", "From Time", 
    ResTime."Reservation Time");
  ResTime.CALCSUMS(Duration);
  VALIDATE(Quantity, ResTime.Duration);
END;</pre></div><p>When a <a class="indexterm" id="id226"/>user enters a value in the <strong>From Time</strong> or <strong>To Time</strong> fields, the <code class="literal">CalcQty</code> function is executed. This checks if both fields have a value and then checks whether <strong>To Time</strong> is larger than <strong>From Time</strong>.</p><p>Then we place a filter on the <strong>Reservation Time</strong> table. Now, when a user makes a reservation from <code class="literal">8:00</code> to <code class="literal">9:00</code>, there are three records in the filter making the result of the <code class="literal">Calcsums</code> (total of all records) of duration <code class="literal">1,5</code>. Therefore, we find the previous reservation time and use that.</p><p>This example shows how easy it is to use the built-in Microsoft Dynamics NAV functionality such<a class="indexterm" id="id227"/> as table relations and <code class="literal">Calcsums</code> instead of complex time calculations, which we could have also used.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec44"/>Price calculation</h2></div></div></div><p>As<a class="indexterm" id="id228"/> discussed in <a class="link" href="ch01.html" title="Chapter 1. Introduction to Microsoft Dynamics NAV">Chapter 1</a>, <em>Introduction to Microsoft Dynamics NAV</em>, there is a special technique to determine prices. Prices <a class="indexterm" id="id229"/>are stored in a table with all possible parameters as fields and by filtering down on these fields, the best price is determined. If required, extra logic is need to find the lowest (or highest) price, if more prices are found.</p><p>To look, learn, and love this part of the standard application, we have used table Sales Price (7002) and codeunit Sales Price Calc. Mgt. (7000), even though we only need a small part of this functionality. This mechanism of price calculation is used throughout the application and offers a normalized way of calculating sales prices. A similar construction is used for purchase prices with the table Purchase Price (7012) and codeunit Purch. Price Calc. Mgt. (7010).</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec08"/>Squash prices</h3></div></div></div><p>In our case, we <a class="indexterm" id="id230"/>have already determined that we have a special rate for members, but let's say we have also a special rate for daytime and evening in winter and summer.</p><p>This could make our table look as follows:</p><div><img alt="Squash prices" src="img/0365EN_02_35.jpg"/></div><p>We can make special prices for members on dates for winter and summer and make a price valid only until a certain time. We can also make a special price for a court.</p><p>This table could be creatively expanded with all kinds of codes until we end up with table Sales Price (7002) in the standard product, which was the template for our example.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec09"/>Price Calc Mgt. codeunit</h3></div></div></div><p>To <a class="indexterm" id="id231"/>calculate the price, we need a codeunit similar to the standard product. This codeunit is called with a squash journal line record and stores all valid prices in a buffer table and then finds the lowest price if there is any overlap:</p><div><pre class="programlisting">
<strong>FindSquashPrice()</strong>
WITH FromSquashPrice DO BEGIN
  SETFILTER("Ending Date",'%1|&gt;=%2',0D,StartingDate);
  SETRANGE("Starting Date",0D,StartingDate);

  ToSquashPrice.RESET;
  ToSquashPrice.DELETEALL;

  SETRANGE(Member, IsMember);

  SETRANGE("Ending Time", 0T);
  SETRANGE("Squash Court No.", '');
  CopySquashPriceToSquashPrice(FromSquashPrice,ToSquashPrice);

  SETRANGE("Ending Time", 0T);
  SETRANGE("Squash Court No.", CourtNo);
  CopySquashPriceToSquashPrice(FromSquashPrice,ToSquashPrice);

  SETRANGE("Squash Court No.", '');
  IF StartingTime &lt;&gt; 0T THEN BEGIN
    SETFILTER("Ending Time",'%1|&gt;=%2',000001T,StartingTime);
    CopySquashPriceToSquashPrice(FromSquashPrice,
      ToSquashPrice);
  END;

  SETRANGE("Squash Court No.", CourtNo);
  IF StartingTime &lt;&gt; 0T THEN BEGIN
    SETFILTER("Ending Time",'%1|&gt;=%2',000001T,StartingTime);
    CopySquashPriceToSquashPrice(FromSquashPrice,
      ToSquashPrice);
  END;
END;</pre></div><p>If there is no price in the filter, it uses the unit price from the squash court, as shown here:</p><div><pre class="programlisting">
<strong>CalcBestUnitPrice()</strong>
WITH SquashPrice DO BEGIN
  FoundSquashPrice := FINDSET;
  IF FoundSquashPrice THEN BEGIN
    BestSquashPrice := SquashPrice;
    REPEAT
      IF SquashPrice."Unit Price" &lt; 
        BestSquashPrice."Unit Price" 
      THEN
        BestSquashPrice := SquashPrice;
    UNTIL NEXT = 0;
  END;
END;

// No price found in agreement
IF BestSquashPrice."Unit Price" = 0 THEN
  BestSquashPrice."Unit Price" := SquashCourt."Unit Price";

SquashPrice := BestSquashPrice;</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec10"/>Inherited data</h3></div></div></div><p>To use the <a class="indexterm" id="id232"/>journal for the product part of the application, we want to inherit some of the fields from the master data tables. In order to make that possible, we need to copy and paste these fields from other tables to our master data table and populate it.</p><p>In our example, we can copy and paste the fields from the Resource table (156). We also need to add code to the <code class="literal">OnValidate</code> triggers in the journal line table.</p><div><img alt="Inherited data" src="img/0365EN_02_36.jpg"/></div><p>The squash court table, for example, is expanded with the fields <strong>Unit Code</strong>, <strong>Unit Price</strong>, <strong>Gen. Prod. Posting Group</strong>, and <strong>VAT Prod. Posting Group</strong>, as shown in the preceding screenshot.</p><p>We can now<a class="indexterm" id="id233"/> add code to the <code class="literal">OnValidate</code> of the <code class="literal">Squash Court No.</code> field in the Journal Line table.</p><div><pre class="programlisting">
<strong>Squash Court No. - OnValidate()</strong>
IF SquashCourt.GET("Squash Court No.") THEN BEGIN
  Description := SquashCourt.Description;
  "Unit Cost" := SquashCourt."Unit Cost";
  "Gen. Prod. Posting Group" := SquashCourt."Gen. Prod. Posting Group";
  FindSquashPlayerPrice;
END;</pre></div><p>Please note that unit price is used in the Squash Price Calc. Mgt. codeunit that is executed from the <code class="literal">FindSquashPlayerPrice</code> function.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec45"/>Dimensions</h2></div></div></div><p>In Microsoft Dynamics NAV, dimensions <a class="indexterm" id="id234"/>are defined in master data and posted to the ledger entries to be used in analysis view <a class="indexterm" id="id235"/>entries. In <a class="link" href="ch03.html" title="Chapter 3. Financial Management">Chapter 3</a>, <em>Financial Management</em>, we will discuss how to analyze the data generated by dimensions. In between that journey they move around a lot in different tables as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Table 348 | Dimension</strong>: This is where the main dimension codes are defined.</li><li class="listitem" style="list-style-type: disc"><strong>Table 349 | Dimension Value</strong>: This is where each dimension can have an unlimited number of values.</li><li class="listitem" style="list-style-type: disc"><strong>Table 350 | Dimension Combination</strong>: In this table, we can block certain combinations of dimension codes.</li><li class="listitem" style="list-style-type: disc"><strong>Table 351 | Dimension Value Combination</strong>: In this table, we can block certain combinations of dimension values. If this table is populated, the value <code class="literal">Limited</code> is populated in the dimension combination table for these dimensions.</li><li class="listitem" style="list-style-type: disc"><strong>Table 352 | Default Dimension</strong>: This table is populated for all master data that has dimensions defined.</li><li class="listitem" style="list-style-type: disc"><strong>Table 354 | Default Dimension Priority</strong>: When more than one master data record in one transaction have the same dimensions, it is possible here to set priorities.</li><li class="listitem" style="list-style-type: disc"><strong>Table 480 | Dimension Set Entry</strong>: This table contains a matrix of all used dimension combinations.</li><li class="listitem" style="list-style-type: disc"><strong>Codeunit 408 | Dimension Management</strong>: This codeunit is the single point in the application where all dimension movement is done.</li></ul></div><p>In our application, dimensions <a class="indexterm" id="id236"/>are moved from the squash player, squash court, and customer table via the squash journal line to the squash ledger entries. When we create an invoice, we move the dimensions from the ledger entries to the sales line table.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec11"/>Master data</h3></div></div></div><p>To <a class="indexterm" id="id237"/>connect dimensions to master data, we first need to allow this changing codeunit 408 dimension management.</p><div><pre class="programlisting">
<strong>SetupObjectNoList()</strong>
TableIDArray[1] := DATABASE::"Salesperson/Purchaser";
TableIDArray[2] := DATABASE::"G/L Account";
TableIDArray[3] := DATABASE::Customer;
...
TableIDArray[22] := DATABASE::"Service Item Group";
TableIDArray[23] := DATABASE::"Service Item";

//* Squash Application
TableIDArray[49] := DATABASE::"Squash Player";
TableIDArray[50] := DATABASE::"Squash Court";
//* Squash Application

Object.SETRANGE(Type,Object.Type::Table);

FOR Index := 1 TO ARRAYLEN(TableIDArray) DO BEGIN
  ...</pre></div><p>The <code class="literal">TableIDArray</code> variable has a default number of 23 dimensions. This we have changed to <code class="literal">50</code>.</p><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>By leaving gaps we allow Microsoft to add master data tables in future without us having to change our code.</p></div></div><p>Without this change, the system would return the following error message when we try to use dimensions:</p><div><img alt="Master data" src="img/0365EN_02_37.jpg"/></div><p>Next change is to add the <strong>Global Dimension</strong> fields to the master data tables. They can be copied and pasted from other master data tables.</p><div><img alt="Master data" src="img/0365EN_02_38.jpg"/></div><p>When these <a class="indexterm" id="id238"/>fields are validated, the <code class="literal">ValidateShortcutDimCode</code> function is executed as follows:</p><div><pre class="programlisting">
<strong>ValidateShortcutDimCode()</strong>
DimMgt.ValidateDimValueCode(FieldNumber,ShortcutDimCode);
DimMgt.SaveDefaultDim(DATABASE::"Squash Player","No.",
  FieldNumber,ShortcutDimCode);
MODIFY;</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec12"/>Journal</h3></div></div></div><p>When we use the<a class="indexterm" id="id239"/> master data records in the journal table, the dimensions are copied from the default dimension table to the dimension set entry table. This is done using the folowing piece of code that is called from <code class="literal">OnValidate</code> of each master data reference field:</p><div><pre class="programlisting">
<strong>CreateDim()</strong>
TableID[1] := Type1;
No[1] := No1;
TableID[2] := Type2;
No[2] := No2;
TableID[3] := Type3;
No[3] := No3;

"Shortcut Dimension 1 Code" := '';
"Shortcut Dimension 2 Code" := '';

"Dimension Set ID" :=
  DimMgt.GetDefaultDimID(TableID,No,"Source Code",
    "Shortcut Dimension 1 Code",
      "Shortcut Dimension 2 Code",0,0);</pre></div><p>To decide which dimensions to inherit, we should first analyze which master data is used in our Journal that is using default dimensions.</p><div><pre class="programlisting">
<strong>Squash Court No. - OnValidate()</strong>
CreateDim(
  DATABASE::"Squash Court","Squash Court No.",
  DATABASE::"Squash Player","Squash Player No.",
  DATABASE::Customer,"Bill-to Customer No.");</pre></div><p>In our <a class="indexterm" id="id240"/>case, <code class="literal">Table[1]</code> is <code class="literal">Squash Player</code>, <code class="literal">Table[2]</code> is <code class="literal">Squash Court</code>, and <code class="literal">Table[3]</code> is <code class="literal">Customer</code>. The dimension management codeunit makes sure everything is copied. We can use standard Microsoft Dynamics NAV functions.</p><div><div><div><div><h4 class="title"><a id="ch02lvl4sec01"/>Posting</h4></div></div></div><p>When we <a class="indexterm" id="id241"/>post a journal using <code class="literal">Codeunit Squash Jnl.-Post Line (123456703)</code>, the dimensions are copied using the dimension set ID as follows:</p><div><pre class="programlisting">
<strong>Code()</strong>

...
SquashLedgEntry."Dimension Set ID" := "Dimension Set ID";
...

SquashLedgEntry.INSERT;

NextEntryNo := NextEntryNo + 1;</pre></div><p>This field is also used from our combine invoicing report, which we will create later in this chapter in the <strong>Invoicing</strong> section.</p><div><pre class="programlisting">
<strong>CreateLn()</strong>
...
SalesLn.INIT;

SalesLn."Dimension Set ID" := "Dimension Set ID";

SalesLn.INSERT(TRUE);</pre></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec28"/>The posting process</h1></div></div></div><p>Our<a class="indexterm" id="id242"/> journal is<a class="indexterm" id="id243"/> now ready to be posted. We've implemented all business logic, except the posting code.</p><div><img alt="The posting process" src="img/0365EN_02_39.jpg"/></div><p>The posting process of a journal in <a class="indexterm" id="id244"/>Microsoft Dynamics NAV has several codeunits for the structure:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Jnl.-Check Line</code>: This <a class="indexterm" id="id245"/>codeunit checks if the journal line is valid for posting.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Jnl.-Post Line</code>: This<a class="indexterm" id="id246"/> codeunit does the actual creation of the ledger entry and register tables and calls other <code class="literal">Jnl.-Post Line</code> codeunits if necessary to provide the transaction structure in <a class="link" href="ch01.html" title="Chapter 1. Introduction to Microsoft Dynamics NAV">Chapter 1</a>, <em>Introduction to Microsoft Dynamics NAV</em>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Jnl.-Post Batch</code>: This<a class="indexterm" id="id247"/> codeunit loops though all journal lines in a journal batch and posts all the lines.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Jnl.-Post</code>: This is<a class="indexterm" id="id248"/> the codeunit that is called from the page. It calls the <code class="literal">Jnl.-Post Batch</code> codeunit and takes care of some user messaging.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Jnl.-Post+Print</code>: This <a class="indexterm" id="id249"/>is the codeunit that is called when you click on <strong>Post + Print</strong>. It does the same as the <code class="literal">Jnl.-Post</code> codeunit but with the additional printing of a report defined in the journal template.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Jnl.-B.Post</code>: This <a class="indexterm" id="id250"/>posts all the journal lines that have no errors and marks the ones that have errors.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Jnl.-B.Post+Print</code>: This<a class="indexterm" id="id251"/> does the same as <code class="literal">Jnl.-B.Post</code> but with the additional printing of a report defined in the journal template.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec46"/>Check line</h2></div></div></div><p>Let's have a look at the<a class="indexterm" id="id252"/> check line codeunit. When it comes to testing, Microsoft Dynamics NAV has a simple rule:</p><p>
<em>Test near, Test far, Do it, Clean up</em>
</p><p>First, we need to test the field in the journal line table, then read external data tables to check if all is good, and then post the lines and delete the data from the journal table.</p><p>It does not make sense to read the G/L setup table from the database if the document no. in our own table is <a class="indexterm" id="id253"/>blank, or to start the posting process and error out because the posting date is outside of a valid range. This would cause a lot of unnecessary I/O from the database to the client.</p><div><pre class="programlisting">
<strong>RunCheck()</strong>
WITH SquashJnlLine DO BEGIN
  IF EmptyLine THEN
    EXIT;

  TESTFIELD("Squash Player No.");
  TESTFIELD("Squash Court No.");
  TESTFIELD("Posting Date");
  TESTFIELD("Gen. Prod. Posting Group");
  TESTFIELD("From Time");
  TESTFIELD("To Time");
  TESTFIELD("Reservation Date");
  TESTFIELD("Bill-to Customer No.");

  IF "Entry Type" = "Entry Type"::Invoice THEN
    TESTFIELD("Applies-to Entry No.");

  IF "Applies-to Entry No." &lt;&gt; 0 THEN
    TESTFIELD("Entry Type", "Entry Type"::Invoice);
  IF "Posting Date" &lt;&gt; NORMALDATE("Posting Date") THEN
    FIELDERROR("Posting Date",Text000);

  IF (AllowPostingFrom = 0D) AND (AllowPostingTo = 0D) THEN 
    ...  
  END;

  ...

  IF NOT DimMgt.CheckDimIDComb("Dimension Set ID") THEN
    ...
  TableID[1] := DATABASE::"Squash Player";
  No[1] := "Squash Player No.";
  ...
  IF NOT DimMgt.CheckJnlLineDimValuePosting(JnlLineDim,
    TableID,No) 
  THEN
    IF "Line No." &lt;&gt; 0 THEN
      ..................</pre></div><p>In the preceding code, we can clearly see that fields in our table are checked first, and then the date <a class="indexterm" id="id254"/>validation, and lastly the dimension checking.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec47"/>Post line</h2></div></div></div><p>The actual <a class="indexterm" id="id255"/>posting code turns out to be quite simple. The values are checked and then a register is created or updated.</p><div><pre class="programlisting">
<strong>Code()</strong>
WITH SquashJnlLine DO BEGIN
  IF EmptyLine THEN
    EXIT;

  SquashJnlCheckLine.RunCheck(SquashJnlLine,TempJnlLineDim);

  IF NextEntryNo = 0 THEN BEGIN
    SquashLedgEntry.LOCKTABLE;
    IF SquashLedgEntry.FIND('+') THEN
      NextEntryNo := SquashLedgEntry."Entry No.";
    NextEntryNo := NextEntryNo + 1;
  END;

  IF SquashReg."No." = 0 THEN BEGIN
    SquashReg.LOCKTABLE;
    IF (NOT SquashReg.FIND('+') OR ... THEN BEGIN
      SquashReg.INIT;
      SquashReg."No." := SquashReg."No." + 1;
      ...
      SquashReg.INSERT;
    END;
  END;
  SquashReg."To Entry No." := NextEntryNo;
  SquashReg.MODIFY;

  SquashPlayer.GET("Squash Player No.");
  SquashPlayer.TESTFIELD(Blocked,FALSE);

  IF (GenPostingSetup."Gen. Bus. Posting Group" &lt;&gt; 
    "Gen. Bus. Posting Group") OR
    (GenPostingSetup."Gen. Prod. Posting Group" &lt;&gt; 
    "Gen. Prod. Posting Group")
  THEN
    GenPostingSetup.GET("Gen. Bus. Posting Group",
      "Gen. Prod. Posting Group");

  SquashLedgEntry.INIT;
  SquashLedgEntry."Entry Type" := "Entry Type";
  SquashLedgEntry."Document No." := "Document No.";
  ...
  SquashLedgEntry."No. Series" := "Posting No. Series";

  SquashLedgEntry.INSERT;</pre></div><p>All the fields <a class="indexterm" id="id256"/>are simply moved to the ledger entry table. This is what makes Microsoft Dynamics NAV simple and powerful.</p><p>Here, we can clearly see how easy it is to add a field to a posting process. Just add the fields to the journal line, the ledger entry, and add one line of code to the posting process.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Invoicing</h1></div></div></div><p>The last<a class="indexterm" id="id257"/> issue on our to-do list <a class="indexterm" id="id258"/>is the invoicing process. For this, we use a part of the standard application.</p><p>As explained in <a class="link" href="ch01.html" title="Chapter 1. Introduction to Microsoft Dynamics NAV">Chapter 1</a>, <em>Introduction to Microsoft Dynamics NAV</em>, invoicing is done using a document structure with a header and a line table. This has a posting routine that will start the journal transactions.</p><p>For our application, we need to create the invoice document and make sure that when posted, it updates our sub administration.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec48"/>Invoice document</h2></div></div></div><p>The sales<a class="indexterm" id="id259"/> invoice documents in Microsoft Dynamics NAV are stored in the Sales Header (36) and Sales Line (37) tables. We <a class="indexterm" id="id260"/>will create a report that will combine the outstanding reservation entries into invoices allowing the user to filter on a specific entry or any other field value in the squash ledger entry table.</p><p>Reports in Microsoft Dynamics NAV are not just for printing documents; we can also use its dataset capabilities to start batch jobs.</p><p>To enable this, our batch job needs to have a special property, <code class="literal">ProcessingOnly</code>, so let's start a blank report and do this.</p><div><img alt="Invoice document" src="img/0365EN_02_40.jpg"/></div><p>The report<a class="indexterm" id="id261"/> will browse through the squash<a class="indexterm" id="id262"/> ledger entries filtered on entry type<strong> Reservation</strong> and open <strong>Yes</strong>. The sorting is <strong>Open</strong>, <strong>Entry Type</strong>, <strong>Bill-to Customer No.</strong>, and <strong>Reservation Date</strong>. To use sorting, the fields must be defined together as a key in the table definition.</p><div><img alt="Invoice document" src="img/0365EN_02_41.jpg"/></div><p>As <strong>Bill-to Customer No.</strong> is the first non-filtered value in the sorting, we can assume that if this value changes, we need a new sales header.</p><p>For every squash ledger entry, we will generate a sales line as follows:</p><div><pre class="programlisting">
<strong>Squash Ledger Entry - OnAfterGetRecord()</strong>
IF "Bill-to Customer No." &lt;&gt; SalesHdr."Bill-to Customer No." 
THEN
  CreateSalesHdr;

CreateLn;</pre></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec13"/>Sales header</h3></div></div></div><p>The code to <a class="indexterm" id="id263"/>create a sales header is as follows:</p><div><pre class="programlisting">
<strong>CreateSalesHdr()</strong>
CLEAR(SalesHdr);
SalesHdr.SetHideValidationDialog(TRUE);
SalesHdr."Document Type" := SalesHdr."Document Type"::Invoice;
SalesHdr."Document Date" := WORKDATE;
SalesHdr."Posting Date" := WORKDATE;
SalesHdr.VALIDATE("Sell-to Customer No.", 
  "Squash Ledger Entry"."Bill-to Customer No.");
SalesHdr.INSERT(TRUE);

NextLineNo := 10000;
CounterOK := CounterOK + 1;</pre></div><p>The <code class="literal">SetHideValidationDialog</code> function<a class="indexterm" id="id264"/> makes sure we don't get pop-up messages while validating values. This is a standard function in Microsoft Dynamics NAV, which is designed for this purpose.</p><p>The <code class="literal">TRUE</code> parameter to the <code class="literal">INSERT</code> statement makes sure that the Number Series are triggered.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec14"/>Sales line</h3></div></div></div><p>To create a<a class="indexterm" id="id265"/> sales line, we need a minimum of the following code. Please note that we added the field <code class="literal">Applies-to Squash Entry No.</code> to the sales line table.</p><div><pre class="programlisting">
<strong>CreateLn()</strong>
WITH "Squash Ledger Entry" DO BEGIN
  GenPstSetup.GET("Gen. Bus. Posting Group", 
    "Gen. Prod. Posting Group");
  GenPstSetup.TESTFIELD("Sales Account");

  SalesLn.INIT;
  SalesLn."Document Type" := SalesHdr."Document Type";
  SalesLn."Document No." := SalesHdr."No.";
  SalesLn."Line No." := NextLineNo;
  SalesLn."Dimension Set ID" := "Dimension Set ID";
  
  SalesLn."System-Created Entry" := TRUE;

  SalesLn.Type := SalesLn.Type::"G/L Account";
  SalesLn.VALIDATE("No.", GenPstSetup."Sales Account");
  SalesLn.Description := Description;

  SalesLn.VALIDATE(Quantity, Quantity);
  SalesLn.VALIDATE("Unit Price", "Unit Price");
  SalesLn.VALIDATE("Unit Cost (LCY)", "Unit Cost");

  SalesLn."Applies-to Squash Entry No." := "Entry No.";
  SalesLn.INSERT(TRUE);

END;
NextLineNo := NextLineNo + 10000;</pre></div><div><div><h3 class="title"><a id="tip13"/>Tip</h3><p>When you add fields to the sales and purchase document tables, make sure to also add these to the posted equivalents of these tables with the same number. This way you make sure that the information is copied to the historic data. This is done using the <code class="literal">TRANSFERFIELDS</code> command. We will discuss these tables in <a class="link" href="ch06.html" title="Chapter 6. Trade">Chapter 6</a>, <em>Trade</em>.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec15"/>Dialog</h3></div></div></div><p>If the<a class="indexterm" id="id266"/> combined invoicing takes some time, it might be good to show the user a process bar. For this, Microsoft Dynamics NAV has a standard structure.</p><p>The window shows the bill-to customer no. it is currently processing and a bar going from 1 percent to 100 percent. This is calculated by keeping a counter.</p><p>At the end of the process, we show a message telling the user how many invoices were created out of the number of squash ledger entries.</p><div><pre class="programlisting">
<strong>Squash Ledger Entry - OnPreDataItem()</strong>
CounterTotal := COUNT;
Window.OPEN(Text000);

<strong>Squash Ledger Entry - OnAfterGetRecord()</strong>
Counter := Counter + 1;
Window.UPDATE(1,"Bill-to Customer No.");
Window.UPDATE(2,ROUND(Counter / CounterTotal * 10000,1));

...

<strong>Squash Ledger Entry - OnPostDataItem()</strong>
Window.CLOSE;
MESSAGE(Text001,CounterOK,CounterTotal);</pre></div><p>To do this, we need<a class="indexterm" id="id267"/> some variables. The <strong>Window</strong> variable is of type <strong>Dialog</strong> whilst <strong>Counter</strong>, <strong>CounterTotal</strong>, and <strong>CounterOK</strong> are integers, as shown in the following screenshot:</p><div><img alt="Dialog" src="img/0365EN_02_42.jpg"/></div><p>The constant <strong>Text000</strong> has the special values <strong>#1##########</strong> and <strong>@2@@@@@@@@@@@@@</strong>. The first allows us to show and update some text; the latter is used to create the process bar.</p><div><img alt="Dialog" src="img/0365EN_02_43.jpg"/></div><p>The result will look like what is shown in the following screenshot:</p><div><img alt="Dialog" src="img/0365EN_02_45.jpg"/></div><div><div><h3 class="title"><a id="note02"/>Note</h3><p>There is a best practice document about using progress bars in combination with the impact on performance at <a class="ulink" href="http://www.mibuso.com/howtoinfo.asp?FileID=17">http://www.mibuso.com/howtoinfo.asp?FileID=17</a>.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec49"/>Posting process</h2></div></div></div><p>Now, our Sales Invoice<a class="indexterm" id="id268"/> is ready so we can start making the necessary <a class="indexterm" id="id269"/>changes to the posting process. Posting a sales document is done using a single posting codeunit and some helper objects.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Report 297</strong>: This report can be used to post more than one document at the same time with a filter.</li><li class="listitem" style="list-style-type: disc"><strong>Codeunit 80</strong>: This is the actual posting routine we are going to change.</li><li class="listitem" style="list-style-type: disc"><strong>Codeunit 81</strong>: This codeunit is called from the user interface and has a dialog if the user wants to ship, invoice, or both if the document is an order and a yes/no if the document is an invoice or credit memo.</li><li class="listitem" style="list-style-type: disc"><strong>Codeunit 82</strong>: When the user chooses post and print, this codeunit is executed, which does the same as <strong>Codeunit 81</strong> plus printing a report.</li></ul></div><p>So we will make a change to <strong>Codeunit 80</strong>. This codeunit has a specific structure that we need to understand before we go in and make the change.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec16"/>Analyze the object</h3></div></div></div><p>The <a class="indexterm" id="id270"/>codeunit also has the <em>Test Near</em>, <em>Test Far</em>, <em>Do it</em>, and <em>Clean up</em> strategy so the first step is to make sure everything is in place before the actual posting starts. Let's have a look at how this codeunit is structured.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>The Sales-Post codeunit is too long to discuss in detail. We will focus on the most important parts and learning how to read this type of code routine.</p></div></div><p>This first part does the test near step and a part of the test far step. The <code class="literal">Ship</code>, <code class="literal">Invoice</code>, and <code class="literal">Receive</code> fields are set in codeunit 81 and 82 but checked and completed to make sure.</p><div><pre class="programlisting">
<strong>Code()</strong>
...
WITH SalesHeader DO BEGIN
  TESTFIELD("Document Type");
  TESTFIELD("Sell-to Customer No.");
  TESTFIELD("Bill-to Customer No.");
  TESTFIELD("Posting Date");
  TESTFIELD("Document Date");
  IF GenJnlCheckLine.DateNotAllowed("Posting Date") THEN
    FIELDERROR("Posting Date",Text045);
  CASE "Document Type" OF
    "Document Type"::Order:
      Receive := FALSE;
    "Document Type"::Invoice:
      BEGIN
        Ship := TRUE;
        Invoice := TRUE;
        Receive := FALSE;
      END;
    "Document Type"::"Return Order":
      Ship := FALSE;
    "Document Type"::"Credit Memo":
      BEGIN
        Ship := FALSE;
        Invoice := TRUE;
        Receive := TRUE;
      END;
  END;

  IF NOT (Ship OR Invoice OR Receive) THEN
    ERROR(...);

  WhseReference := "Posting from Whse. Ref.";
  "Posting from Whse. Ref." := 0;

  IF Invoice THEN
    CreatePrepaymentLines(...);
  CheckDim;</pre></div><p>The next step is <a class="indexterm" id="id271"/>moving the sales header information to the history tables for shipment, invoice, credit memo, or return receipt header. These sections are commented like this:</p><div><pre class="programlisting">  // Insert invoice header or credit memo header
  IF Invoice THEN
    IF "Document Type" IN ["Document Type"::Order,
      "Document Type"::Invoice] 
    THEN BEGIN
      SalesInvHeader.INIT;
      SalesInvHeader.TRANSFERFIELDS(SalesHeader);</pre></div><div><div><h3 class="title"><a id="note04"/>Note</h3><p>We will discuss the relation between a sales header and the sales shipment, sales invoice, sales credit memo, and return receipt in <a class="link" href="ch06.html" title="Chapter 6. Trade">Chapter 6</a>, <em>Trade</em>.</p></div></div><p>When this is <a class="indexterm" id="id272"/>done, the sales lines are processed. They are also moved to the various posted line tables. This is all part of the <em>Do it</em> section of the posting routine.</p><div><pre class="programlisting">  // Lines
  InvPostingBuffer[1].DELETEALL;
  DropShipPostBuffer.DELETEALL;
  EverythingInvoiced := TRUE;

  SalesLine.RESET;
  SalesLine.SETRANGE("Document Type","Document Type");
  SalesLine.SETRANGE("Document No.","No.");
  LineCount := 0;
  RoundingLineInserted := FALSE;
  MergeSaleslines(...);</pre></div><p>If there is a drop shipment in a purchase order, this is handled here. We will discuss drop shipments in <a class="link" href="ch06.html" title="Chapter 6. Trade">Chapter 6</a>, <em>Trade</em>.</p><div><pre class="programlisting">  // Post drop shipment of purchase order
  PurchSetup.GET;
  IF DropShipPostBuffer.FIND('-') THEN
    REPEAT
      PurchOrderHeader.GET(
        PurchOrderHeader."Document Type"::Order,
        DropShipPostBuffer."Order No.");</pre></div><p>Then there is a section that creates the financial information in the general journal. We will go deeper into this section in <a class="link" href="ch03.html" title="Chapter 3. Financial Management">Chapter 3</a>, <em>Financial Management</em>.</p><div><pre class="programlisting">  IF Invoice THEN BEGIN
    // Post sales and VAT to G/L entries from posting buffer
    LineCount := 0;
    IF InvPostingBuffer[1].FIND('+') THEN
      REPEAT
        LineCount := LineCount + 1;
        Window.UPDATE(3,LineCount);

        GenJnlLine.INIT;
        GenJnlLine."Posting Date" := "Posting Date";
        GenJnlLine."Document Date" := "Document Date";</pre></div><p>Then the <em>Clean up</em> section starts by calculating remaining quantities, VAT, and deleting the sales header and sales lines if possible.</p><div><pre class="programlisting">IF ("Document Type" IN ["Document Type"::Order,
  "Document Type"::"Return Order"]) AND
   (NOT EverythingInvoiced)
THEN BEGIN
  MODIFY;
  // Insert T336 records
  InsertTrackingSpecification;

  IF SalesLine.FINDSET THEN
    REPEAT
      IF SalesLine.Quantity &lt;&gt; 0 THEN BEGIN
        IF Ship THEN BEGIN
          SalesLine."Quantity Shipped" :=
            SalesLine."Quantity Shipped" +
            SalesLine."Qty. to Ship";
          SalesLine."Qty. Shipped (Base)" :=
            SalesLine."Qty. Shipped (Base)" +
            SalesLine."Qty. to Ship (Base)";
        END;</pre></div><p>The <em>Clean up</em> section<a class="indexterm" id="id273"/> ends by deleting the sales document and related information and clearing the variables used.</p><div><pre class="programlisting">IF HASLINKS THEN DELETELINKS;
DELETE;
...

SalesLine.DELETEALL;
DeleteItemChargeAssgnt;
...

CLEAR(WhsePostRcpt);
CLEAR(WhsePostShpt);
...
CLEAR(WhseJnlPostLine);
CLEAR(InvtAdjmt);
Window.CLOSE;</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec17"/>Making the change</h3></div></div></div><p>The change <a class="indexterm" id="id274"/>we are going to make is in the section where the lines are handled:</p><div><pre class="programlisting">// Squash Journal Line
IF SalesLine."Applies-to Squash Entry No." &lt;&gt; 0 THEN
  PostSquashJnlLn;

IF (SalesLine.Type &gt;= SalesLine.Type::"G/L Account") AND 
  (SalesLine."Qty. to Invoice" &lt;&gt; 0) 
THEN BEGIN
  // Copy sales to buffer</pre></div><p>We will <a class="indexterm" id="id275"/>create a new function, <code class="literal">PostSquashJnlLn</code>. This way we minimize the impact on standard code and when we upgrade to a newer version, we can easily copy and paste our function and only need to change the calling place if required.</p><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>Always try to design for easy upgrading whenever possible. Remember that Microsoft might change this code in newer versions so the more flexible we are and the more we manage to minimize the impact on standard code, the better.</p></div></div><div><pre class="programlisting">
<strong>PostSquashJnlLn()</strong>
WITH SalesHeader DO BEGIN
  OldSquashLedEnt.GET(
    SalesLine."Applies-to Squash Entry No.");
  OldSquashLedEnt.TESTFIELD(Open);
  OldSquashLedEnt.TESTFIELD("Bill-to Customer No.", 
    "Bill-to Customer No.");

  SquashJnlLn.INIT;
  SquashJnlLn."Posting Date" := "Posting Date";
  SquashJnlLn."Reason Code" := "Reason Code";
  ...
  SquashJnlLn."Document No." := GenJnlLineDocNo;
  SquashJnlLn."External Document No." := GenJnlLineExtDocNo;
  SquashJnlLn.Quantity := -SalesLine."Qty. to Invoice";
  SquashJnlLn."Source Code" := SrcCode;
  SquashJnlLn."Dimension Set ID" := 
    SalesLine."Dimension Set ID";
  SquashJnlLn.Chargeable := TRUE;
  SquashJnlLn."Posting No. Series" := "Posting No. Series";
  SquashJnlPostLine.RunWithCheck(SquashJnlLn);
END;</pre></div><p>Our new function first gets the squash ledger entry it applies to and tests if it's still open and the bill-to customer no. has not changed. Then, we populate the squash journal line with the help of the sales line and the old squash ledger entry. Then dimensions are handled and the squash journal line is posted.</p><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>The journal lines are never actually inserted into the database. This is for performance and concurrency reasons. All journal transactions here are handled in the service tier cache. A journal is also never populated using <code class="literal">Validate</code>. This makes it very clear for you to see what happens.</p></div></div><p>Now when<a class="indexterm" id="id276"/> we post an invoice, we can see that the invoice entries are created:</p><div><img alt="Making the change" src="img/0365EN_02_46.jpg"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Navigate</h1></div></div></div><p>We have <a class="indexterm" id="id277"/>now covered everything that is necessary for our <a class="indexterm" id="id278"/>squash court application to run but there is one special function of Microsoft Dynamics NAV that needs changing when we add new documents and ledger entries: the <code class="literal">Navigate</code> function.</p><p>The functionality was already discussed in <a class="link" href="ch01.html" title="Chapter 1. Introduction to Microsoft Dynamics NAV">Chapter 1</a>, <em>Introduction to Microsoft Dynamics NAV</em>. The object is a single page (344) in the application that requires two changes.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec50"/>FindRecords</h2></div></div></div><p>The first<a class="indexterm" id="id279"/> function <a class="indexterm" id="id280"/>we change is <code class="literal">FindRecords</code>. This browses through the database finding all possible combinations of document no. and posting date.</p><div><pre class="programlisting">
<strong>FindRecords()</strong>
...
// Squash Ledger Entries
IF SquashLedgEntry.READPERMISSION THEN BEGIN
  SquashLedgEntry.RESET;
  SquashLedgEntry.SETCURRENTKEY("Document No.",
    "Posting Date");
  SquashLedgEntry.SETFILTER("Document No.",DocNoFilter);
  SquashLedgEntry.SETFILTER("Posting Date",PostingDateFilter);
  InsertIntoDocEntry(
    DATABASE::"Squash Ledger Entry",0,
    SquashLedgEntry.TABLECAPTION,SquashLedgEntry.COUNT);
END;
// Squash Ledger Entries

DocExists := FINDFIRST;</pre></div><p>The function <a class="indexterm" id="id281"/>first checks if we have permission to read the squash ledger entry table. If our system administrator does not allow us to see this table, it should not show up.</p><p>The filtering is done on the document no. and posting date. When ready, the system inserts the number of found records in the result table.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec51"/>ShowRecords</h2></div></div></div><p>The <a class="indexterm" id="id282"/>second function to change is<a class="indexterm" id="id283"/> <code class="literal">ShowRecords</code>. This makes sure we see the squash ledger entries when we click on the <strong>Show</strong> action.</p><div><pre class="programlisting">
<strong>ShowRecords()</strong>
...
    DATABASE::"Warranty Ledger Entry":
      FORM.RUN(0,WarrantyLedgerEntry);
//* Squash Ledger Entries
    DATABASE::"Squash Ledger Entry":
      FORM.RUN(0,SquashLedgEntry);
   END;
END;</pre></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec18"/>Testing</h3></div></div></div><p>Now when <a class="indexterm" id="id284"/>we navigate from an invoice we posted that was generated from our combine invoicing report, we get the following result:</p><div><img alt="Testing" src="img/0365EN_02_47.jpg"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec31"/>Summary</h1></div></div></div><p>In this chapter, we created our own vertical add-on application for Microsoft Dynamics NAV. We used similar data model and posting structures and reused parts of the standard application where appropriate but never wrongly used standard features.</p><p>We saw how to reverse engineer Microsoft Dynamics NAV code in order to find out what similar standard functionality to copy, paste, and change for our application.</p><p>We also found out how a journal and document posting code unit works and how to structure using <em>Test near</em>, <em>Test far</em>, <em>Do it</em>, and <em>Clean up</em>.</p><p>In the next chapter, we will explore the financial functionality of Microsoft Dynamics NAV and even make some changes to this part of the application.</p></div></body></html>