<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Unity C# Refresher</h1></div></div></div><p>This book is about mastering scripting for Unity, specifically mastering C# in the context of Unity game development. The concept of mastering needs a definition and qualification, before proceeding further. By mastering, I mean this book will help you transition from having intermediate and theoretical knowledge to having more fluent, practical, and advanced knowledge of scripting. Fluency is the keyword here. From the outset of learning any programming language, the focus invariably turns to language syntax and its rules and laws—the formal parts of a language. This includes concepts such as variables, loops, and functions. However, as a programmer gets experience, the focus shifts from language specifically to the creative ways in which language is applied to solve real-world problems. The<a id="id0" class="indexterm"/> focus changes from language-oriented problems to questions of context-sensitive application. Consequently, most of this book will not primarily be about the formal language syntax of C#.</p><p>After this chapter, I'll assume that you already know the basics. Instead, the book will be about case studies and real-world examples of the use of C#. However, before turning to that, this chapter will focus on the C# basics generally. This is intentional. It'll cover, quickly and in summary, all the C# foundational knowledge you'll need to follow along productively with subsequent chapters. I strongly recommend that you read it through from start to finish, whatever your experience. It's aimed primarily at readers who are reasonably new to C# but fancy jumping in at the deep end. However, it can also be valuable to experienced developers to consolidate their existing knowledge and, perhaps, pick up new advice and ideas along the way. In this chapter, then, I'll outline the fundamentals of C# from the ground up, in a step-by-step, summarized way. I will speak as though you already understand the very basics of programming generally, perhaps with another language, but have never encountered C#. So, let's go.</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Why C#?</h1></div></div></div><p>When it comes to <a id="id1" class="indexterm"/>Unity scripting, an early question when making a new game is which language to choose, because Unity <a id="id2" class="indexterm"/>offers a choice. The official choices are C# or JavaScript. However, there's a debate about whether JavaScript should more properly be named "JavaScript" or "UnityScript" due to the Unity-specific adaptations made to the language. This point is not our concern here. The question is which language should be chosen for your project. Now, it initially seems that as we have a choice, we can actually choose all two languages and write some script files in one language and other script files in another language, thus effectively mixing up the languages. This is, of course, technically possible. Unity won't stop you from doing this. However, it's a "bad" practice because it typically leads to confusion as well as compilation conflicts; it's like trying to calculate distances <a id="id3" class="indexterm"/>in miles and kilometers at the same time.</p><p>The recommended approach, instead, is to choose one of the three languages and apply it consistently across your project as the authoritative language. This is a slicker, more<a id="id4" class="indexterm"/> efficient workflow, but it means <a id="id5" class="indexterm"/>one language must be chosen at the expense of others. This book chooses C#. Why? First, it's not because C# is "better" than the others. There is no absolute "better" or "worse" in my view. Each and every language has its own merits and uses, and all the Unity languages are equally serviceable for making games. The main reason is that C# is, perhaps, the most widely used and supported Unity language, because it connects most readily to the existing knowledge that most developers already have when they approach Unity. Most Unity tutorials are written with C# in mind, as it has a strong presence in other fields of application development. C# is historically tied to the .NET framework, which is also used in Unity (known as Mono there), and C# most closely resembles C++, which generally has a strong presence in game development. Further, by learning C#, you're more likely to find that your skill set aligns with the current demand for Unity programmers in the contemporary games industry. Therefore, I've chosen C# to give this book the widest appeal and one that connects to the extensive body of external tutorials and literature. This allows you to more easily push your knowledge even further after reading this book.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Creating script files</h1></div></div></div><p>If you need to<a id="id6" class="indexterm"/> define a logic or behavior for your game, then you'll need to write a script. Scripting in Unity begins by creating a new script file, which is a standard text file added to the project. This file defines a program that lists all the instructions for Unity to follow. As mentioned, the instructions can be written in either C#, JavaScript, or Boo; for this book, the language will be C#. There are multiple ways to create a script file in Unity.</p><p>One way is to go to <strong>Assets</strong> | <strong>Create</strong> | <strong>C# Script</strong> from the application menu, as shown in the following screenshot:</p><div><img src="img/0655OT_01_01.jpg" alt="Creating script files"/><div><p>Creating a script file via the application menu</p></div></div><p>Another way is to<a id="id7" class="indexterm"/> right-click on the empty space anywhere within the <strong>Project</strong> panel and choose the <strong>C# Script</strong> option in the <strong>Create</strong> menu from the context menu, as shown in the following screenshot. This creates the asset in the currently open folder.</p><div><img src="img/0655OT_01_02.jpg" alt="Creating script files"/><div><p>Creating a script file via the Project panel context menu</p></div></div><p>Once created, a new script file will be generated inside the <code class="literal">Project</code> folder with a <code class="literal">.cs</code> file extension (representing C Sharp). The filename is especially important and has serious implications on the validity of your script files because Unity uses the filename to determine the name of a C# class to be created inside the file. Classes are considered in more depth later in this chapter. In short, be sure to give your file a unique and meaningful name.</p><p>By unique, we mean that no other script file anywhere in your project should have the same name, whether it is located in a different folder or not. All the script files should have a <a id="id8" class="indexterm"/>unique name across the project. The name should also be meaningful by expressing clearly what your script intends to do. Further, there are rules of validity governing filenames as well as class names in C#. The formal definition of these rules can be<a id="id9" class="indexterm"/> found online at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/aa664670%28VS.71%29.aspx">http://msdn.microsoft.com/en-us/library/aa664670%28VS.71%29.aspx</a>. In short, the filename should start with a letter or underscore character only (numbers are not permitted for the first character), and the name should include no spaces, although underscores (_) are allowed:</p><div><img src="img/0655OT_01_03.jpg" alt="Creating script files"/><div><p>Name your script files in a unique way and according to the C# class naming conventions</p></div></div><p>Unity script files can be opened and examined in any text editor or IDE, including Visual Studio and Notepad++, but Unity provides the free and open source editor, <strong>MonoDevelop</strong>. This <a id="id10" class="indexterm"/>software is part of the main Unity package included in the installation and doesn't need to be downloaded separately. By double-clicking on the script file from the<a id="id11" class="indexterm"/> <strong>Project</strong> panel, Unity will automatically open the file inside MonoDevelop. If you later decide to, or need to, rename the script file, you also need to rename the C# class inside the file to match the filename exactly, as shown in the following screenshot. Failure to do so will result in invalid code and compilation errors or problems when attaching the script file to your objects.</p><div><img src="img/0655OT_01_04.jpg" alt="Creating script files"/><div><p>Renaming classes to match the renamed script files</p></div></div><div><div><h3 class="title"><a id="note02"/>Note</h3><p>
<strong>Compiling code</strong>
</p><p>To compile <a id="id12" class="indexterm"/>code in Unity, you just need to save your script file in MonoDevelop by choosing the <strong>Save</strong> option in the <strong>File</strong> menu from the application menu (or by pressing <em>Ctrl</em> + <em>S</em> on the keyboard) and then return to the main Unity Editor. On refocusing on the Unity window, Unity automatically detects code changes in the files and then compiles your code in response. If there are errors, the game cannot be run, and the errors are printed to the <strong>Console</strong> window. If the compile was successful, you don't need to do anything else, except press <strong>Play</strong> on the <strong>Editor</strong> toolbar and test run your game. Take care here; if you forget to save your file in MonoDevelop after making code changes, then Unity will still use the older, compiled version of your code. For this reason as well as for the purpose of backup, it's<a id="id13" class="indexterm"/> really important to save your work regularly, so be sure to press <em>Ctrl</em> + <em>S</em> to save in MonoDevelop.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Instantiating scripts</h1></div></div></div><p>Each script file in Unity<a id="id14" class="indexterm"/> defines one main class that is like a blueprint or design that can be instantiated. It is a collection of related variables, functions, and events (as we'll see soon). By default, a script file is like any other kind of Unity asset, such as meshes and audio files. Specifically, it remains dormant in the <code class="literal">Project</code> folder and does nothing until it's added to a specific scene (by being added to an object as a component), where it comes alive at runtime. Now, scripts, being logical and mathematical in nature, are not added to the scene as tangible, independent objects as meshes are. You cannot see or hear them directly, because they have no visible or audible presence. Instead, they're added onto existing game objects as components, where they define the behavior of those objects. This process of bringing scripts to life as a specific component on a specific object is known as instantiation. Of course, a single script file can be instantiated on multiple objects to replicate the behavior for them all, saving us from making multiple script files for each object, such as when multiple enemy characters must use the same artificial intelligence. The point of the script file, ideally, is to define an abstract formula <a id="id15" class="indexterm"/>or behavior pattern for an object that can be reused successfully across many similar objects in all possible scenarios. To add a script file onto an object, simply drag-and-drop the script from the <strong>Project</strong> panel onto the destination object in the scene. The script will be instantiated as a component, and its public variables will be visible in the <a id="id16" class="indexterm"/>
<strong>Object Inspector</strong> whenever the object is selected, as shown in the following screenshot:</p><div><img src="img/0655OT_01_05.jpg" alt="Instantiating scripts"/><div><p>Attaching scripts onto game objects as components</p></div></div><p>Variables are considered in more depth in the next section.</p><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>More information on creating and using scripts in Unity can be found online at <a class="ulink" href="http://docs.unity3d.com/412/Documentation/Manual/Scripting.html">http://docs.unity3d.com/412/Documentation/Manual/Scripting.html</a>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Variables</h1></div></div></div><p>Perhaps, the core concept in programming and in C# is the variable. Variables often correspond to the letters used in algebra and stand in for numerical quantities, such as <em>X</em>, <em>Y</em>, and <em>Z</em> and <em>a</em>, <em>b</em>, and <em>c</em>. If you need to keep track of information, such as the player name, score, position, orientation, ammo, health, and a multitude of other types of quantifiable data (expressed by nouns), then a <a id="id17" class="indexterm"/>variable will be your friend. A variable represents a single unit of information. This means that multiple variables are needed to hold multiple units, one variable for each. Further, each unit will be of a specific type or kind. For example, the player's name represents a sequence of letters, such as "John", "Tom", and "David". In contrast, the player's health refers to numerical data, such as 100 percent (1) or 50 percent (0.5), depending on whether the player has sustained damage. So, each variable necessarily has a data type. In C#, variables are created using a specific kind of syntax or grammar. Consider the following code sample 1-1 that defines a new script file and class called <code class="literal">MyNewScript</code>, which declares three different variables with class scope, each of a unique type. The word "declare" means that we, as programmers, are telling the C# compiler about the variables required:</p><div><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class MyNewScript : MonoBehaviour 
05 {
06     public string PlayerName = "";
07     public int PlayerHealth = 100;
08     public Vector3 Position = Vector3.zero;
09 
10     // Use this for initialization
11     void Start () {
12 
13     }
14 
15     // Update is called once per frame
16     void Update () {
17 
18     }
19 }</pre></div><div><div><h3 class="title"><a id="note03"/>Note</h3><p>
<strong>Variable data types</strong>
</p><p>Each variable<a id="id18" class="indexterm"/> has a data type. A few of the most common ones include <code class="literal">int</code>, <code class="literal">float</code>, <code class="literal">bool</code>, <code class="literal">string</code>, and <code class="literal">Vector3</code>. Here, are a few examples of these types:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">int</code> (integer or whole number) = -3, -2, -1, 0, 1, 2, 3…</li><li class="listitem" style="list-style-type: disc"><code class="literal">float</code> (floating point number or decimal) = -3.0, -2.5, 0.0, 1.7, 3.9…</li><li class="listitem" style="list-style-type: disc"><code class="literal">bool</code> (Boolean or <code class="literal">true</code>/<code class="literal">false</code>) = <code class="literal">true</code> or <code class="literal">false</code> (1 or 0)</li><li class="listitem" style="list-style-type: disc"><code class="literal">string</code> (string of characters) = "hello world", "a", "another word…"</li><li class="listitem" style="list-style-type: disc"><code class="literal">Vector3</code> (a position value) = (0, 0, 0), (10, 5, 0)…</li></ul></div></div></div><p>Notice from lines 06-08 of code sample 1-1 that each variable is assigned a starting value, and its data type is explicitly<a id="id19" class="indexterm"/> stated as <code class="literal">int</code> (integer), <code class="literal">string</code>, and <code class="literal">Vector3</code>, which represent the points in a 3D space (as well as directions, as we'll see). There's no full list of possible data types, as this will vary extensively, depending on your project (and you'll also create your own!). Throughout this book, we'll work with the most common types, so you'll see plenty of examples. Finally, each variable declaration line begins with the keyword public. Usually, variables can be either <code class="literal">public</code> or <code class="literal">private</code> (and there is another one called <code class="literal">protected</code>, which is not covered here).The <code class="literal">public</code> variables will be accessible and editable in Unity's Object Inspector (as we'll see soon, you can also refer to the preceding screenshot), and they can also be accessed by other classes.</p><p>Variables are so named because their values might vary (or change) over time. Of course, they don't change in arbitrary and unpredictable ways. Rather, they change whenever we explicitly change them, either through direct assignment in code, from the Object Inspector, or through methods and function calls. They can be changed both directly and indirectly. Variables can be assigned values directly, such as the following one:</p><div><pre class="programlisting">PlayerName = "NewName";</pre></div><p>They can also be assigned indirectly using expressions, that is, statements whose final value must be evaluated before the assignment can be finally made to the variable as follows:</p><div><pre class="programlisting">//Variable will result to 50, because: 100 x 0.5 = 50
PlayerHealth = 100 * 0.5;</pre></div><div><div><h3 class="title"><a id="note04"/>Note</h3><p>
<strong>Variable scope</strong>
</p><p>Each variable is<a id="id20" class="indexterm"/> declared with an implicit scope. The scope determines the lifetime of a variable, that is, the places inside a source file where a variable can be successfully referenced and accessed. Scope is determined by the place where the variable is declared. The variables declared in code sample 1-1 have class scope, because they are declared at the top of a class and outside any functions. This means they can be accessed everywhere throughout the class, and (being public) they can also be accessed from other classes. Variables can also be declared inside specific functions. These are known as local variables, because their scope is restricted to the function, that is, a local variable cannot be accessed outside the function<a id="id21" class="indexterm"/> in which it was declared. Classes and functions are considered later in this chapter.</p><p>More information on<a id="id22" class="indexterm"/> variables and their usage in C# can be found at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/aa691160%28v=vs.71%29.aspx">http://msdn.microsoft.com/en-us/library/aa691160%28v=vs.71%29.aspx</a>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Conditional statements</h1></div></div></div><p>Variables change in <a id="id23" class="indexterm"/>potentially many different circumstances: when the player changes their position, when enemies are destroyed, when the level changes, and so on. Consequently, you'll frequently need to check the value of a variable to branch the execution of your scripts that perform different sets of actions, depending on the value. For example, if <code class="literal">PlayerHealth</code> reaches 0 percent, you'll perform a death sequence, but if <code class="literal">PlayerHealth</code> is at 20 percent, you might only display a warning message. In this specific example, the <code class="literal">PlayerHealth</code> variable drives the script in a specified direction. C# offers two main conditional statements to achieve a program branching like this. These are the <code class="literal">if</code> statement and the <code class="literal">Switch</code> statement. Both are highly useful.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>The if statement</h2></div></div></div><p>The <code class="literal">if</code> statement has various forms. The most basic form checks for a condition and will perform a subsequent block <a id="id24" class="indexterm"/>of code if, and only if, that<a id="id25" class="indexterm"/> condition is <code class="literal">true</code>. Consider the following code sample 1-2:</p><div><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class MyScriptFile : MonoBehaviour 
05 {
06     public string PlayerName = "";
07     public int PlayerHealth = 100;
08     public Vector3 Position = Vector3.zero;
09 
10     // Use this for initialization
11     void Start () {
12     }
13 
14     // Update is called once per frame
15     void Update () 
16     {
17         //Check player health - the braces symbol {} are option for one-line if-statements
18         if(PlayerHealth == 100)
19         {
20         Debug.Log ("Player has full health");
21         }
22     }
23 }</pre></div><p>The preceding code is executed like all other types of code in Unity, by pressing the <strong>Play</strong> button from the toolbar, as long as the script file has previously been instantiated on an object in the active scene. The <code class="literal">if</code> statement at line 18 continually checks the <code class="literal">PlayerHealth</code> class variable for its current value. If the <code class="literal">PlayerHealth</code> variable is exactly equal to (<code class="literal">==</code>) <code class="literal">100</code>, then the code inside the <code class="literal">{}</code> braces (in lines 19–21) will be executed. This works because all conditional checks result in a Boolean value of either <code class="literal">true</code> or <code class="literal">false</code>; the<a id="id26" class="indexterm"/> conditional statement is really checked to see whether the queried condition (<code class="literal">PlayerHealth == 100</code>) is <code class="literal">true</code>. The code inside the braces can, in theory, span across multiple lines<a id="id27" class="indexterm"/> and expressions. However, here, there is just a single line in line 20: the <code class="literal">Debug.Log</code> Unity function outputs the <strong>Player has full health</strong> string to the console, as shown in the following screenshot. Of course, the <code class="literal">if</code> statement could potentially have gone the other way, that is, if <code class="literal">PlayerHealth</code> was not equal to <code class="literal">100</code> (perhaps, it was <code class="literal">99</code> or <code class="literal">101</code>), then no message would be printed. Its execution always depends on the previous <code class="literal">if</code> statement evaluating to <code class="literal">true</code>.</p><div><img src="img/0655OT_01_06.jpg" alt="The if statement"/><div><p>The Unity Console is useful for printing and viewing debug messages</p></div></div><p>More<a id="id28" class="indexterm"/> information on the <code class="literal">if</code> statements, the <code class="literal">if-else</code> statement, and<a id="id29" class="indexterm"/> their usage in C# can be found online at <a class="ulink" href="http://msdn.microsoft.com/en-GB/library/5011f09h.aspx">http://msdn.microsoft.com/en-GB/library/5011f09h.aspx</a>.</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>
<strong>Unity Console</strong>
</p><p>As you can see in the preceding screenshot, the console is a debugging tool in Unity. It's a place where <a id="id30" class="indexterm"/>messages can be printed from the code using the <code class="literal">Debug.Log</code> statement (or the<a id="id31" class="indexterm"/> <code class="literal">Print</code> function) to be viewed by developers. They are helpful to<a id="id32" class="indexterm"/> diagnose issues at runtime and compile time. If you get a compile time or runtime error, it should be listed in the <strong>Console</strong> tab. The <strong>Console</strong> tab should be visible in the Unity Editor by default, but it can be displayed manually by selecting <strong>Console</strong> in<a id="id33" class="indexterm"/> the <strong>Window</strong> menu from the Unity application file menu. More information on the <code class="literal">Debug.Log</code> function can be found at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Debug.Log.html">http://docs.unity3d.com/ScriptReference/Debug.Log.html</a>.</p></div></div><p>You can, of course, check for more conditions than just equality (<code class="literal">==</code>), as we did in code sample 1-2. You can use the <code class="literal">&gt;</code> and <code class="literal">&lt;</code> operators to check whether a variable is greater than or less than another value, respectively. You can also use the <code class="literal">!=</code> operator to check whether a variable is not equal to another value. Further, you can even combine multiple conditional checks into the same <code class="literal">if</code> statement using the <code class="literal">&amp;&amp;</code> (AND) operator and the <code class="literal">||</code> (OR) operator. For example, check out the following <code class="literal">if</code> statement. It performs the code block between the <code class="literal">{}</code> braces only if the <code class="literal">PlayerHealth</code> variable is between <code class="literal">0</code> and <code class="literal">100</code> and is not equal to <code class="literal">50</code>, as shown here:</p><div><pre class="programlisting">if(PlayerHealth &gt;= 0 &amp;&amp; PlayerHealth &lt;= 100 &amp;&amp; PlayerHealth !=50)
{
Debug.Log ("Player has full health");
}</pre></div><div><div><h3 class="title"><a id="note06"/>Note</h3><p>
<strong>The if-else statement</strong>
</p><p>One variation <a id="id34" class="indexterm"/>of the <code class="literal">if</code> statement is the <code class="literal">if-else</code> statement. The <code class="literal">if</code> statement performs a code block if its condition evaluates to <code class="literal">true</code>. However, the <code class="literal">if-else</code> statement extends this. It would perform an <code class="literal">X</code> <a id="id35" class="indexterm"/>code block if its <a id="id36" class="indexterm"/>condition is <code class="literal">true</code> and a <code class="literal">Y</code> code block if its condition is <code class="literal">false</code>:</p><div><pre class="programlisting">if(MyCondition)
{
//X - perform my code if MyCondition is true
}
else
{
//Y – perform my code if MyCondition is false
}</pre></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>The switch statement</h2></div></div></div><p>As we've seen, the <code class="literal">if</code> statement is useful to determine whether a single and specific condition is <code class="literal">true</code> or <code class="literal">false</code> and to perform a specific code block on the basis of this. The <code class="literal">switch</code> statement, in<a id="id37" class="indexterm"/> contrast, lets you check a variable for multiple possible conditions or states, and then lets you branch the program in one of many possible directions, not just one or two as is<a id="id38" class="indexterm"/> the case with <code class="literal">if</code> statements. For example, if you're creating an enemy character that can be in one of the many possible states of action (<code class="literal">CHASE</code>, <code class="literal">FLEE</code>, <code class="literal">FIGHT</code>, <code class="literal">HIDE</code>, and so on), you'll probably need to branch your code appropriately to handle each state specifically. The <code class="literal">break</code> keyword is used to exit from a state returning to the end of the <code class="literal">switch</code> statement. The following code sample 1-3 handles a sample enemy using enumerations:</p><div><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class MyScriptFile : MonoBehaviour 
05 {
06     //Define possible states for enemy using an enum
07     public enum EnemyState {CHASE, FLEE, FIGHT, HIDE};
08 
09     //The current state of enemy
10     public EnemyState ActiveState = EnemyState.CHASE;
11 
12     // Use this for initialization
13     void Start () {
14     }
15 
16     // Update is called once per frame
17     void Update () 
18     {
19          //Check the ActiveState variable
20          switch(ActiveState)
21          {
22          case EnemyState.FIGHT:
23          {
24                //Perform fight code here
25                Debug.Log ("Entered fight state");
26          }
27                break;
28 
29 
30          case EnemyState.FLEE:
31          case EnemyState.HIDE:
32          {
33               //Flee and hide performs the same behaviour
34               Debug.Log ("Entered flee or hide state");
35          }
36               break;
37 
38          default:
39          {
40               //Default case when all other states fail
41               //This is used for the chase state
42               Debug.Log ("Entered chase state");
43           }
44               break;
45           }
46     }
47 }</pre></div><div><div><h3 class="title"><a id="note07"/>Note</h3><p>
<strong>Enumerations</strong>
</p><p>This line 07 in code sample <a id="id39" class="indexterm"/>1-3 declares an enumeration (enum) named <code class="literal">EnemyState</code>. An enum is a special structure used to store a range of potential values for one or more other variables. It's not a variable itself per se, but a way of specifying the limits of values that a <a id="id40" class="indexterm"/>variable might have. In code sample 1-3, the <code class="literal">ActiveState</code> variable declared in line 10 makes use of <code class="literal">EnemyState</code>. Its value can be any valid value from the <code class="literal">ActiveState</code> enumeration. Enums are a great way of helping you validate your variables, limiting their values within a specific range and <a id="id41" class="indexterm"/>series of options.</p></div></div><p>Another great<a id="id42" class="indexterm"/> benefit of enums is that variables based on them have their values appear as selectable options from drop-down boxes in the Object Inspector, as shown in the following screenshot:</p><div><img src="img/0655OT_01_07.jpg" alt="The switch statement"/><div><p>Enumerations offer you drop-down options for your variables from the Object Inspector</p></div></div><p>More information on enums and their<a id="id43" class="indexterm"/> usage in C# can be found online at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/sbbt4032.aspx">http://msdn.microsoft.com/en-us/library/sbbt4032.aspx</a>.</p><p>The following are the comments for code sample 1-3:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Line 20</strong>: The <code class="literal">switch</code> statement begins. Parentheses, <code class="literal">()</code>, are used to select the variable whose value or state must be checked. In this case, the <code class="literal">ActiveState</code> variable is being queried.</li><li class="listitem" style="list-style-type: disc"><strong>Line 22</strong>: The first case statement is made inside the <code class="literal">switch</code> statement. The following block of code (lines 24 and 25) will be executed if the <code class="literal">ActiveState</code> variable is set to <code class="literal">EnemyState.Fight</code>. Otherwise, the code will be ignored.</li><li class="listitem" style="list-style-type: disc"><strong>Lines 30 and 31</strong>: Here, two case statements follow one another. The code block in lines 33 and 34 will be executed if, and only if, <code class="literal">ActiveState</code> is either <code class="literal">EnemyState.Flee</code> or <code class="literal">EnemyState.Hide</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Line 38</strong>: The default statement is optional for a <code class="literal">switch</code> statement. When included, it will be entered if no other case statements are <code class="literal">true</code>. In this case, it would apply if <code class="literal">ActiveState</code> is <code class="literal">EnemyState.Chase</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Lines 27, 36, and 44</strong>: The <code class="literal">break</code> statement should occur at the end of a case statement. When it is<a id="id44" class="indexterm"/> reached, it will exit the complete <code class="literal">switch</code> statement to which it belongs, resuming program execution in the line after the <code class="literal">switch</code> statement, in this case, line 45.<div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>More information on the <a id="id45" class="indexterm"/>
<code class="literal">switch</code> statement and its usage in C# can be found at <a class="ulink" href="http://msdn.microsoft.com/en-GB/library/06tc147t.aspx">http://msdn.microsoft.com/en-GB/library/06tc147t.aspx</a>.</p></div></div></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Arrays</h1></div></div></div><p>Lists and sequences are everywhere in games. For this reason, you'll frequently need to keep track of lists of data<a id="id46" class="indexterm"/> of the same type: all enemies in the level, all weapons that have been collected, all power ups that could be collected, all spells and items in the inventory, and so on. One type of list is the array. Each item in the array is, essentially, a unit of information that has the potential to change during gameplay, and so a variable is suitable to store each item. However, it's useful to collect together all the related variables (all enemies, all weapons, and so on) into a single, linear, and traversable list structure. This is what an array achieves. In C#, there are two kinds of arrays: static and dynamic. Static arrays might hold a fixed and maximum number of possible entries in memory, decided in advance, and this capacity remains unchanged throughout program execution, even if you only need to store fewer items than the capacity. This means some slots or entries could be wasted. Dynamic arrays might grow and shrink in capacity, on demand, to accommodate exactly the number of items required. Static arrays typically perform better and faster, but dynamic arrays feel cleaner and avoid memory wastage. This chapter considers only static arrays, and dynamic arrays are considered later, as shown in the following code sample 1-4:</p><div><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class MyScriptFile : MonoBehaviour 
05 {
06     //Array of game objects in the scene
07     public GameObject[] MyObjects;
08 
09      // Use this for initialization
10      void Start ()
11      {
12       }
13 
14       // Update is called once per frame
15       void Update () 
16       {
17       }
18 }</pre></div><p>In code sample 1-4, line 07 declares a completely empty array of <code class="literal">GameObjects</code>, named <code class="literal">MyObjects</code>. To create this, it uses the <code class="literal">[]</code> syntax after the data type <code class="literal">GameObject</code> to designate an array, that is, to signify that a list of <code class="literal">GameObjects</code> is being declared as opposed to a single <code class="literal">GameObject</code>. Here, the declared array will be a list of all objects in the scene. It begins empty, but you can use the Object Inspector in the Unity Editor to build the array<a id="id47" class="indexterm"/> manually by setting its maximum capacity and populating it with any objects you need. To do this, select the object to which the script is attached in the scene and type in a <strong>Size</strong> value for the <strong>My Objects</strong> field to specify the capacity of the array. This should be the total number of objects you want to hold. Then, simply drag-and-drop objects individually from the scene hierarchy panel into the array slots in the Object Inspector to populate the list with items, as shown here:</p><div><img src="img/0655OT_01_08.jpg" alt="Arrays"/><div><p>Building arrays from the Unity Object Inspector</p></div></div><p>You can also build the array manually in code via the <code class="literal">Start</code> function instead of using the Object Inspector. This <a id="id48" class="indexterm"/>ensures that the array is constructed as the level begins. Either method works fine, as shown in the following code sample 1-5:</p><div><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class MyScriptFile : MonoBehaviour 
05 {
06     //Array of game objects in the scene
07     public GameObject[] MyObjects;
08 
09     // Use this for initialization
10     void Start ()
11     {
12          //Build the array manually in code
13          MyObjects = new GameObject[3];
14          //Scene must have a camera tagged as MainCamera
15          MyObjects[0] = Camera.main.gameObject; 

16       //Use GameObject.Find function to
17       //find objects in scene by name
18       MyObjects[1] = GameObject.Find("Cube"); 
19       MyObjects[2] = GameObject.Find("Cylinder"); 
20     }
21 
22     // Update is called once per frame
23     void Update ()
24     {
25     }
26 }</pre></div><p>The following are the comments for code sample 1-5:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Line 10</strong>: The <code class="literal">Start</code> function is executed at level startup. Functions are considered in more depth later in this chapter.</li><li class="listitem" style="list-style-type: disc"><strong>Line 13</strong>: The <code class="literal">new</code> keyword is used to create a new array with a capacity of three. This means that the list can hold no more than three elements at any one time. By default, all elements are set to the starting value of <code class="literal">null</code> (meaning nothing). They are empty.</li><li class="listitem" style="list-style-type: disc"><strong>Line 15</strong>: Here, the first element in the array is set to the main camera object in the scene. Two important points should be noted here. First, elements in the array can be accessed using the array subscript operator <code class="literal">[]</code>. Thus, the first element of <code class="literal">MyObjects</code> can be accessed with <code class="literal">MyObjects[0]</code>. Second, C# arrays are "zero indexed". This means the first element is always at position <code class="literal">0</code>, the next is at <code class="literal">1</code>, the next at <code class="literal">2</code>, and so on. For the <code class="literal">MyObjects</code> three-element array, each<a id="id49" class="indexterm"/> element can be accessed with <code class="literal">MyObjects[0]</code>, <code class="literal">MyObjects[1]</code>, and <code class="literal">MyObjects[2]</code>. Notice that the last element is <code class="literal">2</code> and not <code class="literal">3</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Lines 18 and 19</strong>: Elements <code class="literal">1</code> and <code class="literal">2</code> of the <code class="literal">MyObjects</code> array are populated with objects using the function <code class="literal">GameObject.Find</code>. This searches the active scene for game objects with a specified name (case sensitive), inserting a reference to them at the specified element in the <code class="literal">MyObjects</code> array. If no object of a matching name is found, then <code class="literal">null</code> is inserted instead.</li></ul></div><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>More information on arrays and <a id="id50" class="indexterm"/>their usage in C# can be found online at <a class="ulink" href="http://msdn.microsoft.com/en-GB/library/9b9dty7d.aspx">http://msdn.microsoft.com/en-GB/library/9b9dty7d.aspx</a>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Loops</h1></div></div></div><p>Loops are one of the<a id="id51" class="indexterm"/> most powerful tools in programming. Imagine a game where the entire level can be nuked. When this happens, you'll want to destroy almost everything in the scene. Now, you can do this by deleting each and every object individually in code, one line at a time. If you did this, then a small scene with only a few objects would take just a few lines of code, and this wouldn't be problematic. However, for larger scenes with potentially hundreds of objects, you'd have to write a lot of code, and this code would need to be changed if you altered the contents of the scene. This would be tedious. Loops can simplify the process to just a few lines, regardless of scene complexity or<a id="id52" class="indexterm"/> object number. They allow you to repeatedly perform operations on potentially many objects. There are several kinds of loops in C#. Let's see some examples.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>The foreach loop</h2></div></div></div><p>Perhaps, the simplest loop type in C# is the <code class="literal">foreach</code> loop. Using <code class="literal">foreach</code>, you can cycle through every<a id="id53" class="indexterm"/> element in an array, sequentially from start to end, processing each item<a id="id54" class="indexterm"/> as required. Consider the following code sample 1-6; it destroys all <code class="literal">GameObjects</code> from a <code class="literal">GameObject</code> array:</p><div><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class MyScriptFile : MonoBehaviour 
05 {
06     //Array of game objects in the scene
07     public GameObject[] MyObjects;
08 
09     // Use this for initialization
10     void Start ()
11     {
12          //Repeat code for all objects in array, one by one
13          foreach(GameObject Obj in MyObjects)
14          {
15              //Destroy object
16              Destroy (Obj);
17          }
18    }
19 
20    // Update is called once per frame
21    void Update () 
22    {
23    }
24 }</pre></div><div><div><h3 class="title"><a id="note08"/>Note</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>The <code class="literal">foreach</code> loop repeats the code block <code class="literal">{}</code> between lines 14–17, once for each element in the array <code class="literal">MyObjects</code>. Each pass or cycle in the loop is known as an iteration. The loop depends on array size; this means that larger arrays require more iterations and more processing time. The loop also features a local variable <code class="literal">obj</code>. This is declared in the <code class="literal">foreach</code> statement in line 13. This variable stands in for the selected or active element in the array as the loop passes each iteration, so <code class="literal">obj</code> represents the first element in the loop on the first iteration, the second <a id="id55" class="indexterm"/>element on the second iteration, and so on.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>More information on the<a id="id56" class="indexterm"/> <code class="literal">foreach</code> loop and its usage in C# can be found at <a class="ulink" href="http://msdn.microsoft.com/en-GB/library/ttw7t8t6.aspx">http://msdn.microsoft.com/en-GB/library/ttw7t8t6.aspx</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>The for loop</h2></div></div></div><p>The <code class="literal">foreach</code> loop is handy when you need to iterate through a single array sequentially from start to end, processing<a id="id57" class="indexterm"/> each element one at a time. But sometimes you need more control over the iterations. You might need to process a loop backwards from the end to the start, you <a id="id58" class="indexterm"/>might need to process two arrays of equal length simultaneously, or you might need to process every alternate array element as opposed to every element. You can achieve this using the <code class="literal">for</code> loop, as shown here:</p><div><pre class="programlisting">//Repeat code backwards for all objects in array, one by one
for(int i = MyObjects.Length-1; i &gt;= 0; i--)
{
   //Destroy object
   DestroyMyObjects[i]);
}</pre></div><p>The following are the comments for the preceding code snippet:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Here, the <code class="literal">for</code> loop traverses the <code class="literal">MyObjects</code> array backwards from the end to the start, deleting each <code class="literal">GameObject</code> in the scene. It does this using a local variable <code class="literal">i</code>. This is sometimes known as an <code class="literal">Iterator</code> variable, because it controls how the loop progresses.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">for</code> loop line has the following three main parts, each separated by a semicolon character:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">i</code>: This is initialized to <code class="literal">MyObjects.Length – 1</code> (the last element in the array). Remember that arrays are zero-indexed, so the last element is always <code class="literal">Array Length -1</code>. This ensures that loop iteration begins at the array end.</li><li class="listitem" style="list-style-type: disc"><code class="literal">i &gt;= 0</code>: This expression indicates the condition when the loop should terminate. The <code class="literal">i</code> variable acts like a countdown variable, decrementing backwards through the array. In this case, the loop should end when <code class="literal">i</code> is no longer greater than or equal to <code class="literal">0</code>, because <code class="literal">0</code> represents the start of the array.</li><li class="listitem" style="list-style-type: disc"><code class="literal">i--</code>: This expression controls how the variable <code class="literal">i</code> changes on each iteration of the loop moving from the array end to the beginning. Here, <code class="literal">i</code> will be decremented by one on each iteration, that is, a value of <code class="literal">1</code> will be <a id="id59" class="indexterm"/>subtracted from <code class="literal">i</code> on each pass of the loop. In contrast, the statement <code class="literal">++</code> will add <code class="literal">1</code>.</li></ul></div></li><li class="listitem" style="list-style-type: disc">During the loop, the expression <code class="literal">MyObjects[i]</code> is used to access array elements.</li></ul></div><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>More information on the<a id="id60" class="indexterm"/> <code class="literal">for</code> loop and its usage in C# can be found at <a class="ulink" href="http://msdn.microsoft.com/en-gb/library/ch45axte.aspx">http://msdn.microsoft.com/en-gb/library/ch45axte.aspx</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>The while loop</h2></div></div></div><p>Both the <code class="literal">for</code> and <code class="literal">foreach</code> loops were especially useful when cycling through an array, performing specific operations on each iteration. The <code class="literal">while</code> loop, in contrast, is useful to continually <a id="id61" class="indexterm"/>repeat a specific behavior until a specified condition evaluates to <code class="literal">false</code>. For example, if you must deal damage to the player as long as they're standing on hot lava or continually move a vehicle until the breaks are applied, then a <code class="literal">while</code> loop <a id="id62" class="indexterm"/>could be just what you need, as shown in the following code sample 1-7:</p><div><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class MyScriptFile : MonoBehaviour 
05 {
06     // Use this for initialization
07     void Start ()
08    {
09         //Will count how many messages have been printed
10         int NumberOfMessages = 0;
11 
12         //Loop until 5 messages have been printed to the console
13         while(NumberOfMessages &lt; 5) 
14         {
15              //Print message

16              Debug.Log ("This is Message: " + NumberOfMessages.ToString());

17 
18              //Increment counter
19              ++NumberOfMessages;
20         }
21    }
22 
23    // Update is called once per frame
24    void Update () 
25    {
26    }
27 }</pre></div><div><div><h3 class="title"><a id="note09"/>Note</h3><p>
<strong>ToString</strong>
</p><p>Many classes and objects in Unity have a<a id="id63" class="indexterm"/> <code class="literal">ToString</code> function (see line 16 of code sample 1-7). This function converts the object, such as an integer (whole number), to a human-readable word or statement that can be printed to the <strong>Console</strong> or <strong>Debugging</strong> window. This is useful for printing objects and data to the console when debugging. Note that converting numerical objects to strings requires an implicit conversion.</p></div></div><p>The following <a id="id64" class="indexterm"/>are the comments for code sample 1-7:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Line 13 begins the <code class="literal">while</code> loop with the condition that it repeats until the integer variable <code class="literal">NumberOfMessages</code> exceeds or equals 5</li><li class="listitem" style="list-style-type: disc">The code block between lines 15 and 19 is repeated as the body of the <code class="literal">while</code> loop</li><li class="listitem" style="list-style-type: disc">Line 19 increments the variable <code class="literal">NumberOfMessages</code> on each iteration</li></ul></div><p>The result of code sample 1-7, when executed in the game mode, will be to print five text messages to the Unity Console when the level begins, as shown in the following screenshot:</p><div><img src="img/0655OT_01_09.jpg" alt="The while loop"/><div><p>Printing messages to Console in a while loop</p></div></div><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>More information <a id="id65" class="indexterm"/>on the <code class="literal">while</code> loop and its usage in C# can be found at <a class="ulink" href="http://msdn.microsoft.com/en-gb/library/2aeyhxcd.aspx">http://msdn.microsoft.com/en-gb/library/2aeyhxcd.aspx</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Infinite loops</h2></div></div></div><p>One danger of using loops, especially <code class="literal">while</code> loops, is to accidentally create an infinite loop, that is, a loop that cannot end. If your game enters an infinite loop, it will normally freeze, perhaps permanently, requiring you to force a quit by terminating the application or even worse, causing a <a id="id66" class="indexterm"/>complete system crash! Often, Unity will catch the problem and exit but don't rely on this. For example, removing line 19 of the code sample 1-7 would<a id="id67" class="indexterm"/> create an infinite loop because the <code class="literal">NumberOfMessages</code> variable will never increment to a level that satisfies the <code class="literal">while</code> loop condition, thereby causing an exit. The message of this section, then, is first and foremost, "Take care when writing and planning loops to avoid infinite loops." The following is another classic example of an infinite loop that will certainly cause problems for your game, so be sure to avoid them:</p><div><pre class="programlisting">//Loop forever
while(true)
{
}</pre></div><p>However, believe it or not, there are times when infinite loops are technically what you need for your game under the right conditions! If you need a moving platform to travel up and down endlessly, a magical orb to continually spin round and round, or a day-night cycle to perpetually repeat, then an infinite loop can be serviceable, provided it's implemented appropriately. Later in this book, we'll see examples where infinite loops can be put to good use. Loops are powerful, fun structures, but when coded inappropriately, whether infinite or not, they can be the source of crashes, stalls, and performance issues, so take care. In this book, we'll see good practices for creating loops.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Functions</h1></div></div></div><p>We already used functions<a id="id68" class="indexterm"/> in this chapter, such as the <code class="literal">Start</code> and <code class="literal">Update</code> functions. However, now, it's time to consider them more formally and precisely. In essence, a function is a collection of statements bundled together as a single, identifiable block, which is given a collective name and can be executed on demand, each line of the function being executed in sequence. When you think about the logic of your game, there are times when you need to perform some operations repeatedly on your objects, such as, firing a weapon, jumping in the air, killing enemies, updating the score, and playing a sound. You can copy and paste your code throughout the source file, wherever you need to reuse it; this is not a good habit to cultivate. It's easier to consolidate the recyclable code into a function that can be executed by a name when you need it, as shown in the following code sample 1-8:</p><div><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class MyScriptFile : MonoBehaviour 
05 {
06     //Private variable for score
07     //Accessible only within this class
08     private int Score = 0;
09 
10     // Use this for initialization
11     void Start ()
12    {
13       //Call update score
14       UpdateScore(5, false); //Add five points
15       UpdateScore (10, false); //Add ten points

16       int CurrentScore = UpdateScore (15, false); //Add fifteen points and store result

17 
18       //Now double score
19        UpdateScore(CurrentScore);
20     }
21 
22     // Update is called once per frame
23     void Update () 
24     {
25     }
26 
27     //Update game score

28     public int UpdateScore (int AmountToAdd, bool PrintToConsole = true)

29     {
30       //Add points to score
31       Score += AmountToAdd;
32 
33       //Should we print to console?

34       if(PrintToConsole){Debug.Log ("Score is: " + Score.ToString());}

35 
36       //Output current score and exit function
37       return Score;
38     }
39 }</pre></div><p>The following is the breakdown<a id="id69" class="indexterm"/> of the code present for code sample 1-8:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Line 08</strong>: A private, integer class variable <code class="literal">Score</code> is declared to keep track of a sample score value. This variable will be used later in the function <code class="literal">UpdateScore</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Lines 11, 23, and 28</strong>: The class <code class="literal">MyScriptFile</code> has three functions (sometimes called methods or member functions). These are <code class="literal">Start</code>, <code class="literal">Update</code>, and <code class="literal">UpdateScore</code>. <code class="literal">Start</code> and <code class="literal">Update</code> are special functions that Unity provides, as we'll see shortly. <code class="literal">UpdateScore</code><a id="id70" class="indexterm"/> is a custom function for <code class="literal">MyScriptFile</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Line 28</strong>: The <code class="literal">UpdateScore</code> function represents a complete block of code between lines 29 and 38. This specific function should be invoked every time the game score must change. When called, the code block (lines 29–38) will be executed sequentially. In this way, functions offer us code recyclability.</li><li class="listitem" style="list-style-type: disc"><strong>Lines 14-19</strong>: The <code class="literal">UpdateScore</code> function is called several times during the <code class="literal">Start</code> function. For each call, the execution of the <code class="literal">Start</code> function pauses until the <code class="literal">UpdateScore</code> function completes. At this point, the execution resumes in the next line.</li><li class="listitem" style="list-style-type: disc"><strong>Line 28</strong>: <code class="literal">UpdateScore</code> accepts two parameters or arguments. These are an integer <code class="literal">AmountToAdd</code> and a Boolean <code class="literal">PrintToConsole</code>. Arguments act like inputs we can plug in to the function to affect how they operate. The <code class="literal">AmountToAdd</code> variable expresses how much should be added to the current <code class="literal">Score</code> variable, and <code class="literal">PrintToConsole</code> determines whether the <code class="literal">Score</code> variable should be shown in the <strong>Console</strong> window when the function is executed. There is theoretically no limit to the number of arguments a function can have, and a function can also have no arguments at all, such as the <code class="literal">Start</code> and<a id="id71" class="indexterm"/> <code class="literal">Update</code> functions.</li><li class="listitem" style="list-style-type: disc"><strong>Lines 31–34</strong>: Here, the score is actually updated and printed to <strong>Console</strong>, if required. Notice that the <code class="literal">PrintToConsole</code> argument has a default value of <code class="literal">true</code> already assigned to the function declaration in line 28. This makes the argument optional whenever the function is called. Lines 14, 15, and 16 explicitly override the default value by passing a value of <code class="literal">false</code>. Line 19, in contrast, omits a second value and thereby accepts the default of <code class="literal">true</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Lines 28 and 37</strong>: The <code class="literal">UpdateScore</code> function has a return value, which is a data type specified in line 28 before the function name. Here, the value is an <code class="literal">int</code>. This means on exiting or completion, the function will output an integer. The integer, in this case, will be the current <code class="literal">Score</code>. This is actually output in line 37 using the<a id="id72" class="indexterm"/> <code class="literal">return</code> statement. Functions don't have to return a value, it's not essential. If no return value is needed, the return type should be <code class="literal">void</code> as with <code class="literal">Start</code> and <code class="literal">Update</code>.<div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>More information on functions<a id="id73" class="indexterm"/> and their usage in C# can be found at <a class="ulink" href="http://csharp.net-tutorials.com/basics/functions/">http://csharp.net-tutorials.com/basics/functions/</a>.</p></div></div></li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Events</h1></div></div></div><p>Events are essentially functions used in a distinctive way. Both the <code class="literal">Start</code> and <code class="literal">Update</code> functions, which we have already seen, would more accurately be described as Unity-specific events. Events<a id="id74" class="indexterm"/> are functions called to notify an object that something significant has happened: the level has begun, a new frame has started, an enemy has died, the player has jumped, and others. In being called at these critical times, they offer objects the chance to respond if necessary. The <a id="id75" class="indexterm"/>
<code class="literal">Start</code> function is called automatically by Unity when the object is first created, typically at level startup. The <code class="literal">Update</code> function <a id="id76" class="indexterm"/>is also called automatically, once on each frame. The <code class="literal">Start</code> function, therefore, gives us an opportunity to perform specific actions when the level begins, and the <code class="literal">Update</code> function on each frame many times per second. The <code class="literal">Update</code> function is especially useful, therefore, to achieve motion and animation in your games. Refer to code sample 1-9, which rotates an object over time:</p><div><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class MyScriptFile : MonoBehaviour 
05 {
06     // Use this for initialization
07     void Start ()
08     {
09     }
10 
11     // Update is called once per frame
12     void Update () 
13     {
14       //Rotate object by 2 degrees per frame around the Y axis
15       transform.Rotate(new Vector3(0.0f, 2.0f, 0.0f));
16     }
17 }</pre></div><p>Line 15 in code sample 1-9 is called once per frame. It continually rotates an object 2 degrees around the <em>y</em> axis. This code is frame rate dependent, which means that it'll turn objects faster when run on machines with higher frame rates, because <code class="literal">Update</code> will be called more often. There are techniques to achieve frame rate independence, ensuring that your games perform consistently across all machines, regardless of the frame rate. We'll see these in the next chapter. You can easily check the frame rate for your game directly from the Unity Editor <strong>Game</strong> tab. Select the <strong>Game</strong> tab and click on the <strong>Stats</strong> button in the top-right hand <a id="id77" class="indexterm"/>corner of the toolbar. This will show the <strong>Stats</strong> panel, offering a general, statistical overview of the performance of your game. This panels displays the game<a id="id78" class="indexterm"/> <strong>frames per second</strong> (<strong>FPS</strong>), which indicates both how often <code class="literal">Update</code> is called on your objects and the general performance of your game on your system. In general, an FPS lower than 15 indicates a significant performance problem. Strive for FPS rates of 30 or above. Refer to the following screenshot to access the <strong>Stats</strong> panel:</p><div><img src="img/0655OT_01_10.jpg" alt="Events"/><div><p>Accessing the Stats panel for the Game tab to view FPS</p></div></div><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>There are too many event types to list comprehensively. However, some common events in Unity, such as <code class="literal">Start</code> and <code class="literal">Update</code>, can be found in the <code class="literal">MonoBehaviour</code> class. More information <a id="id79" class="indexterm"/>on <code class="literal">MonoBehaviour</code> is<a id="id80" class="indexterm"/> available at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.html">http://docs.unity3d.com/ScriptReference/MonoBehaviour.html</a>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Classes and object-oriented programming</h1></div></div></div><p>A class is an amalgam of many related variables and functions, all brought together into a self-contained unit or "thing". To put it another way, if you think about a game (such as a fantasy RPG), it's filled <a id="id81" class="indexterm"/>with many independent things such as wizards, orcs, trees, houses, the player, quests, inventory items, weapons, spells, doorways, bridges, force fields, portals, guards, and so on. Many of these objects parallel <a id="id82" class="indexterm"/>objects in the real world too. However, crucially, each of these things is an independent object; a wizard is different and separate from a force field, and a guard is different and separate from a tree. Each of these things, then, can be thought of as an object—a custom type. If we focus our attention on one specific object, an orc enemy, for example, we can identify the properties and behaviors in this object. The orc will have a position, rotation, and scale; these correspond to variables.</p><p>The orc might have several kinds of attacks too, such as a melee attack with an axe and a ranged attack with a crossbow. These attacks are performed through functions. In this way, a collection of variables and functions are brought together into a meaningful relationship. The process of bringing these things together is known as encapsulation. In this example, an orc has been encapsulated into a class. The class, in this case, represents the template for a general, abstract orc (the concept of an orc). Objects, in<a id="id83" class="indexterm"/> contrast, are particular, concrete instantiations of the <code class="literal">Orc</code> class in the level. In Unity, script files define a class. To instantiate the class<a id="id84" class="indexterm"/> as an object in the level, add it to <code class="literal">GameObject</code>. As we've seen, classes are attached to game objects as components. Components are objects, and multiple components together form a <code class="literal">GameObject</code>. Refer to code sample 1-10 for a sample <code class="literal">Orc</code> class stub:</p><div><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class Orc : MonoBehaviour 
05 {
06 //Reference to the transform component of orc (position, rotation, scale)
07 private Transform ThisTransform = null;
08 
09 //Enum for states of orc
10 public enum OrcStates {NEUTRAL, ATTACK_MELEE, ATTACK_RANGE};
11 
12 //Current state of orc
13 public OrcStates CurrentState = OrcStates.NEUTRAL;
14 
15 //Movement speed of orc in meters per second
16 	public float OrcSpeed = 10.0f;
17 
18 //Is orc friendly to player
19 public bool isFriendly = false;
20 
21 //--------------------------------------------------
22 // Use this for initialization
23 void Start ()
24 {
25       //Get transform of orc
26       ThisTransform = transform;
27 }
28 //--------------------------------------------------
29 // Update is called once per frame
30 void Update ()
31 {
32 }
33 //--------------------------------------------------
34 //State actions for orc
35 public void AttackMelee()
36 {
37        //Do melee attack here
38 }
39 //--------------------------------------------------
40 public void AttackRange()
41 {
42        //Do range attack here
43 }
44 //--------------------------------------------------
45 }</pre></div><p>The following are<a id="id85" class="indexterm"/> the comments for code sample 1-10:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Line 04</strong>: Here, the class <code class="literal">keyword</code> is used to define a class named <code class="literal">Orc</code>. This class derives from <code class="literal">MonoBehaviour</code>. The next section of this chapter will consider inheritance<a id="id86" class="indexterm"/> and derived classes further.</li><li class="listitem" style="list-style-type: disc"><strong>Lines 09-19</strong>: Several variables and an enum are added to the <code class="literal">Orc</code> class. The variables are of different types, but all are related to the concept of an orc.</li><li class="listitem" style="list-style-type: disc"><strong>Lines 35-45</strong>: The orc has two methods: <code class="literal">AttackMelee</code> and <code class="literal">AttackRange</code>.<div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>More information <a id="id87" class="indexterm"/>on classes and their usage in C# can be found at <a class="ulink" href="http://msdn.microsoft.com/en-gb/library/x9afc042.aspx">http://msdn.microsoft.com/en-gb/library/x9afc042.aspx</a>.</p></div></div></li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Classes and inheritance</h1></div></div></div><p>Imagine a scenario where you create an <code class="literal">Orc</code> class to encode an orc object in the game. Having done so, you then decide to make two upgraded types. One is an Orc Warlord, with better armor and<a id="id88" class="indexterm"/> weapons, and the other is an Orc Mage who, as the name implies, is a spell caster. Both can do everything that the ordinary orc can do, but more besides. Now, to implement this, you can create three separate classes, <code class="literal">Orc</code>, <code class="literal">OrcWarlord</code>, and <code class="literal">OrcMage</code>, by copying and pasting common code between them.</p><p>The problem is that as Orc Warlord and Orc Mage share a lot of common ground and behaviors with orc, a lot of code will be <a id="id89" class="indexterm"/>wastefully copied and pasted to replicate the common behaviors. Furthermore, if you discovered a bug in the shared code of one class, you'd need to copy and paste the fix to the other classes to propagate it. This is both tedious and technically dangerous, as it risks wasting time, introducing bugs, and causing needless confusion. Instead, the object-oriented concept of inheritance can help us. Inheritance allows you to create a completely new class that implicitly absorbs or contains the functionality of another class, that is, it allows you to build a new class that extends<a id="id90" class="indexterm"/> an existing class without affecting the original one. When inheritance happens, two classes are brought into a relationship with each other. The original class (such as the <code class="literal">Orc</code> class) is known as the case class or ancestor class. The new class (such as the Orc Warlord or Orc Mage), which extends on the ancestor class, is called a super class or derived class.</p><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>More information <a id="id91" class="indexterm"/>on inheritance in C# can be found at <a class="ulink" href="http://msdn.microsoft.com/en-gb/library/ms173149%28v=vs.80%29.aspx">http://msdn.microsoft.com/en-gb/library/ms173149%28v=vs.80%29.aspx</a>.</p></div></div><p>By default, every new Unity script file creates a new class derived from <code class="literal">MonoBehaviour</code>. This means every new script contains all the <code class="literal">MonoBehaviour</code> functionality and has the potential to go beyond, based<a id="id92" class="indexterm"/> on the additional code that you add. To prove this, refer to the following code sample 1-11:</p><div><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class NewScript : MonoBehaviour 
05 {
06 //--------------------------------------------------
07    // Use this for initialization
08    void Start ()
09    {
10       name = "NewObject";
11 }
12    //--------------------------------------------------
13    // Update is called once per frame
14    void Update ()
15    {
16    }
17 }</pre></div><p>The following are the comments for code sample 1-11:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Line 04</strong>: The class <code class="literal">NewScript</code> is derived from <code class="literal">MonoBehaviour</code>. You can, however, substitute <code class="literal">MonoBehaviour</code> for almost any valid class name from which you want to derive.</li><li class="listitem" style="list-style-type: disc"><strong>Line 10</strong>: Here, the variable name is assigned a string during the <code class="literal">Start</code> event. However, notice that the name is not explicitly declared as a variable anywhere in the <code class="literal">NewScript</code> source file. If <code class="literal">NewScript</code> were a completely new class with <a id="id93" class="indexterm"/>no ancestor defined in line 04, then line 10 would be invalid. However, because <code class="literal">NewScript</code> derives from <code class="literal">MonoBehaviour</code>, it automatically inherits all of its variables, allowing us to access and edit them from <code class="literal">NewScript</code>.<div><div><h3 class="title"><a id="note10"/>Note</h3><p>
<strong>When to inherit</strong>
</p><p>Only use inheritance <a id="id94" class="indexterm"/>where it's really appropriate; otherwise, you'll make your classes large, heavy, and confusing. If you're creating a class that shares a lot of common functionality with another and it makes sense to establish connection between them, then use inheritance. Another use of inheritance, as we'll see next, is when you want to override specific functions.</p></div></div></li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec19"/>Classes and polymorphism</h1></div></div></div><p>To illustrate <a id="id95" class="indexterm"/>polymorphism in C#, let's start by considering the following code sample 1-12. This sample doesn't demonstrate polymorphism immediately<a id="id96" class="indexterm"/> but represents the start of a scenario where polymorphism will be useful, as we'll see. Here, a basic skeleton class is defined for a potential <a id="id97" class="indexterm"/>
<strong>non-player character</strong> (<strong>NPC</strong>) in a generic RPG game. The class is intentionally not comprehensive and features basic variables that only mark the starting point for a character. The most important thing here is that the class features a <code class="literal">SayGreeting</code> function, which should be invoked when the player engages the NPC in conversation. It displays a generic welcome message to <strong>Console</strong> as follows:</p><div><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class MyCharacter
05 {
06 public string CharName = "";
07 public int Health = 100;
08 public int Strength = 100;
09 public float Speed = 10.0f;
10 public bool isAwake = true;
11 
12     //Offer greeting to the player when entering conversation
<strong>13     public virtual void SayGreeting()</strong>
14     {
15         Debug.Log ("Hello, my friend");
16     }
17 }</pre></div><p>The first problem to arise relates to the diversity and believability of the <code class="literal">MyCharacter</code> class if we try imagining how it'd really work in a game. Specifically, every character instantiated from <code class="literal">MyCharacter</code> will offer exactly the same greeting when <code class="literal">SayGreeting</code> is invoked: men, women, orcs, and everybody. They'll all say the same thing, namely, <code class="literal">"Hello, my friend"</code>. This is neither believable nor desirable. Perhaps, the most elegant solution would <a id="id98" class="indexterm"/>be to just add a public string variable to the class, thus allowing customization over the message printed. However, to illustrate polymorphism clearly, let's try a different solution. We could create several additional classes instead, all derived from <code class="literal">MyCharacter</code>, one for each new NPC type and each offering a unique greeting from a <code class="literal">SayGreeting</code> function. This is possible with <code class="literal">MyCharacter</code>, because <code class="literal">SayGreeting</code> has been declared using the virtual keyword (line 13). This allows derived<a id="id99" class="indexterm"/> classes to override the behavior of <code class="literal">SayGreeting</code> in the <code class="literal">MyCharacter</code> class. This means<a id="id100" class="indexterm"/> the <code class="literal">SayGreeting</code> function in derived classes will replace the behavior of the original function in the base class. Such a solution might look similar to the code sample 1-13:</p><div><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 //-------------------------------------------
04 public class MyCharacter
05    {
06    public string CharName = "";
07    public int Health = 100;
08 public int Strength = 100;
09 public float Speed = 10.0f;
10 public bool isAwake = true;
11 
12 //Offer greeting to the player when entering conversation
13 public virtual void SayGreeting()
14 {
15        Debug.Log ("Hello, my friend");
16 	}
17 }
18 //-------------------------------------------
19 public class ManCharacter: <strong>MyCharacter</strong>
20 {
<strong>21 public override void SayGreeting()</strong>
22 {
23        Debug.Log ("Hello, I'm a man");
24 }
25 }
26 //-------------------------------------------
27 public class WomanCharacter: <strong>MyCharacter</strong>
28 {
<strong>29 public override void SayGreeting()</strong>
30 {
31        Debug.Log ("Hello, I'm a woman");
32 }
33 }
34 //-------------------------------------------
35 public class OrcCharacter: <strong>MyCharacter</strong>
36 {
<strong>37 public override void SayGreeting()</strong>
38 {
39        Debug.Log ("Hello, I'm an Orc");
40 }
41 }
42 //-------------------------------------------</pre></div><p>With this code, some improvement is made, that is, different classes are created for each NPC type, namely, <code class="literal">ManCharacter</code>, <code class="literal">WomanCharacter</code>, and <code class="literal">OrcCharacter</code>. Each offers a different greeting in the <code class="literal">SayGreeting</code> function. Further, each NPC inherits all the common behaviors from the shared base class <code class="literal">MyCharacter</code>. However, a technical problem regarding type<a id="id101" class="indexterm"/> specificity arises. Now, imagine creating a tavern location inside which there are many NPCs of the different types defined, so far, all enjoying a tankard of grog. As the player<a id="id102" class="indexterm"/> enters the tavern, all NPCs should offer their unique greeting. To achieve this functionality, it'd be great if we could have a single array of all NPCs and simply call their <code class="literal">SayGreeting</code> function from a loop, each offering their own greeting. However, it seems, initially, that we cannot do this. This is because all elements in a single array must be of the same data type, such as <code class="literal">MyCharacter[]</code> or <code class="literal">OrcCharacter[]</code>. We cannot mix types for the same array. We could, of course, declare multiple arrays for each NPC type, but this feels awkward and doesn't easily allow for the seamless creation of more NPC types after the array code has been written. To solve this problem, we'll need a specific and dedicated solution. This is where polymorphism comes to the rescue. Refer to the<a id="id103" class="indexterm"/> following sample 1-14, which defines a new <code class="literal">Tavern</code> class in <a id="id104" class="indexterm"/>a completely separate script file:</p><div><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class Tavern : MonoBehaviour 
05 {
06 //Array of NPCs in tavern
07 public MyCharacter[] Characters = null;
08 //-------------------------------------------------------
09 // Use this for initialization
10 void Start () {
11 
12       //New array - 5 NPCs in tavern
13       Characters = new MyCharacter[5];
14 
15        //Add characters of different types to array MyCharacter
16        Characters[0] = new ManCharacter();
17        Characters[1] = new WomanCharacter();
18        Characters[2] = new OrcCharacter();
19        Characters[3] = new ManCharacter();
20        Characters[4] = new WomanCharacter();
21 
22        //Now run enter tavern functionality
23        EnterTavern();
24 }
25 //-------------------------------------------------------
26 //Function when player enters Tavern
27 public void EnterTavern()
28 {
29       //Everybody say greeting
30       foreach(MyCharacter C in Characters)
31       {
32              //call SayGreeting in derived class
33              //Derived class is accessible via base class
34             C.SayGreeting();
35       }
36 }
37 //-------------------------------------------------------
38 }</pre></div><p>The following are the comments for code sample 1-14:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Line 07</strong>: To keep track of all NPCs in the tavern, regardless of the NPC type, a single array (<code class="literal">Characters</code>) of type <code class="literal">MyCharacter</code> is declared.</li><li class="listitem" style="list-style-type: disc"><strong>Lines 16-20</strong>: The <code class="literal">Characters</code> array is populated with multiple NPCs of different types. This works because, though they are of different types, each NPC derives from the same base class.</li><li class="listitem" style="list-style-type: disc"><strong>Line 27</strong>: The <code class="literal">EnterTavern</code> function is called at level startup.</li><li class="listitem" style="list-style-type: disc"><strong>Line 34</strong>: A <code class="literal">foreach</code> loop cycles through all NPCs in the <code class="literal">Characters</code> array, calling the <code class="literal">SayGreeting</code> function. The result is shown in the following screenshot. The unique<a id="id105" class="indexterm"/> messages for each NPC are printed instead of the generic message defined in the base class. Polymorphism<a id="id106" class="indexterm"/> allows the overridden method in the derived classes to be called instead.<div><img src="img/0655OT_01_11.jpg" alt="Classes and polymorphism"/><div><p>Polymorphism produces a backwards transparency between data types that share a common lineage</p></div></div></li></ul></div><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>More information<a id="id107" class="indexterm"/> on polymorphism in C# can be found at <a class="ulink" href="http://msdn.microsoft.com/en-GB/library/ms173152.aspx">http://msdn.microsoft.com/en-GB/library/ms173152.aspx</a>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec20"/>C# properties</h1></div></div></div><p>When assigning values to class variables, such as <code class="literal">MyClass.x = 10;</code>, there are a couple of important<a id="id108" class="indexterm"/> things to take care of. First, you'll typically want to validate the value being assigned, ensuring that the variable is always valid. Typical cases include clamping an integer between a minimum and maximum range or allowing only a limited set of strings for a string<a id="id109" class="indexterm"/> variable. Second, you might need to detect when a variable changes, initiating other dependent functions and behaviors. C# properties let you achieve both these features. Refer to the following code sample 1-15, which limits an integer between <code class="literal">1</code> and <code class="literal">10</code> and prints a message to the console whenever it changes:</p><div><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 //------------------------------------------------------
04 //Sample class - can be attached to object as a component
05 public class Database : MonoBehaviour 
06 {
07 //------------------------------------------------------
08 //Public property for private variable iMyNumber
09 //This is a public property to the variable iMyNumber
10 public int MyNumber
11 {
12        //Called when retrieving value
13        get
14       {
15               return iMyNumber; //Output iMyNumber
16       }
17 
18         //Called when setting value
19        set
20       {
21              //If value is within 1-10, set number else ignore
22             if(value &gt;= 1 &amp;&amp; value &lt;= 10)
23             {
24                    //Update private variable
25                    iMyNumber = value;
26 
27                    //Call event
28                    NumberChanged();
29             }
30        }
31 }
32 //------------------------------------------------------
33 //Internal reference a number between 1-10
34 private int iMyNumber = 0;
35 //------------------------------------------------------
36 // Use this for initialization
37 void Start () 
38 {
39        //Set MyNumber
40        MyNumber = 11; //Will fail because number is &gt; 10
41 
42        //Set MyNumber
43         MyNumber = 7; //Will succeed because number is between 1-10
44 }
45 //------------------------------------------------------
46 //Event called when iMyNumber is changed
47 void NumberChanged()
48 {

49        Debug.Log("Variable iMyNumber changed to : " + iMyNumber.ToString());

50 }
51 //------------------------------------------------------
52 }
53 //------------------------------------------------------</pre></div><p>The following are the<a id="id110" class="indexterm"/> comments for code sample 1-15:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Line 10</strong>: A public integer property is declared. This property is not an independent variable but simply a <code class="literal">wrapper</code> and <code class="literal">accessor</code> interface for the private variable <code class="literal">iMyNumber</code>, declared in line 34.</li><li class="listitem" style="list-style-type: disc"><strong>Line 13</strong>: When <code class="literal">MyNumber</code> is used or referenced, the internal <code class="literal">get</code> function is called.</li><li class="listitem" style="list-style-type: disc"><strong>Line 14</strong>: When <code class="literal">MyNumber</code> is assigned a value, the internal <code class="literal">set</code> function is called.</li><li class="listitem" style="list-style-type: disc"><strong>Line 25</strong>: The <code class="literal">set</code> function features an implicit argument value that represents the value to be assigned.</li><li class="listitem" style="list-style-type: disc"><strong>Line 28</strong>: The event <code class="literal">NumberChanged</code> is called when the <code class="literal">iMyNumber</code> variable is assigned a value.<div><div><h3 class="title"><a id="note11"/>Note</h3><p>
<strong>Properties and Unity</strong>
</p><p>Properties are useful to validate and control the assignment of values to variables. The main<a id="id111" class="indexterm"/> problem with using them in Unity concerns their visibility in the Object Inspector. Specifically, C# properties are not shown<a id="id112" class="indexterm"/> in the Object Inspector. You can neither get nor set their values in the editor. However, community-made <a id="id113" class="indexterm"/>scripts and solutions are available that can change this default behavior, for example exposing C# properties. These <a id="id114" class="indexterm"/>scripts and solutions can be found at <a class="ulink" href="http://wiki.unity3d.com/index.php?title=Expose_properties_in_inspector">http://wiki.unity3d.com/index.php?title=Expose_properties_in_inspector</a>.</p></div></div></li></ul></div><p>More information on<a id="id115" class="indexterm"/> <strong>Properties</strong> in C# can be found at <a class="ulink" href="http://msdn.microsoft.com/en-GB/library/x9fsa0sw.aspx">http://msdn.microsoft.com/en-GB/library/x9fsa0sw.aspx</a>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec21"/>Commenting</h1></div></div></div><p>Commenting is the <a id="id116" class="indexterm"/>practice of inserting human readable messages into your code, purely for annotation, description, and to make things clearer to the reader. In C#, one-line comments are prefixed with the <code class="literal">//</code> symbol, and multiline comments begin with <code class="literal">/*</code> and end with <code class="literal">*/</code>. Comments are used throughout the code samples in this book. Comments are important, and I recommend that you get into the habit of using them if you're not already in the habit. They benefit not only other developers in your team (if you work with others), but you too! They help remind you of what your code is doing when you return to it weeks or months later, and they even help you get clear and straight about the code you're writing right now. Of course, all these benefits depend on you writing concise and meaningful comments and not long essays filled with irrelevance. However, MonoDevelop offers XML-based comments too to describe functions and <a id="id117" class="indexterm"/>arguments specifically and which integrates with code completion. It can significantly boost your workflow, especially when working in teams. Let's see how to use this. Start by writing your function or any function, as shown in the following screenshot:</p><div><img src="img/0655OT_01_12.jpg" alt="Commenting"/><div><p>Writing a function (AddNumbers) in MonoDevelop (preparing for code commenting)</p></div></div><p>Then insert three forward-slash characters on the line above the function title (<code class="literal">///</code>), as shown in the following screenshot:</p><div><img src="img/0655OT_01_13.jpg" alt="Commenting"/><div><p>Inserting /// above the function title to create an XML comment</p></div></div><p>When you do this, MonoDevelop automatically inserts a template XML comment ready for you to complete<a id="id118" class="indexterm"/> with appropriate descriptions. It creates a summary section that describes the function generally and param entries for each argument in the function, as shown in the following screenshot:</p><div><img src="img/0655OT_01_14.jpg" alt="Commenting"/><div><p>Inserting /// above the function title will autogenerate an XML comment</p></div></div><p>Next, fill in the XML template completely with comments for your function. Be sure to give each parameter an appropriate comment too, as shown in the following screenshot:</p><div><img src="img/0655OT_01_15.jpg" alt="Commenting"/><div><p>Commenting your functions using XML comments</p></div></div><p>Now, when calling the <code class="literal">AddNumbers</code> function elsewhere in code, the code-completion pop-up helper will <a id="id119" class="indexterm"/>display both the summary comment for the function as well as the parameter comments' context sensitively, as shown here:</p><div><img src="img/0655OT_01_16.jpg" alt="Commenting"/><div><p>Viewing comments when making function calls</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec22"/>Variable visibility</h1></div></div></div><p>One excellent feature of Unity specifically is that it exposes (shows) public class variables inside the Object Inspector in the Unity Editor, allowing you to edit and preview variables, even<a id="id120" class="indexterm"/> at runtime. This is especially convenient for debugging. However, by default, the Object Inspector doesn't expose private variables. They are typically hidden from the inspector. This isn't always a good thing because there are many cases where you'll want to debug or, at least, monitor private variables from the inspector without having to change their scope to public. There are two main ways to overcome this problem easily.</p><p>The first solution would be useful if you want to view all public and private variables in a class. You can toggle the Object Inspector in the <strong>Debug</strong> mode. To do this, click on the context menu icon in the top-right corner of the <strong>Inspector</strong> window and select <strong>Debug</strong> from the context menu, as shown in the following screenshot. When <strong>Debug</strong> is selected, all the public and private variables for a class will show.</p><div><img src="img/0655OT_01_17.jpg" alt="Variable visibility"/><div><p>Enabling the Debug mode in the Object Inspector will show all the variables in a class</p></div></div><p>The second solution is useful for displaying specific private variables, variables that you mark explicitly as wanting<a id="id121" class="indexterm"/> to display in the Object Inspector. These will show in both the <strong>Normal</strong> and <strong>Debug</strong> modes. To achieve this, declare the private variable with the attribute <code class="literal">[SerializeField]</code>. C# attributes are considered later in this book, as shown here:</p><div><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class MyClass : MonoBehaviour 
05 {
06 //Will always show
07 public int PublicVar1;
08 
09 //Will always show
10 <strong>[SerializeField]</strong>
11 private int PrivateVar1;
12 
13 //Will show only in Debug Mode
14 private int PrivateVar2;
15 
16 //Will show only in Debug Mode
17 private int PrivateVar3;
18 }</pre></div><div><div><h3 class="title"><a id="tip13"/>Tip</h3><p>You can also use<a id="id122" class="indexterm"/> the <code class="literal">[HideInInspector]</code> attribute to hide a global variable from the inspector.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec23"/>The ? operator</h1></div></div></div><p>The <code class="literal">if-else</code> statements are so common and widely used in C# that a specialized shorthand notation is available for writing simpler ones, without resorting to the full multiline <code class="literal">if-else</code> <a id="id123" class="indexterm"/>statements. This shorthand is called the <code class="literal">?</code> operator. The basic form of this statement is as follows:</p><div><pre class="programlisting">//If condition is true then do expression 1, else do expression 2
(condition) ? expression_1 : expression_2;</pre></div><p>Let's see the <code class="literal">?</code> operator in a practical example as shown here:</p><div><pre class="programlisting">//We should hide this object if its Y position is above 100 units
<strong>bool ShouldHideObject = (transform.position.y &gt; 100) ? true : false;</strong>

//Update object visibility
gameObject.SetActive(!ShouldHideObject);</pre></div><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>The <code class="literal">?</code> operator is useful for shorter statements, but for long and more intricate statements, it can make your code harder to read.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec24"/>SendMessage and BroadcastMessage</h1></div></div></div><p>The <code class="literal">MonoBehaviour</code> class included in the Unity API, which acts as the base class for most new scripts, offers the<a id="id124" class="indexterm"/> <code class="literal">SendMessage</code> and <code class="literal">BroadcastMessage</code> methods. Using these, you can easily execute functions by name on all components attached to an object. To invoke a method of a class, you typically need a local reference to that class to access and run its functions as well as to access its variables. However, the <code class="literal">SendMessage</code> and <code class="literal">BroadcastMessage</code> functions let you run functions using string values by simply<a id="id125" class="indexterm"/> specifying the name of a function to run. This is very convenient and makes your code look a lot simpler and shorter at the cost of efficiency, as we'll see later. Refer to the following code sample 1-16:</p><div><pre class="programlisting">01 using UnityEngine;
02 using System.Collections;
03 
04 public class MyClass : MonoBehaviour 
05 {
06 void start()
07 {
08        //Will invoke MyFunction on ALL components/scripts attached to this object (where the function is present)

09         SendMessage("MyFunction", SendMessageOptions.DontRequireReceiver);

10 }
11 
12 //Runs when SendMessage is called
13 void MyFunction()
14 {
15        Debug.Log ("hello");
16 }
17 }</pre></div><p>The following are the comments for code sample 1-16:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Line 09</strong>: <code class="literal">SendMessage</code> is called to invoke the function <code class="literal">MyFunction</code>. <code class="literal">MyFunction</code> will be invoked not only on this class but on all other components attached to <code class="literal">GameObject</code>, if they have a <code class="literal">MyFunction</code> member, including the <code class="literal">Transform</code> component as well as others.</li><li class="listitem" style="list-style-type: disc"><strong>Line 09</strong>: The parameter <code class="literal">SendMessageOptions.DontRequireReceiver</code> defines what happens if <code class="literal">MyFunction</code> is not present on a component. Here, it specifies that Unity should ignore the component and move on to the next calling <code class="literal">MyFunction</code> wherever it is found.<div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>The term function and member function mean the same thing when the function belongs to a class. A function that belongs to a class is said to be a member function.</p></div></div></li></ul></div><p>We've seen that <code class="literal">SendMessage</code> invokes a specified function across all components attached to a single <code class="literal">GameObject</code>. <code class="literal">BroadcastMessage</code> incorporates the <code class="literal">SendMessage</code> behavior and goes a stage<a id="id126" class="indexterm"/> further, that is, it invokes a specified function for all<a id="id127" class="indexterm"/> components on <code class="literal">GameObject</code> and then repeats this process recursively for all child objects in the scene hierarchy, cascading downwards to all children.</p><p>More information on<a id="id128" class="indexterm"/> <code class="literal">SendMessage</code> and <code class="literal">BroadcastMessage</code> can be<a id="id129" class="indexterm"/> found at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html">http://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html</a> and <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Component.BroadcastMessage.html">http://docs.unity3d.com/ScriptReference/Component.BroadcastMessage.html</a>.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>
<strong>Reflection</strong>
</p><p>
<code class="literal">SendMessage</code> and <code class="literal">BroadcastMessage</code> are effective ways to facilitate inter-object communication and inter-component communication, that is, it's a great way to make components talk to one another if they need to, to synchronize behavior and recycle functionality. However, both <code class="literal">SendMessage</code> and <code class="literal">BroadcastMessage</code> rely internally on a C# feature known as <a id="id130" class="indexterm"/>
<strong>reflection</strong>. By invoking a function using a string, your application is required to look at itself at runtime (to reflect), searching its code for the intended function to run. This process is computationally expensive compared to running a function in the normal way. For this reason, seek to minimize the usage of <code class="literal">SendMessage</code> and <code class="literal">BroadcastMessage</code>, especially during <code class="literal">Update</code> events or other frame-based scenarios, as the impact on performance can be significant. This doesn't mean you should never use them. There might be times when their use is rare, infrequent, and convenient and has practically no appreciable impact. However, later chapters in this book will demonstrate alternative and faster techniques using delegates and interfaces.</p></div></div><p>If you'd like more information on C# and its usage before proceeding further with this book, then I recommend the following sources: </p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Learning C# by Developing Games with Unity 3D Beginner's Guide</em>, <em>Terry Norton</em>, <em>Packt Publishing</em></li><li class="listitem" style="list-style-type: disc"><em>Intro to C# Programming and Scripting for Games in Unity</em>, <em>Alan Thorn</em> (3DMotive video<a id="id131" class="indexterm"/> course found at <a class="ulink" href="https://www.udemy.com/3dmotive-intro-to-c-programming-and-scripting-for-games-in-unity/">https://www.udemy.com/3dmotive-intro-to-c-programming-and-scripting-for-games-in-unity/</a>)</li><li class="listitem" style="list-style-type: disc"><em>Pro Unity Game Development with C#</em>, <em>Alan Thorn</em>, <em>Apress</em></li></ul></div><p>The<a id="id132" class="indexterm"/> following are <a id="id133" class="indexterm"/>a few online <a id="id134" class="indexterm"/>resources:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://msdn.microsoft.com/en-gb/library/aa288436%28v=vs.71%29.aspx">http://msdn.microsoft.com/en-gb/library/aa288436%28v=vs.71%29.aspx</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.csharp-station.com/tutorial.aspx">http://www.csharp-station.com/tutorial.aspx</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://docs.unity3d.com/ScriptReference/">http://docs.unity3d.com/ScriptReference/</a></li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec25"/>Summary</h1></div></div></div><p>This chapter offered a general, Unity-specific overview of Unity's C#, exploring the most common and widely-used language features for game development. Later chapters will revisit some of these subjects in a more advanced way, but everything covered here will be critical for understanding and writing the code featured in subsequent chapters.</p></div></body></html>