- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Dealing with Time and Technical Debt
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理时间和技术债务
- en: 'An information system is like a living organism: it always moves and changes.
    Yet, most of them are designed “one shot,” without thinking of its adequation
    to the business in time, but only of its capacity to handle the business needs
    at the moment it is designed. Lots of IT problems can be related to time.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 信息系统就像一个活生生的有机体：它总是移动和变化。然而，大多数系统都是“一次性”设计的，没有考虑到它们在时间上的适应性，而只是考虑了它们在设计时的处理业务需求的能力。许多IT问题都可以与时间相关联。
- en: 'In the previous chapter, we talked about business alignment and the importance
    of basing the structure on business concerns. This must also be applied to taking
    time as a parameter of the equation for a good information system: if the business
    feature is a one-shot/disposable one, its technical implementation will be no
    more complex than a prototype, quickly coded and soon discarded after use. On
    the other hand, for a feature that will be used for decades in production, you
    must carefully hone the design and polish the implementation, with as few moving
    parts as possible, since a good architect knows that maintaining such a module
    will eventually cost much more than its initial development (see, for example,
    [https://natemcmaster.com/blog/2023/06/18/less-code/](https://natemcmaster.com/blog/2023/06/18/less-code/)
    on this issue). The code’s quality and its ease of maintenance (hence the developer’s
    dreaded activity of documentation) will be much more important than the capacity
    to quickly deliver the feature for time-to-market reasons.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了业务对齐以及基于业务关注点构建结构的重要性。这也必须应用于将时间作为良好信息系统的方程参数：如果业务功能是一次性/可丢弃的，其技术实现将不会比原型更复杂，快速编码并在使用后很快被丢弃。另一方面，对于将在生产中使用数十年的功能，你必须仔细打磨设计并完善实现，尽可能减少移动部件，因为一个好的架构师知道维护这样一个模块最终将比其初始开发成本高得多（例如，参见[https://natemcmaster.com/blog/2023/06/18/less-code/](https://natemcmaster.com/blog/2023/06/18/less-code/)关于这个问题的讨论）。代码的质量及其易于维护（因此是开发者害怕的活动——文档）将比快速交付功能以适应市场时间的重要性更大。
- en: This chapter will analyze this problem of time adequation in information systems
    since most of them are designed with a time-fixed goal and rarely with evolution
    in time. This is why the majority of them see their performance quickly degrade
    in time and also why when their construction is too long, the result is not even
    in conformity to the expressed needs, hence the emergence of Agile software. The
    concept of technical debt will be explained, as well as the notion of coupling.
    Hopefully, by the end of this chapter, you will have improved your critical thinking
    of what needs a **Proof of Concept** (**PoC**) approach and what needs strong,
    evolutive, design.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分析信息系统时间适应性这个问题，因为大多数系统都是基于固定时间目标设计的，很少考虑到时间的演变。这就是为什么它们在时间上性能迅速下降，也是为什么当它们的构建时间过长时，结果甚至不符合表达的需求，因此出现了敏捷软件开发。将解释技术债务的概念，以及耦合的概念。希望到本章结束时，你将提高对需要**概念验证**（**PoC**）方法以及需要强大、可演进的、设计的批判性思维。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The impact of time on systems due to functional change
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能变化对系统时间的影响
- en: How the Agile approach aims to solve the problem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏捷方法旨在如何解决这个问题
- en: The concept of technical debt
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术债务的概念
- en: An experience-proven blueprint method for information systems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息系统的经验证蓝图方法
- en: The impact of time on systems due to functional change
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能变化对系统时间的影响
- en: One of the most difficult things to do when designing systems is to consider
    time. After all, it is already hard to picture how something complex should look
    at a given moment. Taking time into account requires an additional depth of thought,
    which can make this difficult. Moreover, time variations happen in every aspect
    as the system evolves, but it should also take into account time in its functioning,
    just like another variable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计系统时，最难做到的一件事就是考虑时间。毕竟，要想象一个复杂事物在某一时刻的样子已经很困难了。考虑到时间需要额外的思考深度，这可能会使问题更加复杂。此外，随着时间的推移，系统的各个方面都会发生变化，但它也应该在功能运行时考虑到时间，就像另一个变量一样。
- en: A bit of fun with ill-placed comparisons
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些关于不当比较的有趣之处
- en: 'Here are a few sentences you may have heard in your everyday life concerning
    industries other than computers:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些你可能在日常生活中听到的关于计算机行业以外的行业的句子：
- en: The repairman changed my car engine this weekend; it is now ready for another
    10 years
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维修工这周末更换了我的汽车引擎；现在它又可以再使用10年了
- en: 'I took generic pills instead of the commercial brand: they are less expensive
    and I did not notice any difference'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我用普通药片代替了商业品牌：它们更便宜，我没有注意到任何区别
- en: Since we started regularly maintaining the furnace, we haven’t had any failures
    during the winter
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们开始定期维护锅炉，我们在整个冬天都没有出现任何故障
- en: The dimensions of the parts evolved a bit, but we just had to change the parameters
    on the CNC machine; there was no need for the machining expert for such a small
    change
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零件的尺寸略有变化，但我们只需在数控机床上更改参数；对于这样的小改动，不需要加工专家
- en: 'Now, let’s try and transpose this to the IT industry and see if we can hear
    the same expressions without at least a wry smile or a smirking face:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试将其转移到IT行业，看看我们是否能在至少不露出一个苦笑或微笑的表情的情况下听到相同的表达：
- en: We changed the ERP this weekend; everything seemed to work quite well on Monday
    morning
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在本周末更换了ERP系统；周一早上一切似乎运行得相当顺利
- en: 'I used some free software as a replacement for my commercial suite: less expensive
    and since it was 100% compatible, everything works exactly as before'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我使用了一些免费软件作为商业套件的替代品：更便宜，而且由于它与100%兼容，一切工作都和以前一样
- en: Since we regularly maintain our information system, we never have any major
    failures or bugs
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们定期维护我们的信息系统，我们从未遇到过任何重大故障或错误
- en: The business people need to adjust the system due to regulatory systems but,
    since it is just business rules, they do not need the IT team for such a small
    change
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于监管系统，业务人员需要调整系统，但由于这只是业务规则，他们不需要IT团队进行这样的小改动
- en: 'Do any of these sentences sound realistic? If you happen to have the slightest
    experience in information systems, you will know that they aren’t, and even sound
    humorous. Nothing could be further from reality than these utopic sentences. The
    equivalent sentences should be more like the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些句子听起来现实吗？如果你在信息系统方面有一点经验，你会知道它们并不现实，甚至听起来很幽默。没有什么比这些乌托邦式的句子更远离现实的了。相应的句子应该更像是以下这样：
- en: Management has decided to change the core ERP; we expect the information system
    to have a stabilization period of at least 6 months, and the initial project with
    analysis, deployment, and training will certainly take at least a year.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理层已经决定更换核心ERP系统；我们预计信息系统将有一个至少6个月的稳定期，并且最初的包括分析、部署和培训的项目肯定至少需要一年时间。
- en: I switched to open source to eliminate license costs, but since I had to adjust
    most of my processes, I lost a few functionalities and experts are hard to find
    on this technology, I am not sure the TCO will be lower in the end.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我转向开源软件以消除许可费用，但由于我必须调整大部分流程，我失去了一些功能，而且在这个技术领域专家很难找到，我不确定最终的总拥有成本是否会降低。
- en: Due to new cybersecurity compliance rules, we made the entire IT team push updates
    to software applications that are disseminated everywhere in the information system;
    we hope most of the servers are covered but know that we still have a high level
    of risk on the employees’ workstations.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于新的网络安全合规性规则，我们让整个IT团队推送更新到信息系统中的所有软件应用；我们希望大多数服务器都得到了覆盖，但我们知道员工的工作站仍然存在高水平的风险。
- en: “This new GDPR will oblige us to release a brand-new version of the software
    and adjust most of the data streams in the information system; IT will certainly
    spend most of its non-maintenance time on this for the next 6 months.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “新的GDPR将迫使我们必须发布一个全新的软件版本，并调整信息系统中的大部分数据流；IT部门在接下来的6个月里肯定将把大部分非维护时间花在这上面。
- en: 'These versions are way more realistic but sound like a desperate evaluation
    of the situation. Where does such a catastrophic capacity of the information systems
    come from? As explained in [*Chapter 1*](B21293_01.xhtml#_idTextAnchor014), information
    systems are not industrialized yet. But if you pay closer attention to these sentences,
    you will realize that they all bear the notion of evolution in time. And this
    is what makes them sound silly. If time was taken out of the equation, they may
    look fine:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些版本看起来更加真实，但听起来像是对形势的绝望评估。这样的信息系统的灾难性容量是从哪里来的？正如在[*第一章*](B21293_01.xhtml#_idTextAnchor014)中解释的那样，信息系统尚未实现工业化。但如果你更仔细地注意这些句子，你会意识到它们都包含时间演化的概念。这正是它们听起来很愚蠢的原因。如果时间从等式中去除，它们可能看起来还不错：
- en: The ERP we currently use works correctly
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们目前使用的ERP系统运行正常
- en: I am using free software and it works as expected
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我在使用免费软件，它按预期工作
- en: I am using the latest version; everything seems to be fine (for now)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我正在使用最新版本；目前一切似乎都很正常
- en: We have set up the software with initial rules (and we hope we don’t have to
    change them in the future)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经设置了软件的初始规则（并且我们希望未来不需要更改它们）
- en: In short, IT can work and provide great services but most of the time, this
    is when time passes and IT has got to evolve when problems arise.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，IT可以工作并提供优质的服务，但大多数时候，这是时间流逝和IT必须进化以解决问题的时候。
- en: Consequences in the software world
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件世界的后果
- en: 'The preceding comparisons may seem anecdotal, but they bear some reality as
    change is the only constant in life, and thus in information systems. A fun story
    I once heard stated that a perfectly stable information system is possible but
    needs three components: a human, a computer, and a dog. The computer does the
    work, the human feeds the dog, and the dog protects the computer from the human
    touching it.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上述比较可能看起来像是轶事，但它们反映了一些现实，因为变化是生活中唯一不变的因素，因此在信息系统也是如此。我听说的一个有趣的故事说，一个完全稳定的信息系统是可能的，但需要三个组件：一个人，一台计算机和一条狗。计算机做工作，人喂狗，狗保护计算机免受人的触碰。
- en: 'Again, despite the humorous approach, there is some truth in this joke: the
    fact that the perfect system can be considered so because it is stable (the dog
    preventing the human from causing change, and consequently chaos). The computer
    can do a perfect job because it does not need to change what it has been programmed
    to do. Humor put aside, the consequences of time and evolution on information
    systems can be described formally and various concepts are associated with their
    different categories, all of which we will describe here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，尽管这个笑话带有幽默的成分，但其中确实有一些真理：完美的系统之所以被认为是完美的，是因为它是稳定的（狗阻止人造成变化，从而造成混乱）。计算机可以做得完美，因为它不需要改变它被编程去做的事情。抛开幽默，时间和进化对信息系统的影响可以正式描述，并且与它们的不同类别相关联，所有这些我们都会在这里描述：
- en: 'The first concept associated with time in IT – and this one is well-known by
    anyone using computers – is the notion of software upgrades. As time goes by,
    a piece of software, whatever quality efforts are put into its design and development,
    will have to undergo regular changes of versions and at least security patches
    to remain fully operational. A software application is a complex system in itself,
    with sometimes millions of lines of code. If we go on with comparisons with the
    mechanical industry (sorry about coming back on this one, which certainly comes
    from my academic background in mechanical systems), that means a standard industry-grade
    application is closer in complexity to a commercial airplane than a standard automobile.
    No wonder it has to be upgraded and adjusted during its lifetime, just like airliners
    necessitate heavy maintenance. The difficulty comes from the fact that most applications
    are designed in a way that is not as modular as we would expect, and unexpected
    dependencies happen very often, making the application work as a cohesive entity.
    If you take a Rafale war aircraft, the engines can be changed by two mechanics
    in a few hours because the whole plane has been designed with this constraint.
    How about your ERP software? Is there any way you could switch the authorization
    engine in a few hours? Most certainly not... This is why the majority of software
    applications have a limited life expectancy: after many version upgrades, the
    overall quality always degrades and, in time, the application becomes less adapted
    to the business. Sure, some applications stay in business for more than 10 years,
    sometimes 20 or even more. But ask the users if the reason is that the software
    is perfect and if they love it and you will always get the same answer: the piece
    of software is still here simply because it is way too dangerous to try and remove
    it!'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与信息技术中时间相关联的第一个概念——并且这个概念对于任何使用计算机的人来说都是众所周知的——就是软件升级的概念。随着时间的推移，无论在设计和发展过程中投入了多少质量努力，一款软件都必须经历定期的版本更新和至少安全补丁，以保持完全运行。一个软件应用本身就是一个复杂的系统，有时有成百万行代码。如果我们继续用机械工业来做比较（对于再次回到这个话题，我感到抱歉，这肯定来源于我在机械系统方面的学术背景），这意味着一个标准的行业级应用在复杂性上更接近商用飞机，而不是标准汽车。难怪它在其生命周期内需要升级和调整，就像客机需要重型维护一样。困难之处在于，大多数应用的设计方式并不像我们预期的那样模块化，意外的依赖性经常发生，使得应用作为一个统一的实体运行。如果你拿一款“拉法尔”战斗机来说，由于整个飞机都是按照这个限制来设计的，两个机械师可以在几小时内更换发动机。那么你的ERP软件呢？你能在几小时内切换授权引擎吗？当然不可能...这就是为什么大多数软件应用都有有限的预期寿命：经过多次版本升级后，整体质量总是下降，随着时间的推移，应用对业务的适应性也越来越差。当然，有些应用可以持续超过10年，有时甚至20年或更久。但如果你问用户，原因是不是因为软件完美无缺，他们是否喜欢它，你总是会得到同样的答案：这块软件之所以还在这里，仅仅是因为尝试移除它太过危险了！
- en: 'The second kind of impact of time on information systems is not on the software
    part but due to the business itself. As stated at the very beginning of this chapter,
    information systems are live entities, and they evolve continuously because business
    itself evolves. New strategies, regulation changes, large company reorganizations,
    fusion with an acquired company, selling of a business unit, and so on – there
    are so many factors that can move around the uses of the information systems that
    there is almost no way that they can remain stable for a long time, even in very
    stable business domains. In addition, on top of law-related regulations, many
    business rules are specific to companies and this makes it hard to produce applications
    that can truly pretend to reach the “one size fits all” state. Even with the best
    intention to keep things simple, companies often end up tweaking the software
    applications they bought, or integrating them with dedicated connectors or custom
    code, for them to comply with their way of doing business, simply because it costs
    less (at least at first) to do so, rather than reorganizing the corresponding
    function. But this is a trap and is where time comes into the game again: as time
    goes by, this specificity will cost more and more. First, every new major version
    of the application may make it fail, and money will be spent on keeping the specific
    code compatible with the new version. Most of the time, this was not fully budgeted,
    which means the overall cost grows and grows in time, sometimes ending up costing
    much more than initially adjusting the processes to the software. There is also
    a part of psychology in it: functional experts would feel bad adjusting their
    way of doing simply because some piece of code from an external editor thinks
    it is better to do it another way. What do they know about their job?'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间对信息系统的影响的第二种类型并非来自软件部分，而是由于商业本身。正如本章开头所述，信息系统是活跃的实体，并且由于商业本身的演变而持续发展。新的战略、法规变化、大型公司重组、与被收购公司的融合、出售业务单元等等——有如此多的因素可以影响信息系统的使用，以至于它们几乎不可能长时间保持稳定，即使在非常稳定的商业领域也是如此。此外，在法律相关法规之上，许多商业规则是特定于公司的，这使得难以开发出真正能够达到“适合所有情况”状态的应用程序。即使有最好的意图保持事情简单，公司往往最终会调整他们购买的软件应用，或者通过专用连接器或定制代码将它们集成，以符合他们的业务方式，这仅仅是因为这样做成本更低（至少最初是这样），而不是重新组织相应的功能。但这是一种陷阱，也是时间再次介入游戏的地方：随着时间的推移，这种特定性将变得越来越昂贵。首先，每个新的主要版本的应用程序可能会使其失败，并且需要花费金钱来保持特定代码与新版本兼容。大多数情况下，这并没有完全预算，这意味着随着时间的推移，整体成本会不断增长，有时最终会花费比最初调整流程到软件上更多的钱。其中也有一部分心理学因素：功能专家会因为外部编辑的一些代码认为另一种方式更好而感到不高兴去调整他们的工作方式。他们对自己的工作了解多少呢？
- en: 'The third link to time in information systems is neither on software nor on
    functions, but on how the software is adapted to the business functions. This
    can be done through integration, customization, adjustment of application parameters,
    adapting the way the application interoperates with other parts of the software,
    and more. The link to time is a bit more subtle here, but all these ways remain
    mostly specialists’ jobs. And since experts are rare, it is very common that this
    step in a software project takes more time than accounted for. Changing a parameter
    is quick but analyzing all possible impacts in a complex system needs a good understanding
    of it (we talked about the need for a map of the information system in [*Chapter
    3*](B21293_03.xhtml#_idTextAnchor069)) and can take a lot of time. This is one
    of the reasons why ERP projects – a well-known example – take so much time in
    a company (despite everything a commercial can tell you about it, there is no
    way in practice to reduce this time below 6 months at the very least). Another
    consequence of this is vendor lock-in: as more and more parameters get changed
    from their default values, as more and more connectors or integrations are added
    to the system, it becomes more and more difficult to change the software for other
    vendors. After a given amount of time, the application is so engrained in the
    system data streams that customizing a new application would take a huge effort
    (particularly since documentation is not the best asset of these projects), hence
    the stopped evolution of some IT capabilities.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息系统中与时间相关的第三个联系既不在软件也不在功能上，而是在于软件如何适应业务功能。这可以通过集成、定制、调整应用程序参数、调整应用程序与其他软件部分交互的方式以及更多方式来实现。这里的联系稍微微妙一些，但所有这些方式基本上仍然是专家的工作。由于专家很少见，所以在软件项目的这个步骤中花费的时间往往比预期的要多。更改参数很快，但在一个复杂系统中分析所有可能的影响需要对其有很好的理解（我们在[*第三章*](B21293_03.xhtml#_idTextAnchor069)中讨论了信息系统的地图需求）并且可能需要花费大量时间。这就是为什么ERP项目——一个众所周知的例子——在一家公司中花费了如此多的时间（尽管销售人员可能会告诉你关于它的所有事情，但在实践中，至少无法将其时间缩短到6个月以下）。这个后果的另一个结果是供应商锁定：随着越来越多的参数从默认值更改，随着越来越多的连接器或集成被添加到系统中，更改软件以适应其他供应商变得越来越困难。在一段时间后，应用程序已经深深嵌入到系统数据流中，定制新的应用程序将需要巨大的努力（尤其是由于文档不是这些项目的最佳资产），因此一些IT能力的发展停滞了。
- en: All these have the consequence that the company using the information system
    is, in a way, dispossessed from its business processes as there are so many ways
    IT stands in the way and can prevent rapid evolution. Sure, IT helps automate
    processes and, once set in place, can provide interesting gains. But the effort
    to make it work – and in particular to keep it working in time – might not make
    it very interesting (remember the Gartner statistics showing that 70% of the IT
    budget goes into maintenance alone!)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些后果都意味着使用信息系统的公司在某种程度上失去了其业务流程，因为IT以如此多的方式阻碍了发展，并可能阻止快速演变。当然，IT有助于自动化流程，一旦实施，可以提供有趣的收益。但使其工作并保持其按时间工作所需的努力可能并不那么有趣（记住Gartner的统计数据，显示70%的IT预算仅用于维护！）
- en: Finally, **technical debt** is also a concept that is strongly associated with
    time passing by. As it turns out, it is very much like entropy and tends to always
    grow with time. But this one is so important that we will analyze it in its very
    own section later in this chapter. For now, we are going to look at how Agile
    practices can help us deal with time.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**技术债务**也是一个与时间流逝紧密相关的概念。实际上，它非常类似于熵，并且倾向于随着时间的推移而不断增长。但这个概念非常重要，所以我们将在本章稍后的单独部分对其进行分析。现在，我们将探讨敏捷实践如何帮助我们处理时间问题。
- en: How the Agile approach aims at solving the time problem
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敏捷方法旨在解决时间问题的方法
- en: Agile has lots to do with time management, so it may help us deal with the time
    issues around information systems. To explain how, we will go back to what Agile
    is and then observe different ways it can solve the time-based complexity we need
    to tame.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷与时间管理有很大关系，因此它可能有助于我们处理信息系统周围的时间问题。为了解释这一点，我们将回到敏捷是什么，然后观察它以解决我们需要驯服的时间复杂性的不同方式。
- en: A metaphor to explain Agile
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释敏捷的隐喻
- en: '**Agile** is about taking the time factor into account. In a V-cycle development
    process, everything is planned and time passing by is only supposed to make things
    go forward in the process. The Agile approach recognizes that time is itself a
    factor in the project, and it appears everywhere:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**敏捷**是关于考虑时间因素的。在V周期开发过程中，一切都被规划好，随着时间的推移，事情应该只会在流程中向前推进。敏捷方法认识到时间本身就是项目的一个因素，它无处不在：'
- en: There is time negotiation because quality should not be compromised, and adding
    resources does not make a software project get quicker (“five cooks do not bake
    a cake in 10 minutes instead of 50”). So, the only way to adjust to hazards is
    to increase the time or reduce the functional scope (which comes back again to
    increasing time if the client still wants the complete initially-requested perimeter
    to be realized by the end of the project).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于质量不容妥协，增加资源并不能让软件项目更快完成（“五个厨师不可能在10分钟内而不是50分钟内烤好一个蛋糕”），因此，调整风险的唯一方法就是增加时间或减少功能范围（如果客户仍然希望最初请求的完整范围在项目结束时实现，这又回到了增加时间的问题）。
- en: 'Time is one of the major decisions in organizing an Agile project: how long
    should the sprints be if you work with Agile? What cadence should be used if you
    use a Kanban approach? At what frequency should we organize stabilization sprints?
    How quick should continuous integration be to be efficient? How sustainable in
    time is the rhythm used by the team?'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间是组织敏捷项目时的一个主要决策：如果你使用敏捷工作，冲刺应该有多长？如果你使用看板方法，应该使用什么节奏？我们应该以多高的频率组织稳定冲刺？持续集成应该有多快才能有效？团队使用的时间节奏有多可持续？
- en: Filling a sprint is a negotiation around time available, and how estimates of
    time to be taken by backlog tasks should be done and added up to fill the sprint.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充冲刺是对可用时间的谈判，以及如何估算待办事项所需的时间，并将其加起来以填充冲刺。
- en: 'One of the best metaphors I have found to explain Agile software development
    to my customers or students also talks very much about time. The idea is to compare
    two ways of shooting an arrow at a target: the usual way is to aim at the target,
    carefully accounting for the wind and the distance to the target and, when everything
    is fine, shooting the arrow and hoping there will not be a sudden gust of wind,
    that we have estimated correctly the angle, and more. Guess what? If the target
    is far enough, hitting the bull’s eye is pretty much a question of luck, in these
    conditions. This is what the V-cycle is about: carefully planning for the project
    development in time, considering as many initial conditions as possible, and eventually
    launching the project, hoping that nothing will get it out of target... Sadly,
    there will always be external changes in conditions, customers changing their
    minds, a team being sick, an important dependency not being released on time,
    and so on.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我找到的最好的比喻之一，用来向我的客户或学生解释敏捷软件开发，也谈到了很多关于时间的内容。这个想法是将两种射箭的方式进行比较：通常的方式是瞄准目标，仔细考虑风力和目标距离，当一切准备就绪时，射箭并希望不会突然刮起一阵风，我们估计的角度是正确的，等等。猜猜看？如果目标足够远，在这些条件下命中靶心几乎就是一个运气的问题。这就是V周期的内容：在时间上仔细规划项目开发，尽可能考虑初始条件，最终启动项目，希望一切不会偏离目标……遗憾的是，总会有外部条件的变化，客户改变主意，团队生病，重要的依赖项没有按时发布，等等。
- en: 'Meet the Agile way to hit the bull’s eye at every shot, or at least with a
    considerably higher probability: you must take the arrow in your hand, walk to
    the target against the changing winds, correct your path if the target moves,
    and eventually plant the arrow in the target when you’re close enough. Sure, walking
    to the target with an arrow in your hand takes way longer than the flight of the
    arrow once it’s been shot. But are you sure it is going to take longer than hitting
    many arrows in the wind to eventually have one reaching the target, not even in
    the middle? The difference lies in the conditions of the project. If everything
    is stable, no external dependencies are there, and you are in a fully controlled
    context, maybe planning everything in advance will be a bit quicker than adjusting
    step by step. However, the vast majority of software projects do not belong to
    this utopic situation. Most of them are developed in extremely changing contexts,
    with hazards everywhere.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以敏捷的方式射击每一枪都能命中靶心，或者至少有相当高的概率：你必须握住手中的箭，逆风走向靶心，如果靶心移动，就纠正你的路径，最终在你足够接近时将箭射入靶心。当然，手里拿着箭走向靶心比箭射出后的飞行时间要长得多。但你确定这会比在风中射出多支箭，最终有一支射中靶心，哪怕不是正中心吗？区别在于项目的条件。如果一切都很稳定，没有外部依赖，并且你处于完全受控的环境中，那么提前规划一切可能比逐步调整要快一些。然而，绝大多数软件项目并不属于这种乌托邦式的情境。大多数项目都是在极其变化的环境中开发的，到处都是危险。
- en: Back to the concept of emerging architecture
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到涌现架构的概念
- en: In [*Chapter 3*](B21293_03.xhtml#_idTextAnchor069), emerging code architecture
    was quickly cited and I said we would come back to this. Now is the right moment
    to do so. Since we talked about Agile development and we are in the middle of
    a discussion about time, let’s look at two things that are closely related to
    emerging architecture. This concept is about achieving a good architecture **without
    aiming at it in advance, with schemas and plans**, by refining the architecture
    along the development of a software project and refactoring the code structure
    at every step of iterative development. Without aiming at it in advance... does
    this remind you of something? This is the metaphor we used previously to explain
    the Agile approach to hit the target of a software project. Again, time is the
    concept that allows us to reach an agreement between architecture (in its meaning
    of structuring in advance) and the impossibility of knowing a complex business
    domain before working with it (thus needing to advance with the arrow in your
    hand and readjusting the path). This opposition and its resolution are so important
    that they need a dedicated section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B21293_03.xhtml#_idTextAnchor069)中，我迅速提到了涌现代码架构，并说我将回过头来讨论这个话题。现在正是时候。既然我们讨论了敏捷开发，而且我们正处于关于时间的讨论中，让我们看看与涌现架构密切相关的东西。这个概念是关于在没有提前瞄准架构、没有模式和计划的情况下实现良好的架构，通过在软件项目的发展过程中细化架构，并在迭代开发的每一步中重构代码结构。没有提前瞄准……这让你想起了什么？这是我们之前用来解释敏捷方法达到软件项目目标的隐喻。再次强调，时间是允许我们在架构（其意义为提前结构化）和在工作之前无法了解复杂业务领域的不可能性之间达成协议的概念。这种对立及其解决方法如此重要，以至于需要一个专门的章节。
- en: Apparent opposition between architecture and Agile methods
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构与敏捷方法之间的明显对立
- en: A decade ago, when I started understanding the principles of Agile software
    and applying them to the technical team I was leading, it was hard for me to understand
    why a typical Scrum team would be developers, testers, a product owner, and a
    Scrum master. How come there was no architect in there? As it was my business
    card title at this time, I took it personally. This was a bit disturbing since,
    at the same time, I was realizing the huge value Agile had compared to the old
    way we were using by then.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 十年前，当我开始理解敏捷软件的原则并将它们应用到我所带领的技术团队中时，我很难理解为什么一个典型的Scrum团队会包括开发者、测试员、产品负责人和Scrum大师。为什么没有架构师呢？因为那时我的名片上写着这个头衔，所以我对此感到个人受到了打击。这有点令人不安，因为在同一时间，我意识到敏捷与那时我们使用的老方法相比具有巨大的价值。
- en: 'After discussing this with many Agile leaders who brought the concept to France,
    I eventually gave a conference in 2013 specifically on the subject of how to bring
    together architecture and Agile methods (French version: [https://www.infoq.com/fr/presentations/concilier-architecture-et-agilite/](https://www.infoq.com/fr/presentations/concilier-architecture-et-agilite/)).
    After exposing the many contradictions and how an “ivory tower” architect would
    have a hard time in short iterations, I ended up explaining a possible way to
    conciliate the utility of “seeing in advance” and “acting in short iterations
    and adjusting the vision”. Like most patterns, which are not invented but discovered
    independently by many people, this concept of emerging architecture is simply
    the result of any work trying to erase the contradiction stated previously.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在与许多将这一概念带到法国的敏捷领导者讨论之后，我最终在2013年就如何将架构与敏捷方法结合起来进行了专题讲座（法语版本：[https://www.infoq.com/fr/presentations/concilier-architecture-et-agilite/](https://www.infoq.com/fr/presentations/concilier-architecture-et-agilite/))。在揭示了众多矛盾以及“象牙塔”建筑师在短迭代中会遇到的困难之后，我最终解释了一种可能的折衷方法，即如何协调“提前看到”和“在短迭代中行动并调整愿景”的效用。像大多数模式一样，这些模式不是被发明的，而是由许多人独立发现的，这个新兴架构的概念仅仅是任何试图消除之前所述矛盾的任何工作的结果。
- en: 'Again, time is the great equation solver here: **architecture and short iterations
    are not opposed if you set the time horizon of architecture to only a few iterations.**
    This way, the probability that the target moves a lot is strongly reduced, and
    the architecture remains useful because it helps structure the development of
    these few iterations.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，时间在这里是伟大的方程式解算器：**如果你将架构的时间范围设定为只有几个迭代，那么架构和短迭代并不对立**。这样，目标移动很大的可能性会大大降低，架构仍然是有用的，因为它有助于结构化这些少数迭代的开发。
- en: This solves the difficulty for the architect as their job remains necessary,
    even if it changes quite a lot if you consider the job is to think long shots
    ahead. But then again, even before Agile, architects in ivory towers (imagining
    a long time ahead without a grasp of reality and giving plans to the teams...
    that will not follow them) were largely seen as pointless.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了建筑师面临的难题，因为他们的工作仍然是必要的，即使考虑到工作是要提前思考长远，也会有很大的变化。但话又说回来，即使在敏捷方法出现之前，那些在象牙塔中的建筑师（在没有掌握现实的情况下想象很长时间，并向团队提供计划……他们不会遵循的计划）在很大程度上被视为没有意义。
- en: It also helps us understand the concept of emerging architecture, which states
    that, if refactoring is done correctly at the end of each sprint, the final structure
    of the code will be perfectly adequate for the functional needs... just like a
    perfect architectural vision (a long-shot of an arrow in the center of the target,
    in our metaphor) would have done in pure theory (but is practically impossible
    except for very small projects).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它还帮助我们理解新兴架构的概念，该概念指出，如果在每个冲刺结束时正确地进行重构，代码的最终结构将完全适合功能需求……就像完美的建筑愿景（在我们的比喻中，箭头在目标中心的远射）在纯理论中会做到的那样（但除了非常小的项目外，在现实中几乎不可能做到）。
- en: 'In addition to time, semantics also helps remove the contradiction exposed
    previously. The word *architecture* is used in two different ways:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了时间之外，语义学也有助于消除之前暴露的矛盾。*架构*这个词被用于两种不同的方式：
- en: Architecture as *the emerging global shape of a project* is about the structure
    of the code produced by the team
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建筑作为*项目新兴的全球形态*，是关于团队产生的代码结构
- en: Architecture as *the act of envisioning a structure* in the application (or
    even higher, in the information system as a whole) is about trying to reach this
    structured state by initially thinking and acting on the system
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建筑作为*在应用程序中（甚至更高，在整个信息系统）构想结构*的行为，是关于通过最初思考和行动在系统上尝试达到这种结构化状态
- en: This means that this theoretical contradiction can be overcome. But that does
    not mean that there is no practical impact, and I will show you one because it
    will help us go back to the notion of aligning the technical aspects with the
    business ones. But before that, I will add an external analysis.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这种理论上的矛盾可以被克服。但这并不意味着没有实际影响，我会向你展示一个例子，因为它将帮助我们回到将技术方面与业务方面对齐的观念。但在那之前，我将添加一个外部分析。
- en: The position of famous architects
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 著名建筑师的地位
- en: Just like for any scientific discipline, we software architects save a lot of
    time “sitting on the shoulders of giants,” which in our case involves reflecting
    on the state of the art established by real experts of the subject. Martin Fowler
    is certainly one of the best references in software architecture. On this question
    of opposition between “hack, code, and fix” and “big upfront design”, I strongly
    recommend reading the excellent article at [https://www.martinfowler.com/articles/designDead.html](https://www.martinfowler.com/articles/designDead.html).
    The willingly-provocative title *Is Design Dead?* hides the real background subject,
    which is precisely what we’re talking about here.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何科学学科一样，我们软件架构师通过“站在巨人的肩膀上”节省了很多时间，在我们的情况下，这涉及到反思该主题真正专家建立的艺术水平。马丁·福勒无疑是软件架构领域最好的参考资料之一。关于“黑客、编码和修复”与“前期大设计”之间的对立问题，我强烈推荐阅读马丁·福勒在[https://www.martinfowler.com/articles/designDead.html](https://www.martinfowler.com/articles/designDead.html)上发表的优秀文章。标题*设计已死？*虽然挑衅性强，但隐藏的真正背景主题正是我们在这里讨论的。
- en: Martin Fowler’s response to the opposition to architecture is simply to **only
    apply design to increase the capacity of the system to evolve**. As usual, there
    is no “true or false” answer between the two extremes, namely **eXtreme Programming**
    (which explicitly admits its extreme character) and **Big Up Front Design** (which
    often does not admit or even recognize its extreme character and quickly produces
    “ivory tower architects”).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 马丁·福勒对架构的反对意见的回应仅仅是**只应用设计来增加系统演变的能力**。像往常一样，在两个极端之间没有“对或错”的答案，即**极限编程**（它明确承认其极端性）和**前期大设计**（它通常不承认甚至不承认其极端性，并迅速产生“象牙塔架构师”）。
- en: This is where the job of the architect becomes an art as they need to proceed
    with good skills to obtain a subtle balance using some up front design without
    imposing unmovable limits, but still providing healthy guidelines that will truly
    help developers produce faster features *in the long term* (and not get blocked
    by software entropy, as described in Martin Fowler’s article).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是架构师的工作变成一门艺术的地方，因为他们需要运用良好的技能，在不强加不可移动的限制的同时，通过一些前期设计获得微妙的平衡，但仍提供真正有助于开发者长期快速生产功能的健康指导（而不是像马丁·福勒文章中描述的那样，被软件熵所阻碍）。
- en: 'Since, in addition, change is the only constant in software development, there
    is no use in writing what will be out of target due to functional changes in advance,
    but that does not mean the architect’s job is removed: on the contrary, it is
    about **easing the evolutions in the future**. Architecture is not about UML or
    code frameworks but about guidelines on the way the system should be structured:
    what are its fixed points, what are the articulations around which it moves; where
    should we focus on quality, where can we afford disposable code since the business
    evolves so quickly that investing on solidity is pointless? Sometimes, heavy architecture
    efforts can be justified precisely to accommodate an important module to change
    very frequently. This is, for example, the case of using a **business rules management
    system** (we will come back to this in more detail in [*Chapter 5*](B21293_05.xhtml#_idTextAnchor164)).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于，在软件开发中，变化是唯一的不变因素，因此提前编写因功能变化而可能过时的内容是没有用的，但这并不意味着架构师的工作被取消了：相反，这是关于**简化未来的演变**。架构不是关于UML或代码框架，而是关于系统应该如何构建的指导方针：它的固定点是什么，它围绕哪些关节转动；我们应该在哪里关注质量，在哪里可以承担可丢弃的代码，因为业务发展如此迅速，投资于稳定性是没有意义的？有时，大量的架构努力正是为了适应一个需要频繁变更的重要模块。例如，使用**业务规则管理系统**（我们将在第5章中更详细地讨论这一点）。
- en: 'The same applies to coding patterns: the mere fact of working correctly, and
    refactorizing your code continuously, will naturally bring patterns in your code,
    even if you did not know them in advance (I told you that craftsmanship was not
    dead!). An excellent bit of evidence of this, if you have not experienced it already
    by yourself in a coding activity, is that, when you read a lot of code (which
    very few people like to do, even though most great writers have been hungry readers
    beforehand) or when you follow groups of students, you will realize that these
    patterns are often discovered anew. This is the very definition of patterns since
    they are universal and, however, they’re found, if you structure your code correctly,
    the context will make you end up using the right pattern for this precise problem.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的情况也适用于编码模式：仅仅因为代码能够正确运行，并且持续不断地重构你的代码，自然会形成代码中的模式，即使你事先并不知道这些模式（我告诉你了，工艺并没有消亡！）。如果你还没有在编码活动中亲身体验过这一点，那么一个很好的证据是，当你阅读大量的代码（尽管很少有人喜欢这样做，尽管大多数伟大的作家在成为作家之前都是饥渴的读者）或者当你跟随一群学生时，你会意识到这些模式经常被重新发现。这正是模式的定义，因为它们是普遍的，无论它们是如何被发现的，只要你正确地组织你的代码，上下文就会让你最终使用正确的模式来解决这个具体问题。
- en: Thinking ahead with function contracts
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提前思考函数合约
- en: 'Previously, I talked about a practical example to illustrate the opposition
    on long-term and emerging architecture that we talked about before letting the
    expert (Martin Fowler) speak. The example I am talking about comes from my own
    professional experience and is a diagram I have created for a complex scenario
    of interoperation between several applications to implement a functional process.
    When analyzing the business needs at the beginning of the project (or rather their
    initial expression, because they change alongside the project), I created the
    following stream diagram:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前，我谈到了一个实际例子来阐述我们之前讨论过的长期架构和新兴架构之间的对立，让专家（马丁·福勒）发言。我提到的例子来自我的个人专业经验，是为实现功能流程的几个应用程序之间的复杂互操作场景而创建的图表。在项目开始时分析业务需求（或者更确切地说，是它们的初始表达，因为它们随着项目的发展而变化），我创建了以下流图：
- en: '![Figure 4.1 – Example of a data stream](img/B21293_04_1.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 数据流示例](img/B21293_04_1.jpg)'
- en: Figure 4.1 – Example of a data stream
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 数据流示例
- en: Following [*Chapter 3*](B21293_03.xhtml#_idTextAnchor069), you should normally
    recognize the duality between the function and the software implementation, and
    in particular, the essential recommendations that dependencies should point to
    level 2 instead of directly to level 3, which would result in point-to-point interoperation,
    creating a “hard coupling” of software solutions (we will come back to this expression
    shortly if you do not know what it means).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[*第 3 章*](B21293_03.xhtml#_idTextAnchor069)，你应该通常能够认识到函数和软件实现之间的双重性，特别是关于依赖关系应该指向第
    2 层而不是直接指向第 3 层的基本建议，这将导致点对点互操作，从而创建软件解决方案的“硬耦合”（如果你不知道这个表达式的意思，我们很快就会回到这个话题）。
- en: Even if we use machine symbols, the bottom layer is really about software servers,
    hence layer 3\. The intermediate zone is also part of the software layer as it
    contains connectors destined to transform API calls into proprietary calls if
    needed. The orchestration layer at the top shows how functional tasks expressed
    by API contracts are put together to create fine-grained processes. It can mostly
    be considered as layer 2 in the CIGREF map, with some touches of layer 1.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用机器符号，底层实际上还是关于软件服务器，因此是第 3 层。中间区域也是软件层的一部分，因为它包含将 API 调用转换为专有调用的连接器，如果需要的话。顶层的编排层显示了由
    API 合约表达的功能任务是如何组合起来创建细粒度过程的。它基本上可以被认为是 CIGREF 图中的第 2 层，带有一些第 1 层的触感。
- en: 'The reason I’m showing this schema is twofold. First, it illustrates when architecture
    goes too far and how emerging architecture can help save time: I drew this when
    I was a young architect, not fully aware of the concept of emerging architecture
    and it went too far. Sure, it helped to have a project vision, but in the end,
    almost none of the connectors and data streams worked the way I envisioned they
    would and time was wasted there.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我展示这个架构的原因有两个。首先，它说明了当架构走得太远时会发生什么，以及新兴架构如何有助于节省时间：我是在我还是一个年轻的建筑师时画的，当时并不完全了解新兴架构的概念，所以它走得太远了。当然，有一个项目愿景是有帮助的，但最终，几乎所有的连接器和数据流都没有按照我预想的方式工作，时间在这里被浪费了。
- en: Secondly, this schema provides more detail on the interaction between layers
    2 and 3 of the CIGREF map, showing they are about API contracts (and we are not
    talking about API implementations with code, just contracts, which are lists of
    functional capabilities expressed in precise, technical terms). This is where
    it becomes particularly interesting because, despite the technical implementation
    not being (at all) the one envisioned and despite the orchestration of the streams
    having changed many times since the original blueprint, **it turned out the API
    contracts have remained unchanged for** **many years.**
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这个架构提供了关于CIGREF地图第2层和第3层之间交互的更多细节，表明它们是关于API合同（我们不是在谈论带有代码的API实现，而是在谈论合同，即用精确的技术术语表达的功能能力的列表）。这尤其有趣，因为尽管技术实现并不是（完全）预期的，而且自从原始蓝图以来，流编排已经改变了很多次，**但结果却是API合同在**
    **很多年里都没有变化**。
- en: I cannot tell you how much satisfaction it has brought me to realize this a
    few years after the project. When thinking about the code, my initial vision was
    a failure and a very small portion of it had been implemented. When thinking about
    orchestration, the way the APIs are glued together has changed due to modifications
    in the processes and the business rules. But the API contracts I designed with
    the business-knowledgeable people were still there years after, basically unchanged,
    and their extreme alignment with the business had allowed all these changes to
    happen with very limited impact in code or customization.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法告诉你，在项目几年后意识到这一点给我带来了多大的满足感。当思考代码时，我的最初愿景是失败的，其中只有一小部分得到了实施。当思考编排时，由于流程和业务规则的变化，API的粘合方式已经改变。但与业务知识人士设计的API合同在几年后仍然存在，基本上没有变化，并且它们与业务的极端一致性使得所有这些变化在代码或定制中产生了非常有限的影响。
- en: In short, code architecture should be limited to a few iterations. But business
    alignment architecture is an investment worth doing, even at the very beginning
    of the project, because its value will not decay.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，代码架构应该限制在几次迭代之内。但业务一致性架构是一项值得在项目初期就进行的投资，因为它的价值不会衰减。
- en: 'This is why contract-first API design (again, I am not talking about API implementation,
    but solely the definition of the contract) is so important: the contracts can
    be established with pure functional knowledge, leaving every technical aspect
    outside, thus ensuring a very stable base for the definition of business modules
    and their dependencies that will serve as a strong foundation for the software
    implementations to come afterward.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么先合同后API设计（再次强调，我说的不是API实现，而是仅仅定义合同）如此重要的原因：可以通过纯粹的功能知识建立合同，将每个技术方面都排除在外，从而确保定义业务模块及其依赖关系的基础非常稳定，这将作为软件实现后续的强大基础。
- en: We will come back to this notion of contract-first thinking in *Chapters 8*
    and *9* but for now, please just keep in mind that the time horizon has an impact
    on architecture in its two meanings. For technical architecture, the time horizon
    should be limited for “the arrow to reach the target.” But for the functional
    architecture, the time horizon does not stand any limit because in this case,
    what we are doing is getting to know where the target is. This is a prerequisite
    at even just thinking of hitting it!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第8章和第9章回到“先合同后思考”这一概念，但在此，请记住时间范围对架构在两个意义上都有影响。对于技术架构，时间范围应该是有限的，以便“箭头能够达到目标。”但对于功能架构，时间范围没有限制，因为在这种情况下，我们所做的是了解目标在哪里。这是即使仅仅想到要击中它也是必须满足的前提！
- en: The concept of technical debt
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术债务的概念
- en: Technical debt may be one of the most discussed concepts related to IT management
    in the past decade. As the quality of software is a fundamental goal of this book,
    it is something we have to clearly describe.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务可能是过去十年与IT管理最相关的讨论概念之一。作为本书的基本目标之一，软件质量是我们必须清楚地描述的内容。
- en: The general definition of technical debt
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术债务的一般定义
- en: If you are reading this book, you are certainly interested in software quality
    and how to architect things correctly, so you most certainly have a good grasp
    of the concept of technical debt, or at least have been exposed to it. Nonetheless,
    I will give a quick definition of it so that you can try and formalize it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这本书，你肯定对软件质量和如何正确构建事物感兴趣，因此你肯定对技术债务的概念有很好的理解，或者至少已经接触过它。尽管如此，我仍会给出一个快速的定义，以便你可以尝试将其形式化。
- en: What is technical debt?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务是什么？
- en: Technical debt is the amount of accidental complexity you have allowed to enter
    your project, together with its increase in intrinsic complexity.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务是你允许进入项目的意外复杂性及其内在复杂性的增加。
- en: 'Let’s decompose this a little. When you develop a software project, it always
    aims at producing a function on a given business domain perimeter. There is an
    inner, definite, stable complexity that comes from the domain you are trying to
    address: it is much simpler to print an address on an envelope than to optimize
    the flights for an international airport.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微分解一下。当你开发一个软件项目时，它总是旨在在给定的业务领域范围内产生一个功能。有一个内在的、确定的、稳定的复杂性，来自于你试图解决的领域：在信封上打印地址比优化国际机场的航班要简单得多。
- en: '*Or is it? Just as a side note, take great care to always know exactly what
    we are talking about when business needs are expressed, and if you cannot, do
    not hesitate to formulate caveats about what can and will be done. Explaining
    the functional needs with a simple sentence does not necessarily mean that the
    objective is itself simple, and much can be hidden behind this. In this example,
    you should immediately have the reflex of asking how the addresses should be printed,
    if there are different envelope formats to support it, what the international
    address is, if there are some norms and standards to respect, how the data will
    be provided, and* *so on...*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*或者不是吗？作为一个旁注，请务必始终确切地知道我们在谈论什么，当业务需求被表达出来时，如果你不确定，不要犹豫，提出关于可以做什么和将要做什么的保留意见。用一句话简单地解释功能需求并不一定意味着目标本身很简单，而且可能隐藏着很多内容。在这个例子中，你应该立即产生一种反射，询问地址应该如何打印，如果支持不同的信封格式，国际地址是什么，如果有一些规范和标准需要遵守，数据将如何提供，等等...*'
- en: 'This first type of complexity is often called **intrinsic complexity** because
    it comes with the functional business domain you want to address and there is
    no way to escape it. Short of doing less than your client expects, there is no
    way you can reduce this. This does not mean you should take all this complexity
    right away: remember the Agile approach to cutting projects into small, manageable
    chunks that will be dealt with one at a time (“How do you eat an elephant? One
    bite at a time”). And if your customer wants you to go all the way to treat the
    complete business domain function and complexity, you will simply add as many
    sprints as needed to reach the desired level of intrinsic complexity. It will
    only take longer and, thus, be more expensive.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种第一种复杂性通常被称为**内在复杂性**，因为它伴随着你想要解决的功能业务领域，而且无法逃避。除非你做得少于客户期望，否则你无法减少这种复杂性。这并不意味着你应该立即接受所有这些复杂性：记住敏捷方法将项目切割成小块，一次处理一块（“你是怎么吃大象的？一口一口吃”）。如果你的客户希望你处理完整的业务领域功能和复杂性，你只需添加所需数量的冲刺以达到所需的内在复杂性水平。这只会花费更长的时间，因此成本更高。
- en: 'Now, let’s cover the second type of complexity: the accidental one. For this,
    let’s take the first example of expressed functional need, namely printing addresses
    on envelopes. To keep this short, suppose we only have to print standard addresses
    with four lines on a standard A5 format envelope, that the data for the addresses
    is provided in any format we want, and that the hardware part (a special printer
    for envelopes) is taken care of. How could we, as developers, implement this requested
    function?'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈第二种复杂性：意外复杂性。为此，让我们以第一个表达的功能需求为例，即打印信封上的地址。为了使内容简短，假设我们只需要在标准A5格式信封上打印四行标准地址，地址数据以我们想要的任何格式提供，并且硬件部分（用于信封的特殊打印机）由其他人负责。作为开发者，我们如何实现这个请求的功能？
- en: One of the simplest ways that comes to mind is to use the fusion function of
    an Office Word application, consuming the XML data from the integrated assistant,
    and saving the file for future uses by the client.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 想到的最简单的方法之一是使用 Office Word 应用程序的融合功能，从集成助手消耗 XML 数据，并保存文件供客户未来使用。
- en: But there is (way!) more than one way to implement a function with software
    and you may very well find yourself using a Java application that has been created
    from scratch to read addresses from any format, create a PDF document, and send
    it to the printer. It is not that complicated, but there are already more moving
    parts than in the first technical solution... and their maintenance is yours,
    instead of the Office editor’s! You will have to take care of the Java runtime
    with a version compatibility issue. The PDF generation can be a little tricky
    too. And maybe the developers will have left a few TODOs in the code, indicating
    that some corner cases need to be solved in the future. In the end, though not
    extremely complicated, this solution is more technically complex than the first
    one we proposed, though it reaches the same objectives in functional terms.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 但实现一个函数的方法（方式！）不止一种，你可能会发现自己正在使用一个从头开始创建的Java应用程序来读取任何格式的地址、创建PDF文档并将其发送到打印机。这并不复杂，但已经有比第一个技术解决方案更多的移动部件...而且它们的维护是你的责任，而不是办公室编辑的责任！你将不得不处理Java运行时的版本兼容性问题。PDF生成也可能有点棘手。也许开发者会在代码中留下一些TODO，表明一些边缘情况需要在将来解决。最终，尽管不是极其复杂，但这个解决方案在技术复杂度上比我们最初提出的方案要复杂，尽管它在功能上达到了相同的目标。
- en: 'The delta is what we call accidental complexity in that this is the complexity
    that – contrary to the functional one – could have been avoided. It is sometimes
    confused with technical complexity, but this is not the right wording. There will
    always be some kind of technical complexity to implement a function: concrete
    execution cannot come from nowhere and there must be some kind of software to
    execute a function. Accidental complexity is, as its name suggests, the level
    of technical complexity that sits on top of the minimal necessary effort to implement
    the functional need. Therefore, it is considered an accident because things could
    have been done without it, and it is there because of external, unwanted reasons.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的delta就是所谓的偶然复杂性，因为这是可以避免的复杂性——与功能性复杂性相反。有时人们会将它与技术复杂性混淆，但这并不是正确的说法。实现一个函数总是需要某种技术复杂性：具体的执行不能从无中来，并且必须有一些软件来执行函数。偶然复杂性，正如其名称所暗示的，是建立在实现功能性需求所需的最小必要努力之上的技术复杂度。因此，它被视为一个意外，因为事情本可以不这样做，而且它之所以存在，是因为外部的不愿原因。
- en: Causes of technical debt and its relation to time
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术债务的原因及其与时间的关系
- en: 'What are these unwanted reasons? Well, there are so many of them that it would
    be difficult to list them all: laziness, lack of time to reach the appropriate
    quality, lack of training, the tendency that we all have to use a well-known technology
    rather than one that would be a better fit but would have to been learned first
    (“when all you have is a hammer, every problem looks like a nail”), lack of technical
    watch, with the result that we simply do not know about the mere existence of
    a better way to do things, and more.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不想要的原因是什么？嗯，它们如此之多，以至于很难一一列举：懒惰、没有足够的时间达到适当的质量、缺乏培训、我们都有的倾向，即使用一个众所周知的技术而不是一个更适合但需要首先学习的技术（“当你只有锤子时，每个问题看起来都像钉子”）、缺乏技术监控，结果是我们根本不知道还有更好的做事方式，还有更多。
- en: 'On top of these reasons, there is another one that has a deeper reach, namely
    that most technical experts, deep inside of them, actually *love* complexity.
    I often compare developers to gases (without malice: I am one myself, have been
    for decades, and still fall out in this trap): they will always occupy all the
    space you give them.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些原因之上，还有一个更深层次的原因，即大多数技术专家实际上在内心深处*热爱*复杂性。我经常将开发者比作气体（没有恶意：我自己也是，几十年来都是，而且仍然会陷入这个陷阱）：他们总是会占据你给他们的所有空间。
- en: '*This is another similarity with thermodynamics since I was talking about entropy
    as a metaphor for* *technical debt.*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*这与热力学有另一个相似之处，因为我正在将熵作为* *技术债务* *的隐喻。*'
- en: 'Let me give you a (not so unrealistic) example. Form a million-dollar team
    with software experts, asking them to create a function that calculates the sum
    of two integers, and you have a high probability that none of them proposes to
    simply use `Int32.Add`. They will work under the hypothesis that you know what
    you are doing: since you set up such a great team and budget, you must have elevated
    goals of creating a high-performance function to add integers with virtually no
    limits in size, working in all conditions with predictable outcomes.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你一个（并非完全不切实际）的例子。组建一个由软件专家组成的百万美元团队，要求他们创建一个计算两个整数之和的函数，你几乎可以肯定，没有人会提议简单地使用`Int32.Add`。他们会在假设你知道自己在做什么的情况下工作：既然你组建了如此庞大的团队和预算，你肯定有更高的目标，即创建一个高性能的函数，以几乎无限制的大小添加整数，在所有条件下都能产生可预测的结果。
- en: This is because developers are engineers and rarely business people. If they
    were, the first one you contacted in the team would tell you that you need no
    other hire and that they will take the whole job by themselves for only half the
    million dollars. Following this, they would put together a complex piece of machinery
    that simply calls `Int32.Add`, makes you wait for a few months to hide the extreme
    simplicity of it, and delivers the end product to you afterward.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为开发者是工程师，很少是商人。如果他们是，团队中第一个联系的人会告诉你，你不需要其他雇佣人员，他们会自己承担整个工作，只需要五十万美元。接下来，他们会组装一个复杂的机器，它只是调用`Int32.Add`，让你等待几个月来隐藏它的极端简单性，然后之后将最终产品交付给你。
- en: One of the key findings is to always give some boundary constraints to your
    developer teams; otherwise, they will add accidental complexity, sometimes even
    a large amount of it... and it is always a pain to know your best customer’s business
    process is blocked by a bug in a function that was added “in case we need it in
    the future” by an overzealous developer.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键发现是始终给你的开发团队提供一些边界约束；否则，他们可能会添加意外的复杂性，有时甚至数量很大...而且总是很痛苦地知道你最好的客户业务流程被一个添加的“以防万一我们将来需要它”的过度热情的开发者引入的函数中的错误所阻塞。
- en: This first set of reasons for technical debt is quite critical of the developers
    but wait – there’s something to say about functional people too!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务的第一个原因对开发者来说非常关键，但等等——我们还得谈谈功能人员！
- en: 'How about laziness in explaining the precise need? Lack of communication with
    the developers? Extreme reliance on them to figure out the technical complexity
    (previously, I talked about the danger of a one-sentence business needing expression:
    it often hides a lack of understanding by the requester itself)? Lack of availability
    to test the results and adjust the functional request? The list could go on, as
    well as picking on our beloved product owners. It is not because they are not
    technical themselves that functional actors cannot cause accidental complexity!'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 解释精确需求时的懒惰？与开发者的沟通不足？过度依赖他们来理解技术复杂性（之前，我谈到了一句业务需求的危险：它往往隐藏了请求者本身对需求的理解不足）？无法测试结果并调整功能需求？这个清单可以继续下去，还可以挑剔我们心爱的产品负责人。并不是因为他们自己不是技术人员，功能人员就不能造成意外的复杂性！
- en: 'All these changes in the functional definition of what should be done have
    a huge toll on technical implementations: we do not change code like we change
    a wheel on a car! There are links between the functions, and the overall complexity
    of code escapes the human brain’s capacity after a few lines only. So, if indications
    change all the time, the result will undoubtedly be some low-quality code cutting
    corners on quality, full of “temporary” workarounds (who are we kidding? We all
    know they will stay there until the application end of life), `TODO` indications
    for a hypothetical colleague to magically appear later and refactor the dumb incomplete
    code into a marvelous elegant new version, and so on. I am not even talking about
    dead code that will bloat applications forever, simply because the complexity
    – and lack of documentation – just makes it so risky to remove it and create side
    effects...'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些关于应该做什么的功能定义的变化，对技术实现产生了巨大的影响：我们改变代码的方式，就像更换汽车上的轮胎一样！函数之间存在联系，代码的整体复杂性在几行之后就会超出人类大脑的处理能力。因此，如果指示总是变化，结果无疑将是质量低劣的代码，为了节省时间而牺牲质量，充满了“临时”的解决方案（谁在骗谁？我们都知道它们会一直存在，直到应用程序的生命周期结束），为假设的同事留下`TODO`指示，以便神奇地出现并重构那些愚蠢的不完整代码成为美妙优雅的新版本，等等。我甚至没有提到那些将永远膨胀应用程序的无效代码，仅仅因为复杂性——以及缺乏文档——使得删除它并产生副作用的风险如此之大...
- en: Technical debt’s relation to time
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术债务与时间的关系
- en: 'Why, why, why is there so much junk code in today’s software industry? Well...
    time, again. Technical debt is another concept that’s strongly related to time.
    Try to operate a root cause analysis on the aforementioned symptoms and, after
    a few consecutive “whys,” you will almost always reach the same answer: “not enough
    time.” Lack of junior training? We do not have the time. Lack of product owner
    availability? They do not have the time. Absence of documentation? We do not have
    the time...'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么，为什么，为什么今天的软件行业中会有这么多垃圾代码？嗯...又是时间。技术债务是另一个与时间密切相关概念。尝试对上述症状进行根本原因分析，经过几个连续的“为什么”，你几乎总是会得到同一个答案：“时间不足。”缺乏初级培训？我们没有时间。缺乏产品所有者的可用性？他们没有时间。缺乏文档？我们没有时间...
- en: 'Time also appears in another way in technical debt: as mentioned previously,
    technical debt, like entropy, always grows. And like entropy, there may be some
    special places where disorder is locally reducing, but this is always by consuming
    energy and growing disorder in other places, which makes entropy grow in the whole
    system.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 时间以另一种方式出现在技术债务中：如前所述，技术债务，就像熵一样，总是增长的。而且，就像熵一样，可能会有一些特殊的地方，局部上的无序正在减少，但这总是通过消耗能量并在其他地方增加无序来实现的，这使得整个系统的熵增长。
- en: Technical debt is the reason why there is such a small portion of software applications
    that can still run fine after more than a decade. Casual observers may think this
    is because software is a world of fast changes, but when you think of it, change
    is not that quick. Java was the thing of the 90s, .NET came a decade later, the
    2010s saw the use of JavaScript rise to things it was not made for, and the 2020s
    marked a few attempts at new languages with none marking its time for now – not
    such a tremendous rate of change... So, why do we change software so quickly?
    Simply because they are so full of technical debt we cannot maintain them in a
    costly manner anymore!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务是为什么在超过十年后仍然可以正常运行的应用软件如此之少的原因。旁观者可能会认为这是因为软件是一个快速变化的领域，但当你仔细想想，变化并不那么快。Java是90年代的事情，.NET在十年后出现，2010年代见证了JavaScript在它本不应被用于的地方的使用，2020年代标志着尝试一些新语言，但没有一种语言现在标志着它的时代——变化的速度并不那么快...那么，我们为什么改变软件这么快呢？简单地说，是因为它们充满了技术债务，我们不能再以高昂的成本来维护它们了！
- en: 'This is another link to time that technical debt exposes: as time goes by and
    technical debt grows, the time toll it takes on the project by slowing down development
    goes up. This is why technical debt is called this: just like financial debt,
    you must pay the interest, so long as you keep some borrowed capital. The higher
    the capital borrowed (the depth of your technical debt, which is related to the
    number of times you have been cutting corners in your development process), the
    higher the interest (the additional time it takes to add a feature to your application).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一个技术债务暴露时间的例子：随着时间的推移和技术债务的增长，它对项目造成的开发速度减慢的时间成本也在增加。这就是为什么我们称之为技术债务：就像金融债务一样，只要你还保留一些借来的资本，就必须支付利息。借入的资本越高（你的技术债务深度，这与你在开发过程中多次走捷径的次数有关），利息就越高（向你的应用程序添加功能所需额外的时间）。
- en: And since we’re talking about a linear relationship between the level of debt
    and the time it eats away at software development, that means there is a rate,
    just like in financial loans. Now is a good time to analyze this rate in more
    detail.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们在谈论债务水平与消耗软件开发时间的线性关系，这意味着存在一个比率，就像在金融贷款中一样。现在是一个分析这个比率更详细的好时机。
- en: Debt or usury?
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 债务或高利贷？
- en: 'Many of us make loans, at least once in our lives, to buy a house. And it makes
    sense to pay a few percent of the amount obtained compared to the advantages we
    can draw from them: owning the house at the end of the loan, not paying rent anymore,
    and more. Depending on the economic context (and individual preferences also take
    a great part in the choice), there may be some cases where it is better to rent
    and not buy but, in the longer term, building some capital always wins.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的许多人至少在一生中贷过款，用来买房子。与我们可以从中获得的优点相比，支付所获得金额的一小部分是合理的：贷款结束后拥有房子，不再支付租金，等等。根据经济环境（以及个人偏好在选择中也起着很大作用），可能有些情况下租房而不是买房更好，但从长远来看，积累一些资本总是胜出的。
- en: 'However, this only holds true because the rate is small enough! How comfortable
    would you be if you had to borrow money at a rate of 10%, 20%, or even 50% interest
    per year? In this case, of course, nobody would ever borrow some money as, 2 years
    later only, the loan would have cost as much as the capital: in this case, you
    are way better off holding off your purchase for 2 years and buying cash.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这只有在利率足够小的情况下才成立！如果你必须以每年10%、20%甚至50%的利率借钱，你会感到多么不舒服？在这种情况下，当然，没有人会借钱，因为2年后，贷款的成本就会和本金一样多：在这种情况下，你最好推迟2年购买，用现金支付。
- en: Except there are cases where you cannot do this. Sure, you can rent a place
    to live instead of buying it. But how about when you need money to eat or have
    a temporary shelter because of a hard incident in your life? Without regulation,
    the banks could increase their rates as much as they want, and, in some cases,
    you would be obliged to take the loan anyway because your life depends on it.
    In this situation, you would have to reimburse this when your situation improves,
    but the rate is so high that it would eat up everything you have saved and you
    would end up contracting another loan, in a never-ending poverty loop. This is
    to avoid the situation that, for centuries, banks and even individual actors performing
    financial operations have been limited by governments through what is called the
    **usury rate**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了有些情况下你不能这样做。当然，你可以租房子住而不是买房子。但是，当你需要钱吃饭或因为生活中发生的困难事件需要临时住所时怎么办？如果没有监管，银行可以随心所欲地提高利率，在某些情况下，你可能会被迫贷款，因为你的生活依赖于它。在这种情况下，当你情况改善时，你将不得不偿还这笔贷款，但利率如此之高，以至于它会吞噬你所有的储蓄，你最终会陷入另一个贷款的恶性循环。这是为了避免几个世纪以来，政府和甚至进行金融操作的个体行为者通过所谓的**高利贷利率**受到限制的情况。
- en: If you do not know this financial term, usury refers to lending money at such
    a high rate that it makes it practically impossible to reimburse the capital.
    Society improvement is why it is now illegal in most countries, where maximum
    rates are fixed. For example, in France, at the time of writing, the usury rate
    was 5.33%, which means that banks are not allowed to lend money at a rate higher
    than this value.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不了解这个金融术语，高利贷指的是以如此高的利率贷款，以至于实际上无法偿还本金。社会进步是为什么现在在大多数国家都是非法的，那里的最高利率是固定的。例如，在撰写本文时，法国的高利贷利率为5.33%，这意味着银行不允许以高于这个价值的利率贷款。
- en: 'Now, let’s go back to technical debt and evaluate the rate at which we borrow.
    This isn’t very hard to find since the Gartner study on the cost of maintenance
    in information systems has already been cited twice previously: it is a flabbergasting
    70% of the IT budget! Okay, this does not account for a 70% interest rate in technical
    debt, because you should also count the benefits the IT systems offer the company
    and the cost of doing otherwise. I will let you do the calculation as this can
    vary depending on your organization’s context. But all in all, there’s a chance
    that you will reach a figure that you would, by no means, tolerate from your bank
    on a financial loan, and that will be *way* higher than the usury rate.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到技术债务，并评估我们借款的比率。这并不难找到，因为Gartner关于信息系统维护成本的研究已经被引用过两次：令人震惊的是，占IT预算的70%！好吧，这并不包括技术债务的70%利率，因为你还应该计算IT系统为公司带来的好处以及不这样做带来的成本。我将让你自己计算，因为这会根据你所在组织的具体情况而有所不同。但总的来说，你可能会得到一个数字，这个数字你无论如何都不会容忍从银行获得的金融贷款，而且这个数字将远远高于高利贷利率。
- en: So, why should we tolerate this? Reasons for the situation have already been
    cited previously; now is the time to lay a few solution paths to get rid of excessive
    technical debt. This is what we will do in the coming section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们为什么要容忍这种情况呢？这种情况的原因已经在前文中提到；现在是时候提出一些解决方案，以消除过度的技术债务。这就是我们在下一节将要做的。
- en: Ways to balance technical debt
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术债务的平衡方法
- en: 'People often talk about fighting technical debt or suppressing it. This is
    not the right wording as it bears the meaning that technical debt (and thus accidental
    complexity) should be downed to zero. This sounds like a hard thing to obtain
    as perfection costs a lot of money: in fact, your goal should not be removing
    all technical debt but rather keeping it in control, just like you should not
    try and find a 0% interest rate loan (you never will) but rather find the right
    rate that allows your project to be more cost-effective, balancing the interest
    rate, the amount and duration of the loan, and more.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常谈论与技术债务作斗争或压制它。这种说法并不准确，因为它意味着技术债务（以及因此产生的意外复杂性）应该降至零。这听起来像是一个很难实现的目标，因为完美需要花费很多钱：事实上，你的目标不应该是不再有任何技术债务，而应该是控制它，就像你不应该试图找到一个0%的利率贷款（你永远找不到）而是找到一个合适的利率，这样可以让你的项目更具成本效益，平衡利率、贷款金额和期限等等。
- en: So, a bit of technical debt is acceptable. If you have to roll out this feature
    in time for the yearly seminar with all the customers, who will care that you
    did not put logging in place for the occasion? The only really important part
    is that you have placed a ticket in the development tool and the product owners
    agreed that it will be done in a coming sprint, before putting the feature into
    production. If they come back on their promise and try to delay this “technical”
    ticket and make a fuss about it, remind them of the consequences, send an email
    explaining how this will impact the future, ask for their written agreement of
    responsibility, escalate it to the big boss... whatever it takes to get this feature
    back on track! Otherwise, it will be your responsibility that technical debt starts
    to grow.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一点技术债务是可以接受的。如果你必须按时推出这个功能，以便在年度研讨会上向所有客户展示，谁会在意你当时没有为这次活动设置日志记录呢？真正重要的是，你已经将工单放入开发工具中，并且产品负责人同意在将功能投入生产之前，在即将到来的冲刺中完成它。如果他们违背承诺，试图推迟这个“技术”工单，并对它大吵大闹，提醒他们后果，发送一封电子邮件解释这将如何影响未来，要求他们书面同意承担责任，将其升级给大老板……无论需要做什么，都要确保这个功能回到正轨！否则，技术债务开始增长的责任将是你。
- en: Of course, the best way will always be simply to not let the technical debt
    slip away. Sure, it may sound easier to say than to do, but knowing how the problem
    can arise is already a great step forward. Remember that the mere concept of “technical
    debt” was not known or formalized in the 2000s; now, even non-technical managers
    working in IT or software development may have heard about it. This is already
    a big improvement and lets you make an educated point to them, explaining how
    reduced delays and lack of training or time for documentation and quality will
    end up in slow development in a few months. Again, if you are a technical lead
    or a CTO, controlling the technical debt is one of your first and most important
    duties.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最好的方法始终是简单地不让技术债务溜走。当然，说起来可能比做起来容易，但知道问题可能如何产生已经是一个很大的进步。记住，“技术债务”这个概念在2000年代并不为人所知或正式化；现在，甚至非技术经理在IT或软件开发领域工作也可能听说过它。这已经是一个很大的进步，并让你能够向他们做出有根据的论点，解释减少延迟、缺乏培训或文档和质量的时机将导致几个月后开发缓慢。再次强调，如果你是技术负责人或CTO，控制技术债务是你的首要且最重要的职责之一。
- en: 'But you may be in a situation where the technical debt of a software application
    is already high – either because you have let it slip in the past (silly you)
    or because you are responsible for a piece of software that was already in a bad
    state. First of all, make it abundantly clear – if it is not perfectly known by
    stakeholders – that the situation is bad: you wouldn’t imagine how long bad software
    teams can invent pretexts for their inability to deliver, and you do need to have
    the capacity to improve the situation. If you accept the job but do not quickly
    issue warnings about the unstable situation, everyone will assume the software
    is fine. And you will not be able to alert about its state later, because, as
    you are a technical expert, everyone will logically consider that you should have
    seen it before, particularly if it is such a mess as you describe. You might even
    find some inconsiderate former owners ready to swear that the software was perfectly
    fine before they handed it over to your team!'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 但您可能处于一个软件应用程序的技术债务已经很高的境地——要么是因为您过去让它滑落了（真傻啊），要么是因为您负责的软件本身就已经处于糟糕的状态。首先，要清楚地表明——如果利益相关者并不完全了解——情况很糟糕：您不会想到糟糕的软件团队可以编造多少借口来掩盖他们无法交付的能力，而且您确实需要有能力改善这种情况。如果您接受了这份工作但并未迅速发出关于不稳定状况的警告，那么每个人都会认为软件没问题。而且您以后也无法对其状态发出警告，因为您是一个技术专家，逻辑上每个人都会认为您应该在此之前就看到它，尤其是如果它像您描述的那样一团糟。您甚至可能会发现一些不负责任的先前所有者发誓说，在将软件转交给您的团队之前，软件完全没问题！
- en: In this case, establish a map of the technical debt in the application (using
    the CIGREF four-layer map, not forgetting that technical debt can even come from
    badly designed processes or ill-defined functions, with incorrect governance).
    There might be some places where a bit of technical debt is acceptable. There
    will be some others where it eats most of the maintenance time and budget and
    where it has to be urgently taken care of. When evaluating the risks of correcting
    this, lots of people who have participated in the initial mess will tell you that
    the impacts will be so high that trying to correct the software will not work,
    and maybe even that they already tried and it failed. In this case, make your
    best estimations and ask for managers to decide and take ownership. When announcing
    that rewriting the concerned feature will cost 100,000 dollars and will come with
    a 20% risk of impact worth 200,000 dollars more, everybody around the table will
    certainly frown... but if you also explain that this software has cost the company
    40,000 dollars every year for the last decade, thus already sending 400,000 dollars
    down the drain, the decision makers will be quick to perform the calculation and
    give you a go.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，建立应用程序中技术债务的地图（使用CIGREF四层图，不要忘记技术债务甚至可能来自设计不良的过程或定义不明确的功能，以及不正确的治理）。可能有些地方一点技术债务是可以接受的。而有些地方则大部分维护时间和预算都被消耗，必须紧急处理。当评估纠正这些风险时，许多参与最初混乱的人会告诉您，影响将会非常高，试图纠正软件将不会奏效，甚至可能已经尝试过并失败了。在这种情况下，做出您最好的估计，并要求经理们做出决定并承担责任。当宣布重写相关功能将花费10万美元，并带来20%的影响风险，额外增加20万美元时，在座的每个人肯定会皱眉...但如果您也解释说，这款软件在过去十年中每年已为公司造成4万美元的损失，因此已经浪费了40万美元，决策者会迅速进行计算并让您尝试。
- en: This means you may reimburse some of the capital (in the metaphor of financial
    loans) by removing technical debt, even if it is generally difficult to explain
    the benefits of this to the managers. After all, the business impact is not immediately
    perceivable and no customers are complaining that the software doesn’t work. So,
    again, you really must put a strong case together by evaluating how much time
    technical debt costs you, what features could have been done for your customers’
    delight at the same time, and how much time it will take to reimburse the debt
    and bring the application to a sound level of quality, without forgetting the
    impact analysis – there is always a risk in “changing the engine while the car
    is running.”
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您可能通过消除技术债务（在金融贷款的比喻中）来偿还部分资本，即使向经理们解释这种做法的好处通常很困难。毕竟，业务影响不是立即可见的，也没有客户抱怨软件不工作。所以，再次强调，您真的必须通过评估技术债务给您带来的时间成本，同时可以为客户的愉悦完成哪些功能，以及偿还债务并使应用程序达到良好质量水平所需的时间来构建一个强有力的论点，同时不要忘记影响分析——在“汽车行驶时更换引擎”总是存在风险。
- en: The Big Bang temptation
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大爆炸的诱惑
- en: 'How about the Big Bang approach? You know – throwing it all away and restarting
    a new, fresh, clean product. The dream of all engineers... **If you think about
    it, this is not the right situation. If it happens without you being able to prevent
    it, then this is for the best.** Let me explain this: the Big Bang approach, however
    seductive it may be, is *never* the right one. If you have a technical debt problem
    in your software, this is because your development process is wrong. So, if you
    start another application hoping it will be better than the previous one without
    fixing the process, you will simply lose a few years and reach the same state.
    If you know what was wrong in the process and have corrected it, the application
    will improve, so there is no use in throwing it anymore.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 大爆炸方法怎么样？你知道的——把所有东西都扔掉，重新启动一个全新的、干净的产品。所有工程师的梦想... **如果你仔细想想，这并不是正确的做法。如果你无法阻止它发生，那么这是最好的结果。**
    让我来解释一下：大爆炸方法，尽管它可能很有吸引力，但**永远**不是正确的选择。如果你的软件中存在技术债务问题，那是因为你的开发过程是错误的。所以，如果你开始另一个应用程序，希望它比前一个更好，但又不修复这个过程，你只会浪费几年时间，最终达到相同的状态。如果你知道过程中哪里出了问题，并且已经纠正了它，应用程序将会改进，所以再扔掉它也没有用了。
- en: Does this mean that the Big Bang never happens? No, of course. Even if it is
    not a good idea, people still try to do it... and fail. But a clean slate is such
    an appealing idea that application owners, even though poor in marketing in all
    other aspects, will go to great lengths to obtain an agreement and budget from
    the stakeholders. They will do so by promising increased performance, providing
    better time-to-market for future features and ease of improvement, and so many
    other qualities that participants will eventually wonder why this had not been
    proposed earlier. And again, they will fail. This is not me saying this, but a
    return on experience that you will find from about everyone with experience with
    these kinds of projects.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着大爆炸永远不会发生？不，当然不是。即使这不是一个好主意，人们仍然会尝试去做... 并失败。但是一张干净的纸是如此吸引人，以至于即使在其他方面营销能力较差，应用程序所有者也会不遗余力地争取利益相关者的同意和预算。他们会通过承诺提高性能、提供更好的上市时间、未来功能的易于改进以及许多其他质量来做到这一点，以至于参与者最终会
    wonder 为什么之前没有提出这个建议。而且，他们还是会失败。这不是我说的话，而是从这些类型的项目中拥有经验的人都会找到的经验之谈。
- en: There are a few exceptions, like in any rule, and some Big Bang projects have
    indeed succeeded. I have noticed this in projects where the Big Bang was not intended
    by the teams but experienced through the fact that the old project simply collapsed
    down on its weight. In France, where I live, we have had many cases of such huge
    government projects where the failure was so big that there was nothing to be
    saved from the project and new software companies had to restart from scratch.
    The “Louvois” project (managing soldiers’ salaries) comes to mind, with millions
    of euros being thrown away with the project. To come back to what I said before
    about shared responsibilities in these events, technical problems were abundant
    in this project, but there was also a huge lack of functional feature descriptions
    and almost no cutting down of the project, which led to this industrial catastrophe.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何规则中都有一些例外，确实有一些大爆炸项目是成功的。我注意到在那些大爆炸并非团队意图而是通过旧项目因自身重量而崩溃的事实中。在我居住的法国，我们有很多这样的大型政府项目，失败如此严重，以至于从项目中没有任何东西可以挽救，新的软件公司不得不从头开始。例如，“卢沃伊”项目（管理士兵的薪水），该项目浪费了数百万欧元。回到我之前提到的这些事件中的共同责任，这个项目中技术问题很多，但功能特性描述严重不足，几乎没有缩减项目规模，这导致了这场工业灾难。
- en: The different types of coupling
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 耦合的不同类型
- en: Coupling between applications is the last concept we well talk about concerning
    time... Just like technical debt is a little too much of something that must exist
    (technical complexity, to implement functional complexity), coupling is the name
    given to a dependency that is a little stronger than what’s needed from a functional
    point of view.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序之间的耦合是我们将要讨论的关于时间的最后一个概念... 就像技术债务是必须存在的东西（技术复杂性，以实现功能复杂性）的略微过多一样，耦合是指从功能角度来看比所需更强的依赖关系。
- en: 'Let’s consider an example: you want to send a contract with an electronic signature
    to one of your customers. Of course, the contract module will have a dependency
    on the electronic signing application, as well as on the module providing the
    information you need about this customer (namely, their financial or legal contact
    email address). But there are dependencies and dependencies...'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子：你想要向你的客户之一发送一份带有电子签名的合同。当然，合同模块将依赖于电子签名应用程序，以及提供你所需要关于该客户信息的模块（即他们的财务或法律联系电子邮件地址）。但是，有依赖关系，还有依赖关系...
- en: 'Imagine that the first one has been very well designed, and you can simply
    send a contract for a signature by calling an API in your information system that
    will then take care of everything. You do not even need to know what company will
    do the actual work, nor how this will be legally binding: you simply call the
    API and if it returns an OK (`HTTP 200`, in technical terms), you are fine. This
    kind of dependency is a low-coupled one: things may change in the implementation,
    with your company preferring another electronic signature vendor, or routing the
    documents to sign in different ways, depending on who is calling the API: you
    do not care as you simply call something such as [https://mycompany.com/document-sign](https://mycompany.com/document-sign)
    with a `POST` command. This is all you know; whatever happens behind the scenes
    is not your concern. You still depend on the function’s completion to get your
    contract signed but this dependency is very flexible and you may never have to
    change anything in the way you call the function; the coupling you are subject
    to is low.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设第一个依赖关系设计得非常好，你只需通过在信息系统调用一个API来发送一份合同进行签名，然后它会处理所有事情。你甚至不需要知道哪家公司将实际完成这项工作，也不需要知道这如何具有法律约束力：你只需调用API，如果它返回OK（技术上称为`HTTP
    200`），你就没问题了。这种依赖关系是一种低耦合的依赖关系：实现中可能会有变化，你的公司可能更倾向于选择另一个电子签名供应商，或者根据调用API的人将文档以不同的方式路由进行签署：你不必关心，因为你只需使用`POST`命令调用类似[https://mycompany.com/document-sign](https://mycompany.com/document-sign)这样的东西。这就是你所知道的一切；幕后发生的一切都不关你的事。你仍然依赖于函数的完成来签署你的合同，但这种依赖性非常灵活，你可能永远不需要改变调用函数的方式；你所承受的耦合度很低。
- en: 'Now, let’s take the second dependency and imagine something at the other end
    of the spectrum: you need to get the email of the financial or legal contact for
    the customer, and to do this, you must know the customer ID. Sadly, this is not
    the same identification as the one you use internally in your service. So, first,
    you will have to call the service in charge of customer references to know the
    exact identification to use. When you have this information, you will have to
    dive deep into a folder shared through its IP number and go down the folder structure,
    starting with the year the consumer was recorded (it looks like it’s the first
    two numbers of the identifier you got, but you’re not sure), then a folder named
    `Contact`, and final a folder with the kind of contact, namely `FIN` for finance
    and `JUR` for legal. There, you will eventually find a Word document in which
    you will have to skip through some useless information before you finally get
    to page 2, where you find the email address you have been looking for all this
    time.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看第二个依赖关系，并想象一下另一端的情况：你需要获取客户的财务或法律联系人的电子邮件地址，为此，你必须知道客户ID。遗憾的是，这并不是你在服务内部使用的同一标识。因此，首先，你必须调用负责客户参考的服务来了解确切的使用标识。当你有了这些信息后，你必须深入到一个通过其IP号共享的文件夹中，并沿着文件夹结构向下走，从消费者被记录的年份开始（看起来像是你得到的标识符的前两个数字，但你并不确定），然后是一个名为`Contact`的文件夹，最后是一个包含联系类型的文件夹，即`FIN`代表财务和`JUR`代表法律。在那里，你最终会找到一个Word文档，你必须跳过一些无用的信息，直到你最终到达第2页，在那里你找到了你一直在寻找的电子邮件地址。
- en: This sounds far-fetched but this is a real-world example I have seen during
    my consulting years (admittedly, though, it was one of the worst information systems
    I have ever seen in the 15 years I was working on customer systems). And we’re
    not even done yet! Some customers had multiple identifiers; and when they were
    deleted and re-entered in the database, their identifiers were recovered... but
    their data was in the folder corresponding to the renewal year instead of the
    initial creation year. At some point, the `Contact` folder was renamed `CONTACTS`,
    ruining the few attempts at automating information recovery, and the codes for
    the types of contacts were changed. Finally, the Word documents in the folders
    evolved in their format and the email address was not to be found at the same
    place, leaving people wondering if the new location contained the right data or
    if it was about new email information. All this useless complexity made this dependency
    on an email address one with a huge strong coupling (again, this is the worst
    example I have seen).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来有些牵强，但这是我咨询生涯中遇到的一个真实世界的例子（诚然，尽管如此，这是我15年来在客户系统工作中见过的最差的信息系统之一）。而且我们还没有完成！一些客户有多个标识符；当他们在数据库中删除并重新输入时，他们的标识符被恢复了...但他们的数据在对应续签年份的文件夹中，而不是初始创建年份的文件夹中。在某个时候，`联系`文件夹被重命名为`CONTACTS`，这破坏了信息恢复自动化的几次尝试，并且联系类型的代码也发生了变化。最后，文件夹中的Word文档格式发生了变化，电子邮件地址不再位于同一位置，让人们怀疑新位置是否包含正确的数据，或者是否是关于新的电子邮件信息。所有这些无用的复杂性使得对电子邮件地址的依赖变得非常紧密（这又是我所见过的最糟糕的例子）。
- en: Of course, low-coupling is generally better but, just like for technical debt,
    it is OK to have some coupling and the important thing is to control it. There
    might be some places where extremely strong coupling is not a concerning issue.
    For example, tight coupling to a budget structure is usually not a big deal because
    these structures are regulatory imposed and they change with a frequency calculated
    in decades. So, it’s no big deal if you have to radically review your processes
    and software applications in this case. On the other hand, you will want low coupling
    if you use a commercial dependency from a provider that tends to increase their
    license price when they realize you do a fair deal of business with their tools
    (you most certainly know of such editors). In this case, showing your CEO/CFO
    that you have made it possible to switch providers with a few changes of parameters
    and a small migration procedure will make you their beloved CTO partner as they
    will return to negotiations with the supplier having extremely strong arguments
    and an easy escape door if the latter will not change its pricing policy.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，低耦合通常更好，但就像技术债务一样，有一些耦合是可以接受的，重要的是要控制它。可能有些地方，极端紧密的耦合并不是一个令人担忧的问题。例如，紧密耦合到一个预算结构通常不是什么大问题，因为这些结构是监管强加的，并且它们的变化频率以十年计算。所以，在这种情况下，你必须彻底审查你的流程和软件应用，这并不是什么大问题。另一方面，如果你使用的是供应商的商业依赖，而该供应商在你意识到你用他们的工具做了很多业务时提高他们的许可价格（你肯定知道这样的编辑器），你将希望有低耦合。在这种情况下，向你的CEO/CFO展示你通过一些参数更改和一个小型的迁移过程就能切换供应商，这将使你成为他们喜爱的CTO合作伙伴，因为他们将带着极其有力的论据和一条容易逃生的后路回到与供应商的谈判中。
- en: Finally, coupling is also related to time. There are lots of kinds of coupling,
    but there is a category of coupling that is chronologically measured. If, to proceed
    with a task in module A, you need a piece of information that comes from module
    B, the dependency is synchronous (and you will certainly find it is implemented
    through a synchronous call such as an HTTP `GET` call). If your process in module
    A can continue freely after it has called a function in module B, the dependency
    is asynchronous (and you will certainly see it as, for example, a `POST` API that
    returns a callback URL that you may call afterward to see if the job is done –
    or even better, you can register a webhook to get informed once the job is terminated;
    this will send you another URL you can contact to get the result of the external
    task). In [*Chapter 17*](B21293_17.xhtml#_idTextAnchor608), we will come back
    to this approach and, in particular, explain the difference between orchestration
    and choreography and when to use each of them – as always, there is no true or
    false here and the right technology depends on the exact functional need and its
    context. Ideally, both approaches are used in a good information system, each
    in the context where they are the preferred solution.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，耦合也与时间有关。有很多种耦合方式，但有一种耦合是按时间顺序衡量的。如果你要在模块A中执行任务，需要来自模块B的信息，那么这种依赖是同步的（你肯定会发现它通过同步调用实现，例如HTTP
    `GET`调用）。如果你的模块A在调用模块B中的函数后可以自由继续，那么这种依赖是异步的（你肯定会看到它，例如，一个返回回调URL的`POST` API，你可以在之后调用它来查看工作是否完成——或者更好的是，你可以注册一个webhook，一旦工作完成就会通知你；这将发送另一个你可以联系以获取外部任务结果的URL）。在[*第17章*](B21293_17.xhtml#_idTextAnchor608)中，我们将回到这种方法，并特别解释编排和协奏之间的区别以及何时使用每种方法——就像往常一样，没有对错之分，正确的技术取决于确切的功能需求和其上下文。理想情况下，在良好的信息系统中，两种方法都应使用，每种方法在其首选解决方案的上下文中使用。
- en: At this point, you should now have a clear understanding of technical debt and
    how it affects the evolution of information systems. As time goes by and technical
    debt cumulates, IT assemblies slow down in their evolution and sometimes their
    sheer functioning because of technical debt. What can we do about this? Well,
    this is the subject of the next section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经清楚地理解了技术债务及其对信息系统演变的影响。随着时间的推移和技术债务的累积，IT组件在演变和有时仅仅是功能上会因技术债务而减速。我们能做些什么呢？嗯，这正是下一节的主题。
- en: An experience-proven blueprint method for information systems
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信息系统的经验证蓝图方法
- en: In this last section, I would like to explain a method I have been using to
    create blueprints of information systems evolution that I have been perfecting
    in the past few years with several industrial customers. There’s nothing special
    in there, nor particularly innovative, as it is just applying common sense to
    reach function targets... but it is formalized enough so that I can imagine you
    finding value in the description of the steps used.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，我想解释一个方法，我过去几年中一直在使用它来创建信息系统演变的蓝图，并与几家工业客户一起完善了它。里面没有什么特别之处，也没有特别创新，因为这仅仅是将常识应用于达到功能目标...但它足够正式，以至于我可以想象你在描述所使用的步骤时能找到价值。
- en: The full method is quite elaborate and would need a dedicated book, so I will
    concentrate on a case that is precisely the subject of the chapter, namely dealing
    with time and technical debt. The example I’ll use will involve extracting a monolith
    software application ridden with technical debt but sadly used as the core of
    the customer company’s business (yes, a worst-case scenario). A multi-year planned
    blueprint had to be created to extract this dependency while limiting the impacts
    on the daily business. The following sections explain how this has been done,
    concentrating on the method and not showing the exact actions, to maintain the
    confidentiality of the customer.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的方法相当复杂，需要一本专门的书籍来详细说明，所以我将专注于本章的精确主题，即处理时间和技术债务。我将使用的例子将涉及从一个充满技术债务的单体软件应用中提取依赖项，但遗憾的是，它被用作客户公司业务的基石（是的，这是一个最坏的情况）。为了在限制对日常业务的影响的同时提取这个依赖项，不得不创建一个多年的计划蓝图。以下章节将解释如何完成这项工作，重点在于方法而不是具体行动，以维护客户的机密性。
- en: It all starts with... mapping!
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有这一切都始于...映射！
- en: 'As explained in [*Chapter 3*](B21293_03.xhtml#_idTextAnchor069), we have to
    start with a formalized mapping of the problem, and the CIGREF map was established
    around the perimeter to be studied. As the problem was on the functional and software
    layers, the processes were not represented at all and the fourth layer regarding
    hardware infrastructure just skirted over because all we needed there was the
    global cost of associated machines. The result was the following structure, where
    you can spot the top-left large white square in the software layer (this was the
    monolith subject we studied):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第 3 章*](B21293_03.xhtml#_idTextAnchor069)所述，我们必须从对问题的正式映射开始，CIGREF 地图建立在对研究边界的周围。由于问题在功能和软件层，过程完全没有表示，关于硬件基础设施的第四层只是略过，因为我们只需要相关机器的全球成本。结果是以下结构，其中你可以看到软件层中左上角的大白方块（这是我们研究的单体主题）：
- en: '![Figure 4.2 – The evolution of the preciseness in maps](img/B21293_04_2.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 地图中精确度的演变](img/B21293_04_2.jpg)'
- en: Figure 4.2 – The evolution of the preciseness in maps
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 地图中精确度的演变
- en: 'This is something so important that I want to stress it again: **only the parts
    related to the study have been mapped**. Remember this graph from the previous
    chapter?'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一件非常重要的事情，我想再次强调：**只有与学习相关的部分被绘制在地图上**。还记得上一章中的这个图表吗？
- en: '![Figure 4.3 – Example of a real-world map with reduced content](img/B21293_04_3.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 具有减少内容的真实世界地图示例](img/B21293_04_3.jpg)'
- en: Figure 4.3 – Example of a real-world map with reduced content
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 具有减少内容的真实世界地图示例
- en: It was applied there because, with 20 software applications or so, it was only
    a small part of the whole information system of this company. As for the business
    capability map, it was more exhaustive, but this is only because we needed the
    whole perimeter for another project. As you can see, only a few of these functions
    were related to the software applications under study (following the lines between
    layer 2 and layer 3).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，在20个左右软件应用中，它只是该公司整个信息系统的一小部分。至于业务能力地图，它更为详尽，但这仅仅是因为我们需要整个边界线用于另一个项目。正如你所见，只有少数这些功能与正在研究的软件应用相关（沿着层2和层3之间的线条）。
- en: 'Back on the giants’ shoulders, I will simply recall that what Martin Fowler
    states about classes applies perfectly to functions and software applications
    mapping: Martin recommends not to draw all classes in UML diagrams, only important
    ones. He then goes on to explain that the main problem with diagrams is that people
    drawing them try to make them comprehensive. Diagrams should help us understand
    concise and clear information, while only the code should be the source of comprehensive
    information.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 回到巨人的肩膀上，我将简单地回顾一下马丁·福勒关于类所提出的观点，这完全适用于函数和软件应用映射：马丁建议不要在UML图中绘制所有类，只绘制重要的类。然后他继续解释，图表的主要问题在于绘制它们的人试图使它们全面。图表应该帮助我们理解简洁明了的信息，而代码应该是全面信息的来源。
- en: Finding the atomic actions
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找原子操作
- en: 'Since extracting the monolith at once and changing it for a new application
    was not possible (remember, “No Big Bang... ever”), we had to devise a way to
    progressively extract functions from the application and migrate them, step by
    step, and with limited impact on new, modern implementations. But in which order?
    This is where the map will help, showing the modules and their dependencies. From
    here on, I will use arbitrary schemas to better explain the approach, even if
    they deviate from what happened in this project. Let’s imagine that the three
    important features we need to “rescue” are based on five software modules with
    the following dependencies (beware, there are functional implementations – links
    between layer 2 and layer 3, and technical couplings – links inside layer 3):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一次提取单体并为其新应用进行更改是不可能的（记住，“没有大爆炸……永远”），我们必须设计一种方法，逐步从应用中提取功能并将它们迁移，一步一步地，并尽量减少对新的、现代实现的影响。但顺序是怎样的？这就是地图将帮助的地方，它显示了模块及其依赖关系。从现在开始，我将使用任意架构来更好地解释方法，即使它们与这个项目发生的事情有所偏差。让我们想象一下，我们需要“拯救”的三个重要特性基于以下依赖关系的五个软件模块（注意，有功能实现——层2和层3之间的链接，以及技术耦合——层3内部的链接）：
- en: '![Figure 4.4 – Simple example of functions and their implementations](img/B21293_04_4.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 函数及其实现的简单示例](img/B21293_04_4.jpg)'
- en: Figure 4.4 – Simple example of functions and their implementations
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 函数及其实现的简单示例
- en: 'Once we’ve done this, we can use the information provided to draw two chronological
    approaches (this is where the time relationship is the most present in this section).
    This first one could be, for example, to try and get the first functions out as
    quickly as possible (time-to-market strategy):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成这个，我们就可以使用提供的信息来绘制两种时间顺序的方法（在这个部分中，时间关系最为明显）。第一种方法可能是，尽可能快地将第一个功能推出（市场时间策略）：
- en: '![Figure 4.5 – Scenario with time-to-market priority](img/B21293_04_5.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 以市场时间优先级的场景](img/B21293_04_5.jpg)'
- en: Figure 4.5 – Scenario with time-to-market priority
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 以市场时间优先级的场景
- en: In this case, the duty of rewriting the engine that features (or functions)
    1 and 2 eventually depends on is left for later, but at least function 3 is quickly
    available in its new implementation. The problem with this approach is that, since
    it leaves the technical debt for later, the development process will remain slow
    and features will be harder to release until the end of the project.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，重写具有功能（或功能）1和2的引擎的责任最终被推迟，但至少功能3的新实现可以快速可用。这种方法的缺点是，由于它将技术债务推迟到以后，开发过程将保持缓慢，直到项目结束时功能将更难发布。
- en: 'This calls for another approach where technical debt will be addressed first.
    The advantage is that features will flow quickly in the future. However, the shortcoming
    of this alternative approach is that it will take some time before we see the
    result (and as explained previously, this is where you’d better have a strong
    business case to convince the stakeholders to finance this investment). This second
    approach can be seen in the following diagram:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要另一种方法，其中首先解决技术债务。这种方法的优点是未来功能将快速流动。然而，这种替代方法的缺点是，我们将在一段时间后才能看到结果（正如之前解释的，这是你最好有一个强大的商业案例来说服利益相关者资助这项投资的地方）。这种第二种方法可以在以下图表中看到：
- en: '![Figure 4.6 – Scenario with TCO priority](img/B21293_04_6.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 以TCO优先级的场景](img/B21293_04_6.jpg)'
- en: Figure 4.6 – Scenario with TCO priority
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 以TCO优先级的场景
- en: 'To sum up the advantages and drawbacks of each approach, it is better to superimpose
    the two diagrams, which puts forward the main differences, noted here by letters
    A and B:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结每种方法的优缺点，最好是将两个图表叠加，这提出了主要差异，以下用字母A和B标注：
- en: '![Figure 4.7 – Graphical difference between the two scenarios](img/B21293_04_7.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – 两种场景之间的图形差异](img/B21293_04_7.jpg)'
- en: Figure 4.7 – Graphical difference between the two scenarios
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 两种场景之间的图形差异
- en: The delta marked `A` shows the difference between **initial** time-to-market.
    This happens to be an important criterion in lots of businesses because customers
    need to be truly convinced that you are going forward. Whatever the trusty relationship
    you have with your customers – or internal users, by the way – it is hard to let
    them without any demonstration of what you have been doing for months, and business
    owners know it. In the first scenario, feature 3 arrives sooner on the market,
    and may then participate in the financial investment for the rest of the project.
    In the second one, the first feature to be released not only arrives later but
    is not the same, which can make a great difference depending on what is most important
    for the users.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为“A”的delta显示了**初始**市场时间的差异。这在许多业务中都是一个重要的标准，因为客户需要真正相信你在前进。无论你与客户或内部用户的关系多么可靠——顺便说一句——很难让他们在没有展示你几个月来所做的工作的情况下离开，商业所有者知道这一点。在第一种场景中，功能3更早地进入市场，并可能参与整个项目的财务投资。在第二种场景中，第一个发布的功能不仅来得更晚，而且与之前的不同，这可能会根据用户最重视的内容产生很大差异。
- en: 'The delta marked `B` shows the difference in total time spent on the project:
    while scenario number 2 shows the first results less quickly than scenario number
    1, it solves more technical debt at the beginning of the project, which will make
    for easier and quicker developments for the remaining time. This is something
    that should be taken into account because a development team costs a lot of money.
    Depending on the complexity of the project, this delta may become very important
    (note that in the preceding diagram, the scales are completely arbitrary and do
    not represent anything representative as it depends on your project).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为`B`的delta显示了在项目上花费的总时间差异：虽然场景2比场景1更慢地显示出初步结果，但它解决了项目开始时的更多技术债务，这将使剩余时间的发展更容易和更快。这是应该考虑的事情，因为开发团队的成本很高。根据项目的复杂性，这个delta可能变得非常重要（注意，在前面的图表中，刻度是完全任意的，并不代表任何有代表性的事物，因为它取决于你的项目）。
- en: Now that we have established the two basic scenarios, we will dive into something
    a bit more realistic.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了两个基本场景，我们将深入探讨一些更现实的内容。
- en: Prioritizing the actions based on business criteria
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根据业务准则优先处理行动
- en: It is a used trick, but presenting two extreme alternatives often helps in getting
    stakeholders to choose an intermediate approach. There are good chances that the
    decision will not be between the two extreme approaches that have been explained
    previously but for a compromise somewhere in the middle. But then again, how do
    you adjust the cursor? What criteria can you use for this?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常用的技巧，但提出两个极端的替代方案通常有助于让利益相关者选择一个中间的方法。有很大可能性，决策不会在之前解释的两个极端方法之间，而是在中间某个妥协点。但话又说回来，你如何调整光标？你可以使用哪些准则来进行这种调整？
- en: Some criteria immediately come to mind for any business-savvy software architect,
    namely gross income/turnover and profitability rate. Often, I let the third criterion
    be something vague that stakeholders evaluate in terms of importance to the strategy
    of the company (they know more about this than any IT person). What is important
    at this point of the project is that these criteria should be evaluated fast,
    in a “planning poker” mode, and that they remain limited in number. I use levels
    of one to three stars for each of the criteria, and no more than three criteria
    as a whole. This is generally enough to find out what the best scenario is.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何有商业头脑的软件架构师来说，一些标准准则会立即浮现在脑海中，即总收入/营业额和盈利率。通常，我会让第三个准则是一个模糊的东西，利益相关者会根据对公司战略的重要性来评估它（他们对这一点比任何IT人员都了解得更多）。在项目这个阶段重要的是，这些准则应该快速评估，以“规划扑克”模式进行，并且数量应该有限。我为每个准则使用一到三颗星的水平，整个准则不超过三个。这通常足以找出最佳场景。
- en: 'To come back to something a bit more realistic, here is an example of such
    a decision table that I have created with another company I advised (some entries
    have been deleted or renamed as they would have revealed too much):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 回到更现实的话题，这里有一个例子，是我为另一家我咨询过的公司创建的决策表（一些条目已被删除或重命名，因为它们可能会透露太多信息）：
- en: '![Figure 4.8 – Prioritization of projects through the chosen criteria](img/B21293_04_8.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8 – 通过所选准则优先处理项目](img/B21293_04_8.jpg)'
- en: Figure 4.8 – Prioritization of projects through the chosen criteria
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – 通过所选准则优先处理项目
- en: 'Interestingly, in this case, you will note that the criteria were not the “standard”
    ones proposed previously. Here, we have the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在这种情况下，你会注意到，准则并不是之前提出的“标准”准则。这里，我们有以下内容：
- en: The number of processes improved (in layer 1 of the map)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改善的流程数量（在地图的第一层）
- en: The estimated impact on overall productivity (this was an industrial production
    company)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对整体生产力的预估（这是一个工业生产公司）
- en: The estimated impact on growth (they were operated on a rapidly consolidating
    market, where small companies were bought by bigger ones, so quickly growing was
    of utmost importance to flourish)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对增长预估的影响（它们在一个快速整合的市场上运营，小公司被大公司收购，因此快速增长对繁荣至关重要）
- en: Also, a column was added to the traditional estimated weight of the project
    and delay estimates, namely for the impact and risks associated with the project
    (which is a sound approach and should be done for any such projects). To stress
    the fact that ease of elaboration of such projects is much more important than
    completeness and exact respect of the methodology, here is what the table initially
    resembled, after the 2 hours of analysis directly on a whiteboard.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还增加了一个列到传统的项目估算权重和延迟估算中，即与项目相关的冲击和风险（这是一个合理的方法，并且应该适用于任何此类项目）。为了强调这样一个项目的易于阐述比完整性和对方法的精确尊重更为重要，以下是表格在直接在白板上分析2小时后的初始样子。
- en: 'You can find this whiteboard image on GitHub: [https://github.com/PacktPublishing/Enterprise-Architecture-with-.NET/blob/main/Whiteboard%20image.jpeg](https://github.com/PacktPublishing/Enterprise-Architecture-with-.NET/blob/main/Whiteboard%20image.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到这张白板图片：[https://github.com/PacktPublishing/Enterprise-Architecture-with-.NET/blob/main/Whiteboard%20image.jpeg](https://github.com/PacktPublishing/Enterprise-Architecture-with-.NET/blob/main/Whiteboard%20image.jpeg)
- en: A few last words on time, semantics, and alignment
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后，关于时间、语义和对齐的几点话
- en: Why a complete chapter on the importance of time in software development? You
    might have wondered this and I hope that I have convinced you, not of the importance
    of time, which is a given in any project, but rather of the fact that lots of
    problems in software development and information systems design should be watched
    across the prism of time management.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会有一个关于软件开发中时间重要性的完整章节？你可能想知道这个问题，我希望我已经说服了你，不是时间的的重要性，这在任何项目中都是不言而喻的，而是许多软件开发和信息系统设计中的问题应该通过时间管理的棱镜来观察。
- en: 'It often happens that, taking it for granted as it passes by without anything
    we can do about it, we forget about time in our activities of design, not taking
    into account the perspective of the future. How many information systems were
    born ill because they were designed to solve today’s problems, without thinking
    of how business will evolve in the future? Technical evolution, sure, we can handle
    them, and we do more than we should sometimes by preparing the system for the
    next framework, the future technology, and so on. But this is not the issue! The
    important thing is the business domain functions: they are changing as well and
    the information system has got to remain aligned with the business, not to some
    technical evolution that may be a fad in a few years.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 经常发生的情况是，我们把它视为理所当然，因为它在我们无法采取任何行动的情况下悄然流逝，我们在设计活动中忘记了时间，没有考虑到未来的视角。有多少信息系统因为它们被设计来解决今天的问题，而没有考虑到业务将如何在未来发展而诞生不良？技术演变，当然，我们可以处理它们，有时我们做得比应该的更多，通过为下一个框架、未来的技术等做准备。但这不是问题！重要的是业务领域功能：它们也在变化，信息系统必须与业务保持一致，而不是与可能在几年后成为过时的技术演变保持一致。
- en: 'Time is also often forgotten when we tend to analyze concepts as stable, simply
    because we do not use a broad enough time spectrum to explain them. Lots of concepts
    evolve while seemingly being extremely stable. In [*Chapter 3*](B21293_03.xhtml#_idTextAnchor069),
    I explained how the concept of “customer” is a business rule and not a stable
    entity: a customer can be anyone who bought something in the past 12 months for
    commerce while being anyone who has done so in the past 24 months for marketing.
    And maybe maintenance will have a list of customers based on who has got a running
    guarantee. These rules, like any business rules, can change in time. At some point,
    maybe the big boss will get tired of commerce and marketing not communicating
    the same numbers and evolution rate of customers and will force them to adopt
    a common definition; maybe the guarantee duration will change, which will affect
    the maintenance list of customers. Who knows? One thing is sure: if you have not
    considered time, you will have trouble.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们倾向于将概念视为稳定时，时间也常常被遗忘，仅仅是因为我们没有使用足够广泛的时间范围来解释它们。许多概念在表面上看似极其稳定的同时，实际上正在演变。在[*第三章*](B21293_03.xhtml#_idTextAnchor069)中，我解释了“客户”这一概念是一个业务规则而不是一个稳定的实体：对于商业而言，客户可以是过去12个月内购买过东西的任何人，而对于营销而言，可以是过去24个月内购买过东西的任何人。也许维护部门会根据谁获得了运行保证来列出客户名单。这些规则，就像任何业务规则一样，会随着时间的推移而改变。在某个时候，也许大老板会厌倦商业和营销没有传达相同的客户数量和演变速度，并强迫他们采用一个共同的定义；也许保证期限会改变，这将影响客户维护名单。谁知道呢？有一点是肯定的：如果你没有考虑时间，你会遇到麻烦。
- en: 'A small anecdote – that I hope you will find revealing of the importance of
    time – to conclude this chapter: I happened to advise an organization that, through
    fusion with another one, had to change their logo. Since these organizations were
    subject to political changes after elections, the people there wanted to make
    it easier to adjust their logo in the future because this operation was extremely
    long and boring: the logo had to be changed in every message template from every
    application of the information system that would produce documents, and we were
    talking about thousands of templates and months of work to adjust the logo everywhere.
    The initial approach was to propagate a server share path everywhere: this way,
    changing the logo would automatically happen everywhere when the files were modified.
    Luckily, we had time to think about it a bit more and it was decided to switch
    the approach to a URL exposing the logo resource in different formats through
    content negotiation, and using an additional URL query parameter to indicate the
    reference time for which the logo was to be sent. This way, most applications
    who simply created documents along the way did not have to care about passing
    this parameter and would get the latest logo bitmap resource; but for the few
    legally-constrained applications that had to be able to fusion a letter at a given
    time in the past with the exact pixel-perfect form, it remained possible to do
    so without the new logo appearing on a old letter, which would have cause trouble.
    Today, this organization has equipped itself with an archive-capable content management
    solution, which now solves the problem in a much better way. Technical evolution
    took care of the functional need in a new way. Again, it was only a question of
    time!'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小故事——我希望你能从中发现时间的重要性——来结束这一章：我碰巧为一个组织提供建议，该组织通过与其他组织的合并，不得不更换他们的标志。由于这些组织在选举后都受到政治变化的影响，那里的人们希望使将来调整标志变得更加容易，因为这项操作非常耗时且无聊：标志必须从信息系统中产生文档的每个应用程序的每个消息模板中更改，而我们谈论的是数千个模板和数月的工作来调整标志。最初的方法是在每个地方传播服务器共享路径：这样，当文件被修改时，更改标志将自动在所有地方发生。幸运的是，我们有时间稍微思考一下，并决定将方法切换到通过内容协商公开不同格式的标志资源的URL，并使用额外的URL查询参数来指示要发送标志的参考时间。这样，大多数只是创建文档的应用程序不必关心传递此参数，并将获得最新的标志位图资源；但对于少数法律约束的应用程序，它们必须能够在过去某个时间点与精确的像素完美形式融合信函，仍然可以这样做，而不会在旧信函上出现新标志，这会引起麻烦。如今，这个组织已经配备了一个具有存档功能的内容管理系统，现在以更好的方式解决了这个问题。技术进化以新的方式处理了功能需求。再次强调，这只是时间问题！
- en: 'Here’s one last note about the importance of time and technical debt in information
    systems: there can be things even worse than technical debt, in what we could
    call “functional debt” or, more precisely, “semantics debt.” This will be the
    subject of [*Chapter 9*](B21293_09.xhtml#_idTextAnchor318). But for now, we are
    going to end the theoretical part of this book with something that is extremely
    theoretical: a perfect information system!'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 关于时间和技术债务在信息系统中的重要性，这里有一个最后的注意事项：可能存在比技术债务更糟糕的事情，我们称之为“功能债务”或更精确地说是“语义债务”。这将是[第9章](B21293_09.xhtml#_idTextAnchor318)的主题。但就目前而言，我们将以一个非常理论性的内容结束这本书的理论部分：一个完美的信息系统！
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have shown how time influences everything in the analysis
    of an information system since it is a living entity that evolves throughout its
    use. Time is so current in our daily lives that it is often forgotten when structuring
    an information system, but it is the key to designing it in such a way that it
    will stand the test of time and have a reduced TCO.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了时间如何影响信息系统分析中的每一件事，因为它是一个在使用过程中不断演变的活生生的实体。时间在我们的日常生活中如此普遍，以至于在构建信息系统时常常被遗忘，但它却是设计它的关键，使其能够经受时间的考验，并具有较低的TCO。
- en: The Agile approach is one of the first methods that dealt with this time-related
    reality, and it has radically changed how software is created and handled. The
    same approach can be applied to systems as a whole set of applications working
    together, which means the technical debt can be handled globally and kept under
    control. This notion of technical debt is not well named and, as a future chapter
    will show, semantics is very important, so I would recommend keeping this in mind
    at all times and, if possible, adjusting the naming, as was proposed in this chapter.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷方法是最早处理这种时间相关现实的方法之一，它彻底改变了软件的创建和处理方式。同样的方法可以应用于整个系统，即作为一个协同工作的应用程序集合，这意味着技术债务可以全局处理并保持受控。这种技术债务的概念命名并不准确，正如未来章节将展示的，语义学非常重要，因此我建议时刻牢记这一点，并在可能的情况下调整命名，正如本章所提出的。
- en: The rest of this book contains lots of recipes to help you reduce this technical
    debt or at least keep it to an acceptable level. But in the next chapter, we will
    try and imagine a perfect information system, with little or no debt or coupling.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本书剩余部分包含许多食谱，以帮助您减少这种技术债务或至少将其保持在可接受的水平。但在下一章中，我们将尝试想象一个完美的信息系统，几乎没有任何债务或耦合。
