- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currying and Partial Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! You have already covered more than 90% of the book! You are
    awesome and I’m giving you a virtual high-five! In this chapter, we will talk
    about currying and partial application. I know there is a special keyword, `partial`,
    that allows us to split our class, struct, or interface into parts; however, in
    functional programming, partial application has a different meaning. Currying
    transforms a function with multiple arguments into a sequence of functions, each
    taking a single argument. This transformation allows for incremental application
    of arguments, where each step returns a new function awaiting the next input.
    Partial application, on the other hand, involves fixing a number of arguments
    to a function, producing a function with fewer arguments. Both techniques are
    helpful in scenarios where not all arguments to a function are available at the
    same point in execution, thereby providing the flexibility to apply these arguments
    as they become available.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn these new techniques, we will go through the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding currying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step-by-step currying implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Areas for partial application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges and limitations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before moving on, I can’t leave you without regular self-check tasks to measure
    your knowledge before and after reading the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Task 1 – Currying tower attack functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refactor the `AttackEnemy` function using currying, allowing the `towerType`
    to be preset for multiple uses throughout the game while accepting dynamic inputs
    for `enemyId` and `damage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Task 2 – Partial application for game settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apply partial application to create a function for quick setup of standard
    game settings where the `map` is predefined but allows for dynamic setting of
    `difficultyLevel` and `isMultiplayer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Task 3 – Currying permission checks for game features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Curry this function so that it can first accept a `userRole` and then return
    another function that takes a `feature`, determining whether the specified role
    has access to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You might think these methods are already optimal, but their simplicity is intentional.
    These focused tasks let you practice functional programming without distractions.
    As always, these tasks are just for your self-assessment, and you’re not supposed
    to solve them easily. So, don’t worry if you have any difficulties with them,
    and just proceed with reading the chapter. By its end, you’ll tackle these challenges
    like a pro. Keep that in mind, and I hope you have a happy coding experience!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Currying** is a technique that converts a function with multiple arguments
    into a sequence of functions, each accepting a single argument. Named after the
    mathematician Haskell Curry, currying enables the partial application of arguments,
    where each supplied argument returns a new function poised for the next input.
    This approach is helpful when we want to reuse parts of the function in different
    scenarios or make some calculations between steps in a multi-step function.'
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into the concepts, let’s catch up with Steve and Julia.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *Hey Steve, I see you’ve made great progress with functional programming.
    Today, we’ll explore currying and partial application, two powerful techniques
    that can help you write even more reusable and* *modular code.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *Hi Julia! That sounds interesting. I’ve heard about these concepts
    but never really understood how to apply them in C#. Can you break it down* *for
    me?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *Absolutely! Let’s start with currying. Currying transforms a function
    with multiple arguments into a sequence of functions, each taking a single argument.
    This transformation allows for the incremental application of arguments, where
    each step returns a new function awaiting the* *next input.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *So, it’s like creating a chain of functions, each taking* *one argument?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *Exactly! Let me show you a currying application in a practical example
    within a YouTube video management system. Often, we need to check whether a user
    has the appropriate permissions for different actions, such as viewing, commenting,
    and* *uploading videos.*'
  prefs: []
  type: TYPE_NORMAL
- en: Standard approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Typically, we might use a function such as this to check permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This function is effective but requires both parameters each time you check
    a different action for the same role.
  prefs: []
  type: TYPE_NORMAL
- en: Curried approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By currying this function, we create a more adaptable permission checker, useful
    when handling multiple actions for the same user role during a session or in similar
    contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the curried approach as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in this example, currying has several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reusability**: The curried function allows you to predefine the action and
    create specific functions for checking each role. This is especially beneficial
    when multiple roles need to be checked for the same action repeatedly during a
    session.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduction in redundant code**: Currying separates the action from the role
    evaluation, reducing repetitive code when performing multiple checks for different
    roles under the same action. This improves code readability and maintainability.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Convenience of partial application**: You can partially apply the action
    when you know that all subsequent checks will be for that action, which is common
    in scenarios where a session or particular interface segment is focused on a single
    type of action.'
  prefs: []
  type: TYPE_NORMAL
- en: Step-by-step implementation of currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Julia finished explaining the currying example, Steve nodded thoughtfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *I think I’m starting to get it. But how do we actually implement currying
    in* *our code?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *Great question! Let’s break it* *down step-by-step...*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A process for implementing currying is actually quite easy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Identify the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a function that takes multiple parameters. This function is a candidate
    for currying if you often find yourself using only some of the parameters at a
    time or if the parameters are naturally grouped in stages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define curried functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transform the multi-parameter function into a sequence of nested, single-parameter
    functions. Each function returns another function that expects the next parameter
    in the sequence.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement using Func delegates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can utilize `Func` delegates to implement curried functions. Each Func returns
    another Func until all parameters are accounted for, culminating in the return
    of the final value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Simplify invocation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although currying adds a level of indirection to function invocation, it simplifies
    the process by breaking it down into manageable steps, each of which can be handled
    separately as needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although currying might look a bit cumbersome, it has many situations where
    it is beneficial. Let’s explore some common use cases and see how currying can
    be applied to improve code modularity and reusability.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When setting up configurations that involve multiple parameters, currying allows
    these settings to be specified incrementally throughout the application. Consider
    an example where we need to set up a notification service limiting the maximum
    number of notifications sent per minute for each user group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `CurryNotificationConfig` function accepts the notification
    type, maximum notifications per minute, and recipient email as curried parameters.
    Each group of users has its own settings, making the configuration for each specific
    user more reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Event handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In event-driven programming, currying can be used to handle events with specific
    pre-filled parameters, simplifying event handler logic. Let’s consider an example
    of handling button click events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By currying the button click handler, you can create specialized functions for
    each button (`handleSaveClick` and `handleCancelClick`) with the button name pre-filled.
    This simplifies the event handler attachment and makes the code more readable
    and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currying facilitates partial application, where a function with many parameters
    can be transformed into a function with fewer parameters by fixing some parameter
    values ahead of time. We will discuss it in detail in the next section, but for
    now, let’s look at an example of a logging function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, currying allows you to partially apply the `logLevel` parameter,
    creating `logError` and `logWarning` functions for different log levels. This
    reduces the need to pass the log level repeatedly and makes the logging calls
    more concise and expressive.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currying can simplify asynchronous code by separating the preparation of parameters
    from the execution of asynchronous operations. Here is an example of making an
    HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By currying the HTTP `GET` request function, we can separate the configuration
    of the URL, headers, and cancellation token. This allows for more flexible and
    modular asynchronous code, where each request aspect can be prepared independently
    and combined when needed.
  prefs: []
  type: TYPE_NORMAL
- en: In general, currying aims to reduce redundancy and simplify the function’s usage
    across different parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In simple terms, partial application involves taking a function that accepts
    several arguments, supplying some of these arguments, and returning a new function
    that only requires the remaining arguments. This is very similar to what currying
    does.
  prefs: []
  type: TYPE_NORMAL
- en: Currying transforms a function with multiple arguments into a sequence of functions,
    each accepting a single argument. This enables partial application naturally,
    as each function returned by a curried function can be considered a partially
    applied function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key difference between currying and partial application lies in their implementation
    and usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Currying** is about transforming the function structure itself, turning a
    multi-argument function into a chain of single-argument functions'
  prefs: []
  type: TYPE_NORMAL
- en: '**Partial application**, on the other hand, does not necessarily change the
    function structure but reduces the number of arguments it needs by pre-filling
    some of them'
  prefs: []
  type: TYPE_NORMAL
- en: Partial application can be particularly useful in scenarios involving configurations,
    repetitive tasks, and predefined conditions. It simplifies the interface for the
    end user of the function and can make the code base easier to maintain by encapsulating
    common parameters within partially applied functions.
  prefs: []
  type: TYPE_NORMAL
- en: Steve scratched his head, looking a bit confused.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *Julia, I’m having trouble seeing the difference between currying and
    partial application. They seem* *really similar*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *You’re* *right that they’re related, Steve. The key difference is in
    how they’re implemented and used. Let me* *explain further...*'
  prefs: []
  type: TYPE_NORMAL
- en: Areas for partial application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although partial application is used in quite similar scenarios to the currying
    ones, the possibility of having more than just one parameter makes it more applicable.
    Here are some good places to apply partial application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration management**: In systems where configurations vary slightly
    between environments or parts of the application, partial application can simplify
    configuration management by pre-setting common parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User interface events**: In GUI programming, event handlers often require
    specific parameters that don’t change once set. Partial application allows developers
    to prepare these handlers with predefined arguments, making the code cleaner and
    easier to manage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API integration**: When interacting with external APIs, certain parameters
    such as API keys and user tokens remain constant across requests. Partially applying
    these parameters to API request functions can simplify function calls and enhance
    security by isolating sensitive data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logging and monitoring**: A common requirement across applications, logging
    often involves repetitive information such as log levels and categories. Partial
    applications can create specialized logging functions that are easier to use and
    reduce the likelihood of errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data processing pipelines**: In scenarios involving data transformation and
    processing, functions often need specific settings or operations to be applied
    consistently. Partial applications can preconfigure these functions with the necessary
    settings, making the pipeline more modular and reusable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example of partially applying a function for configuration settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider a scenario in a content management system where different types of
    content require specific rendering settings. The function that handles rendering
    might take multiple parameters, but many of these parameters are common across
    content types.
  prefs: []
  type: TYPE_NORMAL
- en: Standard rendering function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say we have a function to render our content that takes multiple parameters
    and can be used only when we have all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Partially applied function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To simplify the use of this function across the application, particularly when
    most content uses a standard format and theme, you can partially apply these common
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach allows us to use the `renderStandard` function without repeatedly
    specifying the format and theme. You must be thinking now that we could use default
    parameters here and get rid of all this partial application. But what if we have
    not just one “standard” way of rendering, but several of them: desktop, cellphone,
    and tablet? That’s when we create specific functions for each case with shared
    code in the “main” `RenderContent` function. It looks like an inheritance for
    functions of sorts.'
  prefs: []
  type: TYPE_NORMAL
- en: After studying currying and partial application, Steve couldn’t help but feel
    a bit overwhelmed. He reached out to Julia to voice his apprehensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *Julia, while I see the potential of these techniques, I’m worried about
    the increased complexity and potential performance issues. How do you manage those
    challenges in* *your projects?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *Those are valid points, Steve. It’s true that currying and partial
    application have their challenges and limitations. Let’s go through some of them
    and discuss strategies to* *overcome them...*'
  prefs: []
  type: TYPE_NORMAL
- en: Challenges and limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After studying currying and partial application, Steve couldn’t help but feel
    a bit overwhelmed. He reached out to Julia to voice his apprehensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *Julia, while I see the potential of these techniques, I’m worried about
    the increased complexity and potential performance issues. How do you manage those
    challenges in* *your projects?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *Those are valid points, Steve. It’s true that currying and partial
    application have their challenges and limitations. The following are* *some examples:*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased complexity**: For developers unfamiliar with functional programming,
    currying and partial application can make the code seem more complex and harder
    to understand, leading to a steeper learning curve.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance overheads**: Every function call in .NET involves a certain overhead,
    and currying increases the number of function calls by transforming a single multi-parameter
    function into multiple single-parameter functions. This can potentially impact
    performance, especially in performance-critical applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugging difficulty**: Debugging curried functions can be more challenging
    because the flow of data and execution is spread across multiple function calls
    rather than being concentrated in a single function body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sounds a bit scary, but there is no need to worry because we can overcome
    these challenges using the* *following strategies:*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Education and training**: Providing training sessions and resources on functional
    programming concepts can help team members understand and effectively use currying
    and partial applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selective use**: Apply currying and partial application selectively, focusing
    on areas where they provide clear benefits, such as in configuration management
    and API interaction, rather than applying them universally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance monitoring**: Always monitor the performance implications of
    currying in your specific context. Use profiling tools to identify any bottlenecks
    and refactor the code if necessary to optimize performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced debugging techniques**: Utilize advanced debugging tools and techniques,
    such as conditional breakpoints and call stack analysis, to better manage the
    debugging of curried functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration strategies**: When working within an object-oriented framework,
    integrate functional programming techniques gradually and ensure they complement
    rather than complicate the architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While currying and partial application can introduce some complexity and challenges,
    with the right strategies and tools, these challenges can be managed effectively.
  prefs: []
  type: TYPE_NORMAL
- en: As they wrapped up their discussion on currying and partial application, Steve
    looked thoughtful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *This has been really enlightening, Julia. I can see how these techniques
    could make our tower defense game code more flexible* *and maintainable.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *Exactly, Steve! And remember, like any tool in programming, the key
    is knowing when and how to apply these* *concepts effectively.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *Thanks, Julia. I’m looking forward to trying these out in our next*
    *coding session!*'
  prefs: []
  type: TYPE_NORMAL
- en: Julia smiled, pleased with Steve’s enthusiasm and progress in functional programming
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve explored the functional programming concepts of currying
    and partial application. Now, let’s apply these techniques to practical scenarios
    in a mobile tower defense game.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refactor the `AttackEnemy` function using currying, allowing the `towerType`
    to be preset for multiple uses throughout the game while accepting dynamic inputs
    for `enemyId` and `damage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apply partial application to create a function for quick setup of standard
    game settings where the `map` is predefined but allows for dynamic setting of
    `difficultyLevel` and `isMultiplayer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Curry this function so that it can first accept a `userRole` and then return
    another function that takes a `feature`, determining whether the specified role
    has access to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These exercises are tailored to help you apply currying and partial application
    within the context of a mobile tower defense game. By practicing these techniques,
    you’ll enhance the functionality and scalability of the game’s code base, making
    it easier to manage and extend. Remember, the more you practice these functional
    programming techniques, the more proficient you’ll become in building sophisticated
    game logic.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are the solutions to the exercises related to currying and partial application
    within the context of a mobile tower defense game. These solutions demonstrate
    how to implement the concepts discussed and provide practical examples of their
    use in game development.
  prefs: []
  type: TYPE_NORMAL
- en: Solution 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To refactor the `AttackEnemy` function using currying, we first define the
    original function and then transform it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This curried function allows the `towerType` to be set once and reused for multiple
    attacks, enhancing code reusability and reducing redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: Solution 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use partial application for simplifying game settings configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This function partially applies the map setting, allowing other settings such
    as `difficultyLevel` and `isMultiplayer` to be configured dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Solution 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implement a curried function for managing permissions based on user roles and
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This curried function simplifies permission checks by setting the `userRole`
    once and allowing dynamic checks for various features, streamlining the permission
    management process.
  prefs: []
  type: TYPE_NORMAL
- en: These solutions demonstrate practical applications of currying and partial application,
    improving the structure and maintainability of code within a mobile tower defense
    game. By implementing these techniques, developers can enhance both the flexibility
    and readability of their game logic.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored currying and partial application. Currying transforms
    a multi-parameter function into a sequence of single-parameter functions, each
    accepting one argument and returning another function ready to take the next argument.
    This technique is particularly beneficial for creating configurable and highly
    modular code.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application involves fixing some arguments of a function and creating
    a new function that requires fewer arguments. This approach is invaluable in scenarios
    where certain parameters are repeatedly used with the same values, as it simplifies
    function calls and reduces redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: If something is still not clear, use the examples provided in this chapter –
    modify them, experiment with them, and integrate them with your projects. In other
    words, see how it works in practice. Whether simplifying configuration management,
    making event handling more straightforward, or reducing the complexity of API
    interactions, currying and partial application can help you to reduce complexity
    in function calls, enhance code modularity and readability, and overall, bring
    your programs to the next level in terms of functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will sum up all we’ve learned about pipelines and composition
    from the previous chapters, add more real-world scenarios, and discuss more advanced
    topics such as error handling, testing, and performance consideration.
  prefs: []
  type: TYPE_NORMAL
