<html><head></head><body>
<div id="_idContainer098">
<h1 class="chapter-number" id="_idParaDest-132"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-133"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.2.1">Writing Structured and Correlated Logs</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Distributed tracing is a great tool to describe and correlate operations, but sometimes, we need to record things such as callbacks and startup configurations, or conditionally write debug information. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we’re going to explore logs – the oldest and most popular telemetry signal that can </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">describe anything.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">First, we’ll talk about logging use cases and discover different APIs available in .NET, and then we’ll focus on </span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">ILogger</span></strong><span class="koboSpan" id="kobo.7.1"> – a common logging façade. </span><span class="koboSpan" id="kobo.7.2">We’ll learn how to use it efficiently to write structured events. </span><span class="koboSpan" id="kobo.7.3">We’ll see how to export logs with OpenTelemetry and write rich queries over them. </span><span class="koboSpan" id="kobo.7.4">Finally, we’ll explore log sampling and </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">cost-saving strategies.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, you’ll learn </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">When to write logs and which .NET API </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">to use</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">How to write logs with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.14.1">Microsoft.Extentions.Logging.ILogger</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.15.1"> class</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">How to capture and export logs </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">with OpenTelemetry</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Cost-management strategies with the </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">OpenTelemetry Collector</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.20.1">By the end of this chapter, you will be able to efficiently instrument your application with logs and events to debug and analyze </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">service behavior.</span></span></p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.22.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.23.1">The code for this chapter is available in the book’s repository on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter8"><span class="No-Break"><span class="koboSpan" id="kobo.25.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter8</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.26.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">To run samples and perform analysis, we’ll need the </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">following tools:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.29.1">.NET SDK 7.0 </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">or later</span></span></li>
<li><span class="koboSpan" id="kobo.31.1">Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">docker-compose</span></strong></span></li>
</ul>
<h1 id="_idParaDest-135"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.34.1">Logging evolution in .NET</span></h1>
<p><span class="koboSpan" id="kobo.35.1">Logs are the</span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.36.1"> most flexible</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.37.1"> telemetry signal and usually include a timestamp, a level, a category, a message, and </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">sometimes attributes.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">Logs are frequently intended to be human-readable and don’t have a strict structure. </span><span class="koboSpan" id="kobo.39.2">Here’s an example of a log record written to </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">stdout</span></strong><span class="koboSpan" id="kobo.41.1"> by an ASP.NET </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">Core application:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.43.1">
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: http://localhost:5050</span></pre>
<p><span class="koboSpan" id="kobo.44.1">If we need to investigate something, we’d first look for logs describing interesting operations and then read the filtered logs. </span><span class="koboSpan" id="kobo.44.2">Our ability to understand what happened depends on how much context is logged and how searchable it is, with tools such </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">grep</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">Structured logs</span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.49.1"> are sometimes called </span><strong class="bold"><span class="koboSpan" id="kobo.50.1">events</span></strong><span class="koboSpan" id="kobo.51.1">. </span><span class="koboSpan" id="kobo.51.2">Events are intended to be queried, potentially across</span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.52.1"> multiple requests and based on any property, and need a strict and consistent structure. </span><span class="koboSpan" id="kobo.52.2">Here’s the previous log record in the OpenTelemetry </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">JSON format:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.54.1">
"timeUnixNano":"1673832588236902400",
"severityNumber":9, "severityText":"Information",
"body":{"stringValue":"Now listening on: {address}"},
"attributes":[
  {"key":"dotnet.ilogger.category",
     "value":{"stringValue":"Microsoft.Hosting.Lifetime"}},
  {"key":"Id","value":{"intValue":"14"},
  {"key":"address",
     "value":{"stringValue":"http://[::]:5050"}}], "traceId":"",
        "spanId":""}</span></pre>
<p><span class="koboSpan" id="kobo.55.1">It’s not human-readable, but even when written to </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">stdout</span></strong><span class="koboSpan" id="kobo.57.1"> or a file, it can be easily parsed into structured records without any prior knowledge of the semantics of </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">the event.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">As we started exploring in </span><a href="B19423_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.60.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.61.1">, </span><em class="italic"><span class="koboSpan" id="kobo.62.1">Observability Needs of Modern Applications</span></em><span class="koboSpan" id="kobo.63.1">, the difference between logs and events is semantical – the same information can be optimized and printed in human-readable format or stored and indexed in a database in a </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">structured format.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">We’re going to learn</span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.66.1"> how to write </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.67.1">such structured logs with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">Microsoft.Extensions.Logging.ILogger</span></strong><span class="koboSpan" id="kobo.69.1"> class, but first, let’s take a quick look at other logging APIs </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">in .NET.</span></span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.71.1">Console</span></h2>
<p><span class="koboSpan" id="kobo.72.1">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">System.Console</span></strong><span class="koboSpan" id="kobo.74.1"> class as a logger</span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.75.1"> and write everything to </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">stdout</span></strong><span class="koboSpan" id="kobo.77.1">. </span><span class="koboSpan" id="kobo.77.2">We’d need to implement all logging primitives from scratch and forward </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">stdout</span></strong><span class="koboSpan" id="kobo.79.1"> to the log management system, parsing it along the way to bring the original log structure back. </span><span class="koboSpan" id="kobo.79.2">Logging to </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">Console</span></strong><span class="koboSpan" id="kobo.81.1"> is neither a convenient nor an </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">efficient solution.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.83.1">Trace</span></h2>
<p><span class="koboSpan" id="kobo.84.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">System.Diagnostics.Trace</span></strong><span class="koboSpan" id="kobo.86.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">System.Diagnostics.TraceSource</span></strong><span class="koboSpan" id="kobo.88.1"> classes provide</span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.89.1"> methods to write messages, along with some arguments, and support logging levels. </span><span class="koboSpan" id="kobo.89.2">We can also listen to them with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">TraceListener</span></strong><span class="koboSpan" id="kobo.91.1"> class to export them to a log </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">management system.</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">It seems like a good start, but there are a couple </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">of limitations:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.95.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">TraceSource</span></strong><span class="koboSpan" id="kobo.97.1"> API does not provide a standard way to write arguments. </span><span class="koboSpan" id="kobo.97.2">So, it’s easy to format a message as a string, but we need to know specific event semantics to know </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">argument names.</span></span></li>
<li><span class="koboSpan" id="kobo.99.1">By default, </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">TraceSource</span></strong><span class="koboSpan" id="kobo.101.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">TraceListener</span></strong><span class="koboSpan" id="kobo.103.1"> use a global lock on every operation. </span><span class="koboSpan" id="kobo.103.2">It’s possible to use them in a lock-free way, but it might be easy to overlook until the load becomes</span><a id="_idIndexMarker472"/> <span class="No-Break"><span class="koboSpan" id="kobo.104.1">high enough.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.105.1">So, </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">Trace</span></strong><span class="koboSpan" id="kobo.107.1"> APIs solve some logging problems but introduce </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">new ones.</span></span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.109.1">EventSource</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">System.Diagnostics.Tracing.EventSource</span></strong><span class="koboSpan" id="kobo.111.1"> is another logging</span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.112.1"> API in .NET. </span><span class="koboSpan" id="kobo.112.2">It’s designed for high-performance scenarios, supports logging levels, and rich payloads, and captures the names and values of arguments. </span><span class="koboSpan" id="kobo.112.3">It’s possible to listen to it by implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">EventListener</span></strong><span class="koboSpan" id="kobo.114.1"> class or with .NET diagnostics tools running as a </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">side-car process.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">EventSource</span></strong><span class="koboSpan" id="kobo.117.1"> is a part of the .NET platform and can be used directly without any extra dependencies. </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">EventSource</span></strong><span class="koboSpan" id="kobo.119.1"> is a perfect candidate to log in libraries that don’t want to add any </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">new dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">When it comes to consumption, many observability vendors provide custom packages to listen to event sources, but there is no integration with OpenTelemetry yet, which is likely to change by the time you </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">read it.</span></span></p>
<p><span class="koboSpan" id="kobo.123.1">EventSource events can also be captured with </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">dotnet</span></strong><span class="koboSpan" id="kobo.125.1"> diagnostics tools – </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">dotnet-trace</span></strong><span class="koboSpan" id="kobo.127.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">dotnet-monitor</span></strong><span class="koboSpan" id="kobo.129.1"> – as we saw in </span><a href="B19423_04.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.130.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.131.1">, </span><em class="italic"><span class="koboSpan" id="kobo.132.1">Low-Level Performance Analysis with Diagnostic Tools</span></em><span class="koboSpan" id="kobo.133.1">, and </span><a href="B19423_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.134.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.135.1">, </span><em class="italic"><span class="koboSpan" id="kobo.136.1">Native Monitoring </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.137.1">in .NET</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">.</span></span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.139.1">ILogger</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">Microsoft.Extensions.Logging.ILogger</span></strong><span class="koboSpan" id="kobo.141.1"> is a common logging</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.142.1"> façade integrated</span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.143.1"> with ASP.NET Core. </span><span class="koboSpan" id="kobo.143.2">It supports structured logging and levels and has a rich ecosystem, making it easy to configure and send data to any provider, local </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">or remote.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">Logs written with </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">ILogger</span></strong><span class="koboSpan" id="kobo.147.1"> can be consumed from other logging libraries, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">Serilog</span></strong><span class="koboSpan" id="kobo.149.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">NLog</span></strong><span class="koboSpan" id="kobo.151.1">, and it’s also supported by OpenTelemetry. </span><span class="koboSpan" id="kobo.151.2">Many observability backends support </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">ILogger</span></strong><span class="koboSpan" id="kobo.153.1">, making it a perfect tool to write application </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">logs with.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">ILogger</span></strong><span class="koboSpan" id="kobo.156.1"> logs can be captured out of process with .NET diagnostics tools. </span><span class="koboSpan" id="kobo.156.2">This is done by forwarding logs to </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">EventSource</span></strong><span class="koboSpan" id="kobo.158.1"> first with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">Microsoft.Extensions.Logging.EventSource .EventSourceLoggingProvider</span></strong><span class="koboSpan" id="kobo.160.1"> class. </span><span class="koboSpan" id="kobo.160.2">This provider is enabled by default in ASP.NET Core applications, and you can configure it manually with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">AddEventSourceLogger</span></strong><span class="koboSpan" id="kobo.162.1"> extension method for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">ILoggingBuilder</span></strong><span class="koboSpan" id="kobo.164.1"> interface. </span><span class="koboSpan" id="kobo.164.2">We used this mechanism to capture</span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.165.1"> logs with </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">dotnet-monitor</span></strong><span class="koboSpan" id="kobo.167.1"> and control log verbosity</span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.168.1"> dynamically in </span><a href="B19423_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.169.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.170.1">, </span><em class="italic"><span class="koboSpan" id="kobo.171.1">Native Monitoring </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.172.1">in .NET</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">Let’s go through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">ILogger</span></strong><span class="koboSpan" id="kobo.176.1"> usage in </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">more detail.</span></span></p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.178.1">Logging with ILogger</span></h1>
<p><span class="koboSpan" id="kobo.179.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">ILogger</span></strong><span class="koboSpan" id="kobo.181.1"> class</span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.182.1"> is part</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.183.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">Microsoft.Extensions.Logging.Abstractions</span></strong><span class="koboSpan" id="kobo.185.1"> NuGet package. </span><span class="koboSpan" id="kobo.185.2">If you work on an ASP.NET Core application, worker service, or use other </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">Microsoft.Extensions</span></strong><span class="koboSpan" id="kobo.187.1"> packages, you already depend on </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">it transitively.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">ILogger</span></strong><span class="koboSpan" id="kobo.191.1"> interface exposes a </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">few methods:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">Log</span></strong><span class="koboSpan" id="kobo.194.1"> records a log message with a given level, ID, exception, state, and formatter. </span><span class="koboSpan" id="kobo.194.2">The state type is generic but should contain a message, along with all the parameters and </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">their names.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">IsEnabled</span></strong><span class="koboSpan" id="kobo.197.1"> checks whether logging at this level </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">is enabled.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">BeginScope</span></strong><span class="koboSpan" id="kobo.200.1"> adds an object to the logging scope, allowing you to enrich nested log records with it. </span><span class="koboSpan" id="kobo.200.2">We saw scopes in action in </span><a href="B19423_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.201.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.202.1">, </span><em class="italic"><span class="koboSpan" id="kobo.203.1">Native Monitoring in .NET</span></em><span class="koboSpan" id="kobo.204.1">, where we annotated console logs with trace context and ASP.NET Core </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">request information.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.206.1">It’s common to use convenient extension methods defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">Microsoft.Extensions.Logging.LoggerExtensions</span></strong><span class="koboSpan" id="kobo.208.1"> class instead of the vanilla </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">ILogger.Log</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.210.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">Before writing any logs, let’s first obtain an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">ILogger</span></strong><span class="koboSpan" id="kobo.213.1"> – in ASP.NET Core applications, we can do it with constructor parameter injection, as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">this example:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.215.1">frontend/RetryHandler.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.216.1">
private readonly ILogger&lt;RetryHandler&gt; _logger;
public RetryHandler(ILogger&lt;RetryHandler&gt; logger) =&gt;
    _logger = logger;</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter8/memes/frontend/RetryHandler.cs "><span class="koboSpan" id="kobo.217.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter8/memes/frontend/RetryHandler.cs</span></a></p>
<p><span class="koboSpan" id="kobo.218.1">Here, we obtain an </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">ILogger</span></strong><span class="koboSpan" id="kobo.220.1"> instance with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">RetryHandler</span></strong><span class="koboSpan" id="kobo.222.1"> type parameter. </span><span class="koboSpan" id="kobo.222.2">The full name of the type</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.223.1"> parameter translates into the logging </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">category</span></strong><span class="koboSpan" id="kobo.225.1">, which is important to control verbosity and query logs, as we’ll see later in the </span><em class="italic"><span class="koboSpan" id="kobo.226.1">Capturing logs with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.227.1">OpenTelemetry</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.228.1"> section.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.229.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.230.1">Please refer</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.231.1"> to the .NET documentation at </span><a href="https://learn.microsoft.com/aspnet/core/fundamentals/logging"><span class="koboSpan" id="kobo.232.1">https://learn.microsoft.com/aspnet/core/fundamentals/logging</span></a><span class="koboSpan" id="kobo.233.1"> to learn how to create and </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">configure loggers.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">Now, we can finally</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.236.1"> log things. </span><span class="koboSpan" id="kobo.236.2">For example, we</span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.237.1"> can write an information log with </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">_logger.LogInformation("hello world")</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.240.1">If you use standard logging implementation, this call is broadcast to all registered logging providers that have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">Information</span></strong><span class="koboSpan" id="kobo.242.1"> level enabled for this </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">logging category.</span></span></p>
<p><span class="koboSpan" id="kobo.244.1">Filters are provided at configuration time and can be global or specific to the logging provider. </span><span class="koboSpan" id="kobo.244.2">For example, here’s a global logging configuration in our </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">memes application:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.246.1">frontend/appsettings.json</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.247.1">
"Logging": {
  "LogLevel": {
    "frontend": "Information",
    "Microsoft.Hosting.Lifetime": "Information",
    "Default": "Warning"
  }
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter8/memes/frontend/appsettings.json "><span class="koboSpan" id="kobo.248.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter8/memes/frontend/appsettings.json</span></a></p>
<p><span class="koboSpan" id="kobo.249.1">This global configuration sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">Information</span></strong><span class="koboSpan" id="kobo.251.1"> level for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">frontend</span></strong><span class="koboSpan" id="kobo.253.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">Microsoft.Hosting.Lifetime</span></strong><span class="koboSpan" id="kobo.255.1"> categories and </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">Warning</span></strong><span class="koboSpan" id="kobo.257.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">everything else.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">Let’s get back to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">ILogger</span></strong><span class="koboSpan" id="kobo.261.1"> API and see how</span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.262.1"> we can write more useful logs. </span><span class="koboSpan" id="kobo.262.2">For example, let’s log</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.263.1"> debug messages for error responses that include a </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">response body.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">We should be cautious here – a body stream usually can only be read once and can be very long, but in any case, we should be able to control any overhead that </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">is introduced:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.267.1">frontend/RetryHandler.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.268.1">
if (!response.IsSuccessStatusCode &amp;&amp;
     _logger.IsEnabled(LogLevel.Debug))
  _logger.LogDebug("got response: {status} {body} {url}",
    (int)response.StatusCode,
    await response.Content.ReadAsStringAsync(),
    response.RequestMessage?.RequestUri);
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter8/memes/frontend/RetryHandler.cs"><span class="koboSpan" id="kobo.269.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter8/memes/frontend/RetryHandler.cs</span></a></p>
<p><span class="koboSpan" id="kobo.270.1">Here, we write the log record at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">Debug</span></strong><span class="koboSpan" id="kobo.272.1"> level and check whether the level is enabled </span><em class="italic"><span class="koboSpan" id="kobo.273.1">before</span></em><span class="koboSpan" id="kobo.274.1"> reading</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.275.1"> the response stream. </span><span class="koboSpan" id="kobo.275.2">We also use </span><strong class="bold"><span class="koboSpan" id="kobo.276.1">semantic</span></strong><span class="koboSpan" id="kobo.277.1"> (aka structured) logging, providing parameter names in curly brackets in the message string and their values </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">as arguments.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.279.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.280.1">Make sure to use semantic logging. </span><span class="koboSpan" id="kobo.280.2">String interpolation or explicit formatting for </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">ILogger</span></strong><span class="koboSpan" id="kobo.282.1"> messages removes the structure and makes performance optimization based on logging </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">level impossible.</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">Arguments are passed as objects. </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">ILogger</span></strong><span class="koboSpan" id="kobo.286.1"> implementations, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">OpenTelemetryLogger</span></strong><span class="koboSpan" id="kobo.288.1">, support some types and usually call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">ToString</span></strong><span class="koboSpan" id="kobo.290.1"> method on everything else. </span><span class="koboSpan" id="kobo.290.2">If logging at this level is not enabled, </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">ToString</span></strong><span class="koboSpan" id="kobo.292.1"> is never called, saving you some CPU cycles and </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">memory allocations.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">Guarding logging</span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.295.1"> calls, along with the retrieval or computation of arguments</span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.296.1">, with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">IsEnabled</span></strong><span class="koboSpan" id="kobo.298.1"> check, is a great way to keep the performance impact of disabled categories </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">very low.</span></span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.300.1">Optimizing logging</span></h2>
<p><span class="koboSpan" id="kobo.301.1">Logging-related code</span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.302.1"> frequently becomes a source of performance degradation. </span><span class="koboSpan" id="kobo.302.2">Avoiding memory allocations and the computation of arguments, especially when logging at this level is disabled, is the first step, but we should also optimize logging on the hot path when it’s enabled. </span><span class="koboSpan" id="kobo.302.3">Here’re a few tips </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">for it:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.304.1">Avoid excessive logging</span></strong><span class="koboSpan" id="kobo.305.1">: You might need to write a log record when entering an important code branch, a callback is called, or an exception is caught. </span><span class="koboSpan" id="kobo.305.2">Avoid logging exceptions multiple times as they propagate, or logging the same callback in </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">nested methods.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.307.1">Avoid duplication</span></strong><span class="koboSpan" id="kobo.308.1">: Unify multiple logs related to the same operation, and use logs coming from ASP.NET Core and other libraries when they are available, instead of adding </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">your own.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.310.1">Avoid calculating any values for logging purposes only</span></strong><span class="koboSpan" id="kobo.311.1">: It’s common to serialize objects and parse or format strings, but this can usually be optimized by reusing existing objects, caching values, or formatting text at </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">query time.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.313.1">Finally, when log volume and arguments are optimized, we can do some micro-optimizations. </span><span class="koboSpan" id="kobo.313.2">One of them uses compile-time logging source generation and is demonstrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">following example:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.315.1">StorageService.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.316.1">
[LoggerMessage(EventId = 1, Level = LogLevel.Information,
  Message = "download {memeSize} {memeName}")]
private partial void DownloadMemeEvent(long? </span><span class="koboSpan" id="kobo.316.2">memeSize,
  string memeName);</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter8/memes/frontend/StorageService.cs"><span class="koboSpan" id="kobo.317.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter8/memes/frontend/StorageService.cs</span></a></p>
<p><span class="koboSpan" id="kobo.318.1">Here, we defined a partial method</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.319.1"> and annotated it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">LoggerMessage</span></strong><span class="koboSpan" id="kobo.321.1"> attribute, providing an event ID, level, and message. </span><span class="koboSpan" id="kobo.321.2">The implementation of this method is generated</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.322.1"> at compile time (you can find more information on it in the .NET documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">at </span></span><a href="https://learn.microsoft.com/dotnet/core/extensions/logger-message-generator"><span class="No-Break"><span class="koboSpan" id="kobo.324.1">https://learn.microsoft.com/dotnet/core/extensions/logger-message-generator</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.325.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">If we check the generated code, we can see that it caches logger calls along with their static arguments. </span><span class="koboSpan" id="kobo.326.2">Please</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.327.1"> refer to the .NET documentation available at </span><a href="https://learn.microsoft.com/dotnet/core/extensions/high-performance-logging"><span class="koboSpan" id="kobo.328.1">https://learn.microsoft.com/dotnet/core/extensions/high-performance-logging</span></a><span class="koboSpan" id="kobo.329.1"> for more details on </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">this approach.</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">We can compare the performance of different logging approaches by running </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">logging-benchmark$ dotnet run -c Release</span></strong><span class="koboSpan" id="kobo.333.1"> and checking the results in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">BenchmarkDotNet.Artifacts</span></strong><span class="koboSpan" id="kobo.335.1"> folder. </span><span class="koboSpan" id="kobo.335.2">The benchmark uses a dummy logger and measures the instrumentation side only. </span><span class="koboSpan" id="kobo.335.3">If we compare results for compile-time logging source generation and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">LogInformation</span></strong><span class="koboSpan" id="kobo.337.1"> (or similar) method, we’ll see the </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">following results:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.339.1">Compile-time logging source generation eliminates memory allocations on the instrumentation side, even when logging is enabled. </span><span class="koboSpan" id="kobo.339.2">As a result, GC becomes less frequent, leading to higher throughput and smaller </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">P95 latency.</span></span></li>
<li><span class="koboSpan" id="kobo.341.1">With compile-time logging source generation, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">IsEnabled</span></strong><span class="koboSpan" id="kobo.343.1"> check is not needed if the argument values are </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">readily available.</span></span></li>
<li><span class="koboSpan" id="kobo.345.1">The duration of an individual log call, when logging is enabled, does not depend much on the </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">approach used.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.347.1">These results may vary, depending</span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.348.1"> on the argument types and values. </span><span class="koboSpan" id="kobo.348.2">Make sure to run performance, stress, and load tests, or profile your application with a similar logging configuration as used </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">in production.</span></span></p>
<p><span class="koboSpan" id="kobo.350.1">Now, you’re fully equipped to write logs, so it’s time to explore the </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">consumption side.</span></span></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.352.1">Capturing logs with OpenTelemetry</span></h1>
<p><span class="koboSpan" id="kobo.353.1">By default, ASP.NET Core</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.354.1"> applications write logs to </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">stdout</span></strong><span class="koboSpan" id="kobo.356.1">, but since we want</span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.357.1"> to correlate them with traces and query them by any attribute, we should export them to the observability backend or the log management tool that supports it. </span><span class="koboSpan" id="kobo.357.2">If your vendor supports </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">ILogger</span></strong><span class="koboSpan" id="kobo.359.1">, you can send logs directly to your vendor by configuring the corresponding logging provider. </span><span class="koboSpan" id="kobo.359.2">It will be up to this logging provider to annotate logs with trace context or environment information. </span><span class="koboSpan" id="kobo.359.3">By collecting logs with OpenTelemetry, we can annotate them consistently with </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">other signals.</span></span></p>
<p><span class="koboSpan" id="kobo.361.1">Let’s see how to collect logs from the meme application with OpenTelemetry. </span><span class="koboSpan" id="kobo.361.2">To get the most</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.362.1"> out of the structure, we’ll export them to </span><strong class="bold"><span class="koboSpan" id="kobo.363.1">ClickHouse</span></strong><span class="koboSpan" id="kobo.364.1"> – an open source database that supports </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">SQL queries.</span></span></p>
<p><span class="koboSpan" id="kobo.366.1">Here’s an example</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.367.1"> of a configuration that exports logs with the </span><strong class="bold"><span class="koboSpan" id="kobo.368.1">OpenTelemetry Protocol</span></strong><span class="koboSpan" id="kobo.369.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.370.1">OTLP</span></strong><span class="koboSpan" id="kobo.371.1">) exporter to the OpenTelemetry </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">Collector first:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.373.1">frontend/Program.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.374.1">
builder.Logging.AddOpenTelemetry(b =&gt; {
  b.SetResourceBuilder(resource);
  b.ParseStateValues = true;
  b.AddOtlpExporter();
});</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter8/memes/frontend/Program.cs"><span class="koboSpan" id="kobo.375.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter8/memes/frontend/Program.cs</span></a></p>
<p><span class="koboSpan" id="kobo.376.1">Here, we added an OpenTelemetry logging provider to the application’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">ILoggingBuilder</span></strong><span class="koboSpan" id="kobo.378.1"> instance and then configured the provider. </span><span class="koboSpan" id="kobo.378.2">We configured resource attributes, enabled parsing state values to populate arguments, and added the OTLP exporter. </span><span class="koboSpan" id="kobo.378.3">The exporter endpoint is configured with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">OTEL_EXPORTER_OTLP_ENDPOINT</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.380.1">environment variable.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">The OpenTelemetry Collector is configured to send all logs to a file and write sampled logs to ClickHouse – we’ll look into its configuration in the </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.383.1">Let’s go ahead and run the memes application with </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">memes$ docker-compose up --build</span></strong><span class="koboSpan" id="kobo.385.1">. </span><span class="koboSpan" id="kobo.385.2">Then, we’ll hit the frontend at </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">http://localhost:5051/</span></strong><span class="koboSpan" id="kobo.387.1"> to upload and download </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">some memes.</span></span></p>
<p><span class="koboSpan" id="kobo.389.1">To query logs in ClickHouse, run </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">$ docker exec -it memes-clickhouse-1 /usr/bin/clickhouse-client</span></strong><span class="koboSpan" id="kobo.391.1"> – this will start a client</span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.392.1"> where we can write SQL</span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.393.1"> queries, such as the following one, that return all </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">log records:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.395.1">
$ select * from otel_logs order by Timestamp desc</span></pre>
<p><span class="koboSpan" id="kobo.396.1">Here’s an example of the output – the download meme log we added earlier in this chapter (if you don’t see it, keep in mind that logs are sampled and you might need to download </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">more memes):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.398.1">
│ 2023-01-17 03:28:37.446217500 │ 1bf63116f826fcc34a1e255
4b633580e │ 2a6bbdfee21d260a │         1 │ Information │ 9
│ frontend │ download {memeSize} {memeName}│
{'service.instance.id':'833fb55a4717','service.name':'front
end'} │ {'dotnet.ilogger.category':'frontend
.StorageService',
'Id':'1','Name':'DownloadMemeEvent',
'memeSize':'65412', 'memeName':'this is fine'}</span></pre>
<p><span class="koboSpan" id="kobo.399.1">It’s barely readable but easy to query, as it includes a timestamp, a trace context, a log level, a body, resource information, and attributes – an event name, an ID, a meme size, and </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">a name.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.401.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.402.1">At the time of writing, OpenTelemetry log specification is still experimental, so .NET implementation is minimal and details might change; the ClickHouse exporter is in alpha status, and the table schema could change in </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">later versions.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">We didn’t enable capturing logging scopes; otherwise, we’d also see a few of them as attributes. </span><span class="koboSpan" id="kobo.404.2">They’re populated by ASP.NET Core and describe incoming HTTP request properties. </span><span class="koboSpan" id="kobo.404.3">As we saw in </span><a href="B19423_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.405.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.406.1">, </span><em class="italic"><span class="koboSpan" id="kobo.407.1">Native Monitoring in .NET</span></em><span class="koboSpan" id="kobo.408.1">, scopes include trace-context, which OpenTelemetry captures for </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">us anyway.</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">With this, we can correlate logs using trace context or any attributes. </span><span class="koboSpan" id="kobo.410.2">For example, we can find the most popular memes with a query such </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">as this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.412.1">
select LogAttributes['memeName'], count(*) as downloads
from otel_logs
where ServiceName='frontend' and
  LogAttributes['Name']='DownloadMemeEvent'
group by LogAttributes['memeName'] order by downloads desc
limit 3</span></pre>
<p><span class="koboSpan" id="kobo.413.1">This can be useful when making business or technical decisions. </span><span class="koboSpan" id="kobo.413.2">For example, it helps to optimize caching or partitioning strategy, or </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">plan capacity.</span></span></p>
<p><span class="koboSpan" id="kobo.415.1">We can write queries</span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.416.1"> such as these because we have enough structure</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.417.1"> in our logs, including an optional event ID and name. </span><span class="koboSpan" id="kobo.417.2">If we didn’t have them, we’d have to filter logs based on message text, which is neither efficient nor reliable. </span><span class="koboSpan" id="kobo.417.3">For example, when someone changes the message when fixing a typo or adding new arguments, all saved queries need to be changed to </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">reflect this.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.419.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.420.1">To make logs queryable, make sure to use semantic logging. </span><span class="koboSpan" id="kobo.420.2">Provide a static event ID and name. </span><span class="koboSpan" id="kobo.420.3">Use consistent (across the whole system) </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">attribute names.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">By following this approach, we can change observability vendors, print logs in human-readable format, and, at the same time, store them in a structured form, post-process them, or aggregate them </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">if needed.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">Structured logs</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.425.1"> combined with traces allow us to report business</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.426.1"> telemetry and run queries, but it brings new costs – let’s see how we can </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">control them.</span></span></p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.428.1">Managing logging costs</span></h1>
<p><span class="koboSpan" id="kobo.429.1">Similarly to tracing</span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.430.1"> and metrics, logging increases the compute resources needed to run an application, the cost of running a logging pipeline (if any), and the costs associated with using (or running) an observability backend. </span><span class="koboSpan" id="kobo.430.2">Vendor pricing is frequently based on a combination of telemetry volume, retention time, and API calls, </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">including queries.</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">We already know how to write logs efficiently, so let’s talk about pipelines </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">and backends.</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.434.1">Pipelines</span></h2>
<p><span class="koboSpan" id="kobo.435.1">A logging pipeline</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.436.1"> consists of the infrastructure needed to send logs to the backend</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.437.1"> of your choice. </span><span class="koboSpan" id="kobo.437.2">It’s typical to do some grokking, parsing, transformations, buffering, throttling, and hardening on the way to </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">the backend.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">In a simple case, it’s all done by your vendor’s logging provider or the OpenTelemetry processors and exporter inside </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">the process.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">In many cases, we need logging pipelines to capture logs and events coming from outside – the OS, self-hosted third-party services, proxies, and other infrastructure pieces. </span><span class="koboSpan" id="kobo.441.2">They could be structured such as Kubernetes events, have a well-known configurable format such as HTTP server logs, or have no structure </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">at all.</span></span></p>
<p><span class="koboSpan" id="kobo.443.1">A logging pipeline can help parse such logs and transform them into a common format. </span><span class="koboSpan" id="kobo.443.2">In the OpenTelemetry world, this could be done on </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">the Collector.</span></span></p>
<p><span class="koboSpan" id="kobo.445.1">We would  receive logs from </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">files</span></strong><span class="koboSpan" id="kobo.447.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">syslog</span></strong><span class="koboSpan" id="kobo.449.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">journald</span></strong><span class="koboSpan" id="kobo.451.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">fluentd</span></strong><span class="koboSpan" id="kobo.453.1">, other</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.454.1"> systems, or collectors with a </span><strong class="bold"><span class="koboSpan" id="kobo.455.1">receiver</span></strong><span class="koboSpan" id="kobo.456.1">, then massage, filter, and route them with a </span><strong class="bold"><span class="koboSpan" id="kobo.457.1">processor</span></strong><span class="koboSpan" id="kobo.458.1">, and finally, export them</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.459.1"> to the </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">final destination.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">Cost-saving strategies for pipelines start with a typical approach to minimize log volume and avoid duplication and complex transformations, as we discussed earlier in </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">For example, you might enable HTTP tracing, metrics, and logs from both a client and server and logs from the HTTP proxy as well. </span><span class="koboSpan" id="kobo.463.2">Do you need logs from the proxy? </span><span class="koboSpan" id="kobo.463.3">Do you </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">use them?</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">Eliminate duplicates by potentially substituting them with metrics, less verbose events, or attributes on other signals. </span><span class="koboSpan" id="kobo.465.2">If some information is rarely needed, process </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">it lazily.</span></span></p>
<p><span class="koboSpan" id="kobo.467.1">It’s also important to monitor your logging pipeline – measure the error rate and estimate the end-to-end latency and throughput. </span><span class="koboSpan" id="kobo.467.2">The OpenTelemetry Collector helps by exposing its own metrics </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">and logs.</span></span></p>
<p><span class="koboSpan" id="kobo.469.1">Once, the team I worked</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.470.1"> on discovered that some logs had dropped at an ~80% rate within</span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.471.1"> the logging pipeline. </span><span class="koboSpan" id="kobo.471.2">We published them in a fire-and-forget manner and didn’t even know they were dropped  until we were not able to investigate incidents </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">in production.</span></span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.473.1">Backends</span></h2>
<p><span class="koboSpan" id="kobo.474.1">Backend</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.475.1"> cost optimization</span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.476.1"> also starts by producing as few logs as possible. </span><span class="koboSpan" id="kobo.476.2">Then, costs can be controlled in different ways, depending on your constraints and observability backend </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">pricing model:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.478.1">The log volume can be reduced with sampling. </span><span class="koboSpan" id="kobo.478.2">Aggregations based on sampled events would need to be scaled accordingly but would provide unskewed results when unbiased sampling is used. </span><span class="koboSpan" id="kobo.478.3">Logs can be sampled consistently with traces at the same or a </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">higher rate.</span></span></li>
<li><span class="koboSpan" id="kobo.480.1">Logs can stay in hot storage for a short period of time and then move to cold storage. </span><span class="koboSpan" id="kobo.480.2">During the first few days, logs in hot storage can be used for urgent ad hoc queries, but after that, query speed becomes </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">less important.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.482.1">This strategy can be combined with sampling – logs could be sent to the cold (and cheap) storage, while sampled in logs would go to hot storage.</span></p>
<ul>
<li><span class="koboSpan" id="kobo.483.1">Certain logs can be post-processed and aggregated into metrics or reports for </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">frequent queries.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.485.1">All these strategies and combinations of them can be implemented with the OpenTelemetry Collector. </span><span class="koboSpan" id="kobo.485.2">For example, in our memes application, we use a combination of sampling and hot/cold storage, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.486.1">Figure 8</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.487.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer097">
<span class="koboSpan" id="kobo.489.1"><img alt="Figure 8.1 – Logging pipelines with sampling and hot and cold storage" src="image/B19423_08_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.490.1">Figure 8.1 – Logging pipelines with sampling and hot and cold storage</span></p>
<p><span class="koboSpan" id="kobo.491.1">We have two different logging pipelines</span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.492.1"> here. </span><span class="koboSpan" id="kobo.492.2">Both start with the OTLP receiver and batch</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.493.1"> processor. </span><span class="koboSpan" id="kobo.493.2">Then, one pipeline writes all logs to a file, and another one runs a filter based on log record properties. </span><span class="koboSpan" id="kobo.493.3">It checks </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">trace-flags</span></strong><span class="koboSpan" id="kobo.495.1"> and drops logs when the parent span is not recorded. </span><span class="koboSpan" id="kobo.495.2">Logs with a recorded parent (or those that have no parent at all, such as startup logs) end up in ClickHouse. </span><span class="koboSpan" id="kobo.495.3">Here’s the corresponding logging </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">pipeline configuration:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.497.1">otel-collector-config.yml</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.498.1">
logs:
  receivers: [otlp]
  processors: [batch]
  exporters: [file]
logs/sampled:
  receivers: [otlp]
  processors: [batch, filter]
  exporters: [clickhouse]</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter8/memes/configs/otel-collector-config.yml"><span class="koboSpan" id="kobo.499.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter8/memes/configs/otel-collector-config.yml</span></a></p>
<p><span class="koboSpan" id="kobo.500.1">The filter processor, and many other</span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.501.1"> processors, leverage a rich transformation language – </span><strong class="bold"><span class="koboSpan" id="kobo.502.1">OTTL</span></strong><span class="koboSpan" id="kobo.503.1">. </span><span class="koboSpan" id="kobo.503.2">OTTL can be used to rename</span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.504.1"> attributes, change their values, drop metrics</span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.505.1"> and spans, create derived metrics, or add and drop attributes. </span><span class="koboSpan" id="kobo.505.2">Here’s the filter </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">processor configuration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.507.1">
filter:
  logs:
    log_record:
      - 'flags == 0 and trace_id != TraceID
        (0x00000000000000000000000000000000)'</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter8/memes/configs/otel-collector-config.yml"><span class="koboSpan" id="kobo.508.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter8/memes/configs/otel-collector-config.yml</span></a></p>
<p><span class="koboSpan" id="kobo.509.1">The collector can solve many common post-processing needs and take this burden away from </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">your service.</span></span></p>
<p><span class="koboSpan" id="kobo.511.1">That brings us to the end of this chapter. </span><span class="koboSpan" id="kobo.511.2">Let’s recollect what we’ve learned </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">so far.</span></span></p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.513.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.514.1">Logs are the most flexible telemetry signal – they can be used to write information in human-readable format, complement traces with more information, or record structured events to analyze usage </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">or performance.</span></span></p>
<p><span class="koboSpan" id="kobo.516.1">To write logs, we can use different logging APIs – </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">ILogger</span></strong><span class="koboSpan" id="kobo.518.1"> works best for application code, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">EventSource</span></strong><span class="koboSpan" id="kobo.520.1"> is usually the best choice </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">for libraries.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">ILogger</span></strong><span class="koboSpan" id="kobo.523.1"> makes it easy to write structured logs efficiently, but it depends on application authors to do so by minimizing log volume and the operations needed to calculate </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">logging arguments.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">ILogger</span></strong><span class="koboSpan" id="kobo.526.1"> has a rich ecosystem of integrations with .NET frameworks, libraries, and providers that can send logs almost anywhere in a flat or </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">structured format.</span></span></p>
<p><span class="koboSpan" id="kobo.528.1">Collecting and exporting </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">ILogger</span></strong><span class="koboSpan" id="kobo.530.1"> logs with OpenTelemetry produces logs that are consistent and correlated with other </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">telemetry signals.</span></span></p>
<p><span class="koboSpan" id="kobo.532.1">In addition to application logs, we usually also need to collect logs from infrastructure or legacy systems. </span><span class="koboSpan" id="kobo.532.2">We can do it with the OpenTelemetry Collector, which allows us to collect and unify logs from multiple destinations. </span><span class="koboSpan" id="kobo.532.3">The Collector’s logging pipelines can throttle, aggregate, or route logs to help you manage your </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">logging costs.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">You should now be ready to efficiently instrument your application with structured logs and export them with OpenTelemetry. </span><span class="koboSpan" id="kobo.534.2">You’re also prepared to build logging pipelines with OpenTelemetry to add observability to your infrastructure and control </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">logging costs.</span></span></p>
<p><span class="koboSpan" id="kobo.536.1">This concludes our deep dive into individual telemetry signals. </span><span class="koboSpan" id="kobo.536.2">In the next chapter, we’ll talk about choosing a good set of telemetry signals, depending on a scenario, and adding the right level of information, based on OpenTelemetry </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">semantic conventions.</span></span></p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.538.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.539.1">Is the following code snippet correct? </span><span class="koboSpan" id="kobo.539.2">How would you </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">improve it?</span></span><pre class="console"><span class="koboSpan" id="kobo.541.1">
var foo = 42;</span></pre><pre class="console"><span class="koboSpan" id="kobo.542.1">
var bar = "bar";</span></pre><pre class="console"><span class="koboSpan" id="kobo.543.1">
logger.LogInformation($"hello world: {foo}, {bar}");</span></pre></li>
<li><span class="koboSpan" id="kobo.544.1">Let’s say your application writes usage events using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">ILogger</span></strong><span class="koboSpan" id="kobo.546.1"> APIs. </span><span class="koboSpan" id="kobo.546.2">Events are exported somewhere and then used to build business-critical reports. </span><span class="koboSpan" id="kobo.546.3">As your application evolves, you will probably refactor code, rename namespaces and classes, improve log messages, and add more arguments. </span><span class="koboSpan" id="kobo.546.4">How can you write logs to keep the usage report resilient to </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">logging changes?</span></span></li>
<li><span class="koboSpan" id="kobo.548.1">Assuming that traces for HTTP requests are collected, do you also need to write logs for the same </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">HTTP calls?</span></span></li>
</ol>
</div>


<div class="Content" id="_idContainer099">
<h1 id="_idParaDest-148"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.1.1">Part 3: Observability for Common Cloud Scenarios</span></h1>
</div>
<div id="_idContainer100">
<p><span class="koboSpan" id="kobo.2.1">This part provides instrumentation recipes for common scenarios such as network calls, async messaging, databases, and web clients. </span><span class="koboSpan" id="kobo.2.2">It demonstrates how to write your own instrumentation or cover a gap in an automatic one, and, most importantly, how to investigate performance issues using a combination of distributed tracing, metrics, </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">and logs.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B19423_09.xhtml#_idTextAnchor148"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Best Practices</span></em></li>
<li><a href="B19423_10.xhtml#_idTextAnchor161"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Tracing Network Calls</span></em></li>
<li><a href="B19423_11.xhtml#_idTextAnchor174"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 11</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Instrumenting Messaging Scenarios</span></em></li>
<li><a href="B19423_12.xhtml#_idTextAnchor192"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 12</span></em></a><span class="koboSpan" id="kobo.16.1">, </span><em class="italic"><span class="koboSpan" id="kobo.17.1">Instrumenting Database Calls</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer101">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer102">
</div>
</div>
<div>
<div id="_idContainer103">
</div>
</div>
</body></html>