<html><head></head><body>
<div id="_idContainer038">
<h1 class="chapter-number" id="_idParaDest-46"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.2.1">Refactoring Code Flow and Iteration</span></h1>
<p><span class="koboSpan" id="kobo.3.1">While other chapters in </span><em class="italic"><span class="koboSpan" id="kobo.4.1">Part 1</span></em><span class="koboSpan" id="kobo.5.1"> focus on refactorings that can be applied to entire methods or classes, this chapter focuses on improving the readability and efficiency of individual lines </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">of code.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Developers spend the majority of their time reading over individual lines of code and only a fraction of that time modifying code. </span><span class="koboSpan" id="kobo.7.2">So, it is important to make our lines of code as maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">as possible.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we’ll explore the following topics related to improving small pieces </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">of code:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Controlling </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">program flow</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.13.1">Instantiating objects</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Iterating </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">over collections</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Refactoring </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">LINQ statements</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Reviewing and testing our </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">refactored code</span></span></li>
</ul>
<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.20.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.21.1">The starting code for this chapter is available from GitHub at </span><a href="https://github.com/PacktPublishing/Refactoring-with-CSharp"><span class="koboSpan" id="kobo.22.1">https://github.com/PacktPublishing/Refactoring-with-CSharp</span></a><span class="koboSpan" id="kobo.23.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.24.1">Chapter03/Ch3BeginningCode</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.25.1"> folder.</span></span></p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.26.1">Refactoring the boarding app</span></h1>
<p><span class="koboSpan" id="kobo.27.1">This chapter’s code focuses on a pair of</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.28.1"> applications for Cloudy </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">Skies Airline:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.30.1">A </span><em class="italic"><span class="koboSpan" id="kobo.31.1">Boarding Status Display</span></em><span class="koboSpan" id="kobo.32.1"> app that tells the user if it’s time for them to board their flight based on the current boarding group and the person’s ticket, military status, and whether or not they need assistance getting down </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">the jetway.</span></span></li>
<li><span class="koboSpan" id="kobo.34.1">A </span><em class="italic"><span class="koboSpan" id="kobo.35.1">Boarding Kiosk</span></em><span class="koboSpan" id="kobo.36.1"> app that allows airline employees to view the passengers scheduled to be on the flight and </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.37.1">provides information regarding whether each passenger has boarded. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.38.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.39.1">.1</span></em><span class="koboSpan" id="kobo.40.1"> shows the application </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">in action:</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.42.1"><img alt="Figure 3.1 – The Boarding Kiosk app" src="image/B21324_03_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.43.1">Figure 3.1 – The Boarding Kiosk app</span></p>
<p><span class="koboSpan" id="kobo.44.1">Since we’re exploring not one but two applications, we’ll meet the application code in small chunks as we progress through this chapter. </span><span class="koboSpan" id="kobo.44.2">However, feel free to peruse it yourself on GitHub if you’d like to orient </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">yourself first.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">As we go through this chapter, we’ll take its existing functioning code and see how small refactoring steps can improve the maintainability of the code using various C# </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">language features.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">We’ll start by looking at how refactoring can improve the overall flow </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">of code.</span></span></p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.50.1">Controlling program flow</span></h1>
<p><span class="koboSpan" id="kobo.51.1">One of the most basic things new developers learn is how programs execute lines of code in sequence and how </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">if statements</span></strong><span class="koboSpan" id="kobo.53.1"> and other</span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.54.1"> language features control what statements </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">execute </span></span><span class="No-Break"><a id="_idIndexMarker097"/></span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">next.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">In this section, we’ll focus on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">BoardingProcessor</span></strong><span class="koboSpan" id="kobo.59.1"> class's </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">CanPassengerBoard</span></strong><span class="koboSpan" id="kobo.61.1"> method. </span><span class="koboSpan" id="kobo.61.2">The method starts </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">simple enough:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.63.1">
public string CanPassengerBoard(Passenger passenger) {
  bool isMilitary = passenger.IsMilitary;
  bool needsHelp = passenger.NeedsHelp;
  int group = passenger.BoardingGroup;</span></pre>
<p><span class="koboSpan" id="kobo.64.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">CanPassengerBoard</span></strong><span class="koboSpan" id="kobo.66.1"> takes in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">Passenger</span></strong><span class="koboSpan" id="kobo.68.1"> object and returns a string. </span><span class="koboSpan" id="kobo.68.2">The method also declares a few local variables holding pieces of data from the object </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">passed in.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">These variables aren’t necessary and could be removed by performing an inline variable refactoring, which we’ll talk about later in this chapter. </span><span class="koboSpan" id="kobo.70.2">However, as they improve the readability of the code that follows, their existence is largely helpful. </span><span class="koboSpan" id="kobo.70.3">This is part of the reason why we sometimes introduce local variables, as we covered in </span><a href="B21324_02.xhtml#_idTextAnchor026"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.71.1">Chapter 2</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.72.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">The logic that follows gets significantly harder to read, as </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">seen here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.75.1">
 if (Status != BoardingStatus.PlaneDeparted) {
   if (isMilitary &amp;&amp; Status == BoardingStatus.Boarding) {
      return "Board Now via Priority Lane";
   } else if (needsHelp&amp;&amp;Status==BoardingStatus.Boarding) {
      return "Board Now via Priority Lane";
   } else if (Status == BoardingStatus.Boarding) {
      if (CurrentBoardingGroup &gt;= group) {
         if (_priorityLaneGroups.Contains(group)) {
            return "Board Now via Priority Lane";
         } else {
           return "Board Now";
         }
      } else {
         return "Please Wait";
      }
   } else {
      return "Boarding Not Started";
   }
 } else {
   return "Flight Departed";
 }
}</span></pre>
<p><span class="koboSpan" id="kobo.76.1">This method primarily uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">if</span></strong><span class="koboSpan" id="kobo.78.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">else</span></strong><span class="koboSpan" id="kobo.80.1"> statements with a few scattered variable declarations and periodic</span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.81.1"> return statements. </span><span class="koboSpan" id="kobo.81.2">These are fundamental structures of computer programming, and yet it takes a moment to understand what this code </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">truly does.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">For those not wanting to sort through the logic, this code follows </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">these rules:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.85.1">If the plane has departed, return </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">"</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">Flight Departed"</span></strong></span></li>
<li><span class="koboSpan" id="kobo.88.1">If the plane is not yet boarding, return </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">"Boarding </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">Not Started"</span></strong></span></li>
<li><span class="koboSpan" id="kobo.91.1">If the plane is boarding and the passenger needs help or is active military, return </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">"Board Now via </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">Priority Lane"</span></strong></span></li>
<li><span class="koboSpan" id="kobo.94.1">If the plane is boarding and the passenger’s group is not boarding yet, return </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">"</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">Please Wait"</span></strong></span></li>
<li><span class="koboSpan" id="kobo.97.1">If the passenger’s group can board, tell them to board either by the normal lane or via the priority lane if their boarding group is one of the </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">priority groups</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.99.1">However, the code is complex enough that puzzling out these rules can take a bit of time, and the complexity results in uncertainty, making it difficult for others to understand the rules in </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">their entirety.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">Understanding these rules is</span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.102.1"> important if you’re going to maintain the code. </span><span class="koboSpan" id="kobo.102.2">So, improving the readability of this code is important to the code’s </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">long-term success.</span></span></p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.104.1">Inverting if statements</span></h2>
<p><span class="koboSpan" id="kobo.105.1">One of the quickest tricks to simplifying </span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.106.1">complex logic involving </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.107.1">nested </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">if</span></strong><span class="koboSpan" id="kobo.109.1"> statements can be to invert the </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">if</span></strong><span class="koboSpan" id="kobo.111.1"> statement and </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">return early.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">Currently, our high-level logic looks </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">like this:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.115.1">if (Status != BoardingStatus.PlaneDeparted) {</span></strong><span class="koboSpan" id="kobo.116.1">
  // 17 lines of additional if statements and conditions
</span><strong class="bold"><span class="koboSpan" id="kobo.117.1">} else {</span></strong><span class="koboSpan" id="kobo.118.1">
  return "Flight Departed";
</span><strong class="bold"><span class="koboSpan" id="kobo.119.1">}</span></strong></pre>
<p><span class="koboSpan" id="kobo.120.1">By the time we get back to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">else</span></strong><span class="koboSpan" id="kobo.122.1"> statement associated with the plane departed check, the reader has forgotten what the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">if</span></strong><span class="koboSpan" id="kobo.124.1"> statement was to </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">begin with!</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">Here, since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">else</span></strong><span class="koboSpan" id="kobo.128.1"> branch is so simple and easy to understand, it’s helpful to invert the </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">if</span></strong><span class="koboSpan" id="kobo.130.1"> statement by taking the </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">following actions:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.132.1">Swap the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">if</span></strong><span class="koboSpan" id="kobo.134.1"> block and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">else</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.136.1"> block.</span></span></li>
<li><span class="koboSpan" id="kobo.137.1">Invert the boolean expression in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">if</span></strong><span class="koboSpan" id="kobo.139.1"> statement. </span><span class="koboSpan" id="kobo.139.2">When inverting </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">==</span></strong><span class="koboSpan" id="kobo.141.1">, it becomes </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">!=</span></strong><span class="koboSpan" id="kobo.143.1"> and vice versa. </span><span class="koboSpan" id="kobo.143.2">In cases where we do a </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">&gt;</span></strong><span class="koboSpan" id="kobo.145.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">&lt;</span></strong><span class="koboSpan" id="kobo.147.1"> check, you flip the operand and toggle whether equality is included. </span><span class="koboSpan" id="kobo.147.2">Under these rules, </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">&gt;=</span></strong><span class="koboSpan" id="kobo.149.1"> becomes </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">&lt;</span></strong><span class="koboSpan" id="kobo.151.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">&gt;=</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.153.1">becomes </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.156.1">In our case, we check that </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">Status != BoardingStatus.PlaneDeparted</span></strong><span class="koboSpan" id="kobo.158.1">. </span><span class="koboSpan" id="kobo.158.2">In this case, we’d change </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">!=</span></strong><span class="koboSpan" id="kobo.160.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">==</span></strong><span class="koboSpan" id="kobo.162.1"> and wind up </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">with this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.164.1">
Status == BoardingStatus.PlaneDeparted</span></pre>
<p><span class="koboSpan" id="kobo.165.1">These steps preserve the program’s existing behavior but change the order of the statements in the code. </span><span class="koboSpan" id="kobo.165.2">This can increase the readability of our </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">source code.</span></span></p>
<p><span class="koboSpan" id="kobo.167.1">If this sounds </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.168.1">complicated, don’t worry, because Visual Studio has a </span><strong class="bold"><span class="koboSpan" id="kobo.169.1">Quick Action</span></strong><span class="koboSpan" id="kobo.170.1"> refactoring for it </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.171.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.172.1">Invert if</span></strong><span class="koboSpan" id="kobo.173.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.174.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.175.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.177.1"><img alt="Figure 3.2 – The Invert if Quick Action refactoring" src="image/B21324_03_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.178.1">Figure 3.2 – The Invert if Quick Action refactoring</span></p>
<p><span class="koboSpan" id="kobo.179.1">Performing the refactoring here effectively changes our logic to </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.181.1">if (Status == BoardingStatus.PlaneDeparted) {</span></strong><span class="koboSpan" id="kobo.182.1">
  return "Flight Departed";
</span><strong class="bold"><span class="koboSpan" id="kobo.183.1">} else {</span></strong><span class="koboSpan" id="kobo.184.1">
  // 17 lines of additional if statements and conditions
</span><strong class="bold"><span class="koboSpan" id="kobo.185.1">}</span></strong></pre>
<p><span class="koboSpan" id="kobo.186.1">While this is easier to read since the reader no longer must remember what the </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">if</span></strong><span class="koboSpan" id="kobo.188.1"> statement even pertains to 17 lines later, the code can be </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">improved further.</span></span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.190.1">Dropping else statements after return statements</span></h2>
<p><span class="koboSpan" id="kobo.191.1">Since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">return</span></strong><span class="koboSpan" id="kobo.193.1"> statement always</span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.194.1"> leaves the method immediately, you never explicitly </span><em class="italic"><span class="koboSpan" id="kobo.195.1">need</span></em><span class="koboSpan" id="kobo.196.1"> an </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">else</span></strong><span class="koboSpan" id="kobo.198.1"> statement </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.199.1">after a </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">return</span></strong><span class="koboSpan" id="kobo.201.1"> statement because you know that if you get to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">return</span></strong><span class="koboSpan" id="kobo.203.1"> statement, logic after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">if</span></strong><span class="koboSpan" id="kobo.205.1"> block </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">won’t execute.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">This lets us remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">else</span></strong><span class="koboSpan" id="kobo.209.1"> keyword and its curly braces. </span><span class="koboSpan" id="kobo.209.2">Then, we can outdent the code that was previously in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">else</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.211.1"> block.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">The resulting code keeps the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">if</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.214.1"> statement:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.215.1">
if (Status == BoardingStatus.PlaneDeparted) {
  return "Flight Departed";
}</span></pre>
<p><span class="koboSpan" id="kobo.216.1">After this statement, the code that follows is now at the same indentation level as the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">if</span></strong><span class="koboSpan" id="kobo.218.1"> statement and is </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.219.1">easier to read </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">and</span></span><span class="No-Break"><a id="_idIndexMarker107"/></span><span class="No-Break"><span class="koboSpan" id="kobo.221.1"> understand:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.222.1">
if (isMilitary &amp;&amp; Status == BoardingStatus.Boarding) {
  return "Board Now via Priority Lane";
} else if (needsHelp&amp;&amp;Status == BoardingStatus.Boarding) {
  return "Board Now via Priority Lane";
} else if (Status == BoardingStatus.Boarding) {
  if (CurrentBoardingGroup &gt;= group) {
     if (_priorityLaneGroups.Contains(group)) {
        return "Board Now via Priority Lane";
     } else {
        return "Board Now";
     }
  } else {
     return "Please Wait";
  }
} else {
  return "Boarding Not Started";
}</span></pre>
<p><span class="koboSpan" id="kobo.223.1">We can repeat this refactoring a few more times if we want to since the code has a few more </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">if</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">/</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">return</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">/</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">else</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.229.1"> sequences.</span></span></p>
<p><span class="koboSpan" id="kobo.230.1">I’ll leave those for the moment</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.231.1"> since there’s another refactoring I want to show you that can help with what we’re</span><a id="_idIndexMarker109"/> <span class="No-Break"><span class="koboSpan" id="kobo.232.1">seeing here.</span></span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.233.1">Restructuring if statements</span></h2>
<p><span class="koboSpan" id="kobo.234.1">Looking at the </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.235.1">previous code, some of the logic </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.236.1">stands out </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">as repetitive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.238.1">
if (isMilitary &amp;&amp; </span><strong class="bold"><span class="koboSpan" id="kobo.239.1">Status == BoardingStatus.Boarding</span></strong><span class="koboSpan" id="kobo.240.1">) {
  return "Board Now via Priority Lane";
} else if (needsHelp&amp;&amp;</span><strong class="bold"><span class="koboSpan" id="kobo.241.1">Status == BoardingStatus.Boarding</span></strong><span class="koboSpan" id="kobo.242.1">) {
  return "Board Now via Priority Lane";
} else if (</span><strong class="bold"><span class="koboSpan" id="kobo.243.1">Status == BoardingStatus.Boarding</span></strong><span class="koboSpan" id="kobo.244.1">) {
  // Code omitted for brevity
} else {
  return "Boarding Not Started";
}</span></pre>
<p><span class="koboSpan" id="kobo.245.1">Here, we have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">if</span></strong><span class="koboSpan" id="kobo.247.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">else</span></strong><span class="koboSpan" id="kobo.249.1"> chain where three different things are checking whether the flight is currently boarding. </span><span class="koboSpan" id="kobo.249.2">Although each of these three </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">if</span></strong><span class="koboSpan" id="kobo.251.1"> statements is different, there’s enough overlap between them that it makes me question if we could be </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">less repetitive.</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">The first option we could consider might be a simple </span><em class="italic"><span class="koboSpan" id="kobo.254.1">introduce local variable</span></em><span class="koboSpan" id="kobo.255.1"> refactoring, as we saw in </span><a href="B21324_02.xhtml#_idTextAnchor026"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.256.1">Chapter 2</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.257.1">:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.258.1">bool isBoarding = Status == BoardingStatus.Boarding</span></strong><span class="koboSpan" id="kobo.259.1">;
if (isMilitary &amp;&amp; </span><strong class="bold"><span class="koboSpan" id="kobo.260.1">isBoarding</span></strong><span class="koboSpan" id="kobo.261.1">) {
  return "Board Now via Priority Lane";
} else if (needsHelp &amp;&amp; </span><strong class="bold"><span class="koboSpan" id="kobo.262.1">isBoarding</span></strong><span class="koboSpan" id="kobo.263.1">) {
  return "Board Now via Priority Lane";
} else if (</span><strong class="bold"><span class="koboSpan" id="kobo.264.1">isBoarding</span></strong><span class="koboSpan" id="kobo.265.1">) {
  // Code omitted for brevity
} else {
  return "Boarding Not Started";
}</span></pre>
<p><span class="koboSpan" id="kobo.266.1">I find this code easier to </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.267.1">read, even though we gained </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.268.1">an extra line from the new local variable. </span><span class="koboSpan" id="kobo.268.2">However, let’s take a slightly </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">different approach.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">Instead of introducing a variable, we can rearrange our if statements to have an additional layer </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">of nesting:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.272.1">if (Status == BoardingStatus.Boarding) {</span></strong><span class="koboSpan" id="kobo.273.1">
  if </span><strong class="bold"><span class="koboSpan" id="kobo.274.1">(</span></strong><span class="koboSpan" id="kobo.275.1">isMilitary</span><strong class="bold"><span class="koboSpan" id="kobo.276.1">)</span></strong><span class="koboSpan" id="kobo.277.1"> {
     return "Board Now via Priority Lane";
  } else if </span><strong class="bold"><span class="koboSpan" id="kobo.278.1">(</span></strong><span class="koboSpan" id="kobo.279.1">needsHelp</span><strong class="bold"><span class="koboSpan" id="kobo.280.1">)</span></strong><span class="koboSpan" id="kobo.281.1"> {
     return "Board Now via Priority Lane";
  } else {
     // Code omitted for brevity
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.282.1">} else {</span></strong><span class="koboSpan" id="kobo.283.1">
  return "Boarding Not Started";
</span><strong class="bold"><span class="koboSpan" id="kobo.284.1">}</span></strong></pre>
<p><span class="koboSpan" id="kobo.285.1">Here, pulling a common condition from a set of </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">if</span></strong><span class="koboSpan" id="kobo.287.1"> statements into an outer </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">if</span></strong><span class="koboSpan" id="kobo.289.1"> statement helped clarify those </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">if</span></strong><span class="koboSpan" id="kobo.291.1"> statements, although it did so at the expense of an additional degree </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">of nesting.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">However, this simplification helps spot a few other refactoring opportunities, such as combining the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">isMilitary</span></strong><span class="koboSpan" id="kobo.295.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">needsHelp</span></strong><span class="koboSpan" id="kobo.297.1"> checks </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.298.1">since they return the same value if either </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">is true:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.300.1">
if </span><strong class="bold"><span class="koboSpan" id="kobo.301.1">(isMilitary || needsHelp)</span></strong><span class="koboSpan" id="kobo.302.1"> {
  return "Board Now via Priority Lane";
}</span></pre>
<p><span class="koboSpan" id="kobo.303.1">We can also drop the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">else</span></strong><span class="koboSpan" id="kobo.305.1"> statement after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">if</span></strong><span class="koboSpan" id="kobo.307.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">return</span></strong><span class="koboSpan" id="kobo.309.1"> code to outdent our code a bit more, leaving</span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.310.1"> just the boarding </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">group logic:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.312.1">
if (CurrentBoardingGroup &gt;= group) {
  if (_priorityLaneGroups.Contains(group)) {
     return "Board Now via Priority Lane";
  } else {
     return "Board Now";
  }
} else {
  return "Please Wait";
}</span></pre>
<p><span class="koboSpan" id="kobo.313.1">This looks like another place where we can invert </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">if</span></strong><span class="koboSpan" id="kobo.315.1"> and drop the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">else</span></strong><span class="koboSpan" id="kobo.317.1"> statement to simplify the code even more. </span><span class="koboSpan" id="kobo.317.2">Remember that we must change </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">&gt;=</span></strong><span class="koboSpan" id="kobo.319.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">&lt;</span></strong><span class="koboSpan" id="kobo.321.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">do this:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.323.1">if (CurrentBoardingGroup &lt; group) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.324.1">  return "Please Wait";</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.325.1">}</span></strong><span class="koboSpan" id="kobo.326.1">
if (_priorityLaneGroups.Contains(group)) {
  return "Board Now via Priority Lane";
} else {
  return "Board Now";
}</span></pre>
<p><span class="koboSpan" id="kobo.327.1">As you can see, the code is getting significantly easier to read as we </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">simplify it.</span></span></p>
<p><span class="koboSpan" id="kobo.329.1">Let’s take a step back and look at our conditional logic after </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">these refactorings:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.331.1">
if (Status == BoardingStatus.PlaneDeparted) {
  return "Flight Departed";
}
if (Status == BoardingStatus.Boarding) {
  if (isMilitary || needsHelp) {
     return "Board Now via Priority Lane";
  }
  if (CurrentBoardingGroup &lt; group) {
     return "Please Wait";
  }
  if (_priorityLaneGroups.Contains(group)) {
     return "Board Now via Priority Lane";
  } else {
     return "Board Now";
  }
} else {
  return "Boarding Not Started";
}</span></pre>
<p><span class="koboSpan" id="kobo.332.1">The code is now easier to read and harder to misinterpret. </span><span class="koboSpan" id="kobo.332.2">We could invert the Boarding status check to return early, but we'll do something else with </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">here later.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">Let’s look at how we can reduce our line count even further through a more divisive language feature: the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.335.1">ternary operator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">.</span></span></p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.337.1">Using ternary operators</span></h2>
<p><span class="koboSpan" id="kobo.338.1">If you’re a fan of the ternary </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.339.1">operator, you may have </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.340.1">noticed an opportunity to use one in the code as we’ve </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">been refactoring.</span></span></p>
<p><span class="koboSpan" id="kobo.342.1">For those not familiar or not fully comfortable with the ternary conditional operator, think of it as a condensed </span><em class="italic"><span class="koboSpan" id="kobo.343.1">if my condition is true use this value, otherwise use this other value</span></em><span class="koboSpan" id="kobo.344.1"> type of </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">an operator.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">The syntax for ternary is </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">boolExpression ? </span><span class="koboSpan" id="kobo.347.2">trueValue : </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">falseValue;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.350.1">In other words, you could write code without a ternary </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.352.1">
int value;
if (</span><strong class="bold"><span class="koboSpan" id="kobo.353.1">someCondition</span></strong><span class="koboSpan" id="kobo.354.1">) {
  value = </span><strong class="bold"><span class="koboSpan" id="kobo.355.1">1</span></strong><span class="koboSpan" id="kobo.356.1">;
} else {
  value = </span><strong class="bold"><span class="koboSpan" id="kobo.357.1">2</span></strong><span class="koboSpan" id="kobo.358.1">;
}</span></pre>
<p><span class="koboSpan" id="kobo.359.1">However, the same code could be written using a ternary in a </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">single line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.361.1">
int value = </span><strong class="bold"><span class="koboSpan" id="kobo.362.1">someCondition ? </span><span class="koboSpan" id="kobo.362.2">1 : 2</span></strong><span class="koboSpan" id="kobo.363.1">;</span></pre>
<p><span class="koboSpan" id="kobo.364.1">As you can see, the ternary operator lets us take six lines of code and condense it down to a single line. </span><span class="koboSpan" id="kobo.364.2">This conciseness is a key factor for those who like using ternaries in </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">their code.</span></span></p>
<p><span class="koboSpan" id="kobo.366.1">Those who are less fond of ternary operators often point out that ternaries are difficult to read – particularly when trying to read through code quickly. </span><span class="koboSpan" id="kobo.366.2">In other words, while they make code more concise, this conciseness can slow you down in the long run by making the code less easy </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">to maintain.</span></span></p>
<p><span class="koboSpan" id="kobo.368.1">Let’s look at a small part of our code and see how a ternary could </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">be applied:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.370.1">
  if (CurrentBoardingGroup &lt; group) {
     return "Please Wait";
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.371.1">  if (_priorityLaneGroups.Contains(group)) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.372.1">     return "Board Now via Priority Lane";</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.373.1">  } else {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.374.1">     return "Board Now";</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.375.1">  }</span></strong></pre>
<p><span class="koboSpan" id="kobo.376.1">Here, we are checking if the </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.377.1">current boarding group is a priority group and then telling the user to board with the priority lane or to board </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.378.1">normally based on the result of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">Contains</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.380.1"> call.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">Since we’re returning a single value based on the result of a boolean expression, we could rewrite the code with a ternary </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.383.1">
if (CurrentBoardingGroup &lt; group) {
  return "Please Wait";
}
</span><strong class="bold"><span class="koboSpan" id="kobo.384.1">return _priorityLaneGroups.Contains(group)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.385.1">        ? </span><span class="koboSpan" id="kobo.385.2">"Board Now via Priority Lane"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.386.1">        : "Board Now";</span></strong></pre>
<p><span class="koboSpan" id="kobo.387.1">This chops five lines of code down to three lines of code or a single line of code if you want to put the </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">?</span></strong><span class="koboSpan" id="kobo.389.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">:</span></strong><span class="koboSpan" id="kobo.391.1"> segments on the same line as the </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">boolean expression.</span></span></p>
<p><span class="koboSpan" id="kobo.393.1">You might have noticed that this refactoring now puts the whole block of code into a position where you could introduce another ternary based on the boarding group, </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">return "Please Wait"</span></strong><span class="koboSpan" id="kobo.395.1">, if that expression is true, and return the result of the earlier ternary expression if the expression </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">is false:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.397.1">
return </span><strong class="bold"><span class="koboSpan" id="kobo.398.1">(CurrentBoardingGroup &lt; group)</span></strong><span class="koboSpan" id="kobo.399.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.400.1">?</span></strong><span class="koboSpan" id="kobo.401.1"> "Please Wait"
  </span><strong class="bold"><span class="koboSpan" id="kobo.402.1">:</span></strong><span class="koboSpan" id="kobo.403.1"> _priorityLaneGroups.Contains(group)
     ? </span><span class="koboSpan" id="kobo.403.2">"Board Now via Priority Lane"
     : "Board Now";</span></pre>
<p><span class="koboSpan" id="kobo.404.1">While this is valid C#, I can attest that if a coworker showed this to me in code review, I would be tempted to utter some </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">not-very-nice words!</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.406.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.407.1">Remember: fewer lines of code don’t always equate to </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">greater maintainability.</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">At a personal level, my </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.410.1">preference is to avoid the ternary in many places and always avoid chaining ternaries together. </span><span class="koboSpan" id="kobo.410.2">However, I do</span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.411.1"> sometimes use ternaries when I feel it is right for a piece </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">of code.</span></span></p>
<p><span class="koboSpan" id="kobo.413.1">For example, sometimes, a method is very simple and can be condensed to a single line of code if you use a ternary expression. </span><span class="koboSpan" id="kobo.413.2">This particular change lets you use the expression-bodied members feature, which we’ll talk about in </span><a href="B21324_04.xhtml#_idTextAnchor072"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.414.1">Chapter 4</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.415.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">When I use a ternary, I format my ternary expressions on three separate lines, as shown earlier, with the first line containing the boolean expression. </span><span class="koboSpan" id="kobo.416.2">The second line will feature the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">?</span></strong><span class="koboSpan" id="kobo.418.1"> operator and the value to use if the expression was true, and the third line will feature the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">:</span></strong><span class="koboSpan" id="kobo.420.1"> operator and the value to use if the expression </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">was false:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.422.1">
var myVar = </span><strong class="bold"><span class="koboSpan" id="kobo.423.1">booleanExpression</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.424.1">                    ? </span><span class="koboSpan" id="kobo.424.2">valueIfTrue</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.425.1">                    : valueIfFalse</span></strong><span class="koboSpan" id="kobo.426.1">;</span></pre>
<p><span class="koboSpan" id="kobo.427.1">I find that this approach strikes a happy medium between the benefits of more concise code from the ternary and the penalties of code becoming more difficult to read quickly and accurately when using </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">a ternary.</span></span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.429.1">Converting if statements into switch statements</span></h2>
<p><span class="koboSpan" id="kobo.430.1">The logic of this method is</span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.431.1"> now a lot easier to understand, and simplifying it down to this level highlights that we’re doing one of three </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.432.1">things, depending on the current </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">boarding status:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.434.1">Notifying the user the flight has departed if its status </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">PlaneDeparted</span></strong></span></li>
<li><span class="koboSpan" id="kobo.437.1">Checking military status, whether help boarding is needed, and the boarding group for </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">Boarding</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.439.1"> status</span></span></li>
<li><span class="koboSpan" id="kobo.440.1">Notifying the user that boarding hasn’t started yet for other statuses (</span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">NotStarted</span></strong><span class="koboSpan" id="kobo.442.1"> is the only other status at </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">the moment)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.444.1">When working with enumerated</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.445.1"> values, this kind of branching logic </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">is common.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">In our case, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">enum</span></strong><span class="koboSpan" id="kobo.449.1"> value only has</span><a id="_idIndexMarker125"/> <span class="No-Break"><span class="koboSpan" id="kobo.450.1">three states:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.451.1">BoardingStatus.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.452.1">
public enum BoardingStatus {
  NotStarted = 0,
  Boarding = 1,
  PlaneDeparted = 2,
}</span></pre>
<p><span class="koboSpan" id="kobo.453.1">In cases where you find yourself checking the same variable for different values, you can usually rewrite them to use a </span><strong class="bold"><span class="koboSpan" id="kobo.454.1">switch </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.455.1">statement</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.456.1"> instead.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">switch</span></strong><span class="koboSpan" id="kobo.458.1"> statements are essentially a streamlined series of </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">if</span></strong><span class="koboSpan" id="kobo.460.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">else</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.462.1">if</span></strong><span class="koboSpan" id="kobo.463.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">else</span></strong><span class="koboSpan" id="kobo.465.1"> types of checks that all check the same value, as our code does with </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">Status</span></strong><span class="koboSpan" id="kobo.467.1">. </span><span class="koboSpan" id="kobo.467.2">We’ll see an example of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">switch</span></strong><span class="koboSpan" id="kobo.469.1"> statement shortly, but if you’re not familiar with them, you can think of them as just a different way of writing a series of related </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">if</span></strong><span class="koboSpan" id="kobo.471.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">else</span></strong> <span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">if</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.474.1"> statements.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">This can be done manually, or you can use a specific refactoring built into Visual Studio if your code is built in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">if</span></strong><span class="koboSpan" id="kobo.477.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">else</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.479.1">if</span></strong><span class="koboSpan" id="kobo.480.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">else</span></strong><span class="koboSpan" id="kobo.482.1"> type of structure, as the following </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">code illustrates:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.484.1">
if (Status == BoardingStatus.PlaneDeparted) {
  return "Flight Departed";
} </span><strong class="bold"><span class="koboSpan" id="kobo.485.1">else</span></strong><span class="koboSpan" id="kobo.486.1"> if (Status == BoardingStatus.Boarding) {
  if (isMilitary || needsHelp) {
     return "Board Now via Priority Lane";
  }
  if (CurrentBoardingGroup &lt; group) {
     return "Please Wait";
  }
  return _priorityLaneGroups.Contains(group)
           ? </span><span class="koboSpan" id="kobo.486.2">"Board Now via Priority Lane"
           : "Board Now";
} else {
  return "Boarding Not Started";
}</span></pre>
<p><span class="koboSpan" id="kobo.487.1">Note here that I did add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">else</span></strong><span class="koboSpan" id="kobo.489.1"> keyword (in bold in the previous snippet) to our earlier code to get into that </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">if</span></strong><span class="koboSpan" id="kobo.491.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">else</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.493.1">if</span></strong><span class="koboSpan" id="kobo.494.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">else</span></strong><span class="koboSpan" id="kobo.496.1"> structure, which lets Visual Studio identify the refactoring </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.497.1">we’re about </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">to use.</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">Once we have the </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.500.1">code in this pattern, the </span><strong class="bold"><span class="koboSpan" id="kobo.501.1">Convert to ‘switch’ statement</span></strong><span class="koboSpan" id="kobo.502.1"> refactoring option will appear in the </span><strong class="bold"><span class="koboSpan" id="kobo.503.1">Quick Actions</span></strong><span class="koboSpan" id="kobo.504.1"> menu when you have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">if</span></strong><span class="koboSpan" id="kobo.506.1"> statement selected, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.507.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.508.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.510.1"><img alt="Figure 3.3 – The Convert to “switch” statement refactoring option" src="image/B21324_03_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.511.1">Figure 3.3 – The Convert to “switch” statement refactoring option</span></p>
<p><span class="koboSpan" id="kobo.512.1">This refactoring makes </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.513.1">our status-based </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.514.1">logic much </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">more apparent:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.516.1">switch (Status) {</span></strong><span class="koboSpan" id="kobo.517.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.518.1">case BoardingStatus.PlaneDeparted:</span></strong><span class="koboSpan" id="kobo.519.1">
     return "Flight Departed";
  </span><strong class="bold"><span class="koboSpan" id="kobo.520.1">case BoardingStatus.Boarding:</span></strong><span class="koboSpan" id="kobo.521.1">
     if (isMilitary || needsHelp) {
        return "Board Now via Priority Lane";
     }
     if (CurrentBoardingGroup &lt; group) {
        return "Please Wait";
     }
     return _priorityLaneGroups.Contains(group)
              ? </span><span class="koboSpan" id="kobo.521.2">"Board Now via Priority Lane"
              : "Board Now";
  </span><strong class="bold"><span class="koboSpan" id="kobo.522.1">default:</span></strong><span class="koboSpan" id="kobo.523.1">
     return "Boarding Not Started";
}</span></pre>
<p><span class="koboSpan" id="kobo.524.1">As someone reading this code, I find this a lot easier to scan and interpret compared to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">if</span></strong><span class="koboSpan" id="kobo.526.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">else if</span></strong><span class="koboSpan" id="kobo.528.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">else</span></strong><span class="koboSpan" id="kobo.530.1"> chain, even</span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.531.1"> though the logic functions identically. </span><span class="koboSpan" id="kobo.531.2">With an </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">if</span></strong><span class="koboSpan" id="kobo.533.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">else</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.535.1">if</span></strong><span class="koboSpan" id="kobo.536.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">else</span></strong><span class="koboSpan" id="kobo.538.1"> statement, I </span><em class="italic"><span class="koboSpan" id="kobo.539.1">may</span></em><span class="koboSpan" id="kobo.540.1"> notice that logic is comparing the same value several different times, while a </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">switch</span></strong><span class="koboSpan" id="kobo.542.1"> statement makes </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">it explicit.</span></span></p>
<p><span class="koboSpan" id="kobo.544.1">Another benefit you get </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.545.1">with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">switch</span></strong><span class="koboSpan" id="kobo.547.1"> statement is that it unlocks a built-in refactoring option when your switch compares an </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">enum</span></strong><span class="koboSpan" id="kobo.549.1"> value (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">BoardingStatus</span></strong><span class="koboSpan" id="kobo.551.1">) and you’re missing a case for one or more </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">enum</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.553.1"> values.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">This option shows up in the </span><strong class="bold"><span class="koboSpan" id="kobo.555.1">Quick Actions</span></strong><span class="koboSpan" id="kobo.556.1"> menu for the switch statement as </span><strong class="bold"><span class="koboSpan" id="kobo.557.1">Add missing cases</span></strong><span class="koboSpan" id="kobo.558.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.559.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.560.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.562.1"><img alt="Figure 3.4 – The Add missing cases refactoring option in the Quick Actions menu" src="image/B21324_03_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.563.1">Figure 3.4 – The Add missing cases refactoring option in the Quick Actions menu</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.564.1">Warning</span></p>
<p class="callout"><span class="koboSpan" id="kobo.565.1">I want to point out that the </span><strong class="bold"><span class="koboSpan" id="kobo.566.1">Add missing cases</span></strong><span class="koboSpan" id="kobo.567.1"> refactoring option here potentially causes a change in behavior. </span><span class="koboSpan" id="kobo.567.2">The built-in implementation of that refactoring adds the </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">NotStarted</span></strong><span class="koboSpan" id="kobo.569.1"> status and has it break out of the switch instead of returning a value as it previously would have through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">default</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.571.1"> keyword.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.572.1">The C# compiler will flag this mistake for us in this case since the method won’t return a value for this path, but adding missing cases when a </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">default</span></strong><span class="koboSpan" id="kobo.574.1"> case is present in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">switch</span></strong><span class="koboSpan" id="kobo.576.1"> statement typically does introduce a change </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">in behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">In our case, we </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.579.1">can merge the </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">NotStarted</span></strong><span class="koboSpan" id="kobo.581.1"> status with the default case and get a more explicit list </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">of </span></span><span class="No-Break"><a id="_idIndexMarker133"/></span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">options:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.584.1">
switch (Status) {
  case BoardingStatus.PlaneDeparted:
     return "Flight Departed";
  case BoardingStatus.Boarding:
     if (isMilitary || needsHelp) {
        return "Board Now via Priority Lane";
     }
     if (CurrentBoardingGroup &lt; group) {
        return "Please Wait";
     }
     return _priorityLaneGroups.Contains(group)
              ? </span><span class="koboSpan" id="kobo.584.2">"Board Now via Priority Lane"
              : "Board Now";
</span><strong class="bold"><span class="koboSpan" id="kobo.585.1">  case BoardingStatus.NotStarted:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.586.1">  default:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.587.1">     return "Boarding Not Started";</span></strong><span class="koboSpan" id="kobo.588.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.589.1">This code is now significantly easier to read than it was before, and the flow of logic by status is now </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">readily apparent.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">In a real-world application, I might change the default case to throw an exception, explicitly telling me that a specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">Status</span></strong><span class="koboSpan" id="kobo.593.1"> was not supported by this logic. </span><span class="koboSpan" id="kobo.593.2">This would look something like the </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">following logic:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.595.1">
case BoardingStatus.NotStarted:
  return "Boarding Not Started";
</span><strong class="bold"><span class="koboSpan" id="kobo.596.1">default:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.597.1"> throw new NotSupportedException($"Unsupported: {Status}");</span></strong></pre>
<p><span class="koboSpan" id="kobo.598.1">I might also be tempted to perform </span><em class="italic"><span class="koboSpan" id="kobo.599.1">extract method</span></em><span class="koboSpan" id="kobo.600.1"> refactoring – as we saw in </span><a href="B21324_02.xhtml#_idTextAnchor026"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.601.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.602.1"> – to move the logic</span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.603.1"> for handling the boarding status into its own method. </span><span class="koboSpan" id="kobo.603.2">However, I’ll hold off on doing that to showcase </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.604.1">switch </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">expressions instead.</span></span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.606.1">Converting to switch expressions</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.607.1">Switch expressions</span></strong><span class="koboSpan" id="kobo.608.1"> are an</span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.609.1"> evolution of switch statements that rely on </span><strong class="bold"><span class="koboSpan" id="kobo.610.1">pattern-matching</span></strong><span class="koboSpan" id="kobo.611.1"> expressions to simplify and expand </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.612.1">what’s possible inside </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">switch </span></span><span class="No-Break"><a id="_idIndexMarker138"/></span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">statements.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">switch</span></strong><span class="koboSpan" id="kobo.616.1"> expressions are a relatively new feature in C# that was released as part of C# 8 in 2019. </span><span class="koboSpan" id="kobo.616.2">While that’s more than a few years old at the time of writing, I still find switch expressions to be new enough that many C# developers are unfamiliar or unpracticed </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">with them.</span></span></p>
<p><span class="koboSpan" id="kobo.618.1">A simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">switch</span></strong><span class="koboSpan" id="kobo.620.1"> expression looks a lot like a </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">switch statement:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.622.1">
return Status </span><strong class="bold"><span class="koboSpan" id="kobo.623.1">switch</span></strong><span class="koboSpan" id="kobo.624.1"> {
  BoardingStatus.PlaneDeparted =&gt; "Flight Departed",
  BoardingStatus.NotStarted =&gt; "Boarding Not Started",
  BoardingStatus.Boarding =&gt; "Board Now",
  _ =&gt; "Some other status",
};</span></pre>
<p><span class="koboSpan" id="kobo.625.1">These </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">switch</span></strong><span class="koboSpan" id="kobo.627.1"> expressions look very similar to switch statements except for the </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">following aspects:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.629.1">They start with the value you want to evaluate followed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">switch</span></strong><span class="koboSpan" id="kobo.631.1"> keyword instead of starting with </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">switch (value)</span></strong></span></li>
<li><span class="koboSpan" id="kobo.633.1">We don’t use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">case</span></strong><span class="koboSpan" id="kobo.635.1"> or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">break</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.637.1"> keywords</span></span></li>
<li><span class="koboSpan" id="kobo.638.1">Individual cases have some</span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.639.1"> condition that might be true on the left, an arrow notation (</span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">=&gt;</span></strong><span class="koboSpan" id="kobo.641.1">), and then the value to use on the right if the condition on the left </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">is true.</span></span></li>
<li><span class="koboSpan" id="kobo.643.1">Instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">default</span></strong><span class="koboSpan" id="kobo.645.1"> keyword, we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">_</span></strong><span class="koboSpan" id="kobo.647.1">, indicating any </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">other match</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.649.1">One of the nice things</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.650.1"> about </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">switch</span></strong><span class="koboSpan" id="kobo.652.1"> expressions is that they’re extremely concise while still being somewhat readable. </span><span class="koboSpan" id="kobo.652.2">However, there’s more power to </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">switch</span></strong><span class="koboSpan" id="kobo.654.1"> expressions than what I’ve shown you </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">so far.</span></span></p>
<p><span class="koboSpan" id="kobo.656.1">You may have noticed the sample </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">switch</span></strong><span class="koboSpan" id="kobo.658.1"> expression I introduced a moment ago doesn’t adequately handle the logic for boarding. </span><span class="koboSpan" id="kobo.658.2">Specifically, we had rules for active military members, people who need assistance boarding, boarding groups, and priority lanes, and none of that is represented in the previous block </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">of code.</span></span></p>
<p><span class="koboSpan" id="kobo.660.1">Let’s take a look at a </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">switch</span></strong><span class="koboSpan" id="kobo.662.1"> expression that does handle </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">these things:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.664.1">
return Status switch {
  BoardingStatus.PlaneDeparted =&gt; "Flight Departed",
  BoardingStatus.NotStarted =&gt; "Boarding Not Started",
</span><strong class="bold"><span class="koboSpan" id="kobo.665.1">  BoardingStatus.Boarding when isMilitary || needsHelp</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.666.1">     =&gt; "Board Now via Priority Lane",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.667.1">  BoardingStatus.Boarding when CurrentBoardingGroup &lt; group</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.668.1">     =&gt; "Please Wait",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.669.1">  BoardingStatus.Boarding when</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.670.1">   _priorityLaneGroups.Contains(group)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.671.1">     =&gt; "Board Now via Priority Lane",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.672.1">  BoardingStatus.Boarding =&gt; "Board Now",</span></strong><span class="koboSpan" id="kobo.673.1">
  _ =&gt; "Some other status",
};</span></pre>
<p><span class="koboSpan" id="kobo.674.1">This code is a bit different than the last </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">switch</span></strong><span class="koboSpan" id="kobo.676.1"> expression we saw. </span><span class="koboSpan" id="kobo.676.2">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">Boarding</span></strong><span class="koboSpan" id="kobo.678.1"> status is repeated four times and sometimes accompanied by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">when</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.680.1"> keyword.</span></span></p>
<p><span class="koboSpan" id="kobo.681.1">What this code is doing is using pattern matching to check not just that </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">Status</span></strong><span class="koboSpan" id="kobo.683.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">Boarding</span></strong><span class="koboSpan" id="kobo.685.1">, but that other</span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.686.1"> conditions are true as well. </span><span class="koboSpan" id="kobo.686.2">Effectively, we’re able to check the status and optionally another boolean </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.687.1">expression after the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">when</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.689.1"> keyword.</span></span></p>
<p><span class="koboSpan" id="kobo.690.1">If both things are not true, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">switch</span></strong><span class="koboSpan" id="kobo.692.1"> expression evaluates the next line in sequence. </span><span class="koboSpan" id="kobo.692.2">This makes </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">switch</span></strong><span class="koboSpan" id="kobo.694.1"> expressions a set of matching rules that ensure the first rule evaluates </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">to true.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.696.1">Pattern matching</span></p>
<p class="callout"><span class="koboSpan" id="kobo.697.1">Pattern matching is a</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.698.1"> newer C# syntax that allows you to concisely check different properties and aspects of objects and variables. </span><span class="koboSpan" id="kobo.698.2">We’ll explore pattern-matching syntax more in </span><a href="B21324_10.xhtml#_idTextAnchor209"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.699.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.700.1">, </span><em class="italic"><span class="koboSpan" id="kobo.701.1">Defensive Coding Techniques</span></em><span class="koboSpan" id="kobo.702.1">, but this section serves as a good introduction to some of </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">its capabilities.</span></span></p>
<p><span class="koboSpan" id="kobo.704.1">In other words, this </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">switch</span></strong><span class="koboSpan" id="kobo.706.1"> expression checks the following rules and reacts to the first one that </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">is true:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.708.1">The plane </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">has departed.</span></span></li>
<li><span class="koboSpan" id="kobo.710.1">Boarding hasn’t </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">started yet.</span></span></li>
<li><span class="koboSpan" id="kobo.712.1">Boarding has started and the passenger is active military or </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">needs assistance.</span></span></li>
<li><span class="koboSpan" id="kobo.714.1">The passenger’s boarding group hasn’t been </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">called yet.</span></span></li>
<li><span class="koboSpan" id="kobo.716.1">The passenger’s group is boarding and it’s a priority </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">lane group.</span></span></li>
<li><span class="koboSpan" id="kobo.718.1">The passenger’s group is boarding but they’re not in the priority </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">boarding lane.</span></span></li>
<li><span class="koboSpan" id="kobo.720.1">Any </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">other status</span></span></li>
</ol>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">switch</span></strong><span class="koboSpan" id="kobo.723.1"> expressions are concise and allow you to mix the structured clarity of </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">switch</span></strong><span class="koboSpan" id="kobo.725.1"> statements with the power of pattern matching and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">when</span></strong><span class="koboSpan" id="kobo.727.1"> keyword to make very readable ordered </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">logic apparent.</span></span></p>
<p><span class="koboSpan" id="kobo.729.1">As with any tool in your programming toolbelt, </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">switch</span></strong><span class="koboSpan" id="kobo.731.1"> expressions won’t be the solution to every problem and </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.732.1">you and your team may not be as fond of reading </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">switch</span></strong><span class="koboSpan" id="kobo.734.1"> expressions as I am. </span><span class="koboSpan" id="kobo.734.2">However, they remain a valuable tool in your toolbox for simplifying code while keeping it easy to read, maintain, </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">and expand.</span></span></p>
<p><span class="koboSpan" id="kobo.736.1">We’ll revisit some of the</span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.737.1"> pattern-matching syntax in </span><a href="B21324_10.xhtml#_idTextAnchor209"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.738.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.739.1">, but let’s move on to looking at what we can do to improve working with collections </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">of objects.</span></span></p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.741.1">Instantiating objects</span></h1>
<p><span class="koboSpan" id="kobo.742.1">Now that we’ve sufficiently improved our </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">CanPassengerBoard</span></strong><span class="koboSpan" id="kobo.744.1"> method, let’s look at how we can create objects and see</span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.745.1"> a few simple improvements you can make that will simplify </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.746.1">object </span><strong class="bold"><span class="koboSpan" id="kobo.747.1">instantiation</span></strong><span class="koboSpan" id="kobo.748.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">your code.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.750.1">Terminology notes</span></p>
<p class="callout"><span class="koboSpan" id="kobo.751.1">New developers are often tripped up by a handful of phrases that are commonly used by developers. </span><span class="koboSpan" id="kobo.751.2">For example, in this section, we will talk about instantiating objects. </span><span class="koboSpan" id="kobo.751.3">This is a common way of phrasing this for developers, but all it means is the process of creating a specific </span><em class="italic"><span class="koboSpan" id="kobo.752.1">instance</span></em><span class="koboSpan" id="kobo.753.1"> of a class using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">new</span></strong><span class="koboSpan" id="kobo.755.1"> keyword. </span><span class="koboSpan" id="kobo.755.2">When you see the term instantiating, you can think of it simply as creating a specific instance </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">of something.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.757.1">This section’s code could come from anywhere, but we’ll focus on code found in a pair of methods in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">PassengerTests.cs</span></strong><span class="koboSpan" id="kobo.759.1"> file in the test project that accompanies </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">this chapter.</span></span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.761.1">Replacing var with explicit Types</span></h2>
<p><span class="koboSpan" id="kobo.762.1">The first line of code I want to focus on</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.763.1"> comes from one of our </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">unit tests:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.765.1">PassengerTests.cs</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.766.1">var p </span></strong><span class="koboSpan" id="kobo.767.1">= Build(first, last);</span></pre>
<p><span class="koboSpan" id="kobo.768.1">Here, I’ve deliberately omitted the context of</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.769.1"> the code from the surrounding lines to reinforce a point, and the point is this: take a moment and try to determine what data type the </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">p</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.771.1">variable is.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">p</span></strong><span class="koboSpan" id="kobo.773.1"> stores the result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">Build</span></strong><span class="koboSpan" id="kobo.775.1">, which takes in a pair of parameters named </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">first</span></strong><span class="koboSpan" id="kobo.777.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">last</span></strong><span class="koboSpan" id="kobo.779.1">, but we can’t make a confident assertion about what type of data </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">p</span></strong><span class="koboSpan" id="kobo.781.1"> holds from this </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">line alone.</span></span></p>
<p><span class="koboSpan" id="kobo.783.1">This is because </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">p</span></strong><span class="koboSpan" id="kobo.785.1"> was declared with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">var</span></strong><span class="koboSpan" id="kobo.787.1"> keyword. </span><span class="koboSpan" id="kobo.787.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">var</span></strong><span class="koboSpan" id="kobo.789.1"> keyword is a shorthand way of saying “Hey, compiler, when you’re compiling this code, I want you to determine what data type this is going to be and replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">var</span></strong><span class="koboSpan" id="kobo.791.1"> keyword in the compiled code with the actual type of </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">the data.”</span></span></p>
<p><span class="koboSpan" id="kobo.793.1">In other words, </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">var</span></strong><span class="koboSpan" id="kobo.795.1"> is usually a shortcut for not typing out the full name of the data type in question. </span><span class="koboSpan" id="kobo.795.2">However, it comes with a small penalty in that it makes it harder to read what data type the </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">variable contains.</span></span></p>
<p><span class="koboSpan" id="kobo.797.1">This makes sense for when you have a complex data type such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">IDictionary&lt;Guid, HashSet&lt;string&gt;&gt;</span></strong><span class="koboSpan" id="kobo.799.1">, but it can get a little ridiculous for short type names such </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">int</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.803.1">Other uses of var</span></p>
<p class="callout"><span class="koboSpan" id="kobo.804.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">var</span></strong><span class="koboSpan" id="kobo.806.1"> keyword does have other uses beyond what I’ve described here. </span><span class="koboSpan" id="kobo.806.2">For example, it can easily store </span><strong class="bold"><span class="koboSpan" id="kobo.807.1">anonymous types</span></strong><span class="koboSpan" id="kobo.808.1"> and other difficult-to-represent type structures, but for this book, I’m focusing on the common applications of </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">var</span></strong><span class="koboSpan" id="kobo.810.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">most codebases.</span></span></p>
<p><span class="koboSpan" id="kobo.812.1">Visual Studio does let you hover over the variable declaration and see the actual Type being used. </span><span class="koboSpan" id="kobo.812.2">In this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">p</span></strong><span class="koboSpan" id="kobo.814.1"> represents a </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">Passenger</span></strong><span class="koboSpan" id="kobo.816.1"> object, but this still slows down your reading of </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.818.1">Instead, I recommend that you take advantage of the built-in </span><strong class="bold"><span class="koboSpan" id="kobo.819.1">Use explicit type instead of ‘var’</span></strong><span class="koboSpan" id="kobo.820.1"> refactoring. </span><span class="koboSpan" id="kobo.820.2">See </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.821.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.822.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.824.1"><img alt="Figure 3.5 – Using explicit types" src="image/B21324_03_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.825.1">Figure 3.5 – Using explicit types</span></p>
<p><span class="koboSpan" id="kobo.826.1">This makes your code significantly easier </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">to read:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.828.1">Passenger p</span></strong><span class="koboSpan" id="kobo.829.1"> = Build(first, last);</span></pre>
<p><span class="koboSpan" id="kobo.830.1">Of course, </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">var</span></strong><span class="koboSpan" id="kobo.832.1"> exists for a</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.833.1"> reason and it was introduced to </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.834.1">solve certain problems, including redundancy in assignment statements. </span><span class="koboSpan" id="kobo.834.2">We’ll take a look at the </span><strong class="bold"><span class="koboSpan" id="kobo.835.1">target-typed new</span></strong><span class="koboSpan" id="kobo.836.1"> keyword next that offers a different solution to </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">that problem.</span></span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.838.1">Simplifying creation with target-typed new</span></h2>
<p><span class="koboSpan" id="kobo.839.1">One of the</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.840.1"> things the </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">var</span></strong><span class="koboSpan" id="kobo.842.1"> keyword was built to </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.843.1">help with was lines such as the following </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">variable instantiation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.845.1">
private Passenger Build(string firstName, string lastName){
     </span><strong class="bold"><span class="koboSpan" id="kobo.846.1">Passenger passenger = new Passenger();</span></strong><span class="koboSpan" id="kobo.847.1">
     passenger.FirstName = firstName;
     passenger.LastName = lastName;
     return passenger;
}</span></pre>
<p><span class="koboSpan" id="kobo.848.1">When we instantiate a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">Passenger</span></strong><span class="koboSpan" id="kobo.850.1"> object and assign it to the new passenger variable, we repeat ourselves slightly on the left and right-hand sides of the assignment operator (</span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">=</span></strong><span class="koboSpan" id="kobo.852.1">) by using the name of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">Passenger</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.854.1">class twice.</span></span></p>
<p><span class="koboSpan" id="kobo.855.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">var</span></strong><span class="koboSpan" id="kobo.857.1"> keyword allowed us to simplify the creation of this object down to the still readable syntax of </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">var passenger = new Passenger();</span></strong><span class="koboSpan" id="kobo.859.1">. </span><span class="koboSpan" id="kobo.859.2">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">var</span></strong><span class="koboSpan" id="kobo.861.1"> allows us to simplify the left-hand </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.862.1">side of this assignment statement</span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.863.1"> by abbreviating the type that’s used for the </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">new variable.</span></span></p>
<p><span class="koboSpan" id="kobo.865.1">C# 9 introduced the </span><strong class="bold"><span class="koboSpan" id="kobo.866.1">target-typed new</span></strong><span class="koboSpan" id="kobo.867.1"> keyword, which lets us simplify the right-hand side of the assignment operator by effectively saying that the type of class we’re instantiating is the same as the variable that acts as the target of the </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">assignment operator.</span></span></p>
<p><span class="koboSpan" id="kobo.869.1">In other words, target-typed new is a way of telling C# to create the same type as the variable we’ll store the value in. </span><span class="koboSpan" id="kobo.869.2">This allows us to avoid </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">var</span></strong><span class="koboSpan" id="kobo.871.1"> and not </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">repeat ourselves:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.873.1">
Passenger passenger = </span><strong class="bold"><span class="koboSpan" id="kobo.874.1">new();</span></strong></pre>
<p><span class="koboSpan" id="kobo.875.1">I love this syntax and tend to use it in all my code. </span><span class="koboSpan" id="kobo.875.2">It can cause small bits of confusion for other developers the first time they see the feature, but that’s a minor one-time penalty for something that keeps your code concise and readable at the </span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">same time.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.877.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.878.1">Visual Studio gives you a </span><strong class="bold"><span class="koboSpan" id="kobo.879.1">Use ‘new(…)’</span></strong><span class="koboSpan" id="kobo.880.1"> option in the </span><strong class="bold"><span class="koboSpan" id="kobo.881.1">Quick Action</span></strong><span class="koboSpan" id="kobo.882.1"> menu that will let you change a traditional object instantiation to the target-typed </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">new syntax.</span></span></p>
<p><span class="koboSpan" id="kobo.884.1">While we’re talking about creating objects, let’s look at how </span><strong class="bold"><span class="koboSpan" id="kobo.885.1">object initializers</span></strong><span class="koboSpan" id="kobo.886.1"> can help set properties on objects as you </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">create them.</span></span></p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.888.1">Using object initializers</span></h2>
<p><span class="koboSpan" id="kobo.889.1">Let’s take</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.890.1"> another look at that </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">Build</span></strong><span class="koboSpan" id="kobo.892.1"> method from the previous example while focusing on configuring the created </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">passenger object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.894.1">
private Passenger Build(string firstName, string lastName){
     Passenger passenger = new();
</span><strong class="bold"><span class="koboSpan" id="kobo.895.1">     passenger.FirstName = firstName;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.896.1">     </span></strong><strong class="bold"><span class="koboSpan" id="kobo.897.1">passenger.LastName = lastName;</span></strong><span class="koboSpan" id="kobo.898.1">
     return passenger;
}</span></pre>
<p><span class="koboSpan" id="kobo.899.1">This code isn’t bad at all, but it does repeat itself </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">a little.</span></span></p>
<p><span class="koboSpan" id="kobo.901.1">Specifically, the code repeats the information of the object it configures each line by putting </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">passenger.</span></strong><span class="koboSpan" id="kobo.903.1"> in front of each property before assigning a value to </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">that property.</span></span></p>
<p><span class="koboSpan" id="kobo.905.1">This is very minimal with </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.906.1">only two properties. </span><span class="koboSpan" id="kobo.906.2">But imagine a larger object with 10 or more properties you want to configure. </span><span class="koboSpan" id="kobo.906.3">This code would get very repetitive and might even distract from the names of the properties that are </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">being configured.</span></span></p>
<p><span class="koboSpan" id="kobo.908.1">While using a constructor that takes in parameters representing property values is one solution (and one we’ll explore in the next chapter), another solution is to use an </span><strong class="bold"><span class="koboSpan" id="kobo.909.1">object initializer</span></strong><span class="koboSpan" id="kobo.910.1">. </span><span class="koboSpan" id="kobo.910.2">As you’re likely guessing, Visual Studio provides a </span><strong class="bold"><span class="koboSpan" id="kobo.911.1">Quick Actions</span></strong><span class="koboSpan" id="kobo.912.1"> refactoring for this, though the name </span><strong class="bold"><span class="koboSpan" id="kobo.913.1">Object initialization can be simplified </span></strong><span class="koboSpan" id="kobo.914.1">(shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.915.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.916.1">.6</span></em><span class="koboSpan" id="kobo.917.1">) is a </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">bit unusual:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.919.1"><img alt="Figure 3.6 – Simplifying object initialization" src="image/B21324_03_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.920.1">Figure 3.6 – Simplifying object initialization</span></p>
<p><span class="koboSpan" id="kobo.921.1">Using this refactoring transforms our code into a </span><span class="No-Break"><span class="koboSpan" id="kobo.922.1">sparser format:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.923.1">
private Passenger Build(string firstName, string lastName){
     </span><strong class="bold"><span class="koboSpan" id="kobo.924.1">Passenger passenger = new() {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.925.1">           FirstName = firstName,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.926.1">           </span></strong><strong class="bold"><span class="koboSpan" id="kobo.927.1">LastName = lastName</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.928.1">     };</span></strong><span class="koboSpan" id="kobo.929.1">
     return passenger;
}</span></pre>
<p><span class="koboSpan" id="kobo.930.1">I love this syntax and it plays very nicely with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">init</span></strong><span class="koboSpan" id="kobo.932.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">required</span></strong><span class="koboSpan" id="kobo.934.1"> properties, which we’ll explore in </span><a href="B21324_10.xhtml#_idTextAnchor209"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.935.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.936.1">, </span><em class="italic"><span class="koboSpan" id="kobo.937.1">Defensive Coding Techniques</span></em><span class="koboSpan" id="kobo.938.1">. </span><span class="koboSpan" id="kobo.938.2">However, there is a downside to using object initializers: </span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">stack traces.</span></span></p>
<p><span class="koboSpan" id="kobo.940.1">When you have an object</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.941.1"> initializer that sets several different properties of an object and an exception occurs that calculates the value to store, the exception doesn’t indicate which line of code the error occurred on or which property was about to be updated, only that it occurred somewhere in </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">the initializer.</span></span></p>
<p><span class="koboSpan" id="kobo.943.1">On the other hand, if you were using multiple lines setting individual properties, the exception details would identify the line in question. </span><span class="koboSpan" id="kobo.943.2">Of course, this might be an argument to avoid doing calculations in initializers that might </span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">produce exceptions.</span></span></p>
<p><span class="koboSpan" id="kobo.945.1">We’ll revisit initializers more in </span><a href="B21324_10.xhtml#_idTextAnchor209"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.946.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.947.1"> when we discuss </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">init</span></strong><span class="koboSpan" id="kobo.949.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">required</span></strong><span class="koboSpan" id="kobo.951.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">with</span></strong><span class="koboSpan" id="kobo.953.1"> expressions, but for now, let’s move on to talking </span><span class="No-Break"><span class="koboSpan" id="kobo.954.1">about collections.</span></span></p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.955.1">Iterating over collections</span></h1>
<p><span class="koboSpan" id="kobo.956.1">To start exploring collections, let’s go back to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">BoardingProcessor</span></strong><span class="koboSpan" id="kobo.958.1"> class and look at its </span><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">DisplayPassengerBoardingStatus</span></strong><span class="koboSpan" id="kobo.960.1"> method. </span><span class="koboSpan" id="kobo.960.2">We’ll explore this method a bit at a time, starting</span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.961.1"> with its </span><span class="No-Break"><span class="koboSpan" id="kobo.962.1">method signature:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.963.1">
public void DisplayBoardingStatus(
  List&lt;Passenger&gt; passengers, bool? </span><span class="koboSpan" id="kobo.963.2">hasBoarded = null) {</span></pre>
<p><span class="koboSpan" id="kobo.964.1">Here, we can see that the method takes in a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">Passenger</span></strong><span class="koboSpan" id="kobo.966.1"> objects and, optionally, a nullable boolean </span><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">hasBoarded</span></strong><span class="koboSpan" id="kobo.968.1"> parameter that can store </span><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">true</span></strong><span class="koboSpan" id="kobo.970.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.971.1">false</span></strong><span class="koboSpan" id="kobo.972.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">null</span></strong><span class="koboSpan" id="kobo.974.1">. </span><span class="koboSpan" id="kobo.974.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">hasBoarded</span></strong><span class="koboSpan" id="kobo.976.1"> parameter is used to optionally filter down our list of passengers based on </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">its value:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">true</span></strong><span class="koboSpan" id="kobo.979.1">: Only include passengers who have boarded </span><span class="No-Break"><span class="koboSpan" id="kobo.980.1">the plane</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">false</span></strong><span class="koboSpan" id="kobo.982.1">: Only include passengers who have not </span><span class="No-Break"><span class="koboSpan" id="kobo.983.1">yet boarded</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">null</span></strong><span class="koboSpan" id="kobo.985.1">: Do not filter by boarded status (</span><span class="No-Break"><span class="koboSpan" id="kobo.986.1">default option)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.987.1">This nullable filtering </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.988.1">parameter is a common one I see while building search methods and we’ll explore it in more depth again in </span><a href="B21324_05.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.989.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.990.1">, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.991.1">Object-oriented Refactoring</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.992.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.993.1">The next portion of code in </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">DisplayBoardingStatus</span></strong><span class="koboSpan" id="kobo.995.1"> deals with the </span><span class="No-Break"><span class="koboSpan" id="kobo.996.1">filtering logic:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.997.1">
  List&lt;Passenger&gt; filteredPassengers = new();
  for (int i = 0; i &lt; passengers.Count; i++) {
     Passenger p = passengers[i];
     if (!hasBoarded.HasValue || p.HasBoarded==hasBoarded) {
        filteredPassengers.Add(p);
     }
  }</span></pre>
<p><span class="koboSpan" id="kobo.998.1">This is the portion of code we’ll be focusing on for the rest of this section. </span><span class="koboSpan" id="kobo.998.2">It builds a new list of passengers that matches the filtering option the user selected by iterating over the passengers in </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">passengers.</span></strong><span class="koboSpan" id="kobo.1000.1"> and conditionally adds it to our new list </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">of passengers.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1002.1">Terminology note</span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.1003.1">Iterating</span></strong><span class="koboSpan" id="kobo.1004.1"> over something is another term that confuses new developers. </span><span class="koboSpan" id="kobo.1004.2">It just means looping through each item in </span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">a collection.</span></span></p>
<p><span class="koboSpan" id="kobo.1006.1">The remainder of the method focuses on displaying passengers to the agent at the </span><span class="No-Break"><span class="koboSpan" id="kobo.1007.1">boarding kiosk:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1008.1">
  DisplayBoardingHeader();
  foreach (Passenger passenger in filteredPassengers) {
     string statusMessage = passenger.HasBoarded
        ? </span><span class="koboSpan" id="kobo.1008.2">"Onboard"
        : CanPassengerBoard(passenger);
     Console.WriteLine($"{passenger.FullName,-23} Group         {passenger.BoardingGroup}: {statusMessage}");
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1009.1">Essentially, for every passenger that we want to display, we write out their name, boarding group, and the</span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.1010.1"> message they see on their boarding app or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">"Onboard"</span></strong><span class="koboSpan" id="kobo.1012.1"> if they’ve already boarded </span><span class="No-Break"><span class="koboSpan" id="kobo.1013.1">the plane.</span></span></p>
<p><span class="koboSpan" id="kobo.1014.1">Overall, this method is simple and comes in at less than 20 lines of code long, which tends to lead to </span><span class="No-Break"><span class="koboSpan" id="kobo.1015.1">easy-to-maintain code.</span></span></p>
<p><span class="koboSpan" id="kobo.1016.1">That said, let’s look at a few ways we could improve </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">this code.</span></span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.1018.1">Introducing foreach</span></h2>
<p><span class="koboSpan" id="kobo.1019.1">Take another look at the </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.1020.1">code to filter the passenger list into a new list </span><span class="No-Break"><span class="koboSpan" id="kobo.1021.1">of passengers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1022.1">
List&lt;Passenger&gt; filteredPassengers = new();
</span><strong class="bold"><span class="koboSpan" id="kobo.1023.1">for (int i = 0; i &lt; passengers.Count; i++) {</span></strong><span class="koboSpan" id="kobo.1024.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.1025.1">Passenger p = passengers[i];</span></strong><span class="koboSpan" id="kobo.1026.1">
  if (!hasBoarded.HasValue || p.HasBoarded == hasBoarded) {
     filteredPassengers.Add(p);
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.1027.1">}</span></strong></pre>
<p><span class="koboSpan" id="kobo.1028.1">While this code isn’t very involved, one of the things that jumps out to me is that we’re using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1029.1">for</span></strong><span class="koboSpan" id="kobo.1030.1"> loop to enumerate through the passengers. </span><span class="koboSpan" id="kobo.1030.2">Inside this loop, we’re not doing anything with our index variable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">i</span></strong><span class="koboSpan" id="kobo.1032.1">, aside from getting a passenger out of the list by </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">its index.</span></span></p>
<p><span class="koboSpan" id="kobo.1034.1">Whenever you have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1035.1">for</span></strong><span class="koboSpan" id="kobo.1036.1"> loop like this that isn’t doing anything complex (for example, starting anywhere but the beginning of the list, looping in reverse, or skipping every other item), you can usually</span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.1037.1"> replace the loop with a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">foreach</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1039.1"> loop.</span></span></p>
<p><span class="koboSpan" id="kobo.1040.1">To convert a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">for</span></strong><span class="koboSpan" id="kobo.1042.1"> loop into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">foreach</span></strong><span class="koboSpan" id="kobo.1044.1"> loop, you can select the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1045.1">for</span></strong><span class="koboSpan" id="kobo.1046.1"> loop and then use the </span><strong class="bold"><span class="koboSpan" id="kobo.1047.1">Convert to ‘foreach’</span></strong><span class="koboSpan" id="kobo.1048.1"> refactoring feature that’s built into Visual Studio (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1049.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1050.1">.7</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.1052.1"><img alt="Figure 3.7 – The Convert to ‘foreach’ refactoring option in the Quick Actions menu" src="image/B21324_03_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1053.1">Figure 3.7 – The Convert to ‘foreach’ refactoring option in the Quick Actions menu</span></p>
<p><span class="koboSpan" id="kobo.1054.1">This moves to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">foreach</span></strong><span class="koboSpan" id="kobo.1056.1"> loop and gets rid of the variable </span><span class="No-Break"><span class="koboSpan" id="kobo.1057.1">declaration entirely:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1058.1">
List&lt;Passenger&gt; filteredPassengers = new();
</span><strong class="bold"><span class="koboSpan" id="kobo.1059.1">foreach (Passenger p in passengers) {</span></strong><span class="koboSpan" id="kobo.1060.1">
  if (!hasBoarded.HasValue || p.HasBoarded == hasBoarded) {
     filteredPassengers.Add(p);
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.1061.1">}</span></strong></pre>
<p><span class="koboSpan" id="kobo.1062.1">I use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">foreach</span></strong><span class="koboSpan" id="kobo.1064.1"> wherever I can because not only does it remove a variable declaration and use of the indexer, but it makes the overall code easier </span><span class="No-Break"><span class="koboSpan" id="kobo.1065.1">to read.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.1066.1">Almost all</span></em> <strong class="source-inline"><span class="koboSpan" id="kobo.1067.1">for</span></strong><span class="koboSpan" id="kobo.1068.1"> loops start at 0 and loop up to the end of the collection one item at a time, but not every </span><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">for</span></strong><span class="koboSpan" id="kobo.1070.1"> loop does this. </span><span class="koboSpan" id="kobo.1070.2">As a result, whenever I read a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1071.1">for</span></strong><span class="koboSpan" id="kobo.1072.1"> loop, I need to check if it is a standard </span><strong class="source-inline"><span class="koboSpan" id="kobo.1073.1">for</span></strong><span class="koboSpan" id="kobo.1074.1"> loop or if there’s something special about it. </span><span class="koboSpan" id="kobo.1074.2">With a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1075.1">foreach</span></strong><span class="koboSpan" id="kobo.1076.1"> loop, I don’t need to do this because the syntax doesn’t support it. </span><span class="koboSpan" id="kobo.1076.2">This increases reading comfort and speed and improves the maintainability of your code </span><span class="No-Break"><span class="koboSpan" id="kobo.1077.1">through simplicity.</span></span></p>
<p><span class="koboSpan" id="kobo.1078.1">Additionally, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1079.1">foreach</span></strong><span class="koboSpan" id="kobo.1080.1"> loop can be used with anything that implements </span><strong class="source-inline"><span class="koboSpan" id="kobo.1081.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.1082.1">, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.1083.1">for</span></strong><span class="koboSpan" id="kobo.1084.1"> loops require</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.1085.1"> the collection they loop over to have an indexer. </span><span class="koboSpan" id="kobo.1085.2">This means that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">foreach</span></strong><span class="koboSpan" id="kobo.1087.1"> loops can loop over more types of collections than </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">for</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1089.1">loops can.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1090.1">Collection interfaces</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1091.1">.NET provides several collection interfaces, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.1092.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.1093.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1094.1">ICollection</span></strong><span class="koboSpan" id="kobo.1095.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">IList</span></strong><span class="koboSpan" id="kobo.1097.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">IReadOnlyList</span></strong><span class="koboSpan" id="kobo.1099.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1100.1">IReadOnlyCollection</span></strong><span class="koboSpan" id="kobo.1101.1">. </span><span class="koboSpan" id="kobo.1101.2">Knowledge of these collection types is helpful but not required to read this book. </span><span class="koboSpan" id="kobo.1101.3">See the </span><em class="italic"><span class="koboSpan" id="kobo.1102.1">Further reading</span></em><span class="koboSpan" id="kobo.1103.1"> section at the end of this chapter for a link to more information on these interfaces, but for now, know that an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1104.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.1105.1"> interface is just a fancy way of referring to something that can be looped over in a </span><span class="No-Break"><span class="koboSpan" id="kobo.1106.1">foreach loop.</span></span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.1107.1">Converting to for loops</span></h2>
<p><span class="koboSpan" id="kobo.1108.1">While </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">foreach</span></strong><span class="koboSpan" id="kobo.1110.1"> loops are fantastic and</span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.1111.1"> my default loop in most cases, sometimes, you want to have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">for</span></strong><span class="koboSpan" id="kobo.1113.1"> loop for a little bit of added control. </span><span class="koboSpan" id="kobo.1113.2">If you ever need to loop over a collection in a non-standard way or need to use the index variable for something other than reading a variable out of the collection, you usually will want to use a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">for</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1115.1"> loop.</span></span></p>
<p><span class="koboSpan" id="kobo.1116.1">Visual Studio gives us a </span><strong class="bold"><span class="koboSpan" id="kobo.1117.1">Convert to ‘for’</span></strong><span class="koboSpan" id="kobo.1118.1"> refactoring that will transform </span><strong class="source-inline"><span class="koboSpan" id="kobo.1119.1">foreach</span></strong><span class="koboSpan" id="kobo.1120.1"> loops into </span><strong class="source-inline"><span class="koboSpan" id="kobo.1121.1">for</span></strong><span class="koboSpan" id="kobo.1122.1"> loops for you. </span><span class="koboSpan" id="kobo.1122.2">See </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1123.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1124.1">.8</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1125.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.1126.1"><img alt="Figure 3.8 – Converting a foreach loop back to a for loop" src="image/B21324_03_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1127.1">Figure 3.8 – Converting a foreach loop back to a for loop</span></p>
<p><span class="koboSpan" id="kobo.1128.1">I don’t find myself using this refactoring very much, but it’s handy when you </span><span class="No-Break"><span class="koboSpan" id="kobo.1129.1">need it.</span></span></p>
<p><span class="koboSpan" id="kobo.1130.1">For now, let’s leave the </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.1131.1">code in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1132.1">foreach</span></strong><span class="koboSpan" id="kobo.1133.1"> loop and look at how LINQ can help us make </span><span class="No-Break"><span class="koboSpan" id="kobo.1134.1">it better.</span></span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.1135.1">Converting to LINQ</span></h2>
<p><span class="koboSpan" id="kobo.1136.1">You may have noticed that, in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1137.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1138.1">.8</span></em><span class="koboSpan" id="kobo.1139.1">, there were a </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.1140.1">pair of suggestions to convert the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1141.1">foreach</span></strong><span class="koboSpan" id="kobo.1142.1"> loop </span><span class="No-Break"><span class="koboSpan" id="kobo.1143.1">into LINQ.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.1144.1">LINQ</span></strong><span class="koboSpan" id="kobo.1145.1"> stands for </span><strong class="bold"><span class="koboSpan" id="kobo.1146.1">Language INtegrated Query</span></strong><span class="koboSpan" id="kobo.1147.1"> and provides a set of extension methods that work on any collection that implements </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.1149.1">. </span><span class="koboSpan" id="kobo.1149.2">This allows you to perform quick aggregation, transformation, and filtering operations on that collection using </span><span class="No-Break"><span class="koboSpan" id="kobo.1150.1">arrow functions.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1151.1">Arrow functions</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1152.1">Arrow functions (also called Lambda expressions) use “fat arrow” (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1153.1">=&gt;</span></strong><span class="koboSpan" id="kobo.1154.1">) syntax to represent small methods in an abbreviated format. </span><span class="koboSpan" id="kobo.1154.2">This book assumes a basic understanding of </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.1155.1">arrow functions. </span><span class="koboSpan" id="kobo.1155.2">See the </span><em class="italic"><span class="koboSpan" id="kobo.1156.1">Further reading</span></em><span class="koboSpan" id="kobo.1157.1"> section of this chapter if you need more information or want a refresher on how arrow </span><span class="No-Break"><span class="koboSpan" id="kobo.1158.1">functions work.</span></span></p>
<p><span class="koboSpan" id="kobo.1159.1">Let’s look at what happens to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">foreach</span></strong><span class="koboSpan" id="kobo.1161.1"> loop when we use the </span><strong class="bold"><span class="koboSpan" id="kobo.1162.1">Convert to LINQ (call form)</span></strong><span class="koboSpan" id="kobo.1163.1"> refactoring in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1164.1">foreach</span></strong><span class="koboSpan" id="kobo.1165.1"> loop’s </span><strong class="bold"><span class="koboSpan" id="kobo.1166.1">Quick </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1167.1">Actions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1168.1"> menu:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.1169.1"><img alt="Figure 3.9 – Converting a foreach loop to use LINQ" src="image/B21324_03_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1170.1">Figure 3.9 – Converting a foreach loop to use LINQ</span></p>
<p><span class="koboSpan" id="kobo.1171.1">This refactoring transforms our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1172.1">foreach</span></strong><span class="koboSpan" id="kobo.1173.1"> loop into just a tiny portion </span><span class="No-Break"><span class="koboSpan" id="kobo.1174.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1175.1">
List&lt;Passenger&gt; filteredPassengers = new();
</span><strong class="bold"><span class="koboSpan" id="kobo.1176.1">filteredPassengers.AddRange(passengers.Where(p =&gt; !hasBoarded.HasValue || p.HasBoarded == hasBoarded));</span></strong></pre>
<p><span class="koboSpan" id="kobo.1177.1">This code takes our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">passengers</span></strong><span class="koboSpan" id="kobo.1179.1"> collection and calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1180.1">Where</span></strong><span class="koboSpan" id="kobo.1181.1"> extension method. </span><span class="koboSpan" id="kobo.1181.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1182.1">Where</span></strong><span class="koboSpan" id="kobo.1183.1"> method will </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.1184.1">create and return a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1185.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.1186.1"> sequence of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1187.1">passengers</span></strong><span class="koboSpan" id="kobo.1188.1"> and only includes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1189.1">passengers</span></strong><span class="koboSpan" id="kobo.1190.1"> where the arrow function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1191.1">p =&gt; !hasBoarded.HasValue || p.HasBoarded == hasBoarded</span></strong><span class="koboSpan" id="kobo.1192.1">, returns a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1193.1">true</span></strong><span class="koboSpan" id="kobo.1194.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.1195.1">that passenger.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1196.1">Extension methods</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1197.1">Extension methods are static methods defined</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.1198.1"> in static classes that allow you to build syntax that looks like it adds new methods to existing types. </span><span class="koboSpan" id="kobo.1198.2">LINQ relies heavily on extension methods attached to various interfaces. </span><span class="koboSpan" id="kobo.1198.3">We’ll explore creating extension methods in </span><a href="B21324_04.xhtml#_idTextAnchor072"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1199.1">Chapter 4</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1200.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1201.1">This won’t modify our original collection, instead creating a new collection of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1202.1">Passenger</span></strong><span class="koboSpan" id="kobo.1203.1"> objects that are then passed into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1204.1">filteredPassengers.AddRange</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1205.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.1206.1">While this code is already very brief, we can improve it further by taking advantage of a constructor on the generic </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1207.1">List</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1208.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.1209.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">List&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1211.1"> class has a constructor that takes in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1212.1">IEnumerable&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1213.1"> interface and allows you to efficiently create a new list around a sequence of elements. </span><span class="koboSpan" id="kobo.1213.2">This will let us avoid needing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">AddRange</span></strong><span class="koboSpan" id="kobo.1215.1"> call and helps simplify our code down to a </span><span class="No-Break"><span class="koboSpan" id="kobo.1216.1">single statement:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1217.1">
List&lt;Passenger&gt; filteredPassengers =
  </span><strong class="bold"><span class="koboSpan" id="kobo.1218.1">new(</span></strong><span class="koboSpan" id="kobo.1219.1">passengers.Where(p =&gt; !hasBoarded.HasValue ||
      p.HasBoarded == hasBoarded)</span><strong class="bold"><span class="koboSpan" id="kobo.1220.1">)</span></strong><span class="koboSpan" id="kobo.1221.1">;</span></pre>
<p><span class="koboSpan" id="kobo.1222.1">If we wanted to, we could also get rid of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1223.1">filteredPassengers</span></strong><span class="koboSpan" id="kobo.1224.1"> variable entirely by filtering passengers down and reassigning it back </span><span class="No-Break"><span class="koboSpan" id="kobo.1225.1">into itself:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1226.1">passengers = passengers.Where</span></strong><span class="koboSpan" id="kobo.1227.1">(p=&gt;!hasBoarded.HasValue ||
      p.HasBoarded==hasBoarded)</span><strong class="bold"><span class="koboSpan" id="kobo.1228.1">.ToList()</span></strong><span class="koboSpan" id="kobo.1229.1">;</span></pre>
<p><span class="koboSpan" id="kobo.1230.1">Here, we perform the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1231.1">Where</span></strong><span class="koboSpan" id="kobo.1232.1"> call to generate an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1233.1">IEnumerable&lt;Passenger&gt;</span></strong><span class="koboSpan" id="kobo.1234.1"> interface containing our passengers and then call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1235.1">ToList</span></strong><span class="koboSpan" id="kobo.1236.1"> method on that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1237.1">IEnumerable</span></strong><span class="koboSpan" id="kobo.1238.1"> interface to convert it back into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1239.1">List</span></strong><span class="koboSpan" id="kobo.1240.1"> method so that it can be stored in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1241.1">passengers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1242.1"> parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.1243.1">Also, note that any place that</span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.1244.1"> was using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">filteredPassengers</span></strong><span class="koboSpan" id="kobo.1246.1"> before will need to be updated to use </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1247.1">passengers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1248.1"> instead:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1249.1">
foreach (Passenger passenger in </span><strong class="bold"><span class="koboSpan" id="kobo.1250.1">passengers</span></strong><span class="koboSpan" id="kobo.1251.1">) {
  string statusMessage = passenger.HasBoarded
     ? </span><span class="koboSpan" id="kobo.1251.2">"Onboard"
     : CanPassengerBoard(passenger);
  Console.WriteLine($"{passenger.FullName,-23} Group 
     {passenger.BoardingGroup}: {statusMessage}");
}</span></pre>
<p><span class="koboSpan" id="kobo.1252.1">I love LINQ and find it to be invaluable for creating simple and maintainable applications, but it does take some getting used to if you’re not familiar with LINQ or not used to reading arrow function (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1253.1">=&gt;</span></strong><span class="koboSpan" id="kobo.1254.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.1255.1">notation.</span></span></p>
<p><span class="koboSpan" id="kobo.1256.1">That said, I do see some common mistakes in LINQ code. </span><span class="koboSpan" id="kobo.1256.2">So, let’s look at a few of those before we close out </span><span class="No-Break"><span class="koboSpan" id="kobo.1257.1">this chapter.</span></span></p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.1258.1">Refactoring LINQ statements</span></h1>
<p><span class="koboSpan" id="kobo.1259.1">In this final section of this </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.1260.1">chapter, we’ll review a few of the more common optimizations with LINQ code by focusing on some common improvements most codebases that use LINQ will </span><span class="No-Break"><span class="koboSpan" id="kobo.1261.1">benefit from.</span></span></p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.1262.1">Choosing the correct LINQ method</span></h2>
<p><span class="koboSpan" id="kobo.1263.1">LINQ has several different </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.1264.1">ways of finding a specific item in </span><span class="No-Break"><span class="koboSpan" id="kobo.1265.1">a collection.</span></span></p>
<p><span class="koboSpan" id="kobo.1266.1">If you had an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1267.1">IEnumerable&lt;Passenger&gt;</span></strong><span class="koboSpan" id="kobo.1268.1"> interface named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1269.1">people</span></strong><span class="koboSpan" id="kobo.1270.1"> and wanted to find someone by their name, you might write code </span><span class="No-Break"><span class="koboSpan" id="kobo.1271.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1272.1">LinqExamples.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1273.1">
PassengerGenerator generator = new();
List&lt;Passenger&gt; people = generator.GeneratePassengers(50);
</span><strong class="bold"><span class="koboSpan" id="kobo.1274.1">Passenger me =</span></strong><span class="koboSpan" id="kobo.1275.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.1276.1">people.FirstOrDefault(p =&gt; p.FullName == "Matt Eland");</span></strong><span class="koboSpan" id="kobo.1277.1">
Console.WriteLine($"Matt is in group {</span><strong class="bold"><span class="koboSpan" id="kobo.1278.1">me.BoardingGroup</span></strong><span class="koboSpan" id="kobo.1279.1">}");</span></pre>
<p><span class="koboSpan" id="kobo.1280.1">This code uses the LINQ </span><strong class="source-inline"><span class="koboSpan" id="kobo.1281.1">FirstOrDefault</span></strong><span class="koboSpan" id="kobo.1282.1"> method, which searches the collection until it finds the first value that the arrow function</span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.1283.1"> evaluates as true. </span><span class="koboSpan" id="kobo.1283.2">In this example, it’d find the first person with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1284.1">FullName</span></strong><span class="koboSpan" id="kobo.1285.1"> set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1286.1">"Matt Eland"</span></strong><span class="koboSpan" id="kobo.1287.1">, return that value from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1288.1">FirstOrDefault</span></strong><span class="koboSpan" id="kobo.1289.1"> method, and store it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1290.1">Passenger</span></strong><span class="koboSpan" id="kobo.1291.1"> variable </span><span class="No-Break"><span class="koboSpan" id="kobo.1292.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1293.1">matt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1294.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1295.1">However, if no items returned </span><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">true</span></strong><span class="koboSpan" id="kobo.1297.1"> from the arrow function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1298.1">FirstOrDefault</span></strong><span class="koboSpan" id="kobo.1299.1"> will use the default value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1300.1">Passenger</span></strong><span class="koboSpan" id="kobo.1301.1"> type, which would be null for a reference type such as </span><span class="No-Break"><span class="koboSpan" id="kobo.1302.1">a class.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1303.1">Default values</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1304.1">In .NET, the default value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1305.1">bool</span></strong><span class="koboSpan" id="kobo.1306.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1307.1">false</span></strong><span class="koboSpan" id="kobo.1308.1">, numeric types such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1309.1">int</span></strong><span class="koboSpan" id="kobo.1310.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1311.1">float</span></strong><span class="koboSpan" id="kobo.1312.1"> default to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1313.1">0</span></strong><span class="koboSpan" id="kobo.1314.1">, and reference types including </span><strong class="source-inline"><span class="koboSpan" id="kobo.1315.1">string</span></strong><span class="koboSpan" id="kobo.1316.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1317.1">List</span></strong><span class="koboSpan" id="kobo.1318.1">, and other classes default </span><span class="No-Break"><span class="koboSpan" id="kobo.1319.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1320.1">null</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1321.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1322.1">In other words, this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1323.1">FirstOrDefault</span></strong><span class="koboSpan" id="kobo.1324.1"> call will find Matt if he exists in passengers and return him or return </span><strong class="source-inline"><span class="koboSpan" id="kobo.1325.1">null</span></strong><span class="koboSpan" id="kobo.1326.1"> if </span><span class="No-Break"><span class="koboSpan" id="kobo.1327.1">he doesn’t.</span></span></p>
<p><span class="koboSpan" id="kobo.1328.1">The problem with this is that the very next line attempts to read the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1329.1">matt.BoardingGroup</span></strong><span class="koboSpan" id="kobo.1330.1">. </span><span class="koboSpan" id="kobo.1330.2">This is fine if we found the element, but if we didn’t, this code will get a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1331.1">NullReferenceException</span></strong><span class="koboSpan" id="kobo.1332.1"> error upon trying to access </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">BoardingGroup</span></strong><span class="koboSpan" id="kobo.1334.1">, which is likely not what its </span><span class="No-Break"><span class="koboSpan" id="kobo.1335.1">author intended.</span></span></p>
<p><span class="koboSpan" id="kobo.1336.1">Note that how we fix this code depends on what our </span><span class="No-Break"><span class="koboSpan" id="kobo.1337.1">expectations are.</span></span></p>
<p><span class="koboSpan" id="kobo.1338.1">With LINQ, when you are looking for an element in a collection, you need to decide on </span><span class="No-Break"><span class="koboSpan" id="kobo.1339.1">two things:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1340.1">Am I okay with more than one item matching my arrow function or do I need to make sure that </span><em class="italic"><span class="koboSpan" id="kobo.1341.1">at most</span></em><span class="koboSpan" id="kobo.1342.1"> one item </span><span class="No-Break"><span class="koboSpan" id="kobo.1343.1">returns true?</span></span></li>
<li><span class="koboSpan" id="kobo.1344.1">Am I okay with the item I’m looking for not being present </span><span class="No-Break"><span class="koboSpan" id="kobo.1345.1">at all?</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1346.1">The first decision governs whether</span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.1347.1"> you are making a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1348.1">First</span></strong><span class="koboSpan" id="kobo.1349.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1350.1">Single</span></strong><span class="koboSpan" id="kobo.1351.1">. </span><span class="koboSpan" id="kobo.1351.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.1352.1">First</span></strong><span class="koboSpan" id="kobo.1353.1">, the logic will find the first element that matches the query and return it. </span><span class="koboSpan" id="kobo.1353.2">However, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1354.1">Single</span></strong><span class="koboSpan" id="kobo.1355.1">, the logic will keep going past the first match to determine if any other element in the collection matches that expression as well. </span><span class="koboSpan" id="kobo.1355.2">If one does match the expression, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1356.1">InvalidOperationException</span></strong><span class="koboSpan" id="kobo.1357.1"> error is thrown, telling you that the sequence contains more than one </span><span class="No-Break"><span class="koboSpan" id="kobo.1358.1">matching element.</span></span></p>
<p><span class="koboSpan" id="kobo.1359.1">Most developers don’t like seeing exceptions when they’re running their code. </span><span class="koboSpan" id="kobo.1359.2">However, sometimes, you need to know if there’s more than one match to your query. </span><span class="koboSpan" id="kobo.1359.3">In general, it’s better to fail early than fail later in a more confusing spot that hides where the program first got </span><span class="No-Break"><span class="koboSpan" id="kobo.1360.1">off track.</span></span></p>
<p><span class="koboSpan" id="kobo.1361.1">The second decision you make when finding an element in a collection involves being okay with objects not being present that match the query. </span><span class="koboSpan" id="kobo.1361.2">If that’s fine, then you will generally want to make a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1362.1">FirstOrDefault</span></strong><span class="koboSpan" id="kobo.1363.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1364.1">SingleOrDefault</span></strong><span class="koboSpan" id="kobo.1365.1"> (depending on your decision earlier on whether multiple matches are permissible). </span><span class="koboSpan" id="kobo.1365.2">However, if it is never acceptable to not have a match, then you’ll use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1366.1">First</span></strong><span class="koboSpan" id="kobo.1367.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1368.1">Single</span></strong><span class="koboSpan" id="kobo.1369.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1370.1">FirstOrDefault</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1371.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1372.1">SingleOrDefault</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1373.1">.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1374.1">First</span></strong><span class="koboSpan" id="kobo.1375.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1376.1">Single</span></strong><span class="koboSpan" id="kobo.1377.1"> will both throw an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1378.1">InvalidOperationException</span></strong><span class="koboSpan" id="kobo.1379.1"> error if the sequence contains no matching element. </span><span class="koboSpan" id="kobo.1379.2">If you use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1380.1">First</span></strong><span class="koboSpan" id="kobo.1381.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1382.1">Single</span></strong><span class="koboSpan" id="kobo.1383.1"> and nothing in the collection returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1384.1">true</span></strong><span class="koboSpan" id="kobo.1385.1"> from the arrow function, the exception will be thrown. </span><span class="koboSpan" id="kobo.1385.2">This makes it impossible to deal with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1386.1">null</span></strong><span class="koboSpan" id="kobo.1387.1"> values with the result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1388.1">First</span></strong><span class="koboSpan" id="kobo.1389.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1390.1">Single</span></strong><span class="koboSpan" id="kobo.1391.1">, which can be very helpful for simplifying </span><span class="No-Break"><span class="koboSpan" id="kobo.1392.1">your code.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1393.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1394.1">Having an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1395.1">InvalidOperationException</span></strong><span class="koboSpan" id="kobo.1396.1"> error thrown at the exact position your code encounters a problem can be immensely more helpful than encountering a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1397.1">NullReferenceException</span></strong><span class="koboSpan" id="kobo.1398.1"> error 30 lines later in your code and having to figure out how a value got where it was supposed </span><span class="No-Break"><span class="koboSpan" id="kobo.1399.1">to be.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.1400.1">Null-state analysis</span></strong><span class="koboSpan" id="kobo.1401.1"> is another feature that can help prevent a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">NullReferenceException</span></strong><span class="koboSpan" id="kobo.1403.1"> error</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.1404.1"> from occurring. </span><span class="koboSpan" id="kobo.1404.2">We’ll explore this in more </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.1405.1">depth in </span><a href="B21324_10.xhtml#_idTextAnchor209"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1406.1">Chapter 10</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1407.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1408.1">Let’s move on and discuss ways of combining </span><span class="No-Break"><span class="koboSpan" id="kobo.1409.1">LINQ methods.</span></span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.1410.1">Combining LINQ methods</span></h2>
<p><span class="koboSpan" id="kobo.1411.1">One of the nice things</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.1412.1"> about LINQ is that it lets you “chain together” different methods by calling a LINQ method on the result of another LINQ method. </span><span class="koboSpan" id="kobo.1412.2">This lets you do things such as filter down to a subset of items using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1413.1">Where</span></strong><span class="koboSpan" id="kobo.1414.1">, reorder the results with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1415.1">OrderBy</span></strong><span class="koboSpan" id="kobo.1416.1">, and transform them into new objects </span><span class="No-Break"><span class="koboSpan" id="kobo.1417.1">via </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1418.1">Select</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1419.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1420.1">However, as .NET has evolved, LINQ has grown a few more specialized overloads of its existing methods, which makes some of these chained-together methods unnecessary or </span><span class="No-Break"><span class="koboSpan" id="kobo.1421.1">even inefficient.</span></span></p>
<p><span class="koboSpan" id="kobo.1422.1">Look at this block of code as </span><span class="No-Break"><span class="koboSpan" id="kobo.1423.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1424.1">
bool anyBoarded =
  people</span><strong class="bold"><span class="koboSpan" id="kobo.1425.1">.Where</span></strong><span class="koboSpan" id="kobo.1426.1">(p =&gt; p.HasBoarded)</span><strong class="bold"><span class="koboSpan" id="kobo.1427.1">.Any</span></strong><span class="koboSpan" id="kobo.1428.1">();
int numBoarded =
  people</span><strong class="bold"><span class="koboSpan" id="kobo.1429.1">.Where</span></strong><span class="koboSpan" id="kobo.1430.1">(p =&gt; p.HasBoarded)</span><strong class="bold"><span class="koboSpan" id="kobo.1431.1">.Count</span></strong><span class="koboSpan" id="kobo.1432.1">();
Passenger firstBoarded =
  people</span><strong class="bold"><span class="koboSpan" id="kobo.1433.1">.Where</span></strong><span class="koboSpan" id="kobo.1434.1">(p =&gt; p.HasBoarded)</span><strong class="bold"><span class="koboSpan" id="kobo.1435.1">.First</span></strong><span class="koboSpan" id="kobo.1436.1">();</span></pre>
<p><span class="koboSpan" id="kobo.1437.1">At first glance, this code looks fine. </span><span class="koboSpan" id="kobo.1437.2">Each of these three variable assignments is filtering down and then looking at the results of that filtering option. </span><span class="koboSpan" id="kobo.1437.3">Sure, there’s an opportunity to introduce a local variable for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1438.1">people.Where(p =&gt; p.HasBoarded)</span></strong><span class="koboSpan" id="kobo.1439.1">, but otherwise, the code often looks fine at </span><span class="No-Break"><span class="koboSpan" id="kobo.1440.1">a glance.</span></span></p>
<p><span class="koboSpan" id="kobo.1441.1">However, LINQ offers overloaded versions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1442.1">Any</span></strong><span class="koboSpan" id="kobo.1443.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1444.1">Count</span></strong><span class="koboSpan" id="kobo.1445.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1446.1">First</span></strong><span class="koboSpan" id="kobo.1447.1">, and a few other methods that take in a </span><strong class="bold"><span class="koboSpan" id="kobo.1448.1">predicate</span></strong><span class="koboSpan" id="kobo.1449.1"> (which is just a fancy word for an </span><span class="No-Break"><span class="koboSpan" id="kobo.1450.1">arrow function).</span></span></p>
<p><span class="koboSpan" id="kobo.1451.1">These overloaded versions allow you to combine </span><strong class="source-inline"><span class="koboSpan" id="kobo.1452.1">Where</span></strong><span class="koboSpan" id="kobo.1453.1"> methods and other methods into a more </span><span class="No-Break"><span class="koboSpan" id="kobo.1454.1">concise format:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1455.1">
bool anyBoarded = </span><strong class="bold"><span class="koboSpan" id="kobo.1456.1">people.Any(p =&gt; p.HasBoarded);</span></strong><span class="koboSpan" id="kobo.1457.1">
int numBoarded = </span><strong class="bold"><span class="koboSpan" id="kobo.1458.1">people.Count(p =&gt; p.HasBoarded);</span></strong><span class="koboSpan" id="kobo.1459.1">
Passenger firstBoarded = </span><strong class="bold"><span class="koboSpan" id="kobo.1460.1">people.First(p =&gt; p.HasBoarded);</span></strong></pre>
<p><span class="koboSpan" id="kobo.1461.1">Not only is this way of writing things more concise, but these overloads can be more efficient in </span><span class="No-Break"><span class="koboSpan" id="kobo.1462.1">some cases.</span></span></p>
<p><span class="koboSpan" id="kobo.1463.1">For example, before, when we were doing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1464.1">people.Where(p =&gt; p.HasBoarded).Any()</span></strong><span class="koboSpan" id="kobo.1465.1">, this code evaluated left to right, filtering down a large list of items into a smaller list of items. </span><span class="koboSpan" id="kobo.1465.2">Once the entire list had been filtered down, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1466.1">Any</span></strong><span class="koboSpan" id="kobo.1467.1"> method call occurred, which</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.1468.1"> returned </span><strong class="source-inline"><span class="koboSpan" id="kobo.1469.1">true</span></strong><span class="koboSpan" id="kobo.1470.1"> if at least one item was found in that </span><span class="No-Break"><span class="koboSpan" id="kobo.1471.1">resulting list.</span></span></p>
<p><span class="koboSpan" id="kobo.1472.1">Contrast this to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1473.1">people.Any(p =&gt; p.HasBoarded)</span></strong><span class="koboSpan" id="kobo.1474.1"> version. </span><span class="koboSpan" id="kobo.1474.2">This method loops over the items and as soon as it sees any element that returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1475.1">true</span></strong><span class="koboSpan" id="kobo.1476.1"> from the arrow function, it knows it can stop evaluating because its ultimate result is going to </span><span class="No-Break"><span class="koboSpan" id="kobo.1477.1">be true.</span></span></p>
<p><span class="koboSpan" id="kobo.1478.1">Always look for opportunities to use these specialized LINQ overloads as they can result in very concise and even more </span><span class="No-Break"><span class="koboSpan" id="kobo.1479.1">performant code.</span></span></p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.1480.1">Transforming with Select</span></h2>
<p><span class="koboSpan" id="kobo.1481.1">Let’s say you wanted to </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.1482.1">create a list of strings for all the </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.1483.1">passengers who hadn’t boarded the plane yet. </span><span class="koboSpan" id="kobo.1483.2">For each name, you want it formatted with the person’s name and then their boarding group. </span><span class="koboSpan" id="kobo.1483.3">So, a sample entry might be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1484.1">"</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1485.1">Priya Gupta-7"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1486.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1487.1">You could write this code </span><span class="No-Break"><span class="koboSpan" id="kobo.1488.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1489.1">
List&lt;string&gt; names = new();
foreach (Passenger p in people) {
  if (!p.HasBoarded) {
     </span><strong class="bold"><span class="koboSpan" id="kobo.1490.1">names.Add($"{p.FullName}-{p.BoardingGroup}");</span></strong><span class="koboSpan" id="kobo.1491.1">
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1492.1">However, LINQ has a method named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1493.1">Select</span></strong><span class="koboSpan" id="kobo.1494.1"> that allows you to transform items from one form into another, which would be perfect for </span><span class="No-Break"><span class="koboSpan" id="kobo.1495.1">this case.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1496.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1497.1">For those of you with a JavaScript background, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1498.1">Select</span></strong><span class="koboSpan" id="kobo.1499.1"> is similar to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1500.1">Map</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1501.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.1502.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1503.1">Select</span></strong><span class="koboSpan" id="kobo.1504.1"> version </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.1505.1">of this looks </span><span class="No-Break"><span class="koboSpan" id="kobo.1506.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1507.1">
List&lt;string&gt; names =
        people.Where(p =&gt; !p.HasBoarded)
                 </span><strong class="bold"><span class="koboSpan" id="kobo.1508.1">.Select(p =&gt; $"{p.FullName}-{p.BoardingGroup}")</span></strong><span class="koboSpan" id="kobo.1509.1">
                 .ToList();</span></pre>
<p><span class="koboSpan" id="kobo.1510.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1511.1">Where</span></strong><span class="koboSpan" id="kobo.1512.1"> call filtered</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.1513.1"> the results down to non-boarded passengers and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1514.1">Select</span></strong><span class="koboSpan" id="kobo.1515.1"> call transformed those objects from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1516.1">Passenger</span></strong><span class="koboSpan" id="kobo.1517.1"> objects </span><span class="No-Break"><span class="koboSpan" id="kobo.1518.1">into strings.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1519.1">Select</span></strong><span class="koboSpan" id="kobo.1520.1"> isn’t limited to just strings. </span><span class="koboSpan" id="kobo.1520.2">You can select whatever data type is relevant for you, including integers, other objects, lists, or even </span><strong class="bold"><span class="koboSpan" id="kobo.1521.1">anonymous types</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1522.1">or </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1523.1">tuples</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1524.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1525.1">Ultimately, whenever you have a collection of objects in one shape and you need those same objects but in a different form, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1526.1">Select</span></strong><span class="koboSpan" id="kobo.1527.1"> is a great method </span><span class="No-Break"><span class="koboSpan" id="kobo.1528.1">to consider.</span></span></p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.1529.1">Reviewing and testing our refactored code</span></h1>
<p><span class="koboSpan" id="kobo.1530.1">While we didn’t modify a lot of code in this chapter, the code we did change shrunk in size, thus becoming easier to read, understand, and modify in </span><span class="No-Break"><span class="koboSpan" id="kobo.1531.1">the process.</span></span></p>
<p><span class="koboSpan" id="kobo.1532.1">This is why we refactor. </span><span class="koboSpan" id="kobo.1532.2">Refactoring</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.1533.1"> should actively improve the maintainability of our applications and pay down strategic pieces of technical debt that threaten to introduce bugs and delays in </span><span class="No-Break"><span class="koboSpan" id="kobo.1534.1">the future.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1535.1">Refactored code</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1536.1">The final refactored code from this chapter is available in the </span><a href="https://github.com/PacktPublishing/Refactoring-with-Csharp"><span class="koboSpan" id="kobo.1537.1">https://github.com/PacktPublishing/Refactoring-with-Csharp</span></a><span class="koboSpan" id="kobo.1538.1"> repository inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1539.1">Chapter03/Ch3RefactoredCode</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1540.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.1541.1">Since the art of refactoring involves changing the form of code without changing its functionality, we must test the application before </span><span class="No-Break"><span class="koboSpan" id="kobo.1542.1">moving on.</span></span></p>
<p><span class="koboSpan" id="kobo.1543.1">We’ll talk more about manual and automated tests in </span><a href="B21324_06.xhtml#_idTextAnchor133"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1544.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.1545.1">, but for now, run the tests by selecting </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.1546.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.1547.1">Test</span></strong><span class="koboSpan" id="kobo.1548.1"> menu at </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.1549.1">the top of Visual Studio and then clicking </span><strong class="bold"><span class="koboSpan" id="kobo.1550.1">Run </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1551.1">All Tests</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1552.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1553.1">This will show </span><strong class="bold"><span class="koboSpan" id="kobo.1554.1">Test Explorer</span></strong><span class="koboSpan" id="kobo.1555.1"> and a sea of green check marks, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1556.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1557.1">.10</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1558.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.1559.1"><img alt="Figure 3.10 – Passing tests for this chapter’s code" src="image/B21324_03_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1560.1">Figure 3.10 – Passing tests for this chapter’s code</span></p>
<p><span class="koboSpan" id="kobo.1561.1">Now, let’s summarize what we’ve learned in </span><span class="No-Break"><span class="koboSpan" id="kobo.1562.1">this chapter.</span></span></p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.1563.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1564.1">In this chapter, we explored refactoring techniques to help better control program flow, instantiate objects, iterate over collections, and write more efficient code </span><span class="No-Break"><span class="koboSpan" id="kobo.1565.1">through LINQ.</span></span></p>
<p><span class="koboSpan" id="kobo.1566.1">Each refactoring technique we covered is one tool in your toolbelt that might improve the readability and maintainability of your code in the right circumstances. </span><span class="koboSpan" id="kobo.1566.2">As you practice refactoring more, you’ll learn more about when to apply which refactoring to improve the code you’re </span><span class="No-Break"><span class="koboSpan" id="kobo.1567.1">working with.</span></span></p>
<p><span class="koboSpan" id="kobo.1568.1">In the next chapter, we’ll move on from improving individual lines of code and focus on a slightly bigger picture as we work to refactor entire methods of </span><span class="No-Break"><span class="koboSpan" id="kobo.1569.1">C# code.</span></span></p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.1570.1">Questions</span></h1>
<p><span class="koboSpan" id="kobo.1571.1">Answer the following questions to test your knowledge of </span><span class="No-Break"><span class="koboSpan" id="kobo.1572.1">this chapter:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1573.1">Is it more important to have concise code or </span><span class="No-Break"><span class="koboSpan" id="kobo.1574.1">readable code?</span></span></li>
<li><span class="koboSpan" id="kobo.1575.1">Scroll through a file of code in a project you are working on. </span><span class="koboSpan" id="kobo.1575.2">What do you notice about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1576.1">if</span></strong><span class="koboSpan" id="kobo.1577.1"> statements in </span><span class="No-Break"><span class="koboSpan" id="kobo.1578.1">your code?</span></span></li>
<li><span class="koboSpan" id="kobo.1579.1">How frequently are nested </span><strong class="source-inline"><span class="koboSpan" id="kobo.1580.1">if</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1581.1">statements used?</span></span></li>
<li><span class="koboSpan" id="kobo.1582.1">Is any logic repeated frequently in conditions of your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1583.1">if</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1584.1"> statements?</span></span></li>
<li><span class="koboSpan" id="kobo.1585.1">Do you see any places where inverting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1586.1">if</span></strong><span class="koboSpan" id="kobo.1587.1"> statement or switching to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1588.1">switch</span></strong><span class="koboSpan" id="kobo.1589.1"> statement or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1590.1">switch</span></strong><span class="koboSpan" id="kobo.1591.1"> expression could </span><span class="No-Break"><span class="koboSpan" id="kobo.1592.1">improve things?</span></span></li>
<li><span class="koboSpan" id="kobo.1593.1">Do you think your team has been using LINQ to its fullest potential when working with collections? </span><span class="koboSpan" id="kobo.1593.2">What opportunities for improvement do </span><span class="No-Break"><span class="koboSpan" id="kobo.1594.1">you see?</span></span></li>
</ol>
<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.1595.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.1596.1">You can find more information about the materials discussed in this chapter by reading the </span><span class="No-Break"><span class="koboSpan" id="kobo.1597.1">following resources:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.1598.1">Switch </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1599.1">Expressions</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1600.1">: </span></span><a href="https://learn.microsoft.com/en-US/dotnet/csharp/language-reference/operators/switch-expression"><span class="No-Break"><span class="koboSpan" id="kobo.1601.1">https://learn.microsoft.com/en-US/dotnet/csharp/language-reference/operators/switch-expression</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1602.1">Differences between .NET Collection </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1603.1">Interfaces</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1604.1">: </span></span><a href="https://newdevsguide.com/2022/10/09/understanding-dotnet-collection-interfaces/"><span class="No-Break"><span class="koboSpan" id="kobo.1605.1">https://newdevsguide.com/2022/10/09/understanding-dotnet-collection-interfaces/</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1606.1">Query Syntax and Method Syntax in </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1607.1">LINQ</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1608.1">: </span></span><a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq"><span class="No-Break"><span class="koboSpan" id="kobo.1609.1">https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1610.1">Explore Ranges of </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1611.1">Data</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1612.1">: </span></span><a href="https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/ranges-indexes"><span class="No-Break"><span class="koboSpan" id="kobo.1613.1">https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/ranges-indexes</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1614.1">Arrow Functions and the Lambda </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1615.1">Operator</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1616.1">: </span></span><a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-operator"><span class="No-Break"><span class="koboSpan" id="kobo.1617.1">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-operator</span></span></a></li>
</ul>
</div>
</body></html>