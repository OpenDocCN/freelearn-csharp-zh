- en: '*Chapter 5*: Exploring the ASP.NET Core and ABP Infrastructure'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*: 探索 ASP.NET Core 和 ABP 基础设施'
- en: Both ASP.NET Core and ABP Framework provide many building blocks and features
    for modern application development. This chapter will explore the most basic building
    blocks so that you can understand how an application is configured and initialized.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 和 ABP 框架都为现代应用程序开发提供了许多构建块和功能。本章将探索最基本的构建块，以便你了解应用程序是如何配置和初始化的。
- en: We will start with the ASP.NET Core `Startup` class to understand why we need
    a modular system and how ABP provides a modular way to configure and initialize
    an application. Then we will explore the ASP.NET Core dependency injection system
    and ABP's way of automating dependency injection registration with predefined
    rules. We will continue by looking at configuration and the options pattern to
    learn ASP.NET Core's way of configuring the options of ASP.NET Core and other
    libraries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 ASP.NET Core 的 `Startup` 类开始，了解为什么我们需要模块化系统以及 ABP 如何提供一种模块化方式来配置和初始化应用程序。然后我们将探索
    ASP.NET Core 的依赖注入系统以及 ABP 使用预定义规则自动注册依赖注入的方式。我们将继续探讨配置和选项模式，以了解 ASP.NET Core
    配置 ASP.NET Core 和其他库选项的方式。
- en: 'Here are all the topics we''ll cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖所有以下主题：
- en: Understanding modularity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模块化
- en: Using the dependency injection system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用依赖注入系统
- en: Configuring an application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置应用程序
- en: Implementing the options pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现选项模式
- en: Logging
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录日志
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you want to follow and try the examples, you need to have installed an IDE/editor
    (such as Visual Studio) to build the ASP.NET Core projects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要跟踪和尝试示例，你需要安装一个 IDE/编辑器（如 Visual Studio）来构建 ASP.NET Core 项目。
- en: 'You can download the code examples from the following GitHub repository: [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从以下 GitHub 仓库下载代码示例：[https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework)。
- en: Understanding modularity
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模块化
- en: '**Modularity** is a design technique for breaking down the functionalities
    of a large software into smaller parts and allowing each part to communicate with
    the others through standardized interfaces as needed. Modularity has the following
    main benefits:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块化**是将大型软件的功能分解成更小部分的设计技术，并允许每个部分通过标准化的接口按需与其他部分进行通信。模块化有以下主要优点：'
- en: It reduces complexity when every module is designed to be isolated from the
    other modules, and inter-module communications are well defined and limited.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当每个模块都设计为与其他模块隔离，并且模块间通信定义良好且有限时，它降低了复杂性。
- en: It provides flexibility when you design modules to be loosely coupled. You can
    refactor or even replace a module in the future.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你设计模块以实现松散耦合时，它提供了灵活性。你可以在未来重构或甚至替换一个模块。
- en: It allows re-using modules across applications when you design them to be application-independent.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你设计模块以实现与应用程序无关时，它允许跨应用程序重用模块。
- en: Most enterprise software systems are designed to be modular. However, implementing
    modularity is not easy, and the plain ASP.NET Core doesn't help much. One of ABP
    Framework's main goals is to provide infrastructure and tooling to develop truly
    modular systems. We will cover modular application development in [*Chapter 15*](B17287_15_Epub_AM.xhtml#_idTextAnchor443)*,
    Working with Modularity*, but this section introduces the basics of ABP modules.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数企业级软件系统都是模块化的。然而，实现模块化并不容易，纯 ASP.NET Core 并没有提供太多帮助。ABP 框架的主要目标之一是提供基础设施和工具来开发真正的模块化系统。我们将在
    [*第15章*](B17287_15_Epub_AM.xhtml#_idTextAnchor443) *与模块化一起工作* 中介绍模块化应用程序开发，但本节介绍了
    ABP 模块的基本知识。
- en: The Startup class
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Startup` 类'
- en: 'Before defining a module class, it is best to remember the `Startup` class
    in ASP.NET Core to understand the need for module classes. The following code
    block shows a `Startup` class in a simple ASP.NET Core application:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义模块类之前，最好记住 ASP.NET Core 中的 `Startup` 类，以了解模块类的需求。以下代码块展示了简单 ASP.NET Core
    应用程序中的 `Startup` 类：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `ConfigureServices` method is used to configure other services and register
    new services to the dependency injection system. The `Configure` method, on the
    other hand, is used to configure the **ASP.NET Core request pipeline** that processes
    the HTTP requests through middleware components.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigureServices` 方法用于配置其他服务并将新服务注册到依赖注入系统中。另一方面，`Configure` 方法用于配置 **ASP.NET
    Core 请求管道**，该管道通过中间件组件处理 HTTP 请求。'
- en: 'Once you have the `Startup` class, you typically register it in the `Program.cs`
    file while configuring the host builder so that it works on application startup:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了`Startup`类，通常在配置主机构建器时将其注册到`Program.cs`文件中，以便在应用程序启动时工作：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These code parts are already included in ASP.NET Core's startup templates, so
    you normally don't write them manually.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码部分已经包含在ASP.NET Core的启动模板中，所以你通常不需要手动编写它们。
- en: The problem with the `Startup` class is that it is unique. That means you have
    only a single point to configure and initialize all your application services.
    However, in a modular application, you expect that every module configures and
    initializes the services related to that particular module. Also, it is typical
    that a module uses or depends on other modules, so the modules should be configured
    and initialized in the correct order. That is where ABP's module definition class
    comes into play.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Startup`类的问题在于它是唯一的。这意味着你只有一个配置和初始化所有应用程序服务的点。然而，在模块化应用程序中，你期望每个模块配置和初始化与该特定模块相关的服务。此外，一个模块使用或依赖于其他模块是典型的，因此模块应该按正确的顺序配置和初始化。这就是ABP的模块定义类发挥作用的地方。'
- en: Defining a module class
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义模块类
- en: An ABP module is a group of types (such as classes or interfaces) developed
    and shipped together. It is an assembly (a *project* in Visual Studio) with a
    module class derived from `AbpModule`. The module class is responsible for configuring
    and initializing that module and configures any dependent modules if necessary.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ABP模块是一组（如类或接口）一起开发和发布的类型。它是一个由`AbpModule`派生的模块类组成的组件（在Visual Studio中是一个*项目*）。模块类负责配置和初始化该模块，并在必要时配置任何依赖模块。
- en: 'Here is a simple module definition class for an SMS sending module:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的短信发送模块的模块定义类：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Every module can override the `ConfigureServices` method in order to register
    its services to the dependency injection system and configure the other modules.
    The module in this example registers `SmsService` to a dependency injection system
    with a transient lifetime. I've written this example to show the same registration
    code done in the `Startup` class in the previous section. However, most of the
    time, you don't need to register your services manually, thanks to ABP Framework's
    conventional registration system explained in the *Using the dependency injection
    system* section of this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都可以覆盖`ConfigureServices`方法，以便将其服务注册到依赖注入系统中并配置其他模块。在这个例子中，该模块将`SmsService`注册到具有瞬态生命周期的依赖注入系统中。我编写这个例子是为了展示与上一节中`Startup`类中相同的注册代码。然而，大多数时候，你不需要手动注册你的服务，这得益于本章中*使用依赖注入系统*部分解释的ABP框架的约定注册系统。
- en: 'The `AbpModule` class defines the `OnApplicationInitialization` method that
    is executed after the service registration phase is complete and the application
    is ready to run. With this method, you can execute any operation you need to perform
    on application startup. For example, you can initialize a service:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbpModule`类定义了在服务注册阶段完成后、应用程序准备运行时执行的`OnApplicationInitialization`方法。使用此方法，你可以在应用程序启动时执行任何需要的操作。例如，你可以初始化一个服务：'
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this code block, we are using `context.ServiceProvider` to request a service
    from the dependency injection system and initialize the service. We can request
    services because the dependency injection system is ready at this point.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码块中，我们使用`context.ServiceProvider`从依赖注入系统中请求一个服务并初始化该服务。我们可以在此时请求服务，因为依赖注入系统已经准备好了。
- en: You can also think of the `OnApplicationInitialization` method as the `Configure`
    method of the `Startup` class. So, you can build the ASP.NET Core request pipeline
    here. However, you typically configure the request pipeline in the startup module,
    as explained in the next section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将`OnApplicationInitialization`方法视为`Startup`类的`Configure`方法。因此，你可以在这里构建ASP.NET
    Core请求管道。然而，通常你会在启动模块中配置请求管道，如下一节所述。
- en: Module dependencies and the startup module
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块依赖和启动模块
- en: A business application generally consists of more than one module, and ABP Framework
    allows you to declare dependencies between modules. An application should always
    have a **startup module**. The startup module can have dependencies on some modules,
    and these modules can have dependencies on some other modules, and so on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个业务应用程序通常由多个模块组成，ABP框架允许你声明模块之间的依赖关系。应用程序应该始终有一个**启动模块**。启动模块可以依赖于某些模块，而这些模块可以依赖于其他模块，依此类推。
- en: 'The following diagram shows a simple module dependency graph:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了简单的模块依赖关系图：
- en: '![Figure 5.1 – Example module dependency graph'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – 示例模块依赖关系图'
- en: '](img/Figure_5.1_B17287.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B17287.jpg)'
- en: Figure 5.1 – Example module dependency graph
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 示例模块依赖关系图
- en: ABP respects module dependencies and initializes modules based on the dependency
    graph. If module A depends on module B, then module B is always initialized before
    module A. That allows module A to use, set, change, or override configurations
    and services defined by module B.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 尊重模块依赖关系，并根据依赖关系图初始化模块。如果模块 A 依赖于模块 B，则模块 B 总是在模块 A 之前初始化。这允许模块 A 使用、设置、更改或覆盖由模块
    B 定义的配置和服务。
- en: 'For the example graph in *Figure 5.1*, the module initialization will be in
    the following order: G, F, E, D, B, C, A. You don''t have to know the exact initialization
    order; only know that if your module depends on module *X*, then module *X* is
    initialized before your module.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*图 5.1*中的示例图，模块初始化的顺序将是：G、F、E、D、B、C、A。你不必知道确切的初始化顺序；只需知道如果你的模块依赖于模块*X*，则模块*X*将在你的模块之前初始化。
- en: 'Defining a module dependency is declared with the `[DependsOn]` attribute of
    a module:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块的`[DependsOn]`属性声明模块依赖关系：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code block, `ModuleA` depends on `ModuleB` and `ModuleC` by
    declaring the `[DependsOn]` attribute.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，`ModuleA`通过声明`[DependsOn]`属性依赖于`ModuleB`和`ModuleC`。
- en: 'For an ASP.NET Core application, the startup module (`ModuleA` in this example)
    is responsible for setting up the ASP.NET Core request pipeline:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 ASP.NET Core 应用程序，启动模块（本例中的`ModuleA`）负责设置 ASP.NET Core 请求管道：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this code block, we've built the same ASP.NET Core request pipeline built
    previously in the *The Startup class* section. `context.GetApplicationBuilder()`
    and `context.GetEnvironment()` are just shortcuts to obtain the standard `IApplicationBuilder`
    and `IWebHostEnvironment` services from the dependency injection system.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此代码块，我们构建了与之前在*启动类*部分中构建的相同的 ASP.NET Core 请求管道。`context.GetApplicationBuilder()`和`context.GetEnvironment()`只是从依赖注入系统中获取标准`IApplicationBuilder`和`IWebHostEnvironment`服务的快捷方式。
- en: 'Then, we can use this module in the `Startup` class of ASP.NET Core to integrate
    ABP Framework with ASP.NET Core:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在 ASP.NET Core 的`Startup`类中使用此模块来集成 ABP 框架与 ASP.NET Core：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `services.AddApplication()` method is defined by ABP Framework to configure
    the modules. It basically executes the `ConfigureServices` methods of all the
    modules by respecting the order of module dependencies. The `app.InitializeApplication()`
    method is also defined by ABP Framework; similarly, it executes the `OnApplicationInitialization`
    methods of all the modules by respecting the order of module dependencies.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`services.AddApplication()`方法由 ABP 框架定义，用于配置模块。它基本上按照模块依赖关系的顺序执行所有模块的`ConfigureServices`方法。`app.InitializeApplication()`方法也是由
    ABP 框架定义的；同样，它按照模块依赖关系的顺序执行所有模块的`OnApplicationInitialization`方法。'
- en: The `ConfigureServices` and `OnApplicationInitialization` methods are the most
    commonly used methods in a module class; there are more methods explained in the
    next section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigureServices`和`OnApplicationInitialization`方法是模块类中最常用的方法；下文将解释更多方法。'
- en: Module lifecycle methods
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块生命周期方法
- en: 'The `AbpModule` class defines useful methods that you can override to execute
    code on application startup and shutdown. We saw `ConfigureServices` and `OnApplicationInitialization`
    in the previous section; here is a list of all the lifecycle methods:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbpModule`类定义了一些有用的方法，你可以覆盖这些方法以在应用程序启动和关闭时执行代码。我们在前文看到了`ConfigureServices`和`OnApplicationInitialization`；以下是所有生命周期方法的列表：'
- en: '`PreConfigureServices`: This method is called before the `ConfigureServices`
    method. It allows you to write code to be executed before `ConfigureServices`
    of the depended-upon modules.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PreConfigureServices`：此方法在`ConfigureServices`方法之前被调用。它允许你编写在依赖模块的`ConfigureServices`之前执行的代码。'
- en: '`ConfigureServices`: This is the main method to configure the module and register
    services, as explained in the previous section.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConfigureServices`：这是配置模块和注册服务的主要方法，如前文所述。'
- en: '`PostConfigureServices`: This method is called after the `ConfigureServices`
    method of all the modules (including the modules depending on your module), so
    you may perform a final configuration.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostConfigureServices`：此方法在所有模块（包括依赖于你的模块的模块）的`ConfigureServices`方法之后被调用，因此你可以执行最终配置。'
- en: '`OnPreApplicationInitialization`: This method is called before the `OnApplicationInitialization`
    method. In this stage, you can resolve services from dependency injection.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnPreApplicationInitialization`：此方法在 `OnApplicationInitialization` 方法之前被调用。在这个阶段，您可以从依赖注入中解析服务。'
- en: '`OnApplicationInitialization`: This method allows your module to configure
    the ASP.NET Core request pipeline and initialize your services, as explained in
    the previous section.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnApplicationInitialization`：此方法允许您的模块配置 ASP.NET Core 请求管道并初始化您的服务，如前所述。'
- en: '`OnPostApplicationInitialization`: This method is called in the initialization
    phase.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnPostApplicationInitialization`：此方法在初始化阶段被调用。'
- en: '`OnApplicationShutdown`: You can implement your module''s shutdown logic if
    necessary.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnApplicationShutdown`：如果需要，您可以实现您模块的关闭逻辑。'
- en: '`Pre…` and `Post…` methods (such as `PreConfigureServices` and `PostConfigureServices`)
    have the same purpose as the original method. They are rarely used and provide
    a way to perform some configuration/initialization code that works before or after
    all other modules.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pre…` 和 `Post…` 方法（如 `PreConfigureServices` 和 `PostConfigureServices`）与原始方法具有相同的目的。它们很少使用，并提供了一种在所有其他模块之前或之后执行某些配置/初始化代码的方式。'
- en: Asynchronous Lifecycle Methods
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 异步生命周期方法
- en: The lifecycle methods explained in this section are synchronous. At the time
    of writing this book, the ABP Framework team was working to introduce asynchronous
    lifecycle methods with ABP Framework version 5.1\. You can see [https://github.com/abpframework/abp/pull/10928](https://github.com/abpframework/abp/pull/10928)
    for details.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中解释的生命周期方法是同步的。在撰写本书时，ABP 框架团队正在努力在 ABP 框架 5.1 版本中引入异步生命周期方法。您可以查看 [https://github.com/abpframework/abp/pull/10928](https://github.com/abpframework/abp/pull/10928)
    获取详细信息。
- en: As explained before, a module class mainly contains code to register and configure
    services related to that module. In the next section, we will see how to register
    services with ABP Framework.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，模块类主要包含与该模块相关的服务的注册和配置代码。在下一节中，我们将看到如何使用 ABP 框架注册服务。
- en: Using the dependency injection system
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用依赖注入系统
- en: Dependency injection is a technique for obtaining a class's dependencies. It
    separates creating a class from using that class.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一种获取类依赖项的技术。它将创建类和使用类分离。
- en: 'Assume that we have a `UserRegistrationService` class that uses `SmsService`
    to send a verification SMS, as shown in the following code block:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 `UserRegistrationService` 的类，该类使用 `SmsService` 发送验证短信，如下面的代码块所示：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `SmsService` has been obtained using the `SmsService`, in this example,
    is used in the `RegisterAsync` method to send a verification code after saving
    the user into the database.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`SmsService` 是通过 `SmsService` 获取的，在这个例子中，它被用于 `RegisterAsync` 方法，在将用户保存到数据库后发送验证码。
- en: ASP.NET Core natively provides a dependency injection infrastructure, and ABP
    leverages this infrastructure rather than using a third-party dependency injection
    framework. Once you register all the services to the dependency injection system,
    any service can constructor-inject the dependent services without dealing with
    creating them (and their dependencies).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 本地提供依赖注入基础设施，ABP 利用这个基础设施而不是使用第三方依赖注入框架。一旦将所有服务注册到依赖注入系统中，任何服务都可以构造函数注入依赖服务，而无需处理它们的创建（及其依赖项）。
- en: The most important thing you should consider while designing your services is
    the service lifetime.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计服务时，您应该考虑的最重要的事情是服务的生命周期。
- en: Service lifetime
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务生命周期
- en: 'ASP.NET Core offers different lifetime options on service registration, so
    we should select a lifetime for every service. There are three lifetimes in ASP.NET
    Core:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 在服务注册上提供了不同的生命周期选项，因此我们应该为每个服务选择一个生命周期。在 ASP.NET Core 中有三个生命周期：
- en: '**Transient**: Transient services are created whenever you inject them. Every
    time you request/inject the service, a new instance is created.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瞬时的**：瞬时的服务每次注入时都会创建。每次请求/注入服务时，都会创建一个新的实例。'
- en: '**Scoped**: Scoped services are created per scope. This is generally considered
    by request lifetime, as each HTTP request creates a new scope in ASP.NET Core.
    You share the same instance in the same scope and get a different instance in
    different scope.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作用域的**：作用域服务是按作用域创建的。这通常被认为是请求生命周期，因为在 ASP.NET Core 中，每个 HTTP 请求都会创建一个新的作用域。在相同的作用域中，您共享相同的实例，而在不同的作用域中，您将获得不同的实例。'
- en: '**Singleton**: A singleton service has only a single instance in an application.
    All the requests and clients use the same instance. The object is created the
    first time you request it. Then the same object instance is reused in the subsequent
    requests.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例**：单例服务在应用程序中只有一个实例。所有请求和客户端都使用相同的实例。对象是在第一次请求时创建的。然后，在后续请求中重复使用相同的对象实例。'
- en: 'The following module registers two services, one as transient and the other
    as a singleton:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模块注册了两个服务，一个为瞬态，另一个为单例：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`context.Services` is a type of `IServiceCollection`, and all the ASP.NET Core
    extension methods can be used to register and configure your services manually.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`context.Services` 是 `IServiceCollection` 类型，可以使用所有 ASP.NET Core 扩展方法手动注册和配置你的服务。'
- en: In the first example, `AddTransient<ISmsService, SmsService>()`, I've registered
    the `SmsService` class with the `ISmsService` interface. In this way, whenever
    I inject `ISmsService`, the dependency injection system creates an `SmsService`
    object for me. For the second example, `AddSingleton<OtherService>()`, I've registered
    `OtherService` as a singleton with the class reference. To use this service, I
    should inject the `OtherService` class reference.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，`AddTransient<ISmsService, SmsService>()`，我已经将 `SmsService` 类注册为 `ISmsService`
    接口。这样，每次我注入 `ISmsService` 时，依赖注入系统都会为我创建一个 `SmsService` 对象。对于第二个示例，`AddSingleton<OtherService>()`，我已经将
    `OtherService` 注册为单例，并使用类引用。要使用此服务，我应该注入 `OtherService` 类引用。
- en: Scoped Dependencies and ASP.NET Core's Dependency Injection Documentation
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域依赖和 ASP.NET Core 的依赖注入文档
- en: 'As mentioned, scoped services are created per HTTP request for an ASP.NET Core
    application by default. For non-ASP.NET Core applications, you may need to manage
    scopes yourself. Please refer to ASP.NET Core''s documentation for all the details
    of the dependency injection system: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，默认情况下，ASP.NET Core 应用程序会为每个 HTTP 请求创建作用域服务。对于非 ASP.NET Core 应用程序，你可能需要自己管理作用域。请参阅
    ASP.NET Core 的文档以了解依赖注入系统的所有详细信息：[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection)。
- en: When you use ABP Framework, you don't have to think so much about service registration,
    thanks to ABP Framework's conventional and declarative service registration system.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 ABP 框架时，由于 ABP 框架的常规和声明性服务注册系统，你不必过多考虑服务注册。
- en: Conventional service registrations
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统的服务注册
- en: In ASP.NET Core, you should explicitly register all your services to `IServiceCollection`,
    as shown in the previous section. However, most of these registrations are just
    repetitive code and can be automated.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 中，你应该明确地将所有服务注册到 `IServiceCollection` 中，如前所述。然而，这些注册中的大多数都是重复的代码，并且可以自动化。
- en: 'ABP automatically registers services for dependency injection for the following
    types:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 会自动为以下类型注册依赖注入服务：
- en: MVC controllers
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVC 控制器
- en: Razor page models
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Razor 页面模型
- en: View components
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图组件
- en: Razor components
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Razor 组件
- en: SignalR hubs
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SignalR 中心
- en: Application services
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序服务
- en: Domain services
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域服务
- en: Repositories
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓储
- en: All these services are registered with the transient lifetime. So, you don't
    need to care about service registration for these kinds of classes. If you have
    another class type, you can use one of the dependency interfaces, or the `Dependency`
    attribute as explained in the next sections.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '所有这些服务都注册为瞬态生命周期。因此，你不需要关心这些类型的服务注册。如果你有其他类类型，你可以使用下一节中解释的依赖接口或 `Dependency`
    属性。 '
- en: Dependency interfaces
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖接口
- en: 'You can implement an `ITransientDependency`, `IScopedDependency`, or `ISingletonDependency`
    interface to register your service for dependency injection. For example, in this
    code block, we''ve registered the service as a singleton, so only one shared instance
    is created in the application''s lifetime:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以实现 `ITransientDependency`、`IScopedDependency` 或 `ISingletonDependency` 接口来注册你的服务以进行依赖注入。例如，在这个代码块中，我们已经将服务注册为单例，因此在应用程序的生命周期中只创建了一个共享实例： '
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Dependency interfaces are easy and the suggested way for most cases, but they
    are limited compared to the `Dependency` attribute.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖接口易于使用，并且是大多数情况下的推荐方式，但与 `Dependency` 属性相比，它们有限。
- en: The Dependency attribute
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖属性
- en: 'The `Dependency` attribute provides options for fine control of dependency
    registration with the following properties:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dependency` 属性提供了以下属性来对依赖注册进行精细控制：'
- en: '`Lifetime` (`enum`): The lifetime of the service: `Singleton`, `Transient`,
    or `Scoped`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lifetime` (`enum`): 服务的生命周期：`Singleton`、`Transient`或`Scoped`'
- en: '`TryRegister` (`bool`): Registers the service only if it''s not already registered'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TryRegister` (`bool`): 只有在服务尚未注册时才注册服务'
- en: '`ReplaceServices` (`bool`): Replaces the previous registration if the service
    is already registered'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReplaceServices` (`bool`): 如果服务已经注册，则替换之前的注册'
- en: 'Here is an example of service registration using the `Dependency` attribute:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`Dependency`属性进行服务注册的一个示例：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, I used the `[Dependency]` attribute with a `Transient` lifetime and also
    with the `TryRegister` option to register the class to the dependency injection
    system.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用了具有`Transient`生命周期的`[Dependency]`属性，并且还使用了`TryRegister`选项将类注册到依赖注入系统中。
- en: Dependency Attribute versus Dependency Interfaces
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖属性与依赖接口
- en: The `Dependency` attribute can be used alongside the dependency interfaces introduced
    in the previous section. The `Dependency` attribute has a higher priority than
    the dependency interfaces if it defines the `Lifetime` property.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dependency`属性可以与上一节中引入的依赖接口一起使用。如果它定义了`Lifetime`属性，则`Dependency`属性比依赖接口具有更高的优先级。'
- en: Registering a class to the dependency injection system makes it usable in an
    application. However, a class may be injected with different types of class or
    interface references, depending on what service types are exposed by that class.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将类注册到依赖注入系统中使其在应用程序中可用。然而，一个类可能被不同类型的类或接口引用注入，这取决于该类公开的服务类型。
- en: Exposing services
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴露服务
- en: When a class doesn't implement an interface, it can only be injected by the
    class reference. The `UserPermissionCache` class in the previous section is used
    by directly injecting the class type. However, it is common to implement interfaces
    for services.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类没有实现接口时，它只能通过类引用进行注入。上一节中的`UserPermissionCache`类是通过直接注入类类型来使用的。然而，为服务实现接口是很常见的。
- en: 'Assume that we have an interface to abstract the SMS sending:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个用于抽象短信发送的接口：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That is a pretty simple interface that only has a single method to send an
    SMS. Assume that you want to implement the `ISmsService` interface by using Azure:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的接口，它只有一个发送短信的方法。假设你想通过Azure实现`ISmsService`接口：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `AzureSmsService` class implements the `ISmsService` and `ITransientDependency`
    interfaces. The `ITransientDependency` interface is only for registering this
    service for dependency injection, as explained in the previous section.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`AzureSmsService`类实现了`ISmsService`和`ITransientDependency`接口。`ITransientDependency`接口仅用于注册此服务以进行依赖注入，如前节所述。'
- en: 'You typically want to use the `AzureSmsService` class by injecting the `ISmsService`
    interface. ABP is smart enough to understand your purpose and automatically registers
    the `AzureSmsService` class for the `ISmsService` interface. You can consume the
    `AzureSmsService` class either by injecting the `ISmsService` interface or the
    `AzureSmsService` class reference. Injecting the `AzureSmsService` class by the
    `ISmsService` interface is possible by its naming conventions: the `ISmsService`
    interface is the *default interface* for the `AzureSmsService` class because it
    ends with the `SmsService` suffix.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常想通过注入`ISmsService`接口来使用`AzureSmsService`类。ABP足够智能，能够理解你的目的，并自动将`AzureSmsService`类注册为`ISmsService`接口。你可以通过注入`ISmsService`接口或`AzureSmsService`类引用来使用`AzureSmsService`类。通过`ISmsService`接口注入`AzureSmsService`类是可能的，因为它遵循命名约定：`ISmsService`接口是`AzureSmsService`类的*默认接口*，因为它以`SmsService`后缀结尾。
- en: 'Assume that we have a class that implements multiple interfaces as shown in
    the following code block:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个实现多个接口的类，如下面的代码块所示：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `PdfExporter` service can be used by injecting the `IPdfExporter` and `IExporter`
    interfaces or directly with the `PdfExporter` class reference. However, you can't
    inject it using the `ICanExport` interface because the name of `PdfExporter` doesn't
    end with `CanExport`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过注入`IPdfExporter`和`IExporter`接口或直接使用`PdfExporter`类引用来使用`PdfExporter`服务。但是，你不能使用`ICanExport`接口来注入它，因为`PdfExporter`的名字不以`CanExport`结尾。
- en: 'If you need to change the default behavior, you can use the `ExposeServices`
    attribute, as shown in the following code block:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更改默认行为，可以使用`ExposeServices`属性，如下面的代码块所示：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, you can use the `PdfExporter` class only by injecting the `IPdfExporter`
    interface.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你只能通过注入`IPdfExporter`接口来使用`PdfExporter`类。
- en: 'Question: Should I Define Interfaces for Each Service?'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：我应该为每个服务定义接口吗？
- en: 'One potential question you may ask is whether you should define interfaces
    for your services and inject them using interfaces. ABP doesn''t force you to
    do anything here, and general interface best practices are applicable: define
    interfaces if you want to loosely couple your services, have multiple implementations
    of a service, mock in unit tests easily, physically separate interfaces from the
    implementations (say, we define application service interfaces in the `Application.Contracts`
    project and implement them in the `Application` project, or we define repository
    interfaces in the domain layer but implement them in the infrastructure layer),
    and so on.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问的一个潜在问题是，你是否应该为你的服务定义接口并使用接口进行注入。ABP 不强迫你在这里做任何事情，并且通用的接口最佳实践是适用的：如果你想松散耦合你的服务、有多个服务实现、在单元测试中轻松模拟，或者物理上分离接口和实现（例如，我们在
    `Application.Contracts` 项目中定义应用程序服务接口并在 `Application` 项目中实现它们，或者我们在领域层中定义仓储接口但在基础设施层中实现它们），等等。
- en: We've seen how to register and consume services. Some services or libraries
    have options, and you may need to configure them before using them. The next two
    sections explain the standard infrastructure and patterns to configure options
    provided by such services and libraries.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何注册和消费服务。一些服务或库有选项，在使用它们之前你可能需要配置它们。接下来的两个部分解释了配置这些服务库提供的选项的标准基础设施和模式。
- en: Configuring an application
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置应用程序
- en: ASP.NET Core's **configuration** system provides a convenient way to read key-value-based
    configurations for applications. It is an extensible system and can read key-value
    pairs from various resources, such as JSON settings files, environment variables,
    command-line arguments, and Azure Key Vault.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 的 **配置** 系统为应用程序提供了读取基于键值配置的便捷方式。它是一个可扩展的系统，可以从各种资源中读取键值对，例如 JSON
    设置文件、环境变量、命令行参数和 Azure Key Vault。
- en: ABP Framework versus ASP.NET Core's Configuration System
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 框架与 ASP.NET Core 的配置系统比较
- en: 'ABP Framework doesn''t add a specific feature to ASP.NET Core''s configuration
    system. However, it is essential to understand it to work with ASP.NET Core and
    ABP Framework properly. I will cover the basics in this book. Please see ASP.NET
    Core''s documentation for a complete reference: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 框架没有为 ASP.NET Core 的配置系统添加特定功能。然而，理解它是正确使用 ASP.NET Core 和 ABP 框架的关键。本书将涵盖基础知识。请参阅
    ASP.NET Core 的文档以获取完整参考：[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration)。
- en: Setting the configuration values
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置配置值
- en: 'The easiest way to set a configuration value is to use the `appsettings.json`
    file by default. Assume that we are building a service to send SMS using Azure,
    and we need the following configuration values:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 设置配置值的最简单方法是默认使用 `appsettings.json` 文件。假设我们正在构建一个使用 Azure 发送短信的服务，我们需要以下配置值：
- en: '`Sender`: The sender number shown to the target user'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sender`：显示给目标用户的发送者号码'
- en: '`ConnectionString`: The connection string of your Azure resouce'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConnectionString`：你的 Azure 资源连接字符串'
- en: 'We can define these settings in the configuration section of the `appsettings.json`
    file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `appsettings.json` 文件的配置部分中定义这些设置：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The configuration section name (`AzureSmsService` here) and key names are completely
    arbitrary. You can set any name as long as you use the same keys in your code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 配置部分名称（此处为 `AzureSmsService`）和键名称是完全任意的。只要你在代码中使用相同的键，你可以设置任何名称。
- en: Once you've set values in the settings file, you can easily read them from your
    application code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在设置文件中设置了值，你就可以轻松地从你的应用程序代码中读取它们。
- en: Reading the configuration values
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取配置值
- en: 'You can inject and use the `IConfiguration` service whenever you need to read
    configured values. For example, we can get the Azure configuration to send SMS
    in the `AzureSmsService` class:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在需要读取配置值时注入并使用 `IConfiguration` 服务。例如，我们可以在 `AzureSmsService` 类中获取 Azure
    配置以发送短信：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This class gets the configuration values from the `IConfiguration` service,
    and the`:` notation is used to access values in nested sections. In this example,
    `AzureSmsService:Sender` is used to get the `Sender` value inside the `AzureSmsService`
    section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此类从 `IConfiguration` 服务获取配置值，并使用 `:` 符号来访问嵌套部分中的值。在这个例子中，`AzureSmsService:Sender`
    用于获取 `AzureSmsService` 部分内的 `Sender` 值。
- en: 'The `IConfiguration` service is also usable in the `ConfigureServices` of your
    module:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`IConfiguration`服务也可以在你的模块的`ConfigureServices`中使用：'
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This way, you can access the configured values even before the dependency injection
    registration phase is completed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以在依赖注入注册阶段完成之前访问配置的值。
- en: The configuration system is a perfect way to configure and get key-value-style
    settings for your application. However, if you are building a reusable library,
    the options pattern can be a better way to define type-safe options for your library.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 配置系统是配置和获取应用程序键值样式设置的一个完美方式。然而，如果你正在构建一个可重用的库，选项模式可能是定义库中类型安全选项的更好方式。
- en: Implementing the options pattern
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现选项模式
- en: With the **options pattern**, we use a plain class (sometimes called a **POCO**
    – **Plain Old C# Object**) to define a group of related options. Let's begin with
    how to define, configure, and use the configuration using the options pattern.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**选项模式**，我们使用一个普通的类（有时称为**POCO** – **Plain Old C# Object**）来定义一组相关的选项。让我们从如何使用选项模式定义、配置和使用配置开始。
- en: Defining an options class
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义选项类
- en: 'An options class is a simple plain C# class. We can define an options class
    for the Azure SMS service as shown in the following code block:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 选项类是一个简单的普通C#类。我们可以为Azure SMS服务定义一个选项类，如下面的代码块所示：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is a convention to add the `Options` suffix to options classes. Once you
    define such a class, any module using this service can configure the options easily.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在选项类中添加`Options`后缀是一种约定。一旦你定义了这样的类，任何使用此服务的模块都可以轻松地配置选项。
- en: Configuring the options
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置选项
- en: 'As mentioned in the *ABP modules* section, you can configure the services of
    the dependent modules in the `ConfigureServices` method of your module. We use
    the `IServiceCollection.Configure` extension method to set values for any options
    class. You can configure `AzureSmsServiceOptions` as shown in the following code
    block:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如在*ABP模块*部分所述，你可以在你的模块的`ConfigureServices`方法中配置依赖模块的服务。我们使用`IServiceCollection.Configure`扩展方法为任何选项类设置值。你可以像以下代码块所示配置`AzureSmsServiceOptions`：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `context.Services.Configure` method is a generic method that gets the options
    class as the generic parameter. It also takes a delegate (an action) to set the
    option values. In this example, we've configured `AzureSmsServiceOptions` by setting
    the `Sender` and `ConnectionString` properties in the specified lambda expression.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`context.Services.Configure`方法是一个泛型方法，它将选项类作为泛型参数。它还接受一个委托（一个操作）来设置选项值。在这个例子中，我们通过在指定的lambda表达式中设置`Sender`和`ConnectionString`属性来配置了`AzureSmsServiceOptions`。'
- en: 'The `AbpModule` base class provides a `Configure` method as a shortcut of the
    `context.Services.Configure` method, so you could re-write the code as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbpModule`基类提供了一个`Configure`方法，作为`context.Services.Configure`方法的快捷方式，因此你可以将代码重写如下：'
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We've just replaced the `context.Services.Configure<…>` call with the `Configure<…>`
    shortcut method.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚将`context.Services.Configure<…>`调用替换为`Configure<…>`快捷方法。
- en: Configuring the options is simple. Now, we can see how to use the configured
    values.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 配置选项很简单。现在，我们可以看到如何使用配置的值。
- en: Multiple Configure Actions
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 多次配置操作
- en: You can configure the same options multiple times in an application. The same
    instance is sent to all delegates so that you can change the previously configured
    values. If multiple modules configure the same value, the last one wins. Remember
    that modules are initialized by the dependency order.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在应用程序中多次配置相同的选项。相同的实例被发送到所有委托，这样你就可以更改之前配置的值。如果有多个模块配置了相同的值，则最后一个配置的值生效。请记住，模块是按照依赖顺序初始化的。
- en: Using the configured option values
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用配置的选项值
- en: 'ASP.NET Core provides an `IOptions<T>` interface to inject the options class
    to read the configured values. We can re-write the `AzureSmsService` class to
    use `AzureSmsServiceOptions` instead of the `IConfiguration` service, as in the
    following code block:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core提供了一个`IOptions<T>`接口，用于注入选项类以读取配置的值。我们可以重写`AzureSmsService`类，使用`AzureSmsServiceOptions`而不是`IConfiguration`服务，如下面的代码块所示：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that we are injecting `IOptions<AzureSmsServiceOptions>` and using its
    `Value` property to obtain the `AzureSmsServiceOptions` instance. The `IOptions<T>`
    interface is defined by the `Microsoft.Extensions.Options` package and is the
    standard way to inject an options class. It internally executes all the `Configure`
    methods and provides a configured instance of the options class for you. If you
    directly inject the `AzureSmsServiceOptions` class by mistake, you get a dependency
    injection exception. So, always inject as `IOptions<AzureSmsServiceOptions>`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在注入 `IOptions<AzureSmsServiceOptions>` 并使用其 `Value` 属性来获取 `AzureSmsServiceOptions`
    实例。`IOptions<T>` 接口由 `Microsoft.Extensions.Options` 包定义，是注入选项类的标准方式。它内部执行所有 `Configure`
    方法，并为您提供一个配置好的选项类实例。如果您错误地直接注入 `AzureSmsServiceOptions` 类，则会得到一个依赖注入异常。因此，始终以
    `IOptions<AzureSmsServiceOptions>` 的形式注入。
- en: We've simply defined, configured, and used the options. What if we want to use
    the configuration system to set the options defined with the options pattern?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简单地定义、配置并使用了选项。如果我们想使用配置系统来设置使用选项模式定义的选项怎么办？
- en: Setting the options via the configuration
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过配置设置选项
- en: 'The options pattern allows us to set the option values in any way. That means
    we can use the `IConfiguration` service to read the application configuration
    and set the option values. The following code block sets `AzureSmsServiceOptions`
    by getting the values from the configuration service:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 选项模式允许我们以任何方式设置选项值。这意味着我们可以使用 `IConfiguration` 服务来读取应用程序配置并设置选项值。以下代码块通过从配置服务获取值来设置
    `AzureSmsServiceOptions`：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We are getting the `IConfiguration` interface using `context.Services.GetConfiguration()`,
    then using the configuration values to set the option values.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `context.Services.GetConfiguration()` 获取 `IConfiguration` 接口，然后使用配置值来设置选项值。
- en: 'However, since this usage is pretty common, there is a shortcut for it. We
    could re-write the code as shown in the following block:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于这种用法相当常见，有一个快捷方式。我们可以将代码重写如下所示：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With this usage, the `Configure` method gets a configuration section instead
    of a delegate action. It automatically matches the configuration keys with the
    properties of the options class by naming conventions. This code does not affect
    the options if the `AzureSmsService` section is not defined in the configuration.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方式，`Configure` 方法获取一个配置部分而不是一个委托操作。它自动通过命名约定将配置键与选项类的属性匹配。如果配置中没有定义 `AzureSmsService`
    部分，此代码不会影响选项。
- en: The options pattern gives more flexibility to the application developers; they
    may set these options from `IConfiguration` or any other source they like.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 选项模式为应用程序开发者提供了更多的灵活性；他们可以从 `IConfiguration` 或他们喜欢的任何其他来源设置这些选项。
- en: 'Tip: Set Options from the Configuration by Default'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：默认通过配置设置选项
- en: If you are building a reusable module, it is a good practice to set your options
    from the configuration wherever possible. That is, you can write the preceding
    code into your module. In this way, an application developer can directly configure
    their module from the `appsettings.json` file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建一个可重用的模块，尽可能从配置中设置选项是一个好习惯。也就是说，您可以将前面的代码写入您的模块中。这样，应用程序开发者可以直接从 `appsettings.json`
    文件中配置他们的模块。
- en: ASP.NET Core and ABP options
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASP.NET Core 和 ABP 选项
- en: ASP.NET Core and ABP Framework intensively use the options pattern for their
    configuration options.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 和 ABP 框架在它们的配置选项中大量使用选项模式。
- en: 'The following example shows configuring an option in ABP Framework:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了在 ABP 框架中配置一个选项：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`AbpAuditingOptions` is defined by the audit logging system of ABP Framework.
    We are adding a type, `ProductDto`, to be ignored on audit logging.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbpAuditingOptions` 是由 ABP 框架的审计日志系统定义的。我们正在添加一个类型 `ProductDto`，在审计日志中将其忽略。'
- en: 'The next example shows configuring an option in ASP.NET Core:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了在 ASP.NET Core 中配置一个选项：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`MvcOptions` is defined by ASP.NET Core to customize the behavior of the ASP.NET
    Core MVC framework.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`MvcOptions` 是由 ASP.NET Core 定义的，用于自定义 ASP.NET Core MVC 框架的行为。'
- en: Complex Types in the Options Classes
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 选项类中的复杂类型
- en: 'Notice that `AbpAuditingOptions.IgnoredTypes` is a list of `Type`, which is
    not a simple primitive type that you can define in an `appsettings.json` file.
    That is one of the benefits of the options pattern: you can define properties
    with complex types or even action callbacks.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`AbpAuditingOptions.IgnoredTypes` 是一个 `Type` 列表，它不是一个可以在 `appsettings.json`
    文件中定义的简单原始类型。这是选项模式的一个好处之一：您可以定义具有复杂类型或甚至操作回调的属性。
- en: The configuration system and the options pattern provide a convenient way to
    configure and customize the behavior of the services being used. You can configure
    ASP.NET Core and ABP Framework and define configuration options for your own services.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 配置系统和选项模式提供了一种方便的方式来配置和自定义正在使用的服务的行为。您可以配置 ASP.NET Core 和 ABP 框架，并为您自己的服务定义配置选项。
- en: The next section explains logging, another fundamental system that you will
    frequently use in your application code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将解释日志记录，这是您将在应用程序代码中频繁使用的另一个基本系统。
- en: Logging
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: '**Logging** is a common aspect used in every application. ASP.NET Core provides
    a simple yet efficient logging system. It can be integrated with popular logging
    libraries such as NLog, Log4Net, and Serilog.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**日志记录**是每个应用程序中常用的一个方面。ASP.NET Core 提供了一个简单而高效的日志系统。它可以与流行的日志库（如 NLog、Log4Net
    和 Serilog）集成。'
- en: Serilog is a widely used library that provides many options for the log target,
    including console, text files, and Elasticsearch. ABP startup templates come with
    the Serilog library pre-installed and configured. It writes logs into a log file
    in the `Logs` folder of the application. So, you can directly use the logging
    system in your services. If you need, you can configure Serilog to write logs
    to different targets. Please refer to Serilog's documentation to configure the
    Serilog options. Serilog is not a core dependency of ABP Framework. All the configuration
    is included in the startup template. So, if you like, you can easily change it
    with another provider.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Serilog 是一个广泛使用的库，提供了许多日志目标的选项，包括控制台、文本文件和 Elasticsearch。ABP 启动模板预装并配置了 Serilog
    库。它将日志写入应用程序的 `Logs` 文件夹中的日志文件。因此，您可以直接在您的服务中使用日志系统。如果需要，您可以配置 Serilog 将日志写入不同的目标。请参阅
    Serilog 的文档以配置 Serilog 选项。Serilog 不是 ABP 框架的核心依赖项。所有配置都包含在启动模板中。因此，如果您愿意，可以轻松地使用另一个提供者进行更改。
- en: The `ILogger<T>` interface is used to write logs in ASP.NET Core, where `T`
    is typically your service type.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`ILogger<T>` 接口用于在 ASP.NET Core 中写入日志，其中 `T` 通常代表您的服务类型。'
- en: 'Here is an example service that writes logs:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个写入日志的示例服务：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `AzureSmsService` class injects the `ILogger<AzureSmsService>` service in
    its constructor and uses the `LogInformation` method to write information-level
    log text to the logging system.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`AzureSmsService` 类在其构造函数中注入了 `ILogger<AzureSmsService>` 服务，并使用 `LogInformation`
    方法将信息级别的日志文本写入日志系统。'
- en: 'There are more methods on the `ILogger` interface to write logs with different
    severity levels, such as LogError and LogDebug. Please refer to ASP.NET Core''s
    documentation for all details of the logging system: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`ILogger` 接口提供了更多方法来以不同的严重级别写入日志，例如 LogError 和 LogDebug。请参阅 ASP.NET Core 的文档以获取日志系统的所有详细信息：[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging)。'
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has covered the core building blocks of ASP.NET Core and ABP Framework.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已涵盖 ASP.NET Core 和 ABP 框架的核心构建块。
- en: You've learned about using the `Startup` class, configuration system, and options
    pattern to configure ASP.NET Core and ABP Framework services on application startup
    and implement your own configuration options when you need them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在应用程序启动时配置 ASP.NET Core 和 ABP 框架服务，并在需要时实现您自己的配置选项时，您已经了解了如何使用 `Startup` 类、配置系统和选项模式。
- en: ABP offers a modularity system that takes ASP.NET Core's initialization and
    configuration system one step further to create multiple modules where each module
    initializes its services and configures its dependencies. In this way, you can
    split your application into modules to better organize your code base or create
    modules that can be reused in different applications.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 提供了一个模块化系统，它将 ASP.NET Core 的初始化和配置系统进一步发展，以创建多个模块，每个模块初始化其服务并配置其依赖项。这样，您可以按更好的方式组织代码库或将应用程序拆分为可以在不同应用程序中重用的模块。
- en: The dependency injection system is the most fundamental infrastructure of an
    ASP.NET Core application. A service consumes others using the dependency injection
    system. I've introduced the essential aspects of the dependency injection system
    and explained how ABP simplifies registering your services.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入系统是 ASP.NET Core 应用程序最基本的基础设施。一个服务通过依赖注入系统消费其他服务。我已经介绍了依赖注入系统的基本方面，并解释了
    ABP 如何简化服务注册。
- en: The next chapter focuses on data access infrastructure, which is an essential
    aspect of a business application. We will see how ABP Framework standardizes defining
    entities and using repositories to abstract and perform database operations while
    automating database connections and transaction management.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章重点介绍数据访问基础设施，这是企业应用的一个基本方面。我们将了解ABP框架如何标准化定义实体和使用存储库来抽象和执行数据库操作，同时自动化数据库连接和事务管理。
