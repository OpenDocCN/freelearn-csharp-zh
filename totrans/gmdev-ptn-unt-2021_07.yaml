- en: Managing Character States with the State Pattern
  prefs: []
  type: TYPE_NORMAL
- en: In video games, entities continually transition from one state to another depending
    on player inputs or events. An enemy character might go from an idle state to
    an attack state depending on whether it spots the player moving across the map.
    A player character is constantly blending from one animation to another as it
    responds to the player inputs. In this chapter, we will review a pattern that
    permits us to define the individual states of an entity and its stateful behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: To start, we will use the traditional State pattern to manage the individual
    finite states of our main character. In the context of our racing game project,
    the main character is a motorcycle, so it has a set of mechanical behaviors and
    animations. As we progress in our implementation of the State pattern, we will
    soon see its limitations, which we will overcome by introducing FSM (Finite State
    Machine) concepts.
  prefs: []
  type: TYPE_NORMAL
- en: We will not write an FSM by hand, but instead explore the native state machine
    implementation in Unity's native animation system. Therefore, this chapter will
    provide a two-fold approach, an introduction to the core concepts of the State
    pattern, and how to repurpose Unity's animation system to manage character states
    and animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the State pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of the State pattern to manage the main character's states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is hands-on. You will need to have a basic understanding of Unity
    and C#.
  prefs: []
  type: TYPE_NORMAL
- en: The code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter05](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [https://bit.ly/36EbbHe](https://bit.ly/36EbbHe)
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the State pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use the State design pattern to implement a system that will permit an object
    to change its behavior based on its internal state. Thus, a change of context
    will bring on a change of behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The State pattern has three core participants in its structure:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Context` class defines an interface that permits a client to request a
    change in the internal state of an object. It also holds a pointer to the current
    state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IState` interface establishes an implementation contract for the concrete
    state classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ConcreteState` classes implement the `IState` interface and expose a public
    method named `handle()` that the `Context` object can call to trigger the state's
    behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s now review a diagram of this pattern definition, but in the context
    of an actual implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7163ee9-b7f9-4b58-8e2f-190b406eab17.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – UML diagram of the State pattern
  prefs: []
  type: TYPE_NORMAL
- en: To update an object's state, the client can set the expected state through the
    `Context` object and request a transition to the new state. Thus, the context
    is always aware of the current state of the object it handles. However, it doesn't
    need to be acquainted with each of the concrete state classes that exist. We can
    add as many state classes as we wish without modifying a single line of code in
    the `Context` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this approach scales better than defining all our states in a
    single class and managing the transition between them with a switch case, as we
    can see in the following pseudo-code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a basic understanding of the structure of the State pattern,
    we can start defining the states and behaviors of our main character, in this
    case, the bike, as we are going to see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Defining character states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our game, the entity that will transition between states the most is our
    racing bike. It's under the player's control; it interacts with almost every element
    in the environment, including obstacles and enemy drones. Therefore, it will never
    stay in the same state for long.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram showcases a shortlist of finite states for our bike:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25554af1-79f0-40a6-8a49-e3e7e94b8da8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Diagram illustrating the finite states of the bike
  prefs: []
  type: TYPE_NORMAL
- en: 'And now let''s define some expected behaviors for some of the listed states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stop**: In this state, the bike is not moving. Its current speed is at zero.
    Its gears are set to neutral. If we decide that the engine should be on, but running
    in idle mode in that state, we could have an animation of the chassis of the bike
    vibrating to show that the motor is running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start**: In this state, the bike moves at full speed, and the wheels turn
    to match the forward motion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Turn**: In the turning state, the bike turns to the left or to the right,
    depending on the player''s input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Crash**: If the bike is in a crash state, it means it''s on fire and on its
    side. The vehicle will no longer respond to the player''s input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just unpolished definitions of potential states for our vehicle. We
    could go as granular and specific as we wish, but for our use case, it's enough.
  prefs: []
  type: TYPE_NORMAL
- en: It is necessary to keep in mind that each definition of a state contains the
    description of behavior and animations. These requirements will be essential to
    consider when we write and review our implementation of the State pattern in the
    next section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the State pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part of the chapter, we will implement the State pattern with the explicit
    goal of encapsulating the expected behaviors of each of the vehicle's finite states
    that we defined in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to focus on writing minimalist skeleton classes for reasons of
    brevity and clarity. This approach will permit us to focus on the pattern's structure
    without being bogged down by implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to note that the version of the State pattern presented
    in this book might be slightly unorthodox as it deviates somewhat from traditional
    approaches. Therefore, it should be considered a permutation of the State pattern
    adapted to the context of a Unity project and for a specific use case.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the State pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to review our code example in several steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by writing down the main interface that each of our concrete state
    classes will implement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We should note that we are passing an instance of `BikeController` in the `Handle()`
    method. This approach permits state classes to access public properties of `BikeController`.
    This approach might deviate slightly from tradition as usually, it's the `Context`
    object that gets passed to the states.
  prefs: []
  type: TYPE_NORMAL
- en: However, nothing stops us from passing both the `Context` object and the instance
    of `BikeController` to the state classes. Alternatively, we could set an instance
    reference to `BikeController` when we initialize each state class.
  prefs: []
  type: TYPE_NORMAL
- en: However, it was just simpler to do, as we are going to do for this use case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our interface, let''s implement the context class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `BikeStateContext` class exposes a public property that points
    to the current state of the bike; thus, it's aware of any state change. Therefore,
    we could update the current state of our entity through its property and transition
    into it by calling the `Transition()` method.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, this mechanism is beneficial if we wanted to link states together
    by letting each state class declare the next one in the chain. Then, we could
    cycle through the linked states by simply calling the `Transition()` method of
    the `Context` object. However, this approach won't be necessary for our use case,
    as we will call the overloaded `Transition()` method and simply pass the state
    in which we want to transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is `BikeController`. This class initializes the `Context` object and
    the states, and it also triggers state changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If we didn't encapsulate the behaviors of the bike inside individual state classes,
    we would probably implement them inside `BikeController`. This approach would
    have likely resulted in a bloated controller class that's difficult to maintain.
    Therefore, by using the State pattern, we are making our classes smaller and easier
    to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: And we are also giving back to `BikeController` its original responsibilities
    of controlling the bike's core components. It exists to offer an interface to
    control the bike, expose its configurable properties, and manage its structural
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following three classes are going to be our states; they are quite self-explanatory.
    Notice that each implements the `IBikeState` interface. Let''s start with `BikeStopState`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next state class is `BikeStartState`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, there is `BikeTurnState`, which makes the bike turn left or right:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For our final class, `BikeController` references an enum named `Direction`,
    which we will implement here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We now have all our ingredients ready to test our State pattern implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the State pattern implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To quickly test our implementation of the State pattern in your own instance
    of Unity, you need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy all the scripts we just reviewed inside your Unity project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new empty scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a 3D GameObject to the scene, such as a cube, ensuring that it's visible
    to the main camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the `BikeController` script to the GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also attach the following client script to the GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you start the scene, you should see the following GUI buttons on your
    screen, which you can use to control the GameObject by triggering state changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5ed8b4c-d1d7-4a42-a1ce-d2f84c6d4ed1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Screenshot of the code example in action
  prefs: []
  type: TYPE_NORMAL
- en: In the next section of the book, we are going to review the benefits of the
    State pattern, but also its limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks of the State pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the benefits of using the State pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation**: The State pattern allows us to implement an entity''s stateful
    behaviors as a collection of components that can be assigned dynamically to an
    object when it changes states.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintenance**: We can easily implement new states without having to modify
    long conditional statements or bloated classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the State pattern does have its limitations when we use it to manage
    an animated character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a shortlist of potential limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blending**: In its native form, the State pattern doesn''t offer a solution
    to blend animations. This limitation can become an issue when you want to achieve
    a smooth visual transition between the animated states of a character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transitioning**: In our implementation of the pattern, we can easily switch
    between states, but we are not defining the relation between them. Therefore,
    if we wish to define transitions between states based on relationships and conditions,
    we will have to write a lot more code; for instance, if I want the idle state
    to transition to the walk state, and then the walk state to transition to the
    run state. And this happens automatically and smoothly, back and forth, depending
    on a trigger or condition. This could be time-consuming to do in code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, the limitations listed above can be overcome by using the Unity animation
    system and its native state machine. We can easily define animation states and
    attach animation clips and scripts to each of the configured states. But its more
    important feature is that it lets us define and configure a set of transitions
    between states with conditions and triggers through a visual editor, as we can
    see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b87b4fc2-6426-4513-98f8-6a9224524a71.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Screenshot of the Unity animation system editor
  prefs: []
  type: TYPE_NORMAL
- en: The rectangles present represent individual animation states, and the arrows
    indicate relationships and transitions. A deep dive into how to use Unity animation
    is beyond the scope of this book. The goal of this chapter was to get introduced
    to the State pattern in the context of the Unity engine. As we see, Unity offers
    us a native solution that we can leverage to manage the animation states of our
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: It's essential to keep in mind that this tool is not limited to animating humanoid
    characters. We could use it for mechanical entities such as cars or even background
    ingredients, such as a vending machine; hence, anything that has states, animations,
    and behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will review a shortlist of alternative patterns to consider
    before using the State pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on Unity''s animation system, you can read the official
    documentation at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Manual/AnimationSection.html](https://docs.unity3d.com/Manual/AnimationSection.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing alternative solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of patterns that are related or alternatives to the
    State pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blackboard/Behavior Trees**:If you are planning to implement complex AI behaviors
    for NPC characters, I would recommend considering patterns such as the Blackboard
    or concepts such as **Behavior Trees** (**BT**). For example, if you need to implement
    AI with dynamic decision-making behaviors, then BT is a more appropriate approach
    because it permits you to implement behavior using a tree of actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FSM**:A question that often arises when discussing the State pattern is the
    core difference between an FSM and the State pattern. The quick answer is that
    the State pattern is concerned with encapsulating an object''s state-dependent
    behaviors. However, FSM is more deeply involved with transitioning between finite
    states based on specific input triggers. And so, FSM is often considered more
    suited for the implementation of automaton-like systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memento**: Memento is similar to the State pattern, but with an extra feature
    that gives objects the ability to roll back to a previous state. This pattern
    could be useful in implementing a system that needs the ability to undo a change
    made to itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were able to leverage the State pattern to define and implement
    stateful behaviors of our main character. In our case, the character is a vehicle.
    After reviewing its structure in the context of a specific code example, we saw
    its limits when dealing with animated entities. However, Unity offers us a native
    solution that permits us to manage the states of animated characters with a sophisticated
    state machine and a visual editor.
  prefs: []
  type: TYPE_NORMAL
- en: However, it doesn't mean that the State pattern in itself is useless in Unity.
    We could easily use it as a foundation to build stateful systems or mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will define the global states of our racing game and
    manage them with Event Bus.
  prefs: []
  type: TYPE_NORMAL
