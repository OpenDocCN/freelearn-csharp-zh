<html><head></head><body>
        

                            
                    <h1 class="header-title">Prototype</h1>
                
            
            
                
<p>The goal of using the Prototype pattern is to assist in establishing a consistent way of making a copy of an object, based on a Prototype. This Prototype is usually an <strong>archetypal object</strong> that we need to create several times during the lifespan of our application. To avoid the potential performance costs of initializing new objects, we can use the Prototype pattern to set up a system that's very similar to a photocopying machine. By implementing the Prototype pattern, we will be able to make copies of archetypal objects on the fly while minimizing the impact on the overall performance of our application. In other words, the Prototype pattern is a handy tool to add to our programming toolbox.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>We will review the Prototype pattern's core concepts.</li>
<li>We will implement a spawn system, using the Prototype pattern as our foundation.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter is a hands-on chapter; you will need to have a basic understanding of Unity and C#.</p>
<p>We will be using the following specific Unity engine and C# language concepts:</p>
<ul>
<li>Interfaces</li>
<li>Composition</li>
</ul>
<p class="mce-root"/>
<p>If you are unfamiliar with these concepts, please review them before starting this chapter.</p>
<p>The code files of this chapter can be found on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018">https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018</a></p>
<p class="mce-root">Check out the following video to see the code in action:</p>
<p><a href="http://bit.ly/2WviTwe">http://bit.ly/2WviTwe</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">An overview of the Prototype pattern</h1>
                
            
            
                
<p>The Prototype pattern is categorized as a <strong>creational pattern</strong>, meaning that its primary responsibility is to optimize the process of initializing objects. In the Unity scripting API, we usually don't use constructors; instead, we convert our classes to components and attach them to GameObjects. With this approach, the engine manages the initialization sequence of our objects into the memory.</p>
<p>In theory, the initialization overhead of objects is out of our control, because the engine manages this for us. This statement is true to a certain degree, but it doesn't take into account what happens during the lifespan of a scene. If we need to load a prefab dynamically during a specific moment in a scene, the engine will not be able to prevent a sudden drop in the framerate as it loads the entire entity into the memory.</p>
<p>A <strong>prefab</strong> is a prefabricated container of a collection of assembled GameObjects and components. For example, you can have a prefab for each type of character in your game. Prefabs are easy to load and copy into memory. They are often referred to as the building blocks of a game.</p>
<p>The Prototype pattern offers a simple solution to this technical hurdle; instead of loading up a new prefab, we copy one that's already in the memory. Similar to a photocopying machine, we can make any number of copies that we need from a single reference. This approach is valid for spawning both prefabs and individual components.</p>
<p class="mce-root"/>
<p>The following UML diagram is an example of a design for a spawn system that uses the Prototype pattern as a foundation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9d2de532-49d8-4b16-9578-8add31aff2de.png"/></p>
<p class="CDPAlignLeft CDPAlign">As you can see, the core element of the Prototype pattern is the interface class named <kbd>ICopyable</kbd>. As its name suggests, any class that implements <kbd>ICopyable</kbd> will need to be able to return a copy of itself. In the preceding diagram, the <kbd>Enemy</kbd> class implements the <kbd>ICopyable</kbd> interface. This relationship indicates that we will be able to request instances of <strong>Drone</strong> and <strong>Tank</strong> without having to create new ones every time.</p>
<p>Associating a design pattern to a real-world system can help you to remember the definition of a specific pattern. Personally, I always compare the Prototype pattern to a photocopier.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits and drawbacks</h1>
                
            
            
                
<p>Let's review a short list of the benefits and potential drawbacks related to the implementation of the Prototype pattern.<br/></p>
<p>The following are the benefits:</p>
<ul>
<li><strong>Reduction of initialization overhead</strong>: In theory, copying an object that's already in the memory is faster than initializing a new one.</li>
<li><strong>Reusability of instances in the memory</strong>: It's possible to copy permutations of a prototype object while it is transferring from one state to another.</li>
<li><strong>Consistency</strong>: There are structural benefits to letting objects copy themselves; it's safer, and it offers a standard interface for the duplication process.</li>
</ul>
<p>The following are the drawbacks:</p>
<ul>
<li><strong>Maintenance of references</strong>: If there's a race condition in which we always destroy our prototype object before making a copy of it, we will end up nullifying any benefits of using this pattern.</li>
<li><strong>Unsupported and circular references</strong>: In some instances, objects have internal structures that don't support cloning. In those cases, it might be difficult to use the objects in a system that implements the Prototype pattern.</li>
</ul>
<p>In this book, we will avoid using strict computer science terminology. With any programming concept, there's always a scientific and practical definition. We will focus on the practical definitions while still considering the theoretical interpretations of the patterns.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Use case example</h1>
                
            
            
                
<p>Now that you have a general understanding of the Prototype pattern, let's implement an actual in-game system, using the pattern as the foundation of our architecture. A spawn system is a perfect use case for a creational pattern like the Prototype pattern. Spawning enemies at the right moment is key to designing a very immersive experience in a video game.</p>
<p>The most critical technical issue that we need to avoid is a dip in the framerate during the spawning process of the enemies. That is why we are going to use the Prototype pattern; we will copy existing instances of specific enemies, instead of creating new ones each time we need to spawn them.</p>
<p>In the next section, we will take the UML diagram that we reviewed at the beginning of the chapter and implement it in actual code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Code example</h1>
                
            
            
                
<p>In this section, we will implement a bare-bones spawn system for a game that includes drones and snipers as its main enemy types. At this point, let's make sure that our spawn system can return copies of a specific enemy type to a client.</p>
<p>When we use the term <strong>client</strong> in this book, we mean a class that uses the functionality of a pattern. In our context, it's usually a <kbd>Client</kbd> class that permits us to test our code examples.</p>
<p>Throughout this book, we will often use interfaces in our examples. They're a powerful tool in object-oriented programming. They offer a simple way to declare an implementation contract. Refer to the following steps:<br/></p>
<ol>
<li>As our first step, let's implement an interface called <kbd>ICopyable</kbd>. We are going to expose a function called <kbd>Copy()</kbd>:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">public interface iCopyable<br/>{<br/>    iCopyable Copy();<br/>}</pre>
<p style="padding-left: 60px">Notice that our interface is named <kbd>ICopyable</kbd>; this is to avoid confusing it with C#'s native interface, called <kbd>ICloneable</kbd>, which is used to declare a class as being <strong>cloneable</strong>. We are not going to use this C# interface in our example.</p>
<p class="mce-root"/>
<ol start="2">
<li>Now that we have our interface, let's implement it in a concrete class named <kbd>Enemy</kbd>:</li>
</ol>
<div><pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Enemy : MonoBehaviour, iCopyable<br/>{<br/>    public iCopyable Copy()<br/>    {<br/>        return Instantiate(this);<br/>    }<br/>}</pre></div>
<p style="padding-left: 60px">Our <kbd>Enemy</kbd> parent class is now able to return a cloned instance of itself through the <kbd>Copy()</kbd> function. As we mentioned previously, we didn't use the C# native <kbd>ICloneable</kbd> interface because we are utilizing Unity's API by using its <kbd>Instantiate()</kbd> function. This API function is more suitable to our context because it can persist the hierarchical relationships of a native Unity GameObject or component during the cloning process. In other words, when cloning a GameObject with <kbd>Instantiate()</kbd>, you are copying (cloning) its children as well. This approach is essential in Unity because GameObjects are often composed of multiple objects and components, structured in a parent-child arrangement.</p>
<ol start="3">
<li>The next step involves implementing our two main enemies; let's start with <kbd>Drone</kbd>:</li>
</ol>
<pre style="padding-left: 60px">public class Drone: Enemy<br/>{<br/>    public void Fly()<br/>    {<br/>        // Implement flying functionality.<br/>    }<br/><br/>    public void Fire()<br/>    {<br/>        // Implement laser fire functionality.<br/>    }<br/>}</pre>
<p style="padding-left: 60px">As you can see, our <kbd>Drone</kbd> class is now a child of the <kbd>Enemy</kbd> class, and because child objects inherit the properties of their parents in object-oriented environments, the <kbd>Drone</kbd> class obtains access to the <kbd>Copy()</kbd> function. This arrangement means that a client will be able to request a copy of a <kbd>Drone</kbd> by calling <kbd>Copy()</kbd>.</p>
<p class="mce-root"/>
<ol start="4">
<li>Now, let's do the same for our <kbd>Sniper</kbd>:</li>
</ol>
<pre style="padding-left: 60px">public class Sniper : Enemy<br/>{<br/>    public void Shoot()<br/>    {<br/>        // Implement shooting functionality.<br/>    }<br/>}</pre>
<ol start="5">
<li>Now that we have all of our concrete <kbd>Enemy</kbd> type classes written down, let's implement our <kbd>EnemySpawner</kbd>:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class EnemySpawner : MonoBehaviour<br/>{<br/>    public iCopyable m_Copy;<br/><br/>    public Enemy SpawnEnemy(Enemy prototype)<br/>    {<br/>        m_Copy = prototype.Copy();<br/>        return (Enemy)m_Copy;<br/>    }<br/>}</pre>
<p style="padding-left: 60px">Our spawn system is quite simple; it spawns enemies by making copies of any object that he receives that corresponds to the <kbd>Enemy</kbd> type. It's like a Xerox machine; feed it the right document, and it will make copies of it. However, there's one core difference; our <kbd>EnemySpawner</kbd> doesn't do the copying. It just asks the object that it receives to make a copy of itself, and then returns the copy to the client.<br/></p>
<ol start="6">
<li>To test our enemy spawn system implementation, let's write a <kbd>Client</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Client : MonoBehaviour<br/>{<br/>    public Drone m_Drone;<br/>    public Sniper m_Sniper;<br/>    public EnemySpawner m_Spawner;<br/><br/>    private Enemy m_Spawn;<br/>    private int m_IncrementorDrone = 0;<br/>    private int m_IncrementorSniper = 0;<br/><br/>    public void Update()<br/>    {<br/>        if (Input.GetKeyDown(KeyCode.D))<br/>        {<br/>            m_Spawn = m_Spawner.SpawnEnemy(m_Drone);<br/><br/>            m_Spawn.name = "Drone_Clone_" + ++m_IncrementorDrone;<br/>            m_Spawn.transform.Translate(Vector3.forward * m_IncrementorDrone * 1.5f);<br/>        }<br/><br/>        if (Input.GetKeyDown(KeyCode.S))<br/>        {<br/>            m_Spawn = m_Spawner.SpawnEnemy(m_Sniper);<br/><br/>            m_Spawn.name = "Sniper_Clone_" + ++m_IncrementorSniper;<br/>            m_Spawn.transform.Translate(Vector3.forward * m_IncrementorSniper * 1.5f);<br/>        }<br/>    }<br/>}</pre>
<p>Our <kbd>Client</kbd> class is quite simple; depending on whether the player presses <em>S</em> or <em>D</em> on their keyboard, it will request <kbd>EnemySpawner</kbd> to return a <kbd>Drone</kbd> or <kbd>Sniper</kbd> instance, and then it will place it beside the previously spawned entity.</p>
<p class="mce-root">In this book, we assume that the reader has basic Unity skills and already knows how to set up GameObjects and attach components to them. As a quick reminder, to make this code example compile and work in a Unity scene, you will need to do the following:</p>
<ol>
<li class="mce-root">Create two GameObjects with the Drone or Sniper scripts attached to them as components.</li>
<li class="mce-root">Create one GameObject with the Client (Script) attached to it.</li>
<li class="mce-root">In the Inspector of the Client (Script) component, set the Drone and Sniper GameObjects as references in the corresponding fields.</li>
</ol>
<p>The following screenshot displays a typical Unity scene setup for testing our code example:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="img/c3306d86-bf00-403c-9460-40dfd82887a9.png"/></p>
<p>The source code and Unity project for this book are available in the GitHub repository at <a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018">https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018</a>.<a href="https://github.com/keagancarneiro/Hands-On-Game-Development-Patterns-with-Unity-2018"/></p>
<p class="mce-root">We have successfully implemented the Prototype pattern while building a simple spawn system. This code is a solid foundation for developing a more advanced spawn system. The most important lesson to keep in mind is to always consider copying an object before creating it. This approach is a straightforward optimization strategy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We started the practical section of this book with a flexible but simple pattern. The overall concept behind the Prototype pattern is straightforward; instead of initializing new objects, we merely clone them from instances that are already in the memory. To maintain consistency during the cloning process, we encapsulate the manner in which objects clone themselves, removing this responsibility from the client. As a benefit, we can gain performance and consistency in the way that we spawn entities in our game.</p>
<p>In the next chapter, we will explore the Prototype pattern's close cousin, the Factory pattern.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exercise</h1>
                
            
            
                
<p>Every time you learn a new pattern and adapt it to Unity, you should validate whether it is beneficial beyond making your code look structured. Unlike in other domains, game programmers are judged not just by their ability to write clean code, but also by how fast it runs. You will notice that a lot of design patterns sacrifice performance for consistency in structure.</p>
<p>As an exercise, I recommend that you compare the performance of using <kbd>Instantiate()</kbd> by copying an existing object in the memory to that of using <kbd>Resource.Load()</kbd> to load up an existing prefab of the same object.</p>
<p>To accomplish this task, you can experiment with Unity's native profiling tools.</p>
<p>I recommend reading Unity's Profiler documentation; you can view the link in the <em>Further reading</em> section of this chapter. It's a good practice to profile your code often, especially before attempting any optimization. This approach will help you to avoid spending hours optimizing code that's not even executed that often.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<ul>
<li><em>Game Programming Patterns</em> by Robert Nystrom: <a href="http://gameprogrammingpatterns.com/">http://gameprogrammingpatterns.com</a><a href="http://gameprogrammingpatterns.com/"/></li>
<li><em>Unity Manual – Profiler overview: </em><a href="https://docs.unity3d.com/Manual/Profiler.html">https://docs.unity3d.com/Manual/Profiler.html</a></li>
</ul>


            

            
        
    </body></html>