- en: '*Chapter 6*: Parallel Programming Concepts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Task` objects. This chapter will delve deeper into the `System.Threading.Tasks.Parallel`
    members in the TPL and some additional tasking concepts for handling related tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The lines between parallel programming, concurrency, and asynchronous programming
    are not always clear-cut, and you will discover where the three concepts intersect
    as we read ahead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the TPL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel loops in .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relationships between parallel tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common pitfalls with parallelism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand how to use parallel programming
    in your own projects, why you would choose a parallel loop over a standard loop,
    and when to use `async` and `await` instead of a parallel loop.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples in this chapter, the following software is
    recommended for Windows developers:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 version 17.0 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these are recommended, if you have .NET 6 installed, you can use your
    preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later,
    JetBrains Rider, or Visual Studio Code will work just as well.
  prefs: []
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started by discussing the TPL and where it fits within the world of
    parallel programming in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the TPL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `System.Threading` and `System.Threading.Tasks` namespaces in *.NET Framework
    4.0*. The TPL provides features that make parallelism and concurrency simpler
    for .NET developers. There is no need to manage the `ThreadPool` tasks in your
    code. The TPL handles thread management and automatically scales the number of
    active threads based on processor capability and availability.
  prefs: []
  type: TYPE_NORMAL
- en: Developers should use the TPL when they need to introduce parallelism or concurrency
    to their code for improved performance. However, the TPL is not the right choice
    for every scenario. How do you know when to choose the TPL and which TPL constructs
    are the best choice for each scenario?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore a few common scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: I/O-bound operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When dealing with I/O-bound operations such as file operations, database calls,
    or web service calls, asynchronous programming with `Task` objects and C# `async`/`await`
    operations are your best choice. If your service requires that you loop through
    a large collection, making a service call for each object in the loop, you should
    consider refactoring the service to return the data as a single service call.
    This will minimize the overhead associated with each network operation. It will
    also allow your client code to make a single `async` call to the service while
    keeping the main thread free to do other work.
  prefs: []
  type: TYPE_NORMAL
- en: I/O-bound operations are usually not suited to parallel operations, but there
    are exceptions to every rule. If you need to iterate through a set of folders
    and subfolders in the filesystem, a parallel loop can be well-suited for this.
    However, it is important that none of the iterations of your loop attempt to access
    the same file in order to avoid locking issues.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s explore some CPU-bound scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: CPU-bound operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CPU-bound operations are not reliant on outside resources such as the filesystem,
    network, or the internet. They involve processing data in memory within your application’s
    process. There are many types of data transformation that fall into this category.
    Your application may be serializing or deserializing data, converting between
    file types, or processing images or other binary data.
  prefs: []
  type: TYPE_NORMAL
- en: These types of operations make sense for data parallelism and parallel loops
    in particular, with a couple of exceptions. First, if each iteration is not very
    CPU intensive, using the TPL is not worth the overhead it introduces. If the process
    is very intensive, but there are very few objects to iterate over, consider using
    `Parallel.Invoke` instead of one of the parallel loops, `Parallel.For` or `Parallel.ForEach`.
    Using parallel constructs for less CPU-intense operations can often slow your
    code due to the overhead of using the TPL. In [*Chapter 10*](B18552_10_ePub.xhtml#_idTextAnchor158)
    we will learn how to use Visual Studio to determine the performance of parallel
    and concurrent code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have some understanding of when to use parallelism in your applications,
    let’s explore some practical examples of using `Parallel.For` and `Parallel.ForEach`.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel loops in .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore some examples of leveraging data parallelism
    in .NET projects. The parallel versions of the C# `for` and `foreach` loops, `Parallel.For`
    and `Parallel.ForEach`, are part of the `System.Threading.Tasks.Parallel` namespace.
    Using these parallel loops is similar to using their standard counterparts in
    C#.
  prefs: []
  type: TYPE_NORMAL
- en: One key difference is that the body of the parallel loops is declared as a `continue`
    to stop the current iteration of the loop without breaking the entire loop, you
    would use a `return` statement. The equivalent of using `break` to break out of
    a parallel loop is to use the `Stop()` or `Break()` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example of using a `Parallel.For` loop in a .NET WinForms application.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Parallel.For loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to create a new `FileProcessor` class will iterate the files to
    aggregate the file size and find the most recently written file:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new .NET 6 WinForms project in Visual Studio
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class named `FileData`. This class will contain the data from `FileProcessor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will be returning a list of the `FileInfo` objects for the files in the selected
    folder, the total size of all files, the name of the last written file, and the
    date and time that the file was written.
  prefs: []
  type: TYPE_NORMAL
- en: Next, create a new class named `FileProcessor`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a static method named `GetInfoForFiles` to `FileProcessor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Parallel.For` loop and the **lambda expression** of its body are highlighted
    in the preceding code. There are a few things to note about the code inside the
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: First, `index` is provided as a parameter to the lambda expression so the expression
    body can use it to access the current member of the `files` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `totalFileSize` gets updated inside a call to `Interlocked.Add`. This is
    the most efficient way to safely add values in parallel code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There isn’t a simple way to leverage `Interlocked` to update the `lastWriteTime`
    DateTime value. So, instead, we are using a `lock` block with a `dateLock` object
    to safely read and set the `lastWriteTime` method-level variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, open the designer for `Form1.cs` and add the following controls to the
    form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: View the `Form1.designer.cs` file on this chapter’s GitHub repository ([https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06/WinFormsParallelLoopApp](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter06/WinFormsParallelLoopApp))
    to review and set all of the properties for these controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are finished, the form’s designer should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The completed Form1.cs designer view in Visual Studio ](img/Figure_6.1_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The completed Form1.cs designer view in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, double-click the `Form1` designer, and a `FolderBrowserButton_Click`
    event handler will be generated in the code-behind file. Add the following code
    to use the `folderToProcessDialog` object to show a folder picker dialog to the
    user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The selected folder path will be set in `FolderToProcessTextBox` for use in
    the next step. The user can alternatively manually type or paste a folder path
    in the field. If you would like to prevent manual entry, you can set `FolderToProcessTextBox.ReadOnly`
    to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, double-click the `FolderProcessButton_Click` event handler will be generated
    in the code behind. Add the following code to call `FileProcessor` and display
    the results in `FolderResultsTextBox`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code here is straightforward enough. The static `GetInfoForFiles` method
    returns a `FileData` instance with the file information. We’re using `StringBuilder`
    to create the output to be set in `FolderResultsTextBox`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re ready to run the application. Start debugging the project in Visual Studio
    and give it a try. Your results should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Running the Parallel Loops application ](img/Figure_6.2_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Running the Parallel Loops application
  prefs: []
  type: TYPE_NORMAL
- en: That’s all there is to it. If you want to try something more advanced, you can
    try modifying the project to also process files in all subfolders of the selected
    folder. Let’s make a different change to the project so we can reduce the locking
    calls to `Interlocked.Add`.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel loops with thread-local variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Parallel.For` construct has an overload that will allow our code to keep
    a running subtotal of the total file size for each thread participating in the
    loop. What that means is that we will only need to use `Interlocked.Add` when
    aggregating the subtotal from each thread to `totalFileSize`. This is accomplished
    by providing a `Interlocked.Add` will only be called 5 times instead of 200 times
    without losing any thread safety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: To summarize the preceding changes, you will notice we are using the `Parallel.For<long>`
    generic method to indicate that the `subtotal` thread-local variable should be
    `long` instead of `int` (the default type). The size is added to `subtotal` in
    the first lambda expression without any locking expression. We now have to return
    `subtotal`, so the other iterations have access to the data. Finally, we have
    added a final parameter to `For` with a lambda expression that adds each thread’s
    `runningTotal` to `totalFileSize` using `Interlocked.Add`.
  prefs: []
  type: TYPE_NORMAL
- en: If you update `FolderProcessButton_Click` to call `GetInfoForFilesThreadLocal`,
    the output will be the same, but the performance will be improved, perhaps not
    noticeably. The performance improvement depends on the number of files in your
    selected folder.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have tried a couple of exercises with the `Parallel.For` loop, let’s
    create a sample using the `Parallel.ForEach` method.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Parallel.ForEach loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Parallel.ForEach` methods, such as `Parallel.For`, are similar in use
    to their non-parallel counterpart. You would use `Parallel.ForEach` over `Parallel.For`
    when you have an `IEnumerable` collection to process. In this sample, we will
    create a new method that accepts a `List<string>` of image files to iterate and
    convert to `Bitmap` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new private static method named `ConvertJpgToBitmap` in
    the `FileProcessor` class. This method will open each JPG file and return a new
    `Bitmap` containing the image data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a public static method in the same class named `ConvertFilesToBitmaps`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method accepts `List<string>` containing the files in the selected folder.
    Inside the `Parallel.ForEach` loop, it checks whether the file has a `.jpg` or
    `.jpeg` file extension. If it does, it is converted to a bitmap and added to the
    `result` collection.
  prefs: []
  type: TYPE_NORMAL
- en: Add a new button to `Form1.cs`. Set the `Name` property as `ProcessJpgsButton`
    and the `Text` property as `Process JPGs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click the new button to create an event handler in the code-behind file.
    Add the following code to the new event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, run the project, select a folder containing some JPG files, and click the
    new **Process JPGs** button. You should see the height of each converted JPG listed
    in the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s all you need for a simple `Parallel.ForEach` loop. What can you do if
    you need to cancel a long-running parallel loop? Let’s update our example to do
    just that with `Parallel.ForEachAsync`.
  prefs: []
  type: TYPE_NORMAL
- en: Cancel a Parallel.ForEachAsync loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Parallel.ForEachAsync` is new in .NET 6\. It is an awaitable version of `Parallel.ForEach`
    with an `async` lambda expression as its body. Let’s update the previous example
    to use this new parallel method and add the ability to cancel the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to start by making an `async` copy of `ConvertFilesToBitmaps`
    named `ConvertFilesToBitmapsAsync`. The differences are highlighted in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The new method is `async`, returns `Task<List<Bitmap>>`, accepts `CancellationTokenSource`,
    and uses that when creating `ParallelOptions` to pass to the `Parallel.ForEachAsync`
    method. `Parallel.ForEachAsync` is awaited and its lambda expression is declared
    as `async` so we can await the new `Task.Delay` that has been added to give us
    enough time to click the **Cancel** button before the loop completes.
  prefs: []
  type: TYPE_NORMAL
- en: Enclosing `Parallel.ForEachAsync` in a `try`/`catch` block that handles `OperationCanceledException`
    enables the method to catch the cancellation. We’ll show a message to the user
    after the cancellation is handled.
  prefs: []
  type: TYPE_NORMAL
- en: The code is also setting the `ProcessorCount` option. If there is only one CPU
    core available, we will set the value to `1`; otherwise, we want to use no more
    than the number of available cores minus one. The .NET runtime typically manages
    this value very well, so you should only change this option if you find it improves
    your application’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Form1.cs` file, add a new `CancellationTokenSource` private variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update the event handler to be `async`, set `_cts` to be a new instance of `CancellationTokenSource`,
    and pass it to `ConvertFilesToBitmapsAsync`. Add `await` to that call as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All of the necessary changes are highlighted in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Add a new button to the form named `CancelButton` with a caption of `Cancel`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click the **Cancel** button and add the following event handler code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application, browse to and select a folder containing JPG files, click
    the **Process JPGs** button, and immediately click the **Cancel** button. You
    should receive a message indicating that processing has been canceled. No further
    records are processed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will learn more about canceling asynchronous and parallel work in [*Chapter
    11*](B18552_11_ePub.xhtml#_idTextAnchor173). Now, let’s discuss the `Parallel.Invoke`
    construct and relationships between tasks in the TPL.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships between parallel tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, [*Chapter 5*](B18552_05_ePub.xhtml#_idTextAnchor082),
    we learned how to use `async` and `await` to perform work in parallel and manage
    the flow of tasks by using `ContinueWith`. In this section, we will examine some
    of the TPL features that can be leveraged to manage relationships between tasks
    running in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by looking deeper into the `Parallel.Invoke` method provided by
    the TPL.
  prefs: []
  type: TYPE_NORMAL
- en: Under the covers of Parallel.Invoke
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](B18552_02_ePub.xhtml#_idTextAnchor034), we learned how to
    use the `Parallel.Invoke` method to execute multiple tasks in parallel. We are
    going to revisit `Parallel.Invoke` now and discover what is happening under the
    covers. Consider using it to invoke two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what is happening behind the scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Two tasks will be created and queued on the thread pool. Assuming the system
    has available resources, the two tasks should be picked up and run in parallel.
    The calling method will block the current thread, waiting for the parallel tasks
    to complete. The action will block the calling thread for the duration of the
    longest-running task.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is acceptable for your application, using `Parallel.Invoke` makes the
    code cleaner and easy to understand. However, if you don’t want to block the calling
    thread, there are a couple of options. First, let’s make a change to the second
    example to use `await`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'By awaiting `Task.WhenAll` instead of using `Task.WaitAll`, we’re allowing
    the current thread to do other work while waiting for the two child tasks to finish
    processing in parallel. To achieve the same result with `Parallel.Invoke`, we
    can wrap it in `Task`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The same technique can be used with `Parallel.For` to avoid blocking the calling
    thread while waiting for the loop to complete. This is not necessary for `Parallel.ForEach`.
    Instead of wrapping `Parallel.ForEach` in `Task`, we can replace it with `Parallel.ForEachAsync`.
    We learned earlier in this chapter that .NET 6 added `Parallel.ForEachAsync`,
    which returns `Task` and can be awaited.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s discuss how the relationship between parent tasks and their children
    can be managed.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding parallel child tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When executing nested tasks, by default, the parent task will not wait for
    its child tasks unless we use the `Wait()` method or `await` statements. However,
    this default behavior can be controlled with some options when using `Task.Factory.StartNew()`.
    To illustrate the available options, we are going to create a new sample project:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new C# console application named `ParallelTaskRelationshipsSample`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a class to the project named `ParallelWork`. This is where we will create
    the parent methods and their children.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the three following methods to the `ParallelWork` class. These will be
    our child methods. Each one writes some console output when starting and completing.
    Delays are injected with `Thread.SpinWait`. If you are unfamiliar with `Thread.SpinWait`,
    it puts the current thread into a loop for the number of iterations specified,
    injecting a wait without removing the thread from consideration with the scheduler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add a method named `DoAllWork`. This method will create a parent task
    that calls the preceding three methods with child tasks. There is no code added
    to wait for the child tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add some code to run `DoAllWork` from `Program.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program and examine the output. As you might expect, the parent task
    completes before its children:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The console application runs DoAllWork ](img/Figure_6.3_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – The console application runs DoAllWork
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s create a method named `DoAllWorkAttached`. This method will run
    the same three child tasks, but the child task will include the `TaskCreationOptions.AttachedToParent`
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `Program.cs` to call `DoAllWorkAttached` instead of `DoAllWork` and
    run the application again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Running our application and calling DoAllWorkAttached ](img/Figure_6.4_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Running our application and calling DoAllWorkAttached
  prefs: []
  type: TYPE_NORMAL
- en: You can see that even though we are not explicitly waiting for the child tasks,
    the parent task does not complete until its children do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose you have another parent that should not wait for its child tasks,
    regardless of whether they are started with the `TaskCreationOptions.AttachedToParent`
    option. Let’s create a new method that can handle this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a method named `DoAllWorkDenyAttach` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The child tasks are still being created with the `AttachedToParent` option,
    but the parent task now has a `DenyChildAttach` option set. This will supersede
    the child requests to attach to the parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `Program.cs` to call `DoAllWorkDenyAttach` and run the application once
    more:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The console application calls DoAllWorkDenyAttach ](img/Figure_6.5_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – The console application calls DoAllWorkDenyAttach
  prefs: []
  type: TYPE_NORMAL
- en: You can see that `DenyChildAttach` did override the `AttachToParent` option
    set on each child task. The parent completed without waiting for the children,
    as it did when calling `DoAllWork`.
  prefs: []
  type: TYPE_NORMAL
- en: One final note about this example. You may have noticed that we used `Task.Factory.StartNew`
    instead of `Task.Run`, even when we didn’t need to set `TaskCreationOption`. That
    is because `Task.Run` will prohibit any child tasks from attaching to a parent.
    If you used `Task.Run` for the parent task in the `DoAllWorkAttached` method,
    the parent would have completed first, as it did in the other methods.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s finish up this chapter by covering some potential pitfalls when working
    with parallel programming in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Common pitfalls with parallelism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with the TPL, there are some practices to avoid in order to ensure
    the best outcomes in your applications. In some cases, parallelism used incorrectly
    can result in performance degradation. In other cases, it can cause errors or
    data corruption.
  prefs: []
  type: TYPE_NORMAL
- en: Parallelism is not guaranteed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using one of the parallel loops or `Parallel.Invoke`, the iterations can
    run in parallel, but they are not guaranteed to do so. The code in these parallel
    delegates should be able to run successfully in either scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel loops are not always faster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We discussed this earlier in this chapter, but it is important to remember that
    parallel versions of `for` and `foreach` loops are not always faster. If each
    loop iteration runs quickly, the overhead of adding parallelism can slow down
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: This is important to remember when introducing any threading to applications.
    Always test your code before and after introducing concurrency or parallelism
    to ensure that the performance gains are worth the overhead of threading.
  prefs: []
  type: TYPE_NORMAL
- en: Beware of blocking the UI thread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that `Parallel.For` and `Parallel.ForEach` are *blocking calls*. If
    you use them on the UI thread, they will block the UI for the duration of the
    call. This blocking duration will be, at a minimum, the duration of the longest-running
    loop iteration.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in the previous section, you can wrap the parallel code in a
    call to `Task.Run` to move the execution from the UI thread to a background thread
    on the thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do not make calls to .NET methods that are not thread-safe within parallel
    loops. The thread safety of each .NET type is documented on Microsoft Docs. Use
    the .NET API browser to quickly find information about specific .NET APIs: [https://docs.microsoft.com/dotnet/api/](https://docs.microsoft.com/dotnet/api/).'
  prefs: []
  type: TYPE_NORMAL
- en: Limit the use of static .NET methods in parallel loops, even if they are marked
    as thread-safe. They will not cause errors or problems with data consistency,
    but they can negatively impact the loop performance. Even calls to `Console.WriteLine`
    should only be used for testing or demonstration purposes. Do not use these in
    production code.
  prefs: []
  type: TYPE_NORMAL
- en: UI controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Windows client applications, do not try to access UI controls within parallel
    loops. WinForms and WPF controls can only be accessed from the thread on which
    they were created. You can use `Dispatcher.Invoke` to invoke actions on other
    threads, but this will have performance implications. It is best to update the
    UI after your parallel loops have been completed.
  prefs: []
  type: TYPE_NORMAL
- en: ThreadLocal data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember to take advantage of `ThreadLocal` variables in your parallel loops.
    We illustrated how to do this in the *Parallel loops with thread-local variables*
    section earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: That covers your introduction to parallel programming with C# and .NET. Let’s
    wrap up by reviewing everything we have learned in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to leverage parallel programming concepts in
    our .NET applications. We got hands-on with `Parallel.For`, `Parallel.ForEach`,
    and `Parallel.ForEachAsync` loops. In those sections, we learned how to safely
    aggregate data while maintaining thread safety. Next, we learned how to manage
    relationships between parent tasks and their parallel children. This will help
    to ensure your applications maintain an expected order of operations.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we covered some important pitfalls to avoid when implementing parallelism
    in our applications. Developers will want to pay close attention to avoid any
    of these pitfalls in their own applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read more about data parallelism in .NET, the *Data Parallelism* documentation
    on Microsoft Docs is a great place to start: [https://docs.microsoft.com/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library](https://docs.microsoft.com/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue our exploration of the TPL by learning
    how to leverage the various building blocks included in the TPL Dataflow Library.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which parallel loop executes a delegate in parallel for a given number of iterations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which parallel loop is the awaitable version of `Parallel.ForEach`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which parallel method can execute two or more provided actions in parallel?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which `Task.Factory.StartNew` option can attach a child task’s completion to
    its parent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which `Task.Factory.StartNew` option can be provided to a parent task to prevent
    any child tasks from attaching?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you never use `Task.Run` when using `TaskCreationOptions` to establish
    parent/child relationships?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are parallel loops always faster than their traditional counterparts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
