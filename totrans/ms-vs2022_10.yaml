- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous Integration with GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the chapter on **Continuous Integration** ( **CI** ) with GitHub
    Actions. As we delve into this chapter, we will gain a comprehensive understanding
    of how GitHub Actions can enhance our development workflow, streamline our processes,
    and ensure our code base remains robust and reliable, as well as how Visual Studio
    helps us with this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will explore the fundamentals of GitHub Actions, a powerful CI/CD
    tool integrated directly into GitHub. Next, we will dive into configuring workflows
    in GitHub Actions. This section will guide you through setting up and managing
    workflows tailored to your project’s needs. Finally, we will focus on generating
    GitHub Actions files using Visual Studio. Visual Studio provides robust support
    for creating and managing GitHub Actions for Azure deployment, making it easier
    for us to integrate CI/CD into your development environment. We’ll cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GitHub Actions for CI/CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring workflows in GitHub Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating GitHub Actions files with Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering GitHub Actions for CI/CD is crucial for any modern developer. By the
    end of this chapter, you will have the knowledge and skills required to set up
    and manage automated workflows, significantly improving your development efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While writing this chapter, I used the following version of Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Enterprise 2022 Version 17.12.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preview 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To fully follow the chapter, you will also need a valid GitHub account, which
    you can set up at [https://github.com/](https://github.com/) .
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GitHub Actions for CI/CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will dive into GitHub Action to recognize its role in automating
    software workflows directly within GitHub repositories and facilitating CI and
    **continuous deployment** ( **CD** ) processes. CI/CD practices aim to accelerate
    development cycles, enhance code quality, and streamline application deployment
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions enables the direct automation of software workflows within GitHub
    repositories, encompassing CI/CD processes. By automating these workflows, development
    cycles can be expedited, code quality can be ensured, and application deployment
    processes can be streamlined. An example of this automation could be running tests
    on code automatically upon pushing changes to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of CI/CD, CI involves regularly merging all developers’ working
    copies to a shared mainline several times a day. This helps to detect and address
    bugs quickly. By integrating code frequently, teams can identify and fix issues
    early in the development cycle, reducing the cost and effort required to resolve
    them later. For instance, we can set up a GitHub Action to run unit tests every
    time a pull request is merged into the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: CD takes CI one step further by automating the deployment of code changes to
    selected infrastructure environments after they pass through the CI pipeline.
    CD ensures that new features and fixes are released quickly and reliably, improving
    the overall efficiency of the software release process. GitHub allows us to automatically
    deploy a web application to a staging environment whenever there’s a successful
    build from the CI pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions offers several benefits for implementing CI/CD pipelines, including
    ease of setup, integration with GitHub’s ecosystem, and the ability to customize
    workflows to fit specific project needs. These benefits make it accessible for
    teams of all sizes, from individuals working on personal projects to large organizations
    managing complex software products. A team can easily set up a CI/CD pipeline
    without needing extensive DevOps expertise, leading to faster development cycles
    and higher-quality releases.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions streamlines the setup of CI/CD pipelines, removing the need for
    manual configurations such as setting up webhooks, purchasing hardware, and managing
    security patches. Its seamless integration with GitHub allows it to respond to
    any webhook, enabling flexible event triggers for automation or CI/CD pipelines.
    The GitHub community contributes a vast array of pre-built CI/CD workflows through
    the GitHub Marketplace, making it easier for users to use existing solutions or
    share their own. Additionally, GitHub Actions supports any platform, language,
    and cloud, offering unparalleled flexibility for various technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a better understanding of the process, we will explore the different components
    of GitHub Actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Workflows** : A workflow is a configurable automated process that you can
    set up in your repository to build, test, package, release, or deploy any project
    on GitHub. Workflows are defined using **YAML** files stored in the **.github/workflows**
    directory of your repository. YAML originally stood for **Yet Another Markup Language**
    , but it later became the recursive acronym **YAML Ain’t** **Markup Language**
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Events** : An event is something that happens in a GitHub repository, which
    can trigger a workflow. Examples include pushing code ( **push** ), opening a
    pull request ( **pull_request** ), and creating a new issue ( **issue_comment**
    ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jobs** : A job is a set of steps that execute on the same runner. Each job
    runs in its own fresh instance of the virtual environment specified by **runs-on**
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions** : Actions are reusable units of code that perform a specific task,
    such as building a Docker image, running tests, or deploying to a server. They
    can be written in JavaScript (using Node.js) or TypeScript and can be hosted in
    GitHub Marketplace or self-hosted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runners** : Runners are servers where the jobs live while they are being
    executed. There are two types of runners: GitHub-hosted runners and self-hosted
    runners.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this overview of GitHub Actions, we will learn how to configure workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring workflows in GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All components of GitHub can be configured through YAML file. In this section,
    I will explain how the GitHub Actions configuration file is organized to help
    you understand its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The YAML files are placed in the **.github/workflows** directory of our repository.
    These files, known as workflow files, define the scenarios of our CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical GitHub Actions workflow configuration file consists of several key
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**name** : A human-readable name for the workflow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**on** : Specifies the event(s) that trigger the workflow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jobs** : Defines the jobs that make up the workflow. Each job runs on a runner
    environment specified by **runs-on** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**steps** : Within each job, steps are executed sequentially. Steps can run
    commands, set up tasks, or perform an action in your repository, a public repository,
    or an action published in a Docker registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**env** : Allows you to set environment variables for all steps in a job.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**defaults** : Sets default behaviors for all jobs and steps in the workflow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**permissions** : Controls the permissions granted to the GitHub Actions runner
    during the job execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s break down these key sections with a real-world CI workflow for a C# application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the content of a workflow file that we will name **CI.yaml** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s understand how this workflow works and is articulated. There are
    four parts in this file, and they are organized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: the** **Workflow Metadata** :'
  prefs: []
  type: TYPE_NORMAL
- en: '**name** : **C# CI**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a descriptive name for the workflow, making it easier to identify in
    the GitHub UI.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Part 2: the** **Trigger Conditions** :'
  prefs: []
  type: TYPE_NORMAL
- en: '**on:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**push:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**branches: [** **main ]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means the workflow will run whenever there’s a push to the main branch.
    Similarly, the following workflow will run when a pull request is opened, synchronized,
    or reopened targeting the main branch:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**pull_request:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**branches: [** **main ]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3:** **the Jobs** :'
  prefs: []
  type: TYPE_NORMAL
- en: '**jobs** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**build:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**runs-on** : **windows-latest**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This specifies that the job should run on the latest Windows environment provided
    by GitHub Actions. This is important because .NET Core/.NET 5+ applications often
    require a Windows environment to build and run correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Part 4:** **the Steps** :'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each job consists of a sequence of steps that are executed in order. Here’s
    what each step does:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Checkout code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**uses** : **actions/checkout@v2**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This action checks out our repository under **$GITHUB_WORKSPACE** , allowing
    subsequent steps in the job to access it. The **fetch-depth: 0** option ensures
    that all history for all tags and branches is fetched, not just the default branch.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set up .NET:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**name** : **Setup.NET**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**uses** : **actions/setup-dotnet@v1**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This action sets up the .NET environment. The **dotnet-version: ''3.1.x''**
    input specifies which version of .NET to use. We can adjust this to match the
    requirements of our project.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**name** : **Build**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**run** : **dotnet build --** **configuration Release**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This step compiles the application using the .NET CLI. The **--configuration
    Release** flag indicates that the build should produce a **release build** , optimizing
    the output for performance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**name** : **Test**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**run** : **dotnet test --no-build --** **verbosity normal**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This step runs any unit tests in the project without rebuilding the project
    first ( **--no-build** ). The **--verbosity normal** option controls the amount
    of logging output. This helps keep the log clean and focused on essential information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This workflow provides a straightforward CI pipeline for a C# project, ensuring
    that every push or pull request to the main branch is built and tested automatically.
    By adjusting the .NET version and possibly adding more jobs or steps, we can tailor
    this workflow to fit the specific needs of our project.
  prefs: []
  type: TYPE_NORMAL
- en: After pushing our YAML file to GitHub, we might now go to the **Actions** tab
    in our GitHub repository to see our workflow running. When we push changes to
    the main branch or open a pull request, the workflow will automatically run.
  prefs: []
  type: TYPE_NORMAL
- en: Generating GitHub Actions file with Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how Visual Studio allows us to generate our GitHub
    Actions file for our Azure deployment. Please note that you will need a valid
    subscription, as mentioned in the *Technical requirements* section, to complete
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need an application to deploy to Azure, and for that, I simply initiated
    a Blazor project, with the template provided by Visual Studio, which I named **BlazorServerApp**
    . After that, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the top node of our project in order to launch the publish wizard
    and select **Azure** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Publish Azure](img/B22218_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Publish Azure
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, select the type of target you want. It is up to you to choose the target
    that will suit your budget and company politics. For this example, we will choose
    **Azure App** **Service (Linux)** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Specific target](img/B22218_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Specific target
  prefs: []
  type: TYPE_NORMAL
- en: Once we choose the target, we will jump to the selection of the new **App Service**
    . Here, we have to select an existing instance in our subscription.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.3 – App Service subscription](img/B22218_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – App Service subscription
  prefs: []
  type: TYPE_NORMAL
- en: If none are available, you might need to create a new one by clicking on the
    **Create a new instance** link and following the instructions in the wizard.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the last step, we will determine the **Deployment type** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose **CI/CD using GitHub Actions workflows (generates yml file)** , which
    will generate the appropriate YAML file according to our configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Deployment type](img/B22218_10_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Deployment type
  prefs: []
  type: TYPE_NORMAL
- en: Now in the **Solution Explorer** , we can see the Blazor Server project and
    also the generated **BlazorServerApp.yml** file under a **GitHub** **Actions**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.5 – GitHub Actions node](img/B22218_10_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – GitHub Actions node
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to generate a GitHub Actions file. We were able to customize
    it to add code quality to our pipeline, using external tools, for example SonarCloud,
    a widely used static analysis solution, among others. GitHub Actions is a powerful
    asset to explore, and I advise you to read the book *Mastering GitHub Actions*
    by Eric Chapman ( [https://www.packtpub.com/en-us/product/mastering-github-actions-9781805128625](https://www.packtpub.com/en-us/product/mastering-github-actions-9781805128625)
    ) to dig deeper into the subject.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the power of GitHub Actions for CI and CD, learning
    how to automate and streamline our development workflows. We began by understanding
    the fundamental concepts of GitHub Actions. Next, we moved on to configuring workflows
    in GitHub Actions. We then learned how to write and manage YAML files that define
    our CI/CD pipelines. In the final section, we focused on generating GitHub Actions
    files using Visual Studio. Visual Studio’s robust support for GitHub Actions for
    Azure’s deployment simplifies the process of integrating CI/CD into your development
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Having established a strong foundation in automating CI/CD with GitHub Actions,
    it’s time to expand our collaborative capabilities. In the next chapter, we will
    explore how Azure DevOps can enhance team collaboration, streamline project management,
    and further optimize your development processes.
  prefs: []
  type: TYPE_NORMAL
