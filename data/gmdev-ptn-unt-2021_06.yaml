- en: Implementing a Game Manager with the Singleton
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单例实现游戏管理器
- en: In this first hands-on chapter, we will review one of the most infamous software
    design patterns in the field of programming, the **Singleton**. It could be argued
    by many that the Singleton is the most widely used pattern among Unity developers,
    maybe because it's the most straightforward pattern to learn. But it can also
    quickly become the "duct tape" in our programming toolbox that we reach for every
    time we need a quick fix for a complex architectural problem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个实践性章节中，我们将回顾编程领域中臭名昭著的软件设计模式之一，即**单例**。许多人可能会争辩说，单例是Unity开发者中最广泛使用的模式，也许是因为它是学习起来最直接的模式。但它也可以迅速成为我们编程工具箱中的“胶带”，每次我们需要快速修复复杂的架构问题时，我们都会伸手去拿它。
- en: For instance, when using this pattern, we can quickly establish a simple code
    architecture revolving around wrapping and managing all the core systems of our
    game in individual manager classes. Then we could have these managers expose clean
    and straightforward interfaces that will conceal the inner complexity of the systems.
    Also, to make sure that these managers are easily accessible and only a single
    instance runs at a time, we would implement them as Singletons. This approach
    might sound solid and beneficial, but it's full of pitfalls as it will create
    strong coupling between core components and make unit testing very difficult.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当使用这种模式时，我们可以快速建立一个简单的代码架构，围绕将我们游戏的所有核心系统封装和管理在单独的管理类中。然后我们可以让这些管理器提供干净、直接的接口，从而隐藏系统的内部复杂性。此外，为了确保这些管理器易于访问并且每次只有一个实例运行，我们将它们实现为单例。这种方法听起来很稳固且有益，但它充满了陷阱，因为它将在核心组件之间创建强耦合，并使单元测试变得非常困难。
- en: In this book, we will attempt to move away from this type of architecture and
    use design patterns to establish a more robust, modular, and scalable code base.
    But this doesn't mean that we will ignore the Singleton and judge it as inherently
    faulty. Instead, in this chapter, we will explore a use case in which this pattern
    is well suited.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将尝试摆脱这种类型的架构，并使用设计模式来建立一个更健壮、模块化和可扩展的代码库。但这并不意味着我们将忽视单例并认为它本质上是有缺陷的。相反，在本章中，我们将探讨一个这种模式非常适合的使用案例。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The basics of the Singleton pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式的基本原理
- en: Writing a reusable Singleton class in Unity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity中编写可重用的单例类
- en: Implementing a globally accessible GameManager
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现全局可访问的游戏管理器
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This is a hands-on chapter; you will need to have a basic understanding of Unity
    and C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实践性章节；你需要对Unity和C#有一个基本的了解。
- en: 'We will be using the following specific Unity engine and C# language concept:
    **Generics**.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下特定的Unity引擎和C#语言概念：**泛型**。
- en: If unfamiliar with this concept, please review [Chapter 3](c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml),
    *A Short Primer to Programming in Unity*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不熟悉这个概念，请参阅[第3章](c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml)，*Unity编程简明指南*。
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter04](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter04).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter04](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter04)。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：
- en: '[https://bit.ly/3wDbM6W](https://bit.ly/3wDbM6W)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/3wDbM6W](https://bit.ly/3wDbM6W)'
- en: Generics is a compelling C# feature that permits us to defer the type for a
    class at runtime. When we say a class is generic, it means that it doesn't have
    a defined object type. This approach is advantageous because we can assign it
    a specific type when we initialize it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是C#的一个引人入胜的特性，它允许我们在运行时延迟指定类的类型。当我们说一个类是泛型的时候，这意味着它没有定义的对象类型。这种方法的优势在于，当我们初始化它时，我们可以给它指定一个特定的类型。
- en: Understanding the Singleton pattern
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解单例模式
- en: As its name implies, the Singleton pattern's primary goal is to guarantee singularity.
    This approach means if a class implements this pattern correctly, once initialized,
    it will have only one instance of itself in memory during runtime. This mechanism
    can be helpful when you have a class that manages a system that needs to be globally
    accessible from a singular and consistent entry point.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，单例模式的主要目标是保证唯一性。这种方法意味着如果一个类正确实现了这个模式，一旦初始化，它将在运行时内存中只有一个自己的实例。这种机制在有一个需要从单一且一致的入口点全局访问的系统管理的类时非常有用。
- en: 'The design of the Singleton is quite simple. When you implement a Singleton
    class, it becomes responsible for making sure there''s only a single occurrence
    of itself in memory. Once a Singleton detects an instance of an object of the
    same type as itself, it will destroy it immediately. Therefore, it''s pretty ruthless
    and doesn''t tolerate any competition. The following diagram illustrates the process
    to a certain degree:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 单例的设计相当简单。当你实现一个单例类时，它就负责确保在内存中只有一个自己的实例。一旦单例检测到与自身类型相同的对象实例，它将立即销毁它。因此，它相当无情，不容忍任何竞争。以下图表在一定程度上说明了这个过程：
- en: '![](img/c6462456-8fd3-4b52-8ace-904528704212.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c6462456-8fd3-4b52-8ace-904528704212.png)'
- en: Figure 4.1 – UML diagram of the Singleton pattern
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 单例模式的UML图
- en: The most important takeaway from this description of the Singleton pattern is
    that if well implemented, it makes sure that there can only be one of itself;
    if not, it fails at its purpose.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从对单例模式的描述中，最重要的收获是，如果实现得当，它确保只能有一个实例；如果不这样，它就失败了其目的。
- en: Benefits and drawbacks
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 好处与缺点
- en: 'These are some of the benefits of the Singleton pattern:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是单例模式的一些好处：
- en: '**Globally accessible**: We can use the Singleton pattern to create a global
    access point to resources or services.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局访问**: 我们可以使用单例模式来创建对资源或服务的全局访问点。'
- en: '**Control concurrency**: The pattern can be used to limit concurrent access
    to shared resources.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制并发**: 这种模式可以用来限制对共享资源的并发访问。'
- en: 'These are some of the drawbacks of the Singleton pattern:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是单例模式的一些缺点：
- en: '**Unit testing**: If overly used, the Singleton can make unit testing very
    difficult. We might end up with Singleton objects being dependent on other Singletons.
    If one is missing at any moment, the chain of dependency gets broken. This issue
    often happens when combining Facade and Singleton to set up front-facing interfaces
    to core systems. We end up with an array of manager classes, each managing a specific
    core component of the game, all dependent on each other to function. Therefore,
    it becomes impossible to test and debug in isolation.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**: 如果过度使用，单例可能会使单元测试变得非常困难。我们可能会遇到单例对象依赖于其他单例的情况。如果任何一个在某个时刻缺失，依赖链就会被打破。这个问题通常发生在将外观模式和单例结合使用来设置面向核心系统的前端接口时。我们最终会得到一系列管理类，每个管理游戏的一个特定核心组件，所有这些类都相互依赖才能运行。因此，单独测试和调试变得不可能。'
- en: '**Laziness**: Because of its ease of use, the Singleton is a pattern that can
    quickly instill faulty programming habits. As mentioned in the *Unit testing*
    drawback, we can easily make everything accessible from anywhere with the Singleton.
    The simplicity it offers can also make us unwilling to test out more sophisticated
    approaches when writing code.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**惰性**: 由于其易用性，单例是一种可以迅速养成不良编程习惯的模式。正如在*单元测试*的缺点中提到的，我们可以很容易地通过单例从任何地方访问一切。它提供的简单性也可能使我们不愿意在编写代码时尝试更复杂的方法。'
- en: When making design choices, it's essential to always keep in mind whether your
    architecture is maintainable, scalable, and testable. When it comes to testable,
    I often ask myself whether I can easily test my core systems, components, and
    mechanics individually and in isolation. If not, then I know I made some potentially
    unwise decisions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出设计选择时，始终牢记你的架构是否可维护、可扩展和可测试是非常重要的。当涉及到可测试性时，我经常问自己是否可以轻松地单独和独立地测试我的核心系统、组件和机制。如果不能，那么我知道我可能做出了某些可能不明智的决定。
- en: Designing a Game Manager
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计游戏管理器
- en: A standard class we often see in Unity projects is the Game Manager. It's usually
    implemented as a Singleton by developers, but its responsibility varies from one
    code base to another. Some programmers use it to manage top-level game states
    or as a globally accessible front-facing interface to core game systems.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity项目中，我们经常看到的标准类是游戏管理器。开发者通常将其实现为单例，但其责任因代码库而异。一些程序员用它来管理顶级游戏状态，或者作为全局可访问的前端接口来访问核心游戏系统。
- en: In the context of this chapter, we will give it the singular responsibility
    of managing a game session. Similar to the concept of a game master in board gaming,
    it will be responsible for setting up the game for the player. It can also take
    on additional responsibilities, such as communicating with backend services, initializing
    global settings, logging, and saving the player's progress.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的上下文中，我们将赋予它管理游戏会话的单一责任。类似于桌面游戏中的游戏主持人，它将负责为玩家设置游戏。它还可以承担额外的责任，例如与后端服务通信、初始化全局设置、记录日志以及保存玩家的进度。
- en: The critical thing to keep in mind is that Game Manager will be alive for the
    entire lifespan of the game. Therefore, there will be a singular but persistent
    instance of it in memory at all times.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 需要牢记的关键点是游戏管理器将在整个游戏生命周期中存活。因此，在内存中始终将有一个单一但持久的实例。
- en: 'The following diagram illustrates the overall concept:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了整体概念：
- en: '![](img/d61677e1-5c53-4159-9d2b-54e8d2743a9f.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d61677e1-5c53-4159-9d2b-54e8d2743a9f.png)'
- en: Figure 4.2 – Diagram that illustrates the lifespan of the Game Manager
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 说明游戏管理器生命周期的图示
- en: In the next section, we are going to take the design we just reviewed and translate
    it into code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将把刚刚审查的设计转换为代码。
- en: Implementing the Game Manager
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现游戏管理器
- en: 'In this section, we will implement a Singleton and Game Manager class. We will
    attempt to utilize some core Unity API features to adapt the pattern for use in
    the engine:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现单例和游戏管理器类。我们将尝试利用一些核心Unity API功能来适应在引擎中使用该模式：
- en: 'For the first step of the process, we will implement the `Singleton` class.
    To make it easier to understand its intricacies, we will split it up into two
    distinct segments:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个过程的第一步，我们将实现`Singleton`类。为了更容易理解其复杂性，我们将将其分为两个不同的部分：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the first segment of the `Singleton<T>` class, we can see that we implemented
    a `public static` property with a `get` accessor. In this accessor, we are making
    sure that there's no existing instance of this object before initializing a new
    one. `FindObjectOfType<T>()` searches for the first loaded object of a specified
    type. If we can't find one, then we create a new `GameObject`, rename it, and
    add a component to it of a non-specified type.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Singleton<T>`类的第一部分中，我们可以看到我们实现了一个`public static`属性，并带有`get`访问器。在这个访问器中，我们确保在初始化新实例之前没有现有的实例。`FindObjectOfType<T>()`搜索指定类型的第一个已加载对象。如果我们找不到，那么我们将创建一个新的`GameObject`，重命名它，并添加一个非指定类型的组件。
- en: This process will be more evident when we implement the `GameManager` class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现`GameManager`类时，这个过程将更为明显。
- en: 'Let''s implement the final segment of the `Singleton` class:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现`Singleton`类的最后一段：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For the last segment of the class, we have an `Awake()` method that we marked
    as `virtual`, which means it can be overridden by a derived class. What is essential
    to understand is that when the `Awake()` method gets called by the engine, the
    Singleton component will check whether there's already an instance of itself initialized
    in memory. If not, then it will become the current instance. But if one already
    exists, it will destroy itself to prevent duplication.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类的最后一段，我们有一个标记为`virtual`的`Awake()`方法，这意味着它可以被派生类覆盖。需要理解的是，当引擎调用`Awake()`方法时，单例组件将检查内存中是否已经初始化了自身的实例。如果没有，那么它将成为当前实例。但如果已经存在一个实例，它将销毁自己以防止重复。
- en: Therefore, there can only be one instance of a specific type of Singleton in
    a Scene at once. If you try to add two, one will get automatically destroyed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在场景中一次只能有一个特定类型的单例实例。如果你尝试添加两个，其中一个将被自动销毁。
- en: 'Another important detail to review is the following line:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要审查的重要细节是以下这一行：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`DontDestroyOnLoad` is a public static method that is included in the Unity
    API; it prevents a target object from being destroyed when a new scene is loaded.
    In other words, it makes sure that the current instance of an object persists
    even when switching between scenes. This API feature is handy for our Singleton
    because it guarantees the object will be available throughout the application''s
    lifespan, in this context, the game.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`DontDestroyOnLoad` 是 Unity API 中包含的一个公共静态方法；它防止目标对象在新场景加载时被销毁。换句话说，它确保对象的当前实例在场景切换时仍然存在。这个
    API 功能对我们来说很有用，因为它保证了对象将在整个应用程序的生命周期内可用，在这个上下文中，是游戏。'
- en: 'For the final steps of our implementation, we will write a skeleton version
    of the `GameManager` class. We will focus only on code that will validate our
    `Singleton` implementation for reasons of brevity:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们实现的最后一步，我们将编写 `GameManager` 类的骨架版本。我们将只关注验证我们的 `Singleton` 实现的代码，出于简洁的考虑：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To give more context to `GameManager`, we left a `TODO` list of potential tasks
    for the class to accomplish. But we also added a timer and a GUI button. Both
    will help us validate whether our `Singleton` is working when we start the testing
    phase.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给 `GameManager` 提供更多上下文，我们留下了一个潜在任务的 `TODO` 列表，以便于该类完成。但我们还添加了一个计时器和 GUI 按钮。这两个都将帮助我们验证在开始测试阶段时我们的
    `Singleton` 是否正常工作。
- en: 'But at the moment, our `GameManager` is not a `Singleton`; to make it one,
    we just need to make one change to a single line of code, as we can see here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但目前，我们的 `GameManager` 不是一个 `Singleton`；要使其成为单一实例，我们只需对代码中的一行进行修改，如下所示：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's as simple as that; we took a regular `MonoBehaviour` class and converted
    it into a `Singleton` with one line of code. This is made possible because we
    are using Generics. Hence, our `Singleton` class can be anything until we assign
    it a specific type.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如此简单；我们从一个普通的 `MonoBehaviour` 类转换成了一个 `Singleton`，只用了五行代码。这是因为我们使用了泛型。因此，我们的
    `Singleton` 类可以是任何东西，直到我们给它分配一个特定的类型。
- en: 'So, for our last step, we took our `GameManager` class and converted it into
    `Singleton`, as seen here:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，在我们的最后一步中，我们将 `GameManager` 类转换成了 `Singleton`，如下所示：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have prepared all our ingredients, it's time to start the testing
    phase, which we will do next.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了所有配料，是时候开始测试阶段了，我们将在下一步进行。
- en: Testing the Game Manager
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试游戏管理器
- en: 'If you wish to test the classes you just wrote in your instance of Unity, then
    you should go through the following steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望测试你在 Unity 实例中编写的类，那么你应该按照以下步骤进行：
- en: Create a new empty Unity scene called `Init`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Init` 的新空 Unity 场景。
- en: In the `Init` scene, add an empty `GameObject` and attach the `GameManager`
    class to it.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Init` 场景中，添加一个空的 `GameObject` 并将其 `GameManager` 类附加到它上。
- en: Create several empty Unity scenes, as many as you wish.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建多个空 Unity 场景，数量不限。
- en: 'In **Build Settings** under the **File** menu, add the **Init** scene at index
    0:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **文件** 菜单下的 **构建设置** 中，将 **Init** 场景添加到索引 0：
- en: '![](img/0a040acf-a6ed-45b1-8185-575116bbc459.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a040acf-a6ed-45b1-8185-575116bbc459.jpg)'
- en: Figure 4.3 – Build Settings
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 构建设置
- en: Then add your new empty Unity scenes to the **Build Settings** list, as many
    as you wish.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将你新创建的空 Unity 场景添加到 **构建设置** 列表中，数量不限。
- en: 'If you now start the `Init` scene, you should see a GUI button named Next Scene
    as in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在启动 `Init` 场景，你应该看到一个名为 **下一场景** 的 GUI 按钮，如下截图所示：
- en: '![](img/f2e01498-e545-48b7-9875-a23bf0bf34e3.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2e01498-e545-48b7-9875-a23bf0bf34e3.png)'
- en: Figure 4.4 – Screenshot of the code example in action
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 代码示例执行截图
- en: If you click on the Next Scene button, you will cycle through each of the scenes
    you added in Build Settings, and the GUI will persist onscreen. If you stop running
    the game, you should see in the console log the duration of your session. If you
    try to add additional GameManagers to GameObjects in any scene, you will notice
    that they get destroyed, as only one can exist during the entire lifespan of the
    game.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击 **下一场景** 按钮，你将循环浏览在构建设置中添加的每个场景，并且 GUI 将持续显示在屏幕上。如果你停止运行游戏，你应该在控制台日志中看到你的会话时长。如果你尝试在任何场景中为
    GameObject 添加额外的 `GameManager`，你会注意到它们被销毁，因为在整个游戏生命周期中只能存在一个。
- en: This concludes our tests; we now have the first draft of a GameManager class
    and a reusable Singleton implementation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的测试；我们现在有了 `GameManager` 类的第一个草稿和一个可重用的 `Singleton` 实现。
- en: Summary
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we tackled one of the most controversial design patterns out
    there. But we found a way to implement it with a consistent and reusable approach.
    The Singleton is a pattern that's perfectly suited to Unity's coding model but
    overusing it can lead you to become too dependent on it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了最具有争议的设计模式之一。但我们找到了一种以一致和可重用的方法来实现它的方法。单例模式是完美适合Unity编码模型的模式，但过度使用它可能会导致你过度依赖它。
- en: In the next chapter, we will review the State pattern, which we will use to
    implement a controller class for the main ingredient of our game, the racing bike.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾状态模式，我们将使用它来实现我们游戏主要成分——赛车自行车——的控制类。
