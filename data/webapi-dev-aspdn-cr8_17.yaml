- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Cloud-Native Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云原生模式
- en: In the preceding chapters, we have covered a range of fundamental skills for
    web API development using ASP.NET Core. We discussed different styles of API development,
    such as REST, gRPC, and GraphQL, and how to implement the data access layer using
    Entity Framework Core. We also introduced how to secure a web API using the ASP.NET
    Core Identity framework. Additionally, we learned how to write unit tests and
    integration tests for web API applications, as well as common practices for API
    development, such as testing, caching, observability, and more. We also discussed
    how to deploy the containerized web API application to the cloud by using CI/CD
    pipelines. These are all essential skills for web API development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经涵盖了使用 ASP.NET Core 开发 Web API 的各种基本技能。我们讨论了不同的 API 开发风格，如 REST、gRPC
    和 GraphQL，以及如何使用 Entity Framework Core 实现数据访问层。我们还介绍了如何使用 ASP.NET Core Identity
    框架来保护 Web API。此外，我们还学习了如何为 Web API 应用程序编写单元测试和集成测试，以及 API 开发中的常见实践，如测试、缓存、可观察性等。我们还讨论了如何通过
    CI/CD 管道将容器化的 Web API 应用程序部署到云端。这些都是 Web API 开发的基本技能。
- en: However, this is just the beginning of the journey. As we wrap up our exploration
    of the fundamental concepts of web API development using ASP.NET Core, it is time
    to embark on a journey to explore more advanced topics. In this chapter, we will
    transition from the basics to delve into topics that are important for developers
    aspiring to master web API development. Now, let us elevate our skills to the
    next level.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仅仅是旅程的开始。随着我们结束对使用 ASP.NET Core 开发 Web API 的基本概念探索，是时候踏上探索更高级主题的旅程了。在本章中，我们将从基础知识过渡到深入探讨对希望掌握
    Web API 开发的开发者来说重要的主题。现在，让我们将我们的技能提升到下一个层次。
- en: 'We will delve into the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨以下主题：
- en: Domain-driven design
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域驱动设计
- en: Clean architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清洁架构
- en: Microservices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务
- en: Web API design patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web API 设计模式
- en: By the end of this chapter, you will have a high-level understanding of these
    topics and be able to explore them further on your own.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将对这些主题有一个高级的理解，并能够自行进一步探索。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code example in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter17](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter17).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可以在[https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter17](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter17)找到。
- en: Domain-driven design
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域驱动设计
- en: 'The term **domain-driven design**, also known as **DDD**, was coined by Eric
    Evans in his book *Domain-Driven Design: Tackling Complexity in the Heart of Software*,
    published in 2003\. DDD consists of a set of principles and practices that focus
    on the domain model and domain logic, which help developers manage the complexity
    and build flexible and maintainable software. DDD is not bound to any particular
    technology or framework. You can use it in any software project, including web
    API development.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**领域驱动设计**，也称为**DDD**，由埃里克·埃文斯在他的2003年出版的书籍《领域驱动设计：软件核心的复杂性处理》中提出。DDD 包含了一系列原则和实践，这些原则和实践专注于领域模型和领域逻辑，帮助开发者管理复杂性并构建灵活且可维护的软件。DDD
    不局限于任何特定的技术或框架。你可以在任何软件项目中使用它，包括 Web API 开发。
- en: 'In Eric Evans’ book, he defines three important principles of DDD:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在埃里克·埃文斯的书中，他定义了 DDD 的三个重要原则：
- en: Focusing on the core domain and domain logic
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注核心领域和领域逻辑
- en: Basing complex designs on the domain models
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以领域模型为基础进行复杂设计
- en: Collaborating with technical and domain experts to iteratively refine the model
    that solves domain problems
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与技术和领域专家合作，迭代地完善解决领域问题的模型
- en: A domain is a subject area that the software system is built for. The domain
    model is a conceptual model of the domain, which incorporates both data and behavior.
    Developers build the domain model based on the domain knowledge from domain experts.
    The domain model is the core of the software system that can be used to solve
    domain problems.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 领域是软件系统所构建的主题区域。领域模型是领域概念模型，它结合了数据和行为。开发者根据领域专家的领域知识构建领域模型。领域模型是软件系统的核心，可以用来解决领域问题。
- en: In the following subsections, we will introduce the basic concepts of DDD and
    how to apply them to web API development. Note that domain-driven design is a
    comprehensive topic that cannot be covered in a single chapter. So, the subsections
    are not intended to be a complete guide to DDD. Instead, it will provide a high-level
    overview of DDD and explain some of the key concepts of DDD. If you want to learn
    more about DDD, you can refer to other resources, such as Eric Evans’ DDD book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下子节中，我们将介绍DDD的基本概念以及如何将其应用于Web API开发。请注意，领域驱动设计是一个综合性的主题，无法在一个章节中涵盖。因此，子节的目的不是成为DDD的完整指南，而是提供一个DDD的高级概述并解释一些DDD的关键概念。如果您想了解更多关于DDD的信息，可以参考其他资源，例如埃里克·埃文斯的DDD书籍。
- en: Ubiquitous language
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用语言
- en: One of the core concepts of DDD is that to build a software system for a complex
    business domain, we need to build ubiquitous language and a domain model that
    reflects the business domain. Under domain-driven design, the software structure
    and code, such as class names, class methods, and so on, should match the business
    domain. The domain terms should be embedded in the code. When developers talk
    to domain experts, they should use the same terms. For example, if we are building
    a web API for a banking system, we may have a `Banking` domain. When we discuss
    the requirements with domain experts, we may hear terms such as `Account`, `Transaction`,
    `Deposit`, `Withdrawal`, and so on. In a banking system, an `Account` object can
    have different types, such as `SavingAccount`, `LoanAccount`, `CreditCardAccount`,
    and so on. A `SavingAccount` may have a `Deposit()` method and a `Withdrawal()`
    method. In the code of the system, we should use the same terms as the domain
    experts.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: DDD的一个核心概念是，为了构建一个复杂业务领域的软件系统，我们需要构建通用语言和反映业务领域的领域模型。在领域驱动设计中，软件结构和代码，如类名、类方法等，应与业务领域相匹配。领域术语应嵌入到代码中。当开发者与领域专家交谈时，他们应使用相同的术语。例如，如果我们正在构建一个银行系统的Web
    API，我们可能有一个`Banking`领域。当我们与领域专家讨论需求时，我们可能会听到诸如`Account`、`Transaction`、`Deposit`、`Withdrawal`等术语。在银行系统中，一个`Account`对象可以有不同的类型，例如`SavingAccount`、`LoanAccount`、`CreditCardAccount`等。一个`SavingAccount`可能有一个`Deposit()`方法和一个`Withdrawal()`方法。在系统的代码中，我们应该使用与领域专家相同的术语。
- en: The use of a ubiquitous language is an essential pillar of DDD. This language
    provides a common understanding between domain experts, developers, and users,
    allowing them to effectively communicate system requirements, design, and implementation.
    By consciously using the ubiquitous language in the code, developers can build
    a domain model that accurately reflects the business domain. Without this, the
    code may become disconnected from the business domain and become difficult to
    manage.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通用语言的运用是DDD的一个基本支柱。这种语言在领域专家、开发者和用户之间提供了共同的理解，使他们能够有效地沟通系统需求、设计和实现。通过在代码中自觉地使用通用语言，开发者可以构建一个准确反映业务领域的领域模型。如果没有这一点，代码可能会与业务领域脱节，变得难以管理。
- en: Bounded context
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边界上下文
- en: In the realm of DDD, the concept of a bounded context is essential. A bounded
    context is a boundary that defines a domain model and serves as a delineated area
    of responsibility within a software system. It is like a linguistic territory
    in which a specific model holds meaning and relevance. By encapsulating a distinct
    understanding of the domain, bounded contexts promote clarity and precision in
    communication between domain experts and developers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域驱动设计（DDD）的领域中，边界上下文的概念至关重要。边界上下文是一个定义领域模型并作为软件系统内责任划分区域的边界。它就像一个语言领土，在这个领土中，特定的模型具有意义和相关性。通过封装对领域的独特理解，边界上下文促进了领域专家和开发者之间沟通的清晰性和精确性。
- en: Consider a scenario where we are building a web API for a banking system. Without
    bounded contexts, the term `Account` could be interpreted differently in the `Banking`
    domain and the `customer relationship management` (CRM) domain. This ambiguity
    can lead to confusion, misaligned expectations, and ultimately, a fragmented understanding
    of the entire system. To avoid this, bounded contexts should be used to clearly
    define the scope of the domain model.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个场景，我们正在构建一个银行系统的Web API。如果没有边界上下文，`Account`这个术语在`Banking`领域和客户关系管理（CRM）领域可能会有不同的解释。这种歧义可能导致混淆、期望不一致，最终导致对整个系统的理解碎片化。为了避免这种情况，应该使用边界上下文来明确定义领域模型的范围。
- en: In many cases, a domain consists of several subdomains, each of which may refer
    to a distinct part of the business domain, thus creating different bounded contexts.
    These bounded contexts communicate with each other through programmatic interfaces,
    such as web APIs and message queues.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，领域由几个子领域组成，每个子领域可能指代业务领域的不同部分，从而创建不同的边界上下文。这些边界上下文通过程序接口相互通信，例如Web API和消息队列。
- en: DDD layers
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DDD层
- en: 'A DDD solution is often represented as a layered architecture. Each layer has
    a specific responsibility. The following diagram shows the typical layers of a
    DDD application:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: DDD解决方案通常表示为一个分层架构。每一层都有特定的职责。以下图显示了DDD应用的典型层：
- en: '![Figure 17.1 – Typical layers of a DDD application](img/B18971_17_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图17.1 – DDD应用的典型层](img/B18971_17_01.jpg)'
- en: Figure 17.1 – Typical layers of a DDD application
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1 – DDD应用的典型层
- en: 'In the preceding diagram, there are four layers:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，有四个层：
- en: '**Presentation layer**: This layer is responsible for presenting the data to
    the user and receiving user input. Normally, this layer is implemented as a user
    interface, such as a web application, a mobile application, or a desktop application.
    In this book, we mainly focus on web API applications that do not have a user
    interface. In this case, the presentation layer can be a client application that
    consumes the web API.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**：这一层负责向用户展示数据并接收用户输入。通常，这一层实现为一个用户界面，例如Web应用程序、移动应用程序或桌面应用程序。在这本书中，我们主要关注没有用户界面的Web
    API应用程序。在这种情况下，表示层可以是一个消费Web API的客户端应用程序。'
- en: '**Application layer**: This layer is responsible for coordinating the application’s
    activity. It receives user input from the presentation layer, invokes the domain
    layer to perform business logic, and returns the results to the presentation layer.
    In our case, the application layer is the web API application, which receives
    HTTP requests from the client application, invokes the domain layer to execute
    business logic, and returns the results to the client application.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**：这一层负责协调应用程序的活动。它从表示层接收用户输入，调用领域层执行业务逻辑，并将结果返回给表示层。在我们的案例中，应用层是Web API应用程序，它从客户端应用程序接收HTTP请求，调用领域层执行业务逻辑，并将结果返回给客户端应用程序。'
- en: '`Deposit` method for the `SavingAccount` class, the logic in the domain layer
    does not have any knowledge of how to save data to the database. Instead, it only
    focuses on the business logic of the `Deposit` method using abstractions and interfaces.
    This layer often contains entities, value objects, aggregates, repositories, and
    domain services.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SavingAccount`类的`Deposit`方法，领域层中的逻辑并不知道如何将数据保存到数据库中。相反，它只关注使用抽象和接口的`Deposit`方法业务逻辑。这一层通常包含实体、值对象、聚合、存储库和领域服务。'
- en: '**Infrastructure layer**: This layer implements the application infrastructure,
    such as data access, caching, logging, messaging, and so on. It often integrates
    with external systems as dependencies, such as database, message queues, and so
    on. In our case, the infrastructure layer can include the data access layer, which
    uses EF Core to access the database.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施层**：这一层实现了应用程序的基础设施，例如数据访问、缓存、日志记录、消息传递等。它通常与外部系统作为依赖项集成，例如数据库、消息队列等。在我们的案例中，基础设施层可以包括数据访问层，该层使用EF
    Core来访问数据库。'
- en: DDD focuses primarily on the domain and application layers. This is because
    the UI layer and the infrastructure layer are not specific to DDD and can be implemented
    with any technology or framework. For example, the UI layer can be implemented
    using **ASP.NET Core MVC**, **Blazor**, **React**, **WPF**, or any other UI framework
    on various platforms, while the core domain logic remains the same. Similarly,
    DDD does not dictate data storage, which can be a relational database, a NoSQL
    database, or any other data storage. The domain layer uses the repository pattern
    to access the data, which is independent of data storage. Another example is the
    logging mechanism, which is also not specific to DDD, as the domain layer needs
    to log the business events but does not care about the logging system used.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: DDD 主要关注领域和应用层。这是因为 UI 层和基础设施层不是 DDD 特有的，可以使用任何技术或框架来实现。例如，UI 层可以使用 **ASP.NET
    Core MVC**、**Blazor**、**React**、**WPF** 或任何其他平台上的 UI 框架来实现，而核心领域逻辑保持不变。同样，DDD
    也不指定数据存储，可以是关系型数据库、NoSQL 数据库或任何其他数据存储。领域层使用仓储模式来访问数据，这与数据存储无关。另一个例子是日志机制，它也不是
    DDD 特有的，因为领域层需要记录业务事件，但并不关心所使用的日志系统。
- en: DDD building blocks
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DDD 构建模块
- en: 'DDD has a set of building blocks that can be used to build the domain model.
    These building blocks include entities, value objects, aggregates, repositories,
    and domain services. In the following subsections, we will introduce these building
    blocks and how to use them to build the domain model:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: DDD 有一些构建模块，可以用来构建领域模型。这些构建模块包括实体、值对象、聚合、仓储和领域服务。在接下来的小节中，我们将介绍这些构建模块以及如何使用它们来构建领域模型：
- en: Entity
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实体
- en: You may have essential knowledge of **object-oriented programming** (**OOP**)
    and **object-relational mapping** (**ORM**) if you have read the previous chapters.
    In OOP, an object is an instance of a class. An object has a state and behavior.
    The state is represented by the properties of the object, while the behavior is
    represented by the methods of the object.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了前面的章节，你可能对 **面向对象编程**（**OOP**）和 **对象关系映射**（**ORM**）有基本的了解。在 OOP 中，一个对象是一个类的实例。对象具有状态和行为。状态由对象属性表示，而行为由对象的方法表示。
- en: In DDD, the entity is similar to an object in OOP, but it is more than that.
    An **entity** is an object that has a unique identity and is defined by its identity,
    not its attributes. Normally, an entity is mapped to a table in the database.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DDD 中，实体类似于 OOP 中的对象，但不仅如此。**实体**是一个具有唯一标识符的对象，它由其标识符定义，而不是由其属性定义。通常，实体映射到数据库中的表。
- en: The identity of an entity is normally represented by an ID property. The ID
    property is immutable, which means that once it is set, it cannot be changed.
    The ID property can be a primitive type, such as an integer, a string, or a GUID.
    It can also be composite keys.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实体的标识符通常由一个 ID 属性表示。ID 属性是不可变的，这意味着一旦设置，就不能更改。ID 属性可以是原始类型，如整数、字符串或 GUID。它也可以是复合键。
- en: If two entities have the same properties but different identities, they are
    considered different entities.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个实体具有相同的属性但不同的标识符，它们被认为是不同的实体。
- en: For example, in a banking system, `Account` is an entity. It has a unique identity
    that can be represented by an `Id` property. Two accounts cannot have the same
    `Id` property.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个银行系统中，`Account` 是一个实体。它有一个唯一的标识符，可以用 `Id` 属性来表示。两个账户不能有相同的 `Id` 属性。
- en: Value object
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 值对象
- en: A **value object** is another type of object in DDD. It is identified by its
    properties, rather than a unique identity. Normally, a value object is immutable,
    which means that its properties cannot be changed once it is created. If two value
    objects have the same properties, they are considered the same value object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**值对象**是 DDD 中的一种对象类型。它通过其属性来识别，而不是通过唯一的标识符。通常，值对象是不可变的，这意味着一旦创建，其属性就不能被更改。如果两个值对象具有相同的属性，它们被认为是相同的值对象。'
- en: For example, `Address` is a value object. It is identified by its properties,
    such as `Street`, `City`, `State`, and `ZipCode`. If two addresses have the same
    `Street`, `City`, `State`, and `ZipCode`, they are considered the same address.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Address` 是一个值对象。它通过其属性，如 `Street`、`City`、`State` 和 `ZipCode` 来识别。如果两个地址具有相同的
    `Street`、`City`、`State` 和 `ZipCode`，它们被认为是相同的地址。
- en: Aggregate
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 聚合
- en: An **aggregate** is a cluster of associated objects, including entities and
    value objects, which are treated as a unit for data changes. An aggregate has
    a root entity, which is the only object that can be accessed from outside the
    aggregate. The root entity is responsible for maintaining the consistency and
    integrity of the aggregate. It is important to note that if the external objects
    need to access the objects inside the aggregate or modify the objects inside the
    aggregate, they must go through the root entity.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**聚合**是一组关联的对象，包括实体和值对象，它们被视为数据变更的单位。聚合有一个根实体，这是唯一可以从聚合外部访问的对象。根实体负责维护聚合的一致性和完整性。需要注意的是，如果外部对象需要访问聚合内的对象或修改聚合内的对象，它们必须通过根实体进行。'
- en: 'For example, in an invoicing system, an `Invoice` entity is an aggregate root.
    It contains a list of `InvoiceItem` entities, which are the items of the invoice.
    To add an item to the invoice, the external objects must go through the `Invoice`
    entity, as shown in the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个发票系统中，`Invoice` 实体是一个聚合根。它包含一个 `InvoiceItem` 实体的列表，这些是发票的项目。要向发票中添加项目，外部对象必须通过
    `Invoice` 实体，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, if we need to add or remove an item from the invoice,
    we must get the `Invoice` entity first, and then call the `AddItem()` or `RemoveItem()`
    method to add or remove the item. We cannot directly add or remove an item from
    the `Items` property because the `Items` property is private and can only be accessed
    from inside the `Invoice` entity. In this way, the domain logic is encapsulated
    inside the `Invoice` entity, and the consistency and integrity of the invoice
    are maintained. Similarly, we cannot change the `Total` property directly. Instead,
    the `AddItem` or `RemoveItem` method can update the `Total` property.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，如果我们需要向发票中添加或删除项目，我们必须首先获取 `Invoice` 实体，然后调用 `AddItem()` 或 `RemoveItem()`
    方法来添加或删除项目。我们不能直接从 `Items` 属性添加或删除项目，因为 `Items` 属性是私有的，并且只能从 `Invoice` 实体内部访问。这样，领域逻辑就被封装在
    `Invoice` 实体内部，并维护了发票的一致性和完整性。同样，我们也不能直接更改 `Total` 属性。相反，`AddItem` 或 `RemoveItem`
    方法可以更新 `Total` 属性。
- en: Repository
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 存储库
- en: A **repository** is an abstraction layer used to access the data persistence
    layer. It encapsulates the data access logic and provides a way to query and save
    data. To ensure the domain layer does not depend on any specific data access technology,
    a repository is typically implemented as an interface. The infrastructure layer
    can then use a specific data access technology, such as EF Core or Dapper, to
    implement the repository interface and access different data sources, such as
    relational databases or NoSQL databases. This decouples the domain layer from
    the data access technology and data storage.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**存储库**是一个用于访问数据持久层的抽象层。它封装了数据访问逻辑，并提供了一种查询和保存数据的方式。为了确保领域层不依赖于任何特定的数据访问技术，存储库通常实现为一个接口。然后，基础设施层可以使用特定的数据访问技术，如
    EF Core 或 Dapper，来实现存储库接口并访问不同的数据源，如关系数据库或 NoSQL 数据库。这种方式将领域层与数据访问技术和数据存储解耦。'
- en: 'An example of a repository interface is shown in the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了存储库接口的一个示例：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We introduced the repository pattern in [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371).
    It is not a specific DDD pattern. However, it is often used in DDD to decouple
    the domain layer from the data access layer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第9章*](B18971_09.xhtml#_idTextAnchor371)中介绍了存储库模式。它不是一个特定的 DDD 模式。然而，它经常在
    DDD 中用于解耦领域层和数据访问层。
- en: Domain service
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 领域服务
- en: A **domain service** is a stateless service that contains domain logic that
    does not belong to any specific entity or value object. It is often used to implement
    complex domain logic that involves multiple entities or value objects. To access
    the data persistence layer, a domain service may depend on one or more repositories.
    Additionally, it may also depend on other external services. These dependencies
    are injected into the domain service through the dependency injection mechanism.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域服务**是一种无状态服务，它包含不属于任何特定实体或值对象的领域逻辑。它通常用于实现涉及多个实体或值对象的复杂领域逻辑。为了访问数据持久层，领域服务可能依赖于一个或多个存储库。此外，它还可能依赖于其他外部服务。这些依赖通过依赖注入机制注入到领域服务中。'
- en: For example, in a banking system, the `TransferService` domain service is responsible
    for the logic of transferring money from one account to another. To do this, it
    relies on the `AccountRepository` to access the `Account` entity. Additionally,
    it may need to use an external service to send a notification to the account holder
    after the transfer is complete. If the accounts are in different banks, the `TransferService`
    domain service may also need to use an external service to transfer money between
    them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个银行系统中，`TransferService` 领域服务负责将资金从一个账户转移到另一个账户的逻辑。为此，它依赖于 `AccountRepository`
    来访问 `Account` 实体。此外，它可能需要使用外部服务在转账完成后向账户持有人发送通知。如果账户在不同的银行，`TransferService` 领域服务可能还需要使用外部服务在它们之间转账。
- en: 'The following code shows an example of a domain service:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了领域服务的示例：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code shows a `TransferService` domain service. It has four dependencies:
    `IAccountRepository`, `ITransactionRepository`, `INotificationService`, and `IBankTransferService`.
    The `TransferAsync` method transfers money from one account to another. It first
    obtains the accounts from `IAccountRepository`, and then transfers money between
    the accounts. After that, it saves the changes to `IAccountRepository` and creates
    transaction records in `ITransactionRepository`. Finally, it sends a notification
    to the account holders using `INotificationService`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了 `TransferService` 领域服务。它有四个依赖项：`IAccountRepository`、`ITransactionRepository`、`INotificationService`
    和 `IBankTransferService`。`TransferAsync` 方法用于将资金从一个账户转移到另一个账户。它首先从 `IAccountRepository`
    获取账户信息，然后在这些账户之间进行转账。之后，它将更改保存到 `IAccountRepository` 并在 `ITransactionRepository`
    中创建交易记录。最后，它使用 `INotificationService` 向账户持有人发送通知。
- en: Important note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: The preceding example is simplified for demonstration purposes. The actual implementation
    to transfer money between two accounts is much more complicated. For example,
    it may need to check the balance of the accounts, check the daily transfer limit,
    and so on. It may also need to transfer money between different banks, which involves
    a lot of complex logic to handle any errors that may occur during the transfer.
    If any error occurs, it may need to roll back the transaction. This is a typical
    example of a domain service that implements complex domain logic.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例为了演示目的而简化了。实际在两个账户之间转账的实现要复杂得多。例如，可能需要检查账户余额、检查每日转账限额等。它还可能需要在不同的银行之间转账，这涉及到处理转账过程中可能发生的任何错误的复杂逻辑。如果发生任何错误，可能需要回滚交易。这是一个典型的实现复杂领域逻辑的领域服务示例。
- en: Unit of work
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 工作单元
- en: In the preceding example, when transferring money between two accounts, the
    process involves multiple steps. What if an error occurs during the process? In
    order to prevent any money from being lost during the process of transferring
    funds between two accounts, it is necessary to wrap the process in a transaction.
    This will ensure that in the event of an error occurring, the transaction will
    be rolled back, and the funds will remain secure. For example, if the `TransferAsync()`
    method throws an exception after the money has been withdrawn from `fromAccount`
    but before it is deposited to `toAccount`, the transaction will be rolled back,
    and the money will not be lost.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，当在两个账户之间转账时，涉及多个步骤。如果在过程中发生错误怎么办？为了防止在两个账户之间转账过程中任何资金丢失，有必要将这个过程包裹在一个事务中。这将确保在发生错误的情况下，事务将被回滚，资金将保持安全。例如，如果
    `TransferAsync()` 方法在从 `fromAccount` 提取资金后但在将其存入 `toAccount` 之前抛出异常，则事务将被回滚，资金不会丢失。
- en: The term **transaction** is often used in the context of databases. This kind
    of transaction is called a **unit of work** in DDD. A unit of work is a sequence
    of operations that must be performed as a whole. All the steps in a unit of work
    must succeed or fail together. If any step fails, the entire unit of work must
    be rolled back. This prevents the data from being left in an inconsistent state.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库的上下文中，术语 **transaction** 经常被使用。这种交易在 DDD 中被称为 **工作单元**。工作单元是一系列必须作为一个整体执行的操作。工作单元中的所有步骤必须同时成功或失败。如果任何步骤失败，整个工作单元必须回滚。这可以防止数据处于不一致的状态。
- en: A unit of work can be implemented in various ways. In many scenarios, a unit
    of work is implemented as a database transaction. Another example is a message
    queue. When a message is received, it is processed as a unit of work. If the process
    is successful, the message is removed from the queue. Otherwise, the message remains
    in the queue and will be processed again at a later time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 工作单元可以以多种方式实现。在许多场景中，工作单元被实现为一个数据库事务。另一个例子是消息队列。当接收到消息时，它作为一个工作单元进行处理。如果处理成功，则从队列中删除消息。否则，消息将保留在队列中，将在稍后时间再次进行处理。
- en: Application service
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 应用服务
- en: The application service is responsible for managing the application process.
    It receives user input from the presentation layer, invokes the domain service
    to execute business logic, and returns the results to the Presentation Layer.
    In a web API application, the Application Service can be implemented as a web
    API controller or a separate service that is invoked by the web API controller.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务负责管理应用过程。它从表示层接收用户输入，调用领域服务执行业务逻辑，并将结果返回给表示层。在一个Web API应用程序中，应用服务可以作为一个Web
    API控制器实现，或者作为一个由Web API控制器调用的独立服务。
- en: The application service should be thin and delegate most of the work to the
    domain service. Typically, the application service uses `AutoMapper`. For example,
    an `InvoiceDto` class may contain the properties of an invoice, such as `Id`,
    `Date`, `Status`, `Total`, and so on. It does not have any method to add or remove
    an invoice item or close the invoice. It is purely a data container. If a property
    of the `Invoice` entity is not needed in the presentation layer, it should not
    be included in `InvoiceDto`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务应该是薄的，并将大部分工作委托给领域服务。通常，应用服务使用`AutoMapper`。例如，一个`InvoiceDto`类可能包含发票的属性，如`Id`、`Date`、`Status`、`Total`等。它没有任何添加或删除发票项目或关闭发票的方法。它纯粹是一个数据容器。如果`Invoice`实体的某个属性在表示层中不需要，则不应将其包含在`InvoiceDto`中。
- en: The presentation layer can send a DTO to the application service when it needs
    to create or update an entity. The application service will then map the DTO to
    the entity and invoke the domain service to execute the necessary business logic.
    Finally, the application service will map the entity back to the DTO and return
    it to the presentation layer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当表示层需要创建或更新实体时，它可以向应用服务发送一个DTO。然后，应用服务将DTO映射到实体，并调用领域服务来执行必要的业务逻辑。最后，应用服务将实体映射回DTO，并将其返回给表示层。
- en: 'Here is a simple example of an application service:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个应用服务的简单示例：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding example, the `IInvoiceService` interface defines the methods
    of the application service. The `InvoiceService` class implements the `IInvoiceService`
    interface. It has two dependencies: `IInvoiceRepository` and `IMapper`. `IInvoiceRepository`
    is used to access the `Invoice` entity, while `IMapper` is used to map `InvoiceDto`
    to the `Invoice` entity and vice versa. The `CreateAsync()` method receives `InvoiceDto`
    from the presentation layer via the controller, maps it to the `Invoice` entity,
    and then invokes the `AddAsync()` method of `IInvoiceRepository` to add the `Invoice`
    entity to the database. Finally, it maps the `Invoice` entity back to `InvoiceDto`
    and returns it to the presentation layer.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`IInvoiceService`接口定义了应用服务的方法。`InvoiceService`类实现了`IInvoiceService`接口。它有两个依赖项：`IInvoiceRepository`和`IMapper`。`IInvoiceRepository`用于访问`Invoice`实体，而`IMapper`用于将`InvoiceDto`映射到`Invoice`实体，反之亦然。`CreateAsync()`方法通过控制器从表示层接收`InvoiceDto`，将其映射到`Invoice`实体，然后调用`IInvoiceRepository`的`AddAsync()`方法将`Invoice`实体添加到数据库中。最后，它将`Invoice`实体映射回`InvoiceDto`，并将其返回给表示层。
- en: Important note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: In the preceding example, there is no domain service. This is because the logic
    to create an invoice is simple. In this case, the application service layer can
    directly invoke the repository to add the invoice to the database. However, if
    the logic is more complex, involving multiple entities or aggregates, it is better
    to use a domain service to implement the logic.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，没有领域服务。这是因为创建发票的逻辑很简单。在这种情况下，应用服务层可以直接调用存储库将发票添加到数据库中。然而，如果逻辑更复杂，涉及多个实体或聚合，最好使用领域服务来实现逻辑。
- en: DDD focuses on how to build a domain model that reflects the business domain
    and how to maintain the consistency and integrity of the domain model. It is not
    used to produce reports or user interfaces. Reports may need complex queries that
    are not suitable for the domain model. For this case, you may need to use a separate
    reporting database or reporting service. Similarly, the user interface may need
    to display data in a different way than the domain model. However, the domain
    model should remain the same no matter how the data are displayed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: DDD关注的是如何构建一个反映业务领域的领域模型，以及如何维护领域模型的一致性和完整性。它不是用来生成报告或用户界面的。报告可能需要复杂的查询，这些查询不适合领域模型。在这种情况下，你可能需要使用单独的报表数据库或报表服务。同样，用户界面可能需要以不同于领域模型的方式显示数据。然而，无论数据如何显示，领域模型都应该保持不变。
- en: DDD can help you to manage the complexity and build a flexible and maintainable
    software system. But keep in mind that DDD is not a silver bullet. Typically,
    DDD is used for complex business domains. Developers must implement a lot of isolation,
    abstraction, and encapsulation to maintain the model. This may lead to a lot of
    effort and complexity. If your project is simple, DDD may be a bit overkill. In
    this case, a simple layered architecture may be a better choice.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: DDD可以帮助你管理复杂性并构建一个灵活且可维护的软件系统。但请记住，DDD不是万能的。通常，DDD用于复杂的企业领域。开发者必须实现大量的隔离、抽象和封装来维护模型。这可能会导致大量的努力和复杂性。如果你的项目很简单，DDD可能有点过度。在这种情况下，一个简单的分层架构可能是一个更好的选择。
- en: Clean architecture
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清洁架构
- en: 'Clean architecture is a software architecture that was proposed by Robert C.
    Martin (also known as Uncle Bob) in his book *Clean Architecture: A Craftsman’s
    Guide to Software Structure and Design*, published in 2017\. It is a layered architecture
    that focuses on the separation of concerns. Similar to DDD, clean architecture
    is not a specific technology or framework. It is a set of principles and practices
    that can be applied to any software project.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '清洁架构是一种由罗伯特·C·马丁（也称为Uncle Bob）在其2017年出版的书籍《Clean Architecture: A Craftsman’s
    Guide to Software Structure and Design》中提出的软件架构。它是一种关注关注点分离的分层架构。与DDD类似，清洁架构不是一个特定的技术或框架。它是一套可以应用于任何软件项目的原则和实践。'
- en: 'Clean architecture is also called onion architecture because the layers are
    arranged in a circular shape, like an onion. The following diagram shows the typical
    layers of clean architecture:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构也被称为洋葱架构，因为层是以环形排列的，就像洋葱一样。以下图表显示了清洁架构的典型层：
- en: '![Figure 17.2 – Typical layers of clean architecture](img/B18971_17_02.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图17.2 – 清洁架构的典型层](img/B18971_17_02.jpg)'
- en: Figure 17.2 – Typical layers of clean architecture
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2 – 清洁架构的典型层
- en: The preceding diagram illustrates the dependencies flowing from the outer layers
    to the inner layers. At the center of the architecture lies the application core
    layer, which contains the entities and interfaces for business logic. Additionally,
    this layer contains domain services that implement the interfaces. It does not
    depend on any other layers. Surrounding the application core layer is the Infrastructure
    Layer and UI layer, both of which depend on the application core layer. This architecture
    ensures that the application core layer is unaware of how the data are stored
    or presented to the user. In addition, the Infrastructure Layer and UI layer can
    be replaced without impacting the application core layer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表说明了从外层到内层的依赖关系。在架构的中心是应用核心层，它包含业务逻辑的实体和接口。此外，这一层包含实现接口的领域服务。它不依赖于任何其他层。围绕应用核心层的是基础设施层和UI层，它们都依赖于应用核心层。这种架构确保应用核心层不知道数据是如何存储或呈现给用户的。此外，基础设施层和UI层可以被替换，而不会影响应用核心层。
- en: Clean architecture shares some similarities with DDD. Both of them are layered
    architectures that focus on the separation of concerns. They both use dependency
    injection (or inversion of control) to decouple the layers. DDD focuses on the
    domain layer, while clean architecture prioritizes the importance of isolating
    the core business logic from the external dependencies. The separation of concerns
    allows for modifications to external components without affecting the core business
    logic, making it easier to adapt to evolving requirements.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构与领域驱动设计（DDD）有一些相似之处。它们都是关注关注点分离的分层架构。它们都使用依赖注入（或控制反转）来解耦层。DDD关注领域层，而清洁架构优先考虑将核心业务逻辑从外部依赖中隔离的重要性。关注点分离允许在不影响核心业务逻辑的情况下修改外部组件，使其更容易适应不断变化的需求。
- en: DDD and clean architecture complement each other and can be used together. While
    DDD guides how to build a domain model and understand the business domain, clean
    architecture offers a blueprint for organizing and structuring the codebase. Combining
    these approaches can lead to a flexible and maintainable software system.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计（DDD）和清洁架构相互补充，可以一起使用。虽然DDD指导如何构建领域模型和理解业务领域，但清洁架构提供了一个组织和管理代码库的蓝图。结合这些方法可以导致灵活且易于维护的软件系统。
- en: DDD and clean architecture are both layered architectures that focus on a business
    domain. Next, let us discuss the architecture of the entire software system. In
    the next section, we will introduce microservices, which is a popular architecture
    for building scalable and maintainable software systems.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计（DDD）和清洁架构都是关注业务领域的分层架构。接下来，让我们讨论整个软件系统的架构。在下一节中，我们将介绍微服务，这是一种构建可扩展和可维护软件系统的流行架构。
- en: Microservices
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: Many traditional applications are built as a monolith. A monolithic application
    is deployed as a single unit on a single server. The monolithic application is
    easy to develop and deploy. However, as the application grows, it becomes more
    and more difficult to maintain and scale. A small change in the application may
    require the entire application to be rebuilt, retested, and redeployed. Moreover,
    if one part of the application needs to be scaled, the application must be scaled
    as a whole, which is not cost-effective. In addition, if one part of the application
    fails, it may affect the entire application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 许多传统应用程序都是作为单体构建的。单体应用程序作为一个单一单元部署在单个服务器上。单体应用程序易于开发和部署。然而，随着应用程序的增长，维护和扩展变得越来越困难。应用程序中的微小更改可能需要整个应用程序被重建、重新测试和重新部署。此外，如果应用程序的某一部分需要扩展，整个应用程序都必须进行扩展，这并不经济。此外，如果应用程序的某一部分失败，可能会影响整个应用程序。
- en: This is where microservices come in. A microservice is a small, independent
    service that is responsible for a specific business domain. Each microservice
    has its own database and dependencies. It can be developed, deployed, and scaled
    independently. These microservices communicate with each other through programmatic
    interfaces, such as web APIs or message queues.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是微服务发挥作用的地方。微服务是一个小型、独立的负责特定业务领域的服务。每个微服务都有自己的数据库和依赖。它可以独立开发、部署和扩展。这些微服务通过程序接口（如Web
    API或消息队列）相互通信。
- en: 'Microservices provide several benefits:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务提供了几个好处：
- en: '**Single responsibility**: Each microservice is responsible for a specific
    business domain. It has its own dependencies and database.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责**：每个微服务负责特定的业务领域。它有自己的依赖和数据库。'
- en: '**Resilience and fault tolerance**: Microservices are designed to be resilient
    and fault tolerant. If one microservice fails, it does not affect other microservices.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性和容错性**：微服务被设计成具有弹性和容错性。如果一个微服务失败，它不会影响其他微服务。'
- en: '**Scalability**: Microservices can be scaled independently based on demand.
    If one microservice has a high workload, we can increase the number of instances
    of that microservice to handle the workload.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：微服务可以根据需求独立扩展。如果一个微服务有很高的负载，我们可以增加该微服务的实例数量来处理负载。'
- en: '**Technology diversity**: Each microservice can be built using different technologies
    and frameworks as long as they communicate with each other through standard interfaces,
    such as HTTP APIs or gRPC.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术多样性**：只要微服务通过标准接口（如HTTP API或gRPC）相互通信，每个微服务都可以使用不同的技术和框架构建。'
- en: '**CI/CD**: Microservices facilitate CI/CD by allowing individual microservices
    to be built, tested, and deployed independently, minimizing disruption to the
    entire system.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CI/CD**：微服务通过允许独立构建、测试和部署单个微服务，简化了CI/CD流程，从而最小化对整个系统的干扰。'
- en: Microservices is not a new concept; it has been around for decades. However,
    it has become more popular in recent years, especially with the rise in cloud
    computing. Cloud computing provides a scalable and cost-effective infrastructure
    for microservices. In addition, the emergence of container technology, such as
    Docker, makes it easier to build and deploy microservices. By using containers
    and container orchestration tools, such as **Kubernetes**, developers can easily
    build and deploy microservices to the cloud. The orchestration tools can automatically
    scale the microservices based on the workload. This makes it easier to build a
    scalable and cost-effective software system.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务不是一个新概念；它已经存在了几十年。然而，近年来它变得更加流行，尤其是在云计算兴起之后。云计算为微服务提供了可扩展且成本效益高的基础设施。此外，容器技术，如Docker的出现，使得构建和部署微服务变得更加容易。通过使用容器和容器编排工具，如**Kubernetes**，开发者可以轻松地将微服务构建和部署到云端。编排工具可以根据工作负载自动扩展微服务。这使得构建可扩展且成本效益高的软件系统变得更加容易。
- en: Microservices do not have to be exclusive to other architectures. In fact, they
    can be used in conjunction with other architectures to create a more robust and
    efficient system. You can use layers, such as DDD and clean architecture, to build
    each microservice. By leveraging the benefits of both architectures, organizations
    can create a powerful and reliable system that meets their needs. This approach
    can be especially beneficial for organizations that require a high degree of scalability
    and flexibility.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务不必局限于其他架构。实际上，它们可以与其他架构结合使用，以创建更健壮和高效的系统。您可以使用层，如DDD和清洁架构，来构建每个微服务。通过利用两种架构的优点，组织可以创建一个强大且可靠的系统，以满足其需求。这种方法对于需要高度可扩展性和灵活性的组织尤其有益。
- en: 'For example, in an online shopping system, we may have the following microservices:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个在线购物系统中，我们可能会有以下微服务：
- en: '**Product service**: This service is responsible for managing the products,
    such as adding a new product, updating a product, deleting a product, and so on.
    It has its own database to store the product data.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品服务**：这项服务负责管理产品，例如添加新产品、更新产品、删除产品等。它有自己的数据库来存储产品数据。'
- en: '**Order service**: This service is responsible for managing the orders, such
    as creating a new order, updating an order, deleting an order, and so on. It also
    has its own database to store the order data.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订单服务**：这项服务负责管理订单，例如创建新订单、更新订单、删除订单等。它也有自己的数据库来存储订单数据。'
- en: '**Payment service**: This service is responsible for processing payments, such
    as credit card payments, PayPal payments, and so on. It has its own database to
    store the payment data. It may also need to integrate with external payment services,
    such as PayPal, Stripe, online banking services, and so on.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支付服务**：这项服务负责处理支付，例如信用卡支付、PayPal支付等。它有自己的数据库来存储支付数据。它可能还需要与外部支付服务集成，例如PayPal、Stripe、在线银行服务等。'
- en: '**Shipping service**: This service is responsible for shipping the products,
    such as shipping a product to a customer and tracking the shipment. It needs to
    integrate with external shipping services, such as FedEx, UPS, and so on.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物流服务**：这项服务负责运输产品，例如将产品运送给客户并跟踪运输。它需要与外部物流服务集成，例如联邦快递、联合包裹服务公司等。'
- en: '**Notification service**: This service is responsible for sending notifications
    to the customers, such as sending an email or a text message notification, and
    so on. It needs to integrate with external notification services, such as SendGrid,
    Twilio, and so on.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知服务**：这项服务负责向客户发送通知，例如发送电子邮件或短信通知等。它需要与外部通知服务集成，例如SendGrid、Twilio等。'
- en: '**Identity service**: This service is responsible for managing users, such
    as creating a new user, updating a user, deleting a user, and so on. It may provide
    third-party authentication, such as from Microsoft, Google, Facebook, and so on.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份服务**：这项服务负责管理用户，例如创建新用户、更新用户、删除用户等。它可能提供第三方身份验证，例如来自微软、谷歌、Facebook等。'
- en: '**Gateway service**: This service is responsible for routing the requests to
    the appropriate microservices. It is the entry point of the system. It does not
    have its own database. Instead, it routes the requests to the appropriate microservices
    based on the request URL. It can also implement rate-limiting, authentication,
    authorization, and so on.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网关服务**：这项服务负责将请求路由到适当的微服务。它是系统的入口点。它没有自己的数据库。相反，它根据请求URL将请求路由到适当的微服务。它还可以实现速率限制、身份验证、授权等功能。'
- en: '**Client applications**: These are the client applications that consume the
    microservices. They can be web applications, mobile applications, or desktop applications.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端应用程序**：这些是消费微服务的客户端应用程序。它们可以是Web应用程序、移动应用程序或桌面应用程序。'
- en: Each service is responsible for a specific business domain and has its own dependencies.
    Developers can use different technologies and frameworks to build the services
    because they communicate with each other through standard HTTP APIs or gRPC. If
    one service needs to be scaled, it can be scaled independently. For example, if
    the `Order` service has a high workload, we can increase the number of instances
    of the `Order` service to handle the workload. This is much more cost-effective
    than scaling the entire application. Moreover, if one service fails, it does not
    affect other services. For example, if the `Payment` service fails, the `Order`
    service and `Product` service can still work. It can still receive orders and
    allow users to view products. When the `Payment` service is back online, it can
    process the orders that have not been processed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务负责特定的业务领域，并且有自己的依赖关系。开发者可以使用不同的技术和框架来构建服务，因为它们通过标准HTTP API或gRPC进行通信。如果一个服务需要扩展，它可以独立扩展。例如，如果`Order`服务有很高的负载，我们可以增加`Order`服务的实例数量来处理负载。这比扩展整个应用程序要经济得多。此外，如果一个服务失败，它不会影响其他服务。例如，如果`Payment`服务失败，`Order`服务和`Product`服务仍然可以工作。它仍然可以接收订单并允许用户查看产品。当`Payment`服务恢复在线时，它可以处理尚未处理的订单。
- en: 'Microservices have become more and more popular in recent years. However, it
    increases the complexity of the system. Before adopting microservices, you should
    carefully consider whether it is suitable for your project. Consider the following
    challenges to microservices:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务在近年来变得越来越流行。然而，它增加了系统的复杂性。在采用微服务之前，你应该仔细考虑它是否适合你的项目。考虑以下微服务面临的挑战：
- en: '**Distributed system complexity**: Microservices are distributed systems. They
    are more complex than monolithic applications. For example, if one service needs
    to call another service, you need to consider how to handle the communication
    between the services and how to maintain the consistency of the data. In addition,
    you need to handle network failures, partial failures, cascading failures, and
    so on.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式系统复杂性**：微服务是分布式系统。它们比单体应用程序更复杂。例如，如果一个服务需要调用另一个服务，你需要考虑如何处理服务之间的通信以及如何维护数据的一致性。此外，你还需要处理网络故障、部分故障、级联故障等问题。'
- en: '**Data management**: Each microservice has its own database. This makes it
    difficult to maintain data consistency, as transactions that span multiple microservices
    are not supported. To query data from multiple microservices, a distributed query
    mechanism must be implemented, which can be a complex process.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据管理**：每个微服务都有自己的数据库。这使得维护数据一致性变得困难，因为不支持跨越多个微服务的交易。要从多个微服务查询数据，必须实现分布式查询机制，这可能是一个复杂的过程。'
- en: '**Service discovery**: In a microservice architecture, each service has its
    own URL. They need to know the URLs of other services in order to communicate
    with them. This is called service discovery. There are many ways to implement
    service discovery, such as using a service registry, using a service mesh, and
    so on. The container orchestration tools, such as Kubernetes, can also be used
    to implement service discovery, as they can maintain the internal service URLs
    of the microservices.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现**：在微服务架构中，每个服务都有自己的URL。它们需要知道其他服务的URL才能与之通信。这被称为服务发现。有许多方法可以实现服务发现，例如使用服务注册表、使用服务网格等。容器编排工具，如Kubernetes，也可以用于实现服务发现，因为它们可以维护微服务的内部服务URL。'
- en: '**Testing**: Testing a microservice architecture is more complex than testing
    a monolithic application. In addition to unit testing, integration testing, and
    end-to-end testing, you also need to test the communication between the microservices.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：测试微服务架构比测试单体应用程序更复杂。除了单元测试、集成测试和端到端测试之外，你还需要测试微服务之间的通信。'
- en: '**Monitoring**: Monitoring a microservice architecture requires a well-designed
    monitoring system. You need to monitor the health of each microservice, as well
    as the communication between the microservices. The tracing mechanism can be used
    to trace the requests between the microservices.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控**：监控微服务架构需要一个精心设计监控系统。你需要监控每个微服务的健康状况以及微服务之间的通信。跟踪机制可以用来跟踪微服务之间的请求。'
- en: In summary, if your application is simple, do not overcomplicate it by using
    microservices. As your application grows, you can consider refactoring it into
    microservice architecture step by step.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，如果你的应用程序很简单，不要通过使用微服务而使其过于复杂。随着应用程序的增长，你可以考虑逐步将其重构为微服务架构。
- en: Next, let us discuss some common design patterns for web API applications.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论一些 Web API 应用程序的常见设计模式。
- en: Web API design patterns
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web API 设计模式
- en: 'To build a flexible, scalable, and maintainable web API application, leveraging
    well-established design patterns is essential. These patterns address common challenges
    encountered in web API development, providing effective solutions. Microsoft’s
    comprehensive guide offers insights into these design patterns, and you can find
    more details at the following link: [https://learn.microsoft.com/en-us/azure/architecture/patterns/](https://learn.microsoft.com/en-us/azure/architecture/patterns/).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建一个灵活、可扩展且易于维护的 Web API 应用程序，利用成熟的设计模式是至关重要的。这些模式解决了在 Web API 开发中遇到的常见挑战，并提供了有效的解决方案。Microsoft
    的全面指南提供了对这些设计模式的见解，你可以在以下链接中找到更多详细信息：[https://learn.microsoft.com/en-us/azure/architecture/patterns/](https://learn.microsoft.com/en-us/azure/architecture/patterns/)。
- en: 'These design patterns are not exclusive to ASP.NET Core; they can be applied
    to any web API, regardless of the underlying technology or framework. In the following
    sub-sections, we will introduce some key design patterns, outlining the problems
    they solve, their implementation details, and considerations for their usage.
    These patterns cover solution design and implementation, messaging, reliability,
    and so on, including the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设计模式不仅限于 ASP.NET Core；它们可以应用于任何 Web API，无论其底层技术或框架。在接下来的子章节中，我们将介绍一些关键的设计模式，概述它们解决的问题、实现细节以及使用时的考虑因素。这些模式涵盖了解决方案设计和实现、消息传递、可靠性等方面，包括以下内容：
- en: '**Command query responsibility** **segregation** (**CQRS**)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令查询责任** **分离**（**CQRS**）'
- en: '**Publish/subscribe** (**pub/sub**)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布/订阅**（**pub/sub**）'
- en: '**Backend for** **frontend** (**BFF**)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端后端**（**BFF**）'
- en: Timeout
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超时
- en: Rate limiting
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速率限制
- en: Retry
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试
- en: Circuit breaker
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电路断路器
- en: CQRS
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CQRS
- en: CQRS is a powerful tool for addressing the challenge of scaling and optimizing
    read and write operations. By separating the responsibilities for handling commands
    (writes) and queries (reads), CQRS enables each operation to be optimized independently,
    resulting in improved scalability and efficiency.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 是解决扩展和优化读取和写入操作挑战的有力工具。通过分离处理命令（写入）和查询（读取）的责任，CQRS 使每个操作可以独立优化，从而提高了可扩展性和效率。
- en: Traditionally, the data model of an application is designed to support both
    read and write operations. However, the requirements for read and write operations
    are often different. The read operations may execute different queries, resulting
    in different DTO models. The write operations may need to update multiple tables
    in the database. This may lead to a complex data model that is difficult to maintain.
    In addition, the read operations and write operations may have different performance
    requirements.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，应用程序的数据模型被设计为支持读取和写入操作。然而，读取和写入操作的要求往往不同。读取操作可能执行不同的查询，导致不同的 DTO 模型。写入操作可能需要更新数据库中的多个表。这可能导致一个复杂且难以维护的数据模型。此外，读取操作和写入操作可能具有不同的性能要求。
- en: CQRS divides the application’s data model into separate models for reading and
    writing. This enables the use of different storage mechanisms and optimizations
    tailored to the specific needs of each operation. CQRS uses queries to read data
    and commands to update data. Queries do not change the state of the system, while
    commands do.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 将应用程序的数据模型划分为用于读取和写入的独立模型。这允许使用针对每个操作特定需求定制的不同存储机制和优化。CQRS 使用查询来读取数据，使用命令来更新数据。查询不会改变系统的状态，而命令则会。
- en: To better separate the read and write operations, CQRS can also use different
    data stores for reading and writing. For example, the read store can use multiple
    read-only replicas of the write store, which can improve the performance of the
    read operations. The replicas must be kept in sync with the write store, which
    can be done by using built-in database replication features or an event-driven
    mechanism.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地分离读取和写入操作，CQRS 还可以使用不同的数据存储进行读取和写入。例如，读取存储可以使用多个只读副本的写入存储，这可以提高读取操作的性能。副本必须与写入存储保持同步，这可以通过使用内置的数据库复制功能或事件驱动机制来实现。
- en: 'The following diagram shows a typical CQRS architecture:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了典型的 CQRS 架构：
- en: '![Figure 17.3 – Typical CQRS architecture](img/B18971_17_03.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.3 – 典型的 CQRS 架构](img/B18971_17_03.jpg)'
- en: Figure 17.3 – Typical CQRS architecture
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.3 – 典型的 CQRS 架构
- en: To implement CQRS in ASP.NET Core web API applications, you can use the `MediatR`
    library, which is a simple mediator implementation in .NET. This library is a
    simple mediator implementation in .NET that enables the use of the mediator pattern.
    The mediator pattern is a behavioral design pattern that enables objects to interact
    without having to refer to each other explicitly. Instead, they communicate through
    the mediator, which decouples the objects and allows for greater flexibility.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 ASP.NET Core web API 应用程序中实现 CQRS，您可以使用 `MediatR` 库，这是一个 .NET 中的简单中介者实现。这个库是一个简单的中介者实现，它允许使用中介者模式。中介者模式是一种行为设计模式，它允许对象在不显式引用彼此的情况下进行交互。相反，它们通过中介者进行通信，解耦了对象并提供了更大的灵活性。
- en: 'The following diagram shows a typical CQRS architecture using the `MediatR`
    library:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了使用 `MediatR` 库的典型 CQRS 架构：
- en: '![Figure 17.4 – Typical CQRS architecture using the MediatR library](img/B18971_17_04.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.4 – 使用 MediatR 库的典型 CQRS 架构](img/B18971_17_04.jpg)'
- en: Figure 17.4 – Typical CQRS architecture using the MediatR library
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.4 – 使用 MediatR 库的典型 CQRS 架构
- en: In the preceding diagram, the mediator is responsible for receiving the commands
    and queries from the business logic layer and then invoking the corresponding
    handlers to execute the commands and queries. Then, the handlers can use the repositories
    to access the data persistence layer for reading and writing data. The business
    logic layer does not need to know how the mediator invokes the handlers. It only
    needs to send the commands and queries to the mediator. This decouples the business
    logic layer from the data persistence layer. This pattern also makes it easier
    to send commands and queries to multiple handlers. For example, if we have a command
    to send an email notification to the customer and we need to add a text message
    notification, we can simply add a new handler to handle the command without changing
    the client code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，中介者负责从业务逻辑层接收命令和查询，然后调用相应的处理器来执行命令和查询。然后，处理器可以使用存储库来访问数据持久层进行读取和写入数据。业务逻辑层不需要知道中介者如何调用处理器。它只需要将命令和查询发送给中介者。这种模式解耦了业务逻辑层和数据持久层。这种模式也使得向多个处理器发送命令和查询变得更加容易。例如，如果我们有一个向客户发送电子邮件通知的命令，并且需要添加文本消息通知，我们只需简单地添加一个新的处理器来处理该命令，而无需更改客户端代码。
- en: You can find a sample application that demonstrates how to implement CQRS in
    ASP.NET Core web API applications in the `/chapter17/CqrsDemo` folder of the source
    code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在源代码的 `/chapter17/CqrsDemo` 文件夹中找到一个示例应用程序，该应用程序演示了如何在 ASP.NET Core web API
    应用程序中实现 CQRS。
- en: Important note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The sample project has a separate infrastructure project to implement the data
    persistence layer by following clean architecture. When you run the `dotnet ef`
    command to add a migration or update the database, you need to specify the startup
    project. For example, to add a migration, you need to navigate to the `CqrsDemo.Infrastructure`
    project and run the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 示例项目有一个单独的基础设施项目，通过遵循清洁架构来实现数据持久层。当您运行 `dotnet ef` 命令来添加迁移或更新数据库时，您需要指定启动项目。例如，要添加迁移，您需要导航到
    `CqrsDemo.Infrastructure` 项目并运行以下命令：
- en: '**dotnet ef migrations add InitialCreate --****startup-project ../CqrsDemo.WebApi**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**dotnet ef migrations add InitialCreate --****startup-project ../CqrsDemo.WebApi**'
- en: 'To learn more about the `dotnet ef` command, you can refer to the following
    link: [https://learn.microsoft.com/en-us/ef/core/cli/dotnet#target-project-and-startup-project](https://learn.microsoft.com/en-us/ef/core/cli/dotnet#target-project-and-startup-project).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 `dotnet ef` 命令的信息，您可以参考以下链接：[https://learn.microsoft.com/en-us/ef/core/cli/dotnet#target-project-and-startup-project](https://learn.microsoft.com/en-us/ef/core/cli/dotnet#target-project-and-startup-project)。
- en: 'To follow the next steps, you can use the project in the `/chapter17/CqrsDemo/start`
    folder of the source code. This project contains a basic ASP.NET Core web API
    application to manage the invoices. It contains the following projects:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行下一步，您可以使用源代码 `/chapter17/CqrsDemo/start` 文件夹中的项目。此项目包含一个基本的 ASP.NET Core
    Web API 应用程序，用于管理发票。它包含以下项目：
- en: '`CqrsDemo.WebApi`: This is the ASP.NET Core web API project. It contains the
    controllers and application configurations.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CqrsDemo.WebApi`：这是 ASP.NET Core Web API 项目。它包含控制器和应用程序配置。'
- en: '`CqrsDemo.Core`: This is the core project that contains the domain models,
    interfaces of repositories, services, and so on.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CqrsDemo.Core`：这是包含域模型、仓储接口、服务等的核心项目。'
- en: '`CqrsDemo.Infrastructure`: This project contains the implementation of the
    repositories.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CqrsDemo.Infrastructure`：此项目包含仓储的实现。'
- en: Implementing the model mapping
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现模型映射
- en: 'In the core project, note that the service layer uses DTOs, as shown in the
    following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在核心项目中，请注意服务层使用 DTO，如下所示：
- en: '[PRE4]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These methods use different DTO types for reading and writing. To map the entities
    to DTOs and vice versa, we can use `AutoMapper`, which is a popular `object-to-object
    mapper` library. The following code shows how to configure `AutoMapper` in the
    `InvoiceProfile.cs` file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法使用不同的 DTO 类型进行读写。为了将实体映射到 DTO 以及反之亦然，我们可以使用 `AutoMapper`，这是一个流行的 `对象到对象映射器`
    库。以下代码展示了如何在 `InvoiceProfile.cs` 文件中配置 `AutoMapper`：
- en: '[PRE5]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we can register `AutoMapper` in the `Program.cs` file as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在 `Program.cs` 文件中注册 `AutoMapper`，如下所示：
- en: '[PRE6]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To use the mapper, just simply inject the `IMapper` interface into the service
    layer, as shown in the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用映射器，只需将 `IMapper` 接口注入到服务层，如下所示：
- en: '[PRE7]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using `AutoMapper` can save us a lot of time for mapping the entities to DTOs
    and vice versa. Next, we can implement the queries and commands using the `MediatR`
    library.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `AutoMapper` 可以在将实体映射到 DTO 以及反之亦然时节省我们大量时间。接下来，我们可以使用 `MediatR` 库实现查询和命令。
- en: Implementing queries
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现查询
- en: 'Next, we will implement the CQRS pattern using the `MediatR` library. Follow
    these steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `MediatR` 库实现 CQRS 模式。按照以下步骤操作：
- en: 'First, we need to install the `MediatR` NuGet package. Run the following command
    in the terminal window to install the `MediatR` package:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要安装 `MediatR` NuGet 包。在终端窗口中运行以下命令以安装 `MediatR` 包：
- en: '[PRE8]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a `Queries` folder in the `CqrsDemo.Core` project. Then, create a `GetInvoiceByIdQuery.cs`
    file in the `Queries` folder with the following code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CqrsDemo.Core` 项目中创建一个 `Queries` 文件夹。然后，在 `Queries` 文件夹中创建一个 `GetInvoiceByIdQuery.cs`
    文件，并包含以下代码：
- en: '[PRE9]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code defines a `GetInvoiceByIdQuery` class that implements the
    `IRequest<InvoiceDto?>` interface. This interface is used to indicate that this
    is a query that returns an `InvoiceDto` object. The `Id` property is used to specify
    the ID of the invoice to be retrieved.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码定义了一个 `GetInvoiceByIdQuery` 类，该类实现了 `IRequest<InvoiceDto?>` 接口。此接口用于指示这是一个返回
    `InvoiceDto` 对象的查询。`Id` 属性用于指定要检索的发票的 ID。
- en: 'Similarly, create a `GetInvoiceListQuery.cs` file in the `Queries` folder with
    the following code:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，在 `Queries` 文件夹中创建一个 `GetInvoiceListQuery.cs` 文件，并包含以下代码：
- en: '[PRE10]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the `GetInvoiceListQuery` query returns a list of `InvoiceWithoutItemsDto`
    objects. This is because we do not need the invoice items when listing the invoices.
    This is an example to show how to use different DTOs for reading and writing.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`GetInvoiceListQuery`查询返回一个`InvoiceWithoutItemsDto`对象列表。这是因为我们在列出发票时不需要发票项。这是一个示例，展示了如何使用不同的DTO进行读取和写入。
- en: 'Next, create a `Handlers` folder in the `Queries` folder. Then, create a `GetInvoiceByIdQueryHandler.cs`
    file in the `Handlers` folder with the following code:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Queries`文件夹中创建一个`Handlers`文件夹。然后，在`Handlers`文件夹中创建一个`GetInvoiceByIdQueryHandler.cs`文件，并包含以下代码：
- en: '[PRE11]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `GetInvoiceByIdQueryHandler` class implements the `IRequestHandler<GetInvoiceByIdQuery,
    InvoiceDto?>` interface. This interface is used to indicate that this handler
    handles the `GetInvoiceByIdQuery` query and returns an `InvoiceDto` object. The
    `Handle()` method receives the `GetInvoiceByIdQuery` query and invokes the `GetAsync()`
    method of `IInvoiceService` to get the invoice by using the ID.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GetInvoiceByIdQueryHandler`类实现了`IRequestHandler<GetInvoiceByIdQuery, InvoiceDto?>`接口。该接口用于指示此处理程序处理`GetInvoiceByIdQuery`查询并返回一个`InvoiceDto`对象。`Handle()`方法接收`GetInvoiceByIdQuery`查询并调用`IInvoiceService`的`GetAsync()`方法通过ID获取发票。'
- en: The `IInvoiceService` interface can be injected into the handler. Alternatively,
    you may choose to inject the `IInvoiceRepository` interface directly into the
    handler and implement business logic there. Ultimately, it is your decision where
    to store the logic. It is important to keep in mind that the goal is to separate
    business logic from the data persistence layer.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`IInvoiceService`接口可以注入到处理程序中。或者，您可以选择直接将`IInvoiceRepository`接口注入到处理程序中并在那里实现业务逻辑。最终，这是您的决定在哪里存储逻辑。重要的是要记住，目标是分离业务逻辑和数据持久层。'
- en: 'Similarly, create a `GetInvoiceListQueryHandler.cs` file in the `Handlers`
    folder with the following code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在`Handlers`文件夹中创建一个`GetInvoiceListQueryHandler.cs`文件，并包含以下代码：
- en: '[PRE12]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we have two handlers to handle the `GetInvoiceByIdQuery` query and the
    `GetInvoiceListQuery` query. Next, we need to update the controllers to use the
    `MediatR` library.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们有两个处理程序来处理`GetInvoiceByIdQuery`查询和`GetInvoiceListQuery`查询。接下来，我们需要更新控制器以使用`MediatR`库。
- en: 'Update the `InvoicesController.cs` file in the `CqrsDemo.WebApi` project with
    the following code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新`CqrsDemo.WebApi`项目中的`InvoicesController.cs`文件：
- en: '[PRE13]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code injects the `ISender()` interface into the controller. You
    can also inject the `IMediator` interface instead. In this example, we will use
    the `ISender` interface to send the requests to the handlers.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码将`ISender()`接口注入到控制器中。您也可以注入`IMediator`接口。在这个例子中，我们将使用`ISender`接口向处理程序发送请求。
- en: 'Update the `GetInvoice()` method of the `InvoicesController` class with the
    following code:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新`InvoicesController`类的`GetInvoice()`方法：
- en: '[PRE14]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code creates a `GetInvoiceByIdQuery` object that contains the
    `id` parameter. The `ISender` interface will invoke the `GetInvoiceByIdQueryHandler`
    handler to handle the query. Then, the handler will invoke the `GetAsync` method
    of the `IInvoiceService` to get the invoice via the ID. So, the controller is
    decoupled from the service layer.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码创建了一个包含`id`参数的`GetInvoiceByIdQuery`对象。`ISender`接口将调用`GetInvoiceByIdQueryHandler`处理程序来处理查询。然后，处理程序将调用`IInvoiceService`的`GetAsync`方法通过ID获取发票。因此，控制器与服务层解耦。
- en: 'Similarly, update the `GetInvoices` method of the `InvoicesController` class
    with the following code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，使用以下代码更新`InvoicesController`类的`GetInvoices`方法：
- en: '[PRE15]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code creates a `GetInvoiceListQuery` object that contains the
    `pageIndex` and `pageSize` parameters. The `ISender` interface will invoke the
    `GetInvoiceListQueryHandler` handler to handle the query. Then, the handler will
    invoke the `GetPagedListAsync()` method of the `IInvoiceService` to get the list
    of invoices.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码创建了一个包含`pageIndex`和`pageSize`参数的`GetInvoiceListQuery`对象。`ISender`接口将调用`GetInvoiceListQueryHandler`处理程序来处理查询。然后，处理程序将调用`IInvoiceService`的`GetPagedListAsync()`方法来获取发票列表。
- en: 'Next, we need to register the `MediatR` in the `Program.cs` file as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`Program.cs`文件中按照以下方式注册`MediatR`：
- en: '[PRE16]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code registers all three `MediatR` interfaces and the handlers
    in the `CqrsDemo.Core` project.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码在`CqrsDemo.Core`项目中注册了所有三个`MediatR`接口和处理程序。
- en: Now, we use the queries to implement the read operations. You can run the application
    and test the endpoints, such as `/api/invoices/{id}` and `/api/invoices/paged`.
    These endpoints should work as before.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用查询来实现读操作。您可以运行应用程序并测试端点，例如 `/api/invoices/{id}` 和 `/api/invoices/paged`。这些端点应该像以前一样工作。
- en: Implementing commands
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现命令
- en: 'Next, we will implement the write operations using commands. Follow these steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用命令来实现写操作。按照以下步骤进行：
- en: 'Create a `Commands` folder in the `CqrsDemo.Core` project. Then, create a `CreateInvoiceCommand.cs`
    file in the `Commands` folder with the following code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CqrsDemo.Core` 项目中创建一个 `Commands` 文件夹。然后，在 `Commands` 文件夹中创建一个 `CreateInvoiceCommand.cs`
    文件，并使用以下代码：
- en: '[PRE17]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code defines a `CreateInvoiceCommand` class that implements the
    `IRequest<InvoiceDto>` interface.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码定义了一个实现 `IRequest<InvoiceDto>` 接口的 `CreateInvoiceCommand` 类。
- en: 'Create a `Handlers` folder in the `Commands` folder. Then, create a `CreateInvoiceCommandHandler.cs`
    file in the `Handlers` folder with the following code:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Commands` 文件夹中创建一个 `Handlers` 文件夹。然后，在 `Handlers` 文件夹中创建一个 `CreateInvoiceCommandHandler.cs`
    文件，并使用以下代码：
- en: '[PRE18]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Update the `InvoicesController` class with the following code:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新 `InvoicesController` 类：
- en: '[PRE19]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, run the application and send a `POST` request to the `/api/invoices` endpoint.
    You should be able to create a new invoice.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，运行应用程序并向 `/api/invoices` 端点发送 `POST` 请求。您应该能够创建一个新的发票。
- en: We will not implement all the commands and queries in this example. You can
    work on the remaining commands and queries as an exercise.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将不会实现所有命令和查询。您可以作为一个练习来处理剩余的命令和查询。
- en: '`MediatR` makes it easy to implement the CQRS pattern in ASP.NET Core web API
    applications. However, it is not the only way to implement CQRS. You can also
    implement CQRS without using the `MediatR` library.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediatR` 使得在 ASP.NET Core Web API 应用程序中实现 CQRS 模式变得容易。然而，实现 CQRS 的方法不止一种。您也可以在不使用
    `MediatR` 库的情况下实现 CQRS。'
- en: 'One benefit of using the `MediatR` library is that it can send requests to
    multiple handlers. For example, we can create a command to send an email notification
    and a text message notification to the customer. Then, we can create two handlers
    to handle the command. Follow these steps to implement this feature:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `MediatR` 库的一个好处是它可以向多个处理器发送请求。例如，我们可以创建一个命令来向客户发送电子邮件通知和短信通知。然后，我们可以创建两个处理器来处理该命令。按照以下步骤实现此功能：
- en: 'Add the two properties to the invoice models, as shown in the following:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，将两个属性添加到发票模型中：
- en: '[PRE20]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You need to update the `Invoice` class, `CreateOrUpdateInvoiceDto` class, `InvoiceWithoutItemsDto`
    class, and `InvoiceDto` class. You can also define a `Contact` class for better
    encapsulation.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您需要更新 `Invoice` 类、`CreateOrUpdateInvoiceDto` 类、`InvoiceWithoutItemsDto` 类和 `InvoiceDto`
    类。您还可以定义一个 `Contact` 类以实现更好的封装。
- en: 'Add the database migration and update the database. You may also need to update
    the seed data. Note that you need to specify the startup project when running
    the `dotnet ef` command. For example, to add a migration, you need to navigate
    to the `CqrsDemo.Infrastructure` project and run the following command:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加数据库迁移并更新数据库。您可能还需要更新种子数据。请注意，在运行 `dotnet ef` 命令时需要指定启动项目。例如，要添加迁移，您需要导航到 `CqrsDemo.Infrastructure`
    项目并运行以下命令：
- en: '[PRE21]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, update the database:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新数据库：
- en: '[PRE22]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a `Notification` folder in the `CqrsDemo.Core` project. Then, create
    a `SendInvoiceNotification` class in the `Notification` folder with the following
    code:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CqrsDemo.Core` 项目中创建一个 `Notification` 文件夹。然后，在 `Notification` 文件夹中创建一个 `SendInvoiceNotification`
    类，并使用以下代码：
- en: '[PRE23]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code defines a `SendInvoiceNotification` class that implements
    the `INotification` interface. This interface is used to indicate that this is
    a notification that does not return any result.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码定义了一个实现 `INotification` 接口的 `SendInvoiceNotification` 类。此接口用于指示这是一个不返回任何结果的通知。
- en: 'Create a `Handlers` folder in the `Notification` folder. Then, create a `SendInvoiceEmailNotificationHandler`
    class in the `Handlers` folder with the following code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Notification` 文件夹中创建一个 `Handlers` 文件夹。然后，在 `Handlers` 文件夹中创建一个 `SendInvoiceEmailNotificationHandler`
    类，并使用以下代码：
- en: '[PRE24]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, we use `IInvocieService` to obtain the invoice via the
    ID. Then, we check if the invoice exists and if the contact email is specified.
    If so, we send an email notification to the customer. For simplicity, we just
    print a message to the console.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `IInvocieService` 通过 ID 获取发票。然后，我们检查发票是否存在以及是否指定了联系邮箱。如果是这样，我们将向客户发送电子邮件通知。为了简单起见，我们只是在控制台打印一条消息。
- en: 'Similarly, create a `SendInvoiceTextMessageNotificationHandler` class in the
    `Handlers` folder with the following code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，在`Handlers`文件夹中创建一个名为`SendInvoiceTextMessageNotificationHandler`的类，代码如下：
- en: '[PRE25]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding code is similar to the previous handler. It sends a text message
    notification to the customer.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码与之前的处理器类似。它向客户发送短信通知。
- en: 'Inject the `IPublisher` interface into the `InvoicesController` class, as shown
    in the following:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`IPublisher`接口注入到`InvoicesController`类中，如下所示：
- en: '[PRE26]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `IPublisher` interface is used to publish a notification or event through
    the mediator pipeline to be handled by multiple handlers.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`IPublisher`接口用于通过中介管道发布通知或事件，以便由多个处理器处理。'
- en: 'Update the `CreateInvoice` method in the `InvoicesController` class with the
    following code:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`InvoicesController`类中更新`CreateInvoice`方法，代码如下：
- en: '[PRE27]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, when creating a new invoice, we send a `SendInvoiceNotification`
    notification to the `IPublisher` interface. The `IPublisher` interface will invoke
    the `SendInvoiceEmailNotificationHandler` handler and the `SendInvoiceTextMessageNotificationHandler`
    handler to handle the notification. Then, they will send the email notification
    and text message notification to the customer. If we need more notifications,
    we can simply add more handlers to handle the notification without changing the
    controller code.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，当创建一个新的发票时，我们向`IPublisher`接口发送一个`SendInvoiceNotification`通知。`IPublisher`接口将调用`SendInvoiceEmailNotificationHandler`处理器和`SendInvoiceTextMessageNotificationHandler`处理器来处理通知。然后，它们将发送电子邮件通知和短信通知给客户。如果我们需要更多的通知，我们只需简单地添加更多的处理器来处理通知，而无需更改控制器代码。
- en: Run the application and send a `POST` request to the `/api/invoices` endpoint
    to create a new invoice. You should be able to see the console messages for the
    email notification and text message notifications.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行应用程序，并向`/api/invoices`端点发送一个`POST`请求以创建一个新的发票。你应该能够看到控制台中的电子邮件通知和短信通知消息。
- en: 'This is just a simple example to demonstrate how to use the `MediatR` library
    to implement the CQRS pattern. CQRS and `MediatR` allow us to separate the read
    and write concerns and decouple the business logic layer from the data persistence
    layer. You can also try to use different databases for reading and writing or
    even for different projects. However, note that using different databases may
    lead to data consistency issues. You can use the event-sourcing pattern with the
    CQRS pattern to maintain data consistency and full audit trails. We will not cover
    the event-sourcing pattern in this book. You can find more details about the event-sourcing
    pattern at the following link: [https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing](https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的示例，用于展示如何使用`MediatR`库来实现CQRS模式。CQRS和`MediatR`允许我们分离读取和写入关注点，并将业务逻辑层与数据持久化层解耦。你也可以尝试为读取和写入使用不同的数据库，甚至为不同的项目使用不同的数据库。然而，请注意，使用不同的数据库可能会导致数据一致性问题的出现。你可以使用CQRS模式与事件源模式结合来维护数据一致性和完整的审计跟踪。我们不会在本书中介绍事件源模式。你可以在以下链接中找到有关事件源模式的更多详细信息：[https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing](https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing)。
- en: 'Next, we will introduce a popular pattern for asynchronous communication between
    microservices: the pub/sub pattern.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍一个用于微服务之间异步通信的流行模式：pub/sub模式。
- en: Pub/sub
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pub/sub
- en: In a microservice architecture, the microservices communicate with each other
    through standard interfaces, such as HTTP APIs or gRPC. Sometimes, a microservice
    may need to communicate with other services in an asynchronous way. It may also
    need to broadcast an event to multiple services. The pub/sub pattern can be used
    to address the need for loosely coupled communication between microservices. It
    facilitates broadcasting events or messages to multiple subscribers without them
    being directly aware of each other.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，微服务通过标准接口，如HTTP API或gRPC，相互通信。有时，一个微服务可能需要以异步方式与其他服务通信。它可能还需要向多个服务广播一个事件。pub/sub模式可以用来解决微服务之间松散耦合通信的需求。它便于向多个订阅者广播事件或消息，而无需它们直接相互了解。
- en: 'The pub/sub pattern is a communication model that facilitates the exchange
    of messages between publishers and subscribers without requiring them to be aware
    of each other. It consists of three components: publishers, subscribers, and a
    message broker. Publishers are responsible for publishing events or messages to
    the message broker, which then distributes them to subscribers. Subscribers, in
    turn, subscribe to the message broker and receive the events or messages that
    have been published. This pattern allows for asynchronous communication between
    publishers and subscribers, enabling them to remain independent of each other.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 发布/订阅模式是一种通信模型，它促进了发布者和订阅者之间消息交换，而不需要他们相互了解。它由三个组件组成：发布者、订阅者和消息代理。发布者负责将事件或消息发布到消息代理，然后消息代理将它们分发到订阅者。反过来，订阅者订阅消息代理，接收已发布的事件或消息。这种模式允许发布者和订阅者之间进行异步通信，使他们能够保持相互独立。
- en: 'Many message brokers can be used to implement the pub/sub pattern. Some popular
    message brokers include the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 许多消息代理都可以用于实现发布/订阅模式。以下是一些流行的消息代理：
- en: '**RabbitMQ**: RabbitMQ is an open-source, cross-platform message broker that
    is widely used in microservice architectures. It is lightweight and easy to deploy
    on-premises and in the cloud. For more details, refer to the following link: [https://rabbitmq.com/](https://rabbitmq.com/).'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RabbitMQ**：RabbitMQ是一个开源的、跨平台的消息代理，在微服务架构中广泛使用。它轻量级且易于在本地和云中部署。更多详情，请参阅以下链接：[https://rabbitmq.com/](https://rabbitmq.com/)。'
- en: '**Redis**: Redis is an open-source in-memory data structure store. It is versatile
    and has high performance. Redis is a popular choice for various use cases, such
    as key-value databases, caches, and message brokers. We learned how to use Redis
    as a cache in [*Chapter 15*](B18971_15.xhtml#_idTextAnchor632). It can also be
    used as a message broker to implement the pub/sub pattern. For more details, refer
    to the following link: [https://redis.io/](https://redis.io/).'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Redis**：Redis是一个开源的内存数据结构存储。它功能多样且性能高。Redis是各种用例的流行选择，如键值数据库、缓存和消息代理。我们在[*第15章*](B18971_15.xhtml#_idTextAnchor632)中学习了如何将Redis用作缓存。它也可以用作消息代理以实现发布/订阅模式。更多详情，请参阅以下链接：[https://redis.io/](https://redis.io/)。'
- en: '**Apache Kafka**: Apache Kafka is an open-source, distributed event-streaming
    platform. It is a reliable and scalable message broker that can be used to implement
    the pub/sub pattern. It ensures the durable and reliable storage of event streams
    in a scalable, fault-tolerant, and secure manner. You can manage it yourself or
    use a managed service provided by a variety of cloud providers. For more details,
    refer to the following link: [https://kafka.apache.org/](https://kafka.apache.org/).'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache Kafka**：Apache Kafka是一个开源的、分布式的流事件平台。它是一个可靠且可扩展的消息代理，可用于实现发布/订阅模式。它确保以可扩展、容错和安全的
    manner 存储事件流。您可以自行管理，也可以使用各种云提供商提供的托管服务。更多详情，请参阅以下链接：[https://kafka.apache.org/](https://kafka.apache.org/)。'
- en: '**Azure Service Bus**: Azure Service Bus is a fully managed enterprise message
    broker provided by Microsoft Azure. It supports message queues and topics. For
    more details, refer to the following link: [https://learn.microsoft.com/en-us/azure/service-bus-messaging/](https://learn.microsoft.com/en-us/azure/service-bus-messaging/).'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Service Bus**：Azure Service Bus是Microsoft Azure提供的一个完全托管的面向企业的消息代理。它支持消息队列和主题。更多详情，请参阅以下链接：[https://learn.microsoft.com/en-us/azure/service-bus-messaging/](https://learn.microsoft.com/en-us/azure/service-bus-messaging/)。'
- en: 'The pub/sub pattern decouples the microservices from each other. It also improves
    the scalability and reliability. All the messages or events are handled in an
    asynchronous way. This helps the service continue to function even if the workload
    increases or one of the services fails. However, it also increases the complexity
    of the system. You need to manage the message ordering, message priority, message
    duplication, message expiration, dead-letter queues, and so on. To learn more
    about the pub/sub pattern, you can refer to the following link: [https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber](https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 发布/订阅模式将微服务彼此解耦。它还提高了可伸缩性和可靠性。所有消息或事件都以异步方式处理。这有助于服务在负载增加或某个服务失败的情况下继续运行。然而，这也增加了系统的复杂性。您需要管理消息排序、消息优先级、消息重复、消息过期、死信队列等。要了解更多关于发布/订阅模式的信息，您可以参考以下链接：[https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber](https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber)。
- en: Backends for frontends
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前端后端
- en: '**Backends for frontends** (**BFFs**) address the challenge of efficiently
    serving diverse client interfaces with distinct requirements. This is useful when
    applications need to serve multiple client types, such as web, mobile, and desktop.
    Each client type may need a different data format. In this case, a monolithic
    backend may struggle to cater to the unique needs of each client. Specifically,
    if the backend includes multiple microservices, each microservice may need to
    provide multiple endpoints to serve different client types. This can lead to a
    complex and inefficient system.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**前端后端**（**BFFs**）解决了高效服务于具有不同要求的多样化客户端接口的挑战。当应用程序需要为多种客户端类型提供服务，如Web、移动和桌面时，这非常有用。每种客户端类型可能需要不同的数据格式。在这种情况下，单体后端可能难以满足每个客户端的独特需求。具体来说，如果后端包含多个微服务，每个微服务可能需要提供多个端点来服务于不同的客户端类型。这可能导致一个复杂且低效的系统。'
- en: BFF architecture is a useful solution for applications that need to serve multiple
    client types, such as web, mobile, and desktop. Each client type may have distinct
    requirements for a data format, which can be difficult to manage with a monolithic
    backend. If the backend includes multiple microservices, each microservice may
    need to provide multiple endpoints to serve different client types, resulting
    in a complex and inefficient system. BFFs can help address this challenge by efficiently
    serving diverse client interfaces with distinct requirements.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: BFF架构是针对需要为多种客户端类型提供服务（如Web、移动和桌面）的应用程序的有用解决方案。每种客户端类型可能对数据格式有独特的要求，这在使用单体后端时可能难以管理。如果后端包含多个微服务，每个微服务可能需要提供多个端点来服务于不同的客户端类型，从而导致一个复杂且低效的系统。BFF可以通过高效地为具有不同要求的多样化客户端接口提供服务来帮助解决这一挑战。
- en: BFF introduces dedicated backend services tailored for specific frontend clients.
    Each frontend client has its corresponding backend, enabling fine-grained control
    over data retrieval, processing, and presentation. This allows for a more efficient
    and flexible system that can better meet the needs of each client.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: BFF引入了针对特定前端客户端定制的专用后端服务。每个前端客户端都有其对应的后端，这允许对数据检索、处理和展示进行细粒度控制。这使系统更加高效和灵活，能够更好地满足每个客户端的需求。
- en: 'The following diagram shows a typical BFF architecture:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了典型的BFF架构：
- en: '![Figure 17.5 – Typical BFF architecture](img/B18971_17_05.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图17.5 – 典型的BFF架构](img/B18971_17_05.jpg)'
- en: Figure 17.5 – Typical BFF architecture
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.5 – 典型的BFF架构
- en: In *Figure 17**.5*, each BFF service is responsible for a specific frontend
    client. It can retrieve data from multiple microservices and combine the data
    into a single response. Each BFF service is fine-tuned to meet the specific needs
    of the frontend client. It also illustrates how each BFF service is responsible
    for a particular frontend client. Each BFF service is tailored to meet the specific
    requirements of the frontend client. It can retrieve data from multiple microservices
    and combine them into a single response.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图17*.*5*中，每个BFF服务负责特定的前端客户端。它可以从多个微服务中检索数据并将数据合并成一个响应。每个BFF服务都经过微调以满足前端客户端的具体需求。它还说明了每个BFF服务如何负责特定的前端客户端。每个BFF服务都针对前端客户端的具体要求进行定制。它可以从多个微服务中检索数据并将它们合并成一个响应。
- en: BFFs should be lightweight. They can contain client-specific logic but should
    not contain business logic. The main purpose of BFFs is to tailor the data for
    each frontend client. However, this may lead to code duplication. If the data
    format is similar for multiple frontend clients, BFFs may not be required.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: BFFs应该是轻量级的。它们可以包含客户端特定的逻辑，但不应该包含业务逻辑。BFFs的主要目的是为每个前端客户端定制数据。然而，这可能会导致代码重复。如果多个前端客户端的数据格式相似，可能不需要BFFs。
- en: Resilience patterns
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弹性模式
- en: In a microservice architecture, resilience and reliability are essential for
    a successful system. web APIs are often subject to unpredictable environments,
    such as network latency, transient failures, service unavailability, high traffic,
    and so on. To ensure that these APIs are resilient and reliable, several patterns
    can be implemented. These include retry, rate-limiting, time out, circuit breaker,
    and so on. In this section, we will discuss how to use the `Polly` library to
    implement these patterns in ASP.NET Core web API applications.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，弹性和可靠性对于成功系统至关重要。Web API经常面临不可预测的环境，如网络延迟、瞬态故障、服务不可用、高流量等。为了确保这些API具有弹性和可靠性，可以实施几种模式。这些包括重试、速率限制、超时、断路器等。在本节中，我们将讨论如何在ASP.NET
    Core Web API应用程序中使用`Polly`库来实现这些模式。
- en: 'You can find a sample project in the `/chapter17/PollyDemo` folder. This project
    contains two basic ASP.NET Core web API applications:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`/chapter17/PollyDemo`文件夹中找到一个示例项目。该项目包含两个基本的ASP.NET Core Web API应用程序：
- en: '`PollyServerWebApi`, which behaves as a server'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PollyServerWebApi`，它作为一个服务器'
- en: '`PollyClientWebApi`, which is also a web API application but also behaves as
    a client'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PollyClientWebApi`，它也是一个Web API应用程序，但同时也作为客户端'
- en: 'We will use these two applications to demonstrate how to use the `Polly` library
    to implement the rate-limiting, retry, timeout, and circuit breaker. `Polly` is
    a popular .NET resilience and transient-fault-handling library. You can find more
    details about `Polly` at the following link: [https://www.thepollyproject.org/](https://www.thepollyproject.org/).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这两个应用程序来演示如何使用`Polly`库来实现速率限制、重试、超时和断路器。`Polly`是一个流行的.NET弹性库和瞬态故障处理库。你可以在以下链接中找到更多关于`Polly`的详细信息：[https://www.thepollyproject.org/](https://www.thepollyproject.org/)。
- en: 'To use `Polly` in ASP.NET Core web API applications, you need to install the
    `Polly` NuGet package. Navigate to the `PollyClientWebApi` project and run the
    following command in the terminal window to install the `Polly` package:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要在ASP.NET Core Web API应用程序中使用`Polly`，你需要安装`Polly` NuGet包。导航到`PollyClientWebApi`项目，并在终端窗口中运行以下命令来安装`Polly`包：
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`Polly` provides a resilience pipeline builder to build a resilience pipeline.
    A resilience pipeline runs a series of resilience policies. Each policy is responsible
    for handling a specific type of issue. The following code shows how to create
    a resilience pipeline builder:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`Polly`提供了一个弹性管道构建器来构建弹性管道。弹性管道运行一系列弹性策略。每个策略负责处理特定类型的问题。以下代码展示了如何创建弹性管道构建器：'
- en: '[PRE29]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, we will explore several resilience policies provided by `Polly`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索`Polly`提供的几个弹性策略。
- en: Timeout
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 超时
- en: The **timeout** pattern is a common pattern used to handle slow or unresponsive
    services. When a service is slow or unresponsive, the client may wait for an extended
    period before receiving a response. To avoid this, a timeout can be set for the
    service. If the service cannot respond within the given time frame, the client
    can return an error to the user, thus preventing them from waiting unnecessarily.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**超时**模式是一种常见的模式，用于处理缓慢或无响应的服务。当一个服务缓慢或无响应时，客户端可能会等待很长时间才收到响应。为了避免这种情况，可以为服务设置超时。如果服务在给定的时间框架内无法响应，客户端可以向用户返回错误，从而避免他们不必要的等待。'
- en: In [*Chapter 4*](B18971_04.xhtml#_idTextAnchor170), we introduced a `RequestTimeout`
    middleware to set the timeout for the ASP.NET Core web API application. The `RequestTimeout`
    middleware is applied to the endpoints or actions that need to be timed out. Sometimes,
    we may need to set the timeout for a specific method call, such as calling a REST
    API or querying a database. Let us explore other ways to set the timeout.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B18971_04.xhtml#_idTextAnchor170)中，我们介绍了一个`RequestTimeout`中间件来设置ASP.NET
    Core Web API应用程序的超时。`RequestTimeout`中间件应用于需要超时的端点或操作。有时，我们可能需要为特定的方法调用设置超时，例如调用REST
    API或查询数据库。让我们探索其他设置超时的方法。
- en: 'The `HttpClient` class in .NET Core provides a timeout feature. You can set
    the timeout for the `HttpClient` object by setting the `Timeout` property. The
    following code shows how to set the timeout for the `HttpClient` object:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 中的 `HttpClient` 类提供了超时功能。您可以通过设置 `Timeout` 属性来为 `HttpClient` 对象设置超时。以下代码展示了如何为
    `HttpClient` 对象设置超时：
- en: '[PRE30]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code creates an `HttpClient` object and sets the timeout to 10
    seconds. If the service does not respond within 10 seconds, the `HttpClient` object
    will throw an exception. You can catch the exception and return an error to the
    user.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个 `HttpClient` 对象并将超时设置为 10 秒。如果服务在 10 秒内没有响应，`HttpClient` 对象将抛出异常。您可以捕获这个异常并向用户返回错误。
- en: 'Setting the timeout for the `HttpClient` object is useful for simple tasks,
    such as calling a REST API. However, it is not suitable for more complex tasks
    that do not use `HttpClient`, such as a database query. For other tasks, such
    as a database query, you can use the `CancellationToken` to set the timeout. The
    following code shows how to set the timeout for a database query:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `HttpClient` 对象设置超时对于简单任务很有用，例如调用 REST API。但是，它不适用于不使用 `HttpClient` 的更复杂任务，例如数据库查询。对于其他任务，例如数据库查询，您可以使用
    `CancellationToken` 来设置超时。以下代码展示了如何为数据库查询设置超时：
- en: '[PRE31]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code creates a `CancellationTokenSource` object and sets the timeout
    to 10 seconds. If the database query is not complete within 10 seconds, the `GetAsync()`
    method will throw an exception. This prevents the client from waiting for an extended
    period before receiving a response.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个 `CancellationTokenSource` 对象并将超时设置为 10 秒。如果数据库查询在 10 秒内未完成，`GetAsync()`
    方法将抛出异常。这防止了客户端在收到响应之前长时间等待。
- en: Sometimes, there may be multiple services that need to be called. Moreover,
    setting the timeout for each service call may be tedious. To simplify this, we
    can use the `Polly` library to implement the timeout policy.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，可能需要调用多个服务。此外，为每个服务调用设置超时可能很繁琐。为了简化这个过程，我们可以使用 `Polly` 库来实现超时策略。
- en: '`Polly` provides a timeout policy that can be used to set the timeout for a
    service. Follow these steps to implement the timeout policy:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`Polly` 提供了一个超时策略，可用于设置服务超时。按照以下步骤实现超时策略：'
- en: 'Create an endpoint in the `PollyServerWebApi` application to simulate a slow
    service. Open the `Program.cs` file and add the following code:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PollyServerWebApi` 应用程序中创建一个端点以模拟慢速服务。打开 `Program.cs` 文件并添加以下代码：
- en: '[PRE32]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code defines a minimal API endpoint that simulates a slow service.
    It generates a random delay between 1 and 20 seconds. This endpoint will return
    a response after the delay. This is just an example of simulating a slow service.
    In a real-world application, the service may be slow due to network latency, high
    traffic, and so on.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码定义了一个最小的 API 端点，用于模拟慢速服务。它生成 1 到 20 秒之间的随机延迟。此端点将在延迟后返回响应。这只是一个模拟慢速服务的示例。在实际应用中，服务可能由于网络延迟、高流量等原因而变慢。
- en: 'Create a controller in the `PollyClientWebApi` application to call the slow
    service. Add a `PollyController` class in the `Controllers` folder with the following
    code:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PollyClientWebApi` 应用程序中创建一个控制器以调用慢速服务。在 `Controllers` 文件夹中添加一个 `PollyController`
    类，代码如下：
- en: '[PRE33]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This controller uses the `IHttpClientFactory` to create an `HttpClient` object.
    Then, it calls the slow service and returns the response to the client.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此控制器使用 `IHttpClientFactory` 创建 `HttpClient` 对象。然后，它调用慢速服务并将响应返回给客户端。
- en: Run the two applications and send a request to the `/api/polly/slow-response`
    endpoint of the `PollyClientWebApi` application. You should be able to see the
    response after a random delay between 1 and 20 seconds.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行这两个应用程序并向 `PollyClientWebApi` 应用程序的 `/api/polly/slow-response` 端点发送请求。您应该在
    1 到 20 秒的随机延迟后看到响应。
- en: 'Next, we will implement the timeout policy using `Polly`. For example, we can
    set the timeout to 5 seconds, which means if the service does not respond within
    5 seconds, the client will return an error to the user instead of waiting for
    a long time. Update the `GetSlowResponse()` method of the `PollyController` class
    as follows:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `Polly` 实现超时策略。例如，我们可以将超时设置为 5 秒，这意味着如果服务在 5 秒内没有响应，客户端将返回错误给用户而不是长时间等待。更新
    `PollyController` 类的 `GetSlowResponse()` 方法如下：
- en: '[PRE34]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding code uses `Polly` to create a `ResiliencePipelineBuilder` object.
    Then, it adds a timeout policy with a timeout of 5 seconds. The `ExecuteAsync()`
    method is used to execute the pipeline. If the service does not respond within
    5 seconds, the `ExecuteAsync()` method will throw an exception. The `catch` block
    is used to catch the exception and return an error to the user.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码使用 `Polly` 创建一个 `ResiliencePipelineBuilder` 对象。然后，它添加了一个5秒的超时策略。`ExecuteAsync()`
    方法用于执行管道。如果服务在5秒内没有响应，`ExecuteAsync()` 方法将抛出异常。`catch` 块用于捕获异常并向用户返回错误。
- en: Note that in the `ExecuteAsync()` method, the cancellation token is passed to
    the `GetAsync()` method of the `HttpClient` object. If it does not, the `HttpClient`
    will continue to wait even if the timeout occurs. It is important to respect the
    cancellation token from the `Polly` resilience pipeline.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在 `ExecuteAsync()` 方法中，将取消令牌传递给 `HttpClient` 对象的 `GetAsync()` 方法。如果不这样做，即使发生超时，`HttpClient`
    也会继续等待。尊重来自 `Polly` 弹性管道的取消令牌非常重要。
- en: Run the two applications and send a request to the `/api/polly/slow-response`
    endpoint of the `PollyClientWebApi` application. You should be able to see the
    error message after 5 seconds.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行两个应用程序并向 `PollyClientWebApi` 应用程序的 `/api/polly/slow-response` 端点发送请求。你应该能在5秒后看到错误信息。
- en: 'In the preceding example, we defined the timeout policy in the controller.
    To reuse the timeout policy, we can define a global timeout policy in the `Program.cs`
    file and then use dependency injection to inject the policy into the controller.
    Follow these steps to implement the global timeout policy:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们在控制器中定义了超时策略。为了重用超时策略，我们可以在 `Program.cs` 文件中定义一个全局超时策略，然后使用依赖注入将策略注入到控制器中。按照以下步骤实现全局超时策略：
- en: 'Install the `Polly.Extensions` NuGet package. Navigate to the `PollyClientWebApi`
    project and run the following command in the terminal window to install the `Polly.Extensions`
    package:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `Polly.Extensions` NuGet 包。导航到 `PollyClientWebApi` 项目，并在终端窗口中运行以下命令以安装 `Polly.Extensions`
    包：
- en: '[PRE35]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: builder.Services.AddResiliencePipeline("timeout-5s-pipeline", configure =>{    configure.AddTimeout(TimeSpan.FromSeconds(5));});
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: builder.Services.AddResiliencePipeline("timeout-5s-pipeline", configure =>{    configure.AddTimeout(TimeSpan.FromSeconds(5));});
- en: '[PRE36]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Inject the `ResiliencePipelineProvider<string>` class into the `PollyController`
    class, as shown in the following:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ResiliencePipelineProvider<string>` 类注入到 `PollyController` 类中，如下所示：
- en: '[PRE37]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `ResiliencePipelineProvider<string>` class is used to retrieve the global
    timeout policy. The `string` type parameter specifies the type of the policy name.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ResiliencePipelineProvider<string>` 类用于检索全局超时策略。`string` 类型参数指定了策略名称的类型。'
- en: 'Update the `GetSlowResponse()` method of the `PollyController` class as follows:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `PollyController` 类的 `GetSlowResponse()` 方法如下：
- en: '[PRE38]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this way, we can reuse the global timeout policy by its name.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样，我们可以通过名称重用全局超时策略。
- en: '`Polly` supports many other resilience patterns. Next, let us discuss rate-limiting.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`Polly` 支持许多其他弹性模式。接下来，让我们讨论速率限制。'
- en: Rate-limiting
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 速率限制
- en: The **rate-limiting** pattern is a common pattern used to limit the number of
    requests that can be made to a service. The rate should be set to a reasonable
    value to avoid overloading the service. You can run a performance test to determine
    the optimal rate limit. The performance of the service depends on many factors,
    such as the hardware, network, and the complexity of business logic. Once you
    have determined the optimal rate limit, you can apply it to the service to ensure
    that it can handle the workload.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**速率限制**模式是一种常用的模式，用于限制可以发送到服务的请求数量。速率应设置为合理的值，以避免过载服务。你可以运行性能测试来确定最佳速率限制。服务的性能取决于许多因素，例如硬件、网络和业务逻辑的复杂性。一旦确定了最佳速率限制，就可以将其应用到服务中，以确保它可以处理工作负载。'
- en: For example, if a service can handle 100 requests per second when the number
    of requests exceeds 100, the service may become slow or even unavailable. The
    client may encounter a timeout error. To avoid this, we can set the rate limit
    for the service. When the number of requests exceeds the rate limit, the service
    will reject the requests and return an error to the client. This can prevent the
    service from being overloaded.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个服务在请求数量超过100时每秒可以处理100个请求，那么当请求数量超过这个限制时，服务可能会变慢甚至不可用。客户端可能会遇到超时错误。为了避免这种情况，我们可以为服务设置速率限制。当请求数量超过速率限制时，服务将拒绝请求并向客户端返回错误。这可以防止服务过载。
- en: 'ASP.NET Core provides a rate-limiting middleware that can be used to configure
    rate-limiting in various policies, such as `fixed window`, `sliding window`, `token
    bucket`, and `concurrency`. We introduced rate-limiting middleware in [*Chapter
    4*](B18971_04.xhtml#_idTextAnchor170). You can find more details about rate-limiting
    middleware at the following link: [https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit](https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core提供了一个速率限制中间件，可用于配置各种策略中的速率限制，例如`fixed window`（固定窗口）、`sliding window`（滑动窗口）、`token
    bucket`（令牌桶）和`concurrency`（并发）。我们已在[*第4章*](B18971_04.xhtml#_idTextAnchor170)中介绍了速率限制中间件。您可以在以下链接中找到有关速率限制中间件的更多详细信息：[https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit](https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit)。
- en: 'You can open the `PollyDemo` solution in the `/chapter17/PollyDemo/end` folder.
    In the `Program.cs` file of the `PollyServerWebApi` project, you can find the
    following code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以打开位于`/chapter17/PollyDemo/end`文件夹中的`PollyDemo`解决方案。在`PollyServerWebApi`项目的`Program.cs`文件中，您可以找到以下代码：
- en: '[PRE39]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The rate-limiting policy is applied to the `WeatherForecastController` class:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 速率限制策略应用于`WeatherForecastController`类：
- en: '[PRE40]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding code configures a fixed window rate limiter with a rate limit
    of five requests per 3 seconds. Of course, this is just an example for demonstration
    purposes. When the `PollyClientWebApi` application sends more than five requests
    per 3 seconds to the `PollyServerWebApi` application, the `PollyServerWebApi`
    application will return a `429 Too Many Requests` error to the client. The `OnRejected`
    callback is used to handle the rejected requests. In this example, we simply return
    a message to the client.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码配置了一个固定窗口速率限制器，其速率限制为每3秒五个请求。当然，这只是一个用于演示目的的示例。当`PollyClientWebApi`应用程序在3秒内向`PollyServerWebApi`应用程序发送超过五个请求时，`PollyServerWebApi`应用程序将向客户端返回`429
    Too Many Requests`错误。使用`OnRejected`回调来处理被拒绝的请求。在这个例子中，我们只是向客户端返回一条消息。
- en: Use the `dotnet run` command to run the `PollyServerWebApi` application and
    the `PollyClientWebApi` application. Then, send more than five requests per 3
    seconds to the `/weatherforecast` endpoint of the `PollyClientWebApi` application.
    You should be able to see the `429 Too Many Requests` error in the `PollyClientWebApi`
    application. In this way, we can limit the number of requests to the `PollyServerWebApi`
    service so that it can handle the workload without being overloaded.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dotnet run`命令运行`PollyServerWebApi`应用程序和`PollyClientWebApi`应用程序。然后，向`PollyClientWebApi`应用程序的`/weatherforecast`端点发送每3秒超过五个请求。您应该在`PollyClientWebApi`应用程序中看到`429
    Too Many Requests`错误。这样，我们可以限制对`PollyServerWebApi`服务的请求数量，以便它可以在不过载的情况下处理工作负载。
- en: 'We can also use `Polly` to implement the rate-limiting pattern. Follow these
    steps to implement the rate-limiting pattern using `Polly`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`Polly`来实现速率限制模式。按照以下步骤使用`Polly`实现速率限制模式：
- en: 'Install the `Polly.RateLimiting` NuGet package for the `PollyClientWebApi`
    project by running the following command in the terminal window:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端窗口中运行以下命令为`PollyClientWebApi`项目安装`Polly.RateLimiting` NuGet包：
- en: '[PRE41]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a `/api/normal-response` endpoint in the `PollyServerWebApi` application
    to simulate a normal service. Open the `Program.cs` file and add the following
    code:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PollyServerWebApi`应用程序中创建一个`/api/normal-response`端点以模拟正常服务。打开`Program.cs`文件并添加以下代码：
- en: '[PRE42]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This endpoint will return a response after a random delay between 1 and 1000
    milliseconds, which means, in the worst case, it may take 1 second to return a
    response. To limit the number of requests to this endpoint, we can use the rate-limiting
    policy for the `PollyClientWebApi` application.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此端点将在1到1000毫秒之间的随机延迟后返回响应，这意味着在最坏的情况下，它可能需要1秒钟才能返回响应。为了限制对此端点的请求数量，我们可以使用`PollyClientWebApi`应用程序的速率限制策略。
- en: 'We will use the dependency injection to inject the rate-limiting policy for
    convenience. Define a rate-limiting policy in the `Program.cs` as follows:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用依赖注入来注入速率限制策略以方便使用。在`Program.cs`中定义以下速率限制策略：
- en: '[PRE43]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding code defines a fixed window rate limiter with a rate limit of
    5 requests per 3 seconds. The policy is named `rate-limit-5-requests-in-3-seconds`.
    You can use any name you like.
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的代码定义了一个固定窗口速率限制器，其速率限制为每3秒5个请求。该策略命名为`rate-limit-5-requests-in-3-seconds`。您可以使用您喜欢的任何名称。
- en: 'In this example, we create a separate `Polly` pipeline for the rate-limiting
    policy. You can also combine multiple policies into a single pipeline. For example,
    you can combine the rate-limiting policy and the timeout policy into a single
    pipeline using the following code:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为速率限制策略创建了一个单独的`Polly`管道。你还可以将多个策略组合成一个单一的管道。例如，你可以使用以下代码将速率限制策略和超时策略组合成一个单一的管道：
- en: '[PRE44]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Inject the `ResiliencePipelineProvider<string>` class into the `PollyController`
    class of the `PollyClientWebApi` project, as shown in the following:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ResiliencePipelineProvider<string>`类注入到`PollyClientWebApi`项目的`PollyController`类中，如下所示：
- en: '[PRE45]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You will find that the code is quite similar to the timeout policy.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会发现代码与超时策略非常相似。
- en: 'Run the two applications and send more than 5 requests per 3 seconds to the
    `/api/polly/rate-limit` endpoint of the `PollyClientWebApi` application. Sometimes,
    you may see an error message in the console window of the `PollyClientWebApi`
    application as follows:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行两个应用程序，并在3秒内向`PollyClientWebApi`应用程序的`/api/polly/rate-limit`端点发送超过5个请求。有时，你可能在`PollyClientWebApi`应用程序的控制台窗口中看到如下错误消息：
- en: '[PRE46]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Similarly, you can use `Polly` to implement other rate-limiting policies, such
    as `sliding window`, `concurrency`, and `token bucket`. Here is an example of
    the sliding window rate limiter:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，你可以使用`Polly`实现其他速率限制策略，例如`滑动窗口`、`并发`和`令牌桶`。以下是一个滑动窗口速率限制器的示例：
- en: '[PRE47]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The preceding code defines a sliding window rate limiter with a rate limit of
    100 requests per minute.
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码定义了一个每分钟限制100个请求的滑动窗口速率限制器。
- en: 'As the Polly `RateLimiter` is a disposable resource, it is a good practice
    to dispose of it when it is no longer needed. `Polly` provides an `OnPipelineDisposed`
    callback that can be used to dispose of the `RateLimiter` object. For example,
    we can dispose of the `RateLimiter` object in the `OnPipelineDisposed` callback
    as follows:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Polly的`RateLimiter`是一个可丢弃的资源，因此当它不再需要时销毁它是良好的实践。`Polly`提供了一个`OnPipelineDisposed`回调，可以用来销毁`RateLimiter`对象。例如，我们可以在`OnPipelineDisposed`回调中销毁`RateLimiter`对象，如下所示：
- en: '[PRE48]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this way, we can dispose of the `RateLimiter` object when the pipeline is
    disposed of so that it does not consume resources unnecessarily.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当管道被销毁时，我们可以销毁`RateLimiter`对象，以避免不必要的资源消耗。
- en: Retry
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重试
- en: Next, let us discuss `429 Too Many Requests` error, or a `500 Internal Server
    Error` error, it can retry the request after a delay because the error may be
    caused by a temporary issue, such as rate-limiting or a network glitch. The next
    time the client API sends the request, it may succeed. This is called retry.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论`429 Too Many Requests`错误或`500 Internal Server Error`错误，它可以在延迟后重试请求，因为错误可能是由暂时性问题引起的，例如速率限制或网络故障。当客户端API下次发送请求时，它可能成功。这被称为重试。
- en: The retry pattern is a common approach to addressing transient failures in communication
    between microservices. This pattern is particularly useful in a microservice architecture,
    where network glitches or the temporary unavailability of a service can cause
    communication failures. By implementing retry mechanisms, these transient issues
    can be managed, and the overall reliability of the system can be improved.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 重试模式是解决微服务之间通信中短暂失败的一种常见方法。这种模式在微服务架构中尤其有用，因为网络故障或服务的暂时不可用可能导致通信失败。通过实现重试机制，这些短暂问题可以得到管理，从而提高系统的整体可靠性。
- en: 'Follow these steps to implement the retry pattern using `Polly`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用`Polly`实现重试模式：
- en: 'Update the `Get()` method of the `WeatherForecastController` class as follows:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更新`WeatherForecastController`类的`Get()`方法：
- en: '[PRE49]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The preceding code creates a `ResiliencePipelineBuilder` object to build a resilience
    pipeline. Then, it adds a retry policy to the pipeline. The retry policy will
    retry the request three times if it fails. The delay between retries is 500 milliseconds.
    The `MaxDelay` property is used to specify the maximum delay duration. The `OnRetry`
    callback is used to log the retry attempts. Finally, it executes the pipeline
    to send the request to the `PollyServerWebApi` application.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码创建了一个`ResiliencePipelineBuilder`对象来构建一个弹性管道。然后，它向管道中添加了一个重试策略。如果请求失败，重试策略将重试请求三次。重试之间的延迟为500毫秒。`MaxDelay`属性用于指定最大延迟时间。`OnRetry`回调用于记录重试尝试。最后，它执行管道以将请求发送到`PollyServerWebApi`应用程序。
- en: 'Run the two applications and send more than five requests per 3 seconds to
    the `/weatherforecast` endpoint of the `PollyClientWebApi` application. Sometimes,
    you may see that the request takes a longer time to complete. This is because
    the request is retried if it fails. You should also be able to see the retry attempts
    in the console window of the `PollyClientWebApi` application, as shown in the
    following:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行两个应用程序，并在3秒内向`PollyClientWebApi`应用程序的`/weatherforecast`端点发送超过五个请求。有时，你可能看到请求完成所需的时间更长。这是因为如果请求失败，则会重试请求。你也应该能够在`PollyClientWebApi`应用程序的控制台窗口中看到重试尝试，如下所示：
- en: '[PRE50]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this way, we can automatically retry the request if it fails. This can improve
    the reliability of the system.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以这种方式，如果请求失败，我们可以自动重试请求。这可以提高系统的可靠性。
- en: 'The retry policy can be configured in various ways. For example, we can configure
    the retry policy to retry the request only when the response status code is `429`
    as follows:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重试策略可以以多种方式配置。例如，我们可以将重试策略配置为仅在响应状态码为`429`时重试请求，如下所示：
- en: '[PRE51]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can also delay the retry attempts with an exponential backoff strategy. This
    is because the service may be overloaded, and the retry attempts may fail again.
    In this case, we can delay the retry attempts to avoid overloading the service.
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以使用指数退避策略延迟重试尝试。这是因为服务可能过载，重试尝试可能会再次失败。在这种情况下，我们可以延迟重试尝试以避免过载服务。
- en: 'To use the exponential backoff strategy, we can specify the `BackoffType` property
    of the `RetryStrategyOptions` object as follows:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用指数退避策略，我们可以指定`RetryStrategyOptions`对象的`BackoffType`属性，如下所示：
- en: '[PRE52]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `BackoffType` property is a `DelayBackoffType` enum that can be set to `Constant`,
    `Linear`, or `Exponential`. The `Constant` strategy will delay the retry attempts
    with a constant delay. The `Linear` strategy will delay the retry attempts with
    a linear delay. The `Exponential` strategy will delay the retry attempts with
    an exponential delay. The default strategy is `Constant`.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`BackoffType`属性是一个`DelayBackoffType`枚举，可以设置为`Constant`、`Linear`或`Exponential`。`Constant`策略将以恒定的延迟延迟重试尝试。`Linear`策略将以线性延迟延迟重试尝试。`Exponential`策略将以指数延迟延迟重试尝试。默认策略是`Constant`。'
- en: 'There are a few considerations when using the retry pattern:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用重试模式时，有一些考虑因素：
- en: The retry pattern should only be used to handle transient failures. If you want
    to implement a repeatable operation, you should use some scheduling mechanism,
    such as a background service, or suitable tools, such as `Polly` retry to implement
    a scheduled repeating operation.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试模式应仅用于处理短暂故障。如果你想要实现可重复的操作，你应该使用某种调度机制，例如后台服务，或者合适的工具，如`Polly`重试来实现计划重复操作。
- en: Consider using different retry policies for different types of errors. For example,
    an API call may involve HTTP requests, database queries, and JSON deserialization.
    If the HTTP request fails due to a network glitch, you can retry the request.
    However, if the JSON deserialization fails, it is unlikely to succeed even if
    you retry the JSON deserialization method. In this case, you can use `ShouldHandle`
    to specify the types of errors that should be retried.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑为不同类型的错误使用不同的重试策略。例如，API调用可能涉及HTTP请求、数据库查询和JSON反序列化。如果HTTP请求因网络故障而失败，你可以重试请求。然而，如果JSON反序列化失败，即使重试JSON反序列化方法，成功的可能性也很低。在这种情况下，你可以使用`ShouldHandle`来指定应该重试的错误类型。
- en: Circuit breaker
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 断路器
- en: The **circuit breaker** pattern is a useful tool for preventing service overload
    and failure. In the event that a service is becoming seriously overloaded, a client
    should stop sending requests for a period of time in order to allow the service
    to recover. This is known as the circuit breaker pattern and can help to avoid
    a service crash or total failure.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**断路器**模式是防止服务过载和失败的有用工具。如果服务变得严重过载，客户端应停止发送请求一段时间，以允许服务恢复。这被称为断路器模式，可以帮助避免服务崩溃或完全失败。'
- en: 'We can use `Polly` to implement the circuit breaker pattern. As we have already
    learned how to use Polly to implement the timeout pattern, the rate-limiting pattern,
    and the retry pattern, you should be able to understand the following steps:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Polly`来实现断路器模式。因为我们已经学习了如何使用Polly来实现超时模式、速率限制模式和重试模式，你应该能够理解以下步骤：
- en: 'Create a new `/api/random-failure-response` endpoint in the `PollyServerWebApi`
    application to simulate an overloaded service. Open the `Program.cs` file and
    add the following code:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PollyServerWebApi`应用程序中创建一个新的`/api/random-failure-response`端点以模拟服务过载。打开`Program.cs`文件并添加以下代码：
- en: '[PRE53]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This endpoint will return a `500 Internal Server Error` error with an 80% chance
    (approximately). This is just an example of simulating an overloaded service.
    In a real-world application, the service may be overloaded due to high traffic,
    network latency, and so on.
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此端点将以大约80%的概率（大约）返回一个`500 内部服务器错误`错误。这只是一个模拟服务过载的例子。在实际应用中，服务可能因高流量、网络延迟等原因而过载。
- en: 'Add the following code to the `Program.cs` file of the `PollyClientWebApi`
    application:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`PollyClientWebApi`应用程序的`Program.cs`文件中：
- en: '[PRE54]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The preceding code defines a circuit breaker policy named `circuit-breaker-5-seconds`
    with a failure ratio of 0.7\. This means if the failure ratio is greater than
    0.7, the circuit breaker will open. The `SamplingDuration` property is used to
    specify the duration of the sampling over which the failure ratios are calculated.
    The `MinimumThroughput` property means that at least 10 requests must be made
    within the sampling duration. The `BreakDuration` property means that the circuit
    breaker will stay open for 5 seconds if it opens. The `ShouldHandle` property
    is used to specify the types of errors that should be handled by the circuit breaker.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码定义了一个名为`circuit-breaker-5-seconds`的断路器策略，其故障率为0.7。这意味着如果故障率大于0.7，断路器将打开。`SamplingDuration`属性用于指定计算故障率所使用的采样持续时间。`MinimumThroughput`属性表示在采样期间至少必须发出10个请求。`BreakDuration`属性表示如果断路器打开，它将保持打开状态5秒钟。`ShouldHandle`属性用于指定应由断路器处理的错误类型。
- en: 'Create a new action in the `PollyController` class of the `PollyClientWebApi`
    application to call the overloaded service. Add the following code:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PollyClientWebApi`应用程序的`PollyController`类中创建一个新的操作以调用过载服务。添加以下代码：
- en: '[PRE55]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The preceding code uses `result.EnsureSuccessStatusCode()` to throw an exception
    if the response status code is not successful. As the overloaded service has an
    80% chance of returning an error, the circuit breaker will open after a couple
    of requests. Then, the circuit breaker will stay open for 5 seconds. During this
    period, the client will not send any requests to the overloaded service. After
    5 seconds, the circuit breaker will close, and the client will send requests to
    the overloaded service again.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码使用`result.EnsureSuccessStatusCode()`来抛出异常，如果响应状态码不是成功的。由于过载服务有80%的概率返回错误，断路器在几次请求后会打开。然后，断路器将保持打开状态5秒钟。在这段时间内，客户端不会向过载服务发送任何请求。5秒后，断路器将关闭，客户端将再次向过载服务发送请求。
- en: 'Run the two applications and send more than 10 requests to the `/api/polly/circuit-breaker`
    endpoint of the `PollyClientWebApi` application. Sometimes, you will see a `500
    Internal Server Error` error as follows:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行这两个应用程序并向`PollyClientWebApi`应用程序的`/api/polly/circuit-breaker`端点发送超过10个请求。有时，你会看到如下`500
    内部服务器错误`错误：
- en: '[PRE56]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Send more requests, and you will see that the circuit breaker opens and returns
    a different error message as follows:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送更多请求，你会看到断路器打开并返回不同的错误消息，如下所示：
- en: '[PRE57]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can see that the error message is different from the previous one, which
    indicates that the circuit breaker is open, so any requests to the overloaded
    service will be rejected. You need to wait for 5 seconds before sending more requests
    to the overloaded service. During these 5 seconds, all the requests to the `/api/polly/circuit-breaker`
    endpoint will not be sent to the overloaded service and will return the same error
    message instead.
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以看到错误消息与之前的不同，这表明断路器已打开，因此任何对过载服务的请求都将被拒绝。你需要在发送更多请求到过载服务之前等待5秒钟。在这5秒钟内，所有对`/api/polly/circuit-breaker`端点的请求都不会发送到过载服务，而是返回相同的错误消息。
- en: Circuit breakers are not the same as the retry pattern. The retry pattern expects
    the operation to succeed eventually. However, the circuit breaker pattern prevents
    the operation from being executed if it is likely to fail, which can save resources
    and allow the external service to recover. You can use these two patterns together.
    But note that the retry logic should check the exception type thrown by the circuit
    breaker. If the circuit breaker indicates that the operation failure is not a
    transient issue, the retry logic should not retry the operation.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器与重试模式不同。重试模式期望操作最终会成功。然而，断路器模式会在操作可能失败时阻止其执行，这样可以节省资源并允许外部服务恢复。您可以将这两种模式结合使用。但请注意，重试逻辑应该检查断路器抛出的异常类型。如果断路器指示操作失败不是暂时性问题，则重试逻辑不应重试该操作。
- en: '`Polly` is a powerful library that implements many resilience patterns. This
    section cannot cover all the patterns provided by `Polly`. You can find more examples
    at the following link: [https://www.pollydocs.org/index.html](https://www.pollydocs.org/index.html).'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`Polly`是一个强大的库，实现了许多弹性模式。本节无法涵盖`Polly`提供的所有模式。您可以在以下链接中找到更多示例：[https://www.pollydocs.org/index.html](https://www.pollydocs.org/index.html).'
- en: 'In addition to the design patterns discussed in this chapter, there are more
    patterns for microservice architecture. As many of these patterns are beyond the
    scope of this book, we will not discuss them in detail. You can find more details
    about these patterns from Microsoft Learn: [https://learn.microsoft.com/en-us/azure/architecture/patterns/](https://learn.microsoft.com/en-us/azure/architecture/patterns/).'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本章讨论的设计模式之外，还有更多针对微服务架构的模式。由于许多这些模式超出了本书的范围，我们将不会详细讨论它们。您可以从Microsoft Learn中找到更多关于这些模式的信息：[https://learn.microsoft.com/en-us/azure/architecture/patterns/](https://learn.microsoft.com/en-us/azure/architecture/patterns/).
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored several concepts and patterns for microservice
    architecture, including domain drive design, clean architecture, CQRS, pub/sub,
    and BFF, and resilience patterns, such as timeout, rate-limiting, retry, and circuit
    breaker. These patterns can help us design and implement a maintainable, reliable,
    and scalable microservice architecture. Although this chapter does not cover all
    the patterns for microservice architecture, it should provide a basic understanding
    of what they are and how they can be used. These patterns are essential for developers
    who wish to progress beyond the basic knowledge of ASP.NET Core web API.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了微服务架构的几个概念和模式，包括领域驱动设计、清洁架构、CQRS、pub/sub和BFF，以及弹性模式，如超时、速率限制、重试和断路器。这些模式可以帮助我们设计和实现可维护、可靠和可扩展的微服务架构。尽管本章没有涵盖微服务架构的所有模式，但它应该提供了对它们是什么以及如何使用它们的基本理解。这些模式对于希望超越ASP.NET
    Core Web API基本知识的开发者至关重要。
- en: 'In the next chapter, we will discuss some open-source frameworks that can be
    used to build ASP.NET Core web API applications. You can check the chapter out
    at the following link: [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter18](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter18).'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一些可以用来构建ASP.NET Core Web API应用程序的开源框架。您可以通过以下链接查看该章节：[https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter18](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter18).
- en: Further reading
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about microservice architecture, the following resources from
    Microsoft Learn are highly recommended:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于微服务架构的信息，强烈推荐以下来自Microsoft Learn的资源：
- en: 'Architectural principles: [https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles](https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles).'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构原则：[https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles](https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles).
- en: 'Common web application architectures: [https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/common-web-application-architectures](https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/common-web-application-architectures).'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见网络应用程序架构：[https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/common-web-application-architectures](https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/common-web-application-architectures).
- en: '.NET Microservices: Architecture for Containerized .NET Applications: [https://docs.microsoft.com/en-us/dotnet/architecture/microservices/](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/).'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '.NET 微服务：容器化 .NET 应用的架构: [https://docs.microsoft.com/en-us/dotnet/architecture/microservices/](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/).'
- en: 'Architect Modern Web Applications with ASP.NET Core and Azure: [https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/](https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/).'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 ASP.NET Core 和 Azure 构建现代 Web 应用程序: [https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/](https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/).'
- en: 'Architecting Cloud Native .NET Applications for Azure: [https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/](https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/).'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '为 Azure 构建云原生 .NET 应用程序: [https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/](https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/).'
- en: 'Serverless apps: Architecture, patterns, and Azure implementation: [https://learn.microsoft.com/en-us/dostnet/architecture/serverless/](https://learn.microsoft.com/en-us/dotnet/architecture/serverless/).'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '无服务器应用程序：架构、模式和 Azure 实现: [https://learn.microsoft.com/en-us/dotnet/architecture/serverless/](https://learn.microsoft.com/en-us/dotnet/architecture/serverless/).'
- en: 'Cloud Design Patterns: [https://docs.microsoft.com/en-us/azure/architecture/patterns/](https://docs.microsoft.com/en-us/azure/architecture/patterns/).'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '云设计模式: [https://docs.microsoft.com/en-us/azure/architecture/patterns/](https://docs.microsoft.com/en-us/azure/architecture/patterns/).'
