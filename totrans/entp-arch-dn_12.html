<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-252"><a id="_idTextAnchor446"/>12</h1>
<h1 id="_idParaDest-253"><a id="_idTextAnchor447"/>Externalization of Business Rules</h1>
<p>After the two preceding chapters detailing the Master Data Management and Business Process Management parts of a utopic information system, this chapter will end with the third and last part of such an ideal system, which is the <strong class="bold">Business Rules Management System</strong> (<strong class="bold">BRMS</strong>). We have already discussed briefly business rules in the previous chapters because the data referential may contain some validation rules that are associated with a given business entity, and the business process may also embed some business rules to orient the workflow and decide which branch of the process should be executed, depending on the context. But in the perfectly ideal system that we envision, a centralized system should be responsible for all the business rules, and that is the subject of this chapter.</p>
<p>We will start by explaining in more detail what a BRMS is and what implementing such a solution requires in terms of business rules management, deployment, and architecture of the stream of data in the system. Then, we will show the first example of business rules management using a<a id="_idIndexMarker697"/> standard called <strong class="bold">DMN</strong> (short for, <strong class="bold">Decision Model and Notation</strong>), inside a business process.</p>
<p>Unlike the previous two, we will end this chapter (and the series of three chapters on the different parts of an ideal information system) without providing application examples of our sample information system. The reason behind this is that authorization management is one of the best examples of business rules management, but the subject is so complex that it needs a complete chapter to understand it.<a id="_idTextAnchor448"/></p>
<h1 id="_idParaDest-254"><a id="_idTextAnchor449"/>Business Rules Management Systems</h1>
<p>A <strong class="bold">Business Rules Management System</strong> (we will abbreviate into <strong class="bold">BRMS</strong> from now on) is a piece of software that <a id="_idIndexMarker698"/>deals with computations and decisions that can be applied to data, in order to output results that have a higher business value. There are lots of concepts in that definition, and we are going to explain them one at a time<a id="_idTextAnchor450"/>.</p>
<h2 id="_idParaDest-255"><a id="_idTextAnchor451"/>How does a BRMS handle business rules?</h2>
<p>A <a id="_idIndexMarker699"/>business rule can, for example, calculate the total price of an order line, using the tax-excluding price of an article, the number of articles, and the applicable tax rate. Another example of its application would be to decide whether a piece of document created in an invoicing process should be given an electronic signature or not. In this case, the business rules output a Boolean value, stating whether the result is true or false. Business rules can call each other. In the previous example, we may have to decide how the document will be presented to someone for signature, who will sign if the initial signee is considered absent after several notifications, how many such notifications will be sent and on which channels, and so on – all these are business rules.</p>
<p>As its name suggests, a BRMS manages business rules. But what this entails is not so obvious. In one way, you could consider that a BRMS is the MDM of business rules – it can store them, together with their old versions. It can allow some people to read them, some to write them, or reject others that have no authorization whatsoever on certain business rules. It can group and categorize business rules in order to specify their research. All this is done by an MDM on its referenced business entity, but a BRMS has one more responsibility that an MDM does not have, which is the execution of the business rule. Indeed, a business rule takes input to calculate an output, and it is the main responsibility of a BRMS to do so.</p>
<p>However, responsibility does not mean the BRMS executes everything. Most of the time, it will delegate the enforcement of the rule, as it does not own the data that is addressed by a business rule or the service that executes a business action in a way defined by the output of the rule. That may sound counter-intuitive, but a BRMS can even delegate responsibility for the execution of the rule (which is to calculate the output of the rule from its input). This is the case, for example, where an MDM service validates its incoming data with a rule coming from the BRMS. Some local cache of the rules expressions is also possible since it does not introduce lots of coupling. Nonetheless, the responsibility of the validation rule remains in the BRMS, since if somebody changes the rule in the BRMS editor, then it will apply (maybe after a small delay, if the cache is not immediately invalidated for performance reasons) to all servers using this rule, among which is the MDM of our example.</p>
<p>To summarize, the primary responsibilities of a BRMS are to store, expose, and execute business rules. It is responsible for the right execution of the rules and, thus, either executes them internally or trusts other applications to execute the rules that it provides them. This is often the case, as external applications are the ones that have access to the input data necessary to execute the rule. Also, they will be – most of the time – the ones that use the output of the rule to adjust their behavior accordingl<a id="_idTextAnchor452"/>y.</p>
<h2 id="_idParaDest-256"><a id="_idTextAnchor453"/>Additional characteristics of a BRMS</h2>
<p>We often talk<a id="_idIndexMarker700"/> about the “secondary responsibilities” of a service for features that are not absolutely necessary but still remain important. In the case of BRMS, there are several such responsibilities.</p>
<p>First and foremost, a BRMS should have high performance, both in execution time and in its capacity to withstand a high volume of requests. Indeed, rule execution is one of the few cases where a cache is difficult to apply. When retrieving an image from a URL, there is a great chance that it is not going to change from one call to another one a few seconds after; thus, it is really worth keeping a cache, as this will avoid a network roundtrip and server request handling and drastically improve performance. This is not the case for business rules, as their main function is to be calculated from varying input and provide an output that depends on them.</p>
<p>Sure, the rule expression can be cached (and rules may not change that frequently), but when you do so, the caller has to be able to execute the rule from its textual expression itself, which may be overly complex and necessitate a rule-execution engine. If the rule is shared among many services, many instances of the engine will have to be kept in synchronization with the BRMS, so it is not efficient. So, we come back to the engine being in only one place, which is the BRMS server itself.</p>
<p>In this case, the engine’s moving parts may be cached, or at least kept in RAM, which will provide a quick execution. However, caching the results depending on the input is, most of the time, not efficient, as there are so many possible values. To use our preceding example, there is absolutely no need to cache the result of a calculation of an invoice line total price, as there is almost no chance that another call will come back quickly for the same article, with the same quantity and tax rate. If you add that some rules may be based on ever-changing data (such as stock market values), it can become absolutely impossible to arrange some way of caching. So, we basically fall back to the need for an engine that can output values as quickly as possible. This requirement should of course be supported in case of high volumes. As business data (as opposed to reporting data) tends to be volatile, business rules will be called very often.</p>
<p>The other “secondary” feature of a good BRMS is robustness. When they are used in the industry (which is not very often because they are complex applications), it is because they are a very important part of the business processes. For instance, a BRMS is used by insurance companies to calculate risk, or by mobile phone companies to calculate the price to be paid from data about the conversations (the duration, numbers called, time of the day, etc.) and the contract (a discount for certain numbers, prepaid amount per month, consumption in the month, etc.). Because of the cost of a BRMS, they are generally used for core business functions, where important decisions (in our examples, accepting a contract and sending the correct invoice to a customer) are made based on their output. The <a id="_idIndexMarker701"/>robustness of calculations is, thus, an important aspect because no one would work with a system that can miscalculate from time to time.</p>
<p>For the same reason, traceability is generally an important feature of a BRMS. It can, of course, delegate this to calling services because a BRMS mostly works for other services. But even if the responsibility is shared, there should be logs that record whether a rule has been applied to certain context data, providing output that clarifies why a certain rule was made. Even if logs are better suited to the calling application, it is a good idea that the version of the BRMS set of rules is kept somewhere and that the rule engine versions are immutable. This allows you, if necessary, to go back in time, re-execute business rules calculation on the then-used version of the BRMS engine, and understand why an output value was wrong.</p>
<p>Finally, as explained previously, a BRMS is often used in conjunction with other services and is useless by itself. Its low-level characteristics make its integration and good capacity for interoperation of paramount importance. An implementation should normally come with at least some APIs and, if possible, SDKs for as many languages as possible, making it easy to interact with all possible software applicati<a id="_idTextAnchor454"/>ons.</p>
<h2 id="_idParaDest-257"><a id="_idTextAnchor455"/>Actual use of BRMS</h2>
<p>As <a id="_idIndexMarker702"/>was hinted previously, the actual use of BRMS in the field is very low. The cost of implementation is such that only a few very particular cases of business rule execution are actually worth deploying a dedicated server for. Also, as we saw, the externalization of a rule comes with a high toll on performance, as either the application that knows the data has to send it to the BRMS and wait for the output to follow its flow, or it has to dynamically execute a business rule expression sent by the BRMS, and maybe cached internally. In this case, the speed of execution is still lower than when the rule is compiled into an application. Sure, the coupling between the application and the rule is then maximal, there is no centralized sharing of the rule, and the many uses can diverge. However, the performance issue can be so significant that these reasons are not as important.</p>
<p>Also, let’s not <a id="_idIndexMarker703"/>underestimate habitual factors as well – since developers have spent most of their careers taking business rules from use cases and translating them into code put in an application, it is an effort to change this way of thinking, extract the business rule, and place it somewhere else. And with what results? A large performance drop and code that is more difficult to read and maintain. This means that the business rule should <code>CommonBusinessValues</code> class, in a <code>public static readonly</code> member, and everything will be fine and ready for an update.</p>
<p>This means that, indeed, in 99.99% of the cases, business rules will be concretely implemented, like in the following C# example, by means of code:</p>
<pre class="source-code">
public decimal GetPrice(decimal unitPrice, int quantity, decimal taxRate)
{
    return (unitPrice * quantity) * (1 + taxRate);
}</pre> <p>Also, lots of other business rules will be scattered all over the code:</p>
<pre class="source-code">
if (Document.Type == DocumentTypes.INVOICE)
{
    SendForDigitalSignature(Document);
}</pre> <p>As a side note, it is better to use string values or even dedicated code structures instead of enumerations for this kind of value, as this eases evolution.</p>
<p>In fact, there<a id="_idIndexMarker704"/> are so many business rules everywhere in a code base that it is difficult to spot all of them. But this is not what is most important. The real challenge is for the architect/product owner/developer to know, when creating the application, which ones should be externalized, which ones should be centralized, and which should be simply left in the code, even in duplicates, because they will never change. Beware, though, that some things that are thought to never change sometimes evolve over time! For example, you could say that the rule about net price will always be stable; net price will always be the tax-free price multiplied by one plus the tax rate. Well, yes, until the government decides to apply multiple tax rates that apply differently to the sub-parts of a product. And if you have in your Product Information Management software some articles that are composed of a hardware part and an installation service, for example, you may end up with the first part taxed at 5.5% and the second part taxed at 20%. If the calculation has been written in a centralized function, this is not so bad. But if it has been duplicated in hundreds of places in the code (which can be the case with business rules that everyone assumes are constant and immutable), you will face some difficulty, not only because it will take ages for the change to be realized, but also because the one instance you forget will most likely be the one your most important customer uses.</p>
<p>In short, externalizing a business rule in a dedicated BRMS is 99.99% of the time overkill, and the cost is not justified. But you can go a very long way simply by putting the business rule in a function. And most of the time, the only difficulty there is simply realizing you are implementi<a id="_idTextAnchor456"/>ng one!</p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor457"/>Examples of a BRMS</h2>
<p>Let’s say that <a id="_idIndexMarker705"/>you are indeed in this very particular 0.01% case where you actually could gain business value from implementing a dedicated BRMS. You would, thus, need a piece of software to do this for you, since, as you can imagine from the required secondary features, this kind of server is quite a complex piece of code. At the <a id="_idIndexMarker706"/>time of writing, there were only two serious contenders for BRMS servers – Drools (open source) and <strong class="bold">Operational Decision </strong><strong class="bold">Manager</strong> (<strong class="bold">ODM</strong>).</p>
<p>The most used open source <a id="_idIndexMarker707"/>BRMS is Drools (<a href="https://www.drools.org/">https://www.drools.org/</a>). It contains a core engine to calculate rules (including some functions such as rule chaining), which is sometimes called an inference engine, as it infers results from a data context and a set of rules. It also contains an application to create and manipulate rules (with a web editor). Drools is written in Java and can be interoperated with other platforms, but not natively.</p>
<p>ODM, from IBM, is <a id="_idIndexMarker708"/>a proprietary decision management system that was created to extract the important business rules from legacy COBOL code, in an effort to modernize the information systems on the z/OS platform. Although it can manipulate rules, it is mostly organized around the concepts of decisions on events.</p>
<p>As you can see, the landscape is far from being as complicated as in other fields of IT – for example, Big Data, where a single book could not even describe all the software applications, platforms, and servers that are available, mostly all doing the same things while pretending to be radically different from their competitors. This has the merit of clarity – if you need to implement a BRMS in your information system and you want to reduce costs, Drools will be your first choice.</p>
<p>Of course, there are some lesser-known alternatives. Lots of BPMN engines implement their own language for workflow decisions. Windows Workflow Foundation did so, but it is not supported anymore. PowerApps has some expression capability that can be used for business rule execution, but it can only be mutualized, so it is not a real BRMS system. Another solution, although it involves additional work, is to implement your own BRMS. If you do not need advanced features, you can build one quite quickly if you use an existing expression execution engine. Lots of scripting languages are available, and you can even use C# inside C# with expression trees, dynamic code generation, and other advanced, but still accessible, features.</p>
<p>In short, you have a choice of software, even if it is not as plethoric as in some other fields of IT. However, as you are certainly used to now, business/IT alignment is about reducing coupling, so the choice of software implementation is normally not such an important subject (in the sense it could harm the application evolution) as long as there is a standard norm, widely accepted specification, or even just an organization-wide pivotal format that can serve as a level of indirection between functional dependency and technical implementation. And the great news is that there is a standard for business rules, which is <strong class="bold">Decision Modeling Notation</strong> (<strong class="bold">DMN</strong>) 1.0. This will be our topic of discussion in the next section of th<a id="_idTextAnchor458"/>is chapter.</p>
<h1 id="_idParaDest-259"><a id="_idTextAnchor459"/>The DMN standard</h1>
<p>DMN is a<a id="_idIndexMarker709"/> standard that defines decision trees and decision tables, which are the two main concepts concerning business rule implementation. In the upcoming sections, we will show how it works and how usefu<a id="_idTextAnchor460"/>l it can be.</p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor461"/>The origin and principle of DMN</h2>
<p>The DMN standard<a id="_idIndexMarker710"/> is in version 1.0 and was published by the <strong class="bold">OMG</strong> (short for, <strong class="bold">Object Management Group</strong>) in September 2015. At <a id="_idIndexMarker711"/>the time of writing, the latest validated version is numbered 1.3 and was published in February 2021. Version 1.5 has existed since June 2023, but it is considered a beta version currently. Thus, we will discuss only version 1.3.</p>
<p>Note that OMG is also the consortium behind the BPMN 2.0 standard, which works in conjunction with the DMN standard. As expressed by OMG as soon as the first version was launched (<a href="https://www.omg.org/spec/DMN/1.0/About-DMN">https://www.omg.org/spec/DMN/1.0/About-DMN</a>): “<em class="italic">DMN notation is designed to be useable alongside the standard BPMN business process notation.</em>” And there is a type of task that exists in BPMN that directly relates to business rules:</p>
<div><div><img alt="Figure 12.1 – A business rule task" src="img/B21293_12_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – A business rule task</p>
<p>The idea behind <a id="_idIndexMarker712"/>this type of task is that there are complex business rules that decide how a BPMN business process should behave (mostly, which path in the gateways should be taken) and that a way to handle such a decision should be made possible. Indeed, imagine a (not so) complicated process like the following:</p>
<div><div><img alt="Figure 12.2  – An example of a process with several rules" src="img/B21293_12_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2  – An example of a process with several rules</p>
<p>For now, it is not too bad because there are only three types of contracts. But this is typically the kind of scenario that has many chances to scale (never underestimate the creativity of <a id="_idIndexMarker713"/>salespersons and marketing people). What if there are ten types of contract in the future, maybe with a third criterion to take into account? The process will become more and more complex and, soon, illegible, which would be a big problem, since business processes should always remain a helpful tool for teams and, specifically, not something that makes it more complicated for them to work.</p>
<p>DMN proposes a solution, which is to externalize the decision rules in a dedicated place, in order to free up the design of the process itself. In the previous example, we would externalize the decision table like this:</p>
<div><div><img alt="Figure 12.3 – A decision table" src="img/B21293_12_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – A decision table</p>
<p>This would allow us to draw the process in a much simpler way, as follows (note the icon in the second task, which corresponds to the <code>Business </code><code>rule</code> type):</p>
<div><div><img alt="Figure 12.4 – A simplified BPMN process" src="img/B21293_12_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – A simplified BPMN process</p>
<p class="callout-heading">Note</p>
<p class="callout">Sadly, since there is no standardization of how data is collected in the different tasks of a BPMN process, there can be no standardized way either to call a DMN model. But it’s worth keeping informed about any updates to the norms at <a href="https://www.omg.org/dmn/">https://www.omg.org/dmn/</a> since this is bound to change at some point in the future.</p>
<p>The best part is<a id="_idIndexMarker714"/> that now that this logic has been decoupled from the business process itself, we could evolve to a much more complex definition of the type of contract, such as the following, without having to change anything on the process itself:</p>
<div><div><img alt="Figure 12.5 – An extended decision table" src="img/B21293_12_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – An extended decision table</p>
<p>This time, we also take into account the age of the author to issue some special contract that must be signed by the author’s parents. This is done by using a very simple expression here (<code>FEEL</code> expression language allows for much more sophisticated expressions (if you want to delve into more on this subject, <a href="https://kiegroup.github.io/dmn-feel-handbook/#dmn-feel-handbook">https://kiegroup.github.io/dmn-feel-handbook/#dmn-feel-handbook</a> is a great starting point). You also may have spotted that the <code>AdditionalEdition</code>, since the result was common for any author as long as the book is a new edition of an existing one.</p>
<p>Having these tables to externalize potentially complex rules is already a great advantage, but DMN also comes with a graphical way to represent the decision process itself:</p>
<div><div><img alt="Figure 12.6 – An example decision graph" src="img/B21293_12_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – An example decision graph</p>
<p>In our example, the <a id="_idIndexMarker715"/>diagram is very simple, since we use only two inputs (author and book information) in order to create a decision (the type of contract), possibly using a “knowledge source,” which would be our referential of contracts, although we did not relate to any such use in the simple example previously. However, these diagrams could be much more advanced and show hierarchical decisions if necessary. We could imagine that the type of contract decided on is then itself used to decide the content of a customized contract, depending on the regions of diffusion of the work, and that sales statistics are used to decide on a proposed amount for the contract:</p>
<div><div><img alt="Figure 12.7 – An extended decision graph" src="img/B21293_12_7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – An extended decision graph</p>
<p>To give an idea of the XML structure of a DML file, here is the (shortened) content corresponding to this first example above, where you will easily recognize the first part with the decision <a id="_idIndexMarker716"/>rules (starting at <code>&lt;decision&gt;</code>) and the second part corresponding to the diagram (starting at <code>&lt;dmndi:DMNDI&gt;</code>):</p>
<pre class="source-code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;definitions      id="definitions_065qkmh" name="definitions" namespace="http://camunda.org/schema/1.0/dmn" exporter="dmn-js (https://demo.bpmn.io/dmn)" exporterVersion="15.0.0"&gt;
  &lt;decision id="decision_1u2xbtg" name="Type of contract"&gt;
    &lt;informationRequirement id="InformationRequirement_1i0e44v"&gt;
      &lt;requiredInput href="#InputData_0wi3jz6" /&gt;
    &lt;/informationRequirement&gt;
    &lt;informationRequirement id="InformationRequirement_0g0syf3"&gt;
      &lt;requiredInput href="#InputData_1jz546j" /&gt;
    &lt;/informationRequirement&gt;
    &lt;decisionTable id="decisionTable_0cwlzw4" biodi:annotationsWidth="400"&gt;
      &lt;input id="input1" label="Author"&gt;
        &lt;inputExpression id="inputExpression1" typeRef="string"&gt;
          &lt;text&gt;&lt;/text&gt;
        &lt;/inputExpression&gt;
      &lt;/input&gt;
      &lt;input id="InputClause_1hfsajf" label="Book"&gt;
        &lt;inputExpression id="LiteralExpression_00wz5lk" typeRef="string"&gt;
          &lt;text&gt;&lt;/text&gt;
        &lt;/inputExpression&gt;
      &lt;/input&gt;
      &lt;output id="output1" label="Contract" name="" typeRef="string" /&gt;
      &lt;rule id="DecisionRule_05kn45x"&gt;
        &lt;inputEntry id="UnaryTests_19ou6i4"&gt;
          &lt;text&gt;"New"&lt;/text&gt;
        &lt;/inputEntry&gt;
        &lt;inputEntry id="UnaryTests_0l88vr8"&gt;
          &lt;text&gt;"New"&lt;/text&gt;
        &lt;/inputEntry&gt;
        &lt;outputEntry id="LiteralExpression_05irfs8"&gt;
          &lt;text&gt;"New"&lt;/text&gt;
        &lt;/outputEntry&gt;
      &lt;/rule&gt;
      &lt;!-- Some rules removed --&gt;
      &lt;rule id="DecisionRule_1sg8k57"&gt;
        &lt;inputEntry id="UnaryTests_1yjyvpp"&gt;
          &lt;text&gt;"Existing"&lt;/text&gt;
        &lt;/inputEntry&gt;
        &lt;inputEntry id="UnaryTests_0qo517n"&gt;
          &lt;text&gt;"AddEdition"&lt;/text&gt;
        &lt;/inputEntry&gt;
        &lt;outputEntry id="LiteralExpression_0ymlni0"&gt;
          &lt;text&gt;"AdditionalEdition"&lt;/text&gt;
        &lt;/outputEntry&gt;
      &lt;/rule&gt;
    &lt;/decisionTable&gt;
  &lt;/decision&gt;
  &lt;inputData id="InputData_0wi3jz6" name="Author history" /&gt;
  &lt;inputData id="InputData_1jz546j" name="Books history for the author" /&gt;
  &lt;dmndi:DMNDI&gt;
    &lt;dmndi:DMNDiagram id="DMNDiagram_1r90cap"&gt;
      &lt;dmndi:DMNShape id="DMNShape_15dfipm" dmnElementRef="decision_1u2xbtg"&gt;
        &lt;dc:Bounds height="80" width="180" x="330" y="200" /&gt;
      &lt;/dmndi:DMNShape&gt;
      &lt;dmndi:DMNShape id="DMNShape_14d6htu" dmnElementRef="InputData_0wi3jz6"&gt;
        &lt;dc:Bounds height="45" width="125" x="257" y="337" /&gt;
      &lt;/dmndi:DMNShape&gt;
      &lt;dmndi:DMNEdge id="DMNEdge_1a3apwq" dmnElementRef="InformationRequirement_1i0e44v"&gt;
        &lt;di:waypoint x=»320» y=»337» /&gt;
        &lt;di:waypoint x=»390» y=»300» /&gt;
        &lt;di:waypoint x=»390» y=»280» /&gt;
      &lt;/dmndi:DMNEdge&gt;
      &lt;dmndi:DMNShape id=»DMNShape_0s4bzo1» dmnElementRef=»InputData_1jz546j»&gt;
        &lt;dc:Bounds height="45" width="125" x="457" y="337" /&gt;
      &lt;/dmndi:DMNShape&gt;
      &lt;dmndi:DMNEdge id="DMNEdge_0ng7t96" dmnElementRef="InformationRequirement_0g0syf3"&gt;
        &lt;di:waypoint x="520" y="337" /&gt;
        &lt;di:waypoint x="450" y="300" /&gt;
        &lt;di:waypoint x="450" y="280" /&gt;
      &lt;/dmndi:DMNEdge&gt;
    &lt;/dmndi:DMNDiagram&gt;
  &lt;/dmndi:DMNDI&gt;
&lt;/definitions&gt;</pre> <p>All the graphs<a id="_idIndexMarker717"/> shown previously were designed using the great tool provided by Camunda at <a href="https://demo.bpmn.io/dmn">https://demo.bpmn.io/dmn</a>. Now that you have an introductory knowledge of what DMN is about, let’s see how we can put the stan<a id="_idTextAnchor462"/>dard to work.</p>
<h2 id="_idParaDest-261"><a id="_idTextAnchor463"/>Implementations</h2>
<p>The <a id="_idIndexMarker718"/>Business Rules Execution System landscape is quite small. The go-to implementation of DMN has been and remains the Java open source project called Drools. Drools is a BRMS that supports its own rules language but also DMN, and since DMN is the standard, all servers using Drools are based on it. You can use Drools directly in your Java applications, or even with some bridges to other platforms. In particular, there has been a Drools .NET implementation, and some projects such as <a href="https://github.com/adamecr/Common.DMN.Engine">https://github.com/adamecr/Common.DMN.Engine</a> can help with that, but the maintenance of such projects is questionable, and I’d rather show you another way that – in my opinion – is more suitable to what we are trying to achieve, which is an aligned and adaptable information system.</p>
<p>To do so, we<a id="_idIndexMarker719"/> will get closer to a service-oriented architecture by using a BRMS server that exposes the business rule runtime through REST APIs. Sure, the performance will not be as strong as with an embedded library but remember that, first, “premature optimization is the root of all evil” and, second, that most calls of the business rules are not executed with high frequency (and when they need to be, we will show at the end of the chapter how we can adapt). Kogito has already been cited in the previous chapter, but we did not show a complete example of BPMN with it because, as was explained, this would be overkill for most cases, especially our sample <code>DemoEditor</code> information system. What is interesting is that Kogito also supports DMN, and that is why we are going to use it here – or, rather, use JBPM, which is the product that Kogito is based on.</p>
<p>In fact, Kogito is the cloud-native derivative of JBPM, a product maintained under the JBoss umbrella. Since we are not going to deploy in the cloud, instead keeping a Docker-based deployment of our applications to satisfy either SaaS or on-premise conditions, we will simply use JBPM in the following example. Still, keep in mind for your needs that Kogito may be a better alternative, particularly since it offers some functions that could be compared to a light MDM, exposing entities directly by REST APIs generated dynamically. If you want to go in this direction and see how a fully integrated cloud-oriented approach suits you, you can start with Docker images of Kogito, available at <a href="https://github.com/kiegroup/kogito-images">https://github.com/kiegroup/kogito-images</a>.</p>
<p>The JBoss JBPM server that we are going to exploit is an all-in-one application, providing a frontend and a backend to design and operate BPMN workflows with DMN-based business rules. It works with Maven projects containing some Java code for the unit tests, and possibly for the exposition of the entities, but it can operate with simple standard files in DMN for our example.</p>
<p>In the next section, we will explain how to operate a sample business rule engine in JBPM 7.74, using the Drools engine and a DMN definition of two business decisions with several parameters. For more information about how this works precisely, head over to <a href="https://docs.jboss.org/drools/release/7.74.1.Final/drools-docs/html_single/">https://docs.jboss.org/drools/release/7.74.1.Final/drools-docs/html_single/</a>. The reason why we use a sample provided by JBoss is that designing from scratch an example on the subject of <code>DemoEditor</code> would take up a whole chapter. In addition, it would be a completely artificial exercise, since a DMN rule engine, just like a BPMN engine in the previous chapter, would simply be overkill for our functional needs. It is essential that I respect the principal rule I have been repeating over and over since the beginning of this book, which is that the technical aspects should be completely defined by the <a id="_idIndexMarker720"/>functional needs. Although I – like most of us who are passionate about technology – would love to integrate a full-blown Kogito server in our sample information system, the truth is that it would not be suitable for our needs. The implementation of the business workflows and most business rules will simply be in dedicated .NET services. Only a particular case of business rules would be treated with a dedicated external service that strongly resembles a BRMS, namely the authorization rules. But I am anticipating the last section of this chapter, and for now, we are going to show how we can take advantage of a DMN-based BRMS in a business/IT-aligned cont<a id="_idTextAnchor464"/>ext, using JBPM.</p>
<h2 id="_idParaDest-262"><a id="_idTextAnchor465"/>An example of DMN use</h2>
<p>Simple <a id="_idIndexMarker721"/>exercises such as the one that follows are really where Docker stands out because it will save us the hassle of installing Java and Maven, getting the right dependencies, updating versions, and so on. Provided you have Docker installed on your machine (and if this is not the case, you really should, as this tool is now part of your basic toolset, just like a web browser and a text editor), you can simply enter the following commands:</p>
<pre class="console">
docker run -d --name jbpm-console -p 8080:8080 quay.io/kiegroup/business-central-workbench-showcase:latest
docker run -d --name jbpm-bre -p 8180:8080 --link jbpm-console:kie-wb quay.io/kiegroup/kie-server-showcase:latest</pre> <p>Note that the <code>latest</code> tag, at the time of writing, was the <code>7.74.1.Final</code> version. It is generally recommended to use the <code>latest</code> tag as much as possible, but if you ever encounter a functional problem replaying the example, give it a try using this precise version, even if it is not the latest anymore. The first Docker command will start a container based on the image containing everything that is needed to design, build, test, and deploy projects, including the BPMN and DMN assets. This is where we will manipulate the DMN model. If you want to get some more information about this image, the reference page is <a href="https://quay.io/repository/kiegroup/business-central-workbench-showcase">https://quay.io/repository/kiegroup/business-central-workbench-showcase</a>. The second Docker command runs a container onto which the project will be deployed and that will act as a separate business rule execution engine, or a simple runtime if you prefer to think of it that way. The reference page for this second image is <a href="https://quay.io/repository/kiegroup/kie-server-showcase">https://quay.io/repository/kiegroup/kie-server-showcase</a>.</p>
<p>Once everything has started (you should allow for some time – up to one minute – for the completion of the startup routine), you can access the console by navigating to <code>http://localhost:8080/business-central</code>, where you will be able to connect with the default credentials, <code>admin</code>/<code>admin</code> (the documentation cited previously<a id="_idIndexMarker722"/> provides other credentials for users with different authorization profiles, as well as how to set up production-ready authorization).</p>
<div><div><img alt="Figure 12.8 – The JPBM login page" src="img/B21293_12_8.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – The JPBM login page</p>
<p>Once connected, you will be presented with the welcome page interface, which you can return to at any time by clicking on <strong class="bold">Business Central</strong>, or the home icon in the top-left part of the screen.</p>
<div><div><img alt="Figure 12.9 – The JPBM welcome page" src="img/B21293_12_9.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9 – The JPBM welcome page</p>
<p>In the <strong class="bold">Design</strong> section, click on <strong class="bold">Projects</strong>. This will bring you to an interface in which you can manage<a id="_idIndexMarker723"/> your JBPM projects:</p>
<div><div><img alt="Figure 12.10 – A list of JPBM spaces" src="img/B21293_12_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.10 – A list of JPBM spaces</p>
<p>Spaces are used to organize work and separate groups of projects from one another. In this simple tryout of the technology, simply select the existing <strong class="bold">MySpace</strong> space.</p>
<div><div><img alt="Figure 12.11 – A JPBM space without any project" src="img/B21293_12_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.11 – A JPBM space without any project</p>
<p>The space just<a id="_idIndexMarker724"/> created is, of course, empty for now. We are going to use one of the embedded examples to illustrate how JBPMN works and what we are particularly interested in right now, namely the DMN rules engine. To do so, click on <strong class="bold">Try Samples</strong>, which will bring you to the following interface:</p>
<div><div><img alt="Figure 12.12 – Choosing sample projects" src="img/B21293_12_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.12 – Choosing sample projects</p>
<p>There, select <a id="_idIndexMarker725"/>the <strong class="bold">Traffic_Violation</strong> sample project and click on <strong class="bold">OK</strong>. You should receive a message stating that the project has been correctly imported, and you will land on a page that shows the assets contained by the sample project:</p>
<div><div><img alt="Figure 12.13 – Assets of the traffic violation JBPM sample" src="img/B21293_12_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.13 – Assets of the traffic violation JBPM sample</p>
<p>Of course, the asset<a id="_idIndexMarker726"/> that interests us most is the DMN model. Click on the <strong class="bold">Traffic Violation</strong> asset to analyze it, and you will be led to the following interface, which shows the main part of the DMN model, the decision graph:</p>
<div><div><img alt="Figure 12.14 – A sample DMN decision graph" src="img/B21293_12_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.14 – A sample DMN decision graph</p>
<p>If you have a<a id="_idIndexMarker727"/> driver’s license, the understanding of this example should be self-explanatory – the violation of the speed limit provides data to calculate the associated fine. Then, depending on the fine and additional context on the driver, another decision is taken, regarding whether a suspension of the driver’s license should be invoked.</p>
<p>If you now click on the menu on the left, on the <strong class="bold">Decision Table</strong> entry of the <strong class="bold">Fine</strong> section, you will be shown the following table that describes the conditions of application of the decision:</p>
<div><div><img alt="Figure 12.15 – A sample DMN decision table" src="img/B21293_12_141.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.15 – A sample DMN decision table</p>
<p>Now, go back<a id="_idIndexMarker728"/> to the project by using the breadcrumbs menu at the top, and then click <strong class="bold">Deploy</strong> in the top menu that appears:</p>
<div><div><img alt="Figure 12.16 – The JBPM build and deploy menu" src="img/B21293_12_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.16 – The JBPM build and deploy menu</p>
<p>After a bit of time, you should see a message stating that the build is successful, and then a second one, like the one shown in the following figure, that explains that everything is now ready to exploit the decision engine:</p>
<div><div><img alt="Figure 12.17 – The JBPM deployment success notification" src="img/B21293_12_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.17 – The JBPM deployment success notification</p>
<p>If you care to take a look at the deployment results, you can activate the <strong class="bold">Menu</strong>/<strong class="bold">Execution Servers</strong> command and watch how servers are configured and deployment units are organized on them. You can then start and stop execution servers from this console, or even remove deployments:</p>
<div><div><img alt="Figure 12.18 – The JBPM servers management interface" src="img/B21293_12_18.0.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.18 – The JBPM servers management interface</p>
<p>Since everything <a id="_idIndexMarker729"/>is now set up and deployed, we are able to exploit the b<a id="_idTextAnchor466"/>usiness rules.</p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor467"/>Calling the business rule runtime</h2>
<p>Checking <a id="_idIndexMarker730"/>how effective the engine is, is simply a matter of calling a REST API that has been exposed dynamically for us to consume. In order to do so, and since the engine is (logically) exposed through a <code>POST</code> verb, we need a tool a bit more advanced than a simple web browser, such as Postman. To access the API, you will have to use the port number that was associated with the second Docker container we ran – in our example, <code>8180</code>. The rest of the URL is composed like this:</p>
<ul>
<li><code>/kie-server</code> corresponds to the application server of the rules execution engine (or <strong class="bold">BRE</strong> for <strong class="bold">Business </strong><strong class="bold">Rules Execution</strong>)</li>
<li><code>/services/rest</code> indicates that we will be accessing the REST APIs</li>
<li><code>/server/containers</code> is linked to the fact that BRE servers are exposed through containers, each deployment unit being separate from the others</li>
<li><code>/traffic-violation_1.0.0-SNAPSHOT</code> is the identity of the project that we have chosen to deploy in this unit</li>
<li><code>/dmn</code> corresponds to the resource we are interested in this project, namely the decision management system</li>
</ul>
<p>The content of <a id="_idIndexMarker731"/>the body should be adjusted to <code>raw</code>/<code>json</code> and contain the following data:</p>
<pre class="source-code">
{
    "model-namespace": "https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8",
    "dmn-context": {
        "Driver": {
            "Points": 15
        },
        "Violation": {
            "Type": "speed",
            "Actual Speed": 135,
            "Speed Limit": 100
        }
    }
}</pre> <p><code>model-namespace</code> corresponds to the unique identifier of the project, and <code>dmn-context</code> indicates the values that should be fed to the rules engine for execution. The interface should look like the following:</p>
<div><div><img alt="Figure 12.19 – A sample Postman call" src="img/B21293_12_19.0.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.19 – A sample Postman call</p>
<p>In order for this to <a id="_idIndexMarker732"/>work, you need to go to the <code>kieserver</code> as the username and <code>kieserver1!</code> as the password (these are the default values that, of course, would change if working in production):</p>
<div><div><img alt="Figure 12.20 – Postman authentication settings" src="img/B21293_12_20.0.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.20 – Postman authentication settings</p>
<p>Finally, after sending<a id="_idIndexMarker733"/> the message to the server, the complete response is the following:</p>
<pre class="source-code">
{
  "type" : "SUCCESS",
  "msg" : "OK from container 'traffic-violation_1.0.0-SNAPSHOT'",
  "result" : {
    "dmn-evaluation-result" : {
      "messages" : [ ],
      "model-namespace" : "https://github.com/kiegroup/drools/kie-dmn/_A4BCA8B8-CF08-433F-93B2-A2598F19ECFF",
      "model-name" : "Traffic Violation",
      "decision-name" : [ ],
      "dmn-context" : {
        "Violation" : {
          "Type" : "speed",
          "Speed Limit" : 100,
          "Actual Speed" : 115
        },
        "Driver" : {
          "Points" : 15
        },
        "Fine" : {
          "Points" : 3,
          "Amount" : 500
        },
        "Should the driver be suspended?" : "No"
      },
      "decision-results" : {
        "_4055D956-1C47-479C-B3F4-BAEB61F1C929" : {
          "messages" : [ ],
          "decision-id" : "_4055D956-1C47-479C-B3F4-BAEB61F1C929",
          "decision-name" : "Fine",
          "result" : {
            "Points" : 3,
            "Amount" : 500
          },
          "status" : "SUCCEEDED"
        },
        "_8A408366-D8E9-4626-ABF3-5F69AA01F880" : {
          "messages" : [ ],
          "decision-id" : "_8A408366-D8E9-4626-ABF3-5F69AA01F880",
          "decision-name" : "Should the driver be suspended?",
          "result" : "No",
          "status" : "SUCCEEDED"
        }
      }
    }
  }
}</pre> <p>What interests us in particular is how <code>dmn-context</code> has been completed, with the results of the <a id="_idIndexMarker734"/>decision. In our case, the fine will be 3 points and 500 units of money, and the result of the driver’s license suspension decision will be negative. But change <code>Actual Speed</code> to <code>135</code> in the body of the request, send it again, and watch the impact on the results:</p>
<pre class="source-code">
        "Fine" : {
          "Points" : 7,
          "Amount" : 1000
        },
        "Should the driver be suspended?" : "Yes"</pre> <p>The engine is, thus, ready to be used in any information system that can handle REST APIs (which is any platform on earth, except for a few very exotic exceptions). Note there is also everything you need inside the JBPM platform to perform tests on the decisions that have been built. A test with Postman was preferred because it is closer to how the BRE would be exploited by another application, but if you click on the <code>Violation Scenarios</code> asset, you will be brought to this nice interface, where you can execute preliminary tests in order to make sure everything works fine before deployment:</p>
<div><div><img alt="Figure 12.21 – A JBPM-integrated automatic test interface" src="img/B21293_12_21.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.21 – A JBPM-integrated automatic test interface</p>
<p>Also, if you want to understand better how to create your own project (which is outside of the scope of this book, where we focus only on how to use existing projects to correctly structure an information system), the best starting point is the code source of the example used previously, which can be found at <a href="https://github.com/kiegroup/kie-wb-playground/tree/main/traffic-violation">https://github.com/kiegroup/kie-wb-playground/tree/main/traffic-violation</a>. You can also follow the detailed instructions on how to build this project from the console, as explained at <a href="https://docs.jboss.org/drools/release/7.51.0.Final/drools-docs/html_single/#dmn-gs-new-project-creating-proc_getting-started-decision-services">https://docs.jboss.org/drools/release/7.51.0.Final/drools-docs/html_single/#dmn-gs-new-project-creating-proc_getting-started-decision-services</a>.</p>
<p>Finally, we will <a id="_idIndexMarker735"/>complete this example with a very simple (thanks to Docker) clean-out procedure (be aware that this will erase all data associated with the exercise):</p>
<pre class="console">
docker rm -fv jbpm-console
docker rm -fv jbpm-bre</pre> <p>Everything should be reverted to the state the test machine was in before creating this example, which leaves us with the conclusion<a id="_idTextAnchor468"/> of this chapter.</p>
<h1 id="_idParaDest-264"><a id="_idTextAnchor469"/>Summary</h1>
<p>In this chapter, we showed what a Business Rules Management System does, how useful it can be in an information system, and how we can implement one, starting with a functional example and demonstrating afterward another example relating to authorizations, which are one of the most used sets of business rules in software applications.</p>
<p>Just like BPMN engines, BRMS engines are not used very often. In fact, business rules are – in the great majority of cases – implemented in code expressions or compiled into applications. This is absolutely normal because a BRMS represents an important investment, and implementing such complex applications really needs a strong business case, where business rules change very frequently, they are associated with high regulatory or marketing constraints (such as the necessity to trace all business rules and their changes), there is capacity to simulate the effects of new versions of sets of business rules, and so on. It is clear, then, that this approach is currently limited to very rare contexts. Things may, of course, change in the future, with the longed-for industrialization of information system designs, but currently, BPMNs and BRMSs are efforts that are almost always overkill.</p>
<p>And since two of the three parts of the ideal system are not worth using by most organizations, that means that this system remains utopic. Moreover, even a centralized MDM approach is complicated. The MDM practices per se are applicable to every business domain, so there is no problem with data referential – they are not very complicated to set up, as we will see in practice in <a href="B21293_16.xhtml#_idTextAnchor588"><em class="italic">Chapter 16</em></a> and the upcoming chapters and they bring lots of business value and advantages. However, the ideal system aims for a generic MDM, dynamically adjusting to every entity in the business context of an application. This additional sophistication is also out of context for now, although static code generation for data referential is becoming a viable option, as will be shown at the end of <a href="B21293_19.xhtml#_idTextAnchor634"><em class="italic">Chapter 19</em></a>.</p>
<p>In addition, we have shown that the three responsibilities of an ideal information system are, ultimately, quite interrelated with each other:</p>
<ul>
<li>MDM uses business rules in its validation of data</li>
<li>A BRMS needs data from MDM to apply business rules and decide their output value</li>
<li>A BPMN serves mainly as a collector of data to feed MDM, while also consuming data from MDM</li>
<li>A BPMN also uses business rules to know where to go in the different gateways (and sometimes to calculate some additional data during a given task)</li>
</ul>
<p>All this proves that, technically, this assembly of three generic servers for MDM, BPM, and BRMS is not so feasible, and neither achieves a perfect decoupling. So, why did we bother in <a href="B21293_05.xhtml#_idTextAnchor164"><em class="italic">Chapter 5</em></a> and the last three chapters to discuss such an ideal system? Again, the answer lies in the business/IT alignment. The ideal system is not something that can be realized in practice in information systems today (and certainly for at least a few more decades), but it has the great advantage of forcing an architect to think in terms of three generic, always applicable, functional responsibilities. Even if you use a unique software application, knowing how to separate the data management, the business rules management, and the business process execution provides a great step toward decoupling your information system (which is not achieved at all with <em class="italic">n</em>-tier architecture, for example). As you will see in the upcoming chapters, constructing an information system with these principles in mind will help us achieve a very complex goal, which is to be able to modify important functional rules and behaviors very easily, in most cases without any significant impact on the implementation.</p>
<p>In the next chapter, as explained in the introduction, we will show a particular use case – yet very important application – of business rules management, which is using rules to determine and enforce authorization in a software application. Although we have shown a few examples in this chapter, the most complete description of how to use a BRMS will happen in the next chapter, by applying dedicated authorization management policies to our good old sample information system.</p>
</div>
</body></html>