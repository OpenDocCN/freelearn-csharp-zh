- en: Filter Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover another essential topic in ASP.NET Core: the
    filter pipeline. Filters are a vital component that we can use to achieve cross-cutting
    implementation in our services. Although we have already seen how to implement
    cross-functionalities using the middleware pipeline, filters are more specialized
    components that are linked to the MVC pipeline. Therefore, filters can be used
    to implement more specific logic, related to the controller''s execution. This
    chapter will show you how to implement these filters and will describe some concrete
    use cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to filters in ASP.NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement and apply filters to the filter pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some concrete use cases for filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use resolve dependencies in the filter pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter provides information about the filter stack in .NET Core and how
    to use filters to enhance the features of our web services.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Filters come in handy when we wish to build *cross-cutting concepts* in the
    MVC stack of ASP.NET Core. They are useful when we wish to implement features
    such as authorization or caching. ASP.NET Core provides some out-of-the-box filter
    types. Each of these can be used for a specific purpose in our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Filter type** | **Type description** |'
  prefs: []
  type: TYPE_TB
- en: '| Authorization | This kind of filter is related to the authorization of users.
    It is the first filter that''s executed in the filter pipeline and can short-circuit
    the pipeline of requests. |'
  prefs: []
  type: TYPE_TB
- en: '| Resource | Resource filters run immediately after authorization filters and
    after the rest of the pipeline has completed. They''re useful when we wish to
    implement caching or for performance implementations. |'
  prefs: []
  type: TYPE_TB
- en: '| Action | Action filters are focused on the life cycle of action methods.
    They intercept and change the arguments and the returning results of action methods.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Exception | Exception filters are used to intercept and apply cross-cutting
    policies to unhandled exceptions. |'
  prefs: []
  type: TYPE_TB
- en: '| Result | Result filters are executed immediately before and after the execution
    of an action result. They are usually implemented to change the formatting of
    the outcome. It is essential to note that they are executed only when the action
    method is completed successfully. |'
  prefs: []
  type: TYPE_TB
- en: It is crucial to note that filters act in the domain of the MVC middleware,
    which implies that action filters are unable to operate outside the MVC context.
    Therefore, filters are more specific than middleware; they can be applied to a
    subset of requests, and they have access to some MVC components, for example,
    `ModelState`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the workflow of different types of action filters
    in a request-response workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28daf453-5ea7-445f-af69-e684ee2c4393.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, in a request-response pipeline, different types of filters act
    at various stages. *Authorization filters* act before everything else and block
    the requests in the event any of the privileges are wrong. *Resource filters*
    operate before model validation and model binding of the request and also when
    the results of our request come back from the server. The *action filter* type
    acts before and after an action's invocation. Furthermore, if an action throws
    an exception, the *exception filter* is triggered. At the end of the pipeline,
    the *result filter* operates on the `IActionResult` final object instance. Now
    that we know about the different filter types that are provided by ASP.NET Core,
    we will look at some concrete implementation examples.
  prefs: []
  type: TYPE_NORMAL
- en: Concrete filter implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general, filters can be implemented by extending the built-in types provided
    by ASP.NET Core. Let''s walk through a simple declaration of a custom action filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CustomActionFilter` class implements the `IActionFilter` interface type,
    which offers two different methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The `OnActionExecuting` method is triggered before the execution of the action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OnActionExecuted` method is executed after the action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both methods receive the execution `context` as a callback parameter, which
    provides some useful information about the *filter's stack metadata*, the *controllers*,
    the *action arguments*, and *route data*. Furthermore, the `context` parameter
    also provides access to the `HttpContext` attribute we looked at in previous chapters.
    The `HttpContext` provides all the necessary properties so that we can access
    dependency injection services and the request/response data. ASP.NET Core heavily
    uses the asynchronous stack. This means it also provides an interface that we
    can use to implement asynchronous filters.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Filters support both asynchronous and synchronous behaviors. As we saw in the
    previous example, `CustomActionFilter` implements two synchronous methods: `OnActionExecuting`
    and `OnActionExecuted`. In the case of an asynchronous filter, the implementation
    is different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`CustomActionFilterAsync` implements the `async` version of the action filter
    class, that is, `IAsyncActionFilter`, and implements only one method, that is,
    `OnActionExecutionAsync`. This template is similar to a middleware implementation;
    the `next()` method triggers the execution of the rest of the pipeline. Therefore,
    everything before the `await next()` statement is executed before the execution
    of the action filter, while everything after the `await next()` statement is performed
    after the action''s execution. It is essential to note that the framework searches
    for the `async` implementation first and then for the *synchronous* implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: The scope of filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Filters inherit a different scope based on their initialization in our codebase.
    In practice, a filter may have three different scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global scope**: This means that the filter covers the whole MVC pipeline.
    Every call to a specific MVC route will pass through that filter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller scope**: In this case, the filter is initialized as an attribute
    in one or multiple controller classes. It will act only on requests that have
    been directed to the target controllers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Action scope:** The filter is initialized as an attribute in one or multiple
    action methods. It will act only on requests that have been directed to the target
    methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is also essential to understand that filters are executed, depending on
    the scope, in a specific order: first of all, all *global scope filters* run,
    followed by *controller scope filters*, and finally *action scope filters*. In
    the next subsection, we will look at the implementation of the different scopes
    in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: The use of filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned previously, filters can have three different scopes: *global*,
    *controller*, and *action*. In the first case, the filter is applied globally
    in the `Startup` class. In the other two cases, the filter is used in the form
    of an attribute and is usually applied to the controller class definition or the
    action method definition. Let''s take a closer look at these different approaches.
    The application of a filter in the `Startup` class means that the filter covers
    all the routes in the MVC pipeline, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `CustomFilter` has a *global scope.* The `config.Filters` attribute
    is a collection of `IFilterMetadata` interfaces. This interface is used to describe
    the filters that are present in our MVC pipeline. It should be noted that the
    collection doesn't check duplicates, which means that we may potentially add two
    filters of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Since `FilterCollection` doesn't consider duplicates, it is possible that, in
    a large codebase, a filter type is accidentally initialized more than once, which
    may affect the performance of our service. It is vital to pay attention to code
    merges, especially in a distributed team. By using pull requests and holding code
    review meetings, this kind of silent issue can be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand*,* the *controller scope* and the *action scope* are restricted
    to a specific controller or action. The best way to use a filter on a particular
    controller or action is by extending a filter attribute. ASP.NET Core provides
    some built-in filter attributes. For each filter type, the framework provides
    a corresponding class that provides methods for overriding. For example, this
    is the case for the `ActionFilterAttribute` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CustomControllerFilter` extends the `ActionFilterAttribute` type, which
    contains the `OnActionExecuting` and `OnActionExecuted` methods. The filter can
    be applied to a specific controller class or action method using the syntax of
    the attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the hood, `ActionFilterAttribute` is an abstract class and implements
    the `IActionFilter` interface type, which we looked at previously. Therefore,
    by taking a quick look at the `ActionFilterAttribute` class, we can assume that
    this abstract class also provides the `IAsyncActionFilter`, `IResultFilter`, and
    `IAsyncResultFilter` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet describes how ASP.NET Core always provides an easy
    way for us to customize and extend the behavior of our frameworks. Furthermore,
    the user has full control over the code and the interfaces provided by the framework.
    Eventually, we can easily create a custom abstract type that implements a custom
    behavior for the filter and can be extended by other concrete filter classes.
  prefs: []
  type: TYPE_NORMAL
- en: Life cycle and dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already said, Dependency injection is a core technique in ASP.NET Core.
    Filters usually rely on other components to provide the filter logic. Before discussing
    injecting dependencies in filters, we need to understand the life cycle process.
    In general, when we apply a filter as an attribute, the life cycle of the filter
    is restricted to the request, which means that it is reinitialized for each request.
    The `ServiceFilter` attribute provides a valid alternative to overriding this
    kind of behavior. Therefore, the `ServiceFilter` attribute uses the *service provider*
    to create filter objects, which means that our filter is managed just like any
    other service declared through the dependency injection system of ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s consider the implementation of the `CustomActionFilter`
    class we defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to initialize the `CustomActionFilter` type using the `AddSingleton`
    extension method in the `Startup` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use it in our controllers or action methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach guarantees that we override the life cycle of the filters by
    explicitly defining the life cycle type in the *service provider*. Therefore,
    the filter pipeline is integrated and initialized using the dependency injection
    engine of ASP.NET Core. Moreover, it is also possible to resolve filter dependencies
    using the dependency injection engine. There are two injection techniques related
    to filters:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `ServiceFilter` technique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `TypeFilterAttribute` technique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we saw previously, the `ServiceFilter` type adds the instance of filters
    in the service provider. It is possible to inject the dependency into a filter
    by adding it to the constructor. We can do this using *constructor injection*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code injects the `ILogger` interface into the constructor and
    uses the exposed `LogInformation` extension method. It is also possible to not
    pass through the *service provider* using `TypeFilterAttribute` by referring to
    our filter using the type and not the instance. We do this by declaring another
    class that extends `TypeFilterAttribute`, which passes the type of our filter
    to the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then it applies the attribute to the target controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `CustomActionFilterAttribute` class extends the `TypeFilterAttribute` base
    class and calls the base constructor by referring to the `CustomActionFilter`
    type. This approach enhances the usability of filter attributes that depend on
    other classes. Now that we have a complete understanding of filters and know how
    to apply them to the filter pipeline, we can take a look at some concrete use
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: Filter use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will show some concrete use cases for filters. In general, each
    time you have to replicate the behavior in an action or a controller, you can
    use filters to centralize the logic. Filters also provide a declarative approach,
    which helps us keep your code clean and readable.
  prefs: []
  type: TYPE_NORMAL
- en: Existing entity constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Action methods of controllers usually perform constraints on incoming data.
    A common practice is to centralize that kind of logic in filters. Let''s take,
    for example, `OrderController`, which we discussed in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Three out of five action methods perform the same *existing check* by calling
    `_orderRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A recommended practice is to extract this logic and put it somewhere else,
    possibly an action filter, so that it can be used across action methods. It is
    specific enough to be used only when necessary. Let''s start by setting up our
    filter and adding the dependency with `IOrderRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `OrderExistsFilterImpl` class provides the basic setup for an action filter.
    It accepts `IOrderRepository` as a dependency and implements `OnActionExecutionAsync`.
    This implementation class is contained in an attribute class that implements `TypeFilterAttribute`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After declaring the attribute class, we can proceed by implementing the logic.
    `OrderExistsAttribute` has three purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: To check whether the incoming request contains an `id`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To check whether the requested `id` is a `Guid`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To query `IOrderRepository` to check whether the entity exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s proceed by describing a possible implementation of the previous logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First of all, the code checks whether our action arguments, which are populated
    by the model binder, contain any key by using the `!context.ActionArguments.ContainsKey("id")`
    statement. If the check is not true, the action filters interrupt the pipeline
    by adding a `BadRequestResult` to the response and exiting from the method. Secondly,
    the code checks whether the requested `id` is a `Guid` using `!(context.ActionArguments["id"]
    is Guid id)`. In this case, if the condition fails, it returns a `BadRequestResult`
    and interrupts the pipeline. Finally, the action filter calls `IOrderRepository`
    and checks whether the requested entity exists. If the test is positive, it continues
    the pipeline by calling the `await next();` method; otherwise, it returns a `BadRequestResult`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In conclusion, we can add our attribute on top of methods that perform the
    actual checks and remove the previously replicated code that''s inside each action
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This kind of approach is compliant with the *DRY principle*. Furthermore, we
    can reuse the filter and handle the logic in a unique entry point.
  prefs: []
  type: TYPE_NORMAL
- en: Before ASP.NET Core 2.1, the same approach was used to check whether a model
    was valid. Instead of replicating the `Model.IsValid` *check-in* in each action,
    the logic was centralized in an action filter. With the introduction of the built-in
    `ApiController` attribute, the constraint has now become implicit.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's have a look at altering exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Altering exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common use for filters is changing the response of a specific request.
    Filters are handy in these cases because they can only be applied to particular
    action methods. Some services need to return a custom format to the client, for
    example, when they are used by a legacy system that only accepts a specific format
    or when they need to provide a response that's been wrapped by a particular envelope.
    ASP.NET Core provides the `IExceptionFilter` interface for this, which allows
    us to overload the exceptions and send a custom response to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, if an exception is thrown, it follows two different behaviors,
    depending on the environment. If the API triggers an exception and it is running
    in a development environment, it returns a current detailed exception page, which
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/522af6fe-6a31-491b-a5d1-24e2db25c19d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we are in a *production environment,* it merely returns a generic `500 Internal
    Server Error`. These two behaviors are defined by default in the out of the box
    Web API template of ASP.NET Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In a real-world application, it is usually necessary to provide detailed information
    to the client, thereby guaranteeing reliable communication between the server
    and the client.
  prefs: []
  type: TYPE_NORMAL
- en: In real-world applications, errors are an essential part of services. In some
    cases, companies institute an internal error code definition so that they can
    build more flexible APIs that can handle errors in a better way and establish
    resilient communication between themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement custom exceptions, we should extend the `IExceptionFilter` interface.
    The following code is a possible implementation of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The framework invokes the `HttpCustomExceptionFilterImpl` class each time an
    exception is thrown. The class has two dependencies: `ILogger` and `IWebHostEnvironment`.
    The `OnException` method logs the exception using the `ILogger` class and creates
    a new instance of `JsonErrorPayload`, which contains a generic message and some
    details about the exception. Finally, the `OnException` method returns the `500
    Internal server error` status code, as well as the `exceptionObject` that was
    just created.'
  prefs: []
  type: TYPE_NORMAL
- en: The detailed exception message may have some value, depending on `IWebHostEvinronment`.
    This kind of approach is useful in a production context to avoid revealing sensitive
    information about the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In conclusion, if our service throws an exception, our `IExceptionFilter` transforms
    it into a new JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some filter concepts in ASP.NET Core. We introduced
    different types of filters, how they work, and the specific purpose of each kind
    in the MVC pipeline. We have also seen how to implement filters and explored some
    concrete use cases to understand and discover the power of filters so that we
    can achieve cross-cutting concerns.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is dedicated to the data access layer methodologies in ASP.NET
    Core. You will be introduced to the repository pattern, which will describe the
    implementation of the data access layer using EF Core and Dapper. Furthermore,
    we will also describe some testing techniques that verify the data access layer
    part of an ASP.NET Core application.
  prefs: []
  type: TYPE_NORMAL
