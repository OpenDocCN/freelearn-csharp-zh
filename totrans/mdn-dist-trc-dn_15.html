<html><head></head><body>
<div id="_idContainer149">
<h1 class="chapter-number" id="_idParaDest-234"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.1.1">15</span></h1>
<h1 id="_idParaDest-235"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.2.1">Instrumenting Brownfield Applications</span></h1>
<p><span class="koboSpan" id="kobo.3.1">When building brand-new services and systems, it’s easy to achieve a basic level of observability with distributed traces, metrics, and logs using OpenTelemetry </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">instrumentation libraries.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">However, we don’t usually create applications from scratch – instead, we evolve existing systems that include services in different stages of their life, varying from experimental to legacy ones that are too risky </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">to change.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Such systems normally have some monitoring solutions in place, with custom correlation formats, telemetry schemas, logs and metrics management systems, dashboards, alerts, as well as documentation and processes around </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">these tools.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we’ll explore instrumentation options</span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.10.1"> for such heterogeneous systems, which are frequently referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.11.1">brownfield</span></strong><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">First, we’ll discuss instrumentation options for legacy parts of the system and then look deeper into context propagation and interoperating with legacy correlation formats. </span><span class="koboSpan" id="kobo.12.3">Finally, we’ll talk about existing monitoring solutions and investigate </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">migration strategies.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">You’ll learn to do </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.16.1">Pick a reasonable level of instrumentation for </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">legacy services</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Leverage legacy correlation formats or propagate context transparently to enable </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">end-to-end tracing</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Forward telemetry from legacy services to new </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">observability backends</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.22.1">By the end of this chapter, you will be able to implement distributed tracing in your brownfield application, keeping changes to legacy parts of a system to </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">a minimum.</span></span></p>
<h1 id="_idParaDest-236"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.24.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.25.1">The code for this chapter is available in the book’s repository on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter15"><span class="No-Break"><span class="koboSpan" id="kobo.27.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter15</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.28.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">To run samples for this chapter, we’ll need a Windows machine with the </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">following tools:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.31.1">.NET SDK 7.0 </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">or later</span></span></li>
<li><span class="koboSpan" id="kobo.33.1">.NET </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">SDK 4.6.2</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">docker-compose</span></strong></span></li>
</ul>
<h1 id="_idParaDest-237"><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.38.1">Instrumenting legacy services</span></h1>
<p><span class="koboSpan" id="kobo.39.1">The word </span><strong class="bold"><span class="koboSpan" id="kobo.40.1">legacy</span></strong><span class="koboSpan" id="kobo.41.1"> has a negative connotation in software </span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.42.1">development, implying something out of date and not exciting to work on. </span><span class="koboSpan" id="kobo.42.2">In this section, we will focus on a different aspect and define a legacy service as something that mostly successfully does its job but no longer evolves. </span><span class="koboSpan" id="kobo.42.3">Such services may still receive security updates or fixes for critical issues, but they don’t get new features, refactoring, </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">or optimizations.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">Maintaining such a service requires a different set of skills and fewer people than the evolving one, so the context of a specific system can easily get lost, especially after the team that was developing it moved on and now works on </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">something else.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">As a result, changing such components is very risky, even when it comes to updating runtime or dependency versions. </span><span class="koboSpan" id="kobo.46.2">Any modification might wake up dormant issues, slightly change performance, causing new race conditions or deadlocks. </span><span class="koboSpan" id="kobo.46.3">The main problem here is that with limited resources and a lack of context, nobody might know how a service works, or how to investigate and fix such issues. </span><span class="koboSpan" id="kobo.46.4">There also may no longer be appropriate test infrastructure to </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">validate changes.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">From an observability standpoint, such components usually have some level of monitoring in place, which is likely to be sufficient for </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">maintenance purposes.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">Essentially, when working on the observability of a system, we would touch legacy services only when it’s critical for newer parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">Let’s look at a couple of examples to better understand when changing legacy service is important and how we can minimize </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">the risks.</span></span></p>
<h2 id="_idParaDest-238"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.54.1">Legacy service as a leaf node</span></h2>
<p><span class="koboSpan" id="kobo.55.1">Let’s assume we’re building new parts</span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.56.1"> of the system using a few legacy services as a dependency, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.57.1">Figure 15</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.58.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer144">
<span class="koboSpan" id="kobo.60.1"><img alt="Figure 15.1 – New services depend on legacy ones" src="image/B19423_15_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.61.1">Figure 15.1 – New services depend on legacy ones</span></p>
<p><span class="koboSpan" id="kobo.62.1">For the purposes of our new observability solution, we may be able to treat a legacy system as a black box. </span><span class="koboSpan" id="kobo.62.2">We can trace client calls to the legacy components and measure client-side latency and other stats. </span><span class="koboSpan" id="kobo.62.3">Sometimes, we’ll need to know what happens inside the legacy component – for example, to understand client-side issues or work around legacy system limitations. </span><span class="koboSpan" id="kobo.62.4">For this, we can leverage existing logging and monitoring tools available in the legacy services. </span><span class="koboSpan" id="kobo.62.5">It could be inconvenient, but if it is rare, it can be a </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">reasonable option.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">If legacy components support any correlation headers for incoming requests, we can populate them on the client side to correlate across different parts of a system. </span><span class="koboSpan" id="kobo.64.2">We’ll look at this in the </span><em class="italic"><span class="koboSpan" id="kobo.65.1">Propagating context</span></em><span class="koboSpan" id="kobo.66.1"> section of </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">Another thing we may be able to do without changing a legacy system is forking and forwarding its telemetry to the same observability backend – we’ll take a closer look at this in the </span><em class="italic"><span class="koboSpan" id="kobo.69.1">Consolidating telemetry from legacy-monitoring </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.70.1">tools</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.71.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">Being able to correlate telemetry from new and legacy components and store it in the same place could be enough to debug occasional </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">integration issues.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">Things get more interesting if a legacy system is in the middle of our application – let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">see why.</span></span></p>
<h2 id="_idParaDest-239"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.76.1">A legacy service in the middle</span></h2>
<p><span class="koboSpan" id="kobo.77.1">When we refactor</span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.78.1"> a distributed system, we can update downstream and upstream services around a legacy component, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.79.1">Figure 15</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.80.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer145">
<span class="koboSpan" id="kobo.82.1"><img alt="Figure 15.2 – Legacy service-b is in between the newer service-a and service-c" src="image/B19423_15_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.83.1">Figure 15.2 – Legacy service-b is in between the newer service-a and service-c</span></p>
<p><span class="koboSpan" id="kobo.84.1">From the tracing side, the challenge here is that the legacy component does not propagate W3C Trace Context. </span><span class="koboSpan" id="kobo.84.2">Operations that go through </span><strong class="bold"><span class="koboSpan" id="kobo.85.1">legacy-service-b</span></strong><span class="koboSpan" id="kobo.86.1"> are recorded as two traces – one started by </span><strong class="bold"><span class="koboSpan" id="kobo.87.1">service-a</span></strong><span class="koboSpan" id="kobo.88.1"> and another started </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">by </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.90.1">service-c</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">We need to either support legacy context propagation format in newer parts of the system, or update the legacy component itself to enable </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">context propagation.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">Before we go into the context propagation details, let’s discuss the appropriate level of changes we should consider applying to a service, depending on the level of </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">its maturity.</span></span></p>
<h2 id="_idParaDest-240"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.96.1">Choosing a reasonable level of instrumentation</span></h2>
<p><span class="koboSpan" id="kobo.97.1">Finding the right level of instrumentation</span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.98.1"> for mature parts of a system depends on how big of a change is needed and how risky it is. </span><span class="koboSpan" id="kobo.98.2">Here are several things </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">to consider:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.100.1">Where do legacy services send telemetry to? </span><span class="koboSpan" id="kobo.100.2">Is it the same observability backend that we want to use for the </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">newer parts?</span></span></li>
<li><span class="koboSpan" id="kobo.102.1">How critical is it for the observability of the overall system to get telemetry from </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">legacy components?</span></span></li>
<li><span class="koboSpan" id="kobo.104.1">Do legacy services support some context propagation format? </span><span class="koboSpan" id="kobo.104.2">Can we interoperate with it from </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">newer services?</span></span></li>
<li><span class="koboSpan" id="kobo.106.1">Can we change some of our legacy services? </span><span class="koboSpan" id="kobo.106.2">How old is the .NET runtime? </span><span class="koboSpan" id="kobo.106.3">Do we have an adequate testing infrastructure? </span><span class="koboSpan" id="kobo.106.4">How big is the load on this service? </span><span class="koboSpan" id="kobo.106.5">How critical is </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">the</span></span><span class="No-Break"><a id="_idIndexMarker738"/></span><span class="No-Break"><span class="koboSpan" id="kobo.108.1"> component?</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.109.1">Let’s go through a few solutions that may apply, depending on </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">your answers.</span></span></p>
<h3><span class="koboSpan" id="kobo.111.1">Not changing legacy services</span></h3>
<p><span class="koboSpan" id="kobo.112.1">When legacy parts of a system</span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.113.1"> are instrumented with a vendor-specific SDK or agent and send telemetry to the same observability backend as we want to use for newer parts, we might not need to do anything – correlation might work out of the box or with a little context propagation adapter in newer parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">Your vendor might have a migration plan and documentation explaining how to make services, using their old SDK and OpenTelemetry-based solution, produce </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">consistent telemetry.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">Another case when doing nothing is a good option is when our legacy components are mostly isolated and either work side by side with newer parts or are leaf nodes, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.118.1">Figure 15</span></em></span><em class="italic"><span class="koboSpan" id="kobo.119.1">.1</span></em><span class="koboSpan" id="kobo.120.1">. </span><span class="koboSpan" id="kobo.120.2">Then, we can usually develop and debug new components without data from </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">legacy services.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">We could also be able to tolerate having broken traces, especially if they don’t affect critical flows and we’re going to retire legacy </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">services soon.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">Doing nothing is the best, but if it’s problematic for overall observability, the next discreet option is passing context though a </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">legacy system.</span></span></p>
<h3><span class="koboSpan" id="kobo.126.1">Propagating context only</span></h3>
<p><span class="koboSpan" id="kobo.127.1">If newer parts communicate with legacy services</span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.128.1"> back and forth and we can’t make trace context propagation work, it can prevent us from tracing critical operations through a system. </span><span class="koboSpan" id="kobo.128.2">The least invasive change we can do then is to transparently propagate trace context through a </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">legacy service.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">When such a service receives a request, we would read the trace context in W3C (B3, or another format) and then pass it through, without any modification to all </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">downstream services.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">This way, legacy services will not appear on traces, but we will have consistent end-to-end traces for the </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">newer parts.</span></span></p>
<p><span class="koboSpan" id="kobo.134.1">We can possibly go further and stamp trace context on the legacy telemetry to </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">simplify debugging.</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">If transparent context propagation</span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.137.1"> is still not enough and we need to have telemetry from all services in one place, the next option to consider is forking legacy telemetry and sending it to the new </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">observability backend.</span></span></p>
<h3><span class="koboSpan" id="kobo.139.1">Forwarding legacy telemetry to the new observability backend</span></h3>
<p><span class="koboSpan" id="kobo.140.1">Debugging issues across different observability</span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.141.1"> backends and log management tools can be challenging, even when data </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">is correlated.</span></span></p>
<p><span class="koboSpan" id="kobo.143.1">To improve it, we may be able to intercept telemetry from the legacy system on the way to its backend or enable continuous export from that backend to the new one used by the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">Forwarding may require configuration changes on the legacy system, and even if such changes are small, there is still a risk of slowing down the telemetry pipeline and causing an incident for the </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">legacy service.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">The younger and the more flexible the system is, the more changes we can consider, and the most invasive one is onboarding a legacy system onto OpenTelemetry and enabling </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">network instrumentations.</span></span></p>
<h3><span class="koboSpan" id="kobo.149.1">Adding network-level instrumentation</span></h3>
<p><span class="koboSpan" id="kobo.150.1">It’s likely that legacy telemetry</span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.151.1"> is not consistent with distributed traces coming from new services. </span><span class="koboSpan" id="kobo.151.2">We may be able to transform it, or can sometimes tolerate the difference, but we may as well consider enabling minimalistic distributed tracing in legacy services. </span><span class="koboSpan" id="kobo.151.3">This will take care of context propagation and produce consistent telemetry with the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">With this approach, we’ll pump new telemetry from legacy services to the new backend and keep all existing instrumentations and pipelines running to avoid breaking existing reports, dashboards, </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">and alerts.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">Something to be aware of here is that OpenTelemetry works on .NET 4.6.2 or newer versions of .NET. </span><span class="koboSpan" id="kobo.155.2">While instrumentations</span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.156.1"> for IIS, classic ASP.NET, and OWIN are available in the </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">contrib</span></strong><span class="koboSpan" id="kobo.158.1"> repository (at </span><a href="https://github.com/open-telemetry/opentelemetry-dotnet-contrib"><span class="koboSpan" id="kobo.159.1">https://github.com/open-telemetry/opentelemetry-dotnet-contrib</span></a><span class="koboSpan" id="kobo.160.1">), such instrumentations do not get as much love as </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">newer ones.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">You might also hit some edge cases with </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.164.1"> when using IIS – it can get lost during hopping between managed and </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">native threads.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">Onboarding existing services to OpenTelemetry while keeping old tools working can be a first step in a migration project, which eventually sunsets legacy </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">monitoring solutions.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">This is a viable solution</span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.169.1"> for any mature service and should be considered unless the service is on a retirement path already. </span><span class="koboSpan" id="kobo.169.2">However, if it’s not an option, we can still combine and evolve other approaches mentioned here. </span><span class="koboSpan" id="kobo.169.3">Let’s now look at the practical side and see how we can </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">do it.</span></span></p>
<h1 id="_idParaDest-241"><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.171.1">Propagating context</span></h1>
<p><span class="koboSpan" id="kobo.172.1">The first goal for context propagation</span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.173.1"> is to enable end-to-end distributed tracing for new services, even when they communicate through legacy ones, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.174.1">Figure 15</span></em></span><em class="italic"><span class="koboSpan" id="kobo.175.1">.2</span></em><span class="koboSpan" id="kobo.176.1">. </span><span class="koboSpan" id="kobo.176.2">As a stretch goal, we can also try to correlate telemetry from new and </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">legacy parts.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">The solution that would work in most cases involves enabling context propagation in legacy services. </span><span class="koboSpan" id="kobo.178.2">Depending on how legacy services are implemented, this change can be significant and risky. </span><span class="koboSpan" id="kobo.178.3">So, before we do it, let’s check whether we can </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">avoid it.</span></span></p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.180.1">Leveraging existing correlation formats</span></h2>
<p><span class="koboSpan" id="kobo.181.1">Our legacy services might already propagate</span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.182.1"> context, just in a different format. </span><span class="koboSpan" id="kobo.182.2">One popular approach is to pass a correlation ID that serves the same purpose as a trace ID in the W3C Trace Context standard, identifying a logical </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">end-to-end operation.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">While correlation ID is not compatible with trace context out of the box, it may be possible to translate one </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">to another.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">In a simple case, correlation ID is just a string, and then we just need to pass it to the legacy service in a header. </span><span class="koboSpan" id="kobo.186.2">Then, we can expect it to propagate it as is to downstream calls, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.187.1">Figure 15</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.188.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer146">
<span class="koboSpan" id="kobo.190.1"><img alt="Figure 15.3 – Passing the W3C Trace ID via a legacy correlation header" src="image/B19423_15_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.191.1">Figure 15.3 – Passing the W3C Trace ID via a legacy correlation header</span></p>
<p><span class="koboSpan" id="kobo.192.1">Here, </span><strong class="bold"><span class="koboSpan" id="kobo.193.1">service-a</span></strong><span class="koboSpan" id="kobo.194.1"> populates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">correlation-id</span></strong><span class="koboSpan" id="kobo.196.1"> header along with </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">traceparent</span></strong><span class="koboSpan" id="kobo.198.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.199.1">legacy-service-B</span></strong><span class="koboSpan" id="kobo.200.1"> picks </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">correlation-id</span></strong><span class="koboSpan" id="kobo.202.1"> up, ignoring the unknown </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">traceparent</span></strong><span class="koboSpan" id="kobo.204.1">, and passes it over to </span><strong class="bold"><span class="koboSpan" id="kobo.205.1">service-c</span></strong><span class="koboSpan" id="kobo.206.1">. </span><span class="koboSpan" id="kobo.206.2">In turn, </span><strong class="bold"><span class="koboSpan" id="kobo.207.1">service-c</span></strong><span class="koboSpan" id="kobo.208.1"> supports both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">traceparent</span></strong><span class="koboSpan" id="kobo.210.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">correlation-id</span></strong><span class="koboSpan" id="kobo.212.1"> values. </span><span class="koboSpan" id="kobo.212.2">It only has </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">correlation-id</span></strong><span class="koboSpan" id="kobo.214.1">, so it uses it to continue the trace started </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">by </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.216.1">service-a</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">Let’s implement</span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.219.1"> it with a custom OpenTelemetry context propagator, starting with the injection side, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">code snippet:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.221.1">CorrelationIdPropagator.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.222.1">
public override void Inject&lt;T&gt;(PropagationContext context,
  T carrier, Action&lt;T, string, string&gt; setter)
{
  if (context.ActivityContext.IsValid())
</span><strong class="bold"><span class="koboSpan" id="kobo.223.1">    </span></strong><strong class="bold"><span class="koboSpan" id="kobo.224.1">setter.Invoke(carrier,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.225.1">      CorrelationIdHeaderName,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.226.1">      context.ActivityContext.TraceId.ToString());</span></strong><span class="koboSpan" id="kobo.227.1">
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter15/Brownfield.OpenTelemetry.Common/CorrelationIdPropagator.cs"><span class="koboSpan" id="kobo.228.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter15/Brownfield.OpenTelemetry.Common/CorrelationIdPropagator.cs</span></a></p>
<p><span class="koboSpan" id="kobo.229.1">Here, we check whether the activity</span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.230.1"> context is valid and set </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">TraceId</span></strong><span class="koboSpan" id="kobo.232.1"> as a string on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">correlation-id</span></strong><span class="koboSpan" id="kobo.234.1"> header. </span><span class="koboSpan" id="kobo.234.2">We’re setting this propagator up to run after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">TraceContextPropagator</span></strong><span class="koboSpan" id="kobo.236.1"> implementation available in OpenTelemetry, so there is no need to take care of Trace Context </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">headers here.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">And here’s the </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">extraction code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.240.1">CorrelationIdPropagator.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.241.1">
public override PropagationContext Extract&lt;T&gt;(
  PropagationContext context, T carrier,
  Func&lt;T, string, IEnumerable&lt;string&gt;&gt; getter)
{
  if (context.ActivityContext.IsValid()) return context;
  var correlationIds = getter.Invoke(carrier,
   CorrelationIdHeaderName);
  if (TryGetTraceId(correlationIds, out var traceId))
  {
</span><strong class="bold"><span class="koboSpan" id="kobo.242.1">    var traceContext = new ActivityContext(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.243.1">      ActivityTraceId.CreateFromString(traceId),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.244.1">      ActivitySpanId.CreateRandom(),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.245.1">      ActivityTraceFlags.Recorded,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.246.1">      isRemote: true);</span></strong><span class="koboSpan" id="kobo.247.1">
    return new PropagationContext(traceContext,
     context.Baggage);
  }
  ...
</span><span class="koboSpan" id="kobo.247.2">}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter15/Brownfield.OpenTelemetry.Common/CorrelationIdPropagator.cs"><span class="koboSpan" id="kobo.248.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter15/Brownfield.OpenTelemetry.Common/CorrelationIdPropagator.cs</span></a></p>
<p><span class="koboSpan" id="kobo.249.1">The custom extraction we implemented here runs after trace context extraction, so if there was a valid </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">traceparent</span></strong><span class="koboSpan" id="kobo.251.1"> header in the incoming request, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">context.ActivityContext</span></strong><span class="koboSpan" id="kobo.253.1"> is populated by the time the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">Extract</span></strong><span class="koboSpan" id="kobo.255.1"> method is called. </span><span class="koboSpan" id="kobo.255.2">Here, we give priority to W3C Trace Context and ignore the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">correlation-id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.257.1"> value.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">context.ActivityContext</span></strong><span class="koboSpan" id="kobo.260.1"> is not populated, we retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">correlation-id</span></strong><span class="koboSpan" id="kobo.262.1"> value and try to translate it to a trace</span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.263.1"> ID. </span><span class="koboSpan" id="kobo.263.2">If we can do it, then we create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">ActivityContext</span></strong><span class="koboSpan" id="kobo.265.1"> instance, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">correlation-id</span></strong><span class="koboSpan" id="kobo.267.1"> as a trace ID and a fake parent </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">span ID.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">Here’s the implementation of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">TryGetTraceId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.271.1"> method:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.272.1">CorrelationIdPropagator.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.273.1">
traceId = correlationId.Replace("-", "");
if (correlationId.Length &lt; 32)
  traceId = correlationId.PadRight(32, '0');
else if (traceId.Length &gt; 32)
  traceId = correlationId.Substring(0, 32);</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter15/Brownfield.OpenTelemetry.Common/CorrelationIdPropagator.cs"><span class="koboSpan" id="kobo.274.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter15/Brownfield.OpenTelemetry.Common/CorrelationIdPropagator.cs</span></a></p>
<p><span class="koboSpan" id="kobo.275.1">In this snippet, we support a variety of possible </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">correlation-id</span></strong><span class="koboSpan" id="kobo.277.1"> formats – we remove dashes if it’s a GUID, and pad or trim it if the length is </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">not right.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.279.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.280.1">In a more complicated case, we may need to do other transformations during context extraction and injection. </span><span class="koboSpan" id="kobo.280.2">For example, when a legacy system requires a GUID, we can add dashes. </span><span class="koboSpan" id="kobo.280.3">Alternatively, if it wants a </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">base64</span></strong><span class="koboSpan" id="kobo.282.1">-encoded string, we can decode and encode the </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">trace ID.</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">Let’s now check out the traces we get with </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">this approach.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">First, run new parts of the system with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">$ docker-compose up --build</span></strong><span class="koboSpan" id="kobo.288.1"> command. </span><span class="koboSpan" id="kobo.288.2">It starts with </span><strong class="bold"><span class="koboSpan" id="kobo.289.1">service-a</span></strong><span class="koboSpan" id="kobo.290.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.291.1">service-c</span></strong><span class="koboSpan" id="kobo.292.1">, and the </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">observability stack.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">We also need to start </span><strong class="bold"><span class="koboSpan" id="kobo.295.1">legacy-service-b</span></strong><span class="koboSpan" id="kobo.296.1">, which is the .NET Framework 4.6.2 application running</span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.297.1"> on Windows. </span><span class="koboSpan" id="kobo.297.2">You can start it with your IDE or the </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.299.1">
legacy-service-b$ dotnet run --correlation-mode correlation-id</span></pre>
<p><span class="koboSpan" id="kobo.300.1">Then, hit the following URL in your browser: http://localhost:5051/a?to=c. </span><span class="koboSpan" id="kobo.300.2">This will send a request to </span><strong class="bold"><span class="koboSpan" id="kobo.301.1">service-a</span></strong><span class="koboSpan" id="kobo.302.1">, which will call </span><strong class="bold"><span class="koboSpan" id="kobo.303.1">service-c</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.304.1">through </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.305.1">legacy-service-b</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">Now, let’s open Jaeger at http://localhost:16686 and find the trace from </span><strong class="bold"><span class="koboSpan" id="kobo.308.1">service-a</span></strong><span class="koboSpan" id="kobo.309.1">, which should look like the one shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.310.1">Figure 15</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.311.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer147">
<span class="koboSpan" id="kobo.313.1"><img alt="Figure 15.4 – An end-to-end trace covering service-a and service-c" src="image/B19423_15_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.314.1">Figure 15.4 – An end-to-end trace covering service-a and service-c</span></p>
<p><span class="koboSpan" id="kobo.315.1">As you can see, there is no </span><strong class="bold"><span class="koboSpan" id="kobo.316.1">legacy-service-b</span></strong><span class="koboSpan" id="kobo.317.1"> in the figure – it does not send telemetry to Jaeger. </span><span class="koboSpan" id="kobo.317.2">The only indication is the endpoint – the port (</span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">5050</span></strong><span class="koboSpan" id="kobo.319.1">) belongs </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.321.1">legacy-service-b</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.323.1">There is just one trace, but it still looks broken – spans are correlated, but parent-child relationships between the client span on </span><strong class="bold"><span class="koboSpan" id="kobo.324.1">service-a</span></strong><span class="koboSpan" id="kobo.325.1"> and the server span on </span><strong class="bold"><span class="koboSpan" id="kobo.326.1">service-c</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.327.1">are lost.</span></span></p>
<p><span class="koboSpan" id="kobo.328.1">Still, it’s an improvement. </span><span class="koboSpan" id="kobo.328.2">Let’s now disable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">correlation-id</span></strong><span class="koboSpan" id="kobo.330.1"> support on </span><strong class="bold"><span class="koboSpan" id="kobo.331.1">service-a</span></strong><span class="koboSpan" id="kobo.332.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.333.1">service-c</span></strong><span class="koboSpan" id="kobo.334.1">. </span><span class="koboSpan" id="kobo.334.2">We can do it by changing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">Compatibility__SupportLegacyCorrelation</span></strong><span class="koboSpan" id="kobo.336.1"> environment variable in </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.338.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">false</span></strong><span class="koboSpan" id="kobo.340.1"> on both services and restarting the docker compose application. </span><span class="koboSpan" id="kobo.340.2">Then, we’ll see two independent traces for </span><strong class="bold"><span class="koboSpan" id="kobo.341.1">service-a</span></strong><span class="koboSpan" id="kobo.342.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.343.1">service-c</span></strong><span class="koboSpan" id="kobo.344.1">, so even the correlation will </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">be lost.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.346.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.347.1">By relying on the existing context propagation format and implementing a custom propagation adapter, we can usually record end-to-end traces for new services without any modification to the </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">legacy ones.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">Can we also correlate telemetry from the legacy and new services? </span><span class="koboSpan" id="kobo.349.2">Usually, legacy services stamp their version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">correlation-id</span></strong><span class="koboSpan" id="kobo.351.1"> on all logs. </span><span class="koboSpan" id="kobo.351.2">If that’s the case, we can search using the trace ID across all telemetry but may need to map the trace ID to the correlation ID and back, in the same way we did with </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">the propagator.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">However, what if we didn’t have custom correlation</span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.354.1"> implemented in a legacy service or were not able to implement an adapter? </span><span class="koboSpan" id="kobo.354.2">We’d need to modify the legacy service to enable context propagation – let’s see how it can </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">be done.</span></span></p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.356.1">Passing context through a legacy service</span></h2>
<p><span class="koboSpan" id="kobo.357.1">Essentially, if there is no existing context propagation</span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.358.1"> mechanism, we can implement one. </span><span class="koboSpan" id="kobo.358.2">To minimize changes to legacy systems, we can propagate context transparently, without </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">modifying it.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">We need to intercept incoming and outgoing requests to extract and inject trace context, and we also need a way to pass the context inside </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">the process.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">The implementation of this approach, especially the interception, depends on the technologies, libraries, and patterns used in a specific </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">legacy service.</span></span></p>
<p><span class="koboSpan" id="kobo.364.1">Incoming request interception can be achieved with some middleware or request filter. </span><span class="koboSpan" id="kobo.364.2">If IIS is used, it can be also done in a custom HTTP telemetry module, but then we cannot fully rely on ambient context propagation due to managed-to-native </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">thread hops.</span></span></p>
<p><span class="koboSpan" id="kobo.366.1">Passing context within a process</span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.367.1"> can be usually achieved with </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">AsyncLocal</span></strong><span class="koboSpan" id="kobo.369.1"> on .NET 4.6+ or </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">LogicalCallContext</span></strong><span class="koboSpan" id="kobo.371.1"> on .NET 4.5 – this way, it will be contained in the new code and won’t require plumbing </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">context explicitly.</span></span></p>
<p><span class="koboSpan" id="kobo.373.1">In our demo system, </span><strong class="bold"><span class="koboSpan" id="kobo.374.1">legacy-service-b</span></strong><span class="koboSpan" id="kobo.375.1"> is a self-hosted OWIN application, and we can implement context extraction in the </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">OWIN middleware:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.377.1">PassThroughMiddleware.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.378.1">
private static readonly
  AsyncLocal&lt;IDictionary&lt;string, object&gt;&gt; _currentContext =
    new AsyncLocal&lt;IDictionary&lt;string, object&gt;&gt;();
public static IDictionary&lt;string, object&gt; CurrentContext =&gt;
  _currentContext.Value;
public override async Task Invoke(IOwinContext context)
{
  var tc = EmptyContext;
  if (context.Request.Headers.TryGetValue("traceparent",
    out var traceparent))
  {
    tc = new Dictionary&lt;string, object&gt;
      {{ "traceparent", traceparent[0] }};
    ...
</span><span class="koboSpan" id="kobo.378.2">  }
  _currentContext.Value = tc;
  ...
</span><span class="koboSpan" id="kobo.378.3">  using (var scope = _logger.BeginScope(tc))
  {
    await Next.Invoke(context);
  }
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter15/legacy-service-b/PassThrough/PassThroughMiddleware.cs"><span class="koboSpan" id="kobo.379.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter15/legacy-service-b/PassThrough/PassThroughMiddleware.cs</span></a></p>
<p><span class="koboSpan" id="kobo.380.1">First, we declare a static </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">AsyncLocal</span></strong><span class="koboSpan" id="kobo.382.1"> value that holds trace context, represented with a </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">simple dictionary.</span></span></p>
<p><span class="koboSpan" id="kobo.384.1">In the middleware </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">Invoke</span></strong><span class="koboSpan" id="kobo.386.1"> method, we read </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">traceparent</span></strong><span class="koboSpan" id="kobo.388.1"> along with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">tracestate</span></strong><span class="koboSpan" id="kobo.390.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">baggage</span></strong><span class="koboSpan" id="kobo.392.1"> headers (which are omitted for brevity). </span><span class="koboSpan" id="kobo.392.2">We populate them in the trace context dictionary. </span><span class="koboSpan" id="kobo.392.3">Depending on your needs, you can always limit supported context fields to </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">traceparent</span></strong><span class="koboSpan" id="kobo.394.1"> only and optimize the </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">code further.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">Then, we populate the context </span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.397.1">dictionary on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">_currentContext</span></strong><span class="koboSpan" id="kobo.399.1"> field, which we can then access through the public </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">CurrentContext</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.401.1">static property.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">The last thing we do here is to invoke the next middleware, which we wrap with a logger scope containing the context dictionary. </span><span class="koboSpan" id="kobo.402.2">This allows us to populate trace context on all logs coming from </span><strong class="bold"><span class="koboSpan" id="kobo.403.1">legacy-service-b</span></strong><span class="koboSpan" id="kobo.404.1">, thus correlating them with telemetry coming from </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">new services.</span></span></p>
<p><span class="koboSpan" id="kobo.406.1">In practice, legacy applications rarely use </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">ILogger</span></strong><span class="koboSpan" id="kobo.408.1">, but logging libraries usually have some other mechanism to populate ambient context on log records. </span><span class="koboSpan" id="kobo.408.2">Depending on the library, you may be able to access and populate </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">CurrentContext</span></strong><span class="koboSpan" id="kobo.410.1"> with little change to the logging </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">configuration code.</span></span></p>
<p><span class="koboSpan" id="kobo.412.1">Getting back to context propagation, we now need to inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">CurrentContext</span></strong><span class="koboSpan" id="kobo.414.1"> value into the </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">outgoing requests.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">In the case of HTTP and when .NET </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">HttpClient</span></strong><span class="koboSpan" id="kobo.418.1"> is used, we can do it with custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">DelegatingHandler</span></strong><span class="koboSpan" id="kobo.420.1"> implementation. </span><span class="koboSpan" id="kobo.420.2">It will be more tedious with </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">WebRequest</span></strong><span class="koboSpan" id="kobo.422.1"> usage spread across the application code when there are no helper methods that create </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">them consistently.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">The handler implementation</span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.425.1"> is shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">code snippet:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.427.1">PassThroughHandler.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.428.1">
protected override Task&lt;HttpResponseMessage&gt; SendAsync(
  HttpRequestMessage request, CancellationToken token)
{
</span><strong class="bold"><span class="koboSpan" id="kobo.429.1">  foreach (var kvp in PassThroughMiddleware.CurrentContext)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.430.1">    request.Headers.Add(kvp.Key, pair.Value?.ToString());</span></strong><span class="koboSpan" id="kobo.431.1">
  return base.SendAsync(request, token);
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter15/legacy-service-b/PassThrough/PassThroughMiddleware.cs"><span class="koboSpan" id="kobo.432.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter15/legacy-service-b/PassThrough/PassThroughMiddleware.cs</span></a></p>
<p><span class="koboSpan" id="kobo.433.1">Here, we just inject all fields from </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">CurrentContext</span></strong><span class="koboSpan" id="kobo.435.1"> on outgoing request headers and then invoke the next handler. </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">That’s it.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.437.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.438.1">Starting with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">System.Diagnostics.DiagnosticSource</span></strong><span class="koboSpan" id="kobo.440.1"> package version 6.0.0, .NET provides a </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">DistributedContextPropagator</span></strong><span class="koboSpan" id="kobo.442.1"> base class along with several implementations, including W3C trace context and a pass-through propagator. </span><span class="koboSpan" id="kobo.442.2">It can be useful if you can add a dependency on a newish </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">DiagnosticSource</span></strong><span class="koboSpan" id="kobo.444.1"> package, or when configuring propagation for native distributed tracing instrumentations in ASP.NET Core and </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">HttpClient</span></strong><span class="koboSpan" id="kobo.446.1">. </span><span class="koboSpan" id="kobo.446.2">In the case of our legacy service, extraction and injection alone are trivial, so adding a new dependency is not </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">really justified.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">Now, we can run the application</span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.449.1"> again and check </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">the traces:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.451.1">Start new services with </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">$ docker-compose up --build</span></strong><span class="koboSpan" id="kobo.453.1"> and then </span><strong class="bold"><span class="koboSpan" id="kobo.454.1">legacy-service-b</span></strong><span class="koboSpan" id="kobo.455.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">following command:</span></span><pre class="console">
<strong class="bold"><span class="koboSpan" id="kobo.457.1">legacy-service-b$ dotnet run --correlation-mode pass-through</span></strong></pre></li>
<li><span class="koboSpan" id="kobo.458.1">Then call </span><strong class="bold"><span class="koboSpan" id="kobo.459.1">service-a</span></strong><span class="koboSpan" id="kobo.460.1"> with http://localhost:5051/a?to=c again and open Jaeger. </span><span class="koboSpan" id="kobo.460.2">We should see a trace like the one in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.461.1">Figure 15</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.462.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer148">
<span class="koboSpan" id="kobo.464.1"><img alt="Figure 15.5 – An end-to-end trace with transparent service-b" src="image/B19423_15_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.465.1">Figure 15.5 – An end-to-end trace with transparent service-b</span></p>
<p><span class="koboSpan" id="kobo.466.1">Here, we have correlation and causation – the client span on </span><strong class="bold"><span class="koboSpan" id="kobo.467.1">service-a</span></strong><span class="koboSpan" id="kobo.468.1"> is a direct parent of the server span on </span><strong class="bold"><span class="koboSpan" id="kobo.469.1">service-c</span></strong><span class="koboSpan" id="kobo.470.1">. </span><span class="koboSpan" id="kobo.470.2">However, </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">service-b</span></strong><span class="koboSpan" id="kobo.472.1"> is nowhere to be seen, as it does not actively participate in </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">the tracing.</span></span></p>
<p><span class="koboSpan" id="kobo.474.1">Now, we have a couple of options to pass context through the legacy system, but we can be creative and come up with more options specific to our application – for example, we can stamp legacy correlation or request IDs on the new telemetry, or log them and then post-process telemetry to correlate </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">broken traces.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">With these options, we should be able</span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.477.1"> to achieve at least some level of correlation. </span><span class="koboSpan" id="kobo.477.2">Let’s now check how we can forward telemetry from legacy services to the new </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">observability backends.</span></span></p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.479.1">Consolidating telemetry from legacy monitoring tools</span></h1>
<p><span class="koboSpan" id="kobo.480.1">One of the biggest benefits</span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.481.1"> a good observability solution can provide</span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.482.1"> is low cognitive load when debugging an application and reading through telemetry. </span><span class="koboSpan" id="kobo.482.2">Even perfectly correlated and high-quality telemetry is very hard to use if it’s spread across multiple tools and can’t be visualized and </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">analyzed together.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">When re-instrumenting legacy services with OpenTelemetry is not an option, we should check whether it’s possible to forward existing data from legacy services to a new </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">observability backend.</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">As with context propagation, we can be creative and should start by leveraging existing solutions. </span><span class="koboSpan" id="kobo.486.2">For example, old .NET systems usually report and consume Windows performance counters and send logs to EventLog, or store them on the </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">hard drive.</span></span></p>
<p><span class="koboSpan" id="kobo.488.1">The OpenTelemetry Collector provides support for such cases via receivers, available in the contrib repository (</span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">at </span></span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">https://github.com/open-telemetry/opentelemetry-collector-contrib</span></span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.492.1">For example, we can configure a file receiver with the </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">following snippet:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.494.1">otel-collector-config.yml</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.495.1">
filelog:
  include: [ /var/log/chapter15*.log ]
  operators:
    - type: json_parser
      timestamp:
        parse_from: attributes.Timestamp
        layout: '%Y-%m-%dT%H:%M:%S.%f'
      severity:
        parse_from: attributes.LogLevel</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter15/configs/otel-collector-config.yml"><span class="koboSpan" id="kobo.496.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter15/configs/otel-collector-config.yml</span></a></p>
<p><span class="koboSpan" id="kobo.497.1">Here, we configure the collector</span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.498.1"> receiver and specify the log file location and name pattern. </span><span class="koboSpan" id="kobo.498.2">We also configure</span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.499.1"> mapping and transformation rules for individual properties in log records. </span><span class="koboSpan" id="kobo.499.2">In this example, we only map timestamp and log level, but if log records are structured, it’s possible to parse other properties using </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">similar operators.</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">We can also rely on our backend to grok unstructured log records or parse records at a query time if we rarely need </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">the data.</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">Here’s an example of collector output with a parsed log record, which, depending on your collector configuration, can send logs to the new </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">observability backend:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.505.1">
Timestamp: 2023-05-27 01:00:41.074 +0000 UTC
SeverityText: Information
…
Attributes:
</span><strong class="bold"><span class="koboSpan" id="kobo.506.1">     -&gt; Scopes: Slice([{"Message":"System.Collections.Generic.Dictionary`2[System.String,System.Object]","traceparent":"00-78987df9861c2d7e46c10bd084570122-53106042475b3e32-01"}])</span></strong><span class="koboSpan" id="kobo.507.1">
     -&gt; Category: Str(LegacyServiceB.LoggingHandler)
...
</span><strong class="bold"><span class="koboSpan" id="kobo.508.1">     -&gt; State: Map({"Message":"Request complete. </span><span class="koboSpan" id="kobo.508.2">GET http://localhost:5049/c, OK","method":"GET","status":"OK","url":"http://localhost:5049/c","{OriginalFormat}":"Request complete. </span><span class="koboSpan" id="kobo.508.3">{method} {url}, {status}"})</span></strong><span class="koboSpan" id="kobo.509.1">
Trace ID:
Span ID:</span></pre>
<p><span class="koboSpan" id="kobo.510.1">As you can see, we could also configure the receiver to parse the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">traceparent</span></strong><span class="koboSpan" id="kobo.512.1"> value populated in the log scopes to record </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">Trace ID</span></strong><span class="koboSpan" id="kobo.514.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">Span ID</span></strong><span class="koboSpan" id="kobo.516.1"> for the </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">proper correlation.</span></span></p>
<p><span class="koboSpan" id="kobo.518.1">You can reproduce it by running </span><strong class="bold"><span class="koboSpan" id="kobo.519.1">legacy-service-b</span></strong><span class="koboSpan" id="kobo.520.1"> with the following command and sending some requests to it directly, or </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">via </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.522.1">service-a</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.524.1">
legacy-service-b $ dotnet run --correlation-mode pass-through &gt; ../
tmp/logs/chapter15.log</span></pre>
<p><span class="koboSpan" id="kobo.525.1">A collector can be helpful in sidecar mode, forwarding data available on the machine where legacy service instances are running, and collecting performance counters or logs. </span><span class="koboSpan" id="kobo.525.2">It can also pretend to be our old backend and receive Zipkin or Jaeger spans, Prometheus metrics, and vendor-specific signals, such as Splunk metrics </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">and logs.</span></span></p>
<p><span class="koboSpan" id="kobo.527.1">We can write custom receivers and leverage collector transformation processors to produce consistent telemetry </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">whenever possible.</span></span></p>
<p><span class="koboSpan" id="kobo.529.1">In addition to the endless possibilities</span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.530.1"> a OpenTelemetry Collector can provide, we should</span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.531.1"> check whether the observability vendor we use for legacy services allows continuous export for collected telemetry, which would allow us to get the data without changing anything on the </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">legacy system.</span></span></p>
<h1 id="_idParaDest-245"><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.533.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.534.1">In this chapter, we explored tracing in brownfield applications, where some of the services can be hard to change and onboard onto a full-fledged observability solution </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">with OpenTelemetry.</span></span></p>
<p><span class="koboSpan" id="kobo.536.1">We discussed possible levels of instrumentation for such services and found several cases when we can avoid changing old components altogether. </span><span class="koboSpan" id="kobo.536.2">Then, we went through the changes we can apply, starting with minimalistic transparent context propagation and going all the way to onboarding </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">onto OpenTelemetry.</span></span></p>
<p><span class="koboSpan" id="kobo.538.1">Finally, we applied some of these options in practice, enabling end-to-end correlation through a legacy service and forwarding file logs to the </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">OpenTelemetry Collector.</span></span></p>
<p><span class="koboSpan" id="kobo.540.1">Now, you should be ready to come up with the strategy for your own legacy components and have the building blocks to </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">implement it.</span></span></p>
<p><span class="koboSpan" id="kobo.542.1">This chapter concludes our journey into distributed tracing and observability on .NET – I hope you enjoyed it! </span><span class="koboSpan" id="kobo.542.2">The observability area is evolving fast, but now you have a foundational knowledge to design and implement your systems with observability in mind, evolve them by relying on relevant telemetry data, and operate them with more confidence, knowing what telemetry represents and how it’s collected. </span><span class="koboSpan" id="kobo.542.3">Now, it’s time to apply your knowledge or create something new based </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">on it.</span></span></p>
<h1 id="_idParaDest-246"><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.544.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.545.1">How would you approach instrumenting an existing service that is a critical part of most user scenarios in your system? </span><span class="koboSpan" id="kobo.545.2">This service is mature and is rarely changed, but there are no plans to retire it any </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">time soon.</span></span></li>
<li><span class="koboSpan" id="kobo.547.1">What can go wrong when we add OpenTelemetry to a </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">legacy service?</span></span></li>
<li><span class="koboSpan" id="kobo.549.1">When implementing transparent context propagation, can we leverage the </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">Activity</span></strong><span class="koboSpan" id="kobo.551.1"> class instead of adding our own context primitive and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">AsyncLocal</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.553.1"> field?</span></span></li>
</ol>
</div>


<div id="_idContainer150">
<h1 id="_idParaDest-247"><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.1.1">Assessments</span></h1>
<h1 id="_idParaDest-248"><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.2.1">Chapter 1 – Observability Needs of Modern Applications</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.3.1">You can think about a span as a structured event with a strict but extensible schema, allowing you to track any interesting operation. </span><span class="koboSpan" id="kobo.3.2">Spans have trace context that describes the relationships between them. </span><span class="koboSpan" id="kobo.3.3">They also have a name, start time, end time, status, and a property bag, with attributes to represent </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">operation details.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.5.1">Complex and distributed operations need multiple spans that describe at least each incoming and outgoing request. </span><span class="koboSpan" id="kobo.5.2">A group of such correlated spans that share the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">trace-id </span></strong><span class="koboSpan" id="kobo.7.1">is called a trace.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.8.1">Spans (also known as Activities in .NET) are created by many libraries and applications. </span><span class="koboSpan" id="kobo.8.2">To enable correlation, we need to propagate context within the process and </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">between processes.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.10.1">In .NET, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.11.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.12.1"> to propagate context within the process. </span><span class="koboSpan" id="kobo.12.2">This is a current span that flows with an execution context in synchronous or asynchronous calls. </span><span class="koboSpan" id="kobo.12.3">Whenever a new activity is started, it uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.13.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.14.1"> as its parent and then becomes current itself.</span></p>
<p><span class="koboSpan" id="kobo.15.1">To propagate the trace context between the processes, we pass it over the wire to the next service. </span><span class="koboSpan" id="kobo.15.2">W3C Trace Context is a standard propagation format for the HTTP protocol, but some services use the B3 format.</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.16.1">There is no single answer to this question, but here’re some general considerations on how you can leverage a combination of signals coming from </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">your service:</span></span><ul><li><span class="koboSpan" id="kobo.18.1">Check whether the problem is widespread and affects more than this user and request. </span><span class="koboSpan" id="kobo.18.2">Is your service healthy overall? </span><span class="koboSpan" id="kobo.18.3">Is it specific to the API path the user hits, region, partition, feature flag, or new service version? </span><span class="koboSpan" id="kobo.18.4">Your observability backend might be able to assist </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">with it</span></span></li><li><span class="koboSpan" id="kobo.20.1">If the problem is not widespread, find traces for problematic requests using trace context if it is known, or filtering by known attributes. </span><span class="koboSpan" id="kobo.20.2">If you see gaps in traces, retrieve logs for this operation. </span><span class="koboSpan" id="kobo.20.3">If that’s not enough, use profiling to investigate further. </span><span class="koboSpan" id="kobo.20.4">Consider adding </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">more telemetry.</span></span></li><li><span class="koboSpan" id="kobo.22.1">For widespread issues, you might find the root cause of the problem by identifying specific attributes correlated with the </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">reported problem.</span></span></li><li><span class="koboSpan" id="kobo.24.1">Otherwise, narrow down the issue layer by layer. </span><span class="koboSpan" id="kobo.24.2">Are dependencies working fine? </span><span class="koboSpan" id="kobo.24.3">Is there something new upstream? </span><span class="koboSpan" id="kobo.24.4">Any changes in </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">the load?</span></span></li><li><span class="koboSpan" id="kobo.26.1">If issues are not specific to any combination of attributes, check the dependency health and resource utilization. </span><span class="koboSpan" id="kobo.26.2">Check the crash and restart count, CPU load, memory utilization, extensive garbage collection, I/O, and </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">network bottlenecks.</span></span></li></ul></li>
</ol>
<h1 id="_idParaDest-249"><a id="_idTextAnchor248"/><span class="koboSpan" id="kobo.28.1">Chapter 2 – Native Monitoring in .NET</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.29.1">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">Activity.Current?.Id</span></strong><span class="koboSpan" id="kobo.31.1"> on the page. </span><span class="koboSpan" id="kobo.31.2">For example, like this: </span><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">&lt;</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">p&gt;traceparent: &lt;code&gt;@System.Diagnostics.Activity.Current?.Id&lt;/code&gt;&lt;/p&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">If we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">dotnet-monitor </span></strong><span class="koboSpan" id="kobo.37.1">running as a sidecar, we can connect to its instance corresponding to the problematic service instance, check the metrics and logs, and create dumps. </span><span class="koboSpan" id="kobo.37.2">We could even configure </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">dotnet-monitor </span></strong><span class="koboSpan" id="kobo.39.1">to trigger a dump collection based on certain events or resource </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">consumption thresholds.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.41.1">If we don’t have </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">dotnet-monitor</span></strong><span class="koboSpan" id="kobo.43.1">, but can access service instances, we can install </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">dotnet-monitor </span></strong><span class="koboSpan" id="kobo.45.1">there and get diagnostics information from the running process.</span></p>
<p><span class="koboSpan" id="kobo.46.1">If instances are healthy, but the problem is somewhere inside the telemetry pipeline, troubleshooting steps would depend on the tools we use. </span><span class="koboSpan" id="kobo.46.2">For example, with Jaeger we can check logs; the Prometheus UI shows connectivity with targets; the OpenTelemetry collector provides logs and metrics for self-diagnostics.</span></p>
<ol>
<li value="3"><span class="No-Break"><span class="koboSpan" id="kobo.47.1">Query:</span></span><pre class="console"><span class="koboSpan" id="kobo.48.1">
sum by (service_name, http_route)</span></pre><pre class="console"><span class="koboSpan" id="kobo.49.1">
  (rate(http_server_duration_ms_count[1m]))</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.50.1">The query sums up the request rates across all running service instances, grouping it by service name and </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">http_route</span></strong><span class="koboSpan" id="kobo.52.1"> (which represents the API route).</span></p>
<p><span class="koboSpan" id="kobo.53.1">The rate function </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">(rate(http_server_duration_ms_count)</span></strong><span class="koboSpan" id="kobo.55.1"> first calculates the rate per second, then averages the rate over one minute.</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.56.1">Search the traces with the URL and method filter in Jaeger. </span><span class="koboSpan" id="kobo.56.2">For uploads, it would be </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">http. </span><span class="koboSpan" id="kobo.57.2">url=http://storage:5050/memes/&lt;name&gt; http.method=PUT</span></strong><span class="koboSpan" id="kobo.58.1">. </span><span class="koboSpan" id="kobo.58.2">To find downloads, we would use </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">http.url=http://storage:5050/memes/&lt;name&gt; http. </span><span class="koboSpan" id="kobo.59.2">method=GET</span></strong><span class="koboSpan" id="kobo.60.1">. </span><span class="koboSpan" id="kobo.60.2">However, this isn’t convenient and we should consider adding the meme name as an attribute on </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">all spans.</span></span></li>
</ol>
<h1 id="_idParaDest-250"><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.62.1">Chapter 3 – The .NET Observability Ecosystem</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.63.1">Check the registry (</span><a href="https://opentelemetry.io/registry/"><span class="koboSpan" id="kobo.64.1">https://opentelemetry.io/registry/</span></a><span class="koboSpan" id="kobo.65.1">) and OpenTelemetry .NET repo. </span><span class="koboSpan" id="kobo.65.2">If you don’t see your library in any of them, search in issues and PRs. </span><span class="koboSpan" id="kobo.65.3">It’s also a good idea to search whether anything is available in the library GitHub repo </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">or documentation.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.67.1">When you find an instrumentation, there are several things to check for:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.68.1">Version and stability</span></strong><span class="koboSpan" id="kobo.69.1">: Beta instrumentations could still have a high quality and be battle-tested but do not guarantee API or </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">telemetry stability</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.71.1">Performance and thread safety</span></strong><span class="koboSpan" id="kobo.72.1">: Understanding the mechanism behind instrumentation is important to identify possible limitations and issues </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">in advance</span></span></li>
</ul>
<ol>
<li value="2"><span class="koboSpan" id="kobo.74.1">The most common way to instrument libraries and frameworks is </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.76.1">— it’s the .NET analog of OpenTelemetry Tracer, which can start activities. </span><span class="koboSpan" id="kobo.76.2">You can configure OpenTelemetry to listen to a source by its name. </span><span class="koboSpan" id="kobo.76.3">You might also see instrumentations using </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">DiagnosticSource</span></strong><span class="koboSpan" id="kobo.78.1">—it’s an older and less structured mechanism available </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">in .NET.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.80.1">It’s also common to leverage hooks provided by libraries that can be global or applied to specific instances of the client.</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.81.1">Service meshes can trace requests to and from service mesh sidecars and provide insights into retries, service discovery, or load balancing. </span><span class="koboSpan" id="kobo.81.2">If they handle communication with cloud service, remote database, or queue, they can instrument corresponding communication. </span><span class="koboSpan" id="kobo.81.3">Service meshes can propagate the context from one application to another but cannot propagate it within the service from incoming to </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">outgoing calls.</span></span></li>
</ol>
<h1 id="_idParaDest-251"><a id="_idTextAnchor250"/><span class="koboSpan" id="kobo.83.1">Chapter 4 – Low-Level Performance Analysis with Diagnostic Tools</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.84.1">If your service defines SLIs, check them first and see whether they are within the boundaries defined by your SLOs. </span><span class="koboSpan" id="kobo.84.2">In other words, check the key metrics that measure your user experience and see whether they are within healthy limits. </span><span class="koboSpan" id="kobo.84.3">For REST API-based services, it is usually the throughput of successful requests and latency grouped by API and other things that are important in </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">your application.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.86.1">Resource consumption metrics could be correlated to user experience, but do not determine it. </span><span class="koboSpan" id="kobo.86.2">They (and other metrics that describe the internals of your service) can help you understand why the user experience has degraded and can predict future issues with some level of confidence.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.87.1">First, we should try to find which service is responsible: check upstream and downstream services for whether the load on your service is normal and properly distributed across instances. </span><span class="koboSpan" id="kobo.87.2">Check whether dependencies are healthy using their server-side metrics </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">when possible.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.89.1">If we can narrow down the issue to a specific service, we can check whether the issue is specific to a certain instance or group of instances, or whether instances are restarting a lot. </span><span class="koboSpan" id="kobo.89.2">For affected instances, we can check their resource utilization patterns for memory, CPU, GC frequency, threads, contentions, or anything that looks unusually high or low. </span><span class="koboSpan" id="kobo.89.3">Then, we can capture a dump from the problematic instance(s) to analyze memory and thread stacks.</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.90.1">Performance tracing (also known as profiling or just tracing) is a technique that allows us to capture detailed diagnostics about application behavior and code – call stacks, GC, contention, network events, or anything else that .NET or third-party libraries want to expose. </span><span class="koboSpan" id="kobo.90.2">Such events are off by default but can be enabled and controlled inside the process and out-of-process. </span><span class="koboSpan" id="kobo.90.3">Tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">dotnet-trace</span></strong><span class="koboSpan" id="kobo.92.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">dotnet-monitor</span></strong><span class="koboSpan" id="kobo.94.1">, PerfView, PerfCollect, JetBrains dotTrace, Visual Studio, and continuous profilers can collect and visualize them. </span><span class="koboSpan" id="kobo.94.2">Performance tracing can be used to investigate functional and performance issues or optimize </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">your code.</span></span></li>
</ol>
<h1 id="_idParaDest-252"><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.96.1">Chapter 5 – Configuration and Control Plane</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.97.1">We’d need tail-based sampling that’s applied after span or trace ends and we know the duration or if there were any failures. </span><span class="koboSpan" id="kobo.97.2">Tail-based sampling can’t be done inside the process since we have distributed multi-instance applications, but we can use a tail-based sampling processor in the OpenTelemetry Collector that buffers traces and then samples them based on latency, or </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">status codes.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.99.1">If we only capture suspicious traces, we will not have a baseline anymore – we won’t be able to use traces to observe normal system behavior, build analytics, and so on. </span><span class="koboSpan" id="kobo.99.2">So, we should additionally capture a percentage or rate of random traces – if we mark them somehow, we can analyze them separately from problematic traces to create unbiased analytics.</span></p>
<p><span class="koboSpan" id="kobo.100.1">It’s always a good idea to rate-limit all traces, so we don’t overload the telemetry pipeline with traffic bursts.</span></p>
<p><span class="koboSpan" id="kobo.101.1">In addition to sampling configuration on the OpenTelemetry Collector, we should consider configuring probability sampling on individual .NET services – depending on this, we would allocate an appropriate number of resources for Collector and also balance the performance impact of the instrumentation.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.102.1">Let’s record a try number using the OpenTelemetry </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">http.resend_count</span></strong><span class="koboSpan" id="kobo.104.1"> attribute that should be set on each HTTP span that represents a retry or redirect. </span><span class="koboSpan" id="kobo.104.2">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">EnrichWithHttpRequestMessage</span></strong><span class="koboSpan" id="kobo.106.1"> hook on the HTTP client instrumentation to intercept the outgoing request and its activity, but where would we get the retry </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">number from?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.108.1">Well, we can maintain it in our retry handler (if you use Polly, you could use </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">Context </span></strong><span class="koboSpan" id="kobo.110.1">instead) and pass it to the hook via </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">HttpRequestMessage.Options</span></strong><span class="koboSpan" id="kobo.112.1">. </span><span class="koboSpan" id="kobo.112.2">So, the final solution could look like this:</span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.113.1">Program.cs</span></p>
<pre class="console"><span class="koboSpan" id="kobo.114.1">
AddHttpClientInstrumentation(options =&gt;
{
options.EnrichWithHttpRequestMessage = (act, req) =&gt;
{
if (req.Options.TryGetValue(
new HttpRequestOptionsKey&lt;int&gt;("try"),
out var tryCount) &amp;&amp; tryCount &gt; 0)
act.SetTag("http.resend_count", tryCount);
...
</span><span class="koboSpan" id="kobo.114.2">}
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs"><span class="koboSpan" id="kobo.115.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs</span></a></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.116.1">RetryHandler.cs</span></p>
<pre class="console"><span class="koboSpan" id="kobo.117.1">
for (int i = 0; i &lt; MaxTryCount; i++)
{
request.Options.Set(new
HttpRequestOptionsKey&lt;int&gt;("try"), i);
try
{
var response = await base.SendAsync(request,
token);
...
</span><span class="koboSpan" id="kobo.117.2">}
catch (Exception e) { ... </span><span class="koboSpan" id="kobo.117.3">}
await Task.Delay(delays[i]);
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.118.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/RetryHandler.cs</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.119.1">Let’s check out the OpenTelemetry Collector documentation for tail-based sampling at https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/processor/tailsamplingprocessor/README.md. </span><span class="koboSpan" id="kobo.119.2">We need to declare and configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">tail_sampling </span></strong><span class="koboSpan" id="kobo.121.1">processor and add it to the pipeline. </span><span class="koboSpan" id="kobo.121.2">Here’s a </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">sample configuration:</span></span></li>
</ol>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.123.1">otel-collector-config.yml</span></p>
<pre class="console"><span class="koboSpan" id="kobo.124.1">
processors:
...
</span><span class="koboSpan" id="kobo.124.2">tail_sampling:
decision_wait: 2s
expected_new_traces_per_sec: 500
policies:
[{ name: limit-rate,
type: rate_limiting,
rate_limiting: {spans_per_second: 50}}]
service:
pipelines:
traces:
receivers: [otlp]
processors: [tail_sampling, batch]
exporters: [jaeger]</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/configs/otel-collector-config.yml"><span class="koboSpan" id="kobo.125.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/configs/otel-collector-config.yml</span></a></p>
<p><span class="koboSpan" id="kobo.126.1">You can check your current rate of recorded spans using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">rate(otelcol_receiver_ accepted_spans[1m]</span></strong><span class="koboSpan" id="kobo.128.1">) query in Prometheus and monitor the exported rate with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">rate(otelcol_exporter_sent_spans[1m])</span></strong><span class="koboSpan" id="kobo.130.1"> query.</span></p>
<h1 id="_idParaDest-253"><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.131.1">Chapter 6 – Tracing Your Code</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.132.1">When setting up OpenTelemetry, you can enable </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.134.1"> by calling into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">TracerProviderBuilder.AddSource</span></strong><span class="koboSpan" id="kobo.136.1"> method and passing the source name. </span><span class="koboSpan" id="kobo.136.2">OpenTelemetry will then create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">ActivityListener</span></strong><span class="koboSpan" id="kobo.138.1"> – a low-level .NET API that listens to </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">ActivitySource</span></strong><span class="koboSpan" id="kobo.140.1"> instances. </span><span class="koboSpan" id="kobo.140.2">The listener samples activities using the callback provided by OpenTelemetry and notifies OpenTelemetry when activities start </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">or end.</span></span></li>
<li><span class="koboSpan" id="kobo.142.1">Activity (or span) events can be used to represent something that happens at a point in time or is too short to be a span and does not need individual context. </span><span class="koboSpan" id="kobo.142.2">At the same time, events must happen in the scope of some activity and are recorded along with it. </span><span class="koboSpan" id="kobo.142.3">Activity events stay in memory until the activity is garbage-collected and their number is limited on the </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">exporter side.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.144.1">Logs are usually a better alternative to </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">Activity</span></strong><span class="koboSpan" id="kobo.146.1"> events as they are not necessarily tied to specific activity, sampling, or exporter limitations. </span><span class="koboSpan" id="kobo.146.2">OpenTelemetry treats events and logs similarly. </span><span class="koboSpan" id="kobo.146.3">Events expressed as log records are structured and can follow specific semantic conventions.</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.147.1">Links provide another way to correlate spans with cover scenarios when the span has multiple parents or is related in some way to several other spans at once. </span><span class="koboSpan" id="kobo.147.2">Without links, spans can only have one parent and multiple children and can’t be related to spans in </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">other traces.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.149.1">Links are used in messaging scenarios to express receiving or processing multiple independent messages at once. </span><span class="koboSpan" id="kobo.149.2">When we process multiple messages, we need to extract the trace context and create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">ActivityLink</span></strong><span class="koboSpan" id="kobo.151.1"> from each of them. </span><span class="koboSpan" id="kobo.151.2">Then, we can pass a collection of these links to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">ActivitySource.StartActivity</span></strong><span class="koboSpan" id="kobo.153.1"> method. </span><span class="koboSpan" id="kobo.153.2">We can’t change these links after the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">Activity</span></strong><span class="koboSpan" id="kobo.155.1"> starts. </span><span class="koboSpan" id="kobo.155.2">Observability backends support (or don’t support) links in different ways and we might need to adjust the instrumentation based on the backend capabilities.</span></p>
<h1 id="_idParaDest-254"><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.156.1">Chapter 7 – Adding Custom Metrics</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.157.1">We should first decide what we need the metric for. </span><span class="koboSpan" id="kobo.157.2">For example, if we need it to rank memes in search results or to calculate ad hits, we should separate it from telemetry. </span><span class="koboSpan" id="kobo.157.3">Assuming we store the meme download counter in a database for business logic purposes, we could also stamp it on traces or events as an attribute when the counter </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">is updated.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.159.1">From a telemetry-only standpoint, metric per meme would have high cardinality as we probably have millions of memes in the system and thousands active per minute. </span><span class="koboSpan" id="kobo.159.2">With some additional logic (for example, if we can ignore rarely accessed memes), we might even be able to introduce a metric with a meme name as an attribute.</span></p>
<p><span class="koboSpan" id="kobo.160.1">I would start with traces and aggregate spans by meme name in a rich query. </span><span class="koboSpan" id="kobo.160.2">Even if traces are sampled, I can still calculate the estimated number of downloads, compare it between memes, and see trends.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.161.1">Usually, both, but it depends: we need incoming HTTP request traces to investigate individual failures and delays and know what normal request flow looks like under different conditions. </span><span class="koboSpan" id="kobo.161.2">Do we need metrics as well? </span><span class="koboSpan" id="kobo.161.3">Probably yes. </span><span class="koboSpan" id="kobo.161.4">At a high scale, we sample traces aggressively but likely need more precise data than estimated counts. </span><span class="koboSpan" id="kobo.161.5">Another problem is that even if we don’t sample or don’t mind rough estimates, querying over all spans during the time window can be expensive and long – it might need to process millions of records. </span><span class="koboSpan" id="kobo.161.6">If we build dashboards and alerts on this data, we want queries to be fast and cheap. </span><span class="koboSpan" id="kobo.161.7">Even if they are used for ad hoc analysis during incidents, we still want queries to </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">be fast.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.163.1">So, the answer depends on the observability backend, what it is optimized for, and its pricing model, but collecting both gives us a good starting point.</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.164.1">For the number of active instances, we can report </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">ObservableUpDownCounter</span></strong><span class="koboSpan" id="kobo.166.1"> with resource attributes that include instance information. </span><span class="koboSpan" id="kobo.166.2">The counter would always report </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">1</span></strong><span class="koboSpan" id="kobo.168.1"> so that the sum of values across all instances at any given time will represent the number of active processes. </span><span class="koboSpan" id="kobo.168.2">This is how Kubernetes does it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">kube_node_info</span></strong><span class="koboSpan" id="kobo.170.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">kube_pod_info</span></strong><span class="koboSpan" id="kobo.172.1"> metrics (check out </span><a href="https://github.com/kubernetes/kube-state-metrics"><span class="koboSpan" id="kobo.173.1">https://github.com/kubernetes/kube-state-metrics</span></a><span class="koboSpan" id="kobo.174.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">more information).</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.176.1">Uptime can be reported in multiple ways – for example, as a gauge containing static start time (see </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">kube_node_created</span></strong><span class="koboSpan" id="kobo.178.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">kube_pod_start_time</span></strong><span class="koboSpan" id="kobo.180.1">) or as a resource attribute.</span></p>
<p><span class="koboSpan" id="kobo.181.1">Make sure to check whether your environment already emits anything similar or whether OpenTelemetry semantic conventions define a common way to report the metric you’re interested in.</span></p>
<h1 id="_idParaDest-255"><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.182.1">Chapter 8 – Writing Structured and Correlated Logs</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.183.1">The code uses string interpolation instead of semantic logging. </span><span class="koboSpan" id="kobo.183.2">A log message is formatted right away, so the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">ILogger.Log</span></strong><span class="koboSpan" id="kobo.185.1"> method is called underneath with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">"hello world: 43, bar"</span></strong><span class="koboSpan" id="kobo.187.1"> string, without any indication that there are two arguments with specific names </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">and values.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.189.1">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">Information</span></strong><span class="koboSpan" id="kobo.191.1"> level is disabled, string interpolation happens anyway, serializing all arguments and calculating just the message to be dropped.</span></p>
<p><span class="koboSpan" id="kobo.192.1">This code should be changed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">logger.LogInformation("hello world: {foo}, {bar}", 42, "bar")</span></strong><span class="koboSpan" id="kobo.194.1">.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.195.1">We need to make sure that the usage report is built using log record properties that </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">don’t change:</span></span><ul><li><span class="koboSpan" id="kobo.197.1">A log message would change a lot when new arguments are added or code </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">is refactored.</span></span></li><li><span class="koboSpan" id="kobo.199.1">The logging category is usually based on a namespace, which might change during refactoring. </span><span class="koboSpan" id="kobo.199.2">We can consider passing categories explicitly as strings instead of a generic type parameter, but the better choice would be to make sure the report does not rely on logging categories. </span><span class="koboSpan" id="kobo.199.3">We can use event names or IDs – they have to be specified explicitly; we just need to make sure they are unique and don’t change. </span><span class="koboSpan" id="kobo.199.4">One approach would be to declare them in a separate file and document that the usage reports rely </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">on them.</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.201.1">Traces and logs describing HTTP requests contain similar information. </span><span class="koboSpan" id="kobo.201.2">Logs are more verbose, since we’d usually have human-readable text and need two records for one request (before and after it), with duplicated trace context and </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">other scopes.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.203.1">If your application records all HTTP traces, there is no need to enable HTTP logging as well. </span><span class="koboSpan" id="kobo.203.2">If traces are sampled, there is a trade-off between the cost of capturing all telemetry and your ability to investigate rare issues. </span><span class="koboSpan" id="kobo.203.3">Many applications don’t really need to capture all telemetry to efficiently investigate problems. </span><span class="koboSpan" id="kobo.203.4">For them, collecting sampled traces without HTTP logs would be the best option. </span><span class="koboSpan" id="kobo.203.5">If you have to investigate rare issues, one option would be to increase the sampling rate for traces. </span><span class="koboSpan" id="kobo.203.6">Recording HTTP logs instead is another option that comes with an additional cost to collect, store, retrieve, and analyze logs.</span></p>
<h1 id="_idParaDest-256"><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.204.1">Chapter 9 – Best Practices</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.205.1">HTTP traces, potentially combined with some application-specific attributes, can help answer most questions about tiny RESTful service behavior. </span><span class="koboSpan" id="kobo.205.2">We can aggregate metrics from traces using OpenTelemetry Collector or at query time on the backend. </span><span class="koboSpan" id="kobo.205.3">We still need metrics for resource utilization though. </span><span class="koboSpan" id="kobo.205.4">The right questions to ask here are how much this solution costs us and whether there is the potential to reduce costs with sampling and how much we must spend to keep alerts running based on queries over traces. </span><span class="koboSpan" id="kobo.205.5">If it’s a lot, then we should look into adding metrics. </span><span class="koboSpan" id="kobo.205.6">So, the answer is – yes, but it can be more cost-efficient to add </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">other signals.</span></span></li>
<li><span class="koboSpan" id="kobo.207.1">In an application under heavy load, every bug will happen again and again. </span><span class="koboSpan" id="kobo.207.2">No matter how small of a sampling rate we choose, we’ll record at least some occurrences of such an issue. </span><span class="koboSpan" id="kobo.207.3">A high sampling rate would likely have some performance impact, but more importantly, it’ll be very expensive to store all these traces. </span><span class="koboSpan" id="kobo.207.4">So, a small sampling rate should be the </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">first choice.</span></span></li>
<li><span class="koboSpan" id="kobo.209.1">Socket communication can be very frequent, so instrumenting every request with a span can create a huge overhead. </span><span class="koboSpan" id="kobo.209.2">A good starting point would be to identify how long a typical session lasts, and if it’s within seconds or minutes, instrument a session with a span. </span><span class="koboSpan" id="kobo.209.3">Small requests can be recorded with metrics on a service side, or sometimes </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">with logs/events.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.211.1">OpenTelemetry general and RPC semantic conventions should cover the necessary network attributes to represent the client and server and describe a request. </span><span class="koboSpan" id="kobo.211.2">We can also apply suitable RPC metrics to track duration and throughput.</span></p>
<h1 id="_idParaDest-257"><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.212.1">Chapter 10 – Tracing Network Calls</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.213.1">Reusing existing instrumentation should be the first choice, especially if you don’t have a lot of experience in both tracing and the gRPC stack. </span><span class="koboSpan" id="kobo.213.2">As you saw throughout this chapter, there are multiple details related to retries, the order of execution, and other tiny details that are hard to </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">account for.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.215.1">Custom gRPC instrumentation makes sense if existing instrumentation does not satisfy your needs. </span><span class="koboSpan" id="kobo.215.2">For example, in our streaming experiments, we could optimize two layers of instrumentation (individual messages and gRPC calls) by merging them into one. </span><span class="koboSpan" id="kobo.215.3">We could also correlate requests, responses, and span events better if we knew the message types in the interceptor.</span></p>
<p><span class="koboSpan" id="kobo.216.1">Note that even custom instrumentations benefit from following semantic conventions and relying on common tooling and documentation.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.217.1">In such an application, we should expect to see a very long span that describes a connection between the client and server. </span><span class="koboSpan" id="kobo.217.2">If we sample spans, we should customize the sampler to ensure we capture this span. </span><span class="koboSpan" id="kobo.217.3">Alternatively, we can just drop it and instead capture events that describe anything important that happens with the </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">encompassing connection.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.219.1">Then, we should think about how/whether to trace individual messages. </span><span class="koboSpan" id="kobo.219.2">If they are very small and fast, tracing them individually could be too expensive because of a couple of concerns:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.220.1">The first concern is message size. </span><span class="koboSpan" id="kobo.220.2">Trace context can be propagated frugally with the binary format, but still would require at least 26 bytes. </span><span class="koboSpan" id="kobo.220.3">You can be creative and come up with even more frugal format, propagating the message index instead of the span ID over the wire. </span><span class="koboSpan" id="kobo.220.4">The easiest solution would be to propagate context only for sampled-in messages and rely on metrics and events to see the </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">overall picture.</span></span></li>
<li><span class="koboSpan" id="kobo.222.1">The second concern is performance overhead. </span><span class="koboSpan" id="kobo.222.2">If your processing is very fast, tracing it might be too expensive. </span><span class="koboSpan" id="kobo.222.3">Sampling can help offset some of these costs, but you probably don’t need to trace individual messages. </span><span class="koboSpan" id="kobo.222.4">Logs and events might give you the right level of observability, and you can correlate them with a </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">message identifier.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.224.1">If your message processing is complex and involves other network calls, you’d benefit from mitigating these concerns and tracing individual messages.</span></p>
<h1 id="_idParaDest-258"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.225.1">Chapter 11 – Instrumenting Messaging Scenarios</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.226.1">The most difficult part is finding operations that are important to measure. </span><span class="koboSpan" id="kobo.226.2">In our example, it’s the time between when the meme is uploaded and when it became available for </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">other users.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.228.1">We can emit a couple of events to capture these two timestamps along with the meme identifier and any other context. </span><span class="koboSpan" id="kobo.228.2">Then, we can find the delta by joining events on the meme identifier.</span></p>
<p><span class="koboSpan" id="kobo.229.1">Another option is to record the timestamp of when the meme was published along with the meme metadata and pass it around our system. </span><span class="koboSpan" id="kobo.229.2">Then, we can report delta as a metric or an event.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.230.1">When using batching, it’s usually interesting to know the number of messages in a batch and the payload size. </span><span class="koboSpan" id="kobo.230.2">By tuning these numbers, we can reduce network overhead, so having them readily available in the telemetry can be </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">very useful.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.232.1">The key question is what instrument to use: a counter or histogram (a gauge would not fit here).</span></p>
<p><span class="koboSpan" id="kobo.233.1">We can count messages and batches with two metrics. </span><span class="koboSpan" id="kobo.233.2">The ratio between them would give us the average batch size.</span></p>
<p><span class="koboSpan" id="kobo.234.1">We can also record the number of messages in a batch and the payload size as histograms. </span><span class="koboSpan" id="kobo.234.2">This would give us a distribution in addition to average numbers.</span></p>
<p><span class="koboSpan" id="kobo.235.1">I was tempted to record the batch size as an attribute on existing metrics but decided against it. </span><span class="koboSpan" id="kobo.235.2">In a general case, it’s a high-cardinality attribute, which is also hard to visualize in Prometheus; it would make more sense as a separate metric.</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.236.1">Baggage represents application-specific context-propagated services. </span><span class="koboSpan" id="kobo.236.2">If you have a need to propagate it across messaging systems, it can be injected into each message with the OpenTelemetry propagator similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">trace context.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.238.1">Baggage usually does not need to flow to the messaging system, but it may be hard to prevent it. </span><span class="koboSpan" id="kobo.238.2">Attached to every message, it might create a significant overhead in terms of the payload size, so make sure to account for it and be ready to make trade-offs.</span></p>
<p><span class="koboSpan" id="kobo.239.1">On the consumption side, things get more interesting. </span><span class="koboSpan" id="kobo.239.2">If messages are processed independently, make sure to restore baggage from the message when processing it.</span></p>
<p><span class="koboSpan" id="kobo.240.1">For batch processing, there is no single answer. </span><span class="koboSpan" id="kobo.240.2">Merging baggage from multiple messages may or may not make sense in your application.</span></p>
<p><span class="koboSpan" id="kobo.241.1">If you want to stamp baggage information on your telemetry, one option could be to record known baggage values on link attributes along with message-specific information.</span></p>
<h1 id="_idParaDest-259"><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.242.1">Chapter 12 – Instrumenting Database Calls</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.243.1">The concept of a database change feed is similar to messaging, and we can apply the same approach we used in the previous chapter for it. </span><span class="koboSpan" id="kobo.243.2">The key question is how to propagate context and correlate operations that change the record and process </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">the notification.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.245.1">One solution would be to add a record identifier attribute and use it to find all the operations related to a specific record. </span><span class="koboSpan" id="kobo.245.2">When multiple operations concurrently modify the same record, it will generate multiple notifications and we won’t be able to map producer operations to notification processing with the record ID. </span><span class="koboSpan" id="kobo.245.3">There might be additional notification identifiers we can use, such as record ETags. </span><span class="koboSpan" id="kobo.245.4">But in general cases, correlating operations that modify data and ones that process corresponding notifications would mean we have to add a trace context to the record and modify it on every operation.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.246.1">The answer depends on how your tracing backend treats events and how mature, robust, and reliable the cache configuration and </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">infrastructure are.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.248.1">Arguments for using events would be the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.249.1">Spans/activities have a slightly bigger performance overhead than events. </span><span class="koboSpan" id="kobo.249.2">Events also could be smaller in terms of </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">telemetry volume.</span></span></li>
<li><span class="koboSpan" id="kobo.251.1">We don’t need the precise Redis duration for each operation since we have logical layer activity tracing composite calls and </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">Redis metrics.</span></span></li>
<li><span class="koboSpan" id="kobo.253.1">The status of individual Redis calls is not very important: a set operation is even done in a fire-and-forget manner. </span><span class="koboSpan" id="kobo.253.2">It only matters when the failure rate increases significantly, but we’d see it in </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">the metrics.</span></span></li>
</ul>
<ol>
<li value="3"><span class="koboSpan" id="kobo.255.1">The argument to use spans is that it’s more common and convenient because tracing backends do a much better job at visualizing spans and performing any automated analysis </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">on them.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.257.1">To remove limits, remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">deploy</span></strong><span class="koboSpan" id="kobo.259.1"> section under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">mongo</span></strong><span class="koboSpan" id="kobo.261.1"> container in </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.263.1">. </span><span class="koboSpan" id="kobo.263.2">If you run the application and kill Redis, you’ll see that MongoDB can easily handle the load and throughput changes, which might mean that Redis is not necessary in an application with such a small load.</span></p>
<h1 id="_idParaDest-260"><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.264.1">Chapter 13 – Driving Change</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.265.1">Using a single backend for all signals has certain advantages. </span><span class="koboSpan" id="kobo.265.2">It should be easier to navigate between signals: for example, get all logs correlated with the trace, query events, and traces together with additional context, and jump from metrics to trace with exemplars. </span><span class="koboSpan" id="kobo.265.3">So, using a single backend would reduce cognitive load and minimize duplication in backend-related configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">and tooling.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.267.1">Using multiple backends can help reduce costs. </span><span class="koboSpan" id="kobo.267.2">For example, it’s usually possible to store logs in a cheaper log management system, assuming you already have everything up and running for logs and metrics. </span><span class="koboSpan" id="kobo.267.3">But these backends don’t always support traces well. </span><span class="koboSpan" id="kobo.267.4">Adding a new backend for traces and events only would make total sense.</span></p>
<p><span class="koboSpan" id="kobo.268.1">Tools such as Grafana may be able to provide a common UX on top of different backends to mitigate some of the disadvantages.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.269.1">There are a few things that we need </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">to do:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.271.1">Lock down the context propagation format</span></strong><span class="koboSpan" id="kobo.272.1">: Using W3C Baggage spec is a good default choice unless you already have something in place. </span><span class="koboSpan" id="kobo.272.2">It should be documented and, ideally, implemented and configured in internal common libraries shared by all services in </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">your application.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.274.1">Documenting key naming patterns</span></strong><span class="koboSpan" id="kobo.275.1">: Make sure to use namespaces and define the root one for your system. </span><span class="koboSpan" id="kobo.275.2">It’ll help filter everything else out. </span><span class="koboSpan" id="kobo.275.3">Document several common properties you want to put there – we want to make sure people use them and don’t come up with something custom. </span><span class="koboSpan" id="kobo.275.4">Adding helper methods to populate them would also </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">be great.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.277.1">Use common artifacts</span></strong><span class="koboSpan" id="kobo.278.1">: If you want to stamp baggage on telemetry, customize propagation, or just unify baggage keys, make sure to ship common internal libraries with </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">these features.</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.280.1">When adding a cache, we’re probably trying to reduce the load on a database and optimize the service response time. </span><span class="koboSpan" id="kobo.280.2">We should already have observability of service and database calls and can see whether the cache </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">would help.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.282.1">If we roll this feature out gradually and conditionally, we need to be able to filter and compare telemetry based on feature flags, so we need to make sure they’re recorded.</span></p>
<p><span class="koboSpan" id="kobo.283.1">Finally, we should make sure we have telemetry around the cache that will help us understand how it works, and why it did not work if it fails. </span><span class="koboSpan" id="kobo.283.2">Adding this telemetry along with feature code will have the biggest positive impact during development, testing, and initial iterations.</span></p>
<h1 id="_idParaDest-261"><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.284.1">Chapter 14 – Creating Your Own Conventions</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.285.1">A possible solution is to define and document the stability level </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">for attributes.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.287.1">For example, new conventions are always added at the alpha stability level. </span><span class="koboSpan" id="kobo.287.2">Once it’s fully implemented and deployed, and you’re mostly happy with the outcome, the convention can be graduated to beta.</span></p>
<p><span class="koboSpan" id="kobo.288.1">Conventions should stay in beta until someone tries to use them for alerts, reports, or dashboards. </span><span class="koboSpan" id="kobo.288.2">If it works fine, or after feedback is addressed, the convention becomes stable. </span><span class="koboSpan" id="kobo.288.3">After that, it cannot be changed in a breaking manner.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.289.1">It should be possible to validate actual telemetry to </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">some extent.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.291.1">For example, it should be possible to write a test processor (an in-process one or a custom collector component) that identifies specific spans, events, or metrics that should follow the convention and checks whether the conventions are applied consistently. </span><span class="koboSpan" id="kobo.291.2">This test processor could warn about issues found, flag unknown attributes, notify when expected signals were not received, and so on. </span><span class="koboSpan" id="kobo.291.3">It should be possible to run it as a part of integration testing in the CI pipeline.</span></p>
<p><span class="koboSpan" id="kobo.292.1">Another approach is to just do a regular audit on a random subset of production telemetry, which could also be automated.</span></p>
<h1 id="_idParaDest-262"><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.293.1">Chapter 15 – Instrumenting Brownfield Applications</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.294.1">Such a service is a good candidate for migration to OpenTelemetry – since we still update it, there is probably a reasonable test infrastructure and the context within the team to prevent and mitigate failures. </span><span class="koboSpan" id="kobo.294.2">As a first option, we should consider adding OpenTelemetry with network instrumentation and then gradually migrating existing tools and processes onto the new observability solution, while evolving an </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">OpenTelemetry-based approach.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.296.1">We can control the costs of this approach with sampling, enabling and moving only essential pieces onto OpenTelemetry. </span><span class="koboSpan" id="kobo.296.2">At some point, when we can rely on the new observability solution, we can remove corresponding legacy reporting.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.297.1">It’s likely that the .NET runtime version that the legacy service runs on is older than .NET 4.6.2, and then it’s impossible to use OpenTelemetry. </span><span class="koboSpan" id="kobo.297.2">Even if a newer version of .NET Framework is used, adding new dependencies, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">System.Diagnostics.DiagnosticSource</span></strong><span class="koboSpan" id="kobo.299.1"> and the different </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">Microsoft.Extensions</span></strong><span class="koboSpan" id="kobo.301.1"> packages that OpenTelemetry brings transitively, can cause runtime problems due to </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">version conflicts.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.303.1">Other risks come from small changes and shifts in how an application works and its performance, waking up or amplifying dormant issues such as race conditions, deadlocks, or thread pool starvation.</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.304.1">If you can add newer versions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">System.Diagnostics.DiagnosticSource</span></strong><span class="koboSpan" id="kobo.306.1"> as a dependency, then using </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">Activity</span></strong><span class="koboSpan" id="kobo.308.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">an option.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.310.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">Activity</span></strong><span class="koboSpan" id="kobo.312.1"> class is available in .NET, starting with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">DiagnosticSource</span></strong><span class="koboSpan" id="kobo.314.1"> package version 4.4.0 and .NET Core 3.0; however, it went through a lot of changes. </span><span class="koboSpan" id="kobo.314.2">Most of the functionality we covered in this book, including W3C Trace Context, was not available in the initial versions.</span></p>
<p><span class="koboSpan" id="kobo.315.1">With newer </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">DiagnosticSource</span></strong><span class="koboSpan" id="kobo.317.1"> versions, by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">Activity</span></strong><span class="koboSpan" id="kobo.319.1">, we would modify trace context – instead of passing </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">traceparent</span></strong><span class="koboSpan" id="kobo.321.1"> as is, we would create server and client spans and then pass an ancestor of the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">traceparent</span></strong><span class="koboSpan" id="kobo.323.1"> to the downstream service. </span><span class="koboSpan" id="kobo.323.2">If the legacy service does not report spans to the common observability backend, we’ll see correlated traces, but with missing parent-child relationships, as we saw in </span><em class="italic"><span class="koboSpan" id="kobo.324.1">Figure 15.4</span></em><span class="koboSpan" id="kobo.325.1">.</span></p>
<p><span class="koboSpan" id="kobo.326.1">So, we need to have full-fledged distributed tracing implemented or, if no traces are reported, pass context through as is, without using </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">Activity</span></strong><span class="koboSpan" id="kobo.328.1"> for it.</span></p>
</div>
</body></html>