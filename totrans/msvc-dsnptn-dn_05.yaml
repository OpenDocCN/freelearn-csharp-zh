- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Working with the CQRS Pattern
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CQRS 模式进行工作
- en: We now know that microservices require a bit of foresight during the planning
    phase, and we need to ensure that we employ the best patterns and technology to
    support our decisions. In this chapter, we will be exploring another pattern that
    has gained much acclaim in helping us to write clean and maintainable code. This
    is the **Command Query Responsibility Segregation or Separation** (**CQRS**) pattern,
    which is an extension of the **Command-Query Separation** (**CQS**) pattern.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道，在规划阶段，微服务需要一定的前瞻性，我们需要确保我们采用最佳的模式和技术来支持我们的决策。在本章中，我们将探讨另一种在帮助我们编写干净且可维护的代码方面受到广泛赞誉的模式。这就是
    **命令查询责任分离或分离**（**CQRS**）模式，它是 **命令查询分离**（**CQS**）模式的扩展。
- en: This pattern allows us to cleanly separate our query operations from our command
    operations. In essence, a query asks for data, and the command should modify data
    in one way or another by the end of the operation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式使我们能够干净地分离我们的查询操作和命令操作。本质上，查询请求数据，而命令应该在操作结束时以某种方式修改数据。
- en: As programmers, we tend to employ **Create, Read, Update, and Delete** (**CRUD**)
    in our applications. Considering that every application’s core functionality is
    to support CRUD operations, this is understandable. But the more intricate the
    application gets, the more we need to consider the business logic surrounding
    each of these operations, relative to the problem domain we are addressing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们倾向于在我们的应用程序中使用 **创建、读取、更新和删除**（**CRUD**）。考虑到每个应用程序的核心功能都是支持 CRUD 操作，这是可以理解的。但随着应用程序变得更加复杂，我们需要更多地考虑围绕这些操作的商务逻辑，相对于我们正在解决的问题域。
- en: At that point, we begin to use words such as *behavior* and *scenarios*. We
    begin to consider structuring our code in a manner that allows us to isolate behaviors
    and easily determine whether this behavior is simply a request for data or will
    augment data by the end of the operation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到那时，我们开始使用诸如 *行为* 和 *场景* 这样的词汇。我们开始考虑以某种方式构建我们的代码，使我们能够隔离行为，并轻松地确定这种行为是否仅仅是请求数据，还是会在操作结束时通过某种方式增强数据。
- en: 'After reading this chapter, you will achieve the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，你将实现以下目标：
- en: Understand the benefits of the CQRS pattern and why it is used for microservices
    development
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 CQRS 模式的优势以及为什么它被用于微服务开发
- en: Know how to implement commands in the CQRS pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何在 CQRS 模式中实现命令
- en: Know how to implement queries in the CQRS pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何在 CQRS 模式中实现查询
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Code references used in this chapter can be found in the project repository,
    which is hosted on GitHub at this URL: [https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch05](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch05).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码参考可以在项目仓库中找到，该仓库托管在 GitHub 上，网址为：[https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch05](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch05)。
- en: Why use CQRS for microservices development?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要在微服务开发中使用 CQRS？
- en: '**CQS** was introduced as a pattern that would help developers separate code
    that does read operations from code that does write operations. The shortcoming
    with it was that it didn’t account for establishing specific models for each operation.
    CQRS built on this and introduced the concept of having specific models, tailored
    for the operation to be carried out.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**CQS** 被引入作为一种模式，旨在帮助开发者将执行读取操作的代码与执行写入操作的代码分离。它的不足之处在于，它没有考虑到为每个操作建立特定的模型。CQRS
    在此基础上发展，并引入了为要执行的操作定制特定模型的概念。'
- en: '*Figure 5.1* shows a typical CQRS architecture:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.1* 展示了典型的 CQRS 架构：'
- en: '![Figure 5.1 – The application will interact with models for read operations
    and models for write operations, known as commands](img/Figure_5.1_B19100.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 应用程序将与读取操作和写入操作（称为命令）的模型进行交互](img/Figure_5.1_B19100.jpg)'
- en: Figure 5.1 – The application will interact with models for read operations and
    models for write operations, known as commands
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 应用程序将与读取操作和写入操作（称为命令）的模型进行交互
- en: If you look a bit more closely, it can be argued that CQS only accounts for
    one data store, meaning we are doing read/write operations against the same database.
    CQRS would suggest that you have separate data stores, having potentially a standard
    relational database for your write operations and conducting read operations for
    a separate store, such as a document database or data warehouse. The implementation
    of multiple data stores is not always an option, nor is it a must.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更仔细地观察，可以认为CQS只考虑了一个数据存储，这意味着我们正在对同一个数据库进行读写操作。CQRS会建议你拥有单独的数据存储，可能有一个标准的关系数据库用于你的写入操作，并为另一个存储（如文档数据库或数据仓库）执行读取操作。实现多个数据存储并不总是可行的，也不是必须的。
- en: CQRS has gained much acclaim since its introduction in development and is touted
    as a very important staple in microservice design. The truth is, it can be used
    in standard applications, so it is not unique to microservices. It also adds a
    new level of complexity to the development effort as it introduces the need for
    more specific classes and code to be written, which can lead to project bloat.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 自从CQRS在开发中引入以来，它获得了许多赞誉，并被誉为微服务设计中的一个非常重要的支柱。事实上，它也可以用于标准应用程序，因此它并不仅限于微服务。它还增加了开发工作的新层次复杂性，因为它引入了需要编写更多特定类和代码的需求，这可能导致项目膨胀。
- en: It is said, *“…when we have a hammer, everything looks like a nail…”* and this
    remains true in the context of when we hear of a new pattern and feel the need
    to use it everywhere. I suggest that you apply caution and careful consideration
    before using this pattern and ensure that its value in the application is justified.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常说，“……当我们有一把锤子时，一切看起来都像钉子……”这在当我们听到一个新的模式并觉得需要到处使用它时仍然适用。我建议在使用此模式之前要谨慎并仔细考虑，并确保其在应用程序中的价值是合理的。
- en: For bigger applications, CQRS is recommended to help us structure our code and
    more cleanly handle potentially complex business logic and moving parts. Though
    it is complex, it does have benefits. Let us review the benefits of implementing
    the CQRS pattern in our applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大的应用程序，建议使用CQRS来帮助我们结构化代码，并更干净地处理可能复杂的业务逻辑和移动部件。尽管它很复杂，但它确实有好处。让我们回顾一下在我们的应用程序中实现CQRS模式的好处。
- en: Benefits of the CQRS pattern
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CQRS模式的优点
- en: CQRS is about splitting a single model into two variations, one for reads and
    one for writes. The end goal, however, is a bigger spoke in the wheel. The first
    benefit of this approach is scalability.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS是关于将单个模型拆分为两个变体，一个用于读取，一个用于写入。然而，最终目标是一个更大的轮辐。这种方法的第一个好处是可扩展性。
- en: It is important to assess the read/write workload of the system you are building.
    Read operations are arguably more intensive than write operations, given that
    one read may require copious amounts of data from several tables and each request
    might have its own requirements around what the data needs to look like. One school
    of thought encourages that we employ a data store that is dedicated to and optimized
    for reading operations. This allows us to scale read operations separately from
    write operations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 评估你正在构建的系统的读写工作量是很重要的。考虑到一次读取可能需要从几个表中获取大量数据，并且每个请求可能都有其自己的数据外观要求，读取操作可能比写入操作更密集。一种观点鼓励我们采用一个专门用于和优化读取操作的数据存储。这使我们能够将读取操作与写入操作分开进行扩展。
- en: An example of a dedicated read store could be a *data warehouse*, where data
    is constantly being transformed by some form of data transformation pipeline,
    from the write data store, which is probably a normalized *relational database*.
    Another commonly used technology is NoSQL databases such as **MongoDB** or **Cosmos
    DB**. The data constructs provided by the data warehouse or NoSQL databases represent
    a denormalized, read-only version of the data from the relational data store.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个专门的读取存储示例可以是*数据仓库*，其中数据通过某种形式的数据转换管道不断被转换，从可能是规范化*关系数据库*的写入数据存储。另一种常用的技术是NoSQL数据库，如**MongoDB**或**Cosmos
    DB**。数据仓库或NoSQL数据库提供的数据结构代表了从关系数据存储中提取的未规范化、只读版本的数据。
- en: '*Figure 5.2* shows a CQRS architecture with two databases:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.2*展示了具有两个数据库的CQRS架构：'
- en: "![Figure 5.2 – The query model represents read operation-optimized representations\
    \ of the data from the \uFEFFtransactional database](img/Figure_5.2_B19100.jpg)"
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 查询模型表示从事务数据库中优化的读取操作的数据](img/Figure_5.2_B19100.jpg)'
- en: Figure 5.2 – The query model represents read operation-optimized representations
    of the data from the transactional database
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 查询模型表示从事务数据库中优化的读取操作的数据表示
- en: The second benefit is performance. Though it seems to go hand in hand with scalability,
    there are different dynamics that we consider. Using separate data stores isn’t
    always a viable option, so there are other techniques that we can employ to optimize
    our operations that wouldn’t be possible with a unified data model. We can apply
    caching, for instance, to queries that do read operations. We can also employ
    database-specific features and fine-tuned raw SQL statements for our requests
    in contrast to **object-relational mapping** (**ORM**) code on the side of the
    command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个好处是性能。尽管它似乎与可扩展性密不可分，但我们考虑的因素有所不同。使用独立的数据存储并不总是可行的选择，因此我们可以采用其他技术来优化我们的操作，而这些技术在不使用统一数据模型的情况下是不可能的。例如，我们可以应用缓存来查询执行读取操作。我们还可以使用针对我们请求的特定数据库功能和微调的原始SQL语句，而不是在命令方面使用**对象关系映射**（**ORM**）代码。
- en: Another benefit that we can reap from this pattern is simplicity. This sounds
    contradictory given that we mentioned complications in the earlier parts of this
    chapter, but it depends on the lens that you use to assess the rewards you will
    reap in the long run. Commands and queries have different needs, and it is not
    reasonable to use one data model to suit both sets of needs. CQRS forces us to
    consider creating specific data models for each query or command, which leads
    to more maintainable code. Each new data model is responsible for a specific operation,
    and modification therein will have little to no impact on other aspects of our
    program.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这个模式中获得另一个好处，那就是简单性。考虑到我们在本章前面的部分提到了复杂性，这似乎有些矛盾，但这取决于你用来评估你将长期获得的回报的视角。命令和查询有不同的需求，使用一个数据模型来满足这两组需求是不合理的。CQRS迫使我们考虑为每个查询或命令创建特定的数据模型，这导致代码更容易维护。每个新的数据模型都负责特定的操作，对其进行的修改将对程序的其他方面影响很小或没有影响。
- en: We see here that there are a few benefits to using CQRS in our projects. But
    where there are pros, there are cons. Let us review some of the downsides to employing
    this design pattern.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到，在我们的项目中使用CQRS有一些好处。但是，有利必有弊。让我们回顾一下采用这种设计模式的一些缺点。
- en: Disadvantages of the CQRS pattern
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CQRS模式的缺点
- en: Every pattern that we consider must be investigated thoroughly for the value
    that it adds, and the potential drawbacks. We always want to make sure that the
    benefits outweigh the disadvantages and that we won’t live to regret these major
    design decisions. CQRS is not ideal for applications that will do simple CRUD
    operations. It is behavior- or scenario-driven, as we have stated, so be sure
    that you can justify the use cases before you take the plunge. This pattern will
    lead to a perceived duplication of code since it promotes the concept of **separation
    of concerns** (**SoC**) and encourages that commands and queries have dedicated
    models.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑的每一个模式都必须彻底调查它所增加的价值和潜在的缺点。我们总是想确保好处大于坏处，并且我们不会后悔这些重大的设计决策。CQRS对于将执行简单的CRUD操作的应用程序来说并不理想。它是以行为或场景驱动的，正如我们之前所提到的，所以在你跳入之前，一定要确保你能证明用例的合理性。这个模式会导致代码感知上的重复，因为它促进了**关注点分离**（**SoC**）的概念，并鼓励命令和查询有专门的模式。
- en: On a personal note, I have seen development leads start off with all the best
    intentions and implement CQRS in projects that, in truth, didn’t require it. The
    projects turned out to be overcomplicated, leaving all the newer developers completely
    confused as to what went where.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 说到个人观点，我见过一些开发负责人一开始充满热情，却在实际上并不需要CQRS的项目中实施了它。结果，项目变得过于复杂，让所有的新开发人员完全搞不清楚东西在哪里。
- en: As we have seen, there is a case for multiple data storage areas when we use
    CQRS. Arguably, that is the most complete implementation of it. Once we introduce
    multiple data stores, we introduce data consistency problems and need to implement
    *Event Sourcing* techniques and include **service-level agreements** (**SLAs**)
    to let our users know of the potential gap between our read/write operations.
    We also must consider the additional costs in terms of infrastructure and general
    operation when we have multiple databases. With multiple databases comes multiple
    potential points of failure and the need for additional monitoring and fail-safe
    techniques to ensure that the system runs as smoothly as possible, even in the
    face of outages.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，当我们使用CQRS时，存在多个数据存储区域的情况。这可能是它的最完整实现。一旦我们引入多个数据存储，我们就引入了数据一致性问题，并需要实现*事件溯源*技术，并包括**服务级别协议**（**SLAs**）来让我们的用户了解我们读写操作之间可能存在的差距。当我们拥有多个数据库时，我们也必须考虑额外的成本，包括基础设施和一般操作。随着数据库的增加，潜在的故障点也增加，我们需要额外的监控和故障安全技术来确保系统尽可能平稳运行，即使在出现故障的情况下。
- en: CQRS can add value to a project when it is applied sensibly. When your project
    has complex business logic, or a distinct need for separating data stores and
    read/write operations, then CQRS will shine as an appropriate architectural choice.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当CQRS被合理应用时，它可以给项目带来价值。当你的项目拥有复杂的业务逻辑，或者有明确的需求来分离数据存储和读写操作时，CQRS将作为一个合适的架构选择大放异彩。
- en: This pattern is not unique to any programming language, and .NET has excellent
    support for the pattern. Now let us review implementing CQRS using the Mediator
    pattern with the help of a few tools and libraries.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式并不特定于任何编程语言，.NET对这种模式有很好的支持。现在让我们通过一些工具和库的帮助，回顾使用Mediator模式实现CQRS。
- en: Using the Mediator pattern with CQRS in .NET
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在.NET中使用CQRS的Mediator模式
- en: Before we get into how we implement CQRS, we should discuss a supporting pattern
    called the *Mediator* pattern. The Mediator pattern involves us defining an object
    that embodies how objects interact with each other. So, we can avoid two or more
    objects having direct dependencies on each other and, instead, use a mediator
    in between that will orchestrate the dependencies and route requests to appropriate
    *handlers*. A handler will define all the details of the operation to be carried
    out based on the scenario or task to which the model is associated.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨如何实现CQRS之前，我们应该讨论一个支持模式，称为*Mediator*模式。Mediator模式涉及我们定义一个对象，该对象体现了对象之间的交互方式。因此，我们可以避免两个或多个对象之间直接依赖，而是使用一个中介来协调依赖关系，并将请求路由到适当的*处理程序*。处理程序将根据模型关联的场景或任务定义操作的所有细节。
- en: '*Figure 5.3* shows how the Mediator pattern works:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.3*展示了Mediator模式的工作方式：'
- en: '![Figure 5.3 – The query/command model is registered in the mediator engine,
    which then selects the appropriate handler for an operation](img/Figure_5.3_B19100.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 查询/命令模型在中介引擎中注册，然后选择适当的处理程序](img/Figure_5.3_B19100.jpg)'
- en: Figure 5.3 – The query/command model is registered in the mediator engine, which
    then selects the appropriate handler for an operation
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 查询/命令模型在中介引擎中注册，然后选择适当的处理程序
- en: The Mediator pattern becomes useful relative to the implementation of the CQRS
    pattern since we need to promote loose coupling between the code being defined
    for each task. It allows us to maintain *loose coupling* and promotes more testability
    and scalability.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 相对于为每个任务定义的代码实现，Mediator模式在CQRS的实现中变得有用，因为我们需要促进代码之间的松耦合。它允许我们保持*松耦合*，并促进更高的可测试性和可扩展性。
- en: In .NET Core, we have an excellent third-party package called `MediatR` that
    helps us implement this pattern with relative ease. `MediatR` assumes the role
    of an *in-process* mediator where it manages how classes interact with each other
    during the same process. One limitation here is that it might not be the best
    package if we wanted to separate commands and queries across different systems.
    Notwithstanding that drawback, it helps us to author CQRS-based systems with relative
    ease, efficiency, and reliability. We can develop strongly typed code that will
    ensure that we do not mismatch models and handlers, and we can even construct
    pipelines to govern the entire behavior of a request as it flows through the complete
    cycle.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET Core 中，我们有一个名为 `MediatR` 的优秀第三方包，它帮助我们相对容易地实现此模式。`MediatR` 扮演了 *进程内*
    中介者的角色，它管理类在同一个进程中的交互方式。这里的局限性是，如果我们想要在不同系统中分离命令和查询，它可能不是最好的包。尽管有这个缺点，但它帮助我们相对容易、高效和可靠地编写基于
    CQRS 的系统。我们可以开发强类型代码，这将确保我们不会不匹配模型和处理程序，我们甚至可以构建管道来管理请求在整个周期中的整个行为。
- en: 'In a .NET Core application, we can set up `MediatR` using the following steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET Core 应用程序中，我们可以按照以下步骤设置 `MediatR`：
- en: Install the `MediatR.Extensions.Microsoft.DependencyInjection` NuGet package
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `MediatR.Extensions.Microsoft.DependencyInjection` NuGet 包
- en: 'Modify our `Program.cs` file with the following line: `builder.Services.AddMediatR(typeof(Program));`'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下行修改我们的 `Program.cs` 文件：`builder.Services.AddMediatR(typeof(Program));`
- en: Once we have done this, we can proceed to inject our `IMediator` service into
    our controllers or endpoints for further use. We will also need to implement two
    files that will directly relate to each other as the command/query model and the
    corresponding handler.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们可以继续将我们的 `IMediator` 服务注入到我们的控制器或端点以供进一步使用。我们还需要实现两个文件，这两个文件将直接相互关联，即命令/查询模型和相应的处理器。
- en: Now that we have explored the foundations of setting up a CQRS implementation
    using the Mediator pattern, let us review the steps required to implement a command.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经探讨了使用中介者模式设置 CQRS 实现的基础，让我们回顾一下实现命令所需的步骤。
- en: Implementing a command
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个命令
- en: As we remember, a command is expected to carry out actions that will augment
    the data in the data store, otherwise called a write operation. Given that we
    are using the Mediator pattern to govern how we carry out these operations, we
    will need a command model and a handler.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所记，命令预期将执行将增强数据存储中数据的操作，这通常称为写操作。鉴于我们正在使用中介者模式来管理我们执行这些操作的方式，我们需要一个命令模型和一个处理器。
- en: Creating a command model
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个命令模型
- en: Our model is relatively simple to implement. It tends to be a standard class
    or record, but with `MediatR` present,we will implement a new type called `IRequest`.
    `IRequest` will associate this model class with an associated handler, which we
    will be looking into in a bit.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式相对简单易实现。它通常是一个标准的类或记录，但在 `MediatR` 的帮助下，我们将实现一个名为 `IRequest` 的新类型。`IRequest`
    将将这个模型类与一个相关的处理器关联起来，我们将在稍后探讨这一点。
- en: 'In the example of making an appointment in our system, we can relatively easily
    implement a `CreateAppointmentCommand.cs` file like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们系统的预约示例中，我们可以相对容易地实现一个 `CreateAppointmentCommand.cs` 文件，如下所示：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We use a `record` type in this example, but it could just as easily be a class
    definition if that is more comfortable for you. Notice that we inherit from `IRequest<string>`,
    which outlines to `MediatR` the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个 `record` 类型，但如果你觉得更舒服，它也可以是一个类定义。请注意，我们继承自 `IRequest<string>`，这向
    `MediatR` 概述了以下内容：
- en: This command should be associated with a handler with a corresponding return
    type.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个命令应该与一个具有相应返回类型的处理器相关联。
- en: The handler that is associated with this command is expected to return a string
    value. This will be the appointment `Id` value.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与此命令相关联的处理程序预期将返回一个字符串值。这将是一个预约 `Id` 值。
- en: Commands don’t always need to return a type. If you don’t expect a return type,
    you may simply inherit from `IRequest`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 命令并不总是需要返回一个类型。如果你不期望返回类型，你可以简单地从 `IRequest` 继承。
- en: Now that we have an idea of how the command model needs to look, let us implement
    the corresponding handler.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了命令模型需要看起来是什么样子，让我们实现相应的处理器。
- en: Creating a command handler
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个命令处理器
- en: Our handler is where the logic for carrying out the task usually sits. In some
    implementations and in the absence of a rich data model, you can carry out all
    the validations and additional tasks required to ensure that the task is handled
    properly. This way, we can better isolate the business logic that is expected
    when a particular command is sent for execution.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的处理器是执行任务逻辑通常所在的地方。在某些实现中，在没有丰富数据模型的情况下，你可以执行所有必要的验证和附加任务，以确保任务得到妥善处理。这样，我们可以更好地隔离在发送特定命令以执行时预期的业务逻辑。
- en: 'Our handler for our command to create an appointment will be called `CreateAppointmentHandler.cs`
    and can be implemented like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于创建预约的处理器将被命名为 `CreateAppointmentHandler.cs`，可以像这样实现：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are several things to take note of here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有几个需要注意的事项：
- en: The handler inherits from `IRequestHandler<>`. In the type brackets, we outline
    the specific *command model type* that the handler is being implemented for and
    the *expected return type*.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器继承自 `IRequestHandler<>`。在类型括号中，我们概述了处理器将要实现的特定 *命令模型类型* 和 *期望的返回类型*。
- en: A handler is implemented like any other class and can have dependencies injected
    in as needed.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器的实现方式与其他类相同，并且可以根据需要注入依赖项。
- en: After completing our operations, we must return a value with a data type that
    matches the one outlined by `IRequest<>` from the command model.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成我们的操作后，我们必须返回一个与命令模型中 `IRequest<>` 概述的数据类型相匹配的值。
- en: '`IRequestHandler` implements a method called `Handle` that defaults to the
    outlined return type of `IRequest<>` attached to the command model. It will automatically
    generate a parameter called `request`, which will be of the command model’s data
    type.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IRequestHandler` 实现了一个名为 `Handle` 的方法，该方法默认为附加到命令模型的 `IRequest<>` 的概述返回类型。它将自动生成一个名为
    `request` 的参数，该参数的数据类型为命令模型的数据类型。'
- en: If we did not require a return value, we would have to return `Unit.Value`.
    This is the default `void` representation of `MediatR`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不要求返回值，我们就必须返回 `Unit.Value`。这是 `MediatR` 的默认 `void` 表示形式。
- en: Now that we have some boilerplate code for implementing a command model and
    its corresponding handler, let us look at making an actual call to the handler
    from a controller.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为实现命令模型及其相应处理器编写了一些样板代码，让我们看看如何从控制器中实际调用处理器。
- en: Invoking a command
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用一个命令
- en: 'We have our controller defined for appointment booking operations and it needs
    to have the dependency for our `IMediator` service present to begin orchestrating
    our calls. We need to inject our dependency like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了用于预约操作的控制器，并且它需要具有我们的 `IMediator` 服务的依赖项以开始编排我们的调用。我们需要像这样注入我们的依赖项：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once we have this dependency present, we can begin making our calls. What makes
    this solution so clean is that we do not need to worry about the business logic
    and specific handlers for anything. We need to only create a command-model object
    with the appropriate data and then send it using our mediator, which will then
    call the appropriate handler. The code for our `POST` method is shown here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个依赖项，我们就可以开始进行调用。这个解决方案之所以如此干净，是因为我们不需要担心任何业务逻辑和特定处理器的具体实现。我们只需要创建一个具有适当数据的命令模型对象，然后使用我们的中介发送它，它将调用适当的处理器。我们的
    `POST` 方法的代码如下所示：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are several ways to implement this section. Some alternatives include
    the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一部分有几种方法。一些替代方案包括以下内容：
- en: 'Using *models* or **Data Transfer Objects** (or **DTOs** for short) to accept
    data from the API endpoint. This means that we will then transfer the data points
    from the incoming model object to our command model before sending, as illustrated
    here:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *模型* 或 **数据传输对象**（或简称为 **DTO**）来接受来自 API 端点的数据。这意味着我们将在发送之前将数据点从传入的模型对象传输到我们的命令模型，如下所示：
- en: '[PRE4]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Instead of defining all the data properties in the command model, we use the
    DTO as a property of the command model so that we can pass it along with the mediator
    request, as follows:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不是在命令模型中定义所有数据属性，而是使用 DTO 作为命令模型的一个属性，这样我们就可以将它与中介请求一起传递，如下所示：
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can observe that each method of authoring the code amounts to the same thing,
    and that is we need to compose the appropriate model type with the appropriate
    values before sending it off to our mediator. The mediator would have already
    figured out which model matches which handler and will proceed to carry out its
    operation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以观察到编写代码的每种方法都归结为同一件事，那就是在我们将模型发送到我们的中介之前，我们需要将适当的模型类型与适当的值组合起来。中介已经确定了哪个模型与哪个处理程序相匹配，并将继续执行其操作。
- en: Commands and queries generally follow the same implementation. In the next section,
    we will look at implementing a query model/handler pair using our mediator and
    CQRS patterns.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 命令和查询通常遵循相同的实现。在下一节中，我们将探讨使用中介和CQRS模式实现查询模型/处理程序对。
- en: Implementing a query
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现查询
- en: A query is expected to search for data and return a result. This search might
    be complicated, or it might be simple enough. The fact, though, is that we implement
    this pattern as an easy way to segregate the query logic from the originator of
    the request (such as the controller) and from the command logic. This type of
    separation increases a team’s ability to maintain either side of the application
    without stepping on each other’s toes, so to speak. We will similarly use the
    Mediator pattern to govern how we carry out these operations, and we will need
    a query model and a handler.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 查询预计将搜索数据并返回结果。这种搜索可能很复杂，也可能足够简单。然而，事实是我们将这种模式实现为一个简单的方法，将查询逻辑与请求的发起者（如控制器）和命令逻辑分开。这种分离增加了团队维护应用程序任一方面的能力，而不会相互干扰，换句话说。我们将类似地使用中介模式来管理我们执行这些操作的方式，并且我们需要一个查询模型和一个处理程序。
- en: Creating a query model
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建查询模型
- en: Our model is simple enough as we can leave it empty or include properties that
    will play a part in the process to be carried out in the handler. We inherit `IRequest<>`,
    which defines a return type. I would go out on a limb and say that a return type
    is necessary, considering that this is a query.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式足够简单，我们可以让它为空，或者包含在处理程序中将要执行的过程中的属性。我们继承了`IRequest<>`，它定义了返回类型。我敢说，考虑到这是一个查询，返回类型是必要的。
- en: 'Let us look at two examples of queries, one that will retrieve all the appointments
    in the database and another that will retrieve only by ID. We can define `GetAppointmentsQuery.cs`
    and `GetAppointmentByIdQuery.cs` like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个查询的例子，一个将检索数据库中的所有预约，另一个将仅通过ID检索。我们可以像这样定义`GetAppointmentsQuery.cs`和`GetAppointmentByIdQuery.cs`：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Just take note of the fact that either query model is specific to what it needs
    to represent. The `GetAppointmentsQuery` model doesn’t need any properties since
    it is just going to be used as an outline for the handler to make an association.
    `GetAppointmentByIdQuery` has an `Id` property for the obvious reason that the
    ID is going to be needed for the handler to correctly execute the task at hand.
    The difference in return types is also a crucial point to note as that sets the
    tone for what the handler will be able to return.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 只要注意到，任何查询模型都是特定于它需要表示的内容。`GetAppointmentsQuery`模型不需要任何属性，因为它只是将被用作处理程序创建关联的轮廓。`GetAppointmentByIdQuery`有一个`Id`属性，这是显而易见的原因，因为ID将需要处理程序正确执行当前任务。返回类型的差异也是一个需要注意的关键点，因为它为处理程序可以返回的内容定下了基调。
- en: We need to ensure that we craft our query models specifically for the type of
    data that we are expecting to retrieve from the matching handler. Now, let us
    look at implementing these handlers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保我们为预期的数据类型专门构建我们的查询模型，以便从匹配的处理程序中检索数据。现在，让我们看看如何实现这些处理程序。
- en: Creating a query handler
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建查询处理程序
- en: Our query handlers will execute the expected queries and return the data as
    defined by `IRequest<>`. As previously outlined, the ideal usage of this pattern
    will see us using a separate data store where the data being queried is already
    optimized for return. This would make our query operation efficient and reduce
    the need for data transformation and sanitization.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的查询处理程序将执行预期的查询，并按照`IRequest<>`定义的方式返回数据。如前所述，理想的使用方式将看到我们使用一个单独的数据存储，其中被查询的数据已经针对返回进行了优化。这将使我们的查询操作高效，并减少数据转换和清理的需求。
- en: 'In our example, we are not that fortunate to have a separate data store, so
    we will use the same repository to query the transactional data store. Our handler
    for our query to get all appointments will be called `GetAppointmentsHandler.cs`
    and can be implemented like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们并不那么幸运地拥有一个独立的数据存储，所以我们将会使用同一个仓库来查询事务数据存储。我们用于获取所有预约的查询处理器将被命名为 `GetAppointmentsHandler.cs`，并且可以像这样实现：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This handler’s definition is simple as we simply retrieve a list of appointments.
    When we need to get an appointment by ID, it would imply that we need the details
    of the appointment. This will call for a more complex query that might involve
    joins or, better yet, require synchronous API calls to get the details of related
    records. This is where the database design’s strong points or flaws will come
    into play. If we were guided by our `AppointmentDetailsDto` for return, like so:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理器的定义很简单，因为我们只是检索一个预约列表。当我们需要通过 ID 获取一个预约时，这意味着我们需要预约的详细信息。这将需要一个更复杂的查询，可能涉及连接，或者更好的是，需要同步
    API 调用来获取相关记录的详细信息。这正是数据库设计的优点或缺点会发挥作用的地方。如果我们按照我们的 `AppointmentDetailsDto` 返回，如下所示：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After we have gathered the data needed for this particular scenario, we construct
    our `return` object and send it back to the original sender.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们收集了特定场景所需的数据之后，我们构建我们的 `return` 对象并将其发送回原始发送者。
- en: Now, let us look at what the controller actions look like as they seek to complete
    the queries.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看控制器操作看起来像什么，它们试图完成查询。
- en: Invoking a query
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用一个查询
- en: 'Using the same controller, we can assume that the `IMediator` dependency has
    already been injected and execute the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的控制器，我们可以假设 `IMediator` 依赖项已经被注入，并执行以下代码：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our actions look similar. Each one is defined with the parameters it needs from
    a request. They then call the `mediator` object and new objects of the expected
    query model type. The mediator will orchestrate the call and route the request
    to the appropriate handler.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的操作看起来很相似。每个操作都定义了它从请求中需要的参数。然后它们调用 `mediator` 对象和期望的查询模型类型的新对象。中介者将协调调用并将请求路由到适当的处理器。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: There are several benefits that can be reaped from this approach to development.
    We have already outlined that project bloat is a part of the territory, but the
    level of consistency and structure that can be enforced and guaranteed is perhaps
    worth the additional effort.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从这种开发方法中可以获益的几个好处。我们已经概述了项目膨胀是其中的一部分，但可以强制执行和保证的一致性和结构水平可能值得额外的努力。
- en: In this chapter, we explored the CQRS pattern and how we can employ it in our
    microservice application. We took time to assess the problems that we need to
    address, to bring real context to why we added this new level of complexity. We
    then looked at how we restructure our code to facilitate our handlers and request/command
    objects. We also looked at some design decisions that we can make in terms of
    our data stores for reading and writing operations.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 CQRS 模式以及我们如何在微服务应用程序中应用它。我们花时间评估我们需要解决的问题，为为什么我们添加这一新的复杂层次提供实际背景。然后我们查看我们如何重构我们的代码以方便我们的处理器和请求/命令对象。我们还查看了一些关于我们的数据存储的读写操作我们可以做出的设计决策。
- en: In our next chapter, we will explore Event Sourcing patterns that will tie into
    our CQRS pattern and help us to keep our data relevant throughout our application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨与我们的 CQRS 模式相结合的事件源模式，这将帮助我们保持整个应用程序中的数据相关性。
