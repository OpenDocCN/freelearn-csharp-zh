- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command-Line Parsing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created a console application and learned how to
    pass parameters to it, converting these parameters to their expected data type
    when needed (remember that parameters passed to a console application are of the
    `String` type).
  prefs: []
  type: TYPE_NORMAL
- en: However, even though a console application is at the heart of a CLI application,
    a CLI application is more than just a console application. A CLI application contains
    named parameters, switches, and subcommands to achieve the intended goal.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with our knowledge of creating console applications, we‚Äôll build on top
    of that to learn how to create a CLI application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, in this chapter, we‚Äôll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the console application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing the arguments of a console application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From console to CLI: parsing the arguments using an existing library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will learn how to start with a simple console
    application and convert it to a powerful CLI application that handles commands,
    subcommands, and options.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Bookmarkr
  prefs: []
  type: TYPE_NORMAL
- en: '**Bookmarkr** is the name of the CLI application we will be building throughout
    this book.'
  prefs: []
  type: TYPE_NORMAL
- en: It is a command-line application for managing bookmarks.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the pages of this book, we will bring *Bookmarkr* to life and add
    more and more features to it.
  prefs: []
  type: TYPE_NORMAL
- en: '*Why a* *bookmark manager?*'
  prefs: []
  type: TYPE_NORMAL
- en: Because everyone has used one, so they are familiar with how such a tool works
    and what functionalities it provides.
  prefs: []
  type: TYPE_NORMAL
- en: By removing the burden of understanding the business context of *what* we are
    building, we can then focus all of our attention on *how* we are building it.
    And that is precisely why I chose this application. Plus, it could still be super
    useful üòâ.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter04](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the console application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let‚Äôs start by creating the console application. For this, in Visual Studio
    Code, display the **Terminal** window by going to **View**|**Terminal**.
  prefs: []
  type: TYPE_NORMAL
- en: Then, position yourself where you want the code folder to be created (I mentioned
    in the previous chapter that I always create a `C:\Code` folder that will contain
    all of my code projects).
  prefs: []
  type: TYPE_NORMAL
- en: 'From there, type the following command to create the console application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The .NET project currently looks like this when loaded in Visual Studio Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 ‚Äì The bookmarkr project opened in Visual Studio Code](img/B22400_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 ‚Äì The bookmarkr project opened in Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs add some code to the `Program.cs` file.
  prefs: []
  type: TYPE_NORMAL
- en: The first feature we will implement is the ability to add a new bookmark to
    the list of bookmarks.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we need to create a `BookmarkService` class that will contain all
    the logic for the bookmarking operations. By following the best practices of development,
    we will create that class in its own code file, named `BookmarkService.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will need to add a list of `Bookmark` objects to that `BookmarkService`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to define the `Bookmark` class. Here, again, we will follow
    the best practices of development, and we will create that class in its own code
    file, smartly named `Bookmark.cs` üòä. This class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since the two properties of the `Bookmark` object cannot be `null`, we declare
    them with the `required` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated .NET project now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 ‚Äì The updated bookmarkr project opened in Visual Studio Code](img/B22400_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 ‚Äì The updated bookmarkr project opened in Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all the pieces in place, let‚Äôs see how we can process user
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the arguments of a console application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A request to a CLI application usually contains the name of the command (and
    an optional subcommand) along with arguments that provide values to the parameters
    needed by the command.
  prefs: []
  type: TYPE_NORMAL
- en: The first command we will be adding is the ability to add a new bookmark to
    the list of bookmarks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the expected command is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So, let‚Äôs modify the code to handle such a command!
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the `Main` method of the `Program` class (located in the
    `Program.cs` file). Why? Because this is the method that receives the input parameters
    from the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we may have multiple commands in the future, we will add a `switch` statement
    to handle each one of these. Hence, the code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let‚Äôs explain this code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Main` method dispatches the processing of each command to a specific method
    within the `Program` class. Since, for now, we only have one command (`link`),
    we have only one processing method (`ManageLinks`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ManageLinks` method handles the subcommands related to links. For now,
    we only have one subcommand (`add`) but we can easily imagine having more subcommands,
    such as `update` (to update the URL of an existing link), `remove` (to remove
    an existing link), and `list` (to list all existing links).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `ShowErrorMessage` method is a utility method used to display error
    messages in red-colored text. Its code can be found in the `Helper` class and
    is omitted here because it does not provide value to the topic we are discussing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you write (or copy) this code, you‚Äôll notice that it does not compile. This
    is due to the `AddLink` method not yet being available in the `BookmarkService`
    class. Let‚Äôs add it!
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of the `AddLink` method is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is pretty simple and straightforward, but let‚Äôs explain it briefly:'
  prefs: []
  type: TYPE_NORMAL
- en: We first ensure that both the `name` and `url` parameters are provided. If not,
    we return an error message to the user with the expected syntax for the command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We ensure that the link to be added is not already present in the list of bookmarks.
    If it is present, we inform the user with a warning message and invite them to
    use the `update` subcommand if they intend to update an existing link.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the link does not already exist, we add it to the list of bookmarks and inform
    the user with a success message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pretty easy, isn‚Äôt it? üòä
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a problem with this approach to building CLI applications.
    Can you guess what it is?
  prefs: []
  type: TYPE_NORMAL
- en: It is based on positional parameters. In other words, we expect the first parameter
    to be the name of the command, the second parameter to be the name of the subcommand,
    the third parameter to be the value of the `name` parameter, and the fourth parameter
    to be the value of the `url` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there are a couple of issues:'
  prefs: []
  type: TYPE_NORMAL
- en: How could the user be aware of that order?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if the user provided the `url` value as the third parameter and the `name`
    value as the fourth parameter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you‚Äôre familiar with using CLI applications, you will know that the usual
    syntax for a CLI command looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This helps the user to know what is expected as parameters and to provide the
    parameters in the appropriate manner.
  prefs: []
  type: TYPE_NORMAL
- en: We can, of course, rely on the `args` list of parameters and compare each one
    to what is expected (for example, checking whether the third parameter‚Äôs value
    is `--name` or `-n` so we know that the fourth parameter represents the value
    of the name of the link, and so on), but this will complexify our code too much.
  prefs: []
  type: TYPE_NORMAL
- en: I know what you‚Äôre thinking. You‚Äôre smart and you‚Äôve already figured out that
    the best approach to solve this problem is to develop a library to parse these
    parameters and figure out what they represent.
  prefs: []
  type: TYPE_NORMAL
- en: But, because I know you‚Äôre smart, I know that you‚Äôve already searched for an
    existing library that does just that. After all, you do not want to reinvent the
    wheel, do you?
  prefs: []
  type: TYPE_NORMAL
- en: From console to CLI ‚Äì parsing the arguments using an existing library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although many libraries exist for the different programming languages, including
    .NET, we will focus on `System.CommandLine` throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we chose this library, especially if you are familiar
    with (or have heard about) `CommandLineParser`, which is another common library
    for that matter.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple reasons for that. In essence, `System.CommandLine` is a more
    modern, feature-rich, and performant library, whereas `CommandLineParser` is a
    simpler and more lightweight alternative.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, there are a few other reasons why I prefer `System.CommandLine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.CommandLine` is a .NET Foundation project developed by Microsoft and
    the community, while `CommandLineParser` is a third-party library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.CommandLine` uses a builder pattern and a more declarative approach
    to define commands and options, while `CommandLineParser` uses attributes and
    a more imperative approach'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.CommandLine` provides more advanced features out of the box, such as
    command hierarchies, response files, auto-completion, and parsing directives,
    whereas `CommandLineParser` is more lightweight and focused on basic command-line
    parsing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.CommandLine` is known to be faster and more efficient, especially for
    large command-line structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though both libraries are cross-platform, `System.CommandLine` has better
    support for platform-specific conventions, such as case-insensitivity on Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let‚Äôs rewrite our application to benefit from the `System.CommandLine`
    library!
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note #1'
  prefs: []
  type: TYPE_NORMAL
- en: The previous code of the `Program.cs` file has been moved into a `Program.Console.txt`
    file for further reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note #2'
  prefs: []
  type: TYPE_NORMAL
- en: While you can execute the application by its executable name (located in `bin\Debug\net8.0\bookmarkr.exe`),
    it‚Äôs more convenient, during the development phase, to use the `dotnet` `run`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: I prefer to rely on the executable name because it matches how we will use the
    application in production. If you prefer to use the `dotnet run` command, simply
    replace `bookmarkr` with `dotnet run` in the following execution syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to add the `System.CommandLine` NuGet package
    library to our project. To do this, open the Visual Studio Code terminal and type
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: At the time of the writing of this chapter, this library is still in Beta. When
    it makes it to `--prerelease` switch anymore.
  prefs: []
  type: TYPE_NORMAL
- en: The way `System.CommandLine` works is to have a `RootCommand` object that will
    act as the root command for all other commands of the CLI application. This means
    that every command in the application has, as a parent, either the `root` command
    or another command whose parent is ultimately the root command.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the root command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The root command is the one that gets called when the user invokes the CLI application
    with no parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The root command is an instance of the `RootCommand` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A command has a handler, which is a method that is called as the result of
    the user invoking that command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SetHandler` method takes a delegate to the actual method that does the
    job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, and since the `System.CommandLine` library follows the `Builder` pattern,
    we need to build and invoke a parser to kick things in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, let‚Äôs add the required `using` statements at the top of
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to execute our application! Type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When executed, the application will invoke the appropriate command (here, the
    root command since no argument was passed to the executing application), which,
    in turn, will invoke its handler method (`OnHandleRootCommand`), and the result
    of its execution will be returned to the user. In this example, the command will
    display the message `"Hello from the` `root command!"`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 ‚Äì Invoking the root command](img/B22400_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 ‚Äì Invoking the root command
  prefs: []
  type: TYPE_NORMAL
- en: Isn‚Äôt that exciting? No? You‚Äôre right‚Ä¶ This is not (yet) looking like a CLI
    application. Let‚Äôs add another command!
  prefs: []
  type: TYPE_NORMAL
- en: Adding the link command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax for adding bookmarks using our CLI application is supposed to be
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we need to create a `link` command. This command will have the root command
    as a parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need an `add` command, whose parent will be the `link` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let‚Äôs execute this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Pretty close, huh?
  prefs: []
  type: TYPE_NORMAL
- en: The only elements that are missing are the `<name>` and `<url>` parts. These
    are called **options**, and we will look into them in a moment. But first, let‚Äôs
    focus on commands.
  prefs: []
  type: TYPE_NORMAL
- en: About commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Commands are like a tree where the root command is‚Ä¶ well, the root of that tree.
  prefs: []
  type: TYPE_NORMAL
- en: Each command has a parent, which is either another command (for example, `add`
    has `link` as a parent), or the root command itself (as for the `link` command).
  prefs: []
  type: TYPE_NORMAL
- en: 'The command tree dictates the syntax of the CLI application. For example, we
    cannot perform the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is because no `add` command has the root command as a parent.
  prefs: []
  type: TYPE_NORMAL
- en: Do all commands need to have a handler method?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The answer is, no, they don‚Äôt. Only commands that actually do some processing
    need to have a handler method. In our case, neither the root command nor the `link`
    command require a handler.
  prefs: []
  type: TYPE_NORMAL
- en: Adding options to the link command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since the `add` command requires two parameters (`name` and `url`), we will
    add two options to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, an `Option` is defined by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The data type of its value (here, a string)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its aliases (for `urlOption`, these are `--url` and `-u`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its description, which will be useful when requesting the help menu for that
    command (for `urlOption`, it is `"The URL of` `the bookmark"`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we need to assign these options to the command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to pass these options to the `Handler` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And, finally, we use the values of these options in the `Handler` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we execute the application, we get the expected result. This time,
    we saved about half of the code by not having to parse the arguments of the console
    application and delegating this to the `System.CommandLine` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 ‚Äì We successfully added a bookmark](img/B22400_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 ‚Äì We successfully added a bookmark
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, using the aliases, we can execute the CLI application using this
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The result will be the same as the one shown in *Figure 4**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: What other types of options can we use?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`System.CommandLine` doesn‚Äôt only support `string` options. `Option<T>` is
    a generic type, so you can create an `Option<T>` for any data type. This, for
    example, could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DateTime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Uri`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimeSpan`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Regex`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Enum`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IPAddress`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileInfo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It could even be your own custom class if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the data type we use, the provided value for the option will be
    parsed into that data type. If parsing fails, an exception will be raised, and
    an error message will be displayed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an illustrative example. The root command has been updated to accept
    an integer option. When the program is executed and a value that cannot be parsed
    into an integer is provided for that option, we get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Hmm‚Ä¶ Although the name of the option indicates that it is expecting a number,
    it is not clear what that number is all about. What is its purpose? Is there a
    range of valid values for that number? A little help would be‚Ä¶ well, helpful here
    üòä.
  prefs: []
  type: TYPE_NORMAL
- en: Getting help
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The good news is that when using `System.CommandLine`, we get the help menu
    automatically built for us. All we need to do is to provide meaningful names and
    descriptions to our commands and options and the library will do the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get help by using either one of these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--``help`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-?`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 ‚Äì Help!](img/B22400_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 ‚Äì Help!
  prefs: []
  type: TYPE_NORMAL
- en: 'This also works for subcommands. For example, if we want to get help regarding
    the `link` command, we can type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 ‚Äì Getting help for the link command](img/B22400_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 ‚Äì Getting help for the link command
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this for one subcommand at a time, such as the `link add` command,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 ‚Äì Getting help for the link add command](img/B22400_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 ‚Äì Getting help for the link add command
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You have probably noticed that the `dotnet run` syntax for getting help requires
    an extra `--`. This is not a typo. It is required because, otherwise, the .NET
    CLI tool will *think* that you are requesting help with the `dotnet` tool.
  prefs: []
  type: TYPE_NORMAL
- en: The extra `--` is used to separate the arguments that are passed to `dotnet
    run` from the arguments that are passed to the application being run. Everything
    after `--` is considered an argument to the application, not to `dotnet run`.
  prefs: []
  type: TYPE_NORMAL
- en: However, one thing we should keep in mind is that the usage of a CLI application
    (and hence, its help) depends on the current version of the application. But how
    do we get that information?
  prefs: []
  type: TYPE_NORMAL
- en: Getting the application‚Äôs version number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a built-in option (`--version`) that displays the version number of
    the CLI application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display it, execute the command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: But where does this value come from?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, it can be found in the `.csproj` file, within the `<PropertyGroup>` element
    at the beginning of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that if no `<version>` element is provided, the default value to be returned
    will be `1.0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, too, if you want to use the `dotnet run` syntax to query the version
    number of the application, you‚Äôll need to use the extra `--`, as follows: `dotnet
    run -- --``version`.'
  prefs: []
  type: TYPE_NORMAL
- en: And that‚Äôs it! You‚Äôre now all set and ready to create your first CLI application!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started to build our very own CLI application, *Bookmarkr*,
    which is a bookmark manager provided as a CLI application, so it can be used within
    a Terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: We started with a console application (because remember, ‚ÄúAt the core of every
    CLI application is a console application‚Äù), and then we introduced a library for
    parsing its command-line arguments including commands, subcommands, and options
    so we don‚Äôt need to reinvent the wheel.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we will see how to control inputs and outputs and how
    to read data from and write data to a file so we can perform backup and restore
    operations for our bookmarks. This will prove especially useful to import and
    export bookmarks into and out of our bookmark manager application
  prefs: []
  type: TYPE_NORMAL
- en: Your turn!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following along with the provided code is a great way to learn through practice.
  prefs: []
  type: TYPE_NORMAL
- en: A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to improve the *Bookmarkr* application by adding the following features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Task #1 ‚Äì Delete an existing bookmark'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If the requested link name does not exist, the application should display a
    warning message to the user. Otherwise, the application should delete that bookmark
    and display a success message to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Task #2 ‚Äì Update an existing bookmark'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If the requested link name does not exist, the application should display an
    error message to the user and invite them to use the `add` command to add a new
    bookmark. Otherwise, the application should update the existing bookmark with
    the newly provided URL and display a success message to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Task #3 ‚Äì List all existing bookmarks'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If the list of bookmarks contains no items, the application should display
    a warning message saying that the list of bookmarks is empty and, therefore, there
    is nothing to display. Otherwise, the application should present the list of bookmarks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
