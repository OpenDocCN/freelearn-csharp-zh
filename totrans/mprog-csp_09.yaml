- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Taking Advantage of the Dynamic Language Runtime
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用动态语言运行时的优势
- en: C# is a statically typed language, which means we take our code in text form
    and run it through a compiler, and it produces a binary that is then executed
    later. The code does not change after the compiler is done. Not all languages
    are like this; languages such as Ruby, Python, and JavaScript are dynamic languages
    and do not compile to binary before execution. They are interpreted at runtime,
    meaning that they can also change gradually during runtime. This is a very powerful
    trait.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C# 是一种静态类型语言，这意味着我们将代码以文本形式提交给编译器，然后它生成一个二进制文件，稍后执行。编译器完成后，代码不会改变。并非所有语言都像这样；像Ruby、Python和JavaScript这样的语言是动态语言，在执行之前不会编译成二进制。它们在运行时被解释，这意味着它们也可以在运行时逐渐改变。这是一个非常强大的特性。
- en: In this chapter, we will look into how we can make use of the dynamic language
    runtime part of the .NET runtime and create code dynamically and differently from
    how we’ve done it thus far.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何利用.NET运行时的动态语言运行时部分，以与我们迄今为止所做的方式不同地动态创建代码。
- en: 'We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Understanding the DLR
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 DLR
- en: Reasoning about a dynamic type
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对动态类型进行推理
- en: Creating a DynamicObject and providing metadata
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 DynamicObject 并提供元数据
- en: By the end of the chapter, you will understand what the dynamic language runtime
    is and how you can make use of it to dynamically create types and reason about
    them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解动态语言运行时是什么，以及你如何利用它动态创建类型并对它们进行推理。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter9](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter9)),
    and it builds on top of the **Fundamentals** code that is found here: [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的特定源代码可以在 GitHub 上找到 ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter9](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter9))，并且它建立在以下位置找到的**基础知识**代码之上：[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)。
- en: Understanding the DLR
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 DLR
- en: The **Dynamic Language Runtime** (**DLR**) was introduced in .NET 4 back in
    2010\. It runs on top of the .NET runtime, **Common Language Runtime** (**CLR**),
    providing language services for dynamic languages such as Python and Ruby through
    the IronPython and IronRuby implementations. With the DLR, it is also possible
    to interop between the different languages, effectively making it possible to
    have C# and Python, Ruby, or any other dynamic language that is supported run
    side by side in the same process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态语言运行时**（**DLR**）于2010年随.NET 4一起引入。它运行在.NET运行时之上，即**公共语言运行时**（**CLR**），通过IronPython和IronRuby实现为Python和Ruby等动态语言提供语言服务。有了DLR，还可以在不同语言之间进行互操作，从而有效地使C#和Python、Ruby或任何其他受支持的动态语言能够在同一进程中并行运行。'
- en: The CLR at a glance
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一瞥 CLR
- en: Before diving into the DLR, it’s helpful to understand the constraints it has
    to work with. The CLR is at the heart of everything .NET, which means that everything
    running has to abide by the rules of the CLR. That becomes very interesting when
    looking at the traits of the CLR.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究DLR之前，了解它必须与之合作的约束条件是有帮助的。CLR是.NET的一切核心，这意味着所有运行的内容都必须遵守CLR的规则。当查看CLR的特性时，这一点变得非常有趣。
- en: Just-in-Time (JIT) compilation
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 即时编译（JIT）
- en: The CLR compiles the **Intermediate Language** (**IL**) code into native code
    for the specific machine and operating system at runtime, using the JIT compiler.
    This process enables better optimization, faster execution, and cross-platform
    compatibility.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 使用JIT编译器在运行时将**中间语言**（**IL**）代码编译为特定机器和操作系统的本地代码。此过程使优化更好、执行更快，并实现跨平台兼容性。
- en: Automatic memory management
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动内存管理
- en: The CLR manages memory allocation and deallocation using garbage collection,
    which automatically frees up memory occupied by objects that are no longer in
    use. This helps prevent memory leaks and optimizes memory usage.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 使用垃圾回收来管理内存分配和释放，自动释放不再使用的对象占用的内存。这有助于防止内存泄漏并优化内存使用。
- en: Type safety
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型安全
- en: The CLR ensures type safety by enforcing strict rules during code execution.
    This helps prevent invalid memory operations, such as accessing a memory location
    that has not been initialized or using an object of one type as another type.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 通过在代码执行期间强制执行严格规则来确保类型安全。这有助于防止无效的内存操作，例如访问尚未初始化的内存位置或使用一种类型的对象作为另一种类型。
- en: Exception handling
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常处理
- en: The CLR provides a consistent and robust exception-handling mechanism across
    all .NET languages, allowing developers to handle runtime errors gracefully and
    maintain application stability.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 为所有 .NET 语言提供了一致且健壮的异常处理机制，允许开发者优雅地处理运行时错误并保持应用程序的稳定性。
- en: Cross-language Interoperability
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨语言互操作性
- en: The CLR supports interoperability between .NET languages, allowing developers
    to use components written in different languages within the same application.
    This promotes code reusability and simplifies the development process.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 支持不同 .NET 语言之间的互操作性，允许开发者在同一应用程序中使用用不同语言编写的组件。这促进了代码重用并简化了开发过程。
- en: Versioning and assembly management
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本控制和程序集管理
- en: The CLR manages the versioning of assemblies (compiled code units), helping
    to prevent issues such as “DLL hell,” where conflicting versions of shared libraries
    cause application instability. It also provides features such as side-by-side
    execution, allowing multiple versions of an assembly to coexist on the same system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 管理程序集（编译代码单元）的版本控制，有助于防止诸如“DLL 地狱”等问题，即共享库的冲突版本导致应用程序不稳定。它还提供了诸如并行执行等特性，允许同一系统上共存多个版本的程序集。
- en: Reflection
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反射
- en: The CLR enables developers to inspect and interact with metadata about types,
    objects, and assemblies at runtime. This allows dynamic type creation, method
    invocation, and other advanced programming techniques.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 允许开发者在运行时检查和交互类型、对象和程序集的元数据。这允许动态类型创建、方法调用和其他高级编程技术。
- en: Debugging and profiling
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试和性能分析
- en: The CLR provides integrated support for debugging and profiling .NET applications,
    enabling developers to diagnose and optimize code efficiently.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 为 .NET 应用程序提供了集成的调试和性能分析支持，使开发者能够有效地诊断和优化代码。
- en: The DLR building blocks
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DLR 的构建块
- en: For any of the dynamic languages to work, the DLR needs to support a few things
    that are very different from the more static world of the CLR. The following traits
    are needed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何动态语言来说，DLR 需要支持一些与 CLR 更为静态的世界非常不同的特性。以下是需要的一些特性。
- en: Dynamic type system
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态类型系统
- en: A dynamic runtime needs to be able to create types on the fly. A type is never
    static and should be able to be expanded on.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个动态运行时需要能够即时创建类型。类型永远不会是静态的，应该能够进行扩展。
- en: Dynamic dispatching of methods
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态方法分发
- en: A dynamic runtime should allow calling methods that aren’t known beforehand.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个动态运行时应该允许调用事先未知的函数。
- en: Dynamic code generation
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态代码生成
- en: A dynamic runtime should allow for code generation at runtime, allowing you
    to add code based on input or the result of other code dynamically. It should
    also allow you to modify code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个动态运行时应该允许在运行时进行代码生成，允许你根据输入或其他代码的结果动态地添加代码。它还应该允许你修改代码。
- en: From a CLR perspective, these types of traits seem very unaligned. The engineers
    at Microsoft extended the core functionality and put in place a dynamic runtime
    that works well with the CLR.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从 CLR 的角度来看，这些类型的特性似乎非常不一致。微软的工程师扩展了核心功能，并实施了一个与 CLR 协作良好的动态运行时。
- en: From a metaprogramming perspective, the traits of a dynamic runtime are perfect.
    As part of the DLR, there is a collection of constructs and APIs that enables
    you to dynamically create types and also reason about any dynamic type that fulfills
    the traits we’re looking for.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从元编程的角度来看，动态运行时的特性是完美的。作为 DLR 的一部分，有一系列构造和 API 可以让你动态创建类型，并对任何满足我们所需特性的动态类型进行推理。
- en: Since the .NET runtime itself is a static runtime and relies on well-known types
    with fixed members, the DLR needs to work with this constraint. The DLR, therefore,
    provides a set of classes and interfaces to represent dynamic objects, their properties,
    and operations, such as **IDynamicMetaObjectProvider**, **DynamicMetaObject**,
    **DynamicObject**, and **ExpandoObject**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 .NET 运行时本身是一个静态运行时，依赖于具有固定成员的已知类型，DLR 需要与此约束一起工作。因此，DLR 提供了一系列类和接口来表示动态对象、它们的属性和操作，例如
    **IDynamicMetaObjectProvider**、**DynamicMetaObject**、**DynamicObject** 和 **ExpandoObject**。
- en: For the DLR to work with dynamic languages, it needs a way to represent the
    language semantics. The DLR uses expression trees, which we looked at in more
    detail in [*Chapter 7*](B19418_07.xhtml#_idTextAnchor118), *Reasoning about Expressions*,
    and [*Chapter 8*](B19418_08.xhtml#_idTextAnchor132), *Building and Executing Expressions*.
    With the DLR comes a set of extensions to LINQ expressions that give us control
    flow, assignment, and other language-modeling nodes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 DLR 能够与动态语言一起工作，它需要一种表示语言语义的方法。DLR 使用表达式树，我们在 [*第 7 章*](B19418_07.xhtml#_idTextAnchor118)，*推理表达式*
    和 [*第 8 章*](B19418_08.xhtml#_idTextAnchor132)，*构建和执行表达式* 中更详细地讨论了这一点。随着 DLR 的到来，LINQ
    表达式集增加了一系列扩展，为我们提供了控制流、赋值和其他语言建模节点。
- en: From a compiler perspective, the C# compiler has a keyword called **dynamic**
    that lets you say that a particular variable or argument is of a dynamic type.
    That tells the compiler to not evaluate any member accesses during compile time
    for the instance. Instead, it translates all this into the appropriate **Expression**
    that will execute.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从编译器的角度来看，C# 编译器有一个名为 **dynamic** 的关键字，允许你指定一个特定的变量或参数是动态类型。这告诉编译器在编译时不要评估实例的任何成员访问。相反，它将所有这些转换成将在执行时运行的适当
    **Expression**。
- en: 'To get started with leveraging the DLR and its dynamic capabilities, the easiest
    way is to use the **ExpandoObject** type. **ExpandoObject** provides a type that
    can be dynamically expanded on; it will hold anything you tell it to and can expand
    as you proceed:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始利用 DLR 及其动态功能，最简单的方法是使用 **ExpandoObject** 类型。**ExpandoObject** 提供了一种可以动态扩展的类型；它会保留你告诉它的任何内容，并且可以随着你的操作而扩展：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code creates an instance of **ExpandoObject** and then starts setting values
    on it. **ExpandoObject** does not have **FirstName** or **LastName** as part of
    its type, but by setting them, the values will be there.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个 **ExpandoObject** 实例，然后开始设置其上的值。**ExpandoObject** 类型本身不包含 **FirstName**
    或 **LastName** 作为其类型的一部分，但通过设置它们，这些值就会存在。
- en: 'Accessing these members will be the same; the compiler understands that **ExpandoObject**
    is **dynamic** and will try to bind to the members at runtime rather than at compile
    time. The following code will be completely valid:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 访问这些成员的方式将相同；编译器理解 **ExpandoObject** 是 **dynamic** 的，并且将在运行时而不是在编译时尝试绑定到成员。以下代码将完全有效：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result will be as expected:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如预期：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**ExpandoObject** does this by implementing the **IDynamicMetaObjectProvider**
    interface. With **IDynamicMetaObjectProvider**, it provides its own implementation
    of **DynamicMetaObject** that really holds all the magic of doing the actual binding
    of the operations we tell it to do.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**ExpandoObject** 通过实现 **IDynamicMetaObjectProvider** 接口来完成这一点。通过 **IDynamicMetaObjectProvider**，它提供了自己的
    **DynamicMetaObject** 实现，这实际上包含了执行我们告诉它执行的操作的所有魔法。'
- en: 'The **ExpandoObject** type also implements the **IDictionary<string, object?>**
    interface, which is how it represents all the members given to it and also how
    it can dynamically grow. Through its implementation of **DynamicMetaObject**,
    it basically just works on the internal dictionary. In fact, it is fully possible
    to work with **ExpandoObject** as a dictionary if you want:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**ExpandoObject** 类型还实现了 **IDictionary<string, object?>** 接口，这是它表示所有赋予它的成员的方式，也是它能够动态增长的方式。通过其
    **DynamicMetaObject** 的实现，它基本上只是在内部字典上工作。实际上，如果你想的话，完全可以把 **ExpandoObject** 当作字典来使用：'
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you’re using **dynamic** for data objects, this can be really handy, as it
    gives you a simple way to reason about an object and its content and, at the same
    time, a convenient programming experience by treating it as a dynamic object with
    properties.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 **dynamic** 来处理数据对象，这会非常方便，因为它为你提供了一个简单的方式来推理对象及其内容，同时，通过将其视为具有属性的动态对象，提供了一个方便的编程体验。
- en: Call sites and binders
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Call sites 和绑定器
- en: Whenever you want to perform an operation on a dynamic object – for instance,
    a get or set property or a method call – it goes through something called a **call
    site**. A call site is effectively the location at runtime of the code that will
    execute. For compiled C#, this will be the memory location where the IL code typically
    resides. For other languages, such as Ruby or Python, this would be the location
    in the textual code. Every language has its own call site representation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你想要在动态对象上执行操作时——例如，获取或设置属性或调用方法——它将通过一个称为 **call site** 的东西。call site 实际上是将在运行时执行代码的位置。对于编译后的
    C#，这将通常是 IL 代码驻留的内存位置。对于其他语言，如 Ruby 或 Python，这将是在文本代码中的位置。每种语言都有自己的 call site
    表示。
- en: The big difference between static languages and dynamic languages is that the
    static languages are compiled, and at runtime, they’re either executing some sort
    of intermediate language or actual machine language. Alternatively, a dynamic
    language will interpret code at runtime and execute the result. The benefit of
    a dynamic language then is that it can change its own code dynamically, obviously
    with the downside of a loss in performance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 静态语言和动态语言之间的主要区别在于，静态语言是编译的，在运行时，它们要么执行某种中间语言，要么执行实际的机器语言。相比之下，动态语言将在运行时解释代码并执行结果。动态语言的好处是它可以动态地改变自己的代码，显然，这是以性能损失为代价的。
- en: Once you have the location, or the call site, you can bind to the member and
    then perform the operation you want.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了位置，或者调用点，你就可以绑定到成员，然后执行你想要的操作。
- en: There are binders for the typical operations you want to perform on an object
    – the get and set properties, invoke methods, indexing, and so on. Throughout
    the book, we’ve looked at the power of metadata and how we can reason about the
    running code; the DLR poses some challenges with this.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着执行对象典型操作的绑定器 – 获取和设置属性、调用方法、索引等。在整个书中，我们探讨了元数据的力量以及我们如何对运行中的代码进行推理；DLR在这方面提出了一些挑战。
- en: Reasoning about a dynamic type
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推理动态类型
- en: The DLR is very limited in what it is possible to reason about for a dynamic
    type. Primarily, the DLR is built to be able to host dynamic languages. Naturally
    with dynamic languages, you don’t really know what’s going on with a dynamic type,
    and it can change over time, so even though a member is already there, the DLR
    can’t provide you a reflective experience by giving you any details, such as type
    information, about the member.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: DLR在推理动态类型方面非常有限。主要的是，DLR被构建为能够托管动态语言。自然地，与动态语言一样，你实际上并不知道动态类型在发生什么，它可能会随时间改变，因此即使成员已经存在，DLR也无法通过提供任何细节（如类型信息）来提供反射体验。
- en: One thing we can do, however, is ask it what members it has. Every dynamic object
    implements an interface called **IDynamicMetaObjectProvider**. On this, you can
    call the **GetMetaObject()** method to get an object that allows us to interact
    with the dynamic object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以请求它有哪些成员。每个动态对象都实现了一个名为**IDynamicMetaObjectProvider**的接口。在这个接口上，你可以调用**GetMetaObject()**方法来获取一个允许我们与动态对象交互的对象。
- en: 'Let’s look at **ExpandoObject** with the following properties:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看具有以下属性的**ExpandoObject**：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since **ExpandoObject** does, in fact, implement **IDynamicMetaObjectProvider**,
    we can ask it for its meta-object and then its members:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**ExpandoObject**实际上实现了**IDynamicMetaObjectProvider**接口，我们可以请求它的元对象，然后请求它的成员：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running this code will give you the following result:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将给出以下结果：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code itself assumes it is **IDynamicMetaObjectProvider** by casting it to
    a type, in order for us to call **GetMetaObject()**. The **Expression** we create
    represents the instance of the person that we’re getting the meta-object for.
    Then, we call **GetDynamicMemberNames()**, which returns a collection of strings
    with all its member names.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 代码本身通过将其转换为类型来假设它是**IDynamicMetaObjectProvider**，以便我们调用**GetMetaObject()**。我们创建的**Expression**代表我们正在获取元对象的个人实例。然后，我们调用**GetDynamicMemberNames()**，它返回一个包含所有成员名称的字符串集合。
- en: This is the extent of what it is possible to reason about.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是可以推理的范围。
- en: However, we can dynamically invoke the members, which comes in handy when you
    don’t know the shape of the object. It can be a bit challenging to invoke when
    you don’t really know what the object holds, and if you want to support everything,
    you’ll need fallback mechanisms, as the runtime will throw **RuntimeBinderException**
    if it can’t bind the way you want to.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以动态调用成员，这在不知道对象形状时非常有用。当不知道对象包含什么时调用可能会有些挑战，如果你想要支持一切，你需要回退机制，因为如果运行时无法以你想要的方式绑定，它将抛出**RuntimeBinderException**。
- en: '**DynamicMetaObject** has a set of methods with all the binding you can do.
    These *bind* methods require an actual binder, which you can get from the call
    site. After bind, you will get a new **DynamicMetaObject**. It is possible to
    use all of these things to get to the actual value, but let’s jump directly to
    the C# binder, get the binder we want, and use that instead.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**DynamicMetaObject**有一组方法，可以进行所有绑定操作。这些*绑定*方法需要一个实际的绑定器，你可以从调用点获取。绑定后，你将得到一个新的**DynamicMetaObject**。使用所有这些方法来获取实际值是可能的，但让我们直接跳到C#绑定器，获取我们想要的绑定器，并使用它。'
- en: 'In the **Microsoft.CSharp.RuntimeBinder** namespace, there is a class called
    **Binder**. This class holds a set of static methods to get specific binders.
    The types of binders you can use are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Microsoft.CSharp.RuntimeBinder** 命名空间中，有一个名为 **Binder** 的类。这个类包含一组静态方法来获取特定的绑定器。你可以使用的绑定器类型如下：
- en: '| **BinaryOperation** | Used for binary operations |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **二元运算** | 用于二元运算 |'
- en: '| **Convert** | Used to convert to a specific type |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **转换** | 用于转换为特定类型 |'
- en: '| **GetIndex** | Used to get an index |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **获取索引** | 用于获取索引 |'
- en: '| **GetMember** | Used to get a member’s value |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **获取成员** | 用于获取成员的值 |'
- en: '| **Invoke** | Used to invoke a method |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **调用** | 用于调用方法 |'
- en: '| **InvokeConstructor** | Used to invoke/construct a constructor |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **调用构造函数** | 用于调用/构造构造函数 |'
- en: '| **SetIndex** | Used to set an index |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **设置索引** | 用于设置索引 |'
- en: '| **SetMember** | Used to set a member to a value |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **设置成员** | 用于将成员设置为某个值 |'
- en: '| **UnaryOperation** | Used for unary operations |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **一元运算** | 用于一元运算 |'
- en: 'Since the object we have only has properties, we will use the **GetMember**
    binder to get the property value and, ultimately, the actual value through the
    call site:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们拥有的对象只有属性，我们将使用 **GetMember** 绑定器来获取属性值，并通过绑定点最终获取实际值：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code builds on the **meta** instance we got from **GetMetaObject()** and
    iterates through the member names returned by **GetDynamicMemberNames()**. For
    each member, you can then get the binder for it – in our case, the **GetMember**
    binder – passing default values to it with **member** and the **person** type.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 代码基于我们从 **GetMetaObject()** 获取的 **meta** 实例，并通过 **GetDynamicMemberNames()**
    返回的成员名称进行迭代。对于每个成员，你可以获取它的绑定器——在我们的例子中，是 **GetMember** 绑定器——通过传递默认值 **member**
    和 **person** 类型给它。
- en: In the **System.Runtime.CompilerService** namespace, you’ll find a class called
    **CallSite<>**. This is a dynamic site type that can be used to create a call
    site for the binder dynamically. In our case, the dynamic site will be a delegate,
    **Func<>**, that allows us to call it with **person** and get a value back. The
    types going in and out are both **object**, since the actual type is unknown.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **System.Runtime.CompilerService** 命名空间中，你可以找到一个名为 **CallSite<>** 的类。这是一个动态站点类型，可以用来动态创建绑定点的站点。在我们的例子中，动态站点将是一个代表，**Func<>**，它允许我们用
    **person** 来调用它并返回一个值。输入和输出的类型都是 **object**，因为实际类型是未知的。
- en: 'Running this code should give you this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码应该会给你以下结果：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Important note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The code assumes that all members are properties, which can fail with **RuntimeBinder**
    **Exception**. If you need to support more member types, you would need to handle
    that exception and fall back to the ones you want to support.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 代码假设所有成员都是属性，这可能会导致 **RuntimeBinder** **异常**。如果你需要支持更多成员类型，你需要处理这个异常并回退到你想要支持的类型。
- en: Another approach you could use is to use expressions. The **Expression** class
    has a **Dynamic** method that lets you pass in the binder and then create a **Lambda**
    expression, which gives you a similar **Func<>** delegate that can be invoked.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种你可以使用的方法是使用表达式。**Expression** 类有一个 **Dynamic** 方法，它允许你传入绑定器并创建一个 **Lambda**
    表达式，这给你一个类似的 **Func<>** 委托，可以调用。
- en: 'The following gives you a method that can be called to create **Func<>**, which
    we can call to get the values of members:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下提供了一个可以调用的方法来创建 **Func<>**，我们可以调用它来获取成员的值：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code gets the **GetMember** binder and then creates **DynamicExpression**,
    which involves a conversion of the instance we will pass to **object**. Then,
    the code creates a **Lambda** expression, which we then compile for more performant
    execution.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代码获取 **GetMember** 绑定器，然后创建 **DynamicExpression**，这涉及到将我们将要传递的实例转换为 **object**。然后，代码创建一个
    **Lambda** 表达式，我们随后对其进行编译以实现更高效的执行。
- en: 'This new method can then be used in the following way:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新方法可以按以下方式使用：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of this would be as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出的结果如下：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since the DLR itself is limited in discoverability and reasoning about what
    is there, it might be a good idea in some use cases to provide the metadata yourself,
    using other formats and approaches.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 DLR 本身在可发现性和推理方面有限，在某些用例中，自己提供元数据可能是一个好主意，使用其他格式和方法。
- en: Creating DynamicObject and providing metadata
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 DynamicObject 并提供元数据
- en: Sometimes, you don’t have the luxury of having your types represented in code.
    This could be if you’re calling an external API of some sort, be it a REST API,
    SOAP service, or similar. However, the third party you’re calling might have a
    representation of the type in a standard format, such as a WSDL or JSON schema.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能没有在代码中表示类型的奢侈。这可能是因为你正在调用某种外部API，无论是REST API、SOAP服务还是类似的服务。然而，你调用的第三方可能有一个标准格式（如WSDL或JSON模式）中类型的表示。
- en: Even though dynamic objects can be very flexible, in the real world the shape
    of data tends to be stricter. So, instead of using **ExpandoObject** for everything,
    you could represent these types with a custom dynamic object that gets its metadata
    from a well-known format. It’s very common today to use JSON as a data carrier,
    and it’s also common to represent the shape of data by leveraging JSON schemas.
    Let’s look at how that could be a provider of metadata.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管动态对象可以非常灵活，但在现实世界中，数据的形状往往更加严格。因此，你不必为所有内容都使用 **ExpandoObject**，你可以用自定义动态对象来表示这些类型，该对象从已知格式获取其元数据。今天，使用JSON作为数据载体非常普遍，利用JSON模式来表示数据的形状也很常见。让我们看看它如何成为元数据的提供者。
- en: Building a JSON schema type
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建JSON模式类型
- en: 'Start by creating a folder called **Chapter9**. Change into this folder in
    your command-line interface and create a new console project:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个名为 **Chapter9** 的文件夹。在命令行界面中切换到这个文件夹，并创建一个新的控制台项目：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will rely on a third-party library, giving us an easy way of working with
    JSON schemas. Add the package to the project by running the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依赖第三方库，这为我们提供了一个轻松处理JSON模式的方法。通过运行以下命令将包添加到项目中：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A JSON schema is a simple structure that describes a type, its properties,
    and the type of every property. It is, however, limited to the types available
    to JSON:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: JSON模式是一个简单的结构，它描述了一个类型、其属性以及每个属性的类型。然而，它仅限于JSON可用的类型：
- en: String
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Number
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: Boolean
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔
- en: Array
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Object
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: However, a JSON schema does support a concept of *format* that can be used as
    a sub-type for types. For instance, dates are not part of the JSON type system,
    but having a property of type **string** and a format of type **date** would allow
    you to support any type you want, since strings can hold anything.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JSON模式支持一个名为 *格式* 的概念，它可以作为类型的子类型使用。例如，日期不是JSON类型系统的一部分，但拥有一个类型为 **string**
    且格式为 **date** 的属性将允许你支持任何你想要的类型，因为字符串可以包含任何内容。
- en: JSON schemas can also hold sub-schemas, which makes it possible to have strongly
    typed object definitions within an object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: JSON模式还可以包含子模式，这使得在对象内拥有强类型对象定义成为可能。
- en: For this sample, we’re going to keep it very simple and stick with simple types.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将保持非常简单，坚持使用简单类型。
- en: 'Add a file called **person.json** to your project and add the following to
    it:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个名为 **person.json** 的文件添加到你的项目中，并添加以下内容：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the JSON, you’ll find the **title** property, which is the name of the type,
    and the **type** property is set to **object**, since it describes an object.
    The schema then contains three properties with the following types:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSON中，你可以找到 **title** 属性，它是类型的名称，而 **type** 属性设置为 **object**，因为它描述了一个对象。然后模式包含三个属性，其类型如下：
- en: '| **Property** | **Type** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **类型** |'
- en: '| --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| FirstName | String |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 首字母 | 字符串 |'
- en: '| LastName | String |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 姓氏 | 字符串 |'
- en: '| Birthdate | Date |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 出生日期 | 日期 |'
- en: Table 9.1 – A schema for a person
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1 – 人的模式
- en: 'Add a file called **JsonSchemaType.cs**, and add the following code to it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为 **JsonSchemaType.cs** 的文件，并将以下代码添加到其中：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code creates a new type called **JsonSchemaType** that inherits from the
    **DynamicObject** type found in the **System.Dynamic** namespace. This particular
    type is a helper type, created to make it easier to implement dynamic objects.
    To represent the actual content of the type, the code adds **Dictionary<string,
    object?>**. This gives you the flexibility of putting anything into it, much like
    **ExpandoObject** does. The reason for **object?** as the value type is to allow
    anything and also make it explicit that we allow null values in it. The constructor
    takes a **JsonSchema** type from the **NJsonSchema** dependency you added earlier.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个名为 **JsonSchemaType** 的新类型，它继承自 **System.Dynamic** 命名空间中找到的 **DynamicObject**
    类型。这个特定的类型是一个辅助类型，创建它的目的是为了使实现动态对象更加容易。为了表示类型的实际内容，代码添加了 **Dictionary<string,
    object?>**。这使得你可以将其中的任何内容放入其中，就像 **ExpandoObject** 所做的那样。将 **object?** 作为值类型的原因是允许任何内容，并且明确表示我们允许其中包含空值。构造函数接受来自你之前添加的
    **NJsonSchema** 依赖项的 **JsonSchema** 类型。
- en: Validating properties
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证属性
- en: Since JSON schemas give you a full description of a type, its properties, and
    the types for the properties, it gives you an opportunity to validate the values
    being set on the object.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JSON架构提供了类型的完整描述，包括其属性和属性的类型，它为你提供了验证对象上设置的值的机会。
- en: 'Let’s introduce some basic validation into the object. Start by adding a new
    file that will give us an explicit exception describing the problem that can occur.
    Add a file called **InvalidTypeForProperty.cs**, and add the following code to
    it:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在对象中引入一些基本的验证。首先添加一个新文件，该文件将给出可能发生的具体问题的显式异常。添加一个名为**InvalidTypeForProperty.cs**的文件，并将以下代码添加到其中：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The custom exception takes two properties – the name of the type that owns the
    errored property and then the actual property that was wrong. You could also include
    for good measure the type it was trying to set and what was expected, but to keep
    the sample simple, let’s just go with this.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义异常有两个属性 - 错误属性所属类型的名称以及实际错误的属性。你也可以为了保险起见包括它试图设置的类型以及期望的类型，但为了使示例简单，让我们只使用这个。
- en: 'To do the actual validation, you’ll need something that translates from the
    .NET type to **JsonObjectType**. Go back to the **JsonSchemaType.cs** file and
    add a method that does the necessary translations from the .NET type to a **JsonObjectType**.
    Add the following method to the **JsonSchemaType** class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行实际验证，你需要将.NET类型转换为**JsonObjectType**的东西。回到**JsonSchemaType.cs**文件，添加一个将.NET类型转换为**JsonObjectType**所需的方法。将以下方法添加到**JsonSchemaType**类中：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code uses a simple pattern matching and converts from the .NET type to **JsonObjectType**.
    It defaults to **JsonObjectType.Object** for anything it doesn’t have an explicit
    conversion for.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用简单的模式匹配并将.NET类型转换为**JsonObjectType**。对于没有明确转换的情况，它默认为**JsonObjectType.Object**。
- en: Important note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This implementation is very simplistic and does not cover all the .NET types,
    and you should probably make it a bit more sophisticated for production. Hopefully,
    though, it gives you a general idea.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现非常简单，并不涵盖所有.NET类型，你可能需要为生产环境使其更复杂。不过，它应该给你一个一般性的概念。
- en: 'Now that you have a way of converting from a CLR type to **JsonObjectType**,
    you need a way to actually do the validation. Add the following method to the
    **JsonSchemaType** class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了从CLR类型转换为**JsonObjectType**的方法，你需要一种实际进行验证的方法。将以下方法添加到**JsonSchemaType**类中：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code only validates a value if it is not null, since you wouldn’t be able
    to know its type unless it has a value. With the type, it gets the actual schema
    type and then checks whether or not the property has this type. **JsonObjectType**
    is an enum of flags, and combinations are allowed, which is why you have to use
    the **HasFlag** method. If it’s not the correct type, the code throws the **InvalidTypeForProperty**
    exception.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 代码只有在值不为null时才会验证该值，因为除非它有值，否则你无法知道它的类型。有了类型，它就获取实际的架构类型，然后检查属性是否具有此类型。**JsonObjectType**是一个标志枚举，允许组合，这就是为什么你必须使用**HasFlag**方法。如果类型不正确，代码会抛出**InvalidTypeForProperty**异常。
- en: Important note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A tip here would be to also validate whether null is allowed or not. This information
    is also supported by JSON schemas. Some types also inherently don’t allow nulls,
    such as integers or Booleans, and you should probably not allow that.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个提示是也要验证是否允许null。此信息也由JSON架构支持。某些类型本身也不允许null，例如整数或布尔值，你可能不应该允许这种情况。
- en: Implementing getting and setting properties
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现获取和设置属性
- en: With the constructor and validation in place, you’re now ready to override some
    of the default behavior of the **DynamicObject** type. The **DynamicObject** type
    offers a set of virtual methods that can be overridden for the different operations
    that can be performed, such as getting or setting properties and invoking methods.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数和验证就绪后，你现在可以覆盖**DynamicObject**类型的某些默认行为。**DynamicObject**类型提供了一组虚拟方法，可以覆盖以执行不同的操作，例如获取或设置属性和调用方法。
- en: 'In this sample, we will focus primarily on properties. Add the following method
    to the **JsonSchemaType** class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将主要关注属性。将以下方法添加到**JsonSchemaType**类中：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The **TrySetMember** signature takes **SetMemberBinder**, which holds the information
    about the property being set. It also gets the value, which can be null. The code
    then first validates whether or not the property actually exists in the schema
    by looking into the **ActualProperties** dictionary. If it does not exist, it
    immediately returns **false**, and if you were to try to set an unknown property,
    you would then get **RuntimeBinderException**. When the property exists, the code
    validates the type of the value. If the type is correct, the code then sets the
    value in its private dictionary.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**TrySetMember**签名接受**SetMemberBinder**，它包含有关正在设置的属性的详细信息。它还获取值，该值可能为null。然后代码首先通过查看**ActualProperties**字典来验证该属性是否实际存在于模式中。如果不存在，它立即返回**false**，如果你尝试设置一个未知的属性，那么你会得到**RuntimeBinderException**。当属性存在时，代码验证值的类型。如果类型正确，代码然后将其值设置在其私有字典中。'
- en: 'Once you have set a property, you also want to read it. Add the following method
    to the **JsonSchemaType** class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了一个属性，你也想读取它。向**JsonSchemaType**类添加以下方法：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Similar to the **TrySetMember**, the code adds a check on whether or not the
    schema has the property. However, since this is a **get** operation and the signature
    of the method dictates that the result should be given as an **out** parameter,
    we need to explicitly set it to **null!**. The code then checks whether the private
    dictionary contains a value for the property and returns it if it does or returns
    a **null!** value if not.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与**TrySetMember**类似，代码会检查模式是否有该属性。然而，由于这是一个**get**操作，并且方法的签名规定结果应该作为**out**参数给出，我们需要显式地将它设置为**null!**。然后代码检查私有字典是否包含该属性的值，如果包含则返回它，如果不包含则返回一个**null!**值。
- en: Important note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In a production system, you would typically not want to return just **null**
    if the value is not set. It should be set to either the default value of the type
    or, if the JSON schema holds additional metadata with a default value, you should
    use that.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个生产系统中，你通常不希望仅返回**null**，如果值没有被设置。它应该被设置为该类型的默认值，或者如果JSON模式包含具有默认值的附加元数据，你应该使用那个值。
- en: As a *nice-to-have* feature, we want to allow this type to be converted to another
    type – in our case, **Dictionary<string, object?>**.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项**值得拥有的**功能，我们希望允许这种类型转换为另一种类型——在我们的例子中，是**Dictionary<string, object?>**。
- en: 'One of the methods that **DynamicObject** provides that can be overridden is
    the **TryConvert** method. This method will be called if an explicit cast is done
    from the type to a different target type. Add the following method to the **JsonSchemaType**
    class:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**DynamicObject**提供的一个可以重写的方法是**TryConvert**方法。如果从类型显式转换为不同的目标类型，将调用此方法。向**JsonSchemaType**类添加以下方法：'
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The code only allows conversion to **Dictionary<string, object?>**, so it checks
    for this first by looking at the **Type** property of the **ConvertBinder** type
    being passed in. It is a good practice to return values for all properties in
    the schema and not leave out any properties, and since all properties might be
    set, the code creates a new dictionary from the existing **_values** dictionary
    and then finds any properties that are missing. For every property that is missing,
    it sets a default value.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 代码只允许转换为**Dictionary<string, object?>**，因此它首先通过查看传入的**ConvertBinder**类型的**Type**属性来检查这一点。返回模式中所有属性的值是一种良好的实践，不要遗漏任何属性，并且由于所有属性可能都已设置，代码从现有的**_values**字典创建一个新的字典，然后找到任何缺失的属性。对于每个缺失的属性，它都会设置一个默认值。
- en: Important note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The default values have been simplified. As mentioned earlier, for production
    you should consider a more sophisticated approach to default values and look at
    possible additional metadata in the JSON schema.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值已经简化。如前所述，对于生产，你应该考虑对默认值采用更复杂的方法，并查看JSON模式中可能存在的附加元数据。
- en: 'The last piece of the puzzle we want to add is the ability for outsiders to
    reason about what members are available. The **DynamicObject** type gives us a
    method that can be overridden for this. Add the following method to the **JsonSchemaType**
    class:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要添加的最后一块拼图是让外部人士能够推理出哪些成员可用。**DynamicObject**类型为我们提供了一个可以重写的方法。向**JsonSchemaType**类添加以下方法：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This method will be called by **DynamicMetaObject** that **DynamicObject** produces.
    **DynamicObject** is also **IDynamicMetaObjectProvider** and implements the **GetMetaObject()**
    method.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将由**DynamicObject**产生的**DynamicMetaObject**调用。**DynamicObject**也是**IDynamicMetaObjectProvider**，并实现了**GetMetaObject()**方法。
- en: '**DynamicObject** has more methods that can be overridden to invoke methods,
    perform binary operations, and so on. However, for this sample, we will focus
    on the data aspects with properties.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**DynamicObject** 有更多可重写的方法来调用方法、执行二元运算等。然而，对于这个示例，我们将专注于使用属性的数据方面。'
- en: Using the schema infrastructure
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模式基础设施
- en: 'What you’ve built so far is an infrastructure to work with JSON schemas, together
    with the DLR. Let’s take **JsonSchemaType** out for a spin. Open the **Program.cs**
    file and take out all its content. Add the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您到目前为止构建的是一个用于处理 JSON 模式的基础设施，以及 DLR。让我们来试一试 **JsonSchemaType**。打开 **Program.cs**
    文件并移除其所有内容。添加以下内容：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The code reads the JSON schema from the **person.json** file you created earlier.
    Then, it creates an instance of **JsonSchemaType** and hands it the schema. Since
    **JsonSchemaType** is a dynamic object, it implements **IDynamicMetaObjectProvider**,
    and we can call the **GetMetaObject()** method with the instance of the object
    and then get its members.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从您之前创建的 **person.json** 文件中读取 JSON 模式。然后，它创建一个 **JsonSchemaType** 实例并将其模式传递给它。由于
    **JsonSchemaType** 是一个动态对象，它实现了 **IDynamicMetaObjectProvider**，我们可以使用对象的实例调用 **GetMetaObject()**
    方法，然后获取其成员。
- en: 'When run, the code should produce the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，代码应该产生以下结果：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Setting and getting properties should work as expected:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和获取属性应该按预期工作：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Running the code should give you the following output:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码应该给出以下输出：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since the implementation of **JsonSchemaType** supports default values for
    properties that have not been set, you can get a valid property without any problems:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 **JsonSchemaType** 的实现支持未设置的属性的默认值，您可以无任何问题地获取一个有效的属性：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The result of this should be the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生以下结果：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Converting this property to a dictionary should also work out of the box through
    an explicit cast:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将此属性转换为字典也应该通过显式转换直接工作：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The result of this should be the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生以下结果：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To test the validation, you can try to set the **LastName** property to an
    unsupported type:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试验证，您可以尝试将 **LastName** 属性设置为不支持的数据类型：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The result of this should be the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生以下结果：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The last thing we can do to verify that all is working as expected is to set
    a property that does not exist in the schema:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证一切按预期工作，我们可以设置一个在模式中不存在的属性：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This should produce the following result:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生以下结果：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Working with the **DynamicObject** helper type eases the development of dynamic
    objects, as you don’t have to worry about the complexity of the moving parts and
    can focus on the actual shape and capabilities of the dynamic object you want
    to provide.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **DynamicObject** 辅助类型简化了动态对象的开发，因为您不必担心移动部件的复杂性，可以专注于您想要提供的动态对象的实际形状和能力。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explored the dynamic realm of the .NET runtime and how you can
    take advantage of it to create dynamic types that have its types defined outside
    of C# code. When working with third parties through APIs, this approach can be
    very handy. If you look at REST APIs and the OpenAPI standard, you’ll see extensive
    use of JSON schemas, and marrying the approach in this chapter with such standards
    can provide you a powerful mechanism to dynamically integrate with third parties,
    and at the same time, you can be strict about the shape.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了 .NET 运行时的动态领域以及您如何利用它来创建在 C# 代码之外定义类型的动态类型。当通过 API 与第三方合作时，这种方法可能非常有用。如果您查看
    REST API 和 OpenAPI 标准，您会发现 JSON 模式的广泛使用，将本章中介绍的方法与这些标准相结合，可以为您提供一种强大的机制来动态集成第三方，同时您还可以对数据的形状保持严格。
- en: The DLR can be a powerful tool in your toolbox. It provides another approach
    to dynamically create types and code. Compared to generating intermediate language
    code, it can come across as more intuitive.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: DLR 可以成为您工具箱中的一个强大工具。它提供了另一种动态创建类型和代码的方法。与生成中间语言代码相比，它可能看起来更直观。
- en: One of the downsides of the DLR is that the types generated can be hard to work
    with in a modern IDE or code editor, as it does not know about the types and can’t
    offer services such as IntelliSense for members.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: DLR 的一个缺点是生成的类型在现代 IDE 或代码编辑器中可能难以处理，因为它不了解这些类型，无法提供诸如 IntelliSense 成员等服务。
- en: Another aspect of using the DLR and a dynamic approach can be performance. It
    will not be as performant as generating intermediate language code. This is one
    of the trade-offs you will have to make, but for specific scenarios, that might
    not be an issue at all.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DLR和动态方法的一个方面可能是性能。它的性能可能不如生成中间语言代码。这是您必须做出的权衡之一，但在特定场景下，这可能根本不是问题。
- en: In the next chapter, we will shift gears a little bit and look at how we can
    take advantage of some of the techniques we’ve discussed so far in the book and
    start thinking in terms of **convention** **over configuration**.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将稍微改变一下方向，看看我们如何利用本书中讨论的一些技术，并开始从**约定** **而非配置**的角度思考。
- en: Part 3:Increasing Productivity, Consistency, and Quality
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：提高生产力、一致性和质量
- en: In this part, you will see how metaprogramming can be used to improve code quality
    and leave you with a more maintainable and consistent code base. At the same time,
    this part gives you ideas on how techniques can improve the productivity of you
    and your developers. The different chapters touch on principles and software design
    patterns and how they can be used in real life.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，您将看到如何使用元编程来提高代码质量，并使您的代码库更加可维护和一致。同时，这部分还为您提供了关于如何通过技术提高您和您的开发者的生产力的想法。不同的章节涉及原则和软件设计模式，以及它们如何在现实生活中应用。
- en: 'This part has the following chapters:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 10*](B19418_10.xhtml#_idTextAnchor162), *Convention over Configuration*'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19418_10.xhtml#_idTextAnchor162)，*约定优于配置*'
- en: '[*Chapter 11*](B19418_11.xhtml#_idTextAnchor177), *Applying the Open-Closed
    Principle*'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B19418_11.xhtml#_idTextAnchor177)，*应用开闭原则*'
- en: '[*Chapter 12*](B19418_12.xhtml#_idTextAnchor196), *Go Beyond Inheritance*'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B19418_12.xhtml#_idTextAnchor196)，*超越继承*'
- en: '[*Chapter 13*](B19418_13.xhtml#_idTextAnchor206), *Applying Cross-Cutting Concerns*'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B19418_13.xhtml#_idTextAnchor206)，*应用横切关注点*'
- en: '[*Chapter 14*](B19418_14.xhtml#_idTextAnchor219), *Aspect-Oriented Programming*'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B19418_14.xhtml#_idTextAnchor219)，*面向方面编程*'
