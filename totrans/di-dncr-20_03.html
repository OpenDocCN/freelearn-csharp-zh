<html><head></head><body>
        

                            
                    <h1 class="header-title">Introducing Dependency Injection in .NET Core 2.0</h1>
                
            
            
                
<p>This chapter is a first approach in the implementation of .NET Core Dependency Injection technologies in the most recent version of .NET Core (2.0). Its main features, functionalities, and the namespaces holding the set of classes support these features.</p>
<p>We will talk about the following in this chapter:</p>
<ul>
<li>In all, we'll talk about how .NET Core includes support for several of the SOLID principles in general and those related to Dependency Injection in particular</li>
<li>We'll start with the main characteristics of .NET Core and its installation and usage from Visual Studio, especially focusing on the latest version, Visual Studio 2017, together with the distinct types of deployment that this version allows</li>
<li>Then, we'll get into the Dependency Injection in .NET Core, the <kbd>ActivatorUtilities</kbd> class, and the <kbd>Microsoft.Extensions.DependencyInjection</kbd> container</li>
<li>Later on, we'll see some demos related to the implementation of an object's lifetime and how to map interfaces to instance classes, as well as a brief reminder of some more aspects of the Scope when applied to services</li>
<li>Finally, we'll see how this DI functionality is also implemented inside some .NET Core services, especially those related to logging with plenty of demos showing how to use it in pure .NET Core</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The main characteristics of .NET Core</h1>
                
            
            
                
<p>We've explained the basics of the architecture proposal of .NET Core in <a href="d6bd2d11-4eec-499b-826c-b4ad849945a8.xhtml" target="_blank">Chapter 1</a>, <em>The SOLID Principles of Software Design</em> and how it pretends to be a game-changer, since it offers the possibility of creating code in the same language (C# or VB.NET), capable of executing on any device or platform.</p>
<p>Please note that VB.NET support of new features always goes behind the advances you'll see in the C# language, so, in case you try some new feature using this language, you should make sure that it has been implemented for the version we're using in this book.</p>
<p>This capability also extends to mobile applications, thanks to the incorporation of the Xamarin environment (and IDE) to the set of tools related to .NET Core development.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The main advantages of .NET Core</h1>
                
            
            
                
<p>If we look at this framework from a more developer-like point of view, we could say that what makes .NET Core different from other choices can be summarized in the following points:</p>
<ul>
<li><strong>Cross-platform:</strong> This means execution on Windows, macOS and Linux, and also its portability to other operating systems. You can check the list of supported operating systems on various sites, such as <a href="https://github.com/dotnet/core/blob/master/roadmap.md">https://github.com/dotnet/core/blob/master/roadmap.md</a>, and you should bear in mind that CPUs and application scenarios will keep growing, whether they are provided by Microsoft or other companies.</li>
<li><strong>Compatibility:</strong> .NET Core is not only compatible with the .NET Framework, but also with Xamarin and Mono, thanks to the .NET Standard Library. As the official documentation states, the .NET Standard Library is,</li>
</ul>
<p>"a formal specification of .NET APIs that are intended to be available on all .NET runtimes. The motivation behind the Standard Library is establishing greater uniformity in the .NET ecosystem. ECMA 335 continues to establish uniformity for .NET runtime behavior, but there is no similar spec for the .NET Base Class Libraries (BCL) for .NET library implementations."</p>
<ul>
<li><strong>Deployment:</strong> Perhaps the most interesting feature about runtime is that it can be deployed inside an application or installed in a side-by-side user-or machine-wide basis</li>
<li><strong>Distinct command-line options:</strong> All distinct scenarios can be used at the command-line tools (and that's extensible to the rest of the platforms)</li>
<li><strong>Open source:</strong> The .NET Core platform is open source, since its inception. It uses MIT and Apache 2 licenses, and the documentation is licensed under Creative Commons 4.0 (CC-BY, see <a href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a>). Besides that, .NET Core is a .NET Foundation (<a href="http://www.dotnetfoundation.org/">http://www.dotnetfoundation.org/</a>) project</li>
<li><strong>Microsoft's support:</strong> .NET Core is completely supported by Microsoft, and you'll find plenty of documentation, videos, forums, and so on in promotion sites that the company usually encourages as it is indicated in .NET Core Support (<a href="https://www.microsoft.com/net/core/support/">https://www.microsoft.com/net/core/support/</a>)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Installation of .NET Core in the IDE</h1>
                
            
            
                
<p>In <a href="d6bd2d11-4eec-499b-826c-b4ad849945a8.xhtml" target="_blank">Chapter 1</a>, <em>The SOLID Principles of Software Design</em>, we mentioned that you could use .NET Core (and ASP.NET Core) with any IDE of your choice. However, in this book, I'm using Visual Studio 2017 due to its integration tools and facilities, and its degree of optimization for .NET Core projects.</p>
<p>Nevertheless, and due to its youth, there's no common installation path for all versions of Visual Studio and, depending on the one you use, you'll find two different approaches.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installation path for .NET Core in Visual Studio 2015</h1>
                
            
            
                
<p>If you want to use Visual Studio 2015, you should have Update 3.3 installed. It's available from this link: <a href="https://www.visualstudio.com/en-us/news/releasenotes/vs2015-update3-vs">https://www.visualstudio.com/en-us/news/releasenotes/vs2015-update3-vs</a>. In this site, you'll see how the update is related to NET Core 1.0.0 and .NET Core 1.0.0 SDK Preview 2.</p>
<p>If you're not sure about this version, just check the About Microsoft Visual Studio in the Help menu and make sure the version number is 14.0.25424.00 or higher, and includes Update 3.</p>
<p>You'll also need:</p>
<ul>
<li>The <strong>NuGet Manager</strong> extension for Visual Studio (you know, NuGet is the official package manager for Microsoft development, and we can be sure that it includes .NET Core in all its versions). You need NuGet 3.5.0-beta or higher to build .NET Core apps.</li>
<li>.<strong>NET Core Tooling Preview 2+</strong>, which takes care of project templates and other tools for Visual Studio 2015, and you can find it at <a href="https://go.microsoft.com/fwlink/?LinkID=827546">https://go.microsoft.com/fwlink/?LinkID=827546</a>.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">.NET Core in Visual Studio 2017</h1>
                
            
            
                
<p>The case for Visual Studio 2017 is quite different, since it takes care of the installation of prerequisites, as long as you have selected the .NET Core and Docker workload during the initial installation process (remember that, in V. Studio 2017, installation is made in a modular fashion, so, by default, it only installs a minimum set of features).</p>
<p>As it happens in the previous case, if you want to make sure about the installed version, just check in the Help/About Visual Studio menu, and see if you have version 15.0.26020.0 or higher.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Types of deployment</h1>
                
            
            
                
<p>We've mentioned how .NET Core allows using two distinct kinds of deployment for your apps--<strong>Framework Dependent Deployment</strong> (<strong>FDD</strong>), and <strong>Self-Contained Deployment (SCD).</strong> Which one to choose? That will depend on the target system and the amount of knowledge and management control that we might have about it.</p>
<p>Let's briefly remind ourselves about the main differences between these two types of deployment and its implications facing the management and structure of the assemblies resulted from any .NET Core compilation process:</p>
<ul>
<li>Framework Dependent relies on a shared version of .NET Core that should be installed on the target system. If this is the case, the application is portable between installations of .NET Core.</li>
<li>Notice that, in this case, the app contains only its own code and any third-party dependencies that are outside of the .NET Core libraries. This is because FDDs contain <kbd>.dll</kbd> files that can be launched by means of the <kbd>dotnet</kbd> utility from the command line. Remember that if you launch, for example, the command <kbd>dotnet</kbd><kbd>application1.dll</kbd>, that's enough to run an application named <kbd>application1.dll</kbd>.</li>
<li>On the other side, SCD apps don't rely on any external code installed on the destination system. That is, all components, (and that includes both .NET Core libraries and the .NET Core runtime), are included in the final, installable package, and are isolated from other .NET Core applications.</li>
<li>Consequently, SCDs include an executable (something like <kbd>app1.exe</kbd> on Windows platforms for an app of that name). This is a renamed version of the platform-specific .NET Core host, and a DLL file (such as <kbd>app.dll</kbd>), which is the actual application.</li>
<li>So, you're deploying a concrete version of .NET Core as the executable together with your application, that will always adopt the form of a DLL, and it will run inside the context created by the executable.</li>
</ul>
<p>As you can see, it is a very different approach, and perhaps, the first time that we can generate totally independent executable applications with .NET.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Checking other dependencies in .NET Core</h1>
                
            
            
                
<p>Before we keep on walking through the .NET Core features, it is wise to keep in mind that dependency is not only a matter of classes' relations but also about the components used to build applications, and the IDE might help us when defining and visually analyzing those dependencies even when the application is already compiled.</p>
<p>This is especially important in a framework where these components, are always downloaded from NuGet (or any other valid repository) and updated in our projects within Visual Studio 2017 in a dynamic manner.</p>
<p>Not taking care of these aspects, might lead to several problems. Among them, I'd like to highlight the following:</p>
<ul>
<li>Maintainability issues</li>
<li>Security flaws</li>
<li>License misuse</li>
<li>Unwanted dependencies</li>
</ul>
<p>In order to help developers to prevent dependency's issues, from version 2010 of Visual Studio, the IDE offers the ability to create layer diagrams, which have evolved continuously since that version.</p>
<p>With these diagrams, you can express dependencies between layers, and these dependencies are not just shown through the diagrams hints but, starting in the latest version (2017), in the code itself.</p>
<p>When you design one of these diagrams, you can express dependencies using symbols provided by the designer that include single and bi-directional dependency, layers, and simple shapes, as you can see in the following screenshot:</p>
<div><img class=" image-border" src="img/2a19ce2c-cefb-4ede-b3ed-6e210595a7a9.png"/></div>
<p>This diagram is created using the new menu option related to the Architecture menu in the IDE, which also presents some features related to code analysis, such as Code Map generation, the possibility to create graphs of those external files (graph of <kbd>Include Files</kbd>), and other features. In all, that option presents the following options:</p>
<div><img height="146" width="381" class=" image-border" src="img/331d0368-7f23-41b6-918c-c77efcda6d18.png"/></div>
<p>Remember that this Architecture menu is only available in V.Studio 2017 Enterprise.</p>
<p>One of this menu's options is the new Dependency Validation diagram, which launches a new editing window, where we can drag and drop elements from the solution, including folders, files (C# and VB.NET) and even assemblies. We could consider these features as other implementations that the IDE offers to study any applications' dependencies.</p>
<p>This technique, has been rebuilt from scratch using Roslyn (refer my book <em>Mastering C# and .NET Framework</em> also by Pack, for more details and demos about this feature), and it allows the coder to configure the editor's behavior in a totally customized manner, programming how the IDE should respond when encountering any of these features in code (or even in other assemblies, since the tool accepts drag and drop already-compiled pieces too).</p>
<p>Once you establish relations and dependencies in the diagram, this new Intellisense will be able to validate the existing code, advising the programmer about the conflicting areas inside different application domains.</p>
<p>Actually, you can activate these features in the configuration in a such a way, that, as soon as a problem is detected, you will see a squiggle highlighting your offending code, together with an indication of the root of the problem.</p>
<p>For instance, we can establish which classes are allowed to live in every application's namespace. If a single class is moved to a namespace forbidden by the dependency diagram, a hint will be presented in the code editor itself and, also, in the Error List window (see the following screenshot):</p>
<div><img class=" image-border" src="img/84aa0679-a0fb-4a0d-8f76-410e81044608.png"/></div>
<p>Of course, this behavior is also configurable, and these features are independent from other options we find in the Analyze menu in relation with Code Metrics, Performance Profilers, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dependency Injection in .NET Core</h1>
                
            
            
                
<p>When dealing with the proper features related to Dependency Injection in .NET Core, there are a bunch of previous approaches to consider. One of those is the mantra <kbd>new</kbd> is glue, which we often hear as an advice.</p>
<p>This means that whenever you create a new instance of a class (you use the <kbd>new</kbd> keyword), there's some code cohesion behind the scenes. You're establishing that the class that defines that instance is going to have a dependency on the instantiated class.</p>
<p>We've seen how to get rid of that problem via factories, or using third-party libraries focused on the DI problem and how they can be used, but, in this chapter, we're going to rely on those features provided by the framework itself to achieve the same results.</p>
<p>Ideally, that's something that we could define and, once the definition is registered, every time we need an instance of any of the predefined classes, something else should take care of providing that instance.</p>
<p>In other words, the behavior we've seen related to other DI containers should (more or less) be present here as well, and cover the most important features that those veteran containers offer, including an object's lifetime, registration, and definition of generic classes and interfaces, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">DI Architecture and Object's Lifetime</h1>
                
            
            
                
<p>Considering the preceding points, and even knowing that we're dealing with an initial version of the frameworks, the .NET Core team designed Dependency Injection features based on two ideas:</p>
<ul>
<li>On one side, there was already existing functionality, that could be perfectly extended to work inside .NET Core</li>
<li>On the other side, they thought that it would be wise to include the most used features present in other initiatives, (either Microsoft's or external) like those present in Prism Patterns &amp; Practices or third party DI Containers (remember the four containers we saw in previous chapters)</li>
</ul>
<p>Consequently (following these ideas), when dealing with an object's lifetime, .NET Core presents three types, depending on the way instances will be configured and used--Singleton, Scoped, and Transient.</p>
<ul>
<li>These options do not only have influence in the way we define them, but also in the way we can use them, and in some cases, thread safe precautions, and other aspects should be considered.</li>
<li>In the Singleton option, a unique instance of the object is used (meaning that we only manage a reference to the object). Any further request uses the same instance, according to the singleton pattern.</li>
<li>The Scoped version is local to the context in which it is used and doesn't extend beyond that context.</li>
<li>Finally, the Transient option creates a new instance of the class every time is requested.</li>
</ul>
<p>Although included in the ASP.NET Core documentation, Microsoft provides the following diagram in relation to these options:</p>
<div><img height="195" width="391" class=" image-border" src="img/f55299db-672f-4987-ac1d-d401ea3d01b2.png"/></div>
<p>Since, in the real world, this functionality is mainly linked to ASP.NET Core apps, services and middleware show up with functionality that helps in the task (that's why those references are to the <em>request</em>). But it actually works equally well in pure .NET Core applications.</p>
<p>As we mentioned at the beginning, a big part of this functionality is related to the <kbd>Microsoft.Extensions.DependencyInjection</kbd> namespace, included in a DLL of the same name, which can work in conjunction with another helper DLLs such as <kbd>Microsoft.Extensions.DependencyInjection.Abstractions</kbd> and others.</p>
<p>Concretely, the <kbd>IServiceCollection</kbd> interface is the base of a set of classes that provide methods to instantiate objects (usually called services in this context) via DI using these three options. We'll see this in action in the next sections, but also in <a href="06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml" target="_blank">Chapter 4</a>, <em>Dependency Injection in ASP.NET Core,</em> dedicated to ASP.NET Core.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The class ActivatorUtilities and other helpers</h1>
                
            
            
                
<p>Before we get into the demos, keep in mind that the number of classes included in this namespace is pretty large, since it pretends to offer a wide coverage while still being multi-platform.</p>
<p>One of these cases is the class <kbd>ActivatorUtilities</kbd> class, also included in the <kbd>Microsoft.Extensions.DependencyInjection</kbd> library, which contains static methods to help in the configuration and implementation of services, instances, and factories that ease DI management and control.</p>
<p>Thus, in case you find yourself missing some feature or functionality, take a look at the documentation at <a href="http://docs.microsoft.com">http://docs.microsoft.com</a>, but, keep in mind that you'll find that it is related to ASP.NET Core.</p>
<p>This means that most of the implementations that you will see (on the internet and other sources) are not going to be linked to .NET Core apps, but to ASP.NET Core apps, in which, much of this functionality is implemented by default for different scenarios.</p>
<p>Obviously, there's much more inside those classes that we cannot cover in a single chapter.</p>
<p>To give you an idea of the possibilities linked to this class, I'm including a summary of its functionality presented in the official documentation, reminding you of each method and its main purpose:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Methods summary</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_CreateFactory_System_Type_System_Type___">CreateFactory(Type, Type[])</a></p>
</td>
<td>
<p>Create a delegate that will instantiate a type with constructor arguments provided directly and/or from a <kbd>System.IServiceProvider</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_CreateInstance_System_IServiceProvider_System_Type_System_Object___">CreateInstance(IServiceProvider, Type, Object[])</a></p>
</td>
<td>
<p>Instantiate a type with constructor arguments provided directly and/or from a <kbd>System.IServiceProvider</kbd>.</p>
</td>
</tr>
<tr>
<td>&lt;p&gt;<a href="https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_CreateInstance__1_System_IServiceProvider_System_Object___">CreateInstance&lt;T&gt;(IServiceProvider, Object[])</a></td>
<td>
<p>Instantiate a type with constructor arguments provided directly and/or from a <kbd>System.IServiceProvider</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_GetServiceOrCreateInstance_System_IServiceProvider_System_Type_">GetServiceOrCreateInstance(IServiceProvider, Type)</a></p>
</td>
<td>
<p>Retrieve an instance of the given type from the service provider. If one is not found, then instantiate it directly.</p>
</td>
</tr>
<tr>
<td>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/api/microsoft.extensions.dependencyinjection.activatorutilities#Microsoft_Extensions_DependencyInjection_ActivatorUtilities_GetServiceOrCreateInstance__1_System_IServiceProvider_">GetServiceOrCreateInstance&lt;T&gt;(IServiceProvider)</a></p>
</td>
<td>
<p>Retrieve an instance of the given type from the service provider. If one is not found, then instantiate it directly.</p>
</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>It's now time to start working with the main classes related to DI inside the <kbd><strong>Microsoft.Extensions.DependencyInjection</strong></kbd> and <kbd><strong>Microsoft.Extensions.DependencyInjection.Abstractions</strong></kbd> libraries.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Microsoft.Extensions.DependencyInjection container</h1>
                
            
            
                
<p>Most of the samples that you'll see on the internet about Dependency Injection and .NET Core will reference to ASP.NET Core applications since it comes by default when you use the predefined template inside Visual Studio.</p>
<p>However, the use of ASP.NET Core applications is not mandatory if you want to see how DI works from scratch. That being said, we will have to configure the registering of our services manually. This implies certain extra aspects such as severity levels, an object's lifetime, and disposable features if we want this architecture to work seamlessly.</p>
<p>Since .NET Core offers its own container linked to the external library <kbd>Microsoft.Extensions.DependencyInjection</kbd> (now, in version 2.0), we'll have to reference it via NuGet packages.</p>
<p>For a first demo, we can create a simple .NET Core Console application, reference the library using the NuGet package plug-in, and look for its name online. You'll observe that when you filter for that name, the NuGet Package Manager, presents several versions of the library (see the following screenshot):</p>
<div><img class=" image-border" src="img/b65efcfb-babb-4daf-81f2-c70983dd38e3.png"/></div>
<p>As you see, other libraries are also declared as complementary (<kbd>Microsoft.Extensions.DependencyInjection.Abstractions</kbd>, and <kbd>Microsoft.Extensions.DependencyInjection.Specification.Tests</kbd>). The first one (the <kbd>Abstractions</kbd>) should also appear as referenced inside our project once the installation is completed. But for now, let's focus on the main library.</p>
<p>At this moment, don't be scared of the following dialog box. It will tell you that a whole bunch of libraries is going to be updated, and another set of libraries will be installed anew. The reason for this might be double--on one side, the use of the latest versions of this library implies updating other previously referenced libraries according to an internal library dependency manager that Visual Studio 2017 uses.<br/>
On the other side, installation of some new libraries, like this one, might imply other dependencies, so we end up with two distinct areas of updates (go to the Dependencies section in the Solution Explorer after installation).</p>
<p>Visual Studio 2017 will offer a list of every library being updated and if you scroll down a bit, also the list of all the dependent libraries:</p>
<div><img height="309" width="341" class=" image-border" src="img/b5e0f7ef-5266-4279-b903-81b9dde13c74.png"/></div>
<p>After this dialog box, you'll be presented another one with the License Acceptance of each one of the libraries. Once completed, another entry in your Dependencies section of the Solution Explorer will show up, pointing to NuGet. That's where you'll find all that new stuff.</p>
<p>A further look at those new entries will reveal all the main and dependent libraries linked to that DependencyInjection reference, which might be a few.</p>
<p>Since, initially, we just want to make a test of how this namespace works, we'll start testing it in a very simple manner (Legit is to say that I was inspired by Jurgen Gustch's blog's entry Using Dependency Injection in .NET Core Console Apps, because, for this initial approach, I found it especially suitable and explanatory).</p>
<p>So, I've modified those ideas to create a couple of classes, in which the first one happens to have dependencies on the other (that is, the first class references the second).</p>
<p>Just for the matter of completeness, I included an extra method to check the right moment in which it was invoked, and also implemented the <kbd>IDisposable</kbd> interface to be able to convey information about disposal by the Garbage Collector (more about that later).</p>
<p>So, I ended with this code (outside of the class <kbd>Program</kbd> class that the template creates by default):</p>
<pre>    public class DependencyClass1 : IDisposable 
    { 
      private readonly DependencyClass2 _DC2; 
      public DependencyClass1(DependencyClass2 DC2instance) 
      { 
        _DC2 = DC2instance; 
        Console.WriteLine("Constructor of DependencyClass1 finished"); 
      } 
      public void CurrentTime() 
      { 
        string time = DateTime.Now.Hour.ToString() + ":" + 
           DateTime.Now.Minute.ToString() + ":" + 
           DateTime.Now.Second.ToString(); 
        Console.WriteLine($"Current time: {time}"); 
      } 
      public void Dispose() 
      { 
        _DC2.Dispose(); 
        Console.WriteLine("DependencyClass1 disposed"); 
      } 
    } 
    public class DependencyClass2 : IDisposable 
    { 
      public DependencyClass2() 
      { 
        Console.WriteLine("Constructor of DependencyClass2 finished"); 
      } 
 
      public void Dispose() 
      { 
        Console.WriteLine("DependencyClass2 Disposed"); 
      } 
    } </pre>
<p>Notice also that <kbd>DependencyClass1</kbd> takes care of disposing <kbd>DependencyClass2</kbd>, once it's done with it.</p>
<p>Now it comes when the <kbd>DependencyInjection</kbd> classes are needed. First, we make a reference to the corresponding namespace on top of our code (only two namespaces are required for this simple demo):</p>
<pre>    using Microsoft.Extensions.DependencyInjection; 
    using System; </pre>
<p>Then, inside the <kbd>Program</kbd> class, we need to register and use these classes. The first step is performed using a new instance of the <kbd>ServiceCollection</kbd> class.</p>
<p>Inside that class, we find methods to register all required services in a way that at the same time, configures the object's lifetime mentioned previously, as you can see in the following screenshot:</p>
<div><img height="166" width="716" class=" image-border" src="img/73ac9339-cc80-4532-b126-17912c57a125.png"/></div>
<p>As we will see further on, we're provided with two versions of every method--generic and a non-generic. This gives us more flexibility to integrate different classes and services into our DI architecture.</p>
<p>For this initial version, we're using the <kbd>AddTransient</kbd> generic version of the methods, which will return new instances of every class, every time we make a reference in the code.</p>
<p>Once our classes are registered, a provider has to be built with that definition. That's something we perform with a call to <kbd>BuildServiceProvider()</kbd> on the <kbd>ServicesCollection</kbd> class just created (we'll go back to service providers later on). But, for now, suffice to say that an instance of the <kbd>IServiceProvider</kbd> interface will be created and configured to manage any request for one of the classes previously registered using the <kbd>Add*</kbd> method.</p>
<p>Another thing to point out is that the way objects are instantiated follows the lazy creation pattern that you, reader, which you might already know from other contexts, such as LINQ. That means until the first instance of a DI Object is requested, nothing gets created.</p>
<p>So, even if we don't do anything (useful) with these classes, once the <kbd>DependencyClass1</kbd> is requested, the entire dependency injection mechanism is started.</p>
<p>The following code is modified in the class <kbd>Program</kbd> class to configure this architecture:</p>
<pre>    static void Main(string[] args) 
    { 
      Console.WriteLine("Dependency Injection Demo"); 
      Console.WriteLine("Basic use of the Microsoft.Extensions.<br/>          DependencyInjection Library"); 
      Console.WriteLine("--------------------------------------<br/>          ---------------------------"); 
      var services = new ServiceCollection(); 
      services.AddTransient&lt;DependencyClass2&gt;(); 
      services.AddTransient&lt;DependencyClass1&gt;(); 
      var provider = services.BuildServiceProvider(); 
      using (var DC1Instance = provider.GetService&lt;DependencyClass1&gt;()) 
      { 
        // Merely by declaring DC1Instance 
        // everything gets launched, but we also call 
        // CurrentTime() just to check functionality 
        DC1Instance.CurrentTime(); 
        // Notice also how classes are properly disposed 
        // after used. 
      } 
      Console.ReadLine(); 
    } </pre>
<p>As you can see in the following output, everything works as expected:</p>
<div><img height="211" width="610" class=" image-border" src="img/b31ea530-6e2e-4210-bb84-25a5dc0278c6.png"/></div>
<p>The code shows how whenever we need an instance of a class, we issue a call to the generic <kbd>GetService()</kbd> method and we can start using it in the next sentence.</p>
<p>Another aspect to notice is that the reference to <kbd>DependencyClass2</kbd> goes first, and so it does its disposal. Remember that the constructor of <kbd>DependencyClass1</kbd> receives an instance of <kbd>DependencyClass2</kbd>, so, it doesn't finish until the latter is totally created.</p>
<p>Also, before disposing of the first class, we call on <kbd>Dispose</kbd> of the second, that's why the order is inverted.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Checking the object's lifetime</h1>
                
            
            
                
<p>Another important aspect of this architecture that we should consider carefully, is the way our instances are obtained from the point of view of its lifetime. Let's see the differences in this very demo, adding references and changing the way they are registered into the <kbd>IServiceProvider</kbd> class.</p>
<p>What happens if we create another instance of the first class? As expected, when we change the <kbd>using</kbd> block of code to include another instance of <kbd>DependencyClass1</kbd>, such as in the following code:</p>
<pre>    using (var DC1Instance = provider.<br/>         GetService&lt;DependencyClass1&gt;()) 
    { 
      // Merely by declaring DependencyClass1  
      // everything gets launched, but we also call 
      // CurrentTime() just to check functionality 
      DC1Instance.CurrentTime(); 
      // Notice also how classes are properly disposed 
      // after used. 
      var DC1Instance2 = provider.GetService&lt;DependencyClass1&gt;(); 
      DC1Instance2.CurrentTime(); 
    } </pre>
<p>The output changes noticeably since we're forcing the engine to create a new instance, instead of reusing the previous one:</p>
<div><img height="235" width="567" class=" image-border" src="img/71199e7d-4332-42c9-8a8b-bdf7818bd845.png"/></div>
<p>As seen in the preceding screenshot, we're making the DI engine call the constructor twice, because we're using the <kbd>AddTransient()</kbd> version of the <kbd>services</kbd> configuration object.</p>
<p>However, in this scenario, if we change the registration method for <kbd>AddScoped</kbd> of <kbd>AddSingleton</kbd>, we would be reusing the same instance of the objects, and therefore, saving memory and resources.</p>
<p>For instance, by just changing those two lines of code in this manner:</p>
<pre>    services.AddScoped&lt;DependencyClass2&gt;(); 
    services.AddScoped&lt;DependencyClass1&gt;(); </pre>
<p>We can check the different creation behavior with a simple look at the corresponding output:</p>
<div><img height="258" width="652" class=" image-border" src="img/375fd621-ba77-41e2-93b5-ac9f6ca12f07.png"/></div>
<p>As you can see, the <kbd>CurrentTime</kbd> function is still called twice, but the number of instances in use is only one.</p>
<p>And, in this case, we would get exactly the same output using the <kbd>AddSingleton&lt;&gt;()</kbd> methods, since, in this scenario, there is a coincidence and no more than one instance is going to be used.</p>
<p>Another interesting aspect of the functionality provided by this service is that being a generic collection itself, it is possible to add/remove/clear instances of services at runtime, so we can always have total control of what it is inside the collection and the order in which is defined and instantiated.</p>
<p>To that purpose, we find methods such as <kbd>Clear()</kbd>, <kbd>Contains()</kbd>, <kbd>IndexOf()</kbd>, <kbd>Insert()</kbd>, <kbd>InsertAt()</kbd>, <kbd>Remove</kbd> and <kbd>RemoveAt()</kbd>, just like we would find in any other generic collection.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Mapping interfaces to instance classes</h1>
                
            
            
                
<p>The previous demo is simple enough to understand the basics of DI inside the <kbd>Microsoft.Extensions.DependencyInjection</kbd> library, but, most likely, in a real application, you will have some interfaces defined and a series of classes that implement those interfaces.</p>
<p>In such a case, it is more convenient to be able to map interfaces to classes that implement them, so you just have to ask for an implementation of the corresponding interface, thinking on the functionality the interface provides (the business problem to be solved), rather than in the concrete class that implements it.</p>
<p>Another advantage is that we're able to change the definitions at runtime (remember, it's a collection where we can add/remove items), so it is perfectly possible to redefine any previous mapping to a new one, according to our applications' needs.</p>
<p>As in the preceding demo, we're using a very simple approach to see this in action. I've created two interfaces, and two classes that implement them, with a single method that writes a basic message to the <kbd>Console</kbd>. This is the initial code:</p>
<pre>    public interface IXMLWriter 
    { 
      void WriteXML(); 
    } 
    public interface IJSONWriter 
    { 
      void WriteJSON(); 
    } 
    public class XMLWriter : IXMLWriter 
    { 
      public void WriteXML() 
      { 
        Console.WriteLine("&lt;message&gt;Writing in XML Format&lt;/message&gt;"); 
      } 
    } 
    public class JSONWriter : IJSONWriter 
    { 
      public void WriteJSON() 
      { 
        Console.WriteLine("{'message': 'Writing in JSON Format'}"); 
      } 
    } </pre>
<p>There is a correspondence between classes and interfaces, so we can now refer to the interface and let the DI engine decide which class instance is returned to us. This is quite similar to the demos we saw in the previous chapter when using third-party DI containers.</p>
<p>With that purpose, the <kbd>ServiceCollection</kbd> class supports an alternative way of defining references in which you can pass (generic signature) an interface name and the class that maps such interface when a <kbd>GetService&lt;Interface&gt;()</kbd> is called.</p>
<p>At the time of requesting one of these implementations, we will ask for an instance of the predefined interface, rather than a concrete class.</p>
<p>Note that we also have an alternative way to ask for a service by means of the <kbd>GetRequiredService&lt;Interface&gt;()</kbd> method, that throws an exception if the service type isn't registered.</p>
<p>Assuming this change, the implementation of the demo is quite simple:</p>
<pre>    static void Main(string[] args) 
    { 
      var services = new ServiceCollection(); 
      services.AddTransient&lt;IXMLWriter, XMLWriter&gt;(); 
      services.AddTransient&lt;IJSONWriter, JSONWriter&gt;(); 
      var provider = services.BuildServiceProvider(); 
      Console.WriteLine("Dependency Injection Demo (2)"); 
      Console.WriteLine("Mapping Interfaces to instance classes"); 
      Console.WriteLine("--------------------------------------"); 
      Console.WriteLine("Please, select message format <br/>          (1):XML // (2):JSON"); 
       var res = Console.ReadLine(); 
      if (res == "1") 
      { 
        var XMLInstance = provider.GetService&lt;IXMLWriter&gt;(); 
        XMLInstance.WriteXML(); 
      } 
      else 
      { 
         var JSONInstance = provider.GetService&lt;IJSONWriter&gt;(); 
         JSONInstance.WriteJSON(); 
      } 
      Console.ReadLine(); 
    } </pre>
<p>Unlike the previous case, we don't ask for a given class, but the class implements the required interface.</p>
<p>The output is, again, as expected (see the following screenshot):</p>
<div><img height="205" width="506" class=" image-border" src="img/8eb2f516-7118-402d-a140-fc036cdb5850.png"/></div>
<p>Notice that the registration works in a similar way to what we already saw in other DI containers. That is, if we use this syntax, that latest registered mapping is the one returned, although that can be changed dynamically.</p>
<p>Another very useful feature is the <kbd>GetServices&lt;Interface&gt;</kbd> method, since it allows us to recover all registered services and invoke them at will.</p>
<p>We can prove this by adding a couple of new classes that implement the same interfaces and register them together with the previous ones:</p>
<pre>    public class XMLWriter2 : IXMLWriter 
    { 
      public void WriteXML() 
      { 
        Console.WriteLine("&lt;message&gt;Writing in XML Format (2)&lt;/message&gt;"); 
      } 
    } 
    public class JSONWriter2 : IJSONWriter 
    { 
      public void WriteJSON() 
      { 
        Console.WriteLine("{'message': 'Writing in JSON Format (2)'}"); 
      } 
   } </pre>
<p>After these definitions, we register both classes under the same Interface contracts, so they can be accessed altogether:</p>
<pre>    services.AddTransient&lt;IXMLWriter, XMLWriter&gt;(); 
    services.AddTransient&lt;IXMLWriter, XMLWriter2&gt;(); 
    services.AddTransient&lt;IJSONWriter, JSONWriter&gt;(); 
    services.AddTransient&lt;IJSONWriter, JSONWriter2&gt;(); 
    Now we can use a whole collection by asking for it by means of the <br/>       GetServices&lt;Interface&gt;() method that I mentioned above: 
    var registeredXMLServices = provider.GetServices&lt;IXMLWriter&gt;(); 
    foreach (var svc in registeredXMLServices) 
    { 
      svc.WriteXML(); 
    } </pre>
<p>Since we're using the defined interface functionality, we know all of them will implement the <kbd>WriteXML()</kbd> function, even if they do it differently.</p>
<p>You can appreciate the different calls in the corresponding output:</p>
<div><img height="165" width="449" class=" image-border" src="img/bf46316e-d5cd-4b7f-ba67-9aa2e14c886d.png"/></div>
<p>Another alternative way to get the whole list of services is, of course, from the <kbd>services</kbd> collection itself. To perform this, we need another helper class also provided by the <kbd>Microsoft.Extensions.DependencyInjection</kbd> library.</p>
<p>In this case, the procedure is to create a <kbd>ServiceDescriptor</kbd> collection that holds the information of all services in our <kbd>ServiceCollection</kbd> class. We use an enumerator and the <kbd>CopyTo()</kbd> method (which expects a <kbd>ServiceCollection</kbd> as the first argument) to create such a collection:</p>
<pre>    var myServiceArray = new ServiceDescriptor[services.Count]; 
    // Copy the services into an array. 
    services.CopyTo(myServiceArray, 0); 
    IEnumerator myEnumerator = myServiceArray.GetEnumerator(); 
    Console.WriteLine("The Implementation Types in the array are"); 
    while (myEnumerator.MoveNext()) 
    { 
      var myService1 = (ServiceDescriptor)myEnumerator.Current; 
      Console.WriteLine(myService1.ImplementationType); 
    } </pre>
<p>When the collection is copied to the <kbd>ServiceDescriptor</kbd> collection, we can see at least five interesting properties that might, later on, be used to determine the service we need in a given scenario:</p>
<div><img height="176" width="613" class=" image-border" src="img/f6b2b26e-c182-48c3-8ab1-81c0b127b75e.png"/></div>
<p>Notice that here we're asking for the <kbd>ImplementationType</kbd> property to obtain all defined types:</p>
<div><img height="177" width="399" class=" image-border" src="img/99b1f3a4-c3c8-418d-81de-acb1b0149376.png"/></div>
<p>This gives us a clue on how to select a single service independently of its position in the collection. Another helper method linked to this functionality is the simple <kbd>Contains()</kbd> that asks for a <kbd>ServiceDescriptor</kbd> object as its unique argument.</p>
<p>Another easy way to get information about the currently registered components in our services container is by iterating through it directly, using a simple <kbd>foreach</kbd> loop:</p>
<pre>    //Description of properties in the service collection  
    foreach (var svc in services) 
    { 
      Console.WriteLine($"Type: {svc.ImplementationType} \n" + 
         $"Lifetime: {svc.Lifetime} \n" + 
         $"Service Type: {svc.ServiceType}"); 
    } </pre>
<p>Notice that depending on the way the services are registered and other programming features, not all the properties will have a value (in this case, it only makes sense asking for the interfaces (<kbd>ServiceType</kbd>), the implementations (<kbd>Types</kbd>) and their lifetimes).</p>
<p>This is also useful when we have more than a class that implements the same interface, because we can decide which one we need based on these values:</p>
<div><img height="294" width="413" class=" image-border" src="img/76036b1f-e60a-49f7-b72d-93e854a66e4c.png"/></div>
<p>Additionally, it's possible to use some helper classes linked to the namespaces here implied, to perform registrations <kbd>a posteriori</kbd>. For instance, the <kbd>ServiceProviderServiceExtensions</kbd> class contains a static method capable of obtaining a given <kbd>ServiceType</kbd> linked to a certain provider.</p>
<p>In other words, you can get an instance of a registered service without using the <kbd>ServiceCollection</kbd> that registered it, as long as you can pass the corresponding provider as an argument.</p>
<p>I've created a variant of the previous demo, this time including a read-only property in each of the <kbd>*writer</kbd> classes to hold a unique identifier (a <kbd>GUID</kbd>), so it is easy to determine if we're using the same or another instance of the service.</p>
<p>Consider the following code (a variant of the previous demo):</p>
<pre>    static void Main(string[] args) 
    { 
      var services = new ServiceCollection(); 
      services.AddSingleton&lt;IXMLWriter, XMLWriter&gt;(); 
      var provider = services.BuildServiceProvider(); 
      Console.WriteLine("Dependency Injection Demo (3)"); 
      Console.WriteLine("Choice between implementations"); 
      Console.WriteLine("------------------------------"); 
      // Instance via services class 
      var XMLInstance = provider.GetService&lt;IXMLWriter&gt;(); 
      XMLInstance.WriteXML(); 
      // Instance via ServiceProviderServiceExtensions 
      var XMLInstance2 = ServiceProviderServiceExtensions. 
                       GetService&lt;IXMLWriter&gt;(provider); 
      XMLInstance2.WriteXML();     
      Console.ReadLine(); 
    } </pre>
<p>As you can see, we're using two distinct approaches to get the same instance (identified by its <kbd>GUID</kbd>). We can test it by comparing both outputs (see the following screenshot):</p>
<div><img height="203" width="452" class=" image-border" src="img/76e66637-4315-42cd-b072-4ebfcd7403b3.png"/></div>
<p>This could be especially useful in situations in which, for whatever reason, a call to services is not suitable or convenient.</p>
<p>Providers can also be obtained via helper classes, besides the <kbd>BuildServiceProvider</kbd> method of <kbd>ServiceCollection</kbd>. To do so, we can use the <kbd>CreateDefaultServiceProvider</kbd> class, which also has instance methods to create, either a provider or a <kbd>Builder</kbd>.</p>
<p>For the time being, those two are the only possibilities available to that class, but it can also be quite useful in certain scenarios where we prefer the service collection not to be used:</p>
<div><img height="138" width="661" class=" image-border" src="img/be316783-9b1c-4f05-af4f-579fb1b2ed8e.png"/></div>
<p>The following code has the provider created via the <kbd>DefaultServiceProvider</kbd> class:</p>
<pre>    var services = new ServiceCollection(); 
    services.AddSingleton&lt;IXMLWriter, XMLWriter&gt;(); 
    // Provider via DefaultServiceProviderFactory 
    var factory = new DefaultServiceProviderFactory(); 
    IServiceProvider prov = factory.CreateServiceProvider(services); 
    var XMLInstance = prov.GetService&lt;IXMLWriter&gt;(); 
    XMLInstance.WriteXML(); </pre>
<p>I omit the output here, since it's exactly the same as in the previous demos, and you can check it yourself within the code accompanying this chapter.</p>
<p>This is not the only way in which we can obtain a service provider. Yes, there's another one, linked to the static method <kbd>BuildServiceProvider</kbd> of the <kbd>ServiceCollectionContainerBuilderExtensions</kbd> class.</p>
<p>In this case, programming it is even easier, since we don't need any instance of the class, and the code gets reduced to the following code:</p>
<pre>    var services = new ServiceCollection(); 
    services.AddSingleton&lt;IXMLWriter, XMLWriter&gt;(); 
    // Provider via ServiceCollectionContainerBuilderExtensions 
    IServiceProvider prov = ServiceCollectionContainerBuilderExtensions. 
        BuildServiceProvider(services); 
    var XMLInstance = prov.GetService&lt;IXMLWriter&gt;(); 
    XMLInstance.WriteXML(); </pre>
<p>Just to get exactly the same results as we did before (again, I omit the output).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The concept of Scope Applied to services</h1>
                
            
            
                
<p>When dealing with services and other DI-related functionality, an important point to define is its scope. DI documentation defines the scope of a service closely related to its lifetime, and therefore, with the moment in which that service should be disposed of by the Garbage Collector.</p>
<p>We have talked about the Transient and Singleton lifetimes previously, but the Scope lifetime is, indeed, a bit more confusing.</p>
<p>Concretely, the <kbd>IServiceDispose</kbd> interface, which implements the <kbd>IDispose</kbd> interface, holds the method <kbd>Disposed of()</kbd>, method which, when called, ends the scope lifetime. It is included inside the <kbd>Microsoft.Extensions.DependencyInjection.Abstractions.dll</kbd>.</p>
<p>In more detail, the documentation states: "<em>Once this is disposed of, any scoped services that have been resolved from the</em> <em>M</em><em>icrosoft.Extensions.DependencyInjection.IServiceScope.ServiceProvider will also be disposed of"</em>.</p>
<p>Its declaration is as follows:</p>
<pre>    public interface IServiceScope : IDisposable </pre>
<p>If you remember in the first demos of this chapter, our <kbd>DependencyClass1</kbd> and <kbd>DependencyClass2</kbd> classes implemented the <kbd>IDisposable</kbd> interface, so we could call those methods after the classes' main operations were finished.</p>
<p>As we'll see in <a href="06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml" target="_blank">Chapter 4</a>, <em>Dependency Injection in ASP.NET Core,</em> this concept adapts especially well to some internet applications' scenarios in which it makes a lot of sense to have a specific control for the lifetime of some services, and always have access to the execution context in the form of an instance class.</p>
<p>In <a href="06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml" target="_blank">Chapter 4</a>, <em>Dependency Injection in ASP.NET Core</em>, you'll see that this feature can be important to face performance issues, resources of the server, scalability issues, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Other extensions with DI functionality</h1>
                
            
            
                
<p>Linked to the <kbd>Microsoft.Extensions</kbd> global namespace, we find related namespaces that are becoming popular among developers, because they help in different areas of the application's lifecycle.</p>
<p>Two of the most used are <kbd>Microsoft.Extensions.Logging</kbd> and <kbd>Microsoft.Extensions.Logging.Console</kbd>, which you can use to configure and code logging services using the techniques of Dependency Injection that we've seen in this chapter. They offer functionality similar to other popular frameworks, such as Serilog, Log4Net or NLog.</p>
<p>I'm talking about <kbd>ILoggerFactory</kbd> and <kbd>ILogger&lt;T&gt;</kbd>, mainly used (especially in ASP.NET Core apps) to emit information at runtime, with the ability to redirect that information to different targets (console, output window, and so on).</p>
<p>But they can also be used to monitor and debug applications in .NET Core, and, even not offering the whole set of resources we find in those, more specialized, frameworks, they can be, many times, enough to cover our needs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A reflection on the structure of .NET Core</h1>
                
            
            
                
<p>It's quite interesting to see how .NET Core creators have designed this technology based on the Dependency Injection principles. That's why, besides its value as a tool for the developer, we can see the extra value of seeing DI really implemented by default in .NET Core libraries.</p>
<p>Both classes are available inside the <kbd>Microsoft.Extensions.Logging</kbd> namespace, but other complementary namespaces, such as <kbd>Microsoft.Extensions.Logging.Console</kbd> and <kbd>Microsoft.Extensions.Logging.Debug</kbd>, also permit extended logging functionality that we'll use in the next demo. They can be easily referenced via NuGet packages, as we did before.</p>
<p>To keep on demoing things with the simplest possible code, I'll use a simplified version of the previous demo, only this time using a single external class <kbd>XMLWriter</kbd> and its corresponding interface, with slight changes.</p>
<p>Just like with the <kbd>DependencyInjection</kbd> namespace, <kbd>Microsoft.Extensions.Logging</kbd> appears next to <kbd>Configuration</kbd> and <kbd>Dependency</kbd> libraries when filtering for this criterion in the Search box (notice that we'll need a total of four extra libraries, including <kbd>Logging.Console</kbd> and <kbd>Logging.Debug</kbd>):</p>
<div><img height="294" width="660" class=" image-border" src="img/1db817ef-3a61-47fd-a814-8191e9bc8896.png"/></div>
<p>After installing those libraries, if you're curious about these API's possibilities, you can also inspect the references that will show up in the <kbd>Solution Explorer</kbd>, next to the NuGet references' entry.</p>
<p>The functionality provided by these logging services include the ability to write to the <kbd>Console</kbd>, using distinct types of messages (depending on the nature of the output: debug, information, warning, or error) and using several colors and formats to express these categories.</p>
<p>Mark Michaelis clearly explains in his MSDN article <em>Essential .NET - Dependency Injection with .NET Core</em> some of the advantages of these DI implementations that we find linked to .NET Core.</p>
<p>He points out that, when you want to switch between different implementations of some service and avoid hard-coding a reference to any service implementation, it is much more extensible and maintainable to ask for a factory of such instance, just like we did in other demos. The <kbd>ILoggerFactory</kbd> implements that functionality.</p>
<p>He goes even further, highlighting that: "<em>you ask for an interface (such as ILoggerFactory</em><em>) with the expectation that the service provider (in this case, NLog, Log4Net or Serilog) will implement the interface"</em>.</p>
<p>Thus, <kbd>ILoggerFactory</kbd> is extensible even with third-party libraries! He also remarks that: "<em>the result is that while the client will directly reference the abstract assembly (Logging.Abstractions), defining the service interface, no references to the direct implementation will be needed"</em>.</p>
<p>Actually, you may have noticed that the <kbd>ServiceCollection</kbd> itself owns a method called <kbd>AddLogging()</kbd>, which is a convenient method to activate logging functionality for the collection. This call is really translated to an internal registry of the <kbd>ILoggerFactory</kbd> service as part of the services collection we are configuring.</p>
<p>Considering that we can also concatenate calls to configure our service collections, let's see the first part of our new <kbd>Main()</kbd> method, including that call:</p>
<pre>    // Enabling logging with the ServiceCollection 
    var services = new ServiceCollection() 
      .AddSingleton&lt;IXMLWriter, XMLWriter&gt;() 
      .AddLogging(); 
   var serviceProvider = services.BuildServiceProvider(); </pre>
<p>Consequently, we enable logging inside the <kbd>ServiceCollection</kbd> via <kbd>AddLogging()</kbd>. So, what happened? Let's check the new members that our collection now has, by iterating through the resulting services object, like in a previous demo:</p>
<pre>    // Test the register of AddLoggin() 
    foreach (var svc in services) 
   { 
      Console.WriteLine($"Type: {svc.ImplementationType} \n" + 
        $"Lifetime: {svc.Lifetime} \n" + 
        $"Service Type: {svc.ServiceType}"); 
   } </pre>
<p>We'll obtain a collection containing three services (see the following output), because the <kbd>AddLogging()</kbd> method has, indeed, registered a <kbd>LoggingFactory</kbd> class with the <kbd>ILoggingFactory</kbd> interface, and another generic one, <kbd>ILogger&lt;&gt;</kbd>. That <kbd>ILogger&lt;&gt;</kbd> class will later be configured to provide any other class with the ability to send logging messages to the console:</p>
<div><img height="194" width="597" class=" image-border" src="img/66c9e26a-bf30-486b-a816-6289e9dbd476.png"/></div>
<p>Therefore, the next step is to obtain an <kbd>ILoggerFactory</kbd> object and link that object to the <kbd>Console</kbd>, which we perform with a call to <kbd>AddConsole()</kbd> in this fashion:</p>
<pre>    //Obtain service and configure logging 
    serviceProvider.GetService&lt;ILoggerFactory&gt;() 
      .AddConsole(LogLevel.Debug); </pre>
<p>As you see, <kbd>AddConsole</kbd> expects some additional configuration in the form of an <kbd>enum</kbd> value of type <kbd>LogLevel</kbd>, which determines the minimum level of severity the runtime will filter when sending messages to the console--whenever the logging system receives an entry, it will ignore it if it is below that level.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">LogLevels Severity</h1>
                
            
            
                
<p>The <kbd>LogLevel</kbd> enumeration also establishes the priority of messages (pretty useful in case we want to distinguish low-level from high-level messages, and even redirect them to different output windows).</p>
<p>According to the official documentation these levels are organized as follows (it goes from least to highest severity):</p>
<ul>
<li><strong>Trace = 0</strong>: For information that is valuable only to a developer debugging an issue. These messages may contain sensitive application data and so should not be enabled in a production environment. Disabled by default. For example, credentials: <kbd>{"User":"someuser", "Password":"P@ssword"}</kbd></li>
<li><strong>Debug = 1</strong>: For information that has short-term usefulness during development and debugging. For example, entering the <kbd>Configure</kbd> method with fl the g set to true.</li>
<li><strong>Information = 2</strong>: For tracking the general flow of the application. These logs typically have some long-term value. For example, the request received for path <kbd>/</kbd><kbd>api/todo</kbd>.</li>
<li><strong>Warning = 3</strong>: For abnormal or unexpected events in the application flow. These may include errors or other conditions that do not cause the application to stop, but which may need to be investigated. Handled exceptions are a common place to use the warning log level. For example, <kbd>FileNotFoundException</kbd> for file <kbd>quotes.txt</kbd>.</li>
<li><strong>Error = 4</strong>: For errors and exceptions that cannot be handled. These messages indicate a failure in the current activity or operation (such as the current HTTP request), not an application-wide failure. For example, log message: <kbd>Cannot insert record due to duplicate key violation</kbd>.</li>
<li><strong>Critical = 5</strong>: For failures that require immediate attention. For example, data loss scenarios, out of disk space.</li>
</ul>
<p>The IDE also shows those levels through the IntelliSense services, together with an explanation of each purpose and functionality:</p>
<div><img height="170" width="556" class=" image-border" src="img/3f7d1638-39ba-41ce-9149-55c0adae1e7f.png"/></div>
<p>In this way, the returned <kbd>ILoggerFactory</kbd> service we get when asking for a reference will redirect any output to the console using the debug level configuration, if not instructed otherwise.</p>
<p>The <kbd>ILogger</kbd> and <kbd>ILoggerFactory</kbd> interfaces are located in <kbd>Microsoft.Extensions.Logging.Abstractions</kbd>, and default implementations of them are in <kbd>Microsoft.Extensions.Logging</kbd>.</p>
<p>Now, if we want both classes (<kbd>XMLWriter</kbd> and <kbd>Program</kbd>) to use these logging services, we need an <kbd>ILogger</kbd> instance for each one. We'll start creating one for <kbd>Program</kbd> and presenting a first set of messages in the console:</p>
<pre>    // Create a logger class from ILoggerFactory 
    // and print an initial set of messages. 
    var ILoggerService = serviceProvider.GetService&lt;ILoggerFactory&gt;(); 
    var logger = ILoggerService.CreateLogger&lt;Program&gt;(); </pre>
<p>Notice that the creation of the logger class implies calling the <kbd>CreateLogger&lt;Program&gt;()</kbd> generic method. Once instantiated, the logger has methods to declare different scopes, (marking the beginning and the end of each scope) and to send six different types of messages to the console, each one representing a different severity level:</p>
<pre>    logger.LogCritical("Critical format message from Program"); 
    logger.LogDebug("Debug format message from Program"); 
    logger.LogError("Error format message from Program"); 
    logger.LogInformation("Information format message from Program"); 
    logger.LogTrace("Trace format message from Program"); 
    logger.LogWarning("Warning format message from Program");  </pre>
<p>If we take a look at the output, we can appreciate the differences between those messages' formats:</p>
<div><img height="185" width="378" class=" image-border" src="img/606837b0-ae76-44ad-804d-dc8669814a7a.png"/></div>
<p>As you can see, the different messages' severity levels generate different formats in the output using distinct colors and prefixes to denote its <kbd>LogLevel</kbd> category. But, wait a minute! There's one missing (the <kbd>Trace</kbd> message).</p>
<p>Well, not quite. What happens is that the <kbd>Trace</kbd> <kbd>LogLevel</kbd> doesn't output to the console, and it is prepared to be used mainly in web applications in which the trace switch is enabled (we will see more on that in <a href="06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml" target="_blank">Chapter 4</a>, <em>Dependency Injection in ASP.NET Core</em>).</p>
<p>So, all that said, how can we use this architecture and logging services from our <kbd>XMLWriter</kbd> class? Let's change the implementation, so we use one of the DI patterns that we saw in the previous chapter--the constructor dependency model.</p>
<p>To use that model, we have to change our <kbd>XMLWriter</kbd> class a little to include a read-only property that holds the <kbd>ILogger&lt;&gt;</kbd> instance and assign its value in the class' constructor. So, the final format of our, this time, unique <kbd>XMLWriter</kbd> classes will be (the interface definition is not affected yet, so it's just the same as in previous demos):</p>
<pre>    public class XMLWriter : IXMLWriter 
    { 
      private readonly ILogger&lt;XMLWriter&gt; logger; 
      public XMLWriter(ILoggerFactory loggerFactory) 
      { 
        logger = loggerFactory.CreateLogger&lt;XMLWriter&gt;(); 
      } 
      public void WriteXML() 
      { 
        logger.LogInformation("&lt;message&gt;Writing in XML Format<br/>          (via Logger)&lt;/message&gt;"); 
      } 
    } </pre>
<p>The only thing remaining is to use the <kbd>logger</kbd> instead of the previous calls to <kbd>Console</kbd> and call one of the <kbd>Log*</kbd> methods to generate the intended output. And that's it.</p>
<p>We have totally replaced the functionality provided by the <kbd>Console</kbd> class with the logging services delivered by the <kbd>ILogginFactory</kbd> and <kbd>ILogger</kbd> objects, and we can also configure the severity level to generate distinct output formats.</p>
<p>So, with all that in mind, we end up with a final version of our <kbd>Main</kbd> method with this implementation:</p>
<pre>    static void Main(string[] args) 
    { 
      // Enabling logging in the ServiceCollection 
      // via AddLogging() 
      var services = new ServiceCollection() 
        .AddSingleton&lt;IXMLWriter, XMLWriter&gt;() 
        .AddLogging(); 
      var serviceProvider = services.BuildServiceProvider(); 
      //Obtain service and configure logging 
      serviceProvider.GetService&lt;ILoggerFactory&gt;() 
        .AddConsole(LogLevel.Debug); 
 
      // Create a logger class from ILoggerFactory 
      // and print all types of messages. 
      var ILoggerService = serviceProvider.GetService&lt;ILoggerFactory&gt;(); 
      var logger = ILoggerService.CreateLogger&lt;Program&gt;(); 
      logger.LogCritical("Critical format message from Program"); 
      logger.LogDebug("Debug format message from Program"); 
      logger.LogError("Error format message from Program"); 
      logger.LogInformation("Information format message from Program"); 
      logger.LogTrace("Trace format message from Program"); 
      logger.LogWarning("Warning format message from Program"); 
 
      //Instantiation of XMLInstance 
      var XMLInstance = serviceProvider.GetService&lt;IXMLWriter&gt;(); 
      XMLInstance.WriteXML(); 
 
      logger.LogDebug("Process finished!"); 
      Console.Read(); 
    } </pre>
<p>As we can see in the final output (see the following screenshot), all messages are presented in the console in the same sequence they're invoked, using the predefined formats that .NET Core configures, and including our <kbd>XMLWriter</kbd> message:</p>
<div><img height="271" width="505" class=" image-border" src="img/1d65f85e-fa1c-4fc9-8e55-3a85320b9fdf.png"/></div>
<p>This is not all. We still have other options available that allow us to separate and filter the output message destination. This possibility is correlated to the <kbd>Microsoft.Extensions.Logging.Debug</kbd> library, which should also be referenced just like the others we're using here.</p>
<p>One of the features included in this library is the <kbd>AddDebug()</kbd> method of <kbd>ILoggerFactory</kbd>. Once activated, it permits us to send messages to the Debug window, enabling a separation of messages conditional to its severity level, for instance.</p>
<p>To test this functionality, we'll make a few changes in our definitions of the <kbd>IXMLWriter</kbd> interface and update the implementation accordingly. Our new interface will have another method that also sends messages to the predefined output (which, in this case, will show up in several places at runtime):</p>
<pre>    public interface IXMLWriter 
    { 
        void WriteXML(); 
        void WriteXMLWithSeverityLevel(); 
    } </pre>
<p>So, the updated code of XMLWriter will be:</p>
<pre>    public class XMLWriter : IXMLWriter 
    { 
      private readonly ILogger&lt;XMLWriter&gt; logger; 
      public XMLWriter(ILoggerFactory loggerFactory) 
      { 
        loggerFactory.AddDebug().AddConsole(LogLevel.Information); 
        logger = loggerFactory.CreateLogger&lt;XMLWriter&gt;(); 
      } 
      public void WriteXML() 
      { 
        logger.LogDebug( 
            "&lt;msg&gt;First Message (LogDebug/SeverityLevel: <br/>                 Information)&lt;/msg&gt;"); 
      } 
      public void WriteXMLWithSeverityLevel() 
      { 
        logger.LogDebug( 
            "&lt;msg&gt;Second Message (LogDebug/SeverityLevel: <br/>                 Information&lt;/msg&gt;"); 
      } 
    } </pre>
<p>So, now we have two distinct methods to write messages. To test this functionality, we can configure the <kbd>ILoggerService</kbd> object in the <kbd>Main()</kbd> method (which, remember, is of type <kbd>ILoggerFactory</kbd>). Once the new namespace is loaded and available, we can write:</p>
<pre>    var ILoggerService = serviceProvider.GetService&lt;<br/>          ILoggerFactory&gt;(); 
    ILoggerService.AddDebug(); </pre>
<p>In this manner, we allow sending messages to the <kbd>Debug</kbd> or <kbd>Output</kbd> windows, either for console or web applications.</p>
<p>It's easy to test different options, changing the types of severity levels used in the calls to this method, and the already existing ones. For example, we can make a call to <kbd>WriteXMLWithSeverityLevel()</kbd> and observe the two outputs (now we have two), that are generated during execution:</p>
<pre>    //Instantiation of XMLInstance 
    var XMLInstance = serviceProvider.GetService&lt;IXMLWriter&gt;(); 
    XMLInstance.WriteXML(); 
    XMLInstance.WriteXMLWithSeverityLevel(); </pre>
<p>On one side, the output now presents the new message (nothing unexpected):</p>
<div><img height="308" width="594" class=" image-border" src="img/324caea3-87c7-41a9-9eb7-285ad3cf41e7.png"/></div>
<p>But, now, we have more messages. If we take a look at the <kbd>Output</kbd> window, we'll see the new entries depending on the <kbd>LogLevel</kbd> we configure--some of them will be presented, and others, ignored (as you can see, in this version, only the first four messages are replicated in the Output window, and all XMLWriter messages are ignored):</p>
<div><img height="149" width="600" class=" image-border" src="img/d33a0f69-0e87-4e06-ae02-edc6de0e2883.png"/></div>
<p>This is only a first approach to some of the services that adopt the DI architecture and that are available inside .NET Core. We will see much more on these implementations when dealing with ASP.NET Core coding, in <a href="06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml" target="_blank">Chapter 4</a>, <em>Dependency Injection in ASP.NET Core</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have made a first approach to how Dependency Injection technologies are supported and implemented in the current version of the .NET Core (2.0) and how we can use them, even outside of ASP.NET projects.</p>
<p>To summarize, we've seen the main characteristics of NET Core and its installation and usage from Visual Studio, especially focused on the latest version, Visual Studio 2017, together with the distinct types of deployment linked to this version of the framework, along with the main features and functionality included in the namespaces related to DI and, especially, inside the <kbd>Microsoft.Extensions.DependencyInjection</kbd> and <kbd>Microsoft.Extensions.Logging</kbd> containers.</p>
<p>We've also analyzed the classes and interfaces related to this architecture, together with its implementation through a bunch of samples, ending with some real implementations, that are already part of .NET Core 2.0, such as the logging services, and how to use them, from any class.</p>
<p>In <a href="06d5c629-d866-4319-b2d3-1a5120d1f6d2.xhtml" target="_blank">Chapter 4</a>, <em>Dependency Injection in ASP.NET Core</em>, our approach will be more real, since it deals with web applications and how the new architecture and configuration of websites manage these new concepts, such as middleware and services configuration, in which DI plays an important role since the very beginning.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </body></html>