- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Simplifying Containers and Kubernetes: Azure Container Apps, and Othert Tools'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Kubernetes is probably the most complete orchestrator, any transition
    from monolithic development to microservices on Kubernetes faces two hard difficulties.
  prefs: []
  type: TYPE_NORMAL
- en: The first difficulty is that the cost of a Kubernetes cluster often is not justified
    by the initial low traffic of the application. In fact, a production-grade Kubernetes
    cluster typically requires multiple nodes for redundancy and reliability. While
    self-managed clusters may need at least two master nodes and three worker nodes,
    managed Kubernetes services such as **Amazon Elastic Kubernetes Service** (**Amazon
    EKS**), **Azure Kubernetes Service** (**AKS**), or **Google Kubernetes Engine**
    (**GKE**) often handle control plane redundancy at a lower cost (Amazon EKS control
    plane costs ~$72/month). Teams can start with smaller instance types and scale
    as needed, reducing the initial burden.
  prefs: []
  type: TYPE_NORMAL
- en: Another difficulty is the learning curve of Kubernetes itself. Moving the whole
    team to discrete Kubernetes knowledge/expertise might require time that we simply
    don’t have. Moreover, if we are transitioning an existing monolithic application,
    at the beginning of the transition—when the number of microservices is still low
    and their organization still resembles the same organization of the monolithic
    application—we simply don’t need all the opportunities and options offered by
    Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding considerations led to the conception of **Azure Container Apps**,
    which is a serverless alternative to Kubernetes. Being a serverless option, you
    pay just for what you use and overcome the problem of the initial cluster size
    threshold. **Azure Container Apps** also lowers the learning curve thanks to the
    following features:'
  prefs: []
  type: TYPE_NORMAL
- en: While Kubernetes offers all the building blocks for coding both tools and microservices,
    **Azure Container Apps** building blocks are the microservices themselves, so
    the developer can remain focused on the business logic without spending too much
    time on technical details. Tools such as storage solutions, message brokers, and
    other performance and security tools are taken from the hosting platform—that
    is, Azure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are acceptable defaults for everything, so deploying an application may
    become as simple as deciding on the Docker images to deploy. Customizations can
    also be specified at a later time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a short description of the various tools used to simplify the usage and
    administration of Kubernetes clusters, this chapter describes **Azure Container
    Apps** in detail and how to use it in practice. This chapter relies on preexisting
    knowledge of Kubernetes, so please read it after having studied [*Chapter 8*](Chapter_8.xhtml#_idTextAnchor205),
    *Practical Microservices Organization with Kubernetes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, this chapter covers the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Tools for simplifying Kubernetes cluster usage and administration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Container Apps** basics and plans'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying your microservice application with **Azure Container Apps**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 free *Community Edition*, at least.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Azure CLI. Links for both the 32-bit and 64-bit Windows installers can be found
    at[https://learn.microsoft.com/bs-latn-ba/cli/azure/install-azure-cli-windows?tabs=azure-cli](https://learn.microsoft.com/bs-latn-ba/cli/azure/install-azure-cli-windows?tabs=azure-cli)**.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An Azure subscription.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: minikube and kubectl. Please refer to the *Technical requirements* section of
    [*Chapter 8*](Chapter_8.xhtml#_idTextAnchor205), *Practical Microservices Organization
    with Kubernetes*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tools for simplifying Kubernetes clusters usage and administration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the success of Kubernetes, a lot of products, services and open sources
    connected with it appeared. In this section, we classify them and provide some
    relevant examples. The whole offering related to Kubernetes can be classified
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Tools for packaging libraries and applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubernetes graphic UIs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Administrative tools for taking and presenting various cluster metrics, handling
    alarms, and performing administrative actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tools for handling the whole development and deployment of microservices-based
    applications that include Kubernetes as their target deployment platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Programming environments built on top of Kubernetes. These include both vertical
    applications, such as machine learning and big data tools, and general-purpose
    programming environments, such as Azure Container Apps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When it comes to packaging tools, the most relevant is **Helm**, which became
    a de facto standard for packaging Kubernetes applications and libraries. We will
    analyze it in a dedicated subsection next.
  prefs: []
  type: TYPE_NORMAL
- en: Helm and Helm charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Helm** is a package manager, and the packages it manages are called **Helm
    charts**. Helm charts are a way to organize the installation of complex Kubernetes
    applications that contain several `.yaml` files. A Helm chart is a set of `.yaml`
    files organized into folders and subfolders. Here is a typical folder structure
    of a Helm chart taken from the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: Folder structure of a Helm chart](img/B31916_09_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Folder structure of a Helm chart'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.yaml` files specific to the application are placed in the top `templates`
    directory, while the `charts` directory may contain other Helm charts used as
    helper libraries. The top-level `Chart.yaml` file contains general information
    about the package (name and description), together with both the application version
    and the Helm chart version. The following is a typical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, `type` can be either `application` or `library`. Only `application` charts
    can be deployed, while `library` charts are utilities for developing other charts.
    `library` charts are placed in the `charts` folder of other Helm charts.
  prefs: []
  type: TYPE_NORMAL
- en: In order to configure each specific application installation, Helm chart `.yaml`
    files contain variables that are specified when Helm charts are installed. Moreover,
    Helm charts also provide a simple templating language that allows some declarations
    to be included only if some conditions depending on the input variables are satisfied.
    The top-level `values.yaml` file declares default values for the input variables,
    meaning that the developer needs to specify just a few variables for which they
    require different values from the defaults. We will not describe the Helm chart
    templates language because it would be too extensive, but you can find it in the
    official Helm documentation referred to in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Helm charts are usually organized in public or private repositories in a way
    that is similar to Docker images. There is a Helm client, which you can use to
    download packages from a remote repository and install charts in Kubernetes clusters.
    The Helm client can be installed on any machine with a kubectl installation through
    the Chocolatey package manager, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In turn, you may find the Chocolatey installation procedure in the *Technical
    requirements* section of[*Chapter 8*](Chapter_8.xhtml#_idTextAnchor205), *Practical
    Microservices Organization with Kubernetes*. Helm operates with the current kubectl
    Kubernetes cluster and user.
  prefs: []
  type: TYPE_NORMAL
- en: 'A remote repository must be added before using its packages, as shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command makes the package information of a remote repository available
    locally and gives a local name to that remote repository. The information about
    all charts available in one or more repositories can be refreshed with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If no repository name is specified, all local repositories are updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, any package from the remote repository can be installed with a
    command such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `<namespace>` is the Kubernetes namespace where to install the application.
    As usual, if it’s not provided, the `default` namespace is assumed. `<package
    name>` is the name of the package you would like to install, and finally, `<instance
    name>` is the name that you give to the installed application. You need this name
    to get information about the installed application with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get also information about all applications installed with Helm with
    the help of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The application name is also needed to delete the application from the cluster
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When we install an application, we may also provide a `.yaml` file with all
    the default variable values we want to override. We can also specify a specific
    version of the Helm chart; otherwise, the most recent version is used. Here is
    an example with both the version and values overridden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, default value overrides can also be provided in line with the `--set`
    option, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also upgrade an existing installation with the `upgrade` command, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `upgrade` command may specify new value overrides with the `–f` option or
    with the `--set` option, and it can also specify the new version to install with
    `--version`. If no version is specified, the more recent version is installed.
  prefs: []
  type: TYPE_NORMAL
- en: More details on Helm can be found in the official documentation at [https://helm.sh/](https://helm.sh/).
    We will show how to use Helm in practice in the later subsection about Kubernetes
    administrative tools.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes graphic UIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are also tools that help the definition and deployment of Kubernetes resources
    through user-friendly graphic interfaces. Among them, it is worth mentioning ArgoCD
    and Rancher UI.
  prefs: []
  type: TYPE_NORMAL
- en: '**ArgoCD** handles a database of Kubernetes resources and automatically updates
    a Kubernetes cluster whenever the code that defines a resource changes. ArgoCD
    simplifies a lot of Kubernetes cluster handling but automatic re-deployment of
    resources may cause issues in production environments that require zero downtime.
    We will not describe ArgoCD here, but interested readers can find more details
    in the *Further reading* section.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rancher UI** enables users to interact with several Kubernetes clusters through
    a web-based UI. It has also tools for handling the whole development process,
    such as the definition of projects.'
  prefs: []
  type: TYPE_NORMAL
- en: The Rancher UI web application must be accessible from within each Kubernetes
    cluster it must handle, and requires the installation software inside each of
    the Kubernetes clusters that it must handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rancher UI can also be installed on a developer’s local machine, where it can
    be used to interact with minikube. The simplest way to perform a local installation
    is through Docker. Open a Linux shell and enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A few minutes after the installation is completed, Rancher UI is available at
    `https://localhost`. If you can’t access it, wait a minute and retry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the web interface appears for the first time, you need a temporary password.
    You can get this password with the following Linux command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the temporary password in the Rancher UI initial page, and press **Continue**.
    The new page that appears should propose a new definitive password for the admin
    user, and the URL to be used by minikube to access Rancher UI. Fill this page
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: Rancher initial settings](img/B31916_09_2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Rancher initial settings'
  prefs: []
  type: TYPE_NORMAL
- en: Accept the proposed password, copy it, and store it in a safe place. The `host.docker.internal`
    hostname enables minikube to connect with our machine localhost.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the dashboard, click the **Import Existing** button to start the process
    of connecting an existing cluster with Rancher UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: Importing an existing cluster](img/B31916_09_3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Importing an existing cluster'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the new page that appears, select the [Generic](https://www.Generic.com)
    cluster option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4: Generic cluster option](img/B31916_09_4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Generic cluster option'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill in just the cluster name and description on the page that appears, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B31916_09_5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Filling in the cluster information'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, click the **Create** button. A page with the code to run in your cluster
    should appear. You should select the second code option since the local Rancher
    installation uses a self-signed certificate, which should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this code must be executed in a Linux shell, and `kubectl` is installed
    only on Windows. Therefore, replace the preceding instruction with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Then, execute it in a Linux shell. It will create the `install.yaml` file that
    contains our Kubernetes code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can install Rancher on minikube. Ensure that minikube is running, open
    a Windows console, and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When the installation is complete, return to the dashboard; you should see
    the newly imported minikube cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6: Minikube cluster connected](img/B31916_09_6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: Minikube cluster connected'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the `minikube` link and enjoy the power of interacting with Minikube
    through a graphic UI! Here, you can see nodes, Pods, namespaces, and all types
    of Kubernetes resources, and can also define new resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have finished experimenting, stop minikube and the Rancher container
    in the Docker UI. If you don’t need to interact with minikube through Rancher
    anymore, just execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Kubernetes administrative tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each cloud provider offers administrative UIs together with the Kubernetes offering.
    These UIs include the possibility to perform actions on the cluster, such as inspecting
    Kubernetes resources, collecting various metrics, and both querying and plotting
    these metrics. We will analyze the administrative tools offered by Azure in more
    detail in [*Chapter 10*](Chapter_10.xhtml#_idTextAnchor297), *Security and Observability
    for Serverless and Microservices Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are also several tools offered by third parties and also several
    open source projects. Among the open source projects, it is worth mentioning the
    metrics collector called **Prometheus**, and the UI-based administrative console
    called **Grafana**. Usually, they are installed together and Prometheus works
    as a metrics source for Grafana. They can be installed on any Kubernetes cluster,
    including minikube.
  prefs: []
  type: TYPE_NORMAL
- en: A detailed description of these tools is beyond the purpose of the book, but
    since they are very common and are also a prerequisite for other tools, we will
    describe how to install them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to test these tools on minikube, you need a configuration
    with more memory, and some other custom settings, so the the best option is to
    define a new profile while starting minikube with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `--extra-config` option allows the configuration of various Kubernetes
    installation options. If you don’t use minikube, you must be sure that the Kubernetes
    cluster is configured with the options passed with `--extra-config` in the preceding
    instruction. These settings enable Webhooks on the controller manager that Prometheus
    uses to collect its metrics and change the IP addresses exposed by both the controller
    and scheduler on the master nodes to enforce compatibility with Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all these settings are fixed, we can install both Prometheus and Grafana
    with Helm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first two instructions add the repositories containing Prometheus and Grafana,
    respectively, and the third instruction updates all repository local directories.
    The third instruction installs Prometheus in the `monitoring` namespace, after
    having created this namespace, and finally, the last instruction installs Grafana
    in the same namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation, we can inspect the `monitoring` namespace to verify
    that all resources are ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, both the Prometheus and Grafana UIs can be accessed by port-forwarding
    adequate services. Remember to use a different console window for each port-forward
    service, since the console freezes while port-forwarding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, Prometheus will be available at [http://localhost:9090](http://localhost:9090)
    and Grafana at http://localhost:3000\. While Prometheus doesn’t require a login,
    the default user for Grafana is `admin` and the password must be extracted from
    a Kubernetes secret, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the string returned by the preceding command; we need to Base64-decode
    it to get the actual password. As usual, Base64-decoding can be performed by opening
    a Linux console and using the `base64` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once logged in to Grafana, we must declare Prometheus as its metrics data source.
    In the Grafana left menu, go to **Connections -> Data sources**, and then select
    **Add new data source**. In the page that appears, select **Prometheus**, as shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7: Selecting Prometheus as the data source](img/B31916_09_7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: Selecting Prometheus as the data source'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to configure Prometheus as the default data source and set the URL
    at which to retrieve all metrics to [http://prometheus-server:80](http://prometheus-server:80),
    which corresponds to the address and port of the same Prometheus service we have
    port-forwarded, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8: Prometheus settings](img/B31916_09_8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: Prometheus settings'
  prefs: []
  type: TYPE_NORMAL
- en: You can keep all the other default settings; just click the **Save and test**
    button. After that, click the **Dashboards** tab and import all proposed dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, go to **Dashboards** in the Grafana left menu and inspect all the imported
    dashboards by clicking their links:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9: Available dashboards](img/B31916_09_9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: Available dashboards'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click **new** and then **import**, you can import a dashboard from grafana.com.
    Just follow the `grafana.com/dashboards` link, select a dashboard, take its ID,
    and copy it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10: Importing a dashboard from grafana.com](img/B31916_09_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.10: Importing a dashboard from grafana.com'
  prefs: []
  type: TYPE_NORMAL
- en: You might be required to subscribe to get a dashboard ID. Subscription is free.
    The dashboard selection pages contain links to the documentation you might be
    interested in exploring.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you stop minikube with `minikube stop -p <profle name>`, minikube will be
    stopped but all your data will be saved, so you can continue experimenting with
    Grafana. If you want to uninstall Grafana and Prometheus, you can do it with Helm,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let’s close this section with the remaining tools.
  prefs: []
  type: TYPE_NORMAL
- en: Development environments based on Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Among the complete development platforms based on Kubernetes, it is worth mentioning
    **OpenShift** ([https://www.redhat.com/en/technologies/cloud-computing/openshift](https://www.redhat.com/en/technologies/cloud-computing/openshift)),
    which includes tools for the whole development process, including DevOps automation
    and cloud services.
  prefs: []
  type: TYPE_NORMAL
- en: OpenShift can be installed on-premises or it can be used as a PaaS service available
    in the main cloud services, Azure included ([https://azure.microsoft.com/it-it/products/openshift](https://azure.microsoft.com/it-it/products/openshift)).
  prefs: []
  type: TYPE_NORMAL
- en: Big data and machine learning frameworks use Kubernetes, but we will not discuss
    them since they are completely beyond the purpose of this book.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth mentioning simple code generators offered by some start-ups
    that create Kubernetes applications by combining containers with the help of graphic
    interfaces. Needless to say, similar tools are just aimed at creating low-cost
    applications. We will not describe them because the focus of the book is enterprise
    high-quality applications and, at the moment, there is neither an emerging general
    pattern nor an emerging specific framework.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, when it comes to higher-level abstraction alternatives to Kubernetes
    that are built on top of Kubernetes, at the time this book was written, the most
    relevant option is **Azure Container Apps,** which will be described in the remainder
    of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Container Apps basics and plans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Container Apps is available as a serverless offering with **consumption**
    plans but has also **dedicated** plans based on the horizontal scaling of virtual
    machines, called **workload profiles**. Some advanced features are available only
    with **workload profiles**. We will talk more about plans later on in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Kubernetes offers several kinds of independent building blocks, Azure
    Container Apps is based on just two kinds of building blocks: **applications/jobs**
    and **environments**.'
  prefs: []
  type: TYPE_NORMAL
- en: Applications map one-to-one with microservices, while jobs are useful for long-running
    tasks and will not be discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applications automatically handle replicas—that is, each application may have
    several identical replicas exactly like a Kubernetes Deployment. Applications
    support the same configuration options as Kubernetes Deployments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volume mounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Health probes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU and memory resources configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic log collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They also support communication configuration, secrets, and automatic scaling,
    but they are not defined as separate objects as in Kubernetes but inside the application
    configuration itself. Moreover, there is no equivalent of StatefulSets—that is,
    there is no way to implement sharding algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The rationale behind these choices is that the developer must map each microservice
    into a single resource instead of several coordinated resources, so they can concentrate
    mainly on business business logic without being overwhelmed by orchestrator-specific
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Coordination tools such as StatefulSets are simply omitted since they don’t
    include business logic but are just used for solving coordination and parallel
    update issues. In fact, StatefulSets are used mainly to implement tools such as
    storage engines and message brokers, so the basic idea is that the developer should
    use resources already available in the cloud instead of implementing customized
    solutions so they can concentrate all their efforts on the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Other resources, such as permissions, users, and roles, are taken from Azure,
    too. This way, your microservice application is smoothly integrated into the hosting
    cloud instead of being a self-contained deployment environment loosely coupled
    with the hosting cloud, such as Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up, we can say that Azure Container Apps simplifies the implementation
    of a microservice application at the price of decreasing its portability. Once
    you implement your application to run in Azure Container Apps and to use Azure
    cloud resources, the only option to migrate to another cloud is to rewrite the
    whole orchestrator-related code.
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, if containers are carefully designed, they are not lost in
    the case of migrations, but the whole logic around them is lost.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a big issue if your application is small and consists of a few microservices,
    but for big applications made of hundreds or thousands of microservices, a migration
    might imply an unacceptable cost both in terms of time and money.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, Azure Container Apps is a good option for small applications or when
    you plan to deploy your application on a single cloud (Azure) and when you don’t
    need too many customizations (custom tools, highly customized tools, complex custom
    distributed algorithms, and so on). This makes it a good entry point in the world
    of distributed computing when you start the conversion of a monolithic application.
  prefs: []
  type: TYPE_NORMAL
- en: The boundaries of a microservice application are defined by an **environment**.
    Inside each environment, all applications can freely interact, but you can also
    decide to expose some endpoints to the **outside world**. If you use a consumption
    plan, the outside world is necessarily the internet, but with workload profiles,
    you can bypass this limitation by associating a subnet of an existing Azure virtual
    network to your environment. In fact, in this case, the outside world would be
    the remainder of the virtual network.
  prefs: []
  type: TYPE_NORMAL
- en: There is no equivalent of Kubernetes ingresses for routing communications from
    a single environment entry point to all frontend microservices inside the environment,
    but you can implement a similar functionality by using an application as an API
    gateway (see the *Interfacing the external world* subsection of [*Chapter 2*](Chapter_2.xhtml#_idTextAnchor038),
    *Demystifying Microservices Applications*). For HTTP and HTTPS termination, you
    can configure any application for using HTTPS without the burden of creating and
    handling HTTPS certificates, since Azure will take care of this for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure illustrates what we said about applications and environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11: Azure Container Apps organization](img/B31916_09_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: Azure Container Apps organization'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take note of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Each environment can be defined as either consumption only or a workload profile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each environment can have profiles added to it. Consumption-only environments
    can only have the default consumption profile. Workload profile environments have
    the default consumption profile but can also have customizable workload profiles
    added. Profiles will be discussed more later on in this section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each application associated with the environment can specify which of the profiles
    associated with the environment to run on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each application is accessible with an `http://<application name>` URL from
    inside the environment. We can also decide that an application is not accessible
    with a direct link when we use a message broker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some applications can be configured for access from outside of the environment,
    in which case, they receive the `https://<application name>.<environment name>.<zone>.azurecontainerapps.io`
    URL. Here, `<zone>` is the Azure geographic zone where you defined your environment.
    *HTTP traffic must be passed on the usual 80 and 443 ports*. For pure TCP traffic,
    the developer can specify different ports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each environment has an associated virtual network. Only if the environment
    has a workload profile can you assign it a custom subnet of a virtual network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environments and applications can access any Azure resources if they are granted
    the necessary permissions or credentials.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The remainder of this section is organized into subsections that describe the
    following subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: Consumption-only and workload profiles
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Application versioning
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interacting with Azure Container Apps
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consumption-only and workload profiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Applications running in a consumption profile are billed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In a few words, the application is billed proportionally to its memory, CPU,
    and request consumption. The actual constants for the various countries are available
    here: [https://azure.microsoft.com/en-us/pricing/details/container-apps/.](https://azure.microsoft.com/en-us/pricing/details/container-apps/.
    )'
  prefs: []
  type: TYPE_NORMAL
- en: 'With workload profiles, you are billed according to the CPUs and gigabytes
    of each virtual machine in use and not for the CPU and memory allocated to the
    applications. Thus, for instance, notwithstanding you use just 10% of a profile
    virtual machine, you are billed for the overall virtual machine CPU and memory.
    However, for workload profiles, there is no billing quota corresponding to the
    application requests. There is also an hourly profile-handling cost to add to
    the overall cost of each profile. The actual constants for the various countries
    are available here: [https://azure.microsoft.com/en-us/pricing/details/container-apps/.](https://azure.microsoft.com/en-us/pricing/details/container-apps/.
    )'
  prefs: []
  type: TYPE_NORMAL
- en: Each profile can be used by several applications, and the number of virtual
    machines allocated to a profile is computed according to the CPU and memory requested
    by all applications that run in that profile. That is, a new virtual machine is
    allocated whenever the total CPU or memory requested by all applications exceeds
    the total CPUs and memory of the already allocated machines.
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, one can specify both a maximum number and a minimum number
    of machines allocated to each profile. Since allocating a new virtual machine
    requires time, it is advised to set the minimum number of instances to at least
    1; otherwise, the first requests after a period of inactivity would experience
    unacceptable response times.
  prefs: []
  type: TYPE_NORMAL
- en: The hourly CPU and memory costs of workload profiles are lower than the ones
    of consumption-only profiles but workload profiles have an hourly management cost.
    Workload profiles become convenient when the average workload exceeds 3–4 CPUs
    with 16 GB of memory. However, certain features are only available with workload
    profiles. For instance, you need a workload profile if you want to customize the
    virtual network underlying your environment by adding firewalls, or by using a
    subnet of another virtual network.
  prefs: []
  type: TYPE_NORMAL
- en: 'All available workload profile types are listed on this page: [https://learn.microsoft.com/en-us/azure/container-apps/workload-profiles-overview](https://learn.microsoft.com/en-us/azure/container-apps/workload-profiles-overview).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move on to a useful feature of Azure Container Apps: automatic versioning
    support.'
  prefs: []
  type: TYPE_NORMAL
- en: Application versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure Container Apps automatically versions your applications. Each time you
    modify the containers or scale configuration of your application, a new version
    is automatically created.
  prefs: []
  type: TYPE_NORMAL
- en: Each version is given a name and is called a **revision** of the application.
    As a default, only the last revision is active and accessible through the application
    link.
  prefs: []
  type: TYPE_NORMAL
- en: However, any application may be put in **multiple-revision** mode, in which
    case, you may decide manually which revisions are **active** and which revisions
    are connected to the application link.
  prefs: []
  type: TYPE_NORMAL
- en: 'If more than one revision is connected to the application link, you must specify
    how to split the traffic between them. If just one revision is attached to the
    application link but there are multiple active revisions, you may reach each active
    revision that is not attached to the application URL through its revision name,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Since revision names are automatically generated and are not user-friendly,
    each revision may be attached with friendly labels that can be used to reach the
    revision with links such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Azure Container Apps revisions logic enables several deployment models, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Staging/production*: The newer revision is not attached to the application
    link but can be reached just through its revision link, so it can be tested in
    staging. As soon as the new revision is approved, it is attached to the application
    link and the previous revision is deactivated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*New features preview*: The traffic is split among the last two revisions.
    Initially, the new revision is passed a low percentage of the overall traffic,
    so that users can experiment with new features. Then, gradually, the new version
    receives more traffic till it reaches 100%, and the previous version is deactivated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During traffic splitting, **session affinity** is enabled, so that if a user
    request is served by a revision, `r`, then all subsequent requests will continue
    being served by the same `r` revision. This way, we avoid users walking randomly
    between the two revisions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revisions are useful mainly for frontend services, especially if internal communication
    relies on message brokers. Testing a new version of a worker microservice requires
    a completely separate staging environment.
  prefs: []
  type: TYPE_NORMAL
- en: We will provide more details on the practical usage of revisions at the end
    of the *Deploying your microservice application with Azure Container Apps* section.
    The next subsection explains how to interact with your microservice application
    in Azure Container Apps.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with Azure Container Apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no equivalent of kubectl to interact with Azure Container Apps environments
    and applications. You may interact with them either through the Azure portal or
    with **Azure CLI**.
  prefs: []
  type: TYPE_NORMAL
- en: Application and environment settings can be specified either with command options
    or through `.yaml` or JSON files. We will focus just on command options and `.yaml`
    files, describing just the most practical alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interaction with Azure Containers Apps requires the installation of the
    **containerapp Azure CLI** extension. You can install it with the following command
    after you have logged in with `az login`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first `upgrade` command ensures you have the latest Azure CLI version, while
    the `upgrade` option in the second command updates the extension to the latest
    version. The preceding commands are needed only once, or each time you would like
    to update to a new version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting any new session, you must register a couple of namespaces.
    Namespaces registration has the same semantics as C# `using` statements. Here
    are the required registration commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to interact with Azure Container Apps. The next section explains
    in detail how to deploy and configure your microservice application on Azure Container
    Apps.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying your microservice application with Azure Container Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how to define and configure your applications in
    Azure Container Apps. In the first subsection, we will describe the basic commands
    and operativity, while all configuration options and the `.yaml` file configuration
    formats will be described in a later subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Basic commands and operativity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All Azure Container Apps commands start with `az containerapp`. Then, there
    is the main command and various configuration options. Configuration options may
    be passed each with a different command option or organized in a `.yaml` or JSON
    file.
  prefs: []
  type: TYPE_NORMAL
- en: In a PowerShell console, you can split a command into several lines with the
    help of the ` (backquote) character, as shown in all the commands in this subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `up` command is the simplest way to define an application together with
    a new environment. It is useful to perform a quick test of a container. The only
    obligatory parameters are the application name and the container image URL. For
    all other options, reasonable defaults are assumed. If you don’t specify a resource
    group and an environment, the command creates new ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` is the application name. It is obligatory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image` is the container image URL. It is obligatory. As usual, the `image`
    tag is used for image versioning, and if omitted, `latest` is assumed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ingress` may be `internal` or `external`. In the first case, the application
    will be accessible only from inside its environment, while in the second case,
    the application will be exposed to the external world. If this parameter is omitted,
    the application will not be accessible with a direct link (useful when internal
    communication relies on a message broker).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target-port` specifies the target port exposed by the container, if any. The
    application traffic will be redirected to this container port. If there are several
    containers, there should be just one that receives the application traffic, and
    you must specify its port. Application HTTP/S traffic must be sent to the usual
    `80` and `443` ports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`registry-server`, `registry-username`, and `registry-password` are parameters
    that specify the credentials associated with a specific image registry server,
    which should be the same as used in the `image` parameter. If specified, these
    parameters are added to the application configuration and will be used also in
    subsequent application updates. Later on, we will see how assigning an Azure identity
    to an application allows it to access Azure resources by simply granting adequate
    privileges to this identity with no need to provide passwords.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preexisting environment and resource group can be specified with the `--environment`
    and `--resource-group` options.
  prefs: []
  type: TYPE_NORMAL
- en: The `up` commands can be used to update the application configuration or the
    application container image, but in this case, you must always pass the `--name`,
    `--environment`, and `--resource-group` parameters with the values of the preexisting
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test the `up` command with the simple `gcr.io/google-samples/hello-app:1.0`
    image we used in the *Testing ingresses with minikube* subsection of[*Chapter
    8*](Chapter_8.xhtml#_idTextAnchor205), *Practical Microservices Organization with
    Kubernetes*. You don’t need to specify registry credentials since the registry
    is public. The container port is `8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We previously created a resource group in order to decide its name. We also
    specified the name of the environment to create. The `--query properties.configuration.ingress.fqdn`
    option lets the command return the application URL, which you might also compute
    manually with the URL format we gave in the previous section. Once you have tested
    this simple single HTML page application by going to the application URL with
    your favorite browser, you can also check all Azure resources created on your
    Azure portal home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the whole `.yaml` configuration of the application created with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'A good way to arrive at a properly configured application is by starting with
    default configurations, then getting the `.yaml` application configuration with
    the preceding command, modifying this `.yaml` file, and finally, submitting the
    modified `.yaml` file with the `update` command, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Each application is univocally identified by both its name and its resource
    group, so each `update` or `delete` command must specify both of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to clean up all resources after the experiment is by deleting
    the whole resource group, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When you need to deploy several applications in the same environment, the best
    way to proceed is to create the environment first with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you would like to enable workload profiles on the environment, you must also
    add the `--enable-workload-profiles` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to place all resources involved in your overall microservice application
    in a new resource group. you need to create it before creating the environment,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Workload profiles can be added to an environment with the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `--workload-profile-name` is the name you give to the workload profile,
    while `--workload-profile-type` is a profile type—that is, a type of virtual machine
    that you can select from the ones listed here: [https://learn.microsoft.com/en-us/azure/container-apps/workload-profiles-overview](https://learn.microsoft.com/en-us/azure/container-apps/workload-profiles-overview).
    `--min-nodes` and `--max-nodes` are, respectively, the minimum and maximum instances
    of the virtual machine that can be created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Workload profiles can also be removed at a later time with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When the environment is set up, you can deploy all container images in a common
    registry, and then you can start creating each application with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command creates an application with a default configuration. If
    you want the application to run in a workload profile instead of the default consumption
    profile, you must add the `--workload-profile-name <WORKLOAD_PROFILE_NAME>` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can extract its `.yaml` and modify it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to use the preceding code with this code, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also opt in for immediately specifying a `.yaml` file during the application
    creation, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get the list of all application revisions with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get also all replicas of each revision with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also get an interactive console in a container of a specific replica
    of a specific revision, similar to how Kubernetes `exec` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If there are several containers, you can specify the container name with the
    `--container` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can delete an application with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You can delete a whole environment and all the applications it contains with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: These commands cover most of the practical use cases. Other options and commands
    can be found in the official command reference at [https://learn.microsoft.com/it-it/cli/azure/containerapp?view=azure-cli-latest](https://learn.microsoft.com/it-it/cli/azure/containerapp?view=azure-cli-latest).
    In the next subsection, we will describe how to configure your application with
    a `.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Application configuration options and the .yaml format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest way to customize the application configuration is with a `.yaml`
    file passed to the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The organization of an application `.yaml` file is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: The `identity` section is present only if the application has been attached
    to an Azure identity for handling its access to other resources without passwords.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`environmentId` is the Azure unique ID of the environment the application is
    in (don’t confuse it with the environment name). The simplest way to get this
    and other values is by creating an application with default values and then showing
    its `.yaml` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workloadProfileName` is present only if the application is associated with
    a workload profile and contains the workload profile name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ingress` section is present only if the application must be accessible
    with a direct link from inside or outside its environment. It contains all its
    direct communication-related properties, CORS settings, and traffic splitting
    between versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxInactiveRevisions` is the number of previous revisions that are saved and
    can be activated. The default is 100.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `registries` section contains information about registries that must be
    accessed with credentials. Registries that are not private and don’t need credentials
    should not be listed here. Each entry specifies either the registry username and
    password or an Azure identity with permission to access the registry. The identity
    must be listed in the i`dentity` section. For more details, see the *Associating
    an Azure identity to your application* section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`secrets` are name-value pairs that are stored safely. They are equivalent
    to Kubernetes generic secrets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As in Kubernetes, we have `containers` and `initContainers`. `initContainers`
    work the same as in Kubernetes, but there is no way to declare `sidecar` containers,
    so `sidecar` containers must be included among the standard containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `scale` section contains the minimum and maximum number of application
    replicas and rules for deciding the exact number of replicas. The most common
    rules decide the number of replicas trying to maintain a target number of HTTP
    requests or TCP/IP connections per replica:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we have a `volumes` section that declares all volumes mounted by containers.
    As in Kubernetes, they are referred to by a `volumeMounts` section inside the
    container definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All properties that were not fully specified in the previous `.yaml` file will
    be described in a separate subsection. Let’s start with containers.
  prefs: []
  type: TYPE_NORMAL
- en: Container configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The configuration of each container is similar to the one in Kubernetes but
    there are some simplifications. The schema is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`image` and `name` are identical to the Kubernetes configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables can be defined either as name-value pairs or as `name`-`secretRef`
    pairs, where `secretRef` contains the name of a secret defined in the `secrets`
    section. In the second case, the variable value is the value of the secret.
  prefs: []
  type: TYPE_NORMAL
- en: '`volumeMounts` is similar to Kubernetes, too. The only difference is that the
    volume name is called `name` in Kubernetes while, here, it is called `volumeName`.'
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes `resources` property has two properties, `requests` and `limits`,
    while here we have just a couple of values that correspond to the Kubernetes `requests`
    property. This means that we cannot specify `resources` limits as in Kubernetes.
    The reason behind this choice is probably connected to the serverless nature of
    Azure Container Apps. The meanings and units of measure of both `cpu` and `memory`
    are the same as in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, liveness, readiness, and startup probes are defined in slightly
    different ways but their meaning is the same as in Kubernetes. The syntax and
    meaning of the properties after `type: liveness/readiness/startup` is identical
    to the corresponding Kubernetes configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the `ingress` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The ingress configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ingress` configuration mixes some Kubernetes `Service` and `Ingress` settings
    with the traffic splitting between various revisions, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`external` must be set to `true` to expose the application to the outside world,
    otherwise, to `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`targetPort` is the container port to which to route the application traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exposedPort` must be used only in case of non-HTTP/S traffic. It sets the
    application listening port. All traffic received on this port is routed to `targetPort`.
    The `exposedPort` ports of applications exposed to the outside world must be unique
    inside the environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP/S traffic, instead, always uses the usual `80` and `443` ports with no
    customization possibilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `allowInsecure` is `false`, HTTP traffic is automatically redirected to HTTPS.
    The default is `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clientCertificateMode` specifies whether TCP/IP client certificates are accepted
    for authentication. This setting is completely analogous to a similar setting
    exposed by Kestrel. If set to `accept`, client certificates are accepted and processed.
    If set to `required`, client certificates are obligatory, and if not provided,
    the connection is refused. If set to `ignore`, client certificates are completely
    ignored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`corsPolicy` contains standard web server CORS settings, which are the same
    as those supported by ASP.NET Core. For completeness, we describe all the CORS
    settings here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `allowCredentials` is set to `false`, CORS requests containing credentials
    are refused. The default is `false`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxAge` specifies the caching time of the pre-flight request. The pre-flight
    request has the only purpose of verifying whether a CORS request will be accepted
    before sending actual data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowedOrigins` and `allowedMethods` specify, respectively, the origin domains
    from which to accept CORS requests and the accepted HTTP verbs.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding `allowedHeaders`, as a default, only some safe `requests` headers
    are allowed. This setting adds further `requests` headers to the ones accepted.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding `exposeHeaders`, as a default, only some safe `response` headers are
    exposed in the responses to CORS requests. This setting adds further headers to
    the ones allowed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`traffic` specifies the traffic splitting among various revisions. If a revision
    is listed with a `0` split, it will receive no application traffic but it will
    be set to active—that is, it can be reached with its revision-specific links.
    All labels added to an active revision must be specified here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While revision handling can be done by modifying the `traffic` section, it is
    more practical to handle it with ad hoc commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of all revisions in table format for a given application can be obtained
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Details about a specific revision can be obtained with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Labels can be attached or detached from a specific revision with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'An application can be switched from single revision mode to multiple revision
    mode, and vice versa, with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'A given revision can be activated, deactivated, or restarted with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, traffic splitting between revisions can be changed with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The next section focuses on how to define volumes in the `volumes` section.
  prefs: []
  type: TYPE_NORMAL
- en: Volume definition and allocation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Volumes can be either `EmptyDir` (which works in the same way as Kubernetes
    `EmptyDir`) or file shares taken from Azure Files, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `mystorage` is the name of a file share you created and attached to the
    environment. Therefore, you must execute the following steps to get `mystorage`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a storage account if you don’t have it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a file share:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the credentials to access the storage account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a file share name to the environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can define the volume in your application using the `--storage-name`
    value passed to the last command, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The next subsection explains how to associate an Azure identity to an application,
    thus enabling it to access Azure resources.
  prefs: []
  type: TYPE_NORMAL
- en: Associating an Azure identity to your application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Azure identity to associate with an application can be automatically generated
    and handled by Azure or can be defined manually. The main advantage of using a
    user-defined identity is that you can add the same identity to several applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a system-assigned identity to an application is very easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command returns the Azure resource ID of the created identity.
    A system-assigned identity can be associated with the application also by adding
    `type: SystemAssigned` to the `identity` section of the application’s `.yaml`
    file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: A user-defined identity must be created first and then assigned to the application,
    so adding a user-defined identity requires two steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The identity can be created with the simple command shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--output json` option forces the command to return information about the
    created identity in JSON format. The returned JSON object contains the Azure resource
    ID of the created identity. You need it to associate the identity with your applications
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step can be performed by adding the resource ID of one or more identities
    directly to the `identity` section of the application’s `.yaml` files, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: As an example, let’s see how to enable a created identity to access an Azure
    container registry. This way, we can avoid storing registry credentials in the
    application’s `.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need the container registry resource ID. We can get it with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can assign the `AcrPull` role on our container registry to our identity
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must inform the application that it can use its system-assigned
    or user-assigned identity to access the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step can also be performed by adding an entry to the `registries`
    section of the application’s `.yaml` files, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We have finished our Azure Container Apps trip. We will return to Azure Container
    Apps in [*Chapter 12*](Chapter_12.xhtml#_idTextAnchor345), *Simplifying Microservices
    with .NET Aspire*, where we will see how to automatically create all instructions
    to deploy a whole microservice application to Azure Container Apps, and we will
    use the book case study application as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Our description of Azure Container Apps is fundamentally complete and covers
    95% of practical Azure Container Apps operativity. More details can be found in
    the official documentation at [https://learn.microsoft.com/en-us/azure/container-apps/](https://learn.microsoft.com/en-us/azure/container-apps/).
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter focuses on the security and observability of the microservice
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter described Kubernetes-related tools that facilitate the administration
    and coding of distributed applications and then focused on Azure Container Apps.
  prefs: []
  type: TYPE_NORMAL
- en: We described the basic ideas behind the Azure Container Apps offering, including
    its fundamental concepts and principles. Then, we described the available plans
    and how to interact with Azure Container Apps through the Azure portal.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we described the main commands and the`.yaml` format that defines
    a whole application. We showed how all resources in Kubernetes are implemented
    in Azure Container Apps and compared the two approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is it true that environments are equivalent to Kubernetes namespaces?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They are similar but not equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: How does Helm simplify the deployment of Kubernetes applications and tools?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because it allows the simultaneous deployment of several yaml files which can
    be configured according to selected options and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: What are Prometheus and Grafana?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They’re administrative tools that collect metrics, and other information and
    present them to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Can you describe the URL composition of an Azure Container Apps application
    exposed to the external world?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<application name>.<Environment name>.<zone>.azurecontainerapps.io`'
  prefs: []
  type: TYPE_NORMAL
- en: Do environments provide access to all properties of their underlying networks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No.
  prefs: []
  type: TYPE_NORMAL
- en: Which kinds of Azure identities can be associated with Azure Container Apps?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: User defined and System Assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Is it true that, in Azure Container Apps, Azure file storage allocation is automatic
    (as in Kubernetes) and requires just the declaration of volumes in the `volumes`
    section of the application’s `.yaml` file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No.
  prefs: []
  type: TYPE_NORMAL
- en: Is it possible to deploy an Azure Container Apps application with a single Azure
    console command without filling in any configuration file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, in several ways.
  prefs: []
  type: TYPE_NORMAL
- en: In which section of an Azure Container Apps `.yaml` file can you define traffic
    splitting between revisions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ingress->traffic`'
  prefs: []
  type: TYPE_NORMAL
- en: Can the port where an Azure Container Apps application listens to HTTP/S requests
    be customized?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'More information on Helm and Helm charts can be found in the official documentation.
    This is extremely well written and contains some good tutorials: [https://helm.sh/](https://helm.sh/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Grafana dashboards: [https://grafana.com/grafana/dashboards/](https://grafana.com/grafana/dashboards/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ArgoCD: [https://argo-cd.readthedocs.io/en/stable/](https://argo-cd.readthedocs.io/en/stable/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rancher UI: [https://ranchermanager.docs.rancher.com/](https://ranchermanager.docs.rancher.com/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenShift: [https://www.redhat.com/en/technologies/cloud-computing/openshift](https://www.redhat.com/en/technologies/cloud-computing/openshift).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure OpenShift: [https://azure.microsoft.com/it-it/products/openshift](https://azure.microsoft.com/it-it/products/openshift).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Container Apps pricing: [https://azure.microsoft.com/en-us/pricing/details/container-apps/](https://azure.microsoft.com/en-us/pricing/details/container-apps/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Container Apps custom profiles: [https://learn.microsoft.com/en-us/azure/container-apps/workload-profiles-overview](https://learn.microsoft.com/en-us/azure/container-apps/workload-profiles-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Container Apps official documentation: [https://learn.microsoft.com/en-us/azure/container-apps/](https://learn.microsoft.com/en-us/azure/container-apps/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Container Apps commands reference: [https://learn.microsoft.com/it-it/cli/azure/containerapp?view=azure-cli-latest](https://learn.microsoft.com/it-it/cli/azure/containerapp?view=azure-cli-latest).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/PSMCSharp](https://packt.link/PSMCSharp)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/B31916_Discord-QR-Code.png)'
  prefs: []
  type: TYPE_IMG
