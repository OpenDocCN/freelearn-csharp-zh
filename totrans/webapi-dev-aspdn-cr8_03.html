<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-68"><a id="_idTextAnchor130"/>3</h1>
<h1 id="_idParaDest-69"><a id="_idTextAnchor131"/>ASP.NET Core Fundamentals (Part 1)</h1>
<p>In the previous chapter, we learned how to create a basic REST API using ASP.NET Core. ASP.NET Core provides a lot of features that make it easy to build web APIs.</p>
<p>In this chapter, we will be covering the following topics:</p>
<ul>
<li>Routing</li>
<li>Configuration</li>
<li>Environments</li>
</ul>
<p><strong class="bold">Routing</strong> is <a id="_idIndexMarker256"/>used to map incoming requests to the corresponding controller actions. We will discuss how to use attribute routing to configure the routing for ASP.NET Core web APIs. <strong class="bold">Configuration</strong> is used to provide the initial settings for an application on its startup, such as database connection strings, API keys, and other settings. Configuration is often used with <strong class="bold">environments</strong>, such as development, staging, and production. At the conclusion of this chapter, you will have the skills to create RESTful routes for your ASP.NET Core web APIs and utilize the ASP.NET Core configuration framework to manage configurations for different environments.</p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor132"/>Technical requirements</h1>
<p>The code examples in this chapter can be found at <a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8</a>.</p>
<p>You can use Visual Studio 2022 or <strong class="bold">VS Code</strong> to open the solutions.</p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor133"/>Routing</h1>
<p>In <a href="B18971_02.xhtml#_idTextAnchor068"><em class="italic">Chapter 2</em></a><em class="italic">, </em>we introduced how to <a id="_idIndexMarker257"/>create a simple ASP.NET Core web API project using the default controller-based template. The project uses some attributes, such as <code>[Route("api/controller")]</code>, <code>[HttpGet]</code>, and so on, to map incoming requests to the corresponding controller actions. These attributes are used to configure the routing for the ASP.NET Core web API project.</p>
<p>Routing is a mechanism that monitors incoming requests and determines which action method is to be invoked for those requests. ASP.NET Core provides two types of routing: conventional routing and attribute routing. Conventional routing is typically used for ASP.NET Core MVC applications, while ASP.NET Core web APIs use attribute routing. In this section, we will discuss attribute routing in more detail.</p>
<p>You can download the <code>RoutingDemo</code> sample project from <code>/samples/chapter3/RoutingDemo/</code> in the chapter's GitHub repository.</p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor134"/>What is attribute routing?</h2>
<p>Open <a id="_idIndexMarker258"/>the <code>Program.cs</code> file in the <code>RoutingDemo</code> project. You <a id="_idIndexMarker259"/>will find the following code:</p>
<pre class="source-code">
app.MapControllers();</pre> <p>This line of code adds endpoints for controller actions to the <code>IEndpointRouteBuilder</code> instance without specifying any routes. To specify the routes, we need to use the <code>[Route]</code> attribute on the controller class and the action methods. The following code shows how to use the <code>[Route]</code> attribute on the <code>WeatherForecastController</code> class:</p>
<pre class="source-code">
[ApiController][Route("[controller]")]
public class WeatherForecastController : ControllerBase
{
  // Omitted for brevity
}</pre>
<p>In the preceding code, the <code>[controller]</code> token is a placeholder for the controller name. In this case, the controller name is <code>WeatherForecast</code>, so the <code>[controller]</code> route template is replaced with <code>WeatherForecast</code>. That means the route for the <code>WeatherForecastController</code> class is <code>/WeatherForecast</code>.</p>
<p>ASP.NET Core has<a id="_idIndexMarker260"/> some built-in route tokens, such as <code>[controller]</code>, <code>[action]</code>, <code>[area]</code>, <code>[page]</code>, and so on. These tokens are enclosed in square brackets (<code>[]</code>) and will be replaced with the corresponding values. Note <a id="_idIndexMarker261"/>that these tokens are reserved route parameter names and should not be used as a route parameter like <code>{controller}</code>.</p>
<p>In ASP.NET Core REST web APIs, we usually use a <code>[Route("api/[controller]")]</code> template to represent API endpoints. You can find the <code>PostsController</code> class in the <code>Controllers</code> folder. The following code shows the routing attribute of the <code>PostsController</code> class:</p>
<pre class="source-code">
[ApiController] [Route("api/[controller]")]
 public class PostsController : ControllerBase
 {
   // Omitted for brevity
 }</pre>
<p>The route for the <code>PostsController</code> class is <code>/api/Posts</code>. This is an indication that the endpoint is a REST API endpoint. Whether you use <code>/api</code> as the route prefix or not is up to you. There is no standard for this.</p>
<p>Some developers prefer to use lowercase for route templates, such as <code>/api/posts</code>. To achieve this, the route value can be explicitly specified; for example, <code>[Route("api/posts")]</code>. However, it seems a bit tedious to specify the route value for each controller class. Fortunately, ASP.NET Core provides a way to configure the route value globally. Add the following code to the <code>Program.cs</code> file:</p>
<pre class="source-code">
builder.Services.AddRouting(options =&gt; options.LowercaseUrls = true);</pre> <p>The preceding code converts all route templates to lowercase. Actually, the text matching in ASP.NET Core routing is case-insensitive. So, this change only affects the generated paths’ URLs, such as <a id="_idIndexMarker262"/>the URLs in Swagger UI and the <code>/api/Posts</code> or <code>/api/posts</code> to hit the same controller route.</p>
<p>Multiple routes can be applied to one controller class. The following code shows how to apply multiple routes to the <code>PostsController</code> class:</p>
<pre class="source-code">
[ApiController] [Route("api/[controller]")]
 [Route("api/some-posts-whatever")]
 public class PostsController : ControllerBase
 {
   // Omitted for brevity
 }</pre>
<p>In this <a id="_idIndexMarker264"/>case, the <code>PostsController</code> class has two routes: <code>/api/posts</code> and <code>/api/some-posts-whatever</code>. It is not recommended to have multiple routes for the same controller class as this can lead to confusion. If you require multiple routes for the same controller class, please ensure that you have strong reasons for doing so.</p>
<p>In ASP.NET Core REST APIs, we usually do not use the <code>[action]</code> token because the action name is not included in the route template. Similarly, do not use the <code>[Route]</code> attribute for action methods. Instead, we use the HTTP method to distinguish action methods. We will discuss this in the following section.</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor135"/>Mapping HTTP methods to action methods</h2>
<p>REST APIs <a id="_idIndexMarker265"/>are centered on resources. When<a id="_idIndexMarker266"/> we design a REST API, we need to map the CRUD operations to the HTTP methods. In ASP.NET Core, we can use the following HTTP verb attributes to map HTTP methods to action methods:</p>
<ul>
<li><code>[HttpGet]</code> maps an HTTP <code>GET</code> method to an action method</li>
<li><code>[HttpPost]</code> maps an HTTP <code>POST</code> method to an action method</li>
<li><code>[HttpPut]</code> maps an HTTP <code>PUT</code> method to an action method</li>
<li><code>[HttpDelete]</code> maps an HTTP <code>DELETE</code> method to an action method</li>
<li><code>[HttpPatch]</code> maps an HTTP <code>PATCH</code> method to an action method</li>
<li><code>[HttpHead]</code> maps an HTTP <code>HEAD</code> method to an action method</li>
</ul>
<p>The <a id="_idIndexMarker267"/>following <a id="_idIndexMarker268"/>code shows how to use the <code>[HttpGet]</code> attribute to map the HTTP <code>GET</code> method to the <code>GetPosts()</code> action method:</p>
<pre class="source-code">
[HttpGet] public async Task&lt;ActionResult&lt;List&lt;Post&gt;&gt;&gt; GetPosts()
 {
   // Omitted for brevity
 }</pre>
<p>In ASP.NET Core REST APIs, each action must have an HTTP verb attribute. If you do not specify an HTTP verb attribute, the framework cannot determine which method should be invoked for the incoming request. In the preceding code, a <code>GET</code> request to the <code>/api/posts</code> endpoint is mapped to the <code>GetPosts()</code> action method.</p>
<p>The following code shows how to use the <code>[HttpGet]</code> attribute to map the HTTP <code>GET</code> method to the <code>GetPost()</code> action method with a route template:</p>
<pre class="source-code">
[HttpGet("{id}")] public async Task&lt;ActionResult&lt;Post&gt;&gt; GetPost(int id)
 {
   // Omitted for brevity
 }</pre>
<p>The preceding <code>HttpGet</code> attribute has an <code>{id}</code> route template, which is a route parameter. The route parameter is enclosed in curly braces ( <code>{}</code>). The route parameter is used to capture the value from the incoming request. For example, a <code>GET</code> request to the <code>/api/posts/1</code> endpoint is mapped to the <code>GetPost(int id)</code> action method, and the value <code>1</code> is captured by the <code>{id}</code> route parameter.</p>
<p>The following code shows how to use the <code>[HttpPut]</code> attribute to publish a post:</p>
<pre class="source-code">
[HttpPut("{id}/publish")] public async Task&lt;ActionResult&gt; PublishPost(int id)
 {
   // Omitted for brevity
 }</pre>
<p>The <a id="_idIndexMarker269"/>preceding <code>HttpPut</code> attribute <a id="_idIndexMarker270"/>has an <code>{id}/publish</code> route template. The <code>publish</code> literal is used to match the <code>publish</code> literal in the incoming request. So, a <code>PUT</code> request to the <code>/api/posts/1/publish</code> endpoint is mapped to the <code>PublishPost(int id)</code> action method, and the value <code>1</code> is captured by the <code>{id}</code> route parameter.</p>
<p>When defining a route template, please make sure there are no conflicts. For example, we want to add a new action method to get posts by a user ID. If we use the following code, it will not work:</p>
<pre class="source-code">
[HttpGet("{userId}")] // api/posts/user/1 public async Task&lt;ActionResult&lt;List&lt;Post&gt;&gt;&gt; GetPostsByUserId(int userId)</pre>
<p>This is because we already have a <code>GetPost()</code> action method that uses <code>[HttpGet("{id}")]</code>. When sending a <code>GET</code> request to the <code>/api/posts/1</code> endpoint, the request matches multiple actions, so you will see a <code>500</code> error as follows:</p>
<pre class="source-code">
Microsoft.AspNetCore.Routing.Matching.AmbiguousMatchException: The request matched multiple endpoints. Matches:RoutingDemo.Controllers.PostsController.GetPost (RoutingDemo)
 RoutingDemo.Controllers.PostsController.GetPostsByUserId (RoutingDemo)</pre>
<p>To fix it, we need to specify a different template, such as <code>[HttpGet("user/{userId}")]</code>.</p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor136"/>Route constraints</h2>
<p>In the <a id="_idIndexMarker271"/>previous section, we introduced how to use a route parameter to <a id="_idIndexMarker272"/>capture the value from an incoming request. A <code>[HttpGet("{id}")] </code>attribute can match a <code>GET</code> request to the <code>/api/posts/1</code> endpoint. But what if the request is a <code>GET</code> request to the <code>/</code><code>api/posts/abc</code> endpoint?</p>
<p>As the <code>id</code> parameter is of type <code>int</code>, the framework will try to convert the captured value to an <code>int</code> value. If the conversion fails, the framework will return a <code>400 Bad Request</code> response. So, a <code>GET</code> request to the <code>/api/posts/abc</code> endpoint will fail and return a <code>400 Bad </code><code>Request</code> response.</p>
<p>We can add route constraints to route parameters to restrict the values of the route parameters. For example, we can add a route constraint to the <code>id</code> parameter to ensure that the <code>id</code> parameter is an integer. The following code shows how to add a route constraint to the <code>id</code> parameter:</p>
<pre class="source-code">
[HttpGet("{id:int}")] public async Task&lt;ActionResult&lt;Post&gt;&gt; GetPost(int id)
 {
   // Omitted for brevity
 }</pre>
<p>Now, the <code>id</code> parameter must be an integer. A <code>GET</code> request to the <code>/api/posts/abc</code> endpoint will return a <code>404 Not Found</code> response because the route does not match.</p>
<p>ASP.NET Core provides a set of built-in route constraints, such as the following:</p>
<ul>
<li><code>int</code>: The parameter must be an integer value.</li>
<li><code>bool</code>: The parameter must be a Boolean value.</li>
<li><code>datetime</code>: The parameter must be a DateTime value.</li>
<li><code>decimal</code>: The parameter must be a <code>decimal</code> value. Similarly, there are <code>double</code>, <code>float</code>, <code>long</code>, and so on.</li>
<li><code>guid</code>: The parameter must be a GUID value.</li>
<li><code>minlength(value)</code>: The parameter must be a string with a minimum length; for example, <code>{name:minlength(6)}</code>, which means the <code>name</code> parameter must be a string and the length of the string must be at least 6 characters. Similarly, there are <code>maxlength(value)</code>, <code>length(value)</code>, <code>length(min, max)</code>, and so on.</li>
<li><code>min(value)</code>: The parameter must be an integer with a minimum value; for example, <code>{id:min(1)}</code>, which means the <code>id</code> parameter must be an integer and the value must be greater than or equal to 1. Similarly, there are <code>max(value)</code>, <code>range(min,</code> <code>max)</code>, and so on.</li>
<li><code>alpha</code>: The parameter must be a string with one or more letters.</li>
<li><code>regex(expression)</code>: The parameter must be a string that matches the regular expression.</li>
<li><code>required</code>: The parameter must be provided in the route; for example, <code>{id:required}</code>, which means the <code>id</code> parameter must be provided in the route.</li>
</ul>
<p>If the value <a id="_idIndexMarker273"/>of the route parameter does not match the <a id="_idIndexMarker274"/>route constraint, the action method will not accept the request, and a <code>404 Not Found</code> response will be returned.</p>
<p>Multiple route constraints can be applied together. The following code shows how to apply multiple route constraints to the <code>id</code> parameter, which means the <code>id</code> parameter must be an integer and the value must be greater than or equal to 1 and less than or equal to 100:</p>
<pre class="source-code">
[HttpGet("{id:int:range(1, 100)}")] public async Task&lt;ActionResult&lt;Post&gt;&gt; GetPost(int id)
 {
   // Omitted for brevity
 }</pre>
<p>Route constraints can be used to make a route more specific. However, they should not be used to validate the input. If the input is invalid, the API should return a <code>400 Bad Request</code> response rather than a <code>404 Not </code><code>Found</code> response.</p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor137"/>Binding source attributes</h2>
<p>We can <a id="_idIndexMarker275"/>define parameters in the action. See the<a id="_idIndexMarker276"/> following action method:</p>
<pre class="source-code">
[HttpGet("{id}")] public async Task&lt;ActionResult&lt;Post&gt;&gt; GetPost(int id)</pre>
<p>The <code>GetPost()</code> method has a parameter named <code>id</code>, which matches the parameter in the <code>{id}</code> route template. So, the value of <code>id</code> will come from the route, such as 1 in the <code>/api/posts/1</code> URL. This is called parameter inference.</p>
<p>ASP.NET Core offers the following binding source attributes:</p>
<ul>
<li><code>[FromBody]</code>: The parameter is from the request body</li>
<li><code>[FromForm]</code>: The parameter is from the form data in the request body</li>
<li><code>[FromHeader]</code>: The parameter is from the request header</li>
<li><code>[FromQuery]</code>: The parameter is from the query strings in the request</li>
<li><code>[FromRoute]</code>: The parameter is from the route path</li>
<li><code>[FromServices]</code>: The parameter is from the <strong class="bold">DI</strong> container</li>
</ul>
<p>For example, we can define a pagination action method as follows:</p>
<pre class="source-code">
[HttpGet("paged")] public async Task&lt;ActionResult&lt;List&lt;Post&gt;&gt;&gt; GetPosts([FromQuery] int pageIndex, [FromQuery] int pageSize)
 {
     // Omitted for brevity
 }</pre>
<p>The preceding code means the <code>pageIndex</code> parameter and the <code>pageSize</code> parameter should be from query strings in the URL, such as <code>/api/posts/paged?pageIndex=1&amp;pageSize=10</code>.</p>
<p>When an <code>[ApiController]</code> attribute is applied to a controller class, a set of default inference<a id="_idIndexMarker277"/> rules will be applied, so we do not need to explicitly add these binding <a id="_idIndexMarker278"/>source attributes. For example, the following code shows a <code>POST</code> action method:</p>
<pre class="source-code">
[HttpPost] public async Task&lt;ActionResult&lt;Post&gt;&gt; CreatePost(Post post)
 {
     // Omitted for brevity
 }
The <code>post</code> parameter is a complex type, so <code>[FromBody]</code> inferred that the post should be from the request body. But <code>[FromBody]</code> is not inferred for simple data types, such as <code>int</code>, <code>string</code>, and so on. We will define an action method as follows:
[HttpPost("search")]
 public async Task&lt;ActionResult&lt;Post&gt;&gt; SearchPosts(string keyword)</pre>
<p>The <code>keyword</code> parameter is a simple type, so <code>[FromQuery]</code> inferred that the <code>keyword</code> parameter should be from the query strings in the URL, such as <code>/api/posts/search?keyword=xyz</code>. If we want to force the <code>keyword </code>parameter to be from the request body, we can use the <code>[FromBody]</code> attribute as follows:</p>
<pre class="source-code">
[HttpPost("search")] public async Task&lt;ActionResult&lt;Post&gt;&gt; SearchPosts([FromBody] string keyword)</pre>
<p>Then, the <code>keyword</code> parameter must be from the request body. Note that this is a bad example because we usually do not use the request body to pass a simple type parameter.</p>
<p>The default inference<a id="_idIndexMarker279"/> rules of those binding source attributes are listed next:</p>
<ul>
<li>For complex type parameters, if the type is registered in the DI container, <code>[FromServices]</code> is inferred.</li>
<li>For complex type parameters that are not registered in the DI container, <code>[FromBody]</code> is inferred. It does not support multiple <code>[</code><code>FromBody]</code> parameters.</li>
<li>For types such as <code>IFormFile</code> and <code>IFormFileCollection</code>, <code>[FromForm]</code> is inferred.</li>
<li>For any parameters that appear in the route, <code>[FromRoute]</code> is inferred.</li>
<li>For any parameters of simple types, such as <code>int</code>, <code>string</code>, and so on, <code>[FromQuery]</code> is inferred.</li>
</ul>
<p>If a <a id="_idIndexMarker280"/>parameter can be inferred based on these rules, the binding source attribute can be omitted. Otherwise, we need to explicitly specify the binding source attribute.</p>
<p>Routing is a very important concept in REST APIs. Ensure that routes are well designed, intuitive, and easy to understand. This will help the consumers of your REST APIs use them easily.</p>
<p>Next, we will check the config<a id="_idTextAnchor138"/>uration in ASP.NET Core.</p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor139"/>Configuration</h1>
<p>ASP.NET Core provides<a id="_idIndexMarker281"/> a comprehensive configuration framework that makes it easy to work with configuration settings. A configuration is considered a key-value pair. These configuration settings are stored in a variety of sources, such as JSON files, environment variables, and command-line arguments, or in the cloud, such as Azure Key Vault. In ASP.NET Core, these sources are referred to as <strong class="bold">configuration providers</strong>. Each<a id="_idIndexMarker282"/> configuration provider is responsible for loading configuration settings from a specific source.</p>
<p>ASP.NET Core supports a set of configuration providers, such as the following:</p>
<ul>
<li>The file configuration provider, such as, <code>appsettings.json</code> </li>
<li>The User secrets </li>
<li>The environment variables configuration provider </li>
<li>The command-line configuration provider </li>
<li>The Azure App Configuration provider </li>
<li>The Azure Key Vault configuration provider</li>
</ul>
<p>The configuration of ASP.NET Core is provided by the <code>Microsoft.Extension.Configuration</code> NuGet package. You do not need to install this package explicitly as it is already installed with the default ASP.NET Core template, which provides several built-in configuration providers, such as <code>appsettings.json</code>. These configuration providers are configured in priority order. We will discuss this in more detail in the <em class="italic">Understanding the priorities of configuration and environment variables</em> section. First, let us look at how to use <code>appsettings.json</code>.</p>
<p>Run the following command to create a new ASP.NET Core web API project:</p>
<pre class="console">
dotnet new webapi -n ConfigurationDemo -controllers</pre> <p>You can download the example project named <code>ConfigurationDemo</code> from the <code>/samples/chapter3/ConfigurationDemo</code> folder in the chapter's GitHub repository.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor140"/>Using appsettings.json</h2>
<p>By <a id="_idIndexMarker283"/>default, ASP.NET Core apps are configured to read configuration settings from <code>appsettings.json</code> using <code>JsonConfigurationProvider</code>. The <code>appsettings.json</code> file is located in the project’s root directory, which is a JSON file that contains key-value pairs. The following<a id="_idIndexMarker284"/> code shows the default content of the <code>appsettings.json</code> file:</p>
<pre class="source-code">
{  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}</pre>
<p>You will find another <code>appsettings.Development.json</code> file, which will be used for the development environment. We will introduce the environment in the following section.</p>
<p>Let us add a <code>"MyKey": "MyValue"</code> key-value pair to the <code>appsettings.json</code> file. This key-value pair is an example configuration that we will read in the code using <code>JsonConfigurationProvider</code>:</p>
<pre class="source-code">
{  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "MyKey": "MyValue"
}</pre>
<p>Create a <a id="_idIndexMarker285"/>new controller named <code>ConfigurationController</code> in the <code>Controllers</code> folder. In this controller, we will read the configuration value from the <code>appsettings.json</code> file and return it as a string. The<a id="_idIndexMarker286"/> following code shows the <code>ConfigurationController</code> class:</p>
<pre class="source-code">
using Microsoft.AspNetCore.Mvc;namespace ConfigurationDemo.Controllers;
[ApiController]
[Route("[controller]")]
public class ConfigurationController(IConfiguration configuration) : ControllerBase
{
    [HttpGet]
    [Route("my-key")]
    public ActionResult GetMyKey()
    {
        var myKey = configuration["MyKey"];
        return Ok(myKey);
    }
}</pre>
<p>To <a id="_idIndexMarker287"/>access the configuration settings, we need to inject the <code>IConfiguration</code> interface into the constructor of the controller. The <code>IConfiguration</code> interface represents a set of key/value application <a id="_idIndexMarker288"/>configuration properties. The following code shows how to access the configuration settings:</p>
<pre class="source-code">
var myKey = configuration["MyKey"];</pre> <p>Run the application and send a request to the <code>/Configuration/my-key</code> endpoint. You can use any HTTP client, such as Postman, Thunder Client in VS Code, or HttpRepl. The following code shows how to use HttpRepl:</p>
<pre class="console">
httprepl http://localhost:5116cd Configuration
get my-key</pre>
<p>You will see the following response:</p>
<pre class="console">
HTTP/1.1 200 OKContent-Type: text/plain; charset=utf-8
Date: Fri, 23 Sep 2022 11:22:40 GMT
Server: Kestrel
Transfer-Encoding: chunked
MyValue</pre>
<p>The configuration supports hierarchical settings. For example, consider the following configuration settings:</p>
<pre class="source-code">
{  "Database": {
    "Type": "SQL Server",
    "ConnectionString": "This is the database connection string"
  }
}</pre>
<p>To access <a id="_idIndexMarker289"/>the <code>Type</code> and <code>ConnectionString</code> properties, we <a id="_idIndexMarker290"/>can use the following code:</p>
<pre class="source-code">
[HttpGet][Route("database-configuration")]
public ActionResult GetDatabaseConfiguration()
{
    var type = configuration["Database:Type"];
    var connectionString = configuration["Database:ConnectionString"];
    return Ok(new { Type = type, ConnectionString = connectionString });
}</pre>
<p>Note that we use a colon (<code>:</code>) to separate the hierarchical settings.</p>
<p>Run the application and send a request to the <code>/Configuration/database-configuration</code> endpoint. If you use HttpRepl, you can use the following command:</p>
<pre class="console">
<code>httprepl http://localhost:5116</code><code>cd Configuration</code>
<code>get database-configuration</code></pre>
<p>The following code shows a response from HttpRepl:</p>
<pre class="console">
HTTP/1.1 200 OKContent-Type: application/json; charset=utf-8
Date: Fri, 23 Sep 2022 11:35:55 GMT
Server: Kestrel
Transfer-Encoding: chunked
{
  "type": "SQL Server",
  "connectionString": "This is the database connection string"
}</pre>
<p>Using <a id="_idIndexMarker291"/>the <code>IConfiguration</code> interface, we can access the configuration settings with the <code>configuration[key]</code> format. However, hardcoding the keys is not a good practice. To avoid hardcoding, ASP.NET Core supports the options pattern, which can <a id="_idIndexMarker292"/>provide a strongly typed <a id="_idTextAnchor141"/>way to access hierarchical settings.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor142"/>Using the options pattern</h2>
<p>To use <a id="_idIndexMarker293"/>the <a id="_idIndexMarker294"/>options pattern, we need to create a class that represents the configuration settings. The following code shows how to create a class named <code>DatabaseOption</code>:</p>
<pre class="source-code">
namespace ConfigurationDemo;public class DatabaseOption
{
    public const string SectionName = "Database";
    public string Type { get; set; } = string.Empty;
    public string ConnectionString { get; set; } = string.Empty;
}</pre>
<p>The <code>SectionName</code> field is used to specify the section name in the <code>appsettings.json</code> file. This field is not mandatory. But if we do not define it here, we will need<a id="_idIndexMarker295"/> to pass a hardcoded string for the section name when we bind the configuration section. To better leverage the<a id="_idIndexMarker296"/> strong typing, we can define a <code>SectionName</code> field. The <code>Type</code> and <code>ConnectionString</code> properties are used to represent the <code>Type</code> and <code>ConnectionString</code> fields in the <code>appsettings.json</code> file.</p>
<p>Note that an option class must be non-abstract with a public parameterless constructor.</p>
<p>There are multiple ways to u<a id="_idTextAnchor143"/>se the options pattern. Let's continue.</p>
<h3>Using the ConfigurationBinder.Bind() method</h3>
<p>First, Let's <a id="_idIndexMarker297"/>use the <code>ConfigurationBinder.Bind()</code> method, which attempts to bind a given object instance to configuration values by recursively matching property names against configuration keys.</p>
<p>In the <code>ConfigurationController</code> class, add the following code:</p>
<pre class="source-code">
[HttpGet][Route("database-configuration-with-bind")]
public ActionResult GetDatabaseConfigurationWithBind()
{
    var databaseOption = new DatabaseOption();
    // The `SectionName` is defined in the `DatabaseOption` class, which shows the section name in the `appsettings.json` file.
    configuration.GetSection(DatabaseOption.SectionName).Bind(databaseOption);
    // You can also use the code below to achieve the same result
    // configuration.Bind(DatabaseOption.SectionName, databaseOption);
    return Ok(new { databaseOption.Type, databaseOption.ConnectionString });
}</pre>
<p>Run the <a id="_idIndexMarker298"/>application and send a request to the <code>/Configuration/database-configuration-with-bind</code> endpoint. You will see the same response as in the previous section, <em class="italic">Using appsettings.json</em>. In this way, we can use the strongly typed option class to access the configurat<a id="_idTextAnchor144"/>ion settings, such as <code>databaseOption.Type</code>.</p>
<h3>Using the ConfigurationBinder.Get&lt;TOption&gt;() method</h3>
<p>We<a id="_idIndexMarker299"/> can also use the <code>ConfigurationBinder.Get&lt;TOption&gt;()</code> method, which attempts to bind the configuration instance to a new instance of type <code>T</code>. If this configuration section has a value, then that value will be used; otherwise, it attempts to bind the configuration instance by matching property names against configuration keys recursively. The code is shown next:</p>
<pre class="source-code">
[HttpGet][Route("database-configuration-with-generic-type")]
public ActionResult GetDatabaseConfigurationWithGenericType()
{
    var databaseOption = configuration.GetSection(DatabaseOption.SectionName).Get&lt;DatabaseOption&gt;();
    return Ok(new { databaseOption.Type, databaseOption.ConnectionString });
}</pre>
<p>Run the <a id="_idIndexMarker300"/>application and send a request to the <code>/Configuration/database-configuration-with-generic-type</code> endpoint. You will see the same respon<a id="_idTextAnchor145"/>se as in the <em class="italic">Using </em><em class="italic">appsettings.json</em> section.</p>
<h3>Using the IOptions&lt;TOption&gt; interface</h3>
<p>ASP.NET Core<a id="_idIndexMarker301"/> provides built-in DI support for the options pattern. To use DI, we need to register the <code>DatabaseOption</code> class in the <code>Services.Configure()</code> method of the <code>Program.cs</code> file. The following code shows how to register the <code>DatabaseOption</code> class:</p>
<pre class="source-code">
// Register the DatabaseOption class as a configuration object.// This line must be added before the `builder.Build()` method.
builder.Services.Configure&lt;DatabaseOption&gt;(builder.Configuration.GetSection(DatabaseOption.SectionName));
var app = builder.Build();</pre>
<p>Next, we can use DI to inject the <code>IOptions&lt;DatabaseOption&gt;</code> interface into the <code>ConfigurationController</code> class. The following code shows how to inject the <code>IOptions&lt;DatabaseOption&gt;</code> interface:</p>
<pre class="source-code">
[HttpGet][Route("database-configuration-with-ioptions")]
public ActionResult GetDatabaseConfigurationWithIOptions([FromServices] IOptions&lt;DatabaseOption&gt; options)
{
    var databaseOption = options.Value;
    return Ok(new { databaseOption.Type, databaseOption.ConnectionString });
}</pre>
<p>Run the <a id="_idIndexMarker302"/>application and send a request to the <code>/Configuration/database-configuration-with-ioptions</code> endpoint. You will see the same resp<a id="_idTextAnchor146"/>onse as in the <em class="italic">Using </em><em class="italic">appsettings.json</em> section.</p>
<h3>Using other options interfaces</h3>
<p>We have<a id="_idIndexMarker303"/> introduced several ways to use the options pattern. What differences do they have?</p>
<p>Run the application and test the preceding endpoints. You will see all responses are the same, which contains a <code>Type</code> property with the value <code>SQL Server</code>.</p>
<p>Keep the application running. Let's make a change to the <code>appsettings.json</code> file. Change the <code>Type</code> property from <code>SQL Server</code> to <code>MySQL</code>. Save the file and send the requests to these endpoints again. You will find the following results:</p>
<ul>
<li><code>database-configuration</code> returns the <em class="italic">new</em> value <code>MySQL</code></li>
<li><code>database-configuration-with-bind</code> returns the <em class="italic">new</em> value <code>MySQL</code></li>
<li><code>database-configuration-with-generic-type</code> returns the <em class="italic">new</em> value <code>MySQL</code></li>
<li><code>database-configuration-with-ioptions</code> returns the <em class="italic">old</em> value <code>SQL Server</code></li>
</ul>
<p>Let's try to use the <code>IOptionsSnapshot&lt;T&gt;</code> interface to replace the <code>IOptions&lt;TOption&gt;</code> interface. The <code>IOptionsSnapshot&lt;TOption&gt;</code> interface provides a snapshot of options for the current request. The following code shows how to use the <code>IOptionsSnapshot&lt;TOption&gt;</code> interface:</p>
<pre class="source-code">
[HttpGet][Route("database-configuration-with-ioptions-snapshot")]
public ActionResult GetDatabaseConfigurationWithIOptionsSnapshot([FromServices] IOptionsSnapshot&lt;DatabaseOption&gt; options)
{
    var databaseOption = options.Value;
    return Ok(new { databaseOption.Type, databaseOption.ConnectionString });
}</pre>
<p>Run the <a id="_idIndexMarker304"/>application again. Change the <code>Type</code> property in the <code>appsettings.json</code> file. Send requests to the <code>/Configuration/database-configuration-with-ioptions-snapshot</code> endpoint. You will find the response is the <em class="italic">new</em> value.</p>
<p>Okay, we now know the difference between the <code>IOptions&lt;TOption&gt;</code> interface and the <code>IOptionsSnapshot&lt;TOption&gt;</code> interface:</p>
<ul>
<li>The <code>IOptions&lt;TOption&gt;</code> interface provides a way to access options, but it cannot get the latest value if the setting value has been changed when the application is running.</li>
<li>The <code>IOptionsSnapshot&lt;TOption&gt;</code> interface provides a snapshot of options for the current request. The <code>IOptionsSnapshot&lt;TOption&gt;</code> interface is useful when we want to get the latest options for the current request.</li>
</ul>
<p>But why?</p>
<p>The ASP.NET Core framework provides built-in support for <code>appsetting.json</code> using <code>JsonConfigurationProvider</code>, which reads the configuration values from the <code>appsettings.json</code> file. When the framework registers <code>JsonConfigurationProvider</code>, the code looks like this:</p>
<pre class="source-code">
config.AddJsonFile("appsettings.json", optional: true, reloadOnChange: true)  .AddJsonFile($"appsettings.{env.EnvironmentName}.json", optional: true, reloadOnChange: true);</pre>
<p>The <code>reloadOnChange</code> parameter is set to <code>true</code>, which means the configuration values will be reloaded if the <code>appsettings.json</code> file has been changed. So, the <code>ConfigurationBinder.Bind()</code> method and the <code>ConfigurationBinder.Get&lt;TOption&gt;()</code> method can get the latest value.</p>
<p>However, when the <code>IOptions&lt;TOption&gt;</code> interface is registered by the ASP.NET Core framework, it is registered as a <em class="italic">singleton</em> service, which means an instance of <code>IOption&lt;TOption&gt;</code> will be created only once. You can inject it into any service lifetime, but it cannot read the latest value if the setting value has been changed.</p>
<p>In contrast, the <code>IOptionsSnapshot&lt;TOption&gt;</code> interface is registered as a <em class="italic">scoped</em> service, so<a id="_idIndexMarker305"/> it cannot be injected into a singleton service. It is useful in scenarios if you want to get the latest options for each request.</p>
<p>It looks like <code>IOptionsSnapshot&lt;TOption&gt;</code> is better than <code>IOptions&lt;TOption&gt;</code>. Not really. <code>IOptionsSnapshot&lt;TOption&gt;</code> can only cache options for the current request. It may cause performance issues because it is recomputed per request. So, you need to choose the interface to use wisely. If the options are not changed, you can use the <code>IOptions&lt;TOption&gt;</code> interface. If the options are changed frequently and you want to ensure the app gets the latest value per request, you can use the <code>IOptionsSnapshot&lt;TOption&gt;</code> interface.</p>
<p>There is another options interface called <code>IOptionsMonitor&lt;TOption&gt;</code>. It is a combination of the <code>IOptions&lt;TOption&gt;</code> and the <code>IOptionsSnapshot&lt;TOption&gt;</code> interfaces. It provides the following features:</p>
<ul>
<li>It is a singleton service, which can be injected into any service lifetime</li>
<li>It supports reloadable configuration</li>
</ul>
<p>Here is an example of using the <code>IOptionsMonitor&lt;TOption&gt;</code> interface:</p>
<pre class="source-code">
[HttpGet][Route("database-configuration-with-ioptions-monitor")]
public ActionResult GetDatabaseConfigurationWithIOptionsMonitor([FromServices] IOptionsMonitor&lt;DatabaseOption&gt; options)
{
    var databaseOption = options.CurrentValue;
    return Ok(new { databaseOption.Type, databaseOption.ConnectionString });
}</pre>
<p>The <code>IOptionsMonitor&lt;TOption&gt;</code> interface provides the <code>CurrentValue</code> property to get the latest value. It also provides the <code>OnChange(Action&lt;TOption, string&gt; listener)</code> method to register a listener <a id="_idIndexMarker306"/>that will be called whenever the options are reloaded. Normally, you do not need to use the <code>OnChange()</code> method unless you w<a id="_idTextAnchor147"/>ant to do something when the options are reloaded.</p>
<h3>Using named options</h3>
<p>Sometimes, we<a id="_idIndexMarker307"/> need to use multiple database instances in our application. Consider the following scenario:</p>
<pre class="source-code">
{  "Databases": {
    "System": {
      "Type": "SQL Server",
      "ConnectionString": "This is the database connection string for the system database."
    },
    "Business": {
      "Type": "MySQL",
      "ConnectionString": "This is the database connection string for the business database."
    }
  }
}</pre>
<p>Rather than creating two classes to represent the two database options, we can use the named options feature. The following code shows how to use the named options feature for<a id="_idIndexMarker308"/> each section:</p>
<pre class="source-code">
public class DatabaseOptions{
    public const string SystemDatabaseSectionName = "System";
    public const string BusinessDatabaseSectionName = "Business";
    public string Type { get; set; } = string.Empty;
    public string ConnectionString { get; set; } = string.Empty;
}</pre>
<p>Then, register the named options feature in the <code>Program.cs</code> file:</p>
<pre class="source-code">
builder.Services.Configure&lt;DatabaseOptions&gt;(DatabaseOptions.SystemDatabaseSectionName, builder.Configuration.GetSection($"{DatabaseOptions.SectionName}:{DatabaseOptions.SystemDatabaseSectionName}"));builder.Services.Configure&lt;DatabaseOptions&gt;(DatabaseOptions.BusinessDatabaseSectionName, builder.Configuration.GetSection($"{DatabaseOptions.SectionName}:{DatabaseOptions.BusinessDatabaseSectionName}"));</pre>
<p>The following code shows how to access the named options:</p>
<pre class="source-code">
[HttpGet][Route("database-configuration-with-named-options")]
public ActionResult GetDatabaseConfigurationWithNamedOptions([FromServices] IOptionsSnapshot&lt;DatabaseOptions&gt; options)
{
    var systemDatabaseOption = options.Get(DatabaseOptions.SystemDatabaseSectionName);
    var businessDatabaseOption = options.Get(DatabaseOptions.BusinessDatabaseSectionName);
    return Ok(new { SystemDatabaseOption = systemDatabaseOption, BusinessDatabaseOption = businessDatabaseOption });
}</pre>
<p>Run the<a id="_idIndexMarker309"/> application and send a request to the <code>/Configuration/database-configuration-with-named-options</code> endpoint. You will find the response contains the two database options, as shown next:</p>
<pre class="console">
{  "systemDatabaseOption": {
    "type": "SQL Server",
    "connectionString": "This is the database connection string for the system database."
  },
  "businessDatabaseOption": {
    "type": "MySQL",
    "connectionString": "This is the database connection string for the business database."
  }
}</pre>
<p>Now, Let's summarize the options feature in ASP.NET Core:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-3">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p><strong class="bold">Server lifetime</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Reloadable </strong><strong class="bold">configuration</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Named options</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>IOptions&lt;TOption&gt;</code></p>
</td>
<td class="No-Table-Style">
<p>Singleton</p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
<td class="No-Table-Style">
<p>No</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>IOptionsSnapshot&lt;TOption&gt;</code></p>
</td>
<td class="No-Table-Style">
<p>Scope</p>
</td>
<td class="No-Table-Style">
<p>Yes</p>
</td>
<td class="No-Table-Style">
<p>Yes</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>IOptionsMonitor&lt;TOption&gt;</code></p>
</td>
<td class="No-Table-Style">
<p>Singleton</p>
</td>
<td class="No-Table-Style">
<p>Yes</p>
</td>
<td class="No-Table-Style">
<p>Yes</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Figure">Table 3.1 – Summary of the options feature in <code>ASP.NET</code> Core</p>
<p>Next, we will discuss how to register a group of options to make the <code>Program.cs</code> file cleaner.</p>
<h3><a id="_idTextAnchor148"/>Group options registration</h3>
<p>In <a href="B18971_02.xhtml#_idTextAnchor068"><em class="italic">Chapter 2</em></a>, we introduced how to use group registration to register multiple services in an extension method. The group<a id="_idIndexMarker310"/> registration feature is also available for the options feature. The following code shows how to use the group registration feature to register multiple options:</p>
<pre class="source-code">
using ConfigurationDemo;namespace DependencyInjectionDemo;
public static class OptionsCollectionExtensions
{
    public static IServiceCollection AddConfig(this IServiceCollection services, IConfiguration configuration)
    {
        services.Configure&lt;DatabaseOption&gt;(configuration.GetSection(DatabaseOption.SectionName));
        services.Configure&lt;DatabaseOptions&gt;(DatabaseOptions.SystemDatabaseSectionName, configuration.GetSection($"{DatabaseOptions.SectionName}:{DatabaseOptions.SystemDatabaseSectionName}"));
        services.Configure&lt;DatabaseOptions&gt;(DatabaseOptions.BusinessDatabaseSectionName, configuration.GetSection($"{DatabaseOptions.SectionName}:{DatabaseOptions.BusinessDatabaseSectionName}"));
        return services;
    }
}</pre>
<p>Then, register<a id="_idIndexMarker311"/> the options in the <code>Program.cs</code> file:</p>
<pre class="source-code">
builder.Services.AddConfig(builder.Configuration);</pre> <p>Now, the <code>Program.cs</code> file is much cleaner<a id="_idTextAnchor149"/>.</p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor150"/>Other configuration providers</h2>
<p>We mentioned<a id="_idIndexMarker312"/> that ASP.NET Core supports multiple configuration providers. The configuration provider for reading the <code>appsettings.json</code> file is <code>JsonConfigurationProvider</code>, which is derived from the <code>FileConfigurationProvider</code> base class. There are some other implementations of the <code>FileConfigurationProvider</code> base class, such as <code>IniConfigurationProvider</code>, <code>XmlConfigurationProvider</code>, and so on.</p>
<p>Besides <code>JsonConfigurationProvider</code>, the ASP.NET Core framework automatically registers the following configuration providers:</p>
<ul>
<li>A <code>Development</code> environment</li>
<li>A <strong class="bold">non-prefixed environment variables configuration provider</strong> is used to read environment variables that do not have a prefix</li>
<li>A <strong class="bold">command-line configuration provider</strong> is used to read command-line arguments</li>
</ul>
<p>Let us see more details about these configuration provider<a id="_idTextAnchor151"/>s.</p>
<h3>User secrets configuration provider</h3>
<p>It is <a id="_idIndexMarker313"/>not a <a id="_idIndexMarker314"/>good practice to store sensitive information in the <code>appsettings.json</code> file. For example, if the database connection string is stored in the <code>appsettings.json</code> file, developers may accidentally commit the database connection string (or other sensitive information, secrets, and so on) to the source control system, which will cause security issues.</p>
<p>Instead, we<a id="_idIndexMarker315"/> can use the <a id="_idIndexMarker316"/>user secrets feature to store sensitive information in the local secrets file. The user secrets feature is only available in the <code>Development</code> environment. By default, the ASP.NET Core framework registers the user secrets configuration provider after the JSON configuration provider. Therefore, the user secrets configuration provider has higher priority than the JSON configuration provider, so it will override the JSON configuration provider if the same configuration key exists in both providers.</p>
<p>To use user secrets, we need to use the Secret Manager tool to store the secrets in a local secrets file. Run the following command in the project folder to initialize a local secrets file:</p>
<pre class="console">
dotnet user-secrets init</pre> <p>The preceding command creates a <code>UserSecretsId</code> property in the <code>.csproj</code> file. By default, the value of the <code>UserSecretsId</code> property is a GUID, such as the following:</p>
<pre class="source-code">
&lt;PropertyGroup&gt;  &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
  &lt;Nullable&gt;enable&lt;/Nullable&gt;
  &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
  &lt;UserSecretsId&gt;f3351c6a-2508-4243-8d80-89c27758164d&lt;/UserSecretsId&gt;
&lt;/PropertyGroup&gt;</pre>
<p>Then, we can use the Secret Manager tool to store secrets in the local secrets file. Run the following command from the project folder to store secrets:</p>
<pre class="console">
dotnet user-secrets set "Database:Type" "PostgreSQL"dotnet user-secrets set "Database:ConnectionString" "This is the database connection string from user secrets"</pre>
<p>After running the preceding commands, a <code>secrets.json</code> file is created in the <code>%APPDATA%\Microsoft\UserSecrets\&lt;UserSecretsId&gt;</code> folder. The <code>secrets.json</code> file contains the following content:</p>
<pre class="source-code">
{  "Database:Type": "PostgreSQL",
  "Database:ConnectionString": "This is the database connection string from user secrets"
}</pre>
<p>Note that the JSON structure is flattened.</p>
<p class="callout-heading">Location of the secrets.json file</p>
<p class="callout">If you use Linux or macOS, the <code>secrets.json</code> file is created in the <code>~/.</code><code>microsoft/usersecrets/&lt;UserSecretsId&gt;</code> folder.</p>
<p>Run <code>dotnet run</code> to run the application and send a request to the <code>/Configuration/database-configuration</code> endpoint. You will find the response contains the database options from the user secrets, which overrides the database options from the <code>appsettings.json</code> file and contains a PostgreSQL database type.</p>
<p>The<a id="_idIndexMarker317"/> local secrets file is out <a id="_idIndexMarker318"/>of the project folder and not committed to the source control system. Keep in mind that the Secret Manager tool is only for development purposes. Developers should have the responsibility to protect the local secrets file.</p>
<p>There are some commands to operate the local secrets file. You need to run the following commands from the project folder:</p>
<pre class="console">
# List all the secretsdotnet user-secrets list
# Remove a secret
dotnet user-secrets remove "Database:Type"
# Clear all the secrets
dotnet user-secrets clear</pre>
<p class="callout-heading">Important note</p>
<p class="callout">If you download the code example for this section, the secrets file is not included in the repository. You need to run the <code>dotnet user-secrets init</code> command to initialize the secrets file on your local <a id="_idTextAnchor152"/>machine.</p>
<h3>Environment variables configuration provider</h3>
<p>.NET and ASP.NET Core define<a id="_idIndexMarker319"/> some environment variables that can be used to configure the application. These<a id="_idIndexMarker320"/> specific variables have a prefix of <code>DOTNET_</code>, <code>DOTNETCORE_</code>, or <code>ASPNETCORE_</code>. Variables that have the <code>DOTNET_</code> or <code>DOTNETCORE_</code> prefix are used to configure the .NET runtime. Variables that have the <code>ASPNETCORE_</code> prefix are used to configure ASP.NET Core. For example, the <code>ASPNETCORE_ENVIRONMENT</code> variable is used to set the environment name. We will discuss the environment in the <em class="italic">Environments</em> section.</p>
<p>For those environment variables that do not have the <code>ASPNETCORE_</code> prefix, ASP.NET Core can also use the environment variables configuration provider to read them. Environment variables have a higher priority than the <code>appsettings.json</code> file. For example, we have the following configuration in the <code>appsettings.json</code> file:</p>
<pre class="source-code">
{  "Database": {
    "Type": "SQL Server",
    "ConnectionString": "This is the database connection string."
  }
}</pre>
<p>If we set the <code>Database__Type</code> environment variable to <code>MySQL</code>, the <code>Database__Type</code> value in the <code>appsettings.json</code> file will be overridden by the environment variable value. The following code shows how to access an environment variable in PowerShell:</p>
<pre class="source-code">
$Env:&lt;variable-name&gt;</pre> <p>To <a id="_idIndexMarker321"/>represent<a id="_idIndexMarker322"/> the hierarchical keys of environment variables, it is recommended to use  <code>__</code> (double underscore) as a separator because it is supported by all platforms. Please do not use <code>:</code> because it is not supported by Bash.</p>
<p>You can use the following command to set an environment variable in PowerShell:</p>
<pre class="console">
$Env:Database__Type="SQLite"</pre> <p>To check if the environment variable is set correctly, run the following command:</p>
<pre class="console">
$Env:Database__Type</pre> <p class="callout-heading">Important note</p>
<p class="callout">If you use Bash, you need to use the following command to set the environment variable:</p>
<p class="callout"><code>export Database__Type="SQLite"</code></p>
<p class="callout">For more information, please refer to <a href="https://linuxize.com/post/how-to-set-and-list-environment-variables-in-linux/">https://linuxize.com/post/how-to-set-and-list-environment-variables-in-linux/</a>.</p>
<p class="callout">Also, please note that, unlike in Windows, environment variable names are case-sensitive on macOS and Linux.</p>
<p>You will see <a id="_idIndexMarker323"/>the output is <code>SQLite</code>. Now, in the same PowerShell session, you can use <code>dotnet run</code> to run the application and send a request to the <code>/Configuration/database-configuration</code> endpoint. You will find the response <a id="_idIndexMarker324"/>contains the <code>SQLite</code> value, even though the <code>appsettings.json</code> file contains the <code>SQL Server</code> value. That means the environment variable value overrides the <code>appsettings.js<a id="_idTextAnchor153"/>on</code> file value.</p>
<h3>Command-line configuration provider</h3>
<p>Command-line arguments <a id="_idIndexMarker325"/>have a higher priority than environment variables. By default, the<a id="_idIndexMarker326"/> configuration settings set on the command line override values set with other configuration providers.</p>
<p>Following the example in the previous section, the <code>Database__Type</code> value is set to <code>SQL Server</code> in the <code>appsettings.json</code> file. We also set the <code>Database__Type</code> environment variable to <code>SQLite</code>. Now, let us change the value to <code>MySQL</code> in the command-line argument using the following command:</p>
<pre class="console">
dotnet run Database:Type=MySQL</pre> <p>Send a request to the <code>/Configuration/database-configuration</code> endpoint. You will find the response contains the <code>MySQL</code> value, which means the command-line argument value overrides the environment variable value.</p>
<p>Command-line arguments can also be set in the following ways:</p>
<pre class="console">
dotnet run --Database:Type MySQLdotnet run /Database:Type MySQL</pre>
<p>If <code>--</code> or <code>/</code> is used for the key, the value can follow a space. Otherwise, the value must follow the <code>=</code> sign. Please do not mix the two ways in t<a id="_idTextAnchor154"/>he same command.</p>
<h3>Azure Key Vault configuration provider</h3>
<p>Azure Key Vault is a<a id="_idIndexMarker327"/> cloud-based service that provides secure storage for secrets, such as passwords, certificates, and <a id="_idIndexMarker328"/>keys. The Azure Key Vault configuration provider is used to read the secrets from an Azure Key Vault. It is a good choice for running the application in production.</p>
<p>To use it, you need to install the following NuGet packages:</p>
<ul>
<li><code>Azure.Extensions.AspNetCore.Configuration.Secrets</code></li>
<li><code>Azure.Identity</code></li>
</ul>
<p>Azure App Configuration is a cloud-based service that provides a centralized configuration store for managing application settings and feature flags. App Configuration complements Azure Key Vault. It aims to simplify tasks of working with complex application settings. You need to install the following NuGet packages to use the Azure App Configuration provider:</p>
<ul>
<li><code>Microsoft.Azure.AppConfiguration.AspNetCore</code></li>
</ul>
<p>We will not cover details of the Azure Key Vault and Azure App Configuration providers in this book. For more information, please refer to the following links:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/azure/key-vault/general/">https://learn.microsoft.com/en-us/azure/key-vault/general/</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-app-configuration/">https://docs.microsoft.com/en-us/azure/azure-app-configuration/</a></li>
</ul>
<h1 id="_idParaDest-80"><a id="_idTextAnchor156"/>Environments</h1>
<p>In the previous section, we introduced how to read the configuration settings from various resources, including the <code>appsettings.json</code> file, user secrets, environment variables, and command-line arguments. In this section, we will discuss<a id="_idIndexMarker329"/> environments in more detail.</p>
<p>Run the following command to create a new ASP.NET Core web API project:</p>
<pre class="console">
dotnet new webapi -n EnvironmentDemo -controllers</pre> <p>You can download the example project named <code>EnvironmentDemo</code> from the <code>/samples/chapter3/EnvironmentsDemo</code> folder in the chapter's GitHub repository.</p>
<p>We have mentioned the default ASP.NET Core web API template contains an <code>appsettings.json</code> file and an <code>appsettings.Development.json</code> file. When we run the application using <code>dotnet run</code>, the application runs in the <code>Development</code> environment. So the configuration settings in the <code>appsettings.Development.json</code> file override the configuration settings in the <code>appsettings.json</code> file.</p>
<p>Add the <a id="_idIndexMarker330"/>following section to the <code>appsettings.Development.json</code> file:</p>
<pre class="source-code">
{  // Omitted for brevity
  "Database": {
    "Type": "SQL Server",
    "ConnectionString": "This is the database connection string from base appsettings.json."
  }
}</pre>
<p>Then, add the following section to the <code>appsettings.Development.json</code> file:</p>
<pre class="source-code">
{  // Omitted for brevity
  "Database": {
    "Type": "LocalDB",
    "ConnectionString": "This is the database connection string from appsettings.Development.json"
  }
}</pre>
<p class="callout-heading">Important note</p>
<p class="callout">Note that user secrets have higher priority than the <code>appsettings.Development.json</code> file. So, if you configured the local user secrets in the previous section, please clear the secrets.</p>
<p>Create a<a id="_idIndexMarker331"/> new controller named <code>ConfigurationController.cs</code> and add the following code:</p>
<pre class="source-code">
using Microsoft.AspNetCore.Mvc;namespace EnvironmentsDemo.Controllers;
[ApiController]
[Route("[controller]")]
public class ConfigurationController(IConfiguration configuration) : ControllerBase
{
    private readonly IConfiguration _configuration;
    public ConfigurationController(IConfiguration configuration)
    {
        _configuration = configuration;
    }
    [HttpGet]
    [Route("database-configuration")]
    public ActionResult GetDatabaseConfiguration()
    {
        var type = configuration["database:Type"];
        var connectionString = configuration["Database:ConnectionString"];
        return Ok(new { Type = type, ConnectionString = connectionString });
    }
}</pre>
<p>Run the <a id="_idIndexMarker332"/>application using <code>dotnet run</code>. Send the request to the <code>/Configuration/database-configuration</code> endpoint. You will find the response contains a <code>LocalDB</code> value, which means the <code>appsettings.Development.json</code> file overrides the <code>appsettings.json</code> file.</p>
<p>So, where is the environment<a id="_idTextAnchor157"/> name <code>Development</code> set?</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor158"/>Understanding the launchSettings.json file</h2>
<p>Open <a id="_idIndexMarker333"/>the <code>launchSettings.json</code> file in the <code>Properties</code> folder. You will find the <code>ASPNETCORE_ENVIRONMENT</code> environment variable is set to <code>Development</code>:</p>
<pre class="source-code">
  "profiles": {    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "http://localhost:5161",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "https://localhost:7096;http://localhost:5161",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "launchUrl": "swagger",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }</pre>
<p>The <code>launchSettings.json</code> file is used to configure the local development environment. It is not deployable. The default <code>launchSettings.json</code> file contains three <a id="_idIndexMarker334"/>profiles: <code>http</code>, <code>https</code>, and <code>IIS Express</code>:</p>
<ul>
<li>The <code>http</code> profile is used to run the application with the HTTP protocol</li>
<li>The <code>https</code> profile is used to run the application with the HTTPS protocol</li>
<li>The <code>IIS Express</code> profile is used to run the application in IIS Express</li>
</ul>
<p>The <code>commandName</code> field in the <code>http</code> and <code>https</code> profiles is <code>Project</code>, which means the Kestrel server is launched to run the application. Similarly, the <code>IISExpress</code> value in the <code>IIS Express</code> profile means the application expects IIS Express to be the web server.</p>
<p class="callout-heading">What is the Kestrel server?</p>
<p class="callout">Kestrel is a cross-platform web server for ASP.NET Core. Kestrel is included and enabled by default in ASP.NET Core project templates. ASP.NET Core can also be hosted in IIS (or IIS Express), but IIS is not cross-platform. So, Kestrel is the preferred web server for ASP.NET Core applications.</p>
<p>When <a id="_idIndexMarker335"/>running <code>dotnet run</code>, the first profile with the <code>commandName</code> value, <code>Project</code>, is used. For the demo project, the <code>http</code> profile is used. The <code>ASPNETCORE_ENVIRONMENT</code> environment variable is set to <code>Development</code> in the <code>http</code> profile. So, the application runs in the <code>Development</code> environment. You can see the output in the console:</p>
<pre class="console">
Building...info: Microsoft.Hosting.Lifetime[14]
      Now listening on: http://localhost:5161
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Development
info: Microsoft.Hosting.Lifetime[0]
      Content root path: C:\dev\web-api-with-asp-net\example_code\chapter3\EnvironmentsDemo</pre>
<p>We can specify the profile to use when running the application using the <code>--</code><code>launch-profile</code> argument:</p>
<pre class="console">
dotnet run --launch-profile https</pre> <p>Note that this approach is only available for Kestrel profiles. You cannot use this argument to run the application in IIS Express.</p>
<p>If you use <a id="_idIndexMarker336"/>VS 2022 to open the project, you can choose which profile to use, like this:</p>
<div><div><img alt="Figure 3.1 – Choosing a profile to ﻿use in Visual Studio 2022" src="img/Figure_3.1_B18971.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Choosing a profile to <a id="_idTextAnchor159"/>use in Visual Studio 2022</p>
<p>Next, let's explore how to configure the application to run in the <code>Production</code> environment.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor160"/>Setting the environment</h2>
<p>There<a id="_idIndexMarker337"/> are several ways to change the environment. Let's create a new file named <code>appsettings.Production.json</code>. This configuration file will be used for the <code>Production</code> environment. Add the following section to the file:</p>
<pre class="source-code">
{  // Omitted for brevity
  "Database": {
    "Type": "PostgreSQL",
    "ConnectionString": "This is the database connection string from appsettings.Production.json"
  }
}</pre>
<p>Next, we <a id="_idIndexMarker338"/>will specify the environment as <code>Production</code> t<a id="_idTextAnchor161"/>o apply this configuration.</p>
<h3>Using the launchSettings.json file</h3>
<p>For development purposes, we <a id="_idIndexMarker339"/>can create a new profile in the <code>launchSettings.json</code> file, which specifies the <code>ASPNETCORE_ENVIRONMENT</code> variable as <code>Production</code>. Add the following section to the <code>launchSettings.json</code> file:</p>
<pre class="source-code">
// Omitted for brevity  "profiles": {
    // Omitted for brevity
    "production": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "https://localhost:7096;http://localhost:5161",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Production"
      }
    }
    // Omitted for brevity
  }</pre>
<p>Use the following command to run the application in the <code>Production</code> environment:</p>
<pre class="console">
dotnet run --launch-profile production</pre> <p>You will <a id="_idIndexMarker340"/>see in the console that the application runs in the <code>Production</code> environment:</p>
<pre class="console">
PS C:\dev\web-api-with-asp-net\example_code\chapter3\EnvironmentsDemo&gt; dotnet run --launch-profile productionBuilding...
warn: Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServer[8]
      The ASP.NET Core developer certificate is not trusted. For information about trusting the ASP.NET Core developer certificate, see https://aka.ms/aspnet/https-trust-dev-cert.
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: https://localhost:7096
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: http://localhost:5161
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Production
info: Microsoft.Hosting.Lifetime[0]
      Content root path: C:\dev\web-api-with-asp-net\example_code\chapter3\EnvironmentsDemo</pre>
<p>It looks good. Let's try to access the <code>/Configuration/database-configuration</code> endpoint. You will see the response is from the <code>appsettin<a id="_idTextAnchor162"/>gs.Production.json</code> file.</p>
<h3>Using the ASPNETCORE_ENVIRONMENT  environment variable</h3>
<p>You can also set the <code>ASPNETCORE_ENVIRONMENT</code> environment variable to <code>Production</code> in the current session, as shown next:</p>
<pre class="console">
$Env:ASPNETCORE_ENVIRONMENT = "Production"dotnet run --no-launch-profile</pre>
<p>Furthermore, you <a id="_idIndexMarker341"/>can set the environment variable globally in your system. Use the following command to set the environment variable globally:</p>
<pre class="console">
[Environment]::SetEnvironmentVariable("ASPNETCORE_ENVIRONMENT", "Production", "Machine")</pre> <p>The <code>Machine</code> argument sets the environment variable globally. You can also set the environment variable for the current user by usi<a id="_idTextAnchor163"/>ng the <code>User</code> argument.</p>
<h3>Using the --environment argument</h3>
<p>Another<a id="_idIndexMarker342"/> way is to set the environment with the <code>--</code><code>environment</code> argument:</p>
<pre class="console">
dotn<a id="_idTextAnchor164"/>et run --environment Production</pre> <h3>Using the launch.json file in VS Code</h3>
<p>If you use<a id="_idIndexMarker343"/> VS Code to open the project, you can set the environment in the <code>launch.json</code> file in the <code>.vscode</code> folder. When you open an ASP.NET Core project, VS Code will prompt you to add required assets to debug the project. A <code>launch.json</code> file and a <code>tasks.json</code> file will be added to the <code>.vscode</code> folder. If you do not see the prompt, you can open the Command Palette and run the <strong class="bold">.NET: Generate Assets for Build and </strong><strong class="bold">Debug</strong> command.</p>
<p>Open the <code>launch.json</code> file and you will find the following content:</p>
<pre class="source-code">
{  // Omitted for brevity
  "configurations": [
    {
      "name": ".NET Core Launch (web)",
      "type": "coreclr",
      // Omitted for brevity
      "env": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      // Omitted for brevity
    }
  ]
}</pre>
<p>You can <a id="_idIndexMarker344"/>add a new configuration following the existing one. Change the <code>ASPNETCORE_ENVIRONMENT</code> field to <code>Production</code> and use <code>.NET Core Launch (Production)</code> as the name. Save the file. You can now run the application in the <code>Production</code> environment by clicking the green arrow in the debug panel:</p>
<div><div><img alt="Figure 3.2 – Running the application in a specific environment in VS Code" src="img/Figure_3.2_B18971.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Running the application in a specific environment in VS Code</p>
<p class="callout-heading">Important note</p>
<p class="callout">The <code>launch.json</code> file is only used in VS Code <code>dotnet </code><code>run</code> command.</p>
<h3>Using the launchSettings.json file in Visual Studio 2022</h3>
<p>Visual Studio 2022 <a id="_idIndexMarker345"/>provides a <strong class="bold">Launch Profiles</strong> dialog to set up the environment variables. You have multiple ways to open the <strong class="bold">Launch </strong><strong class="bold">Profiles</strong> dialog:</p>
<ul>
<li>Open the <strong class="bold">Debug</strong> menu | <em class="italic">&lt;Your project name&gt;</em> <strong class="bold">Debug Properties</strong>.</li>
<li>Click the arrow next to the green arrow in the debug panel and select <em class="italic">&lt;Your project name&gt;</em> <strong class="bold">Debug Properties</strong>.</li>
<li>Right-click the project in the <strong class="bold">Solution Explorer</strong> window and select <strong class="bold">Properties</strong>. In the <strong class="bold">Debug / General</strong> tab, click the <strong class="bold">Open debug launch profiles </strong><strong class="bold">UI</strong> link.</li>
</ul>
<p>Then, you can see the <strong class="bold">Launch </strong><strong class="bold">Profiles</strong> dialog:</p>
<div><div><img alt="Figure 3.3 – The Launch Profiles dialog in Visual Studio 2022" src="img/Figure_3.3_B18971.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – The Launch Profiles dialog in Visual Studio 2022</p>
<p>If you <a id="_idIndexMarker346"/>make changes here, you need to restart the application to apply the changes.</p>
<p>We have learned how to set the environment. With the environment set, we can use different configurat<a id="_idTextAnchor166"/>ions for different environments.</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor167"/>Understanding the priorities of configuration and environment variables</h2>
<p>We introduced <a id="_idIndexMarker347"/>quite a few different ways to read configuration values and environment variables. Let us see how configuration and environment variables are prioritized.</p>
<p>The following table shows the priorities of the configuration sources (the lowest number has the highest priority):</p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-2">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Source</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Priority</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Command-line arguments</p>
</td>
<td class="No-Table-Style">
<p>1</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Non-prefixed environment variables</p>
</td>
<td class="No-Table-Style">
<p>2</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>User secrets (<code>Development</code> environment only)</p>
</td>
<td class="No-Table-Style">
<p>3</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>appsettings.{Environment}.json</code></p>
</td>
<td class="No-Table-Style">
<p>4</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>appsettings.json</code></p>
</td>
<td class="No-Table-Style">
<p>5</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Figure">Table 3.2 – Priorities of configuration sources</p>
<p>If other configuration providers are registered in the <code>Program.cs</code> file, the later registered providers have higher priority than the earlier registered providers.</p>
<p>In <a id="_idIndexMarker348"/>terms of environment variables such as <code>ASPNETCORE_ENVIRONMENT</code>, the following table shows the priorities:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table003-2">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Source</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Priority</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Command-line arguments</p>
</td>
<td class="No-Table-Style">
<p>1</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>launchSettings.json</code> (development purposes only)</p>
</td>
<td class="No-Table-Style">
<p>2</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Environment variable in the current process</p>
</td>
<td class="No-Table-Style">
<p>3</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>System environment variable</p>
</td>
<td class="No-Table-Style">
<p>4</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Figure">Table 3.3 – Priorities of environment variables</p>
<p>Note that there are some other ways to configure the environment that are not listed in the preceding table. For example, if you deploy the ASP.NET Core application to Azure App Service, you can set the <code>ASPNETCORE_ENVIRONMENT</code> environment variable in the App Service configuration. For Linux apps and container apps, Azure App Service passes these settings to the container using the <code>--env</code> flag to set the environment variable in the container.</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor168"/>Checking the environment in the code</h2>
<p>Keep <a id="_idIndexMarker349"/>running the application in the <code>Production</code> environment. Let's try to access the Swagger UI page: <code>http://localhost:5161/swagger</code>. You will find it shows a <code>404 Not Found</code> error. Why?</p>
<p>This is because the Swagger UI page is only enabled in the <code>Development</code> environment. You can see the code in the <code>Program.cs</code> file:</p>
<pre class="source-code">
if (app.Environment.IsDevelopment()){
    app.UseSwagger();
    app.UseSwaggerUI();
}</pre>
<p>The preceding code means that the Swagger UI page is enabled for the development environment only.</p>
<p>The three environment names, <code>Development</code>, <code>Staging</code>, and <code>Production</code>, are predefined in the ASP.NET Core framework, as shown next:</p>
<pre class="source-code">
public static class Environments{
    public static readonly string Development = "Development";
    public static readonly string Staging = "Staging";
    public static readonly string Production = "Production";
}</pre>
<p>The <code>app.Environment.IsDevelopment()</code> method checks the current environment. If the current environment is <code>Development</code>, the Swagger UI page is enabled. Otherwise, it is disabled.</p>
<p>To set the environment in code, use the following code when creating <code>WebApplicationBuilder</code>:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(new WebApplicationOptions{
    EnvironmentName = Environments.Staging
});</pre>
<p>The<a id="_idIndexMarker350"/> environment name is stored in the <code>IHostEnvironment.EnvironmentName</code> property. You can define your own environment names. For example, you can define an environment name such as <code>Test</code>. But the framework provides built-in methods, such as <code>IsDevelopment()</code>, <code>IsStaging()</code>, and <code>IsProduction()</code>, to check the environment. If you define your own environment names, you can use the <code>IHostEnvironment.IsEnvironment(string environmentName)</code> method to check the environment.</p>
<p>We can use the <code>System.Environment</code> class to get the environment variable in the code, such as <code>ASPNETCORE_ENVIRONMENT</code>. Add the following code to the <code>Program.cs</code> file:</p>
<pre class="source-code">
// Omitted for brevityvar app = builder.Build();
// Read the environment variable ASPNETCORE_ENVIRONMENT
var environmentName = Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT");
Console.WriteLine($"ASPNETCORE_ENVIRONMENT is {environmentName}");</pre>
<p>Run the application, and you can see the <code>ASPNETCORE_ENVIRONMENT</code> environment variable in the console:</p>
<pre class="console">
PS C:\dev\web-api-with-asp-net\example_code\chapter3\EnvironmentsDemo&gt; dotnet runBuilding...
ASPNETCORE_ENVIRONMENT is Development
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: http://localhost:5161
# Omitted for brevity</pre>
<p class="callout-heading">What should we do for different environments?</p>
<p class="callout">For the development environment, we can enable the Swagger UI page, show detailed error messages, output debugging information, and so on. For the production environment, we should configure the application for best performance and maximum security. Consider the following points for the production environment:</p>
<ul>
<li class="callout">Disable the Swagger UI page.</li>
<li class="callout">Disable detailed error messages.</li>
<li class="callout">Show a friendly error message.</li>
<li class="callout">Do not output debugging information.</li>
<li class="callout">Enable cache.</li>
<li class="callout">Enable HTTPS.</li>
<li class="callout">Enable the response compression.</li>
<li class="callout">Enable monitoring and logging.</li>
</ul>
<h1 id="_idParaDest-85"><a id="_idTextAnchor169"/>Summary</h1>
<p>In this chapter, we explored three important components of ASP.NET Core: routing, configuration, and environments. We discussed how to configure routing for an ASP.NET Core web API application and how to read parameters from the request. Additionally, we learned how to read configuration values from various sources, such as <code>appsettings.json</code>, environment variables, and command-line arguments. We also explored how to read configurations based on the environment, allowing us to enable different features for different environments.</p>
<p>In the next chapter, we will learn about two more essential components of ASP.NET Core: logging and middleware.</p>
</div>
</body></html>