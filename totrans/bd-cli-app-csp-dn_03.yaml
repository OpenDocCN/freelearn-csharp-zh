- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Basic Concepts of Console Applications in .NET
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET 控制台应用程序的基本概念
- en: Now that our development environment has been set up, it’s time to start our
    journey through the development of CLI applications using .NET.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了开发环境，是时候开始使用 .NET 开发 CLI 应用程序之旅了。
- en: However, first, we will explore console applications!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，首先，我们将探索控制台应用程序！
- en: 'You’re probably familiar with console applications, and you may be wondering
    why we need to discuss console applications in a book dedicated to CLI applications.
    The reason is that at the core of every CLI application is a console application.
    That’s why, in this chapter, we’ll take a moment to explore console applications.
    Plus, you know what they say: a reminder never hurts 😉.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对控制台应用程序很熟悉，你可能想知道为什么我们需要在一本关于 CLI 应用程序的书中讨论控制台应用程序。原因在于每个 CLI 应用程序的核心都是一个控制台应用程序。这就是为什么在本章中，我们将花一点时间来探索控制台应用程序。此外，你知道他们说什么：提醒从不伤害人
    😉。
- en: Console applications can be seen as the simplest CLI applications one can build.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序可以被视为可以构建的最简单的 CLI 应用程序。
- en: Hence, by exploring how we create, run, and interact with a console application,
    we will gain a basic understanding of how to work with CLI applications and how
    to build them by leveraging the console application template provided with the
    .NET SDK.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过探索我们如何创建、运行和交互控制台应用程序，我们将获得如何使用 CLI 应用程序以及如何利用 .NET SDK 提供的控制台应用程序模板来构建它们的基本理解。
- en: We will then create a very simple .NET console application, which takes some
    arguments as input and displays a message as an output. We will then enhance this
    application so it can perform some basic validations on the inputs and display
    the appropriate message as an output. This message will be displayed in a given
    color, depending on its severity.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个非常简单的 .NET 控制台应用程序，它接受一些输入参数并显示一条消息作为输出。然后我们将增强这个应用程序，使其能够对输入进行一些基本验证，并显示适当的消息作为输出。这条消息将根据其严重性以给定颜色显示。
- en: 'Specifically, the chapter covers the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，本章涵盖了以下主题：
- en: Learn how to create and execute console applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何创建和执行控制台应用程序
- en: Leverage the `System.Console` class for reading user input and outputting responses
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 `System.Console` 类读取用户输入并输出响应
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter03/helloConsole](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter03/helloConsole).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书配套的 GitHub 仓库中找到，[https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter03/helloConsole](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter03/helloConsole)。
- en: Creating (and executing) a simple console application
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建（并执行）一个简单的控制台应用程序
- en: Let’s start by opening Visual Studio Code and displaying the integrated terminal
    window by going to **View** | **Terminal**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开 Visual Studio Code 并通过转到 **视图** | **终端** 来显示集成终端窗口开始。
- en: Next, position yourself where you want the code folder to be created (I always
    create a `code` folder in my `C:` drive where all my code folders are located;
    I find it convenient to centralize all my code at the same location).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，确定你想要创建代码文件夹的位置（我总是在我的 `C:` 驱动器上的 `code` 文件夹中创建代码文件夹；我发现将所有代码集中在一个位置很方便）。
- en: 'After ensuring that you are in the right working directory, type the following
    command to create a .NET console application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保你处于正确的工作目录后，输入以下命令以创建一个 .NET 控制台应用程序：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s break down this command to understand what it does:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个命令来了解它做了什么：
- en: '`dotnet new console`: This will ask the .NET CLI tool to create a new console
    application. This will use C# as a language and .NET 8 as a framework (since these
    are the default values).'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet new console`：这将要求 .NET CLI 工具创建一个新的控制台应用程序。这将使用 C# 作为语言，.NET 8 作为框架（因为这些是默认值）。'
- en: '`-n helloConsole`: Our application will be named `helloConsole`.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-n helloConsole`：我们的应用程序将被命名为 `helloConsole`。'
- en: '`-o helloConsole`: A `helloConsole` folder will be created that will contain
    all the code files for our application.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-o helloConsole`：将创建一个名为 `helloConsole` 的文件夹，其中将包含我们应用程序的所有代码文件。'
- en: '`--use-program-main`: The `Program` class containing the `Main` method will
    be added to the created `Program.cs` file. This method is the entry point of our
    program, and we will use its parameter to pass input values to our console application
    when we execute it. You can skip using `--use-program-main`, of course, but I
    prefer using it since it makes the `Program` class more explicit and familiar
    to developers coming from older versions of .NET.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--use-program-main`：将包含 `Main` 方法的 `Program` 类添加到创建的 `Program.cs` 文件中。此方法是程序的入口点，我们在执行程序时将通过其参数将输入值传递给我们的控制台应用程序。当然，你可以跳过使用
    `--use-program-main`，但我更喜欢使用它，因为它使 `Program` 类对从旧版 .NET 版本迁移的开发者来说更加明确和熟悉。'
- en: 'Once the command completes, you should see an output that looks like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 命令执行完成后，你应该会看到一个类似以下输出的内容：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This confirms that the application has been successfully created.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这确认了应用程序已成功创建。
- en: A brief tour of the generated project
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 生成项目的简要浏览
- en: 'The generated project contains three files:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 生成项目包含三个文件：
- en: '- `Main` method). While it may contain all the application’s logic in very
    simple applications, it usually serves as a starting point, delegating to other
    classes and methods as needed.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '- `Main` 方法（）。虽然在非常简单的应用程序中它可能包含所有应用程序的逻辑，但它通常作为起点，根据需要委托给其他类和方法。'
- en: '- `.csproj`) file is essential for .NET development as it centralizes project
    configuration, making it easier to manage, build, and share projects across different
    development environments and build systems. It’s particularly important in the
    modern .NET ecosystem, which emphasizes cross-platform development and flexible
    project structures. In this file, we typically find information about the project
    definition, the build configuration, the dependency management (both project references
    and references to NuGet packages), the compilation settings, resource inclusion,
    any build process customization, project-wide properties (such as assembly name
    and version), cross-platform compatibility, and IDE integration.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '- `.csproj` 文件对于 .NET 开发至关重要，因为它集中管理项目配置，使得管理、构建和在不同开发环境和构建系统之间共享项目变得更加容易。在现代
    .NET 生态系统（该生态系统强调跨平台开发和灵活的项目结构）中尤为重要。在此文件中，我们通常可以找到有关项目定义、构建配置、依赖关系管理（包括项目引用和
    NuGet 包的引用）、编译设置、资源包含、任何构建过程自定义、项目范围内的属性（如程序集名称和版本）、跨平台兼容性和 IDE 集成的信息。'
- en: '- `.sln`) file is a text-based file that serves as a container for organizing
    and managing related projects. It plays a crucial role in the development workflow,
    especially for larger applications that comprise multiple projects. Its purpose
    is to organize multiple related projects into a single solution, define build
    configurations and platforms for all projects, store solution-wide settings and
    metadata, and allow Visual Studio to load all related projects simultaneously.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '- `.sln` 文件是一个基于文本的文件，用作组织和管理相关项目的容器。它在开发工作流程中扮演着至关重要的角色，尤其是在由多个项目组成的大型应用程序中。其目的是将多个相关项目组织成一个单一解决方案，为所有项目定义构建配置和平台，存储解决方案范围内的设置和元数据，并允许
    Visual Studio 同时加载所有相关项目。'
- en: 'Now, let’s load the project into Visual Studio Code by typing this command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过输入以下命令将项目加载到 Visual Studio Code 中：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A new instance of Visual Studio Code will open, and you’ll see the content
    of the newly created project, which looks like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将打开一个新的 Visual Studio Code 实例，你将看到新创建的项目内容，其外观如下：
- en: '![Figure 3.1 – The helloConsole project opened in Visual Studio Code](img/B22400_03_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 在 Visual Studio Code 中打开的 helloConsole 项目](img/B22400_03_01.jpg)'
- en: Figure 3.1 – The helloConsole project opened in Visual Studio Code
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 在 Visual Studio Code 中打开的 helloConsole 项目
- en: Do not confuse code with code!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆代码与代码！
- en: The preceding `code` command is the executable name for Visual Studio Code.
    It should not be confused with the `code` folder 😉.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `code` 命令是 Visual Studio Code 的可执行名称。它不应与 `code` 文件夹混淆 😉。
- en: 'The code contained in the `Main` method of the `Program.cs` file doesn’t do
    much at the moment. In fact, it only displays a `"Hello, World!"` message when
    the application is executed:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program.cs` 文件中的 `Main` 方法当前不包含太多代码。事实上，当应用程序执行时，它只显示一条 `"Hello, World!"`
    消息：'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s execute this application and see what it returns. For that matter, we
    will need to type this command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行此应用程序并查看它返回的内容。为此，我们需要输入以下命令：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It is important to note that this command can be executed in any terminal:
    the PowerShell terminal, the CMD console, or the Bash terminal (if you are running
    Linux or macOS). However, since we are using Visual Studio Code, the easiest way
    to run commands is to use the integrated terminal within Visual Studio Code. That
    being said, you must ensure that you are in the project folder, which means that
    the `dotnet run` command should be executed in the same working directory as the
    `.``csproj` file.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这个命令可以在任何终端中执行：PowerShell终端、CMD控制台或Bash终端（如果你正在运行Linux或macOS）。然而，由于我们正在使用Visual
    Studio Code，最简单的方法是使用Visual Studio Code中的集成终端来运行命令。也就是说，你必须确保你处于项目文件夹中，这意味着`dotnet
    run`命令应该在`.csproj`文件相同的当前工作目录中执行。
- en: 'This will build and then execute the application. The output looks like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建并执行应用程序。输出如下所示：
- en: '![Figure 3.2 – Hello, World! output](img/B22400_03_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – Hello, World! 输出](img/B22400_03_02.jpg)'
- en: Figure 3.2 – Hello, World! output
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – Hello, World! 输出
- en: This is not very useful at the moment, is it?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这目前并不很有用，对吧？
- en: However, we can notice that the `Main` method takes an array of strings as an
    argument (that is, as an input parameter). So, let’s use that to pass some parameters
    to our program.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以注意到`Main`方法接受一个字符串数组作为参数（即作为输入参数）。因此，让我们使用它来向我们的程序传递一些参数。
- en: 'First, we modify our application code to show the value of that parameter,
    as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们修改我们的应用程序代码以显示该参数的值，如下所示：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, once executed, our program will display the `Hello` message, followed by
    the value we passed in as a parameter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦执行，我们的程序将显示`Hello`消息，然后是作为参数传递的值。
- en: 'Let’s try it:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result will be as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![Figure 3.3 – Passing in one parameter](img/B22400_03_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 传递一个参数](img/B22400_03_03.jpg)'
- en: Figure 3.3 – Passing in one parameter
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 传递一个参数
- en: 'We can, of course, pass in more than one parameter, like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以传递多个参数，如下所示：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This time, the result will be as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，结果将如下所示：
- en: '![Figure 3.4 – Passing in more than one parameter](img/B22400_03_04.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 传递多个参数](img/B22400_03_04.jpg)'
- en: Figure 3.4 – Passing in more than one parameter
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 传递多个参数
- en: Important note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'There are three remarks you need to be aware of:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个注意事项你需要注意：
- en: 1\. The parameter to be passed to the `Main` method is an array of **strings**.
    This means that you’ll need to parse these strings if the program is expecting
    an input of another data type (such as an integer, for example).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 传递给`Main`方法的参数是一个字符串数组。这意味着如果程序期望输入另一种数据类型（例如整数），你需要解析这些字符串。
- en: 2\. Since this parameter is an array of strings, you can use the passed-in values
    by specifying their index, which represents their position from the program execution.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 由于这个参数是一个字符串数组，你可以通过指定它们的索引来使用传递的值，这代表它们从程序执行的位置。
- en: 3\. If you use a parameter value in the code but don’t pass it when executing
    the program, an exception will be thrown.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 如果你在代码中使用参数值但在执行程序时没有传递它，将会抛出异常。
- en: What do these remarks mean from a code perspective? Let’s consider some illustrative
    examples.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码的角度来看，这些注意事项意味着什么？让我们考虑一些说明性的例子。
- en: First, we’ll address the first remark. This example shows that the input parameter
    is of the `string` type despite its value, `42`, representing an integer. In order
    to use that value as an integer, we need to parse it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将解决第一个注意事项。这个例子表明，尽管其值`42`代表整数，但输入参数的类型是`string`。为了将此值用作整数，我们需要解析它。
- en: '![Figure 3.5 – Parsing input parameters](img/B22400_03_05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 解析输入参数](img/B22400_03_05.jpg)'
- en: Figure 3.5 – Parsing input parameters
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 解析输入参数
- en: Next, let’s consider the second remark. This example shows that by switching
    the indexes of the parameters, we also switch the display of their values.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑第二个注意事项。这个例子表明，通过交换参数的索引，我们也会交换它们值的显示。
- en: '![Figure 3.6 – Switching input parameters](img/B22400_03_06.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 切换输入参数](img/B22400_03_06.jpg)'
- en: Figure 3.6 – Switching input parameters
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 切换输入参数
- en: Finally, regarding the third remark, this example demonstrates that failing
    to provide a value for the input parameter when executing the program will cause
    it to crash and throw an exception.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于第三个注意事项，这个例子演示了在执行程序时未能为输入参数提供值会导致程序崩溃并抛出异常。
- en: '![Figure 3.7 – Missing an input parameter](img/B22400_03_07.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 缺少输入参数](img/B22400_03_07.jpg)'
- en: Figure 3.7 – Missing an input parameter
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 缺少输入参数
- en: We now know how to create and execute .NET console applications. Let’s see how
    we can interact with user inputs and better format our outputs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何创建和执行 .NET 控制台应用程序。让我们看看我们如何与用户输入交互并更好地格式化我们的输出。
- en: Working with the System.Console class
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 System.Console 类
- en: You may have noticed that in all our examples up to this point, we have used
    the `Console` class. More specifically, we only used one of its methods (namely
    `WriteLine`). This method displays the value of the expression passed as a parameter,
    and then gets to the next line. If we don’t want to get to the next line, we can
    use the `Write` method instead.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，到目前为止的所有示例中，我们都使用了 `Console` 类。更具体地说，我们只使用了它的一种方法（即 `WriteLine`）。这个方法显示传递给参数的表达式的值，然后转到下一行。如果我们不想转到下一行，我们可以使用
    `Write` 方法代替。
- en: However, the `Console` class provides other useful properties and methods. We
    won’t go into the details of all of them (for that matter, I’d recommend that
    you visit [https://learn.microsoft.com/en-us/dotnet/api/system.console](https://learn.microsoft.com/en-us/dotnet/api/system.console)).
    Instead, I’ll highlight the most interesting ones when it comes to console applications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Console` 类提供了其他有用的属性和方法。我们不会详细介绍所有这些（实际上，我建议你访问 [https://learn.microsoft.com/en-us/dotnet/api/system.console](https://learn.microsoft.com/en-us/dotnet/api/system.console)）。相反，我将突出显示在控制台应用程序中最有趣的一些。
- en: Useful properties
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的属性
- en: 'There are three properties I would like to tell you about in particular: `BackgroundColor`,
    `ForegroundColor`, and `Title`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个属性我想特别介绍一下：`BackgroundColor`、`ForegroundColor` 和 `Title`。
- en: The first two, as their names suggest, are used to alter the background and
    foreground color of the terminal.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个，正如其名称所暗示的，用于更改终端的背景和前景颜色。
- en: The third one, `Title`, is used to alter the title of the terminal window. Keep
    in mind that you will need to execute the program in an external terminal (not
    in the Visual Studio Code integrated terminal) to see the effect of changing the
    terminal’s title.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个，`Title`，用于更改终端窗口的标题。请记住，您需要在外部终端（而不是 Visual Studio Code 集成终端）中执行程序才能看到更改终端标题的效果。
- en: 'Here is an illustrative example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, at the beginning of the program, we performed a backup of both
    the foreground and the background colors, and we restored them at the end of the
    program.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在程序开始时，我们备份了前景和背景颜色，并在程序结束时恢复它们。
- en: There is no need to do this for the terminal’s title since the set value is
    only effective during the execution of the program.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于终端的标题，没有必要这样做，因为设置的值仅在程序执行期间有效。
- en: Useful methods
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的方法
- en: 'There are also a few interesting (and useful) methods I would like to talk
    about. These are as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想谈谈一些有趣（且有用）的方法。以下是它们：
- en: '`ReadLine`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadLine`'
- en: '`ReadKey`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadKey`'
- en: '`Clear`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear`'
- en: Let’s start with `ReadLine`. This method reads all the characters from the user
    input until they hit *Enter* and returns the user input as a `string`. So, it
    is useful to gather user inputs, such as a name, an age, or an address.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `ReadLine` 开始。这个方法读取用户输入的所有字符，直到他们按下 *Enter* 键，并将用户输入作为 `string` 返回。因此，它对于收集用户输入，如姓名、年龄或地址非常有用。
- en: 'Here is an example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例：
- en: '![Figure 3.8 – Reading user input from the console](img/B22400_03_08.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 从控制台读取用户输入](img/B22400_03_08.jpg)'
- en: Figure 3.8 – Reading user input from the console
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 从控制台读取用户输入
- en: Next, Let’s talk about `ReadKey`. This method reads the character or function
    key the user pressed. It returns an object of the `ConsoleKeyInfo` type, which
    includes information about the pressed key. It also takes an optional Boolean
    parameter that, if set to `true`, will not display the pressed key to the console,
    and if set to `false`, will display it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈 `ReadKey`。这个方法读取用户按下的字符或功能键。它返回一个 `ConsoleKeyInfo` 类型的对象，其中包含有关按下的键的信息。它还接受一个可选的布尔参数，如果设置为
    `true`，则不会在控制台显示按下的键，如果设置为 `false`，则显示。
- en: 'Here’s an example with the Boolean parameter set to `true`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个布尔参数设置为 `true` 的示例：
- en: '![Figure 3.9 – A ReadKey method with the Boolean parameter set to true](img/B22400_03_09.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 将布尔参数设置为 true 的 ReadKey 方法](img/B22400_03_09.jpg)'
- en: Figure 3.9 – A ReadKey method with the Boolean parameter set to true
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 将布尔参数设置为 true 的 ReadKey 方法
- en: 'Now, notice the output when the Boolean parameter is set to `false`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，注意当布尔参数设置为 `false` 时的输出：
- en: '![Figure 3.10 – A ReadKey method with the Boolean parameter set to false](img/B22400_03_10.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10 – 将布尔参数设置为false的ReadKey方法](img/B22400_03_10.jpg)'
- en: Figure 3.10 – A ReadKey method with the Boolean parameter set to false
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 将布尔参数设置为false的ReadKey方法
- en: 'Have you noticed that the pressed key is displayed twice: once after it is
    pressed, and a second time with the output message?'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到按下的键被显示两次：一次是在按下后，另一次是在输出消息时？
- en: By the way, you can visit [https://learn.microsoft.com/en-us/dotnet/api/system.consolekey](https://learn.microsoft.com/en-us/dotnet/api/system.consolekey)
    to find a list of all of the values of the `ConsoleKey` enumeration.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你可以访问[https://learn.microsoft.com/en-us/dotnet/api/system.consolekey](https://learn.microsoft.com/en-us/dotnet/api/system.consolekey)以查找`ConsoleKey`枚举的所有值的列表。
- en: 'Finally, let’s see the `Clear` method. As its name suggests, it clears the
    console:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看`Clear`方法。正如其名所示，它清除了控制台：
- en: '![Figure 3.11 – Clearing the console with the Clear method](img/B22400_03_11.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – 使用Clear方法清除控制台](img/B22400_03_11.jpg)'
- en: Figure 3.11 – Clearing the console with the Clear method
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – 使用Clear方法清除控制台
- en: After the user presses the *C* key, the console is cleared.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下*C*键后，控制台将被清除。
- en: 'This command is typically used in the following scenarios:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令通常用于以下场景：
- en: '**At the startup of the program**: It is used here so that your program gets
    a clean interface by removing all previous outputs from other programs or commands'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在程序启动时**：在这里使用它是为了确保你的程序通过删除来自其他程序或命令的所有先前输出而获得一个干净的界面'
- en: '**When entering a new section or menu item**: This prevents outputs from previous
    sections from polluting the current one'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在进入新部分或菜单项时**：这防止了先前部分的输出污染当前部分'
- en: Useful event
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的事件
- en: If you’ve ever run a CLI application, you’re probably aware of the *Ctrl* +
    *C* or *Ctrl* + *Break* key combinations that make you exit the program at any
    time by terminating it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经运行过CLI应用程序，你可能知道*Ctrl* + *C*或*Ctrl* + *Break*键组合，这可以在任何时候通过终止程序来退出。
- en: In a .NET console application, these key combinations raise an event called
    `CancelKeyPress`. When one of the key combinations is pressed, the event is raised
    and interrupts the operation being executed. Our code can handle this event to
    allow for a graceful shutdown of the program, cleaning and freeing up resources
    before the shutdown.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET控制台应用程序中，这些键组合引发一个名为`CancelKeyPress`的事件。当按下其中一个键组合时，事件被引发并中断正在执行的操作。我们的代码可以处理此事件，以便允许程序优雅地关闭，在关闭前清理和释放资源。
- en: 'Let’s illustrate this with an example. Consider the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来说明这一点。考虑以下代码：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you may notice, this code uses an infinite loop with no exit condition.
    Hence, the only way to exit from it is by using one of the canceling key combinations
    (*Ctrl* + *C* or *Ctrl* + *Break*). However, when pressed, this will abruptly
    terminate the program without giving it a chance to perform some actions in order
    to exit gracefully, such as the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能注意到的，此代码使用了一个没有退出条件的无限循环。因此，从其中退出的唯一方法是使用取消键组合之一（*Ctrl* + *C*或*Ctrl* + *Break*）。然而，当按下时，这将突然终止程序，而不给它机会执行一些动作以优雅地退出，例如以下操作：
- en: Saving the execution state
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存执行状态
- en: Logging out of services
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出服务
- en: Closing database connections
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭数据库连接
- en: 'We will then modify the previous code to handle that termination event, allowing
    the program to gracefully terminate:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改之前的代码以处理该终止事件，允许程序优雅地终止：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, the result of the execution looks like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行的结果看起来像这样：
- en: '![Figure 3.12 – Canceling the current operation](img/B22400_03_12.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12 – 取消当前操作](img/B22400_03_12.jpg)'
- en: Figure 3.12 – Canceling the current operation
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – 取消当前操作
- en: So, if your CLI application interacts with external resources or services (as
    we will do in the upcoming chapters), you should leverage the `Console.CancelKeyPress`
    event.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你的CLI应用程序与外部资源或服务交互（正如我们将在接下来的章节中做的那样），你应该利用`Console.CancelKeyPress`事件。
- en: One more thing
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有一件事
- en: Up to this point, we have executed the program using the .NET CLI `run` command.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用.NET CLI的`run`命令执行了程序。
- en: However, if you are familiar with CLI applications, you will know that this
    type of application is usually executed by the name of its executable file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你熟悉CLI应用程序，你会知道这类应用程序通常通过其可执行文件名来执行。
- en: The first question that comes to mind is “Why have we executed our program using
    the .NET CLI `run` command?”. The answer is “because this is how you will do it
    when developing and testing your CLI application.”
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个浮现的问题可能是“为什么我们使用.NET CLI的`run`命令来执行我们的程序？”。答案是“因为当你开发和测试CLI应用程序时，你就是这样做的。”
- en: The next question that comes to mind is “Well, how do I execute my program using
    its executable?”. The answer to that question is “by reaching the location of
    that executable file and running the program from there.”
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的问题是“那么，我该如何使用它的可执行文件来执行我的程序呢？”这个问题的答案是“通过到达那个可执行文件的位置，并从那里运行程序。”
- en: Let’s see how we do this.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是如何做到这一点的。
- en: 'When you build the program, use the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建程序时，使用以下命令：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will generate the executable file in the `bin\Debug\net8.0` folder on your
    hard drive.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的硬盘上的`bin\Debug\net8.0`文件夹中生成可执行文件。
- en: 'On a Windows machine, this will look like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows机器上，这看起来是这样的：
- en: '![Figure 3.13 – The generated executable file](img/B22400_03_13.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图3.13 – 生成的可执行文件](img/B22400_03_13.jpg)'
- en: Figure 3.13 – The generated executable file
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – 生成的可执行文件
- en: 'To run the program using its executable file name, open a terminal window,
    navigate to that location, and then type the following command (here, we are passing
    `42` as a parameter):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用程序的可执行文件名来运行程序，请打开一个终端窗口，导航到该位置，然后输入以下命令（在这里，我们传递了`42`作为参数）：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result should be similar to this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该类似于这样：
- en: '![Figure 3.14 – Running the program from its executable file](img/B22400_03_14.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图3.14 – 从可执行文件运行程序](img/B22400_03_14.jpg)'
- en: Figure 3.14 – Running the program from its executable file
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – 从可执行文件运行程序
- en: Should I use dotnet run or run the executable file?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该使用`dotnet run`还是运行可执行文件？
- en: 'There are some differences between running the program using the `dotnet run`
    command and running the program from its executable file. Here are the most significant
    ones:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dotnet run`命令运行程序和从其可执行文件运行程序之间有一些区别。以下是最显著的几个：
- en: '- `dotnet run` command builds the project before running it, which ensures
    that we are always running the most up-to-date version of the code. The executable
    file represents the last compiled version of the code.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '- `dotnet run`命令在运行程序之前会构建项目，这确保了我们总是运行代码的最新版本。可执行文件代表代码的最后编译版本。'
- en: '- `dotnet run` is slower (due to the build step) compared to running the program
    from its executable file. While the `dotnet run` command may take a few seconds
    to build and execute the code, the executable file usually executes in a matter
    of milliseconds.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '- `dotnet run`由于构建步骤，比直接从可执行文件运行程序要慢。虽然`dotnet run`命令可能需要几秒钟来构建和执行代码，但可执行文件通常在毫秒内执行。'
- en: It is important to keep this in mind since, during the development phase, you’ll
    likely rely on `dotnet run` to execute your program. However, in the testing and
    production phases, you’ll rely on the name of the executable. So, make sure you
    carefully choose the name for your program (and its executable) 😉.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为在开发阶段，你可能会依赖`dotnet run`来执行你的程序。然而，在测试和生产阶段，你将依赖可执行文件名。所以，确保你仔细选择你程序（及其可执行文件）的名称
    😉。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we explored what lies at the core of a CLI application: a
    console application! This is why it is crucial to learn how to work with console
    applications, as they are the foundation for building more complex CLI applications.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了CLI应用程序的核心：控制台应用程序！这就是为什么学习如何与控制台应用程序一起工作至关重要，因为它们是构建更复杂CLI应用程序的基础。
- en: We saw how we can execute a console application, providing values as input parameters
    and parsing these input parameters’ values in order to convert them into the data
    type expected by our program. We saw how we can gather user inputs through the
    use of the `ReadKey` and `ReadLine` methods of the `Console` class. Finally, we
    saw how we can handle exceptions raised as the result of a missing input parameter
    value.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何执行控制台应用程序，提供输入参数值，并解析这些输入参数值以将它们转换为程序期望的数据类型。我们看到了如何通过使用`Console`类的`ReadKey`和`ReadLine`方法来收集用户输入。最后，我们看到了如何处理由于缺少输入参数值而引发的异常。
- en: However, a CLI application is more than a console one. It contains named parameters,
    flags, and subcommands.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，CLI应用程序不仅仅是控制台应用程序。它包含命名参数、标志和子命令。
- en: In the upcoming chapters, we will see how we can leverage these capabilities
    into a fully functional CLI application. In the next chapter, we will start by
    creating the CLI application and learning how to parse its inputs, including commands,
    flags, and parameters.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到如何利用这些功能构建一个功能齐全的 CLI 应用程序。在下一章中，我们将从创建 CLI 应用程序开始，学习如何解析其输入，包括命令、标志和参数。
- en: Your turn!
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮到你了！
- en: Following along with the provided code is a great way to learn through practice.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随提供的代码是一种通过实践学习的好方法。
- en: 'A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to achieve the following task:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是挑战自己完成任务。因此，我挑战你完成以下任务：
- en: 'Create a console application that does the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个控制台应用程序，执行以下操作：
- en: Sets the title of the terminal window to **GUESSING GAME!**
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将终端窗口的标题设置为 **猜数字游戏！**
- en: Generates a random integer value between 1 and 20
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成一个介于 1 和 20 之间的随机整数
- en: Tells the player that they have three chances to figure out that number
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告诉玩家他们有三次机会猜出那个数字
- en: 'After each player’s trial, it should then do the following:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每位玩家的测试之后，程序应该执行以下操作：
- en: If the player figured out the number, the program displays, in green text, **Congratulations,
    you won!**, along with the number of trials it took the player to figure it out
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家猜出了数字，程序将以绿色文字显示 **恭喜你，你赢了**，以及玩家猜出数字所需的尝试次数
- en: If the player was not able to figure out the number within the three granted
    trials, the program should display, in red text, **Better luck next time! The
    number to be guessed was** along with the value to be guessed
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家在三次尝试内未能猜出数字，程序应以红色文字显示 **下次好运！要猜的数字是** 以及要猜的数值
- en: If the player hits *Enter* without providing a number, the program should consider
    that the value is zero and proceed with it
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家按下 *Enter* 而没有提供数字，程序应将其视为零值并继续执行
- en: If the player hits *Ctrl* + *C*, the program should exit and display, in yellow
    text, **Thank you** **for playing!**
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家按下 *Ctrl* + *C*，程序应退出并显示，以黄色文字显示 **感谢** **您游玩！**
- en: 'Part 2: Foundations of Building CLI Applications'
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：构建 CLI 应用程序的基础
- en: In this part, you will delve into the essential components of CLI application
    development. You'll explore command-line parsing techniques, learning how to effectively
    handle user input and parse arguments using libraries. Next, you'll learn about
    input/output operations and file handling, covering methods to read from and write
    to files, as well as manipulate file streams for efficient data processing. Finally,
    you'll discover best practices for error handling and logging, including implementing
    structured logging with different severity levels, gracefully managing exceptions,
    and providing informative error messages to users while maintaining detailed logs
    for debugging purposes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，你将深入了解 CLI 应用程序开发的必要组件。你将探索命令行解析技术，学习如何有效地使用库处理用户输入和解析参数。接下来，你将了解输入/输出操作和文件处理，包括从文件读取和写入文件的方法，以及如何操纵文件流以进行高效的数据处理。最后，你将发现错误处理和日志记录的最佳实践，包括实现具有不同严重级别的结构化日志、优雅地管理异常，并在保持详细日志以供调试目的的同时，向用户提供信息丰富的错误消息。
- en: 'This part has the following chapters:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 4*](B22400_04.xhtml#_idTextAnchor048)*, Command-Line Parsing*'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 4 章*](B22400_04.xhtml#_idTextAnchor048)*，命令行解析*'
- en: '[*Chapter 5*](B22400_05.xhtml#_idTextAnchor068)*, Input/Output and File Handling*'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 5 章*](B22400_05.xhtml#_idTextAnchor068)*，输入/输出和文件处理*'
- en: '[*Chapter 6*](B22400_06.xhtml#_idTextAnchor084)*, Error Handling and Logging*'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 6 章*](B22400_06.xhtml#_idTextAnchor084)*，错误处理和日志记录*'
