<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-260"><a id="_idTextAnchor259"/>12</h1>
<h1 id="_idParaDest-261"><a id="_idTextAnchor260"/>Code Analysis in Visual Studio</h1>
<p>Thus far, we’ve covered how to refactor our code in a safe, effective, reliable, and productive manner.</p>
<p>In this chapter, we’ll determine areas of code that might need refactoring using code metrics and code analysis tools. Along the way, we’ll cover the following topics:</p>
<ul>
<li>Calculating code metrics in Visual Studio</li>
<li>Performing code analysis in Visual Studio</li>
<li>Exploring advanced code analysis tools</li>
</ul>
<h1 id="_idParaDest-262"><a id="_idTextAnchor261"/>Technical requirements</h1>
<p>The starting code for this chapter is available from GitHub at <a href="https://github.com/PacktPublishing/Refactoring-with-CSharp">https://github.com/PacktPublishing/Refactoring-with-CSharp</a> in the <code>Chapter12/Ch12BeginningCode</code> folder.</p>
<h1 id="_idParaDest-263"><a id="_idTextAnchor262"/>Calculating code metrics in Visual Studio</h1>
<p>Every codebase I’ve ever <a id="_idIndexMarker715"/>worked with has had a few maintainability hot spots. These are areas that are frequently changed, have a higher degree of complexity than <a id="_idIndexMarker716"/>other areas of code, and represent serious quality risks to the software project.</p>
<p>These areas are usually some of the most critical to refactor and they tend to be easily discoverable using <strong class="bold">code metrics</strong>.</p>
<p>Code metrics calculate a handful of useful statistics about every file, class, method, and property in your C# code. This lets you spot hot spots in your code that have significantly higher complexity or lower maintainability. Code metrics can even help you find classes that are too large and likely violate the Single Responsibility Principle (SRP) as we discussed in <a href="B21324_08.xhtml#_idTextAnchor173"><em class="italic">Chapter 8</em></a>.</p>
<p>To calculate code metrics, open your solution in Visual Studio and then click the <strong class="bold">Analyze</strong> menu, followed by <strong class="bold">Calculate Code Metrics</strong>, and then <strong class="bold">For Solution</strong>, as shown in <em class="italic">Figure 12</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 12.1 – Calculating code metrics" src="img/B21324_12_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Calculating code metrics</p>
<p>This will open the <strong class="bold">Code Metrics Results</strong> pane, as <a id="_idIndexMarker717"/>shown in <em class="italic">Figure 12</em><em class="italic">.2</em>:</p>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 12.2 – Code Metrics Results" src="img/B21324_12_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Code Metrics Results</p>
<p>This pane displays a<a id="_idIndexMarker718"/> hierarchical view of your solution, along with the following six metrics:</p>
<ul>
<li><strong class="bold">Lines of Source Code</strong>: The number of lines of code for the class or method.</li>
<li><strong class="bold">Lines of Executable Code</strong>: The lines of source code that ignore blank lines and comments.</li>
<li><code>if</code> statement, loop, switch case, and similar type of branching instruction increases this by 1.</li>
<li><strong class="bold">Maintainability Index</strong>: A calculated <a id="_idIndexMarker719"/>value based on cyclomatic complexity, lines of code, and the number <a id="_idIndexMarker720"/>of operations performed in a method. This value ranges from 0 to 100, indicating how maintainable your code is. Values from 0 to 9 are bad, 10 to 20 are warning areas, and 21 and above are areas to watch.</li>
<li><code>System.Object</code>, which all classes ultimately inherit from.</li>
<li><strong class="bold">Class Coupling</strong>: The number of other classes your code depends on.</li>
</ul>
<p>Each of these metrics is useful individually, but together, they tell a broader picture.</p>
<p>The maintainability index gives you a quick metric for an area of code. Unlike other columns, which sum up values for all code in a class, namespace, or project, the maintainability index acts as an average, which can help you quickly drill into problem areas.</p>
<p>Cyclomatic complexity can identify areas that are hard to test or hard to understand since it identifies the number of distinct paths through a method. <em class="italic">Figure 12</em><em class="italic">.3 </em>illustrates a cyclomatic complexity of the <code>CalculatePrice</code> method:</p>
<div><div><img alt="Figure 12.3 – Calculating cyclomatic complexity" src="img/B21324_12_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Calculating cyclomatic complexity</p>
<p>Here, the <code>CalculatePrice</code> method has a cyclomatic complexity of 4. All methods start with a cyclomatic complexity of 1, representing a single path through the method. Each branching statement, such as the <code>if</code> statements here, increments the cyclomatic complexity by 1, resulting in a total of 4.</p>
<p>I find cyclomatic complexity to be generally useful and try to keep this as low as possible. Keep in mind that cyclomatic complexity is biased against methods that use <code>switch</code> statements since <a id="_idIndexMarker721"/>each <code>case</code> statement adds to the complexity. Simple <code>switch</code> statements with<a id="_idIndexMarker722"/> only a line or two of code are generally not hard to maintain, so treat cyclomatic complexity as only one indicator of code quality. Microsoft recommends a maximum cyclomatic complexity of 10 for each method, but in my experience, I tend to be happiest with a cyclomatic complexity of 7 or less.</p>
<p>Depth of inheritance and class coupling can help you identify places where you may be over-using inheritance or have too high of coupling to other classes, as we covered in <a href="B21324_08.xhtml#_idTextAnchor173"><em class="italic">Chapter 8</em></a>. Microsoft encourages a maximum depth of inheritance of 6 and a maximum class coupling of 9.</p>
<p>The lines of code metrics are quite useful. I find that having many lines of code in a class is frequently one of the greatest signs that a class violates the SRP and needs to be refactored. Similarly, if a method is too large, it’s usually hard to understand, maintain, and test.</p>
<p>I try to keep classes under 200 lines of code and methods to 20 lines or less. In both cases, I look for things I can pull out of the method or class and am hesitant to expand an already large class or method with new logic unless I can pull logic out of the code first.</p>
<p>Keep in mind that these are general guidelines I’ve found generally effective. These are not concrete rules that you<a id="_idIndexMarker723"/> must always follow.</p>
<p>I encourage you to spend<a id="_idIndexMarker724"/> some time looking over code metrics for the sample code for this chapter or some code you maintain. In the case of the code for this chapter, I’m most concerned about the following methods:</p>
<ul>
<li><code>BaggageCalculator.CalculatePrice</code> in the <code>Flight.Baggage</code> namespace has a maintainability index of 58, cyclomatic complexity of 4, and 26 lines of source code</li>
<li><code>FlightScheduler.Search</code>, which takes in a <code>FlightSearch</code> object in the <code>Flight.Scheduling</code> namespace, has a maintainability index of 48, a cyclomatic complexity of 9, a class coupling of 11, and 37 lines of source code</li>
</ul>
<p>Both methods are flagged by the metrics because they have several <code>if</code> statements that they need to run. Neither method is very complex, but at the same time, if either needs to grow significantly more, I’d like to see refactorings like the ones we applied in <a href="B21324_05.xhtml#_idTextAnchor101"><em class="italic">Chapter 5</em></a> to move complexity out of these methods and into other objects.</p>
<p>Now that we’ve covered code metrics, let’s see how code analysis can give us another way of looking at our code.</p>
<h1 id="_idParaDest-264"><a id="_idTextAnchor263"/>Performing code analysis in Visual Studio</h1>
<p>Microsoft knows that as<a id="_idIndexMarker725"/> C# and .NET changes, it can<a id="_idIndexMarker726"/> be very difficult to keep up with evolving standards in a broad and changing language.</p>
<p>To address this, Microsoft gave us tools beyond code metrics in the form of analyzers that inspect our C# code for issues. These analyzers look at our code and flag potential issues and optimizations. This<a id="_idIndexMarker727"/> helps ensure our code complies with <a id="_idIndexMarker728"/>standards and is secure, reliable, and maintainable.</p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor264"/>Analyzing your solution using the default ruleset</h2>
<p>To see an analyzer in<a id="_idIndexMarker729"/> action, build this chapter’s solution in Visual Studio and notice the three warnings that appear in the <strong class="bold">Output</strong> pane, as shown in <em class="italic">Figure 12</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 12.4 – An overview of the build results showing warnings" src="img/B21324_12_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – An overview of the build results showing warnings</p>
<p>These three lines represent separate compiler warnings for the CS8618 code analysis rule, which we’ll look at shortly.</p>
<p>Before we do that, click on the <strong class="bold">View</strong> menu and then select <strong class="bold">Error List</strong>. You should see the same warnings formatted in an easier-to-read manner, as shown in <em class="italic">Figure 12</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 12.5 – An overview of the compiler warnings in Error List" src="img/B21324_12_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – An overview of the compiler warnings in Error List</p>
<p>If these warnings don’t show up, make sure the <strong class="bold">Errors</strong>, <strong class="bold">Warnings</strong>, and <strong class="bold">Messages</strong> buttons are checked, as shown in <em class="italic">Figure 12</em><em class="italic">.5</em>.</p>
<p>Since these warnings are all associated with <code>Airport.cs</code>, let’s review its code:</p>
<pre class="source-code">
public class Airport {
<strong class="bold">  public string Country { get; set; }</strong>
<strong class="bold">  public string Code { get; set; }</strong>
<strong class="bold">  public string Name { get; set; }</strong>
  // Non-relevant code omitted...
}</pre>
<p>When looking at this<a id="_idIndexMarker730"/> code in Visual Studio, you’ll see a “green squiggly” underneath each of these three properties. As shown in <em class="italic">Figure 12</em><em class="italic">.6</em>, hovering the mouse cursor over any of these “squigglies” shows details about the warning or suggestion:</p>
<div><div><img alt="Figure 12.6 – The CS8618 compiler warning associated with the Name property" src="img/B21324_12_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – The CS8618 compiler warning associated with the Name property</p>
<p>In this case, the warning tells us that these three properties are non-nullable, meaning that they are declared as <code>string</code> instead of <code>string?</code>, as we discussed in <a href="B21324_10.xhtml#_idTextAnchor209"><em class="italic">Chapter 10</em></a> when discussing nullability analysis.</p>
<p>Since the default value for any <code>string</code> property in .NET is null and the <code>Airport</code> class doesn’t have any logic to initialize these three properties, the compiler warning is telling us that when <code>Airport</code> instances are created, they’ll have null values in properties we told it couldn’t be null!</p>
<p class="callout-heading">Nullability analysis in .NET</p>
<p class="callout">Remember that although strings are<a id="_idIndexMarker731"/> reference types and can be null, nullability analysis in C# indicates if a property is expected to have a null value at any point in<a id="_idIndexMarker732"/> time. Here, the <code>string</code> type indicator means that we never expect these properties to have a null value. On the other hand, a <code>string?</code> type indicator would indicate that we might expect null values. See <a href="B21324_10.xhtml#_idTextAnchor209"><em class="italic">Chapter 10</em></a> for more information on nullability analysis in C#.</p>
<p>There are a few ways to address this compiler warning:</p>
<ul>
<li>Default these properties to an empty string</li>
<li>Change these properties to <code>string?</code> instead of <code>string</code></li>
<li>Add a constructor<a id="_idIndexMarker733"/> that sets these properties to non-null values</li>
<li>Mark these properties as <code>required</code> so that they must be set on creation</li>
</ul>
<p>As shown here, the <a id="_idIndexMarker734"/>simplest fix is to mark<a id="_idIndexMarker735"/> these properties as <code>required</code>:</p>
<pre class="source-code">
public class Airport {
  public <strong class="bold">required</strong> string Country { get; set; }
  public <strong class="bold">required</strong> string Code { get; set; }
  public <strong class="bold">required</strong> string Name { get; set; }
  // Non-relevant code omitted...
}</pre>
<p>This resolves the three code analysis warnings, leaving two less severe suggestions for us to investigate, both dealing with the <code>Equals</code> method of <code>Airport</code>:</p>
<pre class="source-code">
public override bool Equals(object? obj) {
  Airport? otherAirport = obj as Airport;
  if (otherAirport == null)
    return false;
  string otherName = otherAirport.Name;
  string otherCountry = otherAirport.Country;
  string otherCode = otherAirport.Code;
  return Country == otherCountry &amp;&amp;
          Code == otherCode;
}</pre>
<p>The first warning is IDE0019, which<a id="_idIndexMarker736"/> suggests using pattern matching when declaring <code>otherAirport</code>. Thankfully, this analyzer provides a <code>Airport?</code> type reveals the <strong class="bold">Use pattern matching</strong> <strong class="bold">Quick Action</strong>, as shown in <em class="italic">Figure 12</em><em class="italic">.7</em>:</p>
<div><div><img alt="Figure 12.7 – Applying the Use pattern matching refactoring" src="img/B21324_12_7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Applying the Use pattern matching refactoring</p>
<p>Applying this refactoring resolves the suggestion and makes our code more concise:</p>
<pre class="source-code">
if (<strong class="bold">obj is not Airport otherAirport</strong>)
      return false;</pre>
<p>The last remaining warning is <em class="italic">IDE0059: Unnecessary assignment of a value to ‘otherName’</em>. This highlights that we’ve declared a variable and assigned a value to that variable but never used the variable after that point, as shown here with <code>otherName</code>:</p>
<pre class="source-code">
<strong class="bold">string otherName = otherAirport.Name;</strong>
string otherCountry = otherAirport.Country;
string otherCode = otherAirport.Code;
return Country == otherCountry &amp;&amp;
        Code == otherCode;</pre>
<p>Looking at this code, it’s a toss-up as to whether <code>otherName</code> should be included in the equality check or if the variable is simply not needed. In this case, you might ask a business stakeholder if an airport could ever have multiple names but be the same airport. If you get a “yes,” then<a id="_idIndexMarker739"/> the fix would be to remove the <code>otherName</code> variable, while a “no” would indicate<a id="_idIndexMarker740"/> that a <code>Name</code> check should be added to the <code>return</code> statement.</p>
<p>The correct fix for code issues<a id="_idIndexMarker741"/> is not always obvious without gathering more information about the business domain you’re modeling.</p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor265"/>Configuring code analysis rulesets</h2>
<p>There are a large and<a id="_idIndexMarker742"/> growing number of analyzers in .NET and not every analyzer shares the same levels of importance. Because of this, Microsoft provides different sets of analyzers so that you can start with a small subset of the most useful ones and gradually expand into additional sets of analyzers as your maturity grows.</p>
<p>Let’s look at our code analysis settings for the <code>Chapter12</code> project by right-clicking on the <code>Chapter12</code> project in <strong class="bold">Solution Explorer</strong> and then selecting <strong class="bold">Properties</strong>.</p>
<p>This will open the properties view of the project. This view lists all configurable properties associated with the project and can be scrolled through from top to bottom or navigated using the navigation pane on the left-hand side.</p>
<p>Click on <strong class="bold">Code Analysis</strong> in the navigation pane; you should see the project’s code analysis settings, as shown in <em class="italic">Figure 12</em><em class="italic">.8</em>:</p>
<div><div><img alt="Figure 12.8 – Code Analysis settings for the project" src="img/B21324_12_8.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – Code Analysis settings for the project</p>
<p>As you can see from the <strong class="bold">Run on build</strong> setting, the compiler will analyze code every time the project is built.</p>
<p>The exact set of analyzers used is <a id="_idIndexMarker743"/>controlled by the <strong class="bold">Analysis level</strong> setting, which defaults to <strong class="bold">Latest</strong> for new projects.</p>
<p>There is a wide variety of analysis rulesets supported by Visual Studio, but let’s focus on the four rulesets that start with “Latest” as these are the most recent rulesets available, and the patterns in these rules will help you understand the other rules options. These options are as follows:</p>
<ul>
<li><strong class="bold">Latest</strong>: The default set of rules. This is a set of rules that is intended to be broadly applicable to any type of project.</li>
<li><strong class="bold">Latest Minimum</strong>: Everything in <strong class="bold">Latest</strong> plus additional rules. This represents the minimum set of rules that Microsoft recommends using in a project.</li>
<li><strong class="bold">Latest Recommended</strong>: Everything in <strong class="bold">Latest Minimum</strong> plus some additional rules. This contains a robust set of rules designed to help you maintain a business application that can run in any locale securely and reliably.</li>
<li><strong class="bold">Latest All</strong>: All available rules are enabled. Not every rule may be relevant for the application you’re trying to build, but it maximizes your chances of building a robust and reliable application.</li>
</ul>
<p>Let’s see what happens when<a id="_idIndexMarker744"/> we change our project from <strong class="bold">Latest</strong> to <strong class="bold">Latest Recommended</strong> and then build.</p>
<h2 id="_idParaDest-267"><a id="_idTextAnchor266"/>Responding to code analysis rules</h2>
<p>After changing the<a id="_idIndexMarker745"/> project to use the <strong class="bold">Latest Recommended</strong> ruleset, three new warnings will appear, as shown in <em class="italic">Figure 12</em><em class="italic">.9:</em></p>
<div><div><img alt="Figure 12.9 – New compiler warnings after moving to a stricter ruleset" src="img/B21324_12_9.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9 – New compiler warnings after moving to a stricter ruleset</p>
<p>Let’s start with the first warning. This corresponds to the <code>Flight</code> class, which is currently defined in only a few lines of code:</p>
<pre class="source-code">
public class Flight {
  public string BuildMessage(string id, string status) {
    return $"Flight {id} is {status}";
  }
}</pre>
<p>The CA1822 warning tells us <em class="italic">Member ‘BuildMessage’ does not access instance data and can be marked </em><em class="italic">as static</em>.</p>
<p>This analyzer is suggesting we make the <code>BuildMessage</code> method <code>static</code> because it doesn’t deal with any specific information from the overall <code>Flight</code> class.</p>
<p>In this case, making the method <code>static</code> could make it easier to test and allow the compiler to make a few performance optimizations as well.</p>
<p>We could resolve this warning by performing the <em class="italic">Make method static</em> refactoring we covered in <a href="B21324_04.xhtml#_idTextAnchor072"><em class="italic">Chapter 4</em></a>, but instead, let’s explore suppressing specific warnings.</p>
<p>In this case, let’s say that we intend <code>BuildMessage</code> to deal with instance-specific properties at some point in the future, but haven’t gotten there yet. Because of this, we want the warning to go away without making the method static.</p>
<p>Use the <code>BuildMessage</code> method and then select the <strong class="bold">Suppress or configure issues</strong> submenu. From there, choose <strong class="bold">Suppress CA1822</strong>. This will reveal three<a id="_idIndexMarker746"/> different options for suppressing the issue, as shown in <em class="italic">Figure 12</em><em class="italic">.10</em>:</p>
<div><div><img alt="Figure 12.10 – Options for suppressing the code analysis warnings" src="img/B21324_12_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.10 – Options for suppressing the code analysis warnings</p>
<p>These options are as follows:</p>
<ul>
<li><code>#pragma</code> statements above and below your code to disable the code analysis warning temporarily</li>
<li><strong class="bold">in Suppression File</strong>: This creates a separate file with code telling code analysis not to care about this specific issue for this specific method</li>
<li><code>SuppressMessageAttribute</code> above the method, suppressing the code analysis issue</li>
</ul>
<p>All three of these approaches will suppress the issue, but all do so in different styles. I generally prefer to avoid preprocessor directives such as <code>#pragma</code> to have cleaner and more maintainable code. This leaves the suppression file and attribute approaches.</p>
<p>The advantage of a suppression file is that code analysis suppressions do not clutter your source code and instead live in a separate file. However, that’s also their disadvantage. By hiding away suppressions in another file, you reduce the odds of resolving them in the future since they’re “out of sight, out of mind.”</p>
<p>Using the <code>using</code> statement for <code>System.Diagnostic.CodeAnalysis</code> results <a id="_idIndexMarker747"/>in the following file:</p>
<pre class="source-code">
<strong class="bold">using System.Diagnostics.CodeAnalysis;</strong>
namespace Packt.CloudySkiesAir.Chapter12.Flight;
public class Flight {
<strong class="bold">  [SuppressMessage("Performance",</strong>
<strong class="bold">    "CA1822:Mark members as static",</strong>
<strong class="bold">    Justification = "Intend to work with instance data in future        release")]</strong>
  public string BuildMessage(string id, string status) {
    return $"Flight {id} is {status}";
  }
}</pre>
<p>The <code>SuppressMessage</code> attribute above the method marks the category of the code analysis issue as “Performance.” Next, it names the individual analysis rule being suppressed before providing a justification.</p>
<p>This justification is a string explaining to your coworkers (and future you) why you believe the code analysis rule should not be addressed at this time and should be excluded from the list of code analysis results.</p>
<p>I will never suppress a code analysis warning without providing a valid justification for the suppression. If a rule was important enough for someone to provide an analyzer for, it should either be resolved or I should have a valid justification for why I am choosing to ignore it. In case you were wondering, “I don’t feel like addressing it” is not a valid justification.</p>
<p>With the first warning out of the way, let’s look at the other two warnings together as they’re related.</p>
<p>The first warning is CA1305, which is associated with the <code>DateHelpers</code> class, as shown here:</p>
<pre class="source-code">
public static class DateHelpers {
  public static string Format(this DateTime time) {
    return <strong class="bold">time.ToString("ddd MMM dd HH:mm tt")</strong>;
  }
}</pre>
<p>This warning states that the <code>ToString</code> call might result in a different result, depending on the user’s locale and<a id="_idIndexMarker748"/> language settings. My settings, as someone speaking English in the United States, may be different than someone running the same code with French as their primary locale.</p>
<p>The next warning is on <code>BuildFlightIdentifier</code> in <code>CharterFlightInfo</code>:</p>
<pre class="source-code">
public class CharterFlightInfo : FlightInfoBase {
  public List&lt;ICargoItem&gt; Cargo { get; } = new();
  public override string BuildFlightIdentifier() {
    StringBuilder sb = new(base.BuildFlightIdentifier());
    if (Cargo.Count != 0) {
      sb.Append(" carrying ");
      foreach (var cargo in Cargo) {
<strong class="bold">        sb.Append($"{cargo}, ");</strong>
      }
    }
    return sb.ToString();
  }
}</pre>
<p>This warning is complaining about a similar localization issue stating that the behavior of <code>StringBuilder.Append</code> could differ based on the user’s locale.</p>
<p class="callout-heading">Recommended rules versus minimum and default rules</p>
<p class="callout">These formatting rules are examples of rules that are not relevant to all projects. These rules are not enabled in the default or minimum rulesets for a reason: not all applications you create will need to behave consistently, regardless of where they’re running. If you’re building a<a id="_idIndexMarker749"/> hobby application or an application that runs only on a single server or in your office, this rule probably isn’t important for you. However, if you’re building something that is distributed throughout the globe to customers of all cultures, this is going to be a rule you care about.</p>
<p>The fix for these two <a id="_idIndexMarker750"/>warnings is to provide an explicit culture that you want to be used when formatting strings. This changes our append code to the following line:</p>
<pre class="source-code">
sb.Append(<strong class="bold">CultureInfo.InvariantCulture,</strong> $"{cargo}, ");</pre>
<p>Our date formatting code changes in a similar manner:</p>
<pre class="source-code">
<strong class="bold">CultureInfo culture = CultureInfo.InvariantCulture;</strong>
return time.ToString("ddd MMM dd HH:mm tt", <strong class="bold">culture</strong>);</pre>
<p>With these changes made, we are now free of code analysis warnings. Let’s finish this section by looking at a way of making sure we stay free of warnings.</p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor267"/>Treating warnings as errors</h2>
<p>I’ve met many developers who treat<a id="_idIndexMarker751"/> warnings like they treat speed limits while driving: they ignore them and cruise by at unsafe speeds.</p>
<p>There are a few ways of making sure developers ensure their code is free of warnings. Perhaps the easiest way of doing so is to tell the C# compiler to treat any warning as if it were a compiler error.</p>
<p>You can have the C# compiler treat all warnings as errors by right-clicking on the project and then selecting <strong class="bold">Properties</strong>, as we did before. From there, expand <strong class="bold">Build</strong> in the navigation pane and then click <strong class="bold">Errors and warnings</strong>. Once you do so, you should see something like <em class="italic">Figure 12</em><em class="italic">.11</em>:</p>
<div><div><img alt="Figure 12.11 – Configuring errors and warnings for a project" src="img/B21324_12_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.11 – Configuring errors and warnings for a project</p>
<p>You can check <strong class="bold">Treat warnings as errors</strong> to have all warnings result in errors.</p>
<p>Since developers pay attention to things that stop their code from running at all, causing any warning to stop them from <a id="_idIndexMarker752"/>building their code will certainly get their attention! Be careful when using this as they may not be very happy about the severity of the interruption.</p>
<p>A less extreme option is to configure the <strong class="bold">Treat specific warnings as errors</strong> setting and include the identifiers of specific warnings you believe should always be addressed.</p>
<p>For example, if we wanted to force developers to respond to suggestions of making methods <code>static</code> (CA1822), you could set the <code>$(WarningsAsErrors);NU1605;CA1822</code>; by doing so, any place where the warning occurred and was not suppressed would result in a compiler error.</p>
<p>Now that we’ve covered the code analysis features of Visual Studio, let’s take a look at a pair of additional options in the form of third-party tools that work well with C# code.</p>
<h1 id="_idParaDest-269"><a id="_idTextAnchor268"/>Exploring advanced code analysis tools</h1>
<p>The built-in code analysis<a id="_idIndexMarker753"/> and code metrics tools are very good for engineers wanting to pinpoint bad code and ensure code follows best practices for .NET projects, but they lack some enterprise-level features.</p>
<p>In this section, we’ll look at two different commercial analysis tools that I’ve found to provide<a id="_idIndexMarker754"/> additional<a id="_idIndexMarker755"/> value for .NET projects: <strong class="bold">SonarCloud</strong> and <strong class="bold">NDepend</strong>.</p>
<p>I won’t be covering how to set up these tools as both tools have comprehensive documentation that I’ve<a id="_idIndexMarker756"/> provided links to in the <em class="italic">Further reading</em> section at the end of this chapter. Instead, we’ll focus on the types of insights that dedicated code analysis tools can give you beyond what’s available in Visual Studio.</p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor269"/>Tracking code metrics with SonarCloud and SonarQube</h2>
<p>SonarCloud and SonarQube are a pair of commercial code analysis tools offered by SonarSource. Both products<a id="_idIndexMarker757"/> look at Git repositories containing code in a variety of popular programming languages and generate a series of recommendations.</p>
<p>The primary difference<a id="_idIndexMarker758"/> between SonarCloud and SonarQube is that <a id="_idIndexMarker759"/>SonarCloud is hosted on and analyzed by servers maintained by SonarSource while SonarQube is software you can install on your servers.</p>
<p>Both pieces of software can analyze code in Git repositories and provide heat maps of problem areas in your code in the areas of reliability, maintainability, security, and code duplication. These views give you a simple graphical representation of your code that helps easily flag problem areas, as shown in <em class="italic">Figure 12</em><em class="italic">.12</em>:</p>
<div><div><img alt="Figure 12.12 – SonarCloud analysis highlighting technical debt areas" src="img/B21324_12_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.12 – SonarCloud analysis highlighting technical debt areas</p>
<p>These tools have built-in analyzers<a id="_idIndexMarker760"/> that analyze<a id="_idIndexMarker761"/> your code and flag reliability, security, and performance issues for remediation.</p>
<p>Once an issue has been flagged, you can <a id="_idIndexMarker762"/>use the web user interface shown in <em class="italic">Figure 12</em><em class="italic">.13</em> to assign it to a team member, add comments to it, or mark it as resolved or ignored:</p>
<div><div><img alt="Figure 12.13 – Code analysis recommendations per line of code" src="img/B21324_12_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.13 – Code analysis recommendations per line of code</p>
<p>For me, SonarCloud and<a id="_idIndexMarker763"/> SonarQube have a few major selling points:</p>
<ul>
<li>They help expose technical <a id="_idIndexMarker764"/>debt to non-developers in a very user-friendly way. An engineering manager or chief technology officer can look at the project in their web browser and get an understanding of the weak areas without ever having to install Visual Studio. This helps make technical debt transparent.</li>
<li>Items flagged by SonarCloud and SonarQube tend to be worth investigating, perhaps even more so than items flagged by Visual Studio code analyzers.</li>
<li>You tend to get a good result with these tools out of the box without needing additional configuration, though the configuration is available for customization should you wish to do so.</li>
</ul>
<p>SonarCloud and Sonar<a id="_idIndexMarker765"/>Qube are commercial products that are priced based on the lines of code in your projects. SonarCloud is also freely available for any public GitHub repository.</p>
<p>Since the code in this book is public on GitHub, you can see its code analysis results at <a href="https://sonarcloud.io/summary/overall?id=IntegerMan_Refactoring-with-CSharp">https://sonarcloud.io/summary/overall?id=IntegerMan_Refactoring-with-CSharp</a>. I’d also strongly recommend that you create an account and have SonarCloud analyze some open-source code you’ve written <a id="_idIndexMarker766"/>or are familiar with, just to walk through the setup and analysis process <a id="_idIndexMarker767"/>and see the recommendations it gives you.</p>
<p>While SonarCloud and SonarQube are not .NET-specific tools, I do find they work well with .NET projects, which is why they’re highlighted in this book.</p>
<p>Next, let’s look at a tool <a id="_idIndexMarker768"/>explicitly built for .NET and C# projects in particular: NDepend.</p>
<h2 id="_idParaDest-271"><a id="_idTextAnchor270"/>In-depth .NET analysis with NDepend</h2>
<p>NDepend is a power tool <a id="_idIndexMarker769"/>designed to help architects and software engineers get the most out of their C# projects.</p>
<p>NDepend can operate as a Visual Studio<a id="_idIndexMarker770"/> extension such as GitHub Copilot Chat, as a standalone application, or as a build agent integrated into an Azure DevOps build pipeline.</p>
<p>When NDepend runs its analysis, it produces an HTML report (pictured in <em class="italic">Figure 12</em><em class="italic">.14</em>) and populates a dashboard view with the same information in Visual Studio:</p>
<div><div><img alt="Figure 12.14 – NDepend report showing code analysis results" src="img/B21324_12_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.14 – NDepend report showing code analysis results</p>
<p>This report highlights<a id="_idIndexMarker771"/> the number of code analysis rules violated by the project, the<a id="_idIndexMarker772"/> current unit test code coverage percentages, and how metrics have changed over time.</p>
<p class="callout-heading">Try it out</p>
<p class="callout">You can view a sample NDepend report for this chapter in the <a href="http://Chapter12/Ch12FinalCode/NDependOut/NDependReport.html">Chapter12/Ch12FinalCode/NDependOut/NDependReport.html</a> file in this book’s GitHub repository.</p>
<p>If you and your engineering team are trying to answer questions such as “Are we getting better or worse?”, “What are our major problems?”, or “What areas need to be fixed the most?”, NDepend will help you with that.</p>
<p>Like SonarCloud, NDepend operates on a series of analyzers called “rules.” These rules are written using LINQ against a model representing your source code. The default rules ship with their source code included and can be customized to your team’s needs. You can also write your own rules – much as we’ll write our own Roslyn Analyzers in the next two chapters.</p>
<p>These rules also allow you to compare how your code has changed since it was last baselined and estimate the<a id="_idIndexMarker773"/> amount of time it will take to resolve the technical debt they represent.</p>
<p>NDepend’s strengths go<a id="_idIndexMarker774"/> past its primary report, rules list, and list of rules violations. The real strength of NDepend is in its data visualizations.</p>
<p>The dependency matrix is what NDepend was originally known for and allows you to see a two-dimensional matrix of different namespaces and types, as shown in <em class="italic">Figure 12</em><em class="italic">.15</em>:</p>
<div><div><img alt="Figure 12.15 – The NDepend dependency matrix" src="img/B21324_12_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.15 – The NDepend dependency matrix</p>
<p>This matrix helps you detect namespaces or types that are dependent on each other. When different types or namespaces are mutually dependent on each other, this typically represents incorrectly segmented software architecture, and NDepend makes this highly visible when violations are present.</p>
<p>NDepend’s visualizations don’t stop there, however. My favorite visualization built into NDepend is its heat view, which allows you<a id="_idIndexMarker775"/> to view types or methods inside your project in a hierarchical tree with<a id="_idIndexMarker776"/> different rectangles representing different types or methods.</p>
<p>This view is similar to a tree map in data visualization tools, but each rectangle is colorized and sized based on various metrics calculated by NDepend. These metrics go well beyond the metrics Visual Studio calculates on its own and include things such as the lines of code, cyclomatic complexity, percentage of unit test coverage, or even the amount of comments in the file.</p>
<p>This heat map, pictured in <em class="italic">Figure 12</em><em class="italic">.16</em>, is the most intuitive way I’ve found of helping me zero in on potentially problematic code – and communicate problem areas visually to key stakeholders:</p>
<div><div><img alt="Figure 12.16 – An NDepend heat map showing lines of code and cyclomatic complexity" src="img/B21324_12_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.16 – An NDepend heat map showing lines of code and cyclomatic complexity</p>
<p>NDepend also offers a dependency graph view. This graph allows you to see how assemblies, namespaces, types, methods, properties, events, and even fields interact with each other richly <a id="_idIndexMarker777"/>and interactively, as shown in <em class="italic">Figure 12</em><em class="italic">.17</em>:</p>
<div><div><img alt="Figure 12.17 – Namespace and type interactions within the Chapter12 project" src="img/B21324_12_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.17 – Namespace and type interactions within the Chapter12 project</p>
<p>This allows you to visualize<a id="_idIndexMarker778"/> your software architecture and communicate that architecture to others on your team. This is particularly handy when onboarding new developers.</p>
<p>The graph view also allows you to spot problem areas such as types that depend on too many other types, different namespaces dependent on each other, and classes that likely violate the SRP.</p>
<p>In my experience, NDepend takes some additional time to configure and investigate, but it represents a very effective way of visualizing, communicating, and navigating problem areas in your code.</p>
<p>Let’s finish this chapter by exploring code analysis at our fictional organization.</p>
<h1 id="_idParaDest-272"><a id="_idTextAnchor271"/>Case study – Cloudy Skies Airline</h1>
<p>Cloudy Skies Airlines knew they<a id="_idIndexMarker779"/> had a lot of technical debt and code issues, but they weren’t sure which areas they should prioritize. Each engineer had different opinions on what was most important. As you would expect, these opinions were usually influenced by what each engineer had worked on most recently.</p>
<p>To resolve this issue, engineering leadership turned to the data. They started analyzing the available code metrics in Visual Studio and cataloging where most code analysis warnings seemed to be located.</p>
<p>Engineering management then compared the problem areas with the areas that had changed within the past 3 months and the areas the organization expects will need to change to support the team’s upcoming initiatives. This approach helped engineering management prioritize technical debt resolution in strategic areas that supported business objectives.</p>
<p>To help resolve the backlog <a id="_idIndexMarker780"/>of warnings, developers were given a new mandate: each commit you make should not increase the number of active code analysis warnings. Decreasing the warning count or having it stay the same is fine, but increasing it will not be acceptable in code review.</p>
<p>This policy built additional awareness of code analysis warnings and the warnings were gradually reduced over time. Once the team got acclimated to paying attention to warnings, they moved to a larger code analysis ruleset. This caused a new series of warnings to come in, but those warnings helped identify potential or actual problems, as well as optimizations for the application.</p>
<p>To help provide insight into the health of its code, the organization is currently evaluating SonarCloud and NDepend to provide the team with a quality dashboard that will help them focus on key areas and ensure quality remains high going forward.</p>
<h1 id="_idParaDest-273"><a id="_idTextAnchor272"/>Summary</h1>
<p>In this chapter, we saw how code metrics and code analysis tools can help you spot problem areas in your code, follow best practices, and prioritize areas of technical debt. This will help you understand the issues you and your team struggle with. Once you know the areas you struggle with, you can focus on remediating them going forward. This also helps you prioritize areas of technical debt and communicate those areas to others.</p>
<p>These built-in analyzers are incredibly handy and it turns out you can build some on your own. Over the next two chapters, we’ll do just that as we build our own code analyzer that can detect and automatically fix issues.</p>
<h1 id="_idParaDest-274"><a id="_idTextAnchor273"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li>What are the areas you consider to be most problematic about your code?</li>
<li>What do the code metrics say about these problem areas?</li>
<li>What is cyclomatic complexity and how is it calculated?</li>
<li>What are the things you should consider when picking a code analysis ruleset?</li>
</ol>
<h1 id="_idParaDest-275"><a id="_idTextAnchor274"/>Further reading</h1>
<p>You can find more information about code analysis at these URLs:</p>
<ul>
<li><em class="italic">Code Metrics </em><em class="italic">Values</em>: <a href="https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values">https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values</a></li>
<li><em class="italic">Overview of .NET source code </em><em class="italic">analysis</em>: <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview">https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview</a></li>
<li><em class="italic">SonarCloud</em>: <a href="https://www.sonarsource.com/products/sonarcloud/">https://www.sonarsource.com/products/sonarcloud/</a></li>
<li><em class="italic">NDepend</em>: <a href="https://www.ndepend.com/">https://www.ndepend.com/</a></li>
</ul>
</div>
</body></html>