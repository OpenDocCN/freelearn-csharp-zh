- en: '*Chapter 12*: Procedural Storytelling with ink'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：使用ink进行程序化叙事'
- en: 'In this chapter, we will review **procedural storytelling** using ink and Unity.
    Inkle, the company that created and maintains the narrative scripting language
    ink, has published multiple games that combine ink and Unity. These games use
    procedural storytelling to provide different experiences per session based on
    randomness and player choices. This chapter will introduce approaches to achieving
    this same general result: loading values in ink and coding collections in Unity.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用墨水和Unity回顾**程序化叙事**。Inkle公司创建了并维护了叙事脚本语言ink，并发布了多个结合ink和Unity的游戏。这些游戏使用程序化叙事，根据随机性和玩家的选择，为每个会话提供不同的体验。本章将介绍实现相同一般结果的方法：在ink中加载值和在Unity中编码集合。
- en: In the first topic, we will review the term *procedural storytelling* more generally.
    Based on concepts initially introduced in [*Chapter 3*](B17597_03_Final_PG_ePub.xhtml#_idTextAnchor048),
    *Sequences, Cycles, and Shuffling Text*, we will learn how to use a shuffle in
    ink to create dynamic content based on simple rules.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个主题中，我们将更广泛地回顾术语*程序化叙事*。基于最初在[*第3章*](B17597_03_Final_PG_ePub.xhtml#_idTextAnchor048)中介绍的概念，“序列、循环和文本洗牌”，我们将学习如何使用墨水中的洗牌功能，根据简单的规则创建动态内容。
- en: Diving even deeper into ink, the second topic will demonstrate how to load values
    in ink. This process focuses on using ink to generate content for players based
    on simple rules.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 深入ink，第二个主题将演示如何在ink中加载值。这个过程侧重于使用ink根据简单规则为玩家生成内容。
- en: In the final topic, we will switch the emphasis from ink to Unity. We will use
    Unity to load values and call functions in ink to process values instead. This
    approach uses more complex code in Unity, but simpler code in ink.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个主题中，我们将重点从ink转移到Unity。我们将使用Unity来加载值并在ink中调用函数来处理值。这种方法在Unity中使用更复杂的代码，但在ink中使用更简单的代码。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing procedural storytelling in ink
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在墨水（ink）中引入程序化叙事
- en: Loading values into ink
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值加载到ink中
- en: Coding collections in Unity
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity中编码集合
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The examples in this chapter can be found online on GitHub: [https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter12](https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter12).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例可以在GitHub上找到：[https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter12](https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter12)。
- en: Introducing procedural storytelling in ink
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在墨水（ink）中引入程序化叙事
- en: The term *procedural storytelling* takes its name from another term, *procedural
    generation*. The word "procedural" preceding "generation" means that content is
    created based on a sequence of *procedures*; that is, rules. When referring to
    generating assets such as 3D models or placing non-player characters within some
    world in a video game, the term *procedural generation* applies. When discussing
    planning, generating, or dynamically ordering content related to the story or
    experienced narrative of the player within an interactive project, the better
    term to use is **procedural storytelling**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*程序化叙事*的名字来源于另一个术语，*程序化生成*。在“生成”之前，“程序化”一词意味着内容是根据一系列*程序*（即规则）创建的。也就是说，规则。当提到生成资产，如3D模型或在某些游戏世界中的非玩家角色时，术语*程序化生成*适用。当讨论与交互项目中玩家的故事或体验叙事相关的规划、生成或动态排序内容时，更好的术语是**程序化叙事**。
- en: Procedural storytelling occurs when a project uses rules to define how a player
    may interact with or encounter parts of its story content. For example, if a project
    has a set of rules to create dynamic names for its characters, a player in a science
    fiction setting may interact with a generated character name of *Neldronor*, while
    a different player might see the name *Vynear* for the same entity. Procedurally
    generating story content can also extend beyond substituting names to deciding
    which quests a player may have access to, when they encounter certain characters,
    or even the possible events that may happen in their play session.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个项目使用规则来定义玩家如何与其故事内容的部分交互或遭遇时，就会发生程序化叙事。例如，如果一个项目有一套规则来为其角色创建动态名称，那么在科幻设定中的玩家可能会与生成的角色名称*Neldronor*互动，而另一个玩家可能会看到同一实体的名称*Vynear*。程序化生成故事内容也可以扩展到替换名称之外，决定玩家可以访问哪些任务，他们在遇到某些角色时，甚至在他们游戏会话中可能发生的事件。
- en: In this topic, we will cover three examples of simple patterns for understanding
    procedural generation in ink based on randomness. The first, *Random encounters*,
    will explain how to combine the use of a shuffle and threads in ink to create
    a listing of possible encounters for a player. The second pattern, *Weighted randomness*,
    uses the same concepts as the first pattern but defines the weighted probability
    a player might see some content. Both patterns are easy ways to add simple procedural
    generation to an existing project without too much disruption to its existing
    structure. The last section and pattern, *Conditional content*, will cover using
    the previous actions and input from a player to influence which encounter a player
    sees. It does so by using concepts from the two previous patterns.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将介绍三个基于随机性的简单模式，以了解墨水中的程序生成。第一个，*随机遭遇*，将解释如何结合使用洗牌和墨水中的线程来创建玩家的可能遭遇列表。第二个模式，*加权随机性*，使用与第一个模式相同的概念，但定义了玩家可能看到某些内容的加权概率。这两种模式都是向现有项目添加简单程序生成而不破坏其现有结构的简单方法。最后一部分和模式，*条件内容*，将涵盖使用之前的行为和玩家的输入来影响玩家看到的遭遇。它是通过使用前两种模式的概念来做到这一点的。
- en: Random encounters
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机遭遇
- en: Many tabletop role-playing games use a concept known as a **random table**.
    In the material or book for the game, there is a table or list of possible things
    a player might encounter in a location or scene. The person running the game would
    roll some dice, consult the table to find the row matching the rolled number,
    and then tell the players what they encountered. This system creates the possibility
    for *random* encounters. Based on the random element of the dice, the player would
    see or interact with different things each time they used the same table to generate
    content for their game.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 许多桌面角色扮演游戏使用一个称为**随机表格**的概念。在游戏的材料或书中，有一个表格或列表，列出了玩家可能在某个地点或场景中遇到的可能事物。游戏主持人会掷一些骰子，查阅表格以找到与掷出的数字匹配的行，然后告诉玩家他们遇到了什么。这个系统创造了**随机**遭遇的可能性。基于骰子的随机元素，玩家每次使用相同的表格生成游戏内容时，都会看到或与不同的事物互动。
- en: 'Translated into a digital setting, the random tables of tabletop games can
    become a set of possible encounters. In ink, we can create this using a shuffle
    and threads:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字环境中，桌面游戏的随机表格可以成为一组可能的遭遇。在墨水中，我们可以使用洗牌和线程来创建这个：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Because the shuffle will always pick one of its entries at random, each thread
    has the same probability of occurring. However, as is perhaps not as obvious,
    *each possible encounter is additional content*. Unlike a much more authored experience
    without any procedural storytelling functionality, even a simple addition such
    as a table of possible encounters means creating new content per possible encounter:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因为洗牌总是会随机选择其条目之一，所以每个线程发生的概率相同。然而，可能并不那么明显，**每个可能的遭遇都是额外内容**。与没有程序化叙事功能的、由作者大量创作的体验不同，即使是添加一个可能的遭遇表格这样的简单操作，也意味着为每个可能的遭遇创建新内容：
- en: 'Example 1:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Example 1* demonstrates using a shuffle in ink containing three different
    threads as a simple random encounter system. Each thread references a knot called
    `encounter` with a stitch named after the kind of encounter, such as `animal`.
    Based on random selection, the player would see one of three possible encounters.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1* 展示了使用墨水中的洗牌，包含三个不同的线程，作为一个简单的随机遭遇系统。每个线程都引用一个名为 `encounter` 的结点，其针线以遭遇的类型命名，例如
    `animal`。基于随机选择，玩家将看到三种可能遭遇中的一种。'
- en: Using random encounters, as defined within a shuffle, is an easy way to add
    simple procedural storytelling in ink to a project. It does require adding extra
    content per entry in the shuffle, but such a pattern can be the least disruptive
    to an existing project. It is also possible to have additional sets and create
    more dynamic outcomes where a player might encounter any number of things across
    multiple settings, contexts, or levels where each usage is based on a shuffle
    and threads in ink.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用随机遭遇，如定义在洗牌中，是向项目中添加简单程序化叙事的一种简单方法。这确实需要为洗牌中的每个条目添加额外内容，但这种模式对现有项目的影响最小。也有可能拥有额外的集合，并创建更动态的结果，玩家可能在多个设置、情境或级别中遇到任何数量的事物，每个使用都基于洗牌和墨水中的线程。
- en: In the next section, we will examine weighted probabilities as part of controlling
    the randomness of a set of encounters. Instead of all entries having an equal
    probability of occurring, as is the case when using a shuffle, there may be situations
    where certain encounters should occur more often for players.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将检查加权概率作为控制一系列遭遇随机性的一个部分。与使用洗牌时所有条目都有相同发生概率的情况不同，可能存在某些遭遇应该更频繁地发生的情况。
- en: Weighted randomness
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加权随机性
- en: The shuffle is powerful functionality in ink. It allows us to create a set of
    possible entries and then randomly select one. As was seen in the *Random encounters*
    section, a simple set of possible encounters can be created; then, a shuffle can
    be used to select one as needed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 洗牌是ink中强大的功能。它允许我们创建一组可能的条目，然后随机选择一个。正如在*随机遭遇*部分所看到的，可以创建一个简单的可能遭遇集；然后，可以使用洗牌按需选择一个。
- en: However, there may be situations where equally weighted probabilities are not
    wanted. For example, a developer may only want a player to encounter a character
    30% of the time when traveling through a forest area in a game. For these situations,
    we want to *weight* the randomness of encounters.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能存在不需要等加权概率的情况。例如，开发者可能只想让玩家在游戏中穿越森林区域时30%的时间遇到一个角色。对于这些情况，我们希望对遭遇的随机性进行*加权*。
- en: 'In ink, the `RANDOM()` function allows us to define the range of random whole
    numbers that are produced. If we wanted numbers between `1` and `10`, we could
    use `RANDOM(1,10)`. Based on the number that''s returned by the `RANDOM()` function,
    it is possible to test values and only act if its result is in a certain range:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在ink中，`RANDOM()`函数允许我们定义产生的随机整数的范围。如果我们想要`1`到`10`之间的数字，我们可以使用`RANDOM(1,10)`。根据`RANDOM()`函数返回的数字，可以测试值，并且只有在结果在某个范围内时才采取行动：
- en: 'Example 2:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In *Example 2*, the `brown_wizard` stitch is only encountered if the result
    from the use of `RANDOM(1, 10)` is less than or equal to `3`. This creates a 30%
    chance of the player encountering this character. This is an example of a *weighted*
    probability. Instead of an equal probability between the two encounters, one is
    weighted more than the other. The `travel` stitch is more likely to be encountered
    by the player than the other stitch, `brown_wizard`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在*示例 2*中，只有在使用`RANDOM(1, 10)`的结果小于或等于`3`时，才会遇到`brown_wizard`针法。这为玩家遇到这个角色创造了30%的机会。这是一个*加权概率*的例子。与两个遭遇之间的概率相等不同，其中一个比另一个更受重视。`travel`针法比其他针法`brown_wizard`更有可能被玩家遇到。
- en: In the previous section, *Random encounters*, we learned how to create different
    content within stitches and select them with equal probability using a shuffle.
    In this section, we controlled this randomness using a weighted probability with
    the `RANDOM()` function in ink.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节*随机遭遇*中，我们学习了如何在针法中创建不同的内容，并使用洗牌以相等的概率选择它们。在本节中，我们通过在ink中使用`RANDOM()`函数的加权概率来控制这种随机性。
- en: In the next section, we will combine this and the previous pattern for *conditional*
    content. Based on the previous options that were selected by a player, we can
    influence what the player encounters using both randomness and by comparing other
    values.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将结合这种和之前的*条件性内容*模式。根据玩家之前选择的选项，我们可以通过随机性和比较其他值来影响玩家遇到的遭遇。
- en: Conditional content
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件性内容
- en: In projects that don't use randomness, it is very common to use conditional
    blocks or choices to respond to what the player selects and how they are progressing
    through a story. As we saw in the *Random encounters* and *Weighted randomness*
    sections, we can also use shuffles and the `RANDOM()` function in ink to shape
    a story. In this section, we will look at an example of using both concepts together
    to create more complex procedures to generate connections between content for
    players.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用随机性的项目中，使用条件块或选择来响应玩家选择以及他们如何通过故事进展是很常见的。正如我们在*随机遭遇*和*加权随机性*部分所看到的，我们也可以在ink中使用洗牌和`RANDOM()`函数来塑造故事。在本节中，我们将查看一个使用这两个概念结合来创建更复杂的程序以生成玩家之间内容连接的示例。
- en: In the previous section, *Weighted randomness*, we saw how we can create a set
    of different conditional statements within a block to control what the player
    encounters next. In *Example 2*, this was the weighted outcomes of either the
    `brown_wizard` or `travel` stitch, with the `travel` stitch more likely to be
    seen by the player. However, players rarely want to only read the text in a game.
    They want to have some input over what happens as part of a story.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节，*加权随机性*中，我们看到了如何在块内创建一组不同的条件语句来控制玩家接下来会遇到什么。在 *示例 2* 中，这是 `brown_wizard`
    或 `travel` 线迹的加权结果，其中 `travel` 线迹更有可能被玩家看到。然而，玩家很少只想在游戏中阅读文本。他们希望对故事发生的事情有所输入。
- en: 'By using labels with choices in ink, we can test whether a player selects a
    particular option and then influence the weighted outcome for the player:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用墨水中的选择标签，我们可以测试玩家是否选择了特定的选项，然后影响玩家的加权结果：
- en: 'Example 3:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Example 3* is an updated form of *Example 2*. However, instead of merely showing
    text, the player is presented with two options within a weave. Depending on which
    one they select, the story then branches along two possible paths. In the first,
    if the player chooses to travel in the forest, there is a 30% chance they will
    encounter a character. In the second, if a player chooses to travel by the river,
    they will not encounter the character.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3* 是 *示例 2* 的更新版本。然而，它不仅仅展示文本，玩家在编织中会看到两个选项。根据他们选择的哪一个，故事随后会沿着两条可能的路径分支。在第一种情况下，如果玩家选择在森林中旅行，他们有30%的几率会遇到一个角色。在第二种情况下，如果玩家选择沿着河流旅行，他们将不会遇到这个角色。'
- en: While some projects might use shuffle or weighted options, many more incorporate
    player selections and past choices with randomness. This not only gives the player
    more control over what they are experiencing, but it also allows the author to
    craft a story, along with certain predictable outcomes. Instead of trying to account
    for multiple outcomes when only using a shuffle, the use of the weave and its
    limited number of options shapes the possible paths of future encounters. Because
    there are only two options in the wave, there are only two possible main branches,
    with the weighted randomness only affecting one and not the other.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些项目可能会使用洗牌或加权选项，但更多的项目会结合玩家的选择和过去的选项与随机性。这不仅让玩家对他们的体验有更多的控制权，还允许作者构建一个故事，以及某些可预测的结果。在只使用洗牌时，不是尝试解释多个结果，而是使用编织及其有限的选择数量来塑造未来遭遇的可能路径。因为波浪中只有两个选项，所以只有两个可能的主要分支，加权随机性只影响其中一个，不影响另一个。
- en: In this topic, we have examined three different patterns for introducing or
    adjusting simple procedural storytelling rules in ink projects. In the first section,
    *Random encounters*, we learned how to create a set of equally weighted entries
    using a shuffle with threads to pull in different story content. In the second
    section, *Weighted randomness*, we explored how to control randomness with weighted
    outcomes where one outcome was more likely than another.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们探讨了在ink项目中引入或调整简单的程序化叙事规则的三种不同模式。在第一部分，*随机遭遇*，我们学习了如何使用线程的洗牌来创建一组等权重的条目，以引入不同的故事内容。在第二部分，*加权随机性*，我们探讨了如何通过加权结果来控制随机性，其中一种结果比另一种更有可能。
- en: In the last section, *Conditional content*, we combined randomness with the
    result of players selecting options and investigated how to create seemingly more
    advanced rules, where the number of choices within a weave has a stronger influence
    on the shape of the story than the randomness contained within any one branch.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节，*条件内容*中，我们将随机性与玩家选择选项的结果相结合，研究了如何创建看似更高级的规则，其中编织内的选择数量对故事形状的影响比任何分支中包含的随机性更强。
- en: In the next topic, we will look at more complex patterns. For many projects,
    ink will be the driving force behind content generation and how the project uses
    procedural storytelling. We will look at how to load values into ink as part of
    examining how to write a grammar for stories, and then plan how players will encounter
    its different parts in dynamic ways.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将探讨更复杂的模式。对于许多项目来说，ink将是内容生成和项目如何使用程序化叙事的驱动力。我们将探讨如何将值加载到ink中，作为检查如何编写故事语法的部分，并计划玩家如何以动态方式遇到其不同部分。
- en: Loading values into ink
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将值加载到墨水中
- en: The *procedural* aspect of procedural storytelling can exist either primarily
    in ink or Unity. In this topic, we will examine the process of loading values
    into ink. We will center a design focused on letting ink make procedural decisions
    about what content a user might see or interact with during a play session.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 程序化叙事的*程序化*方面可以主要存在于ink或Unity中。在这个主题中，我们将检查将值加载到ink中的过程。我们将集中设计，让ink在游戏会话期间对用户可能看到或与之交互的内容做出程序化决策。
- en: In the first section, *Substitution grammars*, we will consider how to use what
    we learned in the previous section, *Introducing procedural storytelling in ink*,
    to build a set of possible events for a player. This will lead us into the next
    section, *Story planning*, where we will apply rules to the grammars themselves.
    This will allow us to control how different sets of encounters are influenced
    by previous ones, creating simple formulas for complex stories.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，*替换语法*中，我们将考虑如何使用我们在上一部分*ink中介绍程序化叙事*中学到的知识来构建一套可能的玩家事件。这将引导我们进入下一部分*故事规划*，在那里我们将规则应用于语法本身。这将允许我们控制不同遭遇集如何受先前遭遇的影响，为复杂的故事创建简单的公式。
- en: Substitution grammars
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换语法
- en: In linguistics, **grammar** describes the rules that define how a language works.
    For example, in English, there is a specific order of subject, verb, and object
    in sentences. In programming contexts, we can define what is called **substitution
    grammar**, where a set of rules describes how words or phrases are replaced with
    others. This can often be used to define a specific order, such as the use of
    subjects and verbs in an English sentence. In a programming context, dynamic constructions
    can be produced where dynamic or random values are *substituted* in specific places
    in the defined pattern.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在语言学中，**语法**描述了定义语言工作方式的规则。例如，在英语中，句子中有主语、谓语和宾语的具体顺序。在编程环境中，我们可以定义所谓的**替换语法**，其中一组规则描述了单词或短语如何被替换。这通常用于定义特定的顺序，例如在英语句子中使用主语和谓语。在编程环境中，可以产生动态构造，其中动态或随机值被*替换*在定义模式中的特定位置。
- en: 'In ink, we can create functions to return values based on shuffles. By writing
    a grammar – that is, rules for what order entries appear in – we can create a
    simple substitution pattern where random entries are used from specific sets to
    create a dynamic text interaction:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在ink中，我们可以创建函数来根据洗牌返回值。通过编写语法——即规定条目出现的顺序的规则——我们可以创建一个简单的替换模式，其中从特定集合中随机使用条目来创建动态文本交互：
- en: 'Example 4:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In *Example 4*, the `getLocation()` and `getMarker()` ink functions provide
    the substitutions within the grammar of the sentence. By placing shuffles within
    the functions and surrounding them with quotation marks, the text's result can
    be returned; that is, where the functions are called. Because all functions are
    global, this also means they can be used multiple times in the code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在*示例 4*中，`getLocation()`和`getMarker()` ink函数提供了句子语法中的替换。通过在函数内放置洗牌操作并用引号包围它们，可以返回文本的结果；也就是说，在函数被调用时。因为所有函数都是全局的，这也意味着它们可以在代码中多次使用。
- en: Warning
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Based on *Example 4*, it can be tempting to assume functions can also be used
    to generate possible divert targets using a shuffle. This is not the case. While
    variables can hold divert targets, functions are not allowed to divert in ink,
    and the language prevents combinations of calling functions and using the returned
    value to thread or divert to another section in a story.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*示例 4*，可能会诱使我们假设函数也可以用来使用洗牌生成可能的分叉目标。这不是事实。虽然变量可以持有分叉目标，但在ink中不允许函数进行分叉，并且语言阻止了调用函数和使用返回值来线程或分叉到故事中的另一个部分的组合。
- en: 'Functions in ink can be useful for generating and returning text. However,
    because of its design, ink does not allow functions to control story flow. In
    cases where each entry within a shuffle might also want to use diverting or threads,
    we can create an extended tunnel where each part of the tunnel acts as part of
    the grammar:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ink中的函数可以用于生成和返回文本。然而，由于其设计，ink不允许函数控制故事流程。在每种洗牌操作可能还想使用分叉或线程的情况下，我们可以创建一个扩展的隧道，其中隧道的每一部分都作为语法的一部分：
- en: 'Example 5:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Example 5* is a rewritten version of *Example 4* using an extended tunnel.
    For simple text substitution, the pattern shown in *Example 4*, which is using
    shuffles and functions, can be very useful. However, the pattern in *Example 5*,
    which is using knots and multi-line shuffles, allows each entry in the shuffle
    to potentially divert or use threads themselves. This is often the preferred pattern
    for creating a substitution grammar, where each part of the grammar can expand
    as needed.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5* 是使用扩展隧道对 *示例 4* 进行重写的一个版本。对于简单的文本替换，*示例 4* 中展示的模式，即使用洗牌和函数，可以非常实用。然而，*示例
    5* 中的模式，即使用结和多行洗牌，允许洗牌中的每个条目可能改变或使用线程本身。这通常是创建替换语法的首选模式，其中语法的每个部分都可以根据需要扩展。'
- en: In this section, we learned how to use substitution grammar for text and then
    a more advanced one for incorporating tunnels. In the next section, we will apply
    substitution grammar as part of a planning process for stories. Loops and other
    conditional aspects will be introduced to create more advanced substitution grammars.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用替换语法进行文本替换，然后是更高级的语法来整合隧道。在下一节中，我们将将替换语法作为故事规划过程的一部分来应用。循环和其他条件方面将被引入以创建更高级的替换语法。
- en: Story planning
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故事规划
- en: In the previous section, we saw how substitution grammars can provide us with
    a specific order of events. By using shuffles, we can pick random entries for
    each part and create a dynamic experience for a player. In the examples shown
    in the previous section, there was also only one entry per part of the grammar.
    There was one for `location`, one for `marker`, and then the tunnel ended. This
    is useful, but many games will want to create dynamic patterns based on previous
    entries. In other words, it is also possible to base the range of future entries
    on previous ones within a grammar.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了替换语法如何为我们提供特定的事件顺序。通过使用洗牌，我们可以为每个部分选择随机的条目，为玩家创造动态体验。在上一节中展示的示例中，每个语法部分也只有一个条目。有一个用于
    `location`，一个用于 `marker`，然后隧道结束。这很有用，但许多游戏将希望根据先前条目创建动态模式。换句话说，也有可能在语法内部基于先前的条目来设定未来条目的范围。
- en: When we create a formula where previous entries can affect future entries as
    part of advanced grammar, we are using a concept called **story planning**. In
    procedural storytelling, story planning occurs when the story is *planned* based
    on rules for generating more complex patterns than simple substitution.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个公式，其中先前条目可以作为高级语法的部分影响未来条目时，我们正在使用一个称为 **故事规划** 的概念。在程序化叙事中，当故事根据生成比简单替换更复杂模式的规则进行规划时，就会发生故事规划。
- en: 'As explained in [*Chapter 3*](B17597_03_Final_PG_ePub.xhtml#_idTextAnchor048),
    *Sequences, Cycles, and Shuffling Text*, alternatives can be embedded inside each
    other. This means we can use alternatives inside of multi-line conditional blocks
    to create contexts where, based on previous values, random entries can be chosen:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 [*第 3 章*](B17597_03_Final_PG_ePub.xhtml#_idTextAnchor048) 中所述，*序列、循环和洗牌文本*，替代方案可以嵌套在彼此内部。这意味着我们可以在多行条件块中使用替代方案，以创建基于先前值的上下文，从而选择随机的条目：
- en: 'Example 6:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In *Example 6*, a new variable has been introduced based on the code from *Example
    5*. In this new version, the values of the `marker` knot are based on the `location_pick`
    variable. Within the extended tunnel moving from the `location` knot to the `marker`
    knot, the `location_pick` variable is changed. Depending on its value moving into
    the `marker` knot, different results can be produced. If the random entry from
    `location` is `"tower"`, the first two values, `grave` and `memorial` `stone`,
    are enabled. Otherwise, the `farmstead` and `ancient` `tree` values are.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 6* 中，根据 *示例 5* 中的代码引入了一个新变量。在这个新版本中，`marker` 结的值基于 `location_pick` 变量。在从
    `location` 结到 `marker` 结的扩展隧道中，`location_pick` 变量会改变。根据其值进入 `marker` 结，可以产生不同的结果。如果
    `location` 的随机条目是 `"tower"`，则前两个值 `grave` 和 `memorial stone` 被启用。否则，`farmstead`
    和 `ancient tree` 的值被启用。
- en: In this topic, we focused on loading and generating values in ink. In the first
    section, *Substitution grammars*, we learned how to create simple patterns. In
    this section, *Story planning*, we reviewed a simple example of story planning
    using a single variable for branching within the second part of a tunnel. Depending
    on the planning that's wanted, authors can create very complex grammars using
    different variables where previous values can branch out future calculations and
    ranges of entries in shuffles or other alternatives.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本主题中，我们专注于在ink中加载和生成值。在第一部分，*替换语法*中，我们学习了如何创建简单的模式。在本节，*叙事规划*中，我们回顾了一个使用单个变量在隧道第二部分中进行分支的简单叙事规划示例。根据所需的规划，作者可以使用不同的变量创建非常复杂的语法，其中先前值可以分支出未来的计算和洗牌或其他替代方案中的条目范围。
- en: In the next topic, we will move away from ink and back into Unity. When it comes
    to scripting narrative experiences, ink is an incredible language. However, ink
    does not work well with more complex value manipulations. In Unity, with the use
    of C#, we can perform much more complicated procedural storytelling approaches,
    where we can make decisions about which ink story to load and how to pass its
    values to make decisions internally.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将从墨水（ink）转向Unity。当涉及到脚本化叙事体验时，ink是一种令人难以置信的语言。然而，ink在处理更复杂的值操作时并不适用。在Unity中，使用C#，我们可以执行更复杂的程序化叙事方法，其中我们可以决定加载哪个ink故事以及如何传递其值以进行内部决策。
- en: Coding collections in Unity
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Unity中编码集合
- en: In the previous topic, we examined ways to have ink create and plan content
    for a player. In this section, we move back into Unity. Often, in large projects,
    story and otherwise, narrative content will be one of several complex interlocking
    mechanics in a game. In these cases, procedural storytelling will be one of multiple
    systems, and Unity, as the game engine driving the project, will be programmed
    to use one story over another as part of more complex operations and planning.
    In these cases, the narrative content is stored in what C# names *collections*.
    These can be something as simple as an array or a much more complex data structure
    capable of sorting its internal elements based on patterns or the values of their
    internal elements.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个主题中，我们探讨了ink为玩家创建和规划内容的方法。在本节中，我们回到Unity。在大型项目中，无论是故事还是其他内容，叙事内容通常会是游戏中的多个复杂互锁机制之一。在这些情况下，程序化叙事将是多个系统之一，Unity作为推动项目的游戏引擎，将被编程为在更复杂的操作和规划中使用一个故事而不是另一个。在这些情况下，叙事内容存储在C#称为*集合*的地方。这些可以是像数组这样简单的东西，也可以是更复杂的数据结构，能够根据模式或其内部元素的值对内部元素进行排序。
- en: In the first section, *Using multiple stories*, we will look at an example of
    moving the procedural storytelling aspect of a project from ink into Unity. Instead
    of working with shuffles in ink, we will use randomness in Unity to select between
    different possible stories within a collection and then remove them from future
    selections. This will allow us to concentrate on the story content in ink, creating
    dialog or player choices within separate files, and then use Unity to choose what
    to show a player.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，*使用多个故事*中，我们将查看一个示例，将项目的程序化叙事方面从ink移动到Unity。我们不会在ink中使用洗牌（shuffles），而是在Unity中使用随机性来选择集合中不同的可能故事，然后从未来的选择中移除它们。这将使我们能够专注于ink中的故事内容，在单独的文件中创建对话或玩家选择，然后使用Unity来选择要向玩家展示的内容。
- en: In the final section, *Conditionally choosing stories*, we will apply the concept
    of simple story planning, as shown in the *Story planning* subsection, using ink
    in Unity. Much like it did in ink, this will allow us to start to define a substitution
    grammar for how we want story content to appear to the player, but with the coded
    collections in Unity performing the work of selecting parts instead of ink.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节，*条件性地选择故事*中，我们将使用Unity中的ink应用简单的叙事规划概念，正如*叙事规划*子节中所示。这与ink中的操作非常相似，这将使我们能够开始定义一个替换语法，以确定我们希望故事内容如何呈现给玩家，但由Unity中的编码集合执行选择部分的工作，而不是ink。
- en: Using multiple stories
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多个故事
- en: As we first explored in [*Chapter 11*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159),
    *Quest Tracking and Branching Narratives*, in the *Tracking progress across multiple
    quests* topic, it is possible to use multiple ink files as separate instances
    of the `Story` class in a project. In that topic, each file was a separate quest.
    However, it is also possible to use each file as a scene within a larger story.
    In these cases, each ink file would represent a separate narrative experience
    for a player. This could become part of a session or a longer story, upon being
    selected by Unity, to show the player in a random order.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们首先在 [*第 11 章*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159) 中探讨的，在 *Quest
    Tracking and Branching Narratives*（任务跟踪和分支叙事）主题中，在 *Tracking progress across multiple
    quests*（跟踪多个任务进度）这一主题中，可以使用多个墨迹文件作为项目中 `Story` 类的独立实例。在那个主题中，每个文件都是一个独立的故事。然而，也可以将每个文件用作更大故事中的一个场景。在这些情况下，每个墨迹文件将代表玩家的一种独立的叙事体验。一旦被
    Unity 选择，它就可以作为会话的一部分或更长的故事，以随机顺序向玩家展示。
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The completed project for this section can be found in the [*Chapter 12*](B17597_12_Final_PG_ePub.xhtml#_idTextAnchor174) examples
    on GitHub under the name `Chapter12-MultipleStories`. Only select parts of the
    code will be shown as they relate to the concepts being examined.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本节完成的项目的示例可以在 GitHub 上的 [*第 12 章*](B17597_12_Final_PG_ePub.xhtml#_idTextAnchor174)
    找到，名称为 `Chapter12-MultipleStories`。只会展示与正在考察的概念相关的代码部分。
- en: 'When you''re using multiple ink files to break a story down into different
    scenes where each could be accessed independently of each other, the easiest way
    to approach this is to load them all at once. The following project uses a method
    named `GetFiles()` to process the compiled JSON files and create `Story` class
    instances. With each new object that''s created, it is added to a `List<Story>`
    collection named `Stories`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用多个墨迹文件将故事分解成不同的场景，每个场景可以独立访问时，一次性加载它们是最简单的方法。以下项目使用名为 `GetFiles()` 的方法处理编译后的
    JSON 文件并创建 `Story` 类实例。每当创建一个新的对象时，它就会被添加到一个名为 `Stories` 的 `List<Story>` 集合中：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the *Random encounter* section of the *Introducing procedural storytelling
    in ink* topic, a shuffle was used to pick between different threads. In C#, the
    `Random` class works similarly. It provides random data based on some range. Using
    its `Next()` method and the `Count` property of the collection, it provides an
    index to select between entries in the `List<Story>` collection, which is populated
    by the `GetFiles()` method:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Introducing procedural storytelling in ink*（介绍墨迹中的程序化叙事）主题的 *Random encounter*（随机遭遇）部分，使用了洗牌来在不同的线程之间进行选择。在
    C# 中，`Random` 类的工作方式类似。它基于某个范围提供随机数据。使用其 `Next()` 方法以及集合的 `Count` 属性，它提供了一个索引来在
    `List<Story>` 集合中选择条目，该集合由 `GetFiles()` 方法填充：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To prevent the same story from appearing again, the `RemoveAt()` method removes
    the entry from the `List<Story>` collection at random. This prevents the same
    story from being shown twice.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止相同的故事再次出现，`RemoveAt()` 方法会随机地从 `List<Story>` 集合中移除条目。这防止了相同的故事被展示两次。
- en: 'Put together, the `Start()` method is used to call multiple other methods to
    parse the files and pick a random story. Based on the weave contained in the randomly
    picked `Story`, a method named `UpdateContent()`, which is called from `PickRandomStory()`,
    presents two options to the player as `Button` game objects. Clicking on either
    of these changes the value of a variable within the story. This is then shown
    to the player as updates to two variables, `violence` and `peace`, which are tracked
    in Unity:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，`Start()` 方法用于调用多个其他方法来解析文件并随机选择一个故事。基于随机选择的 `Story` 中的编织内容，名为 `UpdateContent()`
    的方法（由 `PickRandomStory()` 调用）向玩家提供两个选项，作为 `Button` 游戏对象。点击任何一个都会改变故事中变量的值。然后，这些更新作为两个变量的显示呈现给玩家，这两个变量在
    Unity 中被跟踪：`violence`（暴力）和 `peace`（和平）：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: While relatively simple, the project shown in this section illustrates an important
    aspect of balancing between ink and Unity as separate systems for procedural storytelling.
    The complexity of an ink story is not reflected in the C# code needed to pick
    it from a collection or show its contents. Simple code can be used in Unity to
    randomly select an ink story that, itself, uses randomness, substitution grammars,
    or its story planning in its design. In Unity, the C# `Random` class can be used
    without any knowledge of what an ink story is doing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然相对简单，但本节中展示的项目说明了在ink和Unity作为程序化叙事的独立系统之间平衡的重要方面。墨水故事的复杂性不会反映在选择它从集合中或显示其内容所需的C#代码中。在Unity中，可以使用简单的代码随机选择一个墨水故事，该故事本身在其设计中使用随机性、替换语法或其故事规划。在Unity中，可以使用C#的`Random`类，而不需要了解墨水故事正在做什么。
- en: In the next section, we will follow a similar movement to what we did in the
    *Introducing procedural storytelling in ink* topic. In this first section, we
    focused on using multiple ink stories with the C# `Random` class while picking
    between them equally. However, most projects will want to only select ink stories
    based on preconditions. In the next section, we will look at conditionally choosing
    between ink stories.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将遵循与我们在“在ink中引入程序化叙事”主题中所做的类似动作。在本节中，我们专注于使用多个ink故事与C#的`Random`类，并在它们之间进行平等选择。然而，大多数项目只想根据先决条件选择墨水故事。在下一节中，我们将探讨在墨水故事之间进行条件选择。
- en: Conditionally choosing stories
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件选择故事
- en: In the previous section, we saw how the C# `Random` class allows us to pick
    between objects based on the `Story` class as part of a collection, `List<Story>`.
    This has limited usefulness for most projects. Instead, most developers would
    prefer to have control over when an ink story is selected and the conditions under
    which it becomes available. In this section, we will look at a simple implementation
    of a system that checks the preconditions of a story before loading any of its
    contents. Values will be tracked across stories in the collection and, if the
    preconditions are met for the story, it will be considered available. If not,
    it will be ignored.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了C#的`Random`类如何允许我们根据`Story`类作为集合`List<Story>`的一部分来选择对象。这对大多数项目来说作用有限。相反，大多数开发者更希望控制何时选择一个墨水故事以及它成为可用的条件。在本节中，我们将探讨一个简单系统的实现，该系统在加载任何内容之前会检查故事的先决条件。值将在集合中的故事之间跟踪，如果满足故事的先决条件，它将被视为可用。如果不满足，则会被忽略。
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The completed project for this section can be found in the [*Chapter 12*](B17597_12_Final_PG_ePub.xhtml#_idTextAnchor174)
    examples on GitHub under the name `Chapter12-ConditionalStories`. Only select
    parts of the code will be shown as they relate to the concepts being examined.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本节完成的项目的示例可以在GitHub上的[*第12章*](B17597_12_Final_PG_ePub.xhtml#_idTextAnchor174)示例中找到，名称为`Chapter12-ConditionalStories`。将仅展示与正在检查的概念相关的代码部分。
- en: 'To check the preconditions of ink stories, there needs to be a separate class,
    `ConditionalStory`, that contains the ink story and methods that originally appeared
    in the *Tracking quest values* subsection of the *Displaying and awarding player
    progression* section in [*Chapter 11*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159),
    *Quest Tracking and Branching Narratives*, including simplified versions of `ObserveVariables()`
    and `UpdateVariable()`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查墨水故事的先决条件，需要一个单独的类，`ConditionalStory`，它包含墨水故事以及原本出现在[*第11章*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159)中“显示和奖励玩家进度”部分的“跟踪任务值”子部分的`ObserveVariables()`和`UpdateVariable()`方法：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `ConditionalStory` class has a method called `Available()`. Internally,
    this uses the `EvaluateFunction()` method of the `Story` class to call an ink
    function named `check()`. Assuming the ink story contains the function, it will
    be called, and the result will be converted into a Boolean value:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConditionalStory`类有一个名为`Available()`的方法。内部，它使用`Story`类的`EvaluateFunction()`方法来调用一个名为`check()`的ink函数。假设墨水故事包含该函数，它将被调用，并将结果转换为布尔值：'
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Each story file has a conditional check that is fed back into the `Available()`
    method of the `ConditionalStory` class. If the `check()` ink function returns
    `true`, the story is available for use.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每个故事文件都有一个条件检查，该检查被反馈到`ConditionalStory`类的`Available()`方法中。如果`check()` ink函数返回`true`，则故事可用于使用。
- en: 'Various changes have been made to the code shown in the previous section, *Using
    multiple stories*. The first is the use of `ConditionalStory` as a class containing
    an object based on the `Story` class. The second is the `SelectStories()` method.
    Unlike picking a random entry, it uses the `FindAll()` method of `List<ConditionalStory>`
    to search through its entries. If the `Available()` method, which is calling the
    `check()` ink function each time, reports `true`, it considers the story to be
    available:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对上一节中显示的代码进行了各种修改，*使用多个故事*。第一个是使用`ConditionalStory`作为一个包含基于`Story`类的对象的类。第二个是`SelectStories()`方法。与随机选择条目不同，它使用`List<ConditionalStory>`的`FindAll()`方法搜索其条目。如果`Available()`方法（每次调用时都会调用ink中的`check()`函数）报告`true`，则认为故事是可用的：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If each ink story defines how and if it is available for use in a larger project,
    this allows the ink and C# code in Unity to be developed separately. To become
    available so that it can be selected, the `check()` function in ink must report
    `true` to the `ConditionalStory` class in C#. This creates a simple but easily
    repeatable pattern for creating conditional stories in Unity based on understanding
    how its collections work by using the `FindAll()` method, as specified in this
    section, and the `Random` class, as specified in the previous section, in C# to
    access individual entries based on their indices.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个墨迹故事都定义了它是否以及如何可用于更大的项目，这允许墨迹和Unity中的C#代码分别开发。为了使其可用以便选择，ink中的`check()`函数必须向C#中的`ConditionalStory`类报告`true`。这创建了一个简单但易于重复的模式，用于在Unity中创建基于对如何使用`FindAll()`方法（如本节所述）和`Random`类（如前节所述）的集合工作原理的理解的基于条件的故事。
- en: Summary
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The goal of this chapter was not to solve all problems with procedural storytelling
    or to cover every possible algorithm. The first topic, *Introducing procedural
    storytelling in ink*, reviewed the important concepts, such as how randomness
    can play a role in selecting content in ink. The second section, *Loading values
    into ink*, looked at how more advanced concepts such as grammars and story planning
    can be used with ink. Finally, in the *Coding collections in Unity* topic, we
    saw how Unity can be used to randomly select ink stories in a collection in the
    first section, as well as how some simple conditional testing can be incorporated
    by communicating between ink stories and C# classes in Unity.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标不是解决程序化叙事的所有问题或涵盖所有可能的算法。第一个主题，*在ink中介绍程序化叙事*，回顾了重要概念，例如随机性如何在ink中选择内容中发挥作用。第二个部分，*将值加载到ink中*，探讨了如何使用ink结合更高级的概念，如语法和故事规划。最后，在*在Unity中编码集合*这一主题中，我们看到了Unity如何用于在集合中随机选择ink故事（第一部分），以及如何通过ink故事和Unity中的C#类之间的通信结合一些简单的条件测试。
- en: We have now completed the last chapter of this book and hope that you will walk
    away with different concepts to explore and with simple patterns to use for much
    more advanced projects. Procedural storytelling is a diverse and deep subject.
    Many researchers and developers have created and continue to explore possible
    ways to build substitution grammars, plan for stories, and use ink and Unity,
    either separately or together, to craft simple rules for complex stories and experiences
    for players.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了这本书的最后一章，希望你能带着不同的概念去探索，以及一些简单的模式来用于更高级的项目。程序化叙事是一个多样且深奥的主题。许多研究人员和开发者已经创建并继续探索构建替换语法的可能方法、规划故事以及使用ink和Unity（单独或一起）为玩家制作复杂故事和体验的简单规则。
- en: Questions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is procedural storytelling?
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是程序化叙事？
- en: What is a random table?
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是随机表？
- en: What is weighted randomness?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是加权随机性？
- en: What is substitution grammar?
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是替换语法？
- en: What is story planning?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是故事规划？
