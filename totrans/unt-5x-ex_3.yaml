- en: Chapter 3. Project B – the Space Shooter
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章项目B – 太空射击游戏
- en: 'This chapter enters new territory now as we begin development work on our second
    game, which is a twin-stick space shooter. The twin-stick genre simply refers
    to any game in which the player input for motion spans two dimensions or axes,
    typically one axis for movement and one for rotation. Example twin-stick games
    include *Zombies Ate My Neighbors* and *Geometry Wars*. Our game will rely heavily
    on coding in C#, as we''ll see. The primary purpose of this is to demonstrate
    by example just how much can be achieved with Unity procedurally (that is, via
    script), even without using the editor and level-building tools. We''ll still
    use these tools to some extent but not as much here, and that''s a deliberate
    and not an accidental move. Consequently, this chapter assumes that you have not
    only completed the game project created in the previous two chapters, but also
    have a good, basic knowledge of C# scripting generally, though not necessarily
    in Unity. So, let''s roll up our sleeves, if we have any, and get stuck in making
    a twin-stick shooter. This chapter covers the following important topics as well
    as others:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章现在进入了一个新的领域，因为我们开始开发我们的第二个游戏，这是一个双摇杆太空射击游戏。双摇杆类型简单指的是任何玩家输入动作跨越两个维度或轴的游戏，通常一个轴用于移动，一个轴用于旋转。例如，双摇杆游戏包括*Zombies
    Ate My Neighbors*和*Geometry Wars*。我们的游戏将大量依赖C#编程，正如我们将看到的。这样做的主要目的是通过示例展示，即使不使用编辑器和关卡构建工具，也可以通过Unity过程（即通过脚本）实现多少。我们仍然会在一定程度上使用这些工具，但在这里不会过多，这是一个故意的而不是偶然的选择。因此，本章假设您不仅完成了前两个章节中创建的游戏项目，而且对C#脚本有良好的、基本的知识，尽管不一定是在Unity中。所以，让我们卷起袖子，如果有，开始制作双摇杆射击游戏。本章还涵盖了以下以及其他重要主题：
- en: Spawning and prefabs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成和预制体
- en: Twin-stick controls and axial movement
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双摇杆控制和轴向移动
- en: Player controllers and shooting mechanics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家控制器和射击机制
- en: Basic enemy movement and AI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本敌人移动和AI
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to see the game created here, and its related work, in abstract terms,
    that is, as general tools and concepts with multiple applications. For your own
    projects, you may not want to make a twin-stick shooter, and that's fine. I cannot
    possibly know every kind of game that you want to make. However, it's important
    to see the ideas and tools used here as being transferrable, as being the kind
    of things you can creatively use for your own games. Being able to see this is
    very important when working with Unity or any engine.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，以抽象的方式看待这里创建的游戏及其相关工作，即作为具有多种应用的通用工具和概念。对于您自己的项目，您可能不想制作双摇杆射击游戏，这完全可以。我无法知道您想要制作的所有类型的游戏。然而，将这里使用到的想法和工具视为可转移的，作为您可以创造性地用于您自己游戏的工具，这一点非常重要。当使用Unity或任何引擎工作时，能够看到这一点非常重要。
- en: Looking ahead – the completed project
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展望未来 – 完成的项目
- en: Before getting stuck in with the twin-stick shooter game, let's see what the
    completed project looks like and how it works. See *Figure 3.1*. The game to be
    created will contain one scene only. In this scene, the player controls a spaceship
    that can shoot oncoming enemies. The directional keyboard arrows, and WASD, move
    the spaceship around the level, and it will always turn to face the mouse pointer.
    Clicking the left mouse button will fire ammo.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨双摇杆射击游戏之前，让我们先看看完成的项目的样子以及它是如何工作的。见*图3.1*。即将创建的游戏将只包含一个场景。在这个场景中，玩家控制一艘可以射击迎面敌人的宇宙飞船。方向键和WASD键可以移动飞船在关卡中的位置，并且它总是会转向面对鼠标指针。点击左鼠标按钮将发射弹药。
- en: '![Looking ahead – the completed project](img/B05118_03_01.png.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![展望未来 – 完成的项目](img/B05118_03_01.png.jpg)'
- en: 'Figure 3.1: The completed twin-stick shooter game'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：完成的双摇杆射击游戏
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The completed `TwinStickShooter` project, as discussed in this chapter and the
    next, can be found in the book companion files in the `Chapter03/TwinStickShooter
    folder`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章和下一章所讨论的，完成的`TwinStickShooter`项目可以在本书配套文件中的`Chapter03/TwinStickShooter`文件夹中找到。
- en: Most assets for this game (including sound and textures) were sourced from the
    freely accessible site, [OpenGameArt.org](http://OpenGameArt.org). Here, you can
    find many game assets available through the public domain or creative common licenses
    or other licenses.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本游戏的多数资源（包括声音和纹理）均来源于免费可访问的网站，[OpenGameArt.org](http://OpenGameArt.org)。在这里，您可以找到许多通过公共领域或创意共享许可或其他许可方式提供的游戏资源。
- en: Getting started with a space shooter
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始制作太空射击游戏
- en: 'To get started, create a blank Unity 3D project without any packages or specific
    assets. Details about creating new projects can be found in [Chapter 1](ch01.html
    "Chapter 1. The Coin Collection Game – Part 1"), *The Coin Collection Game – Part
    1*. We''ll be coding everything from scratch this time around. Once a project
    is generated, create some basic folders to structure and organize the project
    assets from the outset. This is very important to keep track of your files as
    you work. Create folders for `Textures`, `Scenes`, `Materials`, `Audio`, `Prefabs`,
    and `Scripts`. See *Figure 3.2*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，创建一个没有任何包或特定资源的空白Unity 3D项目。有关创建新项目的详细信息，请参阅[第1章](ch01.html "第1章. 硬币收集游戏
    – 第1部分")，*硬币收集游戏 – 第1部分*。这次我们将从头开始编写所有代码。一旦生成了一个项目，就创建一些基本的文件夹来从一开始就组织和结构化项目资源。这对于你在工作中跟踪文件非常重要。为`Textures`、`Scenes`、`Materials`、`Audio`、`Prefabs`和`Scripts`创建文件夹。参见*图3.2*：
- en: '![Getting started with a space shooter](img/B05118_03_02.png.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![开始制作太空射击游戏](img/B05118_03_02.png.jpg)'
- en: 'Figure 3.2: Create folders for structure and organization'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：创建文件夹以进行结构和组织
- en: 'Next, our game will depend on some graphical and audio assets. These are included
    in the book companion files in the `Chapter03/Assets` folder, but can also be
    downloaded online from [OpenGameArt.org](http://OpenGameArt.org). Let''s start
    with textures for the player spaceship, enemy spaceships, and star-field background.
    Drag and drop `Textures` from Windows Explorer or Finder to the Unity **Project**
    panel in the `Textures` folder. Unity imports and configures the textures automatically.
    *See Figure 3.3*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的游戏将依赖于一些图形和音频资源。这些资源包含在本书的配套文件中，位于`Chapter03/Assets`文件夹，也可以从[OpenGameArt.org](http://OpenGameArt.org)在线下载。让我们从玩家飞船、敌对飞船和星场背景的纹理开始。将`Textures`从Windows资源管理器或Finder拖放到`Textures`文件夹中的Unity
    **项目**面板。Unity会自动导入和配置纹理。*见图3.3*：
- en: '![Getting started with a space shooter](img/B05118_03_03.png.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![开始制作太空射击游戏](img/B05118_03_03.png.jpg)'
- en: 'Figure 3.3: Importing Texture assets for the spaceship, enemies, star background,
    and ammo'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：导入飞船、敌人、星背景和弹药纹理资源
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use of the provided assets is optional. You can create your own if you prefer.
    Just drag and drop your own textures in place of the included assets, and you
    can still follow along with the tutorial just fine.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的资源的使用是可选的。如果你愿意，可以创建自己的。只需将你自己的纹理拖放到包含的资产的位置，你仍然可以很好地跟随教程。
- en: 'By default, Unity imports image files as regular textures for use on 3D objects,
    and it assumes that their pixel dimensions are a power-2 size (4, 8, 16, 32, 64,
    128, 256, and so on). If the size is not actually one of these, then Unity will
    up-scale or down-scale the texture to the nearest valid size. This is not appropriate
    behavior, however, for a 2D top-down space shooter game in which imported textures
    should appear at their native (imported) size without any scaling or automatic
    adjustment. To fix this, select all the imported textures and, from the **Object
    Inspector**, change their **Texture Type** from **Texture** to **Sprite (2D and
    UI)**. Once changed, click on the **Apply** button to update the settings and
    the textures will retain their imported dimensions. See *Figure 3.4*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Unity将图像文件导入为常规纹理，用于3D对象，并假设它们的像素尺寸是2的幂次大小（4、8、16、32、64、128、256等等）。如果大小实际上不是这些之一，那么Unity将放大或缩小纹理到最近的合法大小。然而，对于应该以原始（导入）大小显示，没有任何缩放或自动调整的2D俯视太空射击游戏来说，这不是适当的行为。为了解决这个问题，选择所有导入的纹理，从**对象检查器**中，将它们的**纹理类型**从**纹理**更改为**精灵（2D和UI）**。一旦更改，点击**应用**按钮更新设置，纹理将保留其导入的尺寸。参见*图3.4*：
- en: '![Getting started with a space shooter](img/B05118_03_04.png.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![开始制作太空射击游戏](img/B05118_03_04.png.jpg)'
- en: 'Figure 3.4: Changing the Texture type for imported textures'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：更改导入纹理的纹理类型
- en: 'After changing the **Texture Type** setting to **Sprite (2D and UI)**, also
    remove the check mark from the **Generate Mip Maps** box, in case this box is
    enabled. This will prevent Unity from automatically downgrading the quality of
    textures based on their distance from the camera in the scene. This ensures that
    your textures retain their highest quality. More information on 2D texture settings
    and Mip Maps can be found at the online Unity documentationat [http://docs.unity3d.com/Manual/class-TextureImporter.html](http://docs.unity3d.com/Manual/class-TextureImporter.html).
    *See Figure 3.5*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在将**纹理类型**设置更改为**精灵（2D和UI）**后，也请从**生成Mip映射**框中取消勾选，以防此框被启用。这将防止Unity根据场景中纹理与摄像机的距离自动降低纹理质量。这确保了您的纹理保持最高质量。有关2D纹理设置和Mip映射的更多信息，请参阅在线Unity文档[http://docs.unity3d.com/Manual/class-TextureImporter.html](http://docs.unity3d.com/Manual/class-TextureImporter.html)。*见图3.5*：
- en: '![Getting started with a space shooter](img/B05118_03_05.png.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用太空射击游戏](img/B05118_03_05.png.jpg)'
- en: 'Figure 3.5: Removing MipMapping from imported textures'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：从导入的纹理中移除MipMapping
- en: 'Now you can easily drag and drop your textures to the scene adding them as
    sprite objects. You can''t drag and drop them from the **Project** panel to the
    viewport, but you can drag and drop them from the **Project** panel to the **Hierarchy**
    panel. When you do this, the texture will automatically be added as a sprite object
    in the **Scene**. We''ll make frequent use of this feature as we work at creating
    spaceship objects. See *Figure 3.6*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以将纹理轻松拖放到场景中，将它们作为精灵对象添加。您不能从**项目**面板拖放到视图中，但可以从**项目**面板拖放到**层次结构**面板。当您这样做时，纹理将自动作为精灵对象添加到**场景**中。在我们创建飞船对象的过程中，我们将频繁使用这个功能。*见图3.6*：
- en: '![Getting started with a space shooter](img/B05118_03_06.png.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用太空射击游戏](img/B05118_03_06.png.jpg)'
- en: 'Figure 3.6: Adding sprites to the scene'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：将精灵添加到场景中
- en: 'Next, let''s import music and sound effects, which are also included in the
    book companion files in the `Chapter03/Assets/Audio` folder. These assets were
    downloaded from [OpenGameArt.org](http://OpenGameArt.org). To import the audio,
    simply drag and drop the files from Windows Explorer or Mac Finder to the **Project**
    panel. When you do this, Unity automatically imports and configures the assets.
    You can give the audio a test from within the Unity Editor by pressing play on
    the preview toolbar from the **Object Inspector**. See *Figure 3.7*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们导入音乐和音效，这些内容也包含在本书的配套文件中，位于`Chapter03/Assets/Audio`文件夹中。这些资产是从[OpenGameArt.org](http://OpenGameArt.org)下载的。要导入音频，只需将文件从Windows资源管理器或Mac
    Finder拖放到**项目**面板中。当您这样做时，Unity会自动导入并配置这些资产。您可以通过在**对象检查器**的预览工具栏中按播放来在Unity编辑器内测试音频。*见图3.7*：
- en: '![Getting started with a space shooter](img/B05118_03_07.png.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用太空射击游戏](img/B05118_03_07.png.jpg)'
- en: 'Figure 3.7: Previewing audio from the Object Inspector'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7：在对象检查器中预览音频
- en: 'As with texture files, Unity imports audio files using a set of default parameters.
    These parameters are typically suitable for short sound effects such as footsteps,
    gunshots, and explosions, but for longer tracks such as music, they can be problematic,
    causing long level-loading times. To fix this, select the music track in the **Project**
    panel, and from the **Object Inspector**, disable the **Preload Audio Data** checkbox.
    From the **Load Type** drop-down box, select the **Streaming** option. This ensures
    that the music track is streamed as opposed to loaded wholly in memory at level
    startup. See *Figure 3.8*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与纹理文件一样，Unity使用一组默认参数导入音频文件。这些参数通常适用于短音效，如脚步声、枪声和爆炸声，但对于较长的轨道，如音乐，它们可能存在问题，会导致长时间的水平加载时间。为了解决这个问题，在**项目**面板中选择音乐轨道，并在**对象检查器**中禁用**预加载音频数据**复选框。从**加载类型**下拉菜单中选择**流式传输**选项。这确保音乐轨道以流式传输而不是在关卡启动时完全加载到内存中。*见图3.8*：
- en: '![Getting started with a space shooter](img/B05118_03_08.png.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用太空射击游戏](img/B05118_03_08.png.jpg)'
- en: 'Figure 3.8: Configuring music tracks for streaming'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：配置音乐轨道以进行流式传输
- en: Creating a player object
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建玩家对象
- en: 'We''ve now imported most assets for the twin-stick shooter and we''re ready
    to create a player spaceship object, that is, the object that the player will
    control and move around. Creating this might seem a trivial matter of simply dragging
    and dropping the relevant player sprite from the **Project** panel to the scene,
    but things are not so simple. The player is a complex object with many different
    behaviors, as we''ll see. For this reason, more care needs to be taken about creating
    the player. To get started, create an empty game object in the scene by navigating
    to **GameObject** | **Create Empty** from the application menu and name the object,
    `Player`. See *Figure 3.9*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已导入大多数双摇杆射击游戏资产，并准备好创建玩家飞船对象，即玩家将控制并移动的对象。创建此对象可能看似只是简单地从**项目**面板将相关的玩家精灵拖放到场景中这么简单的事情，但实际上并非如此。玩家是一个具有许多不同行为的复杂对象，正如我们将看到的。因此，在创建玩家时需要更加小心。要开始，通过从应用程序菜单导航到**GameObject**
    | **Create Empty** 在场景中创建一个空游戏对象，并将对象命名为`Player`。参见*图3.9*：
- en: '![Creating a player object](img/B05118_03_09.png.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家对象](img/B05118_03_09.png.jpg)'
- en: 'Figure 3.9: Starting to create the player'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：开始创建玩家
- en: 'The newly created object may or may not be centered at the world origin of
    *(0, 0, 0)* and its rotation properties may not be consistently `0` across **X**,
    **Y**, and **Z**. To ensure a completely zeroed transform, you could manually
    set the values to `0` by entering them directly in the **Transform** component
    for the object in the **Object Inspector**. However, you can set them all to `0`
    automatically by clicking on the cog icon at the top left corner of the **Transform**
    component and selecting **Reset** from the context menu. See *Figure 3.10*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的对象可能或可能不在世界原点 *(0, 0, 0)* 处居中，其旋转属性在 **X**、**Y** 和 **Z** 轴上可能不一致。为确保完全归零变换，您可以通过在**对象检查器**中直接输入值来手动将这些值设置为`0`。然而，您可以通过单击**变换**组件左上角的齿轮图标并从上下文菜单中选择**重置**来自动将它们全部设置为`0`。参见*图3.10*：
- en: '![Creating a player object](img/B05118_03_10.png.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家对象](img/B05118_03_10.png.jpg)'
- en: 'Figure 3.10: Resetting the Transform component'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10：重置变换组件
- en: 'Next, drag and drop the `Player` drop ship sprite (in the `Textures` folder)
    from the **Project** panel to the **Hierarchy** panel, making it a child of the
    empty player object. Then, rotate the drop ship sprite by `90` degrees in **X**
    and `-90` degrees in **Y**. This makes the sprite oriented in the direction of
    its parent''s forward vector and also flattened on the ground plane. The game
    camera will take a top-down view. See *Figure 3.11*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`Player`飞船精灵（位于`Textures`文件夹中）从**项目**面板拖放到**层次**面板，使其成为空玩家对象的子对象。然后，将飞船精灵在**X**轴上旋转`90`度，在**Y**轴上旋转`-90`度。这使得精灵朝向其父对象的正向向量，并在地面平面上展开。游戏摄像机将采用俯视视角。参见*图3.11*：
- en: '![Creating a player object](img/B05118_03_11.png.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家对象](img/B05118_03_11.png.jpg)'
- en: 'Figure 3.11: Aligning the Player ship'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：对齐玩家飞船
- en: 'You can confirm that the ship sprite has been aligned correctly in relation
    to its parent by selecting the `Player` object and viewing the blue forward vector
    arrow. The front of the ship sprite and the blue forward vector should be pointing
    in the same direction. If they''re not, then continue to rotate the sprite by
    90 degrees until they''re in alignment. This will be important later when coding
    player movement to make the ship travel in the direction it''s looking. See *Figure
    3.12*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过选择`Player`对象并查看蓝色正向向量箭头来确认飞船精灵相对于其父对象的定位是否正确。飞船精灵的前部和蓝色正向向量应该指向同一方向。如果不是，则继续将精灵旋转90度，直到它们对齐。这在编写玩家移动代码，使飞船朝向其注视的方向移动时将非常重要。参见*图3.12*：
- en: '![Creating a player object](img/B05118_03_12.png.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家对象](img/B05118_03_12.png.jpg)'
- en: 'Figure 3.12: The blue arrow is called the forward vector'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12：蓝色箭头被称为正向向量
- en: 'Next, the `Player` object should react to physics, that is, the `Player` object
    is solid and affected by physical forces. It must collide with other solids and
    also take damage from enemy ammo when hit. To facilitate this, two additional
    components should be added to the `Player` object, specifically, a **Rigidbody**
    and **Collider**. To do this, select the `Player` object (not the `Sprite` object)
    and navigate to **Component** | **Physics** | **Rigidbody** from the application
    menu. Then, choose `Component` | **Physics** | **Capsule Collider** from the menu.
    This adds both a **Rigidbody** and **Collider**. See *Figure 3.13*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`Player` 对象应该对物理力做出反应，也就是说，`Player` 对象是实心的，会受到物理力的影响。它必须与其他固体碰撞，并在被击中时受到敌人弹药的伤害。为此，应向
    `Player` 对象添加两个额外的组件，具体来说，是一个 **Rigidbody** 和 **Collider**。要做到这一点，选择 `Player`
    对象（而不是 `Sprite` 对象），从应用程序菜单导航到 **Component** | **Physics** | **Rigidbody**。然后，从菜单中选择
    **Component** | **Physics** | **Capsule Collider**。这会添加一个 **Rigidbody** 和 **Collider**。参见
    *图 3.13*：
- en: '![Creating a player object](img/B05118_03_13.png.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家对象](img/B05118_03_13.png.jpg)'
- en: 'Figure 3.13: Adding a Rigidbody and Capsule Collider to the Player object'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13：向玩家对象添加 Rigidbody 和 Capsule Collider
- en: 'The **Collider** component is used to approximate the volume of the object
    and the **Rigibody** component uses the **Collider** to determine how physical
    forces should be applied realistically. Let''s adjust **Capsule Collider** a little
    because the default settings typically do not match up with the `Player` sprite
    as intended. Specifically, adjust the **Direction**, **Radius**, and **Height**
    values until **Capsule** encompasses the `Player` sprite and represents the volume
    of the player. See *Figure 3.14*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**Collider** 组件用于近似对象的体积，而 **Rigibody** 组件则使用 **Collider** 来确定物理力应该如何真实地应用。让我们稍微调整一下
    **Capsule Collider**，因为默认设置通常与预期的 `Player` 精灵不匹配。具体来说，调整 **方向**、**半径** 和 **高度**
    值，直到 **Capsule** 包围 `Player` 精灵并代表玩家的体积。参见 *图 3.14*：'
- en: '![Creating a player object](img/B05118_03_14.png.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家对象](img/B05118_03_14.png.jpg)'
- en: 'Figure 3.14: Adjusting the spaceship Capsule Collider'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14：调整飞船 Capsule Collider
- en: 'By default, the `Rigidbody` component is configured to approximate objects
    that are affected by gravity and fall to the ground, bumping into and reacting
    to other solids in the scene. This is not appropriate for a spaceship that flies
    around. Consequently, the `Rigidbody` should be adjusted. Specifically, remove
    the **Use Gravity** check mark to prevent the object from falling to the ground.
    Additionally, enable the **Freeze Position** **Y** checkbox and the **Freeze Rotation**
    **Z** checkbox to prevent the spaceship moving and rotating around axes that are
    undesirable in a 2D top-down game. See *Figure 3.15*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Rigidbody` 组件被配置为近似受重力影响的对象，这些对象会落到地面上，撞击并反应场景中的其他固体。这对于在空中飞行的飞船来说是不合适的。因此，应该调整
    `Rigidbody`。具体来说，取消勾选 **Use Gravity** 复选框以防止对象落到地面上。此外，启用 **Freeze Position**
    **Y** 复选框和 **Freeze Rotation** **Z** 复选框以防止飞船在2D俯视游戏中沿不希望轴移动和旋转。参见 *图 3.15*：
- en: '![Creating a player object](img/B05118_03_15.png.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![创建玩家对象](img/B05118_03_15.png.jpg)'
- en: 'Figure 3.15: Configuring the Rigidbody component for the player spaceship'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15：配置玩家飞船的 Rigidbody 组件
- en: Excellent work! We've now configured the player spaceship object successfully.
    Of course, it still doesn't move or do anything specific in the game. This is
    simply because we haven't added any code yet. That's something we'll turn to next—making
    the player object respond to user input.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的工作！我们现在已经成功配置了玩家飞船对象。当然，它仍然不会移动或做任何特定的游戏动作。这仅仅是因为我们还没有添加任何代码。这正是我们接下来要做的——使玩家对象对用户输入做出反应。
- en: Player input
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家输入
- en: 'The `Player` object is now created in the scene, configured with both **Rigidbody**
    and **Collider** components. However, this object doesn''t respond to player controls.
    In a twin-stick shooter, the player provides input on two axes and can typically
    shoot a weapon. This often means that keyboard WASD buttons guide player movements
    up, down, left, and right. In addition, mouse movement controls the direction
    in which the player is looking and aiming and the left mouse button typically
    fires a weapon. This is the control scheme required for our game. To implement
    this, we''ll need to create a `PlayerController` script file. Right-click on the
    `Scripts` folder of the **Project** panel and create a new C# script file named
    `PlayerController.cs`. See *Figure 3.16*:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player`对象现在已在场景中创建，配置了**Rigidbody**和**Collider**组件。然而，此对象不会对玩家控制做出反应。在双摇杆射击游戏中，玩家在两个轴向上提供输入，通常可以射击武器。这通常意味着WASD键盘按钮控制玩家向上、向下、向左和向右移动。此外，鼠标移动控制玩家查看和瞄准的方向，而左鼠标按钮通常用于射击武器。这是我们游戏所需的控制方案。为了实现这一点，我们需要创建一个`PlayerController`脚本文件。在**项目**面板的`Scripts`文件夹上右键单击，创建一个名为`PlayerController.cs`的新C#脚本文件。参见*图
    3.16*：'
- en: '![Player input](img/B05118_03_16.png.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![玩家输入](img/B05118_03_16.png.jpg)'
- en: 'Figure 3.16: Creating a player controller C# script file'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16：创建玩家控制器 C# 脚本文件
- en: 'In the `PlayerController.cs` script file, the following code (as shown in *Code
    Sample 3.1*) should be featured. Comments follow this sample:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PlayerController.cs`脚本文件中，以下代码（如*代码示例 3.1*所示）应该被包含。注释跟在此示例之后：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Code Sample 3.1
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例 3.1
- en: 'The following points summarize the code sample:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: The `PlayerController` class should be attached to the `Player` object in the
    scene. Overall, it accepts input from the player and will control the movement
    of the spaceship.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerController`类应该附加到场景中的`Player`对象上。总体而言，它接受玩家的输入并将控制太空船的移动。'
- en: The `Awake` function is called once when the object is created at the level
    start. During this function, two components are retrieved, namely, the **Transform**
    component for controller player rotation and the **Rigidbody** component for controller
    player movement. The **Transform** component can be used to control player movement
    through the **Position** property, but this ignores collisions and solid objects.
    The **Rigidbody** component, in contrast, prevents the player object from passing
    through other solids.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象在关卡开始时创建时，会调用一次`Awake`函数。在此函数期间，检索了两个组件，即用于控制器玩家旋转的**Transform**组件和用于控制器玩家移动的**Rigidbody**组件。**Transform**组件可以通过**Position**属性来控制玩家移动，但这会忽略碰撞和固体物体。相比之下，**Rigidbody**组件可以防止玩家对象穿过其他固体物体。
- en: The `FixedUpdate` function is called once on each update of the physics system,
    which is a fixed number of times per second. `FixedUpdate` differs from `Update`,
    which is called once per frame and can vary on a per second basis as the frame
    rate fluctuates. If you ever need to control an object through the physics system,
    using components such as **Rigidbody**, then you should always do so in `FixedUpdate`
    and not `Update`. This is a Unity convention that you should remember for best
    results.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FixedUpdate`函数在物理系统每次更新时都会被调用一次，这是每秒固定次数的调用。`FixedUpdate`与`Update`不同，`Update`函数每次帧调用一次，并且会根据帧率的变化而变化。如果你需要通过物理系统控制对象，使用如**Rigidbody**之类的组件，那么你应该始终在`FixedUpdate`中这样做，而不是在`Update`中。这是Unity的一个约定，你应该记住以获得最佳效果。'
- en: The `Input.GetAxis` function is called on each `FixedUpdate` to read the axial
    input data from an input device, such as the keyboard or gamepad. This function
    reads from two named axes, `Horizontal` (left-right) and `Vertical` (up-down).
    These work in a normalized space of *-1* to *1*. This means that when the left
    key is pressed and held down, the `Horizontal` axis returns *-1* and, when the
    right key is being pressed and held down, the `Horizontal` axis returns *1*. A
    value of *0* indicates that either no relevant key is being pressed or both left
    and right are being pressed together, canceling each other out. A similar principle
    applies for the `Vertical` axis. Up refers to *1*, down to *-1*, and no keypress
    relates to *0*. More information on the `GetAxis` function can be found online
    in the Unity documentation at [http://docs.unity3d.com/ScriptReference/Input.GetAxis.html](http://docs.unity3d.com/ScriptReference/Input.GetAxis.html).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Input.GetAxis` 函数在每次 `FixedUpdate` 调用中都会被调用，用于从输入设备（如键盘或游戏手柄）读取轴向输入数据。此函数从两个命名轴读取数据，`Horizontal`（左右）和`Vertical`（上下）。这些轴在一个归一化空间中工作，范围从
    *-1* 到 *1*。这意味着当按下并保持左键时，`Horizontal` 轴返回 *-1*，而当按下并保持右键时，`Horizontal` 轴返回 *1*。值为
    *0* 表示没有按下相关键或同时按下左右键，相互抵消。对于 `Vertical` 轴，向上表示 *1*，向下表示 *-1*，没有按键按下对应于 *0*。有关
    `GetAxis` 函数的更多信息，可以在 Unity 文档的在线文档中找到，网址为 [http://docs.unity3d.com/ScriptReference/Input.GetAxis.html](http://docs.unity3d.com/ScriptReference/Input.GetAxis.html)。'
- en: The `Rigidbody.AddForce` function is used to apply a physical force to the `Player`
    object, moving it in a specific direction. `AddForce` encodes a velocity, moving
    the object in a specific direction by a specific strength. The direction is encoded
    in the `MoveDirection` vector, which is based on player input from both the `Horizontal`
    and `Vertical` axes. This direction is multiplied by our maximum speed to ensure
    that the object travels as fast as needed. For more information on `AddForce`,
    see the online Unity documentation at [http://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html](http://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rigidbody.AddForce` 函数用于对 `Player` 对象施加物理力，使其沿特定方向移动。`AddForce` 编码一个速度，通过特定的强度将对象移动到特定方向。方向编码在
    `MoveDirection` 向量中，该向量基于来自 `Horizontal` 和 `Vertical` 轴的玩家输入。这个方向乘以我们的最大速度，以确保对象以所需的速度移动。有关
    `AddForce` 的更多信息，请参阅 Unity 在线文档，网址为 [http://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html](http://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html)。'
- en: The `Camera.ScreenToWorldPoint` function is used to convert the screen position
    of the mouse cursor in the game window into a position in the game world, giving
    the player a target destination to look at. This code is responsible for making
    the player look at the mouse cursor always. However, as we'll see soon, some further
    tweaking is required to make this code work properly. For more information on
    `ScreenToWorldPoint`, see the Unity online documentation at [http://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html](http://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html).
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Camera.ScreenToWorldPoint` 函数用于将游戏窗口中鼠标光标的屏幕位置转换为游戏世界中的位置，为玩家提供一个目标目的地进行观察。此代码负责使玩家始终看向鼠标光标。然而，正如我们很快将看到的，需要对代码进行一些调整才能使其正常工作。有关
    `ScreenToWorldPoint` 的更多信息，请参阅 Unity 在线文档，网址为 [http://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html](http://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html)。'
- en: Configuring the game camera
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置游戏相机
- en: 'The preceding code allows you to control the `Player` object, but there are
    some problems. One of them is that the player doesn''t seem to face the position
    of the mouse cursor, even though our code is designed to achieve this behavior.
    The reason is that the camera, by default, is not configured as it needs to be
    for a top-down 2D game. We''ll fix this in this section. To get started, the scene
    camera should have a top-down view of the scene. To achieve this, switch the **Scene**
    viewport to a top-down 2D view by clicking on the **ViewCube**, the up arrow in
    the top right corner of the **Scene** viewport. This switches your viewport to
    a top view. See *Figure 3.17*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码允许您控制 `Player` 对象，但存在一些问题。其中之一是玩家似乎没有面向鼠标光标的位置，尽管我们的代码旨在实现这种行为。原因是默认情况下，相机没有配置为适用于俯视
    2D 游戏所需的配置。我们将在本节中修复这个问题。要开始，场景相机应该以俯视视角查看场景。为此，通过单击 **ViewCube**（位于 **Scene**
    视口右上角的向上箭头），将 **Scene** 视口切换到俯视 2D 视图。这将切换您的视口到俯视图。参见 *图 3.17*：
- en: '![Configuring the game camera](img/B05118_03_17.png.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![配置游戏相机](img/B05118_03_17.png.jpg)'
- en: 'Figure 3.17: The viewcube can change the viewport perspective'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17：视图立方体可以改变视口视角
- en: 'You can see that the viewport is in a top view because the viewcube will list
    **Top** as the current view. See *Figure 3.18*:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到视口处于俯视图，因为视图立方体将列出**Top**作为当前视图。见图3.18：
- en: '![Configuring the game camera](img/B05118_03_18.png.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![配置游戏相机](img/B05118_03_18.png.jpg)'
- en: 'Figure 3.18: Top view in the Scene viewport'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18：场景视口中的俯视图
- en: 'From here, you can have the scene camera conform to the viewport camera exactly,
    giving you an instant top-down view for your game. To do this, select the **Camera**
    in the **Scene** (or from the **Hierarchy** panel) and then choose **GameObject**
    | **Align With View** from the application menu. See *Figure 3.19*:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你可以使场景相机与视口相机完全一致，为你提供游戏中的即时俯视图。为此，在**场景**（或从**层次**面板）中选择**相机**，然后从应用程序菜单中选择**GameObject**
    | **Align With View**。见图3.19：
- en: '![Configuring the game camera](img/B05118_03_19.png.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![配置游戏相机](img/B05118_03_19.png.jpg)'
- en: 'Figure 3.19: Aligning the camera to the Scene viewport'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19：将相机与场景视口对齐
- en: 'This makes your game look much better than before, but there''s still a problem.
    When the game is running, the spaceship still doesn''t look at the mouse cursor
    as intended. This is because the camera is a **Perspective** camera and the conversion
    between a screen point and world point is leading to unexpected results. We can
    fix this by changing the camera to an **Orthographic** camera, which is a truly
    2D camera that allows no perspective distortion. To do this, select the **Camera**
    in the scene, and from the **Object Inspector**, change the **Projection** setting
    from **Perspective** to **Orthographic**:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这使你的游戏看起来比以前好得多，但仍然存在问题。当游戏运行时，飞船仍然没有按照预期看向鼠标光标。这是因为相机是**透视**相机，屏幕点与世界点之间的转换导致了意外的结果。我们可以通过将相机更改为**正交**相机来解决这个问题，这是一个真正的2D相机，它不允许透视失真。为此，在场景中选择**相机**，然后在**对象检查器**中，将**投影**设置从**透视**更改为**正交**：
- en: '![Configuring the game camera](img/B05118_03_20.png.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![配置游戏相机](img/B05118_03_20.png.jpg)'
- en: 'Figure 3.20: Changing the Camera to Orthographic mode'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20：将相机切换到正交模式
- en: 'Every orthographic camera has a **Size** field in the **Object Inspector**,
    which is not present for perspective cameras. This field controls how many units
    in the world view correspond to pixels on the screen. We want a 1:1 ratio or relationship
    between world units to pixels in order to ensure that our textures appear at the
    correct size and cursor movement has the intended effect. The target resolution
    for our game will be Full HD, which is 1920 x 1080, and this has an aspect ratio
    of 16:9\. For this resolution, the orthographic **Size** should be `5.4`. The
    reasons for this value are beyond the scope of this book, but the formula to arrive
    at it is *screen height (in pixels) / 2 / 100*. Therefore, *1080 / 2 / 100 = 5.4*.
    See *Figure 3.21*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每个正交相机在**对象检查器**中都有一个**大小**字段，而透视相机则没有。该字段控制世界视图中多少单位对应屏幕上的像素。我们希望世界单位与像素之间有一个1:1的比例或关系，以确保我们的纹理以正确的尺寸显示，并且光标移动产生预期效果。我们游戏的目标分辨率将是全高清，即1920
    x 1080，其宽高比为16:9。对于这个分辨率，正交的**大小**应该是`5.4`。这个值的原因超出了本书的范围，但得出这个值的公式是*屏幕高度（以像素为单位）/
    2 / 100*。因此，*1080 / 2 / 100 = 5.4*。见图3.21：
- en: '![Configuring the game camera](img/B05118_03_21.png.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![配置游戏相机](img/B05118_03_21.png.jpg)'
- en: 'Figure 3.21: Changing orthographic size for a 1:1 pixel-to-screen ratio'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21：为1:1像素到屏幕比例更改正交大小
- en: 'Finally, make sure that your **Game** tab view is configured to display the
    game at a **16:9** aspect ratio. If it isn''t, click on the aspect drop-down list
    at the top left corner of the **Game** view and choose the **16:9** option. See
    *Figure 3.22*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保你的**游戏**标签视图配置为以**16:9**宽高比显示游戏。如果不是，点击**游戏**视图左上角的宽高比下拉列表，并选择**16:9**选项。见图3.22：
- en: '![Configuring the game camera](img/B05118_03_22.png.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![配置游戏相机](img/B05118_03_22.png.jpg)'
- en: 'Figure 3.22: Displaying the game at a 16:9 aspect ratio'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.22：以16:9宽高比显示游戏
- en: Now try running the game, and you have a player spaceship that moves based on
    WASD input and also turns to face the mouse cursor. Great work! See *Figure 3.23*.
    The game is really taking shape. However, there's lots more work to do.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行游戏，你将有一个基于WASD输入移动并转向面对鼠标光标的玩家飞船。干得好！见图3.23。游戏真的开始成形了。然而，还有很多工作要做。
- en: '![Configuring the game camera](img/B05118_03_23.png.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![配置游戏相机](img/B05118_03_23.png.jpg)'
- en: 'Figure 3.23: Turning to face the cursor!'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Bounds locking
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On previewing the game thus far, the spaceship probably looks too large. We
    can fix this easily by changing the scale of the `Player` object. I've used a
    value of `0.5` for the **X**, **Y**, and **Z** axes. See *Figure 3.24*. However,
    even with a more sensible scale, a problem remains. Specifically, it's possible
    to move the player outside the boundaries of the screen without limit. This means
    that the player can fly off into the distance, out of view, and never be seen
    again. Instead, the camera should remain still and the player movement should
    be limited to the camera view or bounds so that it never exits the view.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![Bounds locking](img/B05118_03_24.png.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.24: Rescaling the player'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: There are different ways to achieve bounds locking, most of which involve scripting.
    One way is to simply clamp the positional values of the `Player` object between
    a specified range, a minimum and maximum. Consider *Code Sample 3.2* for a new
    C# class called `BoundsLock`. This script file should be attached to the player.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Code Sample 3.2
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: The `LateUpdate` function is always called after all the `FixedUpdate` and `Update`
    calls, allowing an object to modify its position before it's rendered to the screen.
    More information on `LateUpdate` can be found at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html).
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Mathf.Clamp` function ensures that a specified value is capped between
    a minimum and maximum range.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use the `BoundsLock` script, simply drag and drop the file to the `Player`
    object and specify minimum and maximum values for its position. These values are
    specified in world position coordinates and can be determined by temporarily moving
    the `Player` object to the camera extremes and recording its position from the
    **Transform** component:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Code Sample 3.2](img/B05118_03_25.png.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.25: Setting Bounds Lock'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Now take the game for a test run by pressing play on the toolbar. The player
    spaceship should remain in view and be unable to move offscreen. Splendid!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Health
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both the player spaceship and enemies need health. Health is a measure of a
    character''s presence and legitimacy in the scene, typically scored as a value
    between 0-100\. 0 means death and 100 means full health. Now, although health
    is, in many respects, specific to each instance, (The player has a unique health
    bar and each enemy has theirs.) there are nevertheless so many things in common,
    in terms of behavior, between player and enemy health that it makes sense to code
    health as a separate component and class that can be attached to all objects that
    need health. Consider *Code Sample 3.3*, which should be attached to the player
    and all enemies or objects that need health. Comments follow:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Code Sample 3.3
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The `Health` class maintains object health through a `private` variable, `_HealthPoints`,
    which is accessed through a C# property, `HealthPoints`. This property features
    both `get` and `set` accessors to return and set the `Health` variable.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Health` 类通过一个 `private` 变量 `_HealthPoints` 维护对象的生命值，该变量通过 C# 属性 `HealthPoints`
    访问。这个属性具有 `get` 和 `set` 访问器，用于返回和设置 `Health` 变量。'
- en: The `_HealthPoints` variable is declared as `SerializedField`, allowing its
    value to be visible in the **Inspector**. This helps us see the value of the player's
    health during runtime and debug and test the effects of our code.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_HealthPoints` 变量被声明为 `SerializedField`，这使得其值在 **Inspector** 中可见。这有助于我们在运行时查看玩家的生命值，并调试和测试代码的效果。'
- en: The `Health` class is an example of event-driven programming. This is because
    the class could have continually checked the status of object health during an
    `Update` function; checking to see whether the object had died by its health falling
    below *0*. Instead, the check for death is made during the C# property `set` method.
    This makes sense because `set` is the only place where health will ever change.
    This means that Unity is saved from a lot of work in each frame. That's great
    performance saving!
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Health` 类是事件驱动编程的一个例子。这是因为该类本可以在 `Update` 函数中持续检查对象的生命状态；检查对象的生命值是否下降到 *0*
    以判断其是否已死亡。相反，死亡检查是在 C# 属性 `set` 方法中进行的。这样做是有道理的，因为 `set` 是生命值唯一可能改变的地方。这意味着 Unity
    在每一帧中节省了大量工作。这是一个很好的性能提升！'
- en: '`Health` class uses the `SendMessage` function. This function lets you call
    any other public function on any component attached to the object by specifying
    the function name as a string. In this case, a function called `Die` will be executed
    on every component attached to the object (if such a function exists). If no function
    of a matching name exists, then nothing happens for that component. This is a
    quick and easy way to run customized behavior on an object in a type-agnostic
    way without using any polymorphism. The disadvantage is that `SendMessage` internally
    uses a process called `Reflection`, which is slow and performance-prohibitive.
    For this reason, `SendMessage` should be used infrequently only for death events
    and similar events, but not frequently, such as every frame. More information
    on `SendMessage` can be found at the online Unity documentation at [http://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html](http://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html).'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Health` 类使用 `SendMessage` 函数。这个函数允许你通过指定函数名作为字符串来调用任何附加到对象上的组件的任何公共函数。在这种情况下，一个名为
    `Die` 的函数将在每个附加到对象上的组件上执行（如果存在这样的函数）。如果没有匹配名称的函数，则该组件不会发生任何操作。这是一个快速简单的方法，可以在不使用任何多态的情况下以类型无关的方式在对象上运行自定义行为。缺点是
    `SendMessage` 在内部使用一个称为 `Reflection` 的过程，这个过程很慢，并且会降低性能。因此，`SendMessage` 应该仅在不频繁的情况下使用，例如仅在死亡事件和类似事件中，而不是每帧都使用。有关
    `SendMessage` 的更多信息，可以在 Unity 在线文档中找到，网址为 [http://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html](http://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)。'
- en: When health falls below *0*, triggering a death condition, the code will instantiate
    a death particle system to show an effect on death if a particle system is specified
    (more on this shortly).
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当生命值下降到 *0* 以下，触发死亡条件时，代码将实例化一个死亡粒子系统以显示死亡效果（关于这一点稍后会有更多说明）。
- en: 'When the `Health` script is attached to the player spaceship, it appears as
    a component in the **Inspector**. It contains a field for a **Death Particles
    Prefab**. This is an optional field (it can be null), specifying a particle system
    to be spawned when the object dies. This lets you create explosions or blood splatter
    effects easily when objects die. See *Figure 3.26*:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Health` 脚本附加到玩家飞船上时，它会在 **Inspector** 中作为一个组件出现。它包含一个用于 **Death Particles
    Prefab** 的字段。这是一个可选字段（它可以设置为 null），用于指定在对象死亡时生成粒子系统的粒子系统。这使得在对象死亡时轻松创建爆炸或血液飞溅效果。请参见
    *图 3.26*：
- en: '![Code Sample 3.3](img/B05118_03_26.png.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 3.3](img/B05118_03_26.png.jpg)'
- en: 'Figure 3.26: Attaching the Health script'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.26：附加 Health 脚本
- en: Death and particles
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死亡与粒子
- en: 'In this twin-stick shooter game, both the player and enemies are spaceships.
    When they''re destroyed, they should explode in a fiery ball. This is really the
    only kind of effect that would be believable. To achieve explosions, we can use
    a particle system. This simply refers to a special kind of object that features
    two main parts, namely, a **Hose** (or **Emitter**) and **Particles**. The emitter
    refers to the part that spawns or generates new particles into the world and the
    particles are many small objects or pieces that, once spawned, move and travel
    along their own trajectories. In short, particle systems are ideal to create rain,
    snow, fog, sparkles, and explosions. We can create our own Particle Systems from
    scratch using the menu option, **GameObject** | **Particle System**, or we can
    use any premade particle system included with Unity. Let''s use some of the premade
    particle systems. To do this, import the `ParticleSystems` package to the project
    by navigating to **Assets** | **Import Package** | **ParticleSystems** from the
    application menu. See *Figure 3.27*:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个双摇杆射击游戏中，玩家和敌人都是宇宙飞船。当它们被摧毁时，应该以火球的形式爆炸。这确实是唯一可能令人信服的效果。为了实现爆炸效果，我们可以使用粒子系统。这简单指的是一种具有两个主要部分的特殊对象，即**软管**（或**发射器**）和**粒子**。发射器指的是将新粒子生成到世界中的部分，而粒子是许多小对象或碎片，一旦生成，就会移动并沿着自己的轨迹移动。简而言之，粒子系统非常适合创建雨、雪、雾、闪光和爆炸。我们可以通过使用菜单选项**GameObject**
    | **粒子系统**从头开始创建自己的粒子系统，或者我们可以使用Unity附带的所有预制的粒子系统。让我们使用一些预制的粒子系统。为此，通过从应用程序菜单导航到**资产**
    | **导入包** | **粒子系统**将`ParticleSystems`包导入到项目中。见*图3.27*：
- en: '![Death and particles](img/B05118_03_27.png.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![死亡与粒子](img/B05118_03_27.png.jpg)'
- en: 'Figure 3.27: Importing Particle Systems to the project'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.27：将粒子系统导入到项目中
- en: After the **Import** dialog appears, leave all settings at their defaults, and
    simply click on **Import** to import the complete package, including all particle
    systems. The `ParticleSystems` will be added to the **Project** panel in the `Standard
    Assets` | `ParticleSystems` | `Prefabs` folder. See *Figure 3.28*. You can test
    each of the particle systems by simply dragging and dropping each prefab to the
    scene. Note that you can only preview a particle system in the **Scene** viewport
    while it is selected.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在**导入**对话框出现后，请保持所有设置为默认值，并简单地点击**导入**以导入完整包，包括所有粒子系统。`ParticleSystems`将被添加到**项目**面板中的`标准资产`
    | `粒子系统` | `预制体`文件夹中。见*图3.28*。您可以通过将每个预制体简单地拖放到场景中来测试每个粒子系统。请注意，您只能在**场景**视图中选择粒子系统时预览它。
- en: '![Death and particles](img/B05118_03_28.png.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![死亡与粒子](img/B05118_03_28.png.jpg)'
- en: 'Figure 3.28: Particle Systems imported to the Project panel'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.28：导入到项目面板中的粒子系统
- en: 'Notice from *Figure 3.28* that an **Explosion** system is included among the
    default assets, which is great news! To test, we can just drag and drop the explosion
    to the scene, press play on the toolbar, and see the explosion in action. Good!
    We''re almost done, but there''s still a bit more work. We''ve now seen that an
    appropriate particle system is available and we could just drag and drop this
    system to the **Death Particles Prefab** slot in the **Health** component in the
    **Inspector**. This will work technically: when a player or enemy dies, the explosion
    system will be spawned, creating an explosion effect. However, the particle system
    will never be destroyed! This is problematic because, on each enemy death, a new
    particle system will be spawned. This raises the possibility that, after many
    deaths, the scene will be full of disused particle systems. We don''t want this;
    it''s bad for performance and memory usage to have a scene full of unused objects
    lingering around. To fix this, we''ll modify the explosion system slightly, creating
    a new and modified prefab that''ll suit our needs. To create this, drag and drop
    the existing explosion system anywhere to the scene and position it at the world
    origin. See *Figure 3.29*:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *图 3.28* 可以看出，**爆炸** 系统包含在默认资源中，这是一个好消息！为了测试，我们只需将爆炸拖放到场景中，在工具栏上按下播放，就可以看到爆炸效果。很好！我们几乎完成了，但还有一些工作要做。我们已经看到，有一个合适的粒子系统可用，并且我们可以直接将这个系统拖放到
    **Inspector** 中的 **Health** 组件的 **Death Particles Prefab** 槽中。这在技术上是可以工作的：当玩家或敌人死亡时，爆炸系统将被生成，产生爆炸效果。然而，粒子系统永远不会被销毁！这是问题所在，因为，在每次敌人死亡时，都会生成一个新的粒子系统。这可能导致，在经历了多次死亡后，场景中充满了未使用的粒子系统。我们不希望这样；场景中充满了闲置的对象，这对性能和内存使用都是不利的。为了解决这个问题，我们将稍微修改爆炸系统，创建一个新的、修改过的预制件，以满足我们的需求。为了创建这个预制件，将现有的爆炸系统拖放到场景中的任何位置，并将其放置在世界原点。参见
    *图 3.29*：
- en: '![Death and particles](img/B05118_03_29.png.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![死亡和粒子](img/B05118_03_29.png.jpg)'
- en: 'Figure 3.29: Adding an Explosion system to the scene for modification'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.29：将爆炸系统添加到场景中进行修改
- en: 'Next, we must refine the particle system to destroy itself soon after instantiation.
    By making a prefab from this arrangement, each and every generated explosion will
    eventually destroy itself. To make an object destroy itself after a specified
    interval, we''ll create a new C# script. I''ll name this script `TimeDestroy.cs`.
    Refer the following code in *Code Sample 3.4*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须细化粒子系统，使其在实例化后不久自行销毁。通过从这个配置创建一个预制件，每个生成的爆炸最终都会自行销毁。为了使对象在指定的时间间隔后自行销毁，我们将创建一个新的
    C# 脚本。我将把这个脚本命名为 `TimeDestroy.cs`。参考 *代码示例 3.4* 中的以下代码：
- en: '[PRE3]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Code Sample 3.4
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例 3.4
- en: 'The following points summarize the code sample:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: The `TimeDestroy` class simply destroys the object to which it's attached after
    a specified interval (`DestroyTime`) has elapsed.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimeDestroy` 类简单地在指定的时间间隔 (`DestroyTime`) 过去后销毁它附加的对象。'
- en: The `Invoke` function is called in the `Start` event. Invoke will execute a
    function of the specified name once, and only once, after a specified interval
    has elapsed. The interval is measured in seconds.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoke` 函数在 `Start` 事件中被调用。`Invoke` 将在指定的时间间隔过去后执行指定名称的函数一次，并且仅执行一次。间隔以秒为单位。'
- en: Like `SendMessage`, the `Invoke` function relies on `Reflection`. For this reason,
    it should be used sparingly for best performance.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `SendMessage` 类似，`Invoke` 函数依赖于 `Reflection`。因此，为了获得最佳性能，应谨慎使用。
- en: The `Die` function will be executed by `Invoke` after a specified interval to
    destroy the `gameobject` (such as a particle system).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Die` 函数将在指定的时间间隔后由 `Invoke` 执行，以销毁 `gameobject`（如粒子系统）。'
- en: 'Now, drag and drop the `TimedDestroy` script file to the explosion particle
    system in the scene and then press play on the toolbar to test that the code works
    and the object is destroyed after the specified interval, which can be adjusted
    from the **Inspector**. See *Figure 3.30*:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将 `TimedDestroy` 脚本文件拖放到场景中的爆炸粒子系统中，然后在工具栏上按下播放以测试代码是否工作，并且对象在指定的时间间隔后销毁，这个时间间隔可以从
    **Inspector** 中进行调整。参见 *图 3.30*：
- en: '![Code Sample 3.4](img/B05118_03_30.png.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 3.4](img/B05118_03_30.png.jpg)'
- en: 'Figure 3.30: Adding a TimeDestroy script to an explosion Particle System'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.30：将 TimeDestroy 脚本添加到爆炸粒子系统中
- en: 'The `TimeDestroy` script should remove the explosion particle system after
    the delay expires. So let''s create a new and separate prefab from this modified
    version. To do this, rename the explosion system in the **Hierarchy** panel to
    `ExplosionDestroy`, and then drag and drop the system from the **Hierarchy** to
    the **Project** panel in the `Prefabs` folder. Unity automatically creates a new
    prefab, representing the modified particle system. See *Figure 3.31*:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeDestroy` 脚本应在延迟过期后移除爆炸粒子系统。因此，让我们从这个修改版本中创建一个新的独立预制体。为此，在**层次结构**面板中将爆炸系统重命名为
    `ExplosionDestroy`，然后从**层次结构**拖放到 `Prefabs` 文件夹中的**项目**面板。Unity 自动创建一个新的预制体，代表修改后的粒子系统。请参阅
    *图 3.31*：'
- en: '![Code Sample 3.4](img/B05118_03_31.png.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 3.4](img/B05118_03_31.png.jpg)'
- en: 'Figure 3.31: Create a timed explosion prefab'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.31：创建定时爆炸预制体
- en: 'Now, drag and drop the newly created prefab from the **Project** panel to the
    **Death Particle System** slot on the **Health** component for the **Player**
    in the **Object Inspector**. This ensures that the prefab is instantiated when
    the player dies. See *Figure 3.32*:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将新创建的预制体从**项目**面板拖放到**对象检查器**中**玩家**的**健康**组件的**死亡粒子系统**槽位。这确保了当玩家死亡时预制体会被实例化。请参阅
    *图 3.32*：
- en: '![Code Sample 3.4](img/B05118_03_32.png.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 3.4](img/B05118_03_32.png.jpg)'
- en: 'Figure 3.32: Configuring the health script'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.32：配置健康脚本
- en: 'If you run the game now, you''ll see that you cannot initiate a player death
    event to test the particle system generation. Nothing exists in the scene to destroy
    or damage the player, and you cannot manually set the **Health** points to `0`
    from the **Inspector** in a way that is detected by the C# property `set` function.
    For now, however, we can insert some test death functionality into the `Health`
    script that triggers an instant kill when the spacebar is pressed. Refer to *Code
    Sample 3.5* for the modified `Health` script:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，你会看到你不能启动玩家死亡事件来测试粒子系统生成。场景中没有任何东西可以摧毁或伤害玩家，而且你不能从**检查器**中手动将**健康**点数设置为`0`，这种方式会被
    C# 属性的 `set` 函数检测到。然而，目前我们可以将一些测试死亡功能插入到 `Health` 脚本中，当按下空格键时触发立即死亡。请参阅 *代码示例
    3.5* 以获取修改后的 `Health` 脚本：
- en: '[PRE4]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On running the game now, with the modified `Health` script, you can trigger
    an instant player death by pressing the spacebar key on the keyboard. When you
    do this, the player object is destroyed and the particle system is generated until
    the timer destroys that too. Excellent work! We now have a playable, controllable
    player character that supports health and death functionality. Things are looking
    good. See *Figure 3.33*:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行游戏，使用修改后的 `Health` 脚本，你可以通过按下键盘上的空格键来触发玩家的立即死亡。当你这样做时，玩家对象将被销毁，粒子系统也会生成，直到计时器将其销毁。做得好！我们现在有一个可玩、可控制的玩家角色，它支持健康和死亡功能。一切看起来都很顺利。请参阅
    *图 3.33*：
- en: '![Code Sample 3.4](img/B05118_03_33.png.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 3.4](img/B05118_03_33.png.jpg)'
- en: 'Figure 3.33: Trigger the Explosion particle system'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.33：触发爆炸粒子系统
- en: Enemies
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人
- en: 'The next step is to create something for the player to shoot and destroy, which
    can also destroy us, namely, enemy characters. These take the form of roaming
    spaceships that will be spawned into the scene at regular intervals and will follow
    the player, drawing nearer and nearer. Essentially, each enemy represents a complex
    of multiple behaviors working together and these should be implemented as separate
    scripts. Let''s consider them in turn:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为玩家创建可以射击和摧毁的东西，这也可以摧毁我们，即敌人角色。这些以游荡飞船的形式出现，将定期生成到场景中，并跟随玩家，越来越近。本质上，每个敌人代表一个由多个行为共同作用而成的复杂体，这些应该作为单独的脚本实现。让我们逐一考虑它们：
- en: '**Health**: Each enemy supports health functionality. They begin the scene
    with a specified amount of health and will be destroyed when that health falls
    below *0*. We already have a `Health` script created to handle this behavior.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康**：每个敌人支持健康功能。它们在场景开始时具有指定数量的健康值，当健康值降至 *0* 以下时将被销毁。我们已经有了一个 `Health` 脚本来处理这种行为。'
- en: '**Movement**: Each enemy will constantly be in motion, traveling in a straight
    line along a forward trajectory. That is, each enemy will continually travel forward
    in the direction it is looking.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动**：每个敌人将始终处于运动状态，沿着前进轨迹直线行进。也就是说，每个敌人将不断朝向其注视的方向前进。'
- en: '**Turning**: Each enemy will rotate and turn toward the player even when the
    player moves. This ensures that the enemy always faces the player and, in combination
    with the movement functionality, will always be traveling toward the player.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转向**：即使玩家移动，每个敌人也会旋转并转向玩家。这确保了敌人始终面向玩家，并且与移动功能结合，将始终朝向玩家移动。'
- en: '**Scoring**: Each enemy rewards the player with a score value when destroyed.
    Thus, the death of an enemy will increase the player score.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**得分**：每个敌人在被摧毁时都会给玩家奖励一个分数值。因此，敌人的死亡会增加玩家的分数。'
- en: '**Damage**: Each enemy causes damage to the player on collision. Enemies cannot
    shoot but will harm the player on proximity.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**伤害**：每个敌人在碰撞时都会对玩家造成伤害。敌人不能射击，但会在接近时伤害玩家。'
- en: 'Now that we''ve identified the range of behaviors applicable to an enemy, let''s
    create an enemy in the scene. We''ll make one specific enemy, create a prefab
    from that, and use it as the basis to instantiate many enemies. Start by selecting
    the player character in the scene and duplicate the object with *Ctrl* + **D**
    or select **Edit** | **Duplicate** from the application menu. This initially creates
    a second player. See *Figure 3.34*:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了适用于敌人的行为范围，让我们在场景中创建一个敌人。我们将创建一个特定的敌人，从该敌人创建一个预制件，并将其用作实例化许多敌人的基础。首先，在场景中选择玩家角色，并使用
    *Ctrl* + **D** 或从应用程序菜单中选择 **编辑** | **复制** 来复制对象。这最初创建了一个第二个玩家。参见 *图3.34*：
- en: '![Enemies](img/B05118_03_34.png.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![敌人](img/B05118_03_34.png.jpg)'
- en: 'Figure 3.34: Duplicating the Player object'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.34：复制玩家对象
- en: 'Rename the object to `Enemy` and ensure that it is not tagged as `Player`,
    as there should be one and only one object in the scene with the `Player` tag,
    namely, the real player. In addition, temporarily disable the `Player` game object,
    allowing us to focus more clearly on the `Enemy` object in the **Scene** tab.
    See *Figure 3.35*:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象重命名为 `Enemy`，并确保它没有被标记为 `Player`，因为场景中应该只有一个带有 `Player` 标签的对象，即真正的玩家。此外，暂时禁用
    `Player` 游戏对象，以便我们可以在 **场景** 选项卡中更清晰地关注 `Enemy` 对象。参见 *图3.35*：
- en: '![Enemies](img/B05118_03_35.png.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![敌人](img/B05118_03_35.png.jpg)'
- en: 'Figure 3.35: Removing a Player tag from the enemy, if applicable'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.35：如果适用，从敌人中移除玩家标签
- en: 'Select the sprite child object of the duplicated enemy, and from the **Object
    Inspector**, click on the **Sprite** field of the **Sprite Renderer** component
    to pick a new sprite. Pick one of the darker imperial ships for the enemy character,
    and the sprite will update for the object in the viewport. See *Figure 3.36*:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 选择复制的敌人精灵子对象，并在 **对象检查器** 中点击 **Sprite** 字段，选择 **Sprite Renderer** 组件的新精灵。为敌人角色选择一个较暗的帝国飞船精灵，精灵将在视图中更新。参见
    *图3.36*：
- en: '![Enemies](img/B05118_03_36.png.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![敌人](img/B05118_03_36.png.jpg)'
- en: 'Figure 3.36: Selecting a sprite for the Sprite Renderer component'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.36：为精灵渲染器组件选择精灵
- en: 'After changing the sprite to an enemy character, you may need to adjust the
    rotation values to align the sprite to the parent forward vector, ensuring that
    the sprite is looking in the same direction as the forward vector. See *Figure
    3.37*:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在将精灵更改为敌人角色后，您可能需要调整旋转值，以确保精灵与父对象的向前向量对齐，确保精灵朝向与向前向量相同的方向。参见 *图3.37*：
- en: '![Enemies](img/B05118_03_37.png.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![敌人](img/B05118_03_37.png.jpg)'
- en: 'Figure 3.37: Adjusting enemy sprite rotation'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.37：调整敌人精灵的旋转
- en: Now, select the parent object for the enemy and remove the **Rigidbody**, **PlayerController**,
    and `BoundsLock` components, but keep the **Health** component as the enemy should
    support health. See *Figure 3.38*. In addition, feel free to resize the **Capsule
    Collider** component to better approximate the `Enemy` object.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，选择敌人的父对象，并移除 **Rigidbody**、**PlayerController** 和 `BoundsLock` 组件，但保留 **Health**
    组件，因为敌人应该支持生命值。参见 *图3.38*。此外，您可以随意调整 **Capsule Collider** 组件的大小，以更好地逼近 `Enemy`
    对象。
- en: '![Enemies](img/B05118_03_38.png.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![敌人](img/B05118_03_38.png.jpg)'
- en: 'Figure 3.38: Adjusting enemy sprite rotation'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.38：调整敌人精灵的旋转
- en: Let's start coding the enemy, focusing on movement. Specifically, the enemy
    should continually move in the forward direction at a specified speed. To achieve
    this, create a new script file named `Mover.cs`. This should be attached to the
    `Enemy` object. The code for this class is included in *Code Sample 3.6*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写敌人代码开始，重点关注移动。具体来说，敌人应该以指定的速度持续向前移动。为了实现这一点，创建一个名为 `Mover.cs` 的新脚本文件。这个文件应该附加到
    `Enemy` 对象上。该类的代码包含在 *代码示例3.6* 中。
- en: '[PRE5]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Code Sample 3.6
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例3.6
- en: 'The following points summarize the code sample:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: The `Mover` script moves an object at a specified speed (`MaxSpeed` per second)
    along its forward vector. To do this, it uses the **Transform** component.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mover` 脚本以指定的速度（每秒 `MaxSpeed`）沿着其前进向量移动一个对象。为此，它使用 **Transform** 组件。'
- en: The `Update` function is responsible for updating the position of the object.
    In short, it multiplies the forward vector by the object speed and adds this to
    its existing position to move the object further along its line of sight. The
    `Time.deltaTime` value is used to make the motion frame rate independent—moving
    the object per second as opposed to per frame. More information on `deltaTime`
    can be found in the online Unity documentation at [http://docs.unity3d.com/ScriptReference/Time-deltaTime.html](http://docs.unity3d.com/ScriptReference/Time-deltaTime.html).
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update` 函数负责更新对象的位置。简而言之，它将前进向量乘以对象速度，并将其加到现有位置上，以使对象沿着其视线移动得更远。`Time.deltaTime`
    值用于使运动帧率独立——每秒移动对象而不是每帧移动。有关 `deltaTime` 的更多信息，请参阅在线 Unity 文档，网址为 [http://docs.unity3d.com/ScriptReference/Time-deltaTime.html](http://docs.unity3d.com/ScriptReference/Time-deltaTime.html)。'
- en: 'Press play on the toolbar to test run your code. It''s always good practice
    to frequently test code like this. Your enemy may move too slow or too fast. If
    so, stop playback to exit game mode, and select the enemy in the scene. From the
    **Object Inspector**, adjust the **Max Speed** value of the **Mover** component.
    See *Figure 3.39*:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在工具栏上按播放按钮以测试运行您的代码。频繁测试此类代码总是好的实践。您的敌人可能移动得太慢或太快。如果是这样，停止播放以退出游戏模式，并在场景中选择敌人。从
    **对象检查器** 中调整 **Mover** 组件的 **最大速度** 值。参见 *图 3.39*：
- en: '![Code Sample 3.6](img/B05118_03_39.png.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 3.6](img/B05118_03_39.png.jpg)'
- en: 'Figure 3.39: Adjusting enemy speed'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.39：调整敌人速度
- en: 'In addition to moving in a straight line, the enemy should also continually
    turn to face the player wherever they move. To achieve this, we''ll need another
    script file that works similarly to the player controller script. While the player
    turns to face the cursor, the enemy turns to face the player. This functionality
    should be encoded in a new script file called `ObjFace.cs`. This script should
    be attached to the enemy. See *Code Sample 3.7*:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除了直线移动外，敌人还应不断转向以面对玩家，无论他们移动到哪里。为了实现这一点，我们需要另一个与玩家控制器脚本类似工作的脚本文件。当玩家转向面对光标时，敌人转向面对玩家。这种功能应编码在一个名为
    `ObjFace.cs` 的新脚本文件中。此脚本应附加到敌人上。参见 *代码示例 3.7*：
- en: '[PRE6]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Code Sample 3.7
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例 3.7
- en: 'The following points summarize the code sample:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: The `ObjFace` script will always rotate an object so that its forward vector
    points towards a destination point in the scene.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObjFace` 脚本将始终旋转对象，使其前进向量指向场景中的目标点。'
- en: In the `Awake` event, the `FindGameObjectWithTag` function is called to retrieve
    a reference to the one and only object in the scene tagged as a player, which
    should be the player spaceship. The player represents the default look-at destination
    for an enemy object.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Awake` 事件中，调用 `FindGameObjectWithTag` 函数以获取场景中标记为玩家的唯一对象的引用，这应该是玩家飞船。玩家代表敌人对象的默认注视目标。
- en: The `Update` function is called automatically once per frame and will generate
    a displacement vector from the object location to the destination location, and
    this represents the direction in which the object should be looking. The `Quaternion.LookRotation`
    function accepts a direction vector and will rotate an object to align the forward
    vector with the supplied direction. This keeps the object looking towards the
    destination. More information on `LookRotation` can be found at the online Unity
    documentation at [http://docs.unity3d.com/ScriptReference/Quaternion.LookRotation.html](http://docs.unity3d.com/ScriptReference/Quaternion.LookRotation.html).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update` 函数每帧自动调用一次，并从对象位置到目标位置生成一个位移向量，这代表了对象应该朝向的方向。`Quaternion.LookRotation`
    函数接受一个方向向量，并将对象旋转以使前进向量与提供的方向对齐。这使对象始终朝向目标。有关 `LookRotation` 的更多信息，请参阅在线 Unity
    文档，网址为 [http://docs.unity3d.com/ScriptReference/Quaternion.LookRotation.html](http://docs.unity3d.com/ScriptReference/Quaternion.LookRotation.html)。'
- en: 'This is looking excellent! However, before testing this code, make sure that
    the `Player` object in the scene is tagged as **Player**, is enabled, and the
    enemy is offset away from the player. Be sure to enable the **Follow Player**
    checkbox from the **Obj Face** component in the **Object Inspector**. When you
    do this, the enemy will always turn to face the player. See *Figure 3.40*:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来非常好！然而，在测试此代码之前，请确保场景中的`Player`对象被标记为**Player**，处于启用状态，并且敌方角色与玩家偏移。务必从**对象检查器**中的**Obj
    Face**组件启用**跟随玩家**复选框。当你这样做时，敌方角色将始终转向面对玩家。参见*图 3.40*：
- en: '![Code Sample 3.7](img/B05118_03_40.png.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 3.7](img/B05118_03_40.png.jpg)'
- en: 'Figure 3.40: Enemy spaceship moving towards the player'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.40：敌方飞船向玩家移动
- en: 'Now, if and when the enemy finally collides with the player, it should deal
    out damage and potentially kill the player. To achieve this, a collision between
    the enemy and player must be detected. Let''s start by configuring the enemy.
    Select the **Enemy** object, and from the **Object Inspector**, enable the **Is
    Trigger** checkbox in the **Capsule Collider** component. This changes the **Capsule
    Collider** component to allow a true intersection between the player and enemy
    and prevent Unity from blocking the collision. See *Figure 3.41*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果敌方角色最终与玩家发生碰撞，它应该造成伤害并可能杀死玩家。为了实现这一点，必须检测敌方角色和玩家之间的碰撞。让我们先配置敌方角色。选择**敌方**对象，并在**对象检查器**中，在**胶囊碰撞器**组件中启用**是触发器**复选框。这会将**胶囊碰撞器**组件更改为允许玩家和敌方角色之间进行真实交叠，并防止
    Unity 阻止碰撞。参见*图 3.41*：
- en: '![Code Sample 3.7](img/B05118_03_41.png.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 3.7](img/B05118_03_41.png.jpg)'
- en: 'Figure 3.41: Changing the Enemy Collider to a trigger'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.41：将敌方碰撞器更改为触发器
- en: 'Next, we''ll create a script that detects collisions and will continually deal
    out damage to the player as and when they occur and for as long as the collision
    state remains. Refer to the following code (`ProxyDamage.cs`), which should be
    attached to the enemy character:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个脚本，用于检测碰撞，并在发生碰撞时以及碰撞状态持续期间不断对玩家造成伤害。请参考以下代码（`ProxyDamage.cs`），该代码应附加到敌方角色上：
- en: '[PRE7]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Code Sample 3.8
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例 3.8
- en: 'The following points summarize the code sample:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: The `ProxyDamage` script should be attached to an enemy character and it will
    deal out damage to any colliding object with a `Health` component.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProxyDamage`脚本应附加到敌方角色上，并将对任何具有`Health`组件的碰撞对象造成伤害。'
- en: The `OnTriggerStay` event is called once every frame for as long as an intersection
    state persists. During this function, the `HealthPoints` value of the `Health`
    component is reduced by the `DamageRate` (which is measured as damage per second).
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnTriggerStay`事件在交叠状态持续期间每帧被调用一次。在此函数中，`Health`组件的`HealthPoints`值会减少`DamageRate`（以每秒伤害量衡量）。'
- en: 'After attaching the `ProxyDamage` script to an enemy, use the **Object Inspector**
    to set the **Damage Rate** of the **Proxy Damage** component. This represents
    how much health should be reduced on the player, per second, during a collision.
    For a challenge, I''ve set the value to `100` health points. See *Figure 3.42*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`ProxyDamage`脚本附加到敌方角色后，使用**对象检查器**设置**代理伤害**组件的**损伤率**。这表示在碰撞期间，每秒应该减少玩家多少健康值。为了增加挑战性，我将值设置为`100`健康点。参见*图
    3.42*：
- en: '![Code Sample 3.8](img/B05118_03_42.png.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 3.8](img/B05118_03_42.png.jpg)'
- en: 'Figure 3.42: Setting the Damage Rate for a Proxy Damage component'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.42：设置代理伤害组件的损伤率
- en: Now let's give things a test run. Press play on the toolbar and attempt a collision
    between the player and enemy. After one second, the player should be destroyed.
    Things are coming along well. However, we'll need more than one enemy to make
    things challenging.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来测试一下。在工具栏上按播放，尝试玩家和敌方角色的碰撞。一秒后，玩家应该被摧毁。一切进展顺利。然而，为了使游戏更具挑战性，我们需要不止一个敌方角色。
- en: Enemy spawning
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌方生成
- en: 'To make the level fun and challenging, we''ll need more than simply one enemy.
    In fact, for a game that''s essentially endless, we''ll need to continually add
    enemies. These should be added gradually over time. Essentially, we''ll need either
    regular or intermittent spawning of enemies, and this section will add that functionality.
    Before we can do this, however, we''ll need to make a prefab from the enemy object.
    This can be achieved easily. Select the enemy in the **Hierarchy** panel and then
    drag and drop it to the **Project** panel in the `Prefabs` folder. This creates
    an `Enemy` prefab. See *Figure 3.43*:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使游戏级别既有趣又具有挑战性，我们需要的不仅仅是单个敌人。实际上，对于一个本质上无限的游戏，我们需要不断地添加敌人。这些敌人应该随着时间的推移逐渐添加。本质上，我们需要敌人的定期或间歇性生成，本节将添加这一功能。然而，在我们能够做到这一点之前，我们需要从敌人对象制作一个预制件。这可以轻松实现。在**层次**面板中选择敌人，然后将其拖放到`Prefabs`文件夹中的**项目**面板。这样就创建了一个`Enemy`预制件。参见*图3.43*：
- en: '![Enemy spawning](img/B05118_03_43.png.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![敌人生成](img/B05118_03_43.png.jpg)'
- en: 'Figure 3.43: Creating an Enemy prefab'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.43*：创建敌人预制件'
- en: 'Now, we''ll make a new script (`Spawner.cs`) that spawns new enemies in the
    scene over time within a specified radius from the player spaceship. This script
    should be attached to a new, empty game object in the scene. See *Code Sample
    3.9*:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个新的脚本（`Spawner.cs`），该脚本将在玩家飞船指定半径内随时间生成新的敌人。这个脚本应该附加到场景中的一个新空游戏对象上。参见*代码示例3.9*：
- en: '[PRE8]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Code Sample 3.9
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例3.9
- en: 'The following points summarize the code sample:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: The `Spawner` class will spawn instances of `ObjToSpawn` (a prefab) on each
    interval of `Interval`. The interval is measured in seconds. The spawned objects
    will be created within a random radius from a center point, `Origin`.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Spawner`类将在每个间隔内生成`ObjToSpawn`（一个预制件）的实例。间隔以秒为单位测量。生成的对象将在以中心点`Origin`为起点的随机半径内创建。'
- en: During the `Start` event, the `InvokeRepeating` function is called to continually
    execute the `Spawn` function on every interval to spawn a new enemy.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Start`事件期间，`InvokeRepeating`函数被调用，以在每个间隔内持续执行`Spawn`函数来生成新的敌人。
- en: The `Spawn` function will create instances of the enemy in the scene at a random
    radius from an origin point. Once spawned, the enemy will behave as normal, heading
    toward the player for an attack.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Spawn`函数将在场景中创建敌人的实例，这些实例从起点以随机半径生成。一旦生成，敌人将像正常一样行动，朝向玩家进行攻击。'
- en: 'The `Spawner` class is a global behavior that applies scene-wide. It does not
    depend on the player specifically, nor on any specific enemy. For this reason,
    it should be attached to an empty game object. Create one of these by selecting
    **GameObject** | **Create Empty** from the application menu. Name this `Spawner`
    and attach the `Spawner` script to it. See *Figure 3.44*:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spawner`类是一个全局行为，适用于整个场景。它不依赖于特定的玩家，也不依赖于任何特定的敌人。因此，它应该附加到一个空的游戏对象上。通过从应用程序菜单中选择**GameObject**
    | **Create Empty**来创建一个这样的对象。将其命名为`Spawner`，并将`Spawner`脚本附加到它上。参见*图3.44*：'
- en: '![Code Sample 3.9](img/B05118_03_44.png.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例3.9](img/B05118_03_44.png.jpg)'
- en: 'Figure 3.44: Creating an empty game object'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.44*：创建空游戏对象'
- en: 'Once added to the scene, from the **Object Inspector**, drag and drop the `Enemy`
    prefab to the **Obj To Spawn** field in the **Spawner** component. Set the **Interval**
    to `2` seconds and increase the **Max Radius** to `5`. See *Figure 3.45*:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 将其添加到场景后，从**对象检查器**中，将`Enemy`预制件拖放到**Spawner**组件中的**Obj To Spawn**字段。将**间隔**设置为`2`秒，并将**最大半径**增加到`5`。参见*图3.45*：
- en: '![Code Sample 3.9](img/B05118_03_45.png.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例3.9](img/B05118_03_45.png.jpg)'
- en: 'Figure 3.45: Configuring the Spawner for Enemy objects'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.45*：为敌人对象配置Spawner'
- en: 'Now (drum roll), let''s try the level. Press play on the toolbar and take the
    game for a test run. You should now have a level with a fully controllable player
    character surrounded by a growing army of tracking enemy ships! Excellent work!
    See *Figure 3.46*:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在（掌声），让我们尝试这个级别。在工具栏上按播放，进行游戏测试运行。你现在应该有一个带有完全可控制玩家角色的级别，周围是不断增长的追踪敌人飞船的军队！干得好！参见*图3.46*：
- en: '![Code Sample 3.9](img/B05118_03_46.png.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例3.9](img/B05118_03_46.png.jpg)'
- en: 'Figure 3.46: Spawned enemy objects moving toward the player'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.46*：生成的敌人对象向玩家移动'
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Good job on getting this far! The space shooter is really taking shape now,
    featuring a controllable player character that relies on native physics, twin-stick
    mechanics, enemy ships, and a scene-wide spawner for enemies. All these ingredients
    together still don''t make a game: we can''t shoot, we can''t increase the score,
    and we can''t destroy enemies. These issues will need to be addressed, along with
    other technical issues that we''ll certainly encounter. Nevertheless, we now have
    a solid foundation for moving further, and in the next chapter, we''ll complete
    the shooter.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 做得很好，已经走到这一步了！太空射击游戏现在真的有形了，它拥有一个可控的玩家角色，该角色依赖于原生物理，双摇杆机制，敌舰，以及用于生成敌人的场景级生成器。所有这些元素加在一起仍然不能构成一个游戏：我们无法射击，无法增加分数，也无法摧毁敌人。这些问题需要解决，还有我们肯定会遇到的其他技术问题。尽管如此，我们现在有一个坚实的基础来继续前进，在下一章中，我们将完成射击游戏。
