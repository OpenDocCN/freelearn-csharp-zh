<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Developing with Xamarin</h1></div></div></div><p>This chapter examines the<a class="indexterm" id="id0"/> Xamarin framework and architecture on different target platforms and identifies the differences and similarities. It also includes introductory information and tips on preparing the development environment for Xamarin and covers some of the Xamarin development essentials. This chapter is divided into the following sections:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cross-platform projects with Xamarin</li><li class="listitem" style="list-style-type: disc">Target platforms</li><li class="listitem" style="list-style-type: disc">Setting up the development environment</li><li class="listitem" style="list-style-type: disc">Emulator options</li><li class="listitem" style="list-style-type: disc">A typical Xamarin solution structure</li><li class="listitem" style="list-style-type: disc">Quality in cross-development</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Cross-platform projects with Xamarin</h1></div></div></div><p>Developers are <a class="indexterm" id="id1"/>enjoying a new era in which development is not restricted to one single application platform but spans across various media such as cellphones, tablets, personal computers, and even wearable devices. The <a class="indexterm" id="id2"/>shared code and assets between the development projects improves the elegance and the quality of the work. There is also a direct correlation between the robustness, the effort required for maintaining a multi-platform application, and the reusable modules.</p><p>Universal application is a term previously used to identify applications targeting devices running on the iOS operating system (the iPhone and iPad). However, the same term is now used to describe Windows Runtime applications (Windows Store and Windows Phone 8.1 - WinRT) and Android applications for phones and tablets. With the release of Xamarin, a truly universal application concept was born. When considering Xamarin applications, the term, universal, refers to applications that run on all three platforms and adapt to the system resources.</p><p>In this universal application context, developers are now finding it difficult to get the necessary solutions for common tasks on all three platforms. Moreover, taking on each platform as a separate development project results in wasted developer hours even though the main driving factors for such an application, namely data, business logic, and UI, are conceptually almost identical on all platforms.</p><p>Development <a class="indexterm" id="id3"/>strategies and patterns for the Xamarin platform, some of which are described in the rest of this book, try to resolve some of these problems and provide the developers with the tools and strategies necessary to produce cross-platform, manageable, and quality products.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Xamarin as a platform</h2></div></div></div><p>Xamarin <a class="indexterm" id="id4"/>was initially born as a community effort to port the .NET libraries and common language runtime compilers to different operating systems. Initial attempts intended to create a set of binaries to develop, compile, and run applications written in C#, the indigenous language of .NET, on Unix-based platforms. This project, Mono, was later ported to many other operating systems, including iOS (Mono-Touch) and Android (Mono for Android).</p><p>The emergence of the Xamarin development platform created a new development niche creating products for three separate platforms at the same time, while allowing users to adapt their existing .NET development skills to these new platforms and produce applications for a wider range of devices and operating systems.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>Microsoft has been a strong supporter of Xamarin platform and toolset since the early phases. As you will see in the remainder of the chapter, Xamarin tools were fully integrated into Visual Studio and finally included in the Visual Studio 2015 setup. This partnership lasted until the eventual acquisition of Xamarin by Microsoft which was publicly announced in March 2016.</p></div></div><p>Xamarin provides compilers for each of the mentioned platforms so that the code written in the .NET framework (-alike) is compiled into native applications. This process provides highly efficient applications that differ greatly from interpreted mobile HTML applications.</p><p>As well as native compilation, Xamarin also provides access to strongly typed platform-specific features. These features are used in a robust manner with compile-time binding to the underlying platform. Platform-specific execution can also be extended with native invocations which is possible with the interop libraries.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Xamarin as a product</h2></div></div></div><p>Xamarin, as a<a class="indexterm" id="id5"/> development suite, comes in different flavors. Developers with different sets of knowledge and experience can use these tools to set up their development environment according to their own needs. The Xamarin development environment can be configured on different operating systems. However, it is currently not possible to develop for all three platforms on the same operating system.</p><p>For developers who are looking to use the familiar interface of Visual Studio and leverage existing skills, Xamarin extensions for Visual Studio offer a suitable option. Once the extensions are installed, the environment is ready to develop Android and Windows Phone <a class="indexterm" id="id6"/>applications. This extension lets the developers take full advantage of Visual Studio, which includes designers for both of these platforms. In order to develop iOS applications, you need to go through the so-called pairing process of Visual Studio with an Apple OS X build machine. The build machine is used in return to visualize storyboards in the development environment (Visual Studio), compile iOS code, and debug applications.</p><p>The second option is to use Xamarin Studio. Xamarin Studio is a complete IDE with some of the features you are familiar with from Visual Studio, such as intellisense (smart code completion), code analysis, and code formatting. If you run Xamarin Studio on Apple OS X, you can develop for Android and iOS platforms with this IDE. However, with Xamarin Studio on Windows, you can only target the Android platform.</p><p>An important part of this development suite is the real-time monitoring tool called Xamarin Insights. Xamarin Insights lets developers monitor their live applications to help detect and diagnose performance issues and exceptions, and discover how the application is used. Xamarin Insights can also be connected to other applications so, for instance, application errors can be directly pushed into a bug tracking system.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Target platforms</h1></div></div></div><p>As <a class="indexterm" id="id7"/>mentioned, Xamarin created a new platform in which the development efforts target multiple operating systems and a variety of devices. Most importantly, compiled applications do not run an interpreted sequence but have a native code base (such as Xamarin.iOS) or an integrated .NET application runtime (such as Xamarin.Android). In essence, Xamarin replaces the Common Language Runtime and IL for .NET applications with compiled binaries and an execution context, the so-called <a class="indexterm" id="id8"/>
<strong>mono runtime</strong>.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Xamarin on Android</h2></div></div></div><p>With <a class="indexterm" id="id9"/>Android applications, mono runtime is placed right on top of the Linux kernel. This creates a parallel execution context to the Android runtime. Xamarin code is then compiled into IL and accessed by mono runtime. On the other hand, Android runtime is accessed by the so-called <a class="indexterm" id="id10"/>
<strong>Managed Callable Wrappers</strong> (<strong>MCW</strong>) which is a marshalling wrapper between the two runtimes. The MCW layer is responsible for converting managed types to Android runtime types and invoking Android code at execution time. Every time that .NET code needs to invoke Java code, this JNI (Java Interop) bridge is used. MCW provides a wide range of applications including inheriting Java types, overriding methods and implementing Java interfaces.</p><p>The following<a class="indexterm" id="id11"/> image shows the Xamarin.Android architecture:</p><div><img alt="Xamarin on Android" src="img/B04693_01_01.jpg"/><div><p>Figure 1: Xamarin.Android Architecture</p></div></div><p><code class="literal">Android.*</code> and <code class="literal">Java.*</code> namespaces are used throughout the MCWs to access device- and platform-specific features in Android runtime and Java APIs such as facilities like audio, graphics, OpenGL, and telephony .</p><p>Using the interop libraries, it is also possible to load native libraries and execute native code in the execution context with Xamarin.Android. The reverse callback execution in this case is handled through <a class="indexterm" id="id12"/>
<strong>Android Callable Wrappers</strong> (<strong>ACW</strong>). ACW is a JNI bridge which allows the Android runtime to access the .NET domain. An ACW is generated at compile-time for each managed class that is directly or indirectly related to Java types (those that inherit <code class="literal">Java.Lang.Object</code>).</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Xamarin on iOS</h2></div></div></div><p>In iOS <a class="indexterm" id="id13"/>applications, the use of an integrated parallel runtime is (unfortunately) not permissible under the iOS SDK agreement. According to the iOS SDK agreement, interpreted code can only be used if all of the the scripts and code are downloaded and run by Apple's WebKit framework.</p><p>With this restriction in place, developers can still develop applications in .NET and share code over the other three platforms. At compile time, projects are first compiled into IL code and then (with the Mono Touch Ahead-Of-Time compiler—mtouch) into static native iOS bits. This <a class="indexterm" id="id14"/>means that iOS applications developed with Xamarin are completely native applications.</p><div><img alt="Xamarin on iOS" src="img/B04693_01_02.jpg"/><div><p>Figure 2: Xamarin.iOS Compilation</p></div></div><p>Xamarin.iOS, like Xamarin.Android, contains an interop engine that bridges the .NET world with the Objective-C world. Through this bridge, under the <code class="literal">ObjCRuntime</code> namespace, users are able to access iOS C-based APIs, as well as using the Foundation namespace, and can use and derive from native types and access Objective-C properties. For instance, Objective-C types like <code class="literal">NSObject</code>, <code class="literal">NSString</code>, and <code class="literal">NSArray</code> are exposed in C# and provide binding to underlying types. These types can be used either as memory references or as strongly-typed objects. This improves the development experience and also increases type-safety.</p><p>This static compilation is the main reason for using a build machine to develop iOS applications with Xamarin on the Windows platform. Therefore, there is no reverse-callback functionality in Xamarin.iOS where calls to native runtime from .NET code are supported but calls from native code back to .NET domain are not. There are other features that are disabled because of the way that Xamarin.iOS applications are compiled. For example, no generic types are allowed to inherit from <code class="literal">NSObject</code>. Another important limitation is the fact that no dynamic type creation is allowed at runtime which, in return, disables the use of dynamic keywords in Xamarin.iOS applications.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>Xamarin.iOS application packages, if built in a debug configuration, are much larger than their Release counterparts when compared to other platforms. These packages are instrumented and not optimized by the linker. Profiling of these packages is not allowed in Xamarin.iOS applications.</p></div></div><p>In a similar <a class="indexterm" id="id15"/>way to Xamarin.Android development, with Xamarin.iOS, it is also possible to re-use native code and libraries from managed code. To do this, Xamarin provides a project template called a <a class="indexterm" id="id16"/>
<strong>binding library</strong>. A binding library helps developers create managed wrappers for native Objective-C code.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Windows Runtime apps</h2></div></div></div><p>Even though <a class="indexterm" id="id17"/>Xamarin does not include Windows Runtime as a target platform nor provide specialized tools for it (other than Xamarin.Forms), cross-platform projects that involve Xamarin can and generally do include Windows Runtime projects. Since .NET and C# are indigenous to Windows Runtime, most of the shared projects (such as portable libraries, shared projects, and Xamarin.Forms projects) can be reused in Windows Runtime with no further modification.</p><p>With Windows Runtime, developers can create both Windows Phone 8.1 and Windows Store applications. Windows Phone 8 and Windows Phone 8.1 Silverlight can also be targeted and included in the PCL description.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Setting up the development environment</h1></div></div></div><p>Xamarin projects <a class="indexterm" id="id18"/>can be carried out in various development environments. Since a number of platforms are involved in such projects, the operating system, the IDE selection, and the configuration are all crucial parts of the preparation.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>Environment setup not only depends on the target application platforms but also on the Xamarin license. A comparison between different licensing options and pricing information can be found on the Xamarin website (<a class="ulink" href="https://store.xamarin.com/">https://store.xamarin.com/</a>).</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Choosing the right development OS</h2></div></div></div><p>Android applications <a class="indexterm" id="id19"/>can be developed and compiled on Windows using both Xamarin Studio and Visual Studio with Xamarin extensions installed, as well as on an Apple OS X operating system with Xamarin Studio for Mac installed.</p><p>For iOS application development, whether using Visual Studio on Windows or Xamarin Studio on Apple OS X, an Apple Macintosh computer, running at least OS X Mountain Lion, is required. The build machine should have the Xcode development tools with iOS SDK together with the Xamarin.iOS suite installed.</p><p>On the other hand, Windows Store applications can only be developed on the Windows platform.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom">
<p>Apple OS X</p>
</th><th colspan="2" style="text-align: center" valign="bottom">
<p>Microsoft Windows</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p><strong>Xamarin Studio</strong></p>
</td><td style="text-align: left" valign="top">
<p><strong>Xamarin Studio</strong></p>
</td><td style="text-align: left" valign="top">
<p><strong>Visual Studio</strong></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><strong>iOS Apps</strong></p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>Yes (with OS X Build Machine)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><strong>Android Apps</strong></p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><strong>Windows Store Apps</strong></p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>Yes</p>
</td></tr></tbody></table></div><div><blockquote class="blockquote"><p><em>Figure 3: Development IDEs on OS X and Windows</em></p></blockquote></div><p>On the virtualization front, developers are also limited. OS X cannot be installed and run on a non-Apple branded machine nor can it be virtualized, according to the end user agreement. On the other hand, you can set up a virtual machine on an OS X development machine for Microsoft Windows and Visual Studio. However, in this case, the system should be running nested virtualization for Hyper-V to run Visual Studio for Windows Phone and Android emulators. Even though Parallels and VMWare Fusion support nested virtualization, Microsoft doesn't support nesting Hyper-V and, therefore, such machines may be unstable.</p><div><div><div><div><h3 class="title"><a id="ch01lvl2sec12"/>Xamarin Studio setup and configuration</h3></div></div></div><p>Xamarin Studio <a class="indexterm" id="id20"/>can be set up on both the Windows and OS X operating systems. Developers can download it from <a class="ulink" href="http://www.xamarin.com">www.xamarin.com</a> and follow the installation instructions. Xamarin components for target platforms (for example, Xamarin.iOS, Xamarin.Android, and so on) together with the dependencies for these platforms (for example, Android SDK) should be downloaded and installed on the development machine. One required component for OS X, which has to be installed separately and configured, is the iOS SDK with the Xcode development environment.</p><div><img alt="Xamarin Studio setup and configuration" src="img/B04693_01_03.jpg"/><div><p>Figure 4: Xamarin Setup on Mavericks (OS X 10.9)</p></div></div><p>On Microsoft <a class="indexterm" id="id21"/>Windows, it is important to mention that Xamarin Studio only supports the development of Android applications. Neither Windows Phone nor iOS application (even with the remote build machine) projects can be viewed, modified, or compiled with Xamarin Studio on Windows.</p><div><img alt="Xamarin Studio setup and configuration" src="img/B04693_01_04.jpg"/><div><p>Figure 5: Xamarin Dev. Environment Setup on OS X</p></div></div><p>While<a class="indexterm" id="id22"/> developing on OS X, the only option for developing Windows Phone applications together with iOS and Android, is to use a Windows virtual machine and run Visual Studio in parallel with Xamarin Studio. This setup is also helpful for developers who use Team Foundation Server as the source control, since they can use the enhanced integration offered by Visual Studio Client rather than the standalone TFS Everywhere. It can also be set up so that the OS host machine can be paired with Visual Studio to become the build host for iOS applications.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl2sec13"/>Visual Studio setup and configuration</h3></div></div></div><p>A typical <a class="indexterm" id="id23"/>Windows development platform configuration for Xamarin projects includes Visual Studio 2013 or 2015, an Apple OS X build host and Hyper-V and/or VirtualBox to be able to use Android and Windows Phone emulators. Xamarin.iOS applications are then compiled and emulated on the Apple OS X build host.</p><div><img alt="Visual Studio setup and configuration" src="img/B04693_01_05.jpg"/><div><p>Figure 6: Windows Platform Xamarin Development Environment</p></div></div><div><div><h3 class="title"><a id="note05"/>Note</h3><p>In spite of the fact that it is technically possible to run OS X with a virtual machine in the Microsoft Windows environment, Apple's license agreement does not allow this:</p><p><em>"2.H. Other Use Restrictions: The grants set forth in this License do not permit you to, and you agree not to, install, use or run the Apple Software on any non-Apple-branded computer, or to enable others to do so."</em></p></div></div><p>On Microsoft <a class="indexterm" id="id24"/>Windows, the Xamarin installation is similar to the Xamarin Studio setup on Apple OS X. All of the prerequisites for Xamarin development are installed with the Xamarin for Windows package, together with the Visual Studio extension.</p><div><img alt="Visual Studio setup and configuration" src="img/B04693_01_06.jpg"/><div><p>Figure 7: Visual Studio 2015 Setup</p></div></div><p>One of the key differences between OS X and Microsoft Windows is that Visual Studio 2015 now includes cross-platform development tools such as Android SDK, development kits, and Xamarin project templates. Therefore, the Xamarin installation is only responsible for installing the extensions for the requested platforms (that is, Xamarin.iOS and/or Xamarin.Android).</p><p>In order to develop and test iOS applications and visualize and edit storyboards with Visual Studio, an Apple OS X machine must be connected to Visual Studio as a build host. Xamarin 4.0 introduced the concept of Xamarin Mac Agent, which is a background process on the <a class="indexterm" id="id25"/>OS X machine providing the required SSH connection to Visual Studio (a secure connection over port 22). Prior to Xamarin 4.0, the build host machine needed to run the so-called Mac <strong>build host</strong> which<a class="indexterm" id="id26"/> was used to pair the Mac host with Visual Studio. The only prerequisites for Xamarin Mac Agent are to have Xamarin.iOS installed on both the Windows workstation and the OS X build host and the build host to have a remote login enabled for the current user. In Visual Studio, the <strong>Find Xamarin Mac Agent</strong> dialog helps establish the remote connection.</p><div><img alt="Visual Studio setup and configuration" src="img/b04693_01_07.jpg"/><div><p>Figure 8: Xamarin.iOS Build Host</p></div></div><p>It is important to keep in mind that the Mac machine paired with Visual Studio has to have Xcode with iOS SDK installed. A developer account (either enrolled into the app developer program or not) must also be added to the accounts configuration section of Xcode.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>If the account associated with Xcode does not have a paid subscription to the developer program, the platform for the iOS projects can only be set for simulator and debug selection to one of the simulator options, not an actual device. Otherwise, the user will be presented with an error message such as, <strong>No valid iOS code signing keys found in keychain</strong>.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Emulator options</h1></div></div></div><p>There are a<a class="indexterm" id="id27"/> number of emulators for compiled Xamarin projects for the target platform and the development environment. Developers have most flexibility with the emulator for the Android platform, whereas the options for iOS and Windows Store Apps are limited to the SDK-provided emulators.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Emulators for Android</h2></div></div></div><p>Android <a class="indexterm" id="id28"/>applications can be run and tested on a number of emulators on both Microsoft Windows and Apple OS X operating systems.</p><p>Android SDK comes with the default emulator that is installed on the development machine. This emulation option is available both on OS X and Windows operating systems.</p><div><img alt="Emulators for Android" src="img/B04693_01_09.jpg"/><div><p>Figure 9: AVD and Genymotion Emulators</p></div></div><p>This Android emulator uses the <a class="indexterm" id="id29"/>
<strong>Android Virtual Devices</strong> (<strong>AVD</strong>) to emulate the Linux kernel and the Android runtime. It does not require any additional virtualization software to run, however, the lack of virtualization support makes AVD much less responsive and makes the startup time relatively longer. It also provides a wide range of emulation options for developers, from SMS and telephony to hardware, peripherals, and power events.</p><p>The <a class="indexterm" id="id30"/>Genymotion emulator (<a class="ulink" href="https://www.genymotion.com/">https://www.genymotion.com/</a>) is one of the most popular emulation options for Xamarin and Android developers. Although it is available with a free license, the free version only allows for GPS and camera emulation. The Genymotion emulator runs on (and is installed with) VirtualBox virtualization software.</p><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p><strong>VirtualBox together with Hyper-V</strong></p><p>Virtual Box software cannot be run alongside Hyper-V virtualization software, which is required for Windows Phone development and emulation on Windows operating systems. In order to use both the Windows Phone emulator and the Genymotion Android emulator, you can create a dual boot option to disable and enable Hyper-V on Windows start-up.</p><div><pre class="programlisting">
<strong>bcdedit /copy {current} /d "No Hyper-V"</strong>
<strong>bcdedit /set {&lt;identifier from previous command&gt;} hypervisorlaunchtype off</strong>
</pre></div><p>This would create a second boot option to start Windows without the Hyper-V feature so that the virtualization can be used by VirtualBox.</p></div></div><p>The last and the most recent Android emulation option is the Visual Studio Android emulator. This Android emulator runs on Hyper-V and provides various device API versions and emulation options for developers.</p><div><img alt="Emulators for Android" src="img/B04693_01_10.jpg"/><div><p>Figure 10: Visual Studio Android Emulator</p></div></div><p>The <a class="indexterm" id="id31"/>Visual Studio Android emulator is installed as part of the Visual Studio 2015 installation and can also be installed as an extension later. The emulator provides a similar experience to the Windows Phone emulator and allows developers and testers to use almost the same set of emulation options with different device profiles as well as different API levels.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>iOS emulation</h2></div></div></div><p>iOS emulation<a class="indexterm" id="id32"/> is only possible with the Xcode tools and iOS SDK. The iOS simulator can be started either directly on Apple OS X while developing with Xamarin Studio, or by pairing the build machine with the Visual Studio Xamarin extension running on Microsoft Windows. It also can be used to test both iPhone and iPad applications.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>A typical Xamarin solution structure</h1></div></div></div><p>A <a class="indexterm" id="id33"/>Xamarin solution can be composed of different types of projects. Some of these projects are platform-specific projects and the others are shared project types or modules that make it possible to reuse code across platforms.</p><div><img alt="A typical Xamarin solution structure" src="img/B04693_01_11.jpg"/><div><p>Figure 11: Xamarin project solution structure on Visual Studio and Xamarin Studio</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Portable class libraries</h2></div></div></div><p>Portable class libraries <a class="indexterm" id="id34"/>are the most common way of sharing code between cross-platform projects. PCLs provide a set of common reference assemblies that enable .NET libraries and binaries to be used on any .NET-based runtime or with Xamarin compilers—from phones to clients, to servers and clouds. PCL modules are designed to use only a specific subset of the .NET framework and can be set to target different platforms.</p><div><img alt="Portable class libraries" src="img/B04693_01_12.jpg"/><div><p>Figure 12: Portable Class Library Targets</p></div></div><p>Microsoft has <a class="indexterm" id="id35"/>a designation for each target combination and each profile also gets a NuGet target. A subset of .NET libraries for portable class libraries were released through NuGet with the release of Visual Studio 2013. This makes it possible for developers to release their work through NuGet packages, targeting a wide range of mobile platforms (see the <em>NuGet packages</em> section for more information).</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>The currently preferred profile and the greatest common subset for Xamarin projects is the so-called Profile 259. The Microsoft support designation for this profile is the .NET Portable Subset (.NET Framework 4.5, Windows 8, Windows Phone 8.1, Windows Phone Silverlight 8) and the NuGet target framework profile is <code class="literal">portable-net45+netcore45+wpa81+wp8</code>.</p></div></div><p>While creating a PCL, the biggest drawback is the fact that no platform-specific code can be included in or referenced by the project. This caveat is generally addressed by the abstraction of platform-specific requirements or by using dependency injection or similar methods to introduce the implementation in platform-specific projects.</p><p>For instance, in <a class="indexterm" id="id36"/>the device-specific peripheral example below, the common portable class library has a constructor that accepts two separate interfaces which can be injected with a dependency injection container or can be initialized with a device-specific implementation. The common library, in return, creates a business logic implementation, as shown:</p><div><pre class="programlisting">namespace Master.Xamarin.Portable
{
    public class MyPhotoViewer
    {
        private readonly IStorageManager m_StorageManager;

        private readonly ICameraManager m_CameraManager;
        public MyPhotoViewer(IStorageManager storageManager, ICameraManager cameraManager)
        {
            m_StorageManager = storageManager;
            m_CameraManager = cameraManager;
        }

        public async Task TakePhotoAsync()
        {
            var photoFileIdentifier = await m_CameraManager.TakePhotoAndStoreAsync();

            var photoData = await m_StorageManager.RetrieveFileAsync(photoFileIdentifier);

            // TODO: Do something with the photo buffer
        }
    }

    /// &lt;summary&gt;
    /// Should be implemented in Platform Specific Library
    /// &lt;/summary&gt;
    public interface IStorageManager
    {
        Task&lt;string&gt; StoreFileAsync(byte[] buffer);

        Task&lt;byte[]&gt; RetrieveFileAsync(string fileIdentifier);
    }

    /// &lt;summary&gt;
    /// Should be implemented in Platform Specific Library
    /// &lt;/summary&gt;
    public interface ICameraManager
    {
        Task&lt;string&gt; TakePhotoAndStoreAsync();
    }
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Shared projects</h2></div></div></div><p>The term, shared project, was<a class="indexterm" id="id37"/> initially coined by the Microsoft team with the release of Universal Apps for Windows Phone and Windows Runtime (that is, Visual Studio 2013). With the arrival of Xamarin, shared projects can also be referenced by Android and iOS projects. These types of projects are essentially wrappers or containers for shared code and resource files that are linked to multiple projects and platforms. Shared file assets are included in the referencing projects later and compiled as part of these modules.</p><div><img alt="Shared projects" src="img/B04693_01_13.jpg"/><div><p>Figure 13: Shared Projects</p></div></div><p>While using shared projects, developers should be careful when including platform-specific code since the shared elements will be included in all the referencing projects and compiled. Compiler directives (for example, <code class="literal">#if __ANDROID__</code>) can be introduced in shared projects to denote that certain parts of the code are only for a specific platform.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p><strong>Visualizing platform-specific code in shared projects</strong></p><p>With Visual Studio (2013 or higher), it is possible to visualize different execution paths according to the combinations of conditional compilation constants.</p><div><img alt="Shared projects" src="img/B04693_01_14.jpg"/><div><p>Figure 14: Visual Studio shared project editor</p></div></div><p>Visual Studio provides a dropdown in the top corner of the editor window which determines the platform-specific projects that are referencing the shared project. By selecting the project, you can see the disabled sections of the code, according the target platform.</p></div></div><p>If we <a class="indexterm" id="id38"/>used the same example to take a photo, we would need to create two completely different implementations for the same action, as shown here:</p><div><pre class="programlisting">private async Task&lt;string&gt; TakePhotoAsync()
{
    string resultingFilePath = "";

    var fileName = String.Format("testPhoto_{0}.jpg", Guid.NewGuid());

#if __ANDROID__

    Intent intent = new Intent(MediaStore.ActionImageCapture);
    var file = new File(m_Directory, fileName);
    intent.PutExtra(MediaStore.ExtraOutput, Net.Uri.FromFile(_file));

    // TODO: Need an event handler with TaskCompletionSource for
    // Intent's result
    m_CurrentActivity.StartActivityForResult(intent, 0);

    resultingFile = file.AbsolutePath;

#elif WINDOWS_PHONE_APP

    ImageEncodingProperties imgFormat = ImageEncodingProperties.CreateJpeg();


    // create storage file in local app storage   
    var file = await LocalStore.CreateFileAsync(fileName);

    resultingFilePath = file.Path;

    // take photo   
    await capture.CapturePhotoToStorageFileAsync(imgFormat, file);

#endif

    return resultingFile;
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Xamarin.Forms</h2></div></div></div><p>Xamarin.Forms is <a class="indexterm" id="id39"/>the unified library for creating UI implementations for target platforms to be rendered with native controls. Xamarin.Forms projects are generally created as PCL projects and can be referenced by Xamarin.iOS, Xamarin.Android, and Windows Phone development projects. Xamarin.Forms components can also be included in shared projects and can utilize platform-specific features.</p><p>Developers can effectively create common UI implementations with these forms, either declaratively (with XAML), or by using the API provided. These views, which are constructed with Xamarin.Forms components, are then rendered at runtime with platform-specific controls.</p><p>Development projects can be realized with Xamarin.Forms by creating the data access model up until the UI components with a shared implementation, thus raising the amount of  shared code between the platforms to as much as, or at times more than, 90%.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec19"/>NuGet packages</h2></div></div></div><p>NuGet, which<a class="indexterm" id="id40"/> was initially an open source Microsoft initiative to share code among developers, has now become a much larger ecosystem. While NuGet servers can be used as an open source library-sharing platform, many development teams use NuGet as a private company repository for compiled libraries.</p><p>NuGet <a class="indexterm" id="id41"/>packaging is a viable code-sharing and reuse strategy for Xamarin projects since it is supported by both Xamarin Studio and Visual Studio (with no further installation following Visual Studio 2012).</p><p>The NuGet target framework moniker for Xamarin projects is mono and there are further groupings such as MonoAndroid10, which refers to projects with a target framework of MonoAndroid version 1.0 or higher. Other platform targets are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">MonoAndroid: Xamarin.Android</li><li class="listitem" style="list-style-type: disc">Xamarin.iOS: Xamarin.iOS Unified API (supports 64-bit)</li><li class="listitem" style="list-style-type: disc">Xamarin.Mac: Xamarin.Mac's mobile profile</li><li class="listitem" style="list-style-type: disc">MonoTouch: iOS Classic API</li></ul></div><p>Developers are free to either re-use publicly available NuGet packages or create their own repository to store compiled packages to include in Xamarin projects.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p><strong>Creating NuGet packages in Visual Studio 2015</strong></p><p>With the release of Visual Studio 2015, there is a new project template that should help developers to create and reuse NuGet packages.</p><div><img alt="NuGet packages" src="img/B04693_01_15.jpg"/><div><p>Figure 15: The Visual Studio NuGet package project template</p></div></div><p>More information on creating NuGet packages and publishing them can be found on <a class="indexterm" id="id42"/>the NuGet documentation hub: (<a class="ulink" href="http://docs.nuget.org/create/creating-and-publishing-a-package">http://docs.nuget.org/create/creating-and-publishing-a-package</a>)</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Components</h2></div></div></div><p>Components are<a class="indexterm" id="id43"/> another approach to re-using compiled libraries and modules in Xamarin projects. The Component Store is built into both Xamarin Studio and Visual Studio and it has gathered a number of re-usable submissions from developers since its release in 2013. Components can be downloaded and installed into projects in the same way as for NuGet packages by using the Xamarin Component Store. The Xamarin Component Store<a class="indexterm" id="id44"/> can be found at <a class="ulink" href="https://components.xamarin.com">https://components.xamarin.com</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Quality in cross-development</h1></div></div></div><p>Some development <a class="indexterm" id="id45"/>terms help developers create robust, maintainable, high-quality code when developing for multiple platforms. These code descriptors help development teams identify architectural problems, software issues and random errors.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec21"/>Reusability</h2></div></div></div><p><em>"How much of the code can be reused throughout the project?"</em></p><p>Reusability is<a class="indexterm" id="id46"/> one of the key quality identifiers in cross-platform development projects. Xamarin, especially with the release of Xamarin.Forms, has provided developers with extensive resources to create platform-agnostic components that can decrease redundancy and reduce developer hours in complex projects. Code quality matrices generated by Visual Studio and unit test coverage results can convert this descriptor into a quantifiable measure.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec22"/>Abstraction</h2></div></div></div><p><em>"How much do the shared components know about the platform?"</em></p><p>It is almost <a class="indexterm" id="id47"/>unavoidable not to include platform-specific bits in cross-platform solutions. The level that these modules are abstracted to increases the robustness of the shared components and is closely related to how loosely the implemented logic is coupled with the underlying platform. In this way, the shared components can be tested easily with mock or fake libraries without having to create platform-specific test harnesses. Unit test code coverage results help determine the testability of the application.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec23"/>Loose-coupling</h2></div></div></div><p><em>"How easy is it to transpose the project into another platform?"</em></p><p>On top of <a class="indexterm" id="id48"/>the platform-specific abstracted implementation, an autonomous shared implementation layer creates flexible solutions which can easily be adapted to other platforms. Reducing the dependencies of the shared logic to the underlying platform not only inherently increases the reusability but also the agility of the development projects. The number of conditional compilation blocks or <code class="literal">if</code> or <code class="literal">else</code> loops for the underlying platform on shared projects identifies the amount of code executed according to the platform.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec24"/>Nativity</h2></div></div></div><p><em>"How much does your application blend into the platform?"</em></p><p>Even <a class="indexterm" id="id49"/>though the ultimate goal while developing with Xamarin is to create an application that can be easily compiled onto multiple targets, the applications created with Xamarin should look, feel and behave as if they were designed for that specific platform. The UI paradigms and user interaction mechanisms <a class="indexterm" id="id50"/>of each platform should be respected while creating a common foundation. Nativity is more of a nominal and subjective measure when compared to the aforementioned code descriptors.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Summary</h1></div></div></div><p>In this chapter, we have discussed some of the key features of the Xamarin development suite and development on previously described platforms and looked at Xamarin essentials for developing mobile applications. The remaining chapters refer to these key features and the differences between the platforms to identify valuable patterns and strategies to create cross-platform applications with Xamarin.</p><p>The architectural overview of the target platforms and how Xamarin applications are developed and compiled on these platforms were also discussed. The most important difference between these platforms is that Xamarin.Android (and also Windows Phone) uses .NET binaries and mono (and .NET) runtime to execute code, whereas Xamarin.iOS applications have a completely different setup and double compilation (Ahead-of-Time) to make use of .NET binaries, but not to run them directly.</p><p>Whilst developing for Android and iOS platforms with Xamarin, developers are also forced to select between different OS platforms and development IDEs. The selection and configuration of the development environment depends on the targeted platforms. IDE features and emulator and simulator options play an important role in this selection. While providing a familiar interface and letting the developers transfer their .NET-related skills and know-how, the OS X operating system together with Xamarin Studio is currently a more viable option for developing iOS applications.</p><p>Another important refresher was for the Xamarin solution structure. We talked about how developers can share code between different platforms and re-use public or private stores to include shared modules. Shared projects make up the basis for most cross-platform development patterns and strategies together with portable class libraries.</p><p>Overall, when using the Xamarin specifications and features, the main objective of developers should be to create loosely coupled, platform-agnostic modules that increase productivity and improve the quality of cross-platform development projects.</p></div></body></html>