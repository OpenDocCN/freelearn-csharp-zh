<html><head></head><body>
		<div><h1 id="_idParaDest-69"><em class="italic"><a id="_idTextAnchor124"/>Chapter 8</em>: Writing Custom Middleware</h1>
			<p>Wow, we are already onto the eighth chapter of this book! In this chapter, we will learn about <strong class="bold">middleware</strong> and how you can use it to customize your app a little more. We will quickly go over the basics of middleware and then we'll explore some special things you can do with it.</p>
			<p>In this chapter, we'll cover the following topics:</p>
			<ul>
				<li>Introducing middleware</li>
				<li>Writing custom middleware</li>
				<li>Exploring the potential of middleware</li>
				<li>Using middleware on ASP.NET Core 3.0 and later</li>
			</ul>
			<p>The topics covered in this chapter relate to the middleware layer of the ASP.NET Core architecture:</p>
			<div><div><img src="img/Figure_8.1_B17996.jpg" alt="Figure 8.1 – The ASP.NET Core architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – The ASP.NET Core architecture</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor125"/>Technical requirements</h1>
			<p>To follow the descriptions in this chapter, you will need to create an ASP.NET Core MVC application. To do this, open your console, shell, or Bash terminal, and change to your working directory. Then, use the following command to create a new MVC application:</p>
			<pre>dotnet new web -n MiddlewaresSample -o MiddlewaresSample</pre>
			<p>Now, open the project in Visual Studio by double-clicking the project file, or in Visual Studio Code by typing the following command in the already-open console:</p>
			<pre>cd MiddlewaresSample
code .</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The simple <code>web</code> project template changed in .NET 6.0. In version 6.0, Microsoft introduced <strong class="bold">minimal APIs</strong> and changed the project template to use the minimal API approach. This is a simpler way to bootstrap and to get started with a web application.</p>
			<p>All of the code samples in this chapter can be found in the <strong class="bold">GitHub</strong> repository for this book at <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter08">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter08</a>.</p>
			<h1 id="_idParaDest-71">I<a id="_idTextAnchor126"/><a id="_idTextAnchor127"/>ntroducing middleware</h1>
			<p>The majority of you probably already know what middleware is, but some of you might not. Even if you <a id="_idIndexMarker103"/>have already been using ASP.NET Core for a while, you don't really need to know about middleware instances in detail, as they are mostly hidden behind nicely named extension methods such as <code>UseMvc()</code>, <code>UseAuthentication()</code>, <code>UseDeveloperExceptionPage()</code>, and so on. Every time you call a <code>Use</code> method in the <code>Startup.cs</code> file, in the <code>Configure</code> method, you'll implicitly use at least one – or maybe more – middleware components.</p>
			<p>A middleware component is a piece of code that handles the request pipeline. Imagine the request pipeline as a huge tube where you can call something and then an echo comes back. The middleware is responsible for the creation of this echo – it manipulates the sound to enrich the information, handling the source sound, or handling the echo.</p>
			<p>Middleware components are executed in the order in which they are configured. The first middleware component configured is the first that gets executed.</p>
			<p>In an ASP.NET Core web application, if the client requests an image or any other static file, <code>StaticFileMiddleware</code> searches for that resource and returns that resource if it finds it. If not, this middleware component does nothing except call the next one. If there is no final <a id="_idIndexMarker104"/>piece of middleware that handles the request pipeline, the request returns nothing. The <code>MvcMiddleware</code> component also checks the requested resource, tries to map it to a configured route, executes the controller, creates a view, and returns an HTML or web API result. If <code>MvcMiddleware</code> does not find a matching controller, it will return a result anyway – in this case, it is a <code>404</code> status result. So, in any case, it returns an echo. This is why <code>MvcMiddleware</code> is the last piece of middleware configured.</p>
			<div><div><img src="img/Figure_8.2_B17996.jpg" alt="Figure 8.2 – A middleware workflow diagram"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – A middleware workflow diagram</p>
			<p><code>500</code> status:</p>
			<ol>
				<li>You are <a id="_idIndexMarker106"/>able to see how the pipeline is executed if you create an empty ASP.NET Core application, as described in the <em class="italic">Technical requirements</em> section.</li>
				<li>Open <code>Program.cs</code> with your favorite editor. This should be pretty small compared to a regular ASP.NET Core application. In ASP.NET Core 6.0, Microsoft introduced the minimal API approach, which simplifies the application configuration and hides a lot of default configuration from the developers. Microsoft is also implementing default <code>using</code> statements in ASP.NET Core. Because of this, you don't see any <code>using</code> statements initially. This is how <code>Program.cs</code> looks in ASP.NET Core 6.0:<pre>var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.MapGet("/", () =&gt; "Hello World!");
app.Run()<a id="_idTextAnchor128"/>;</pre><p>Here, special lambda middleware is bound to the default route and only writes <code>"Hello World!"</code> to the response stream. The response stream is the echo we learned about previously. This special middleware stops the pipeline and returns something like an echo. So, it is the last middleware to run.</p></li>
				<li>Replace the line with the call of <code>app.MapGet()</code> with the following lines of code, right before the <code>app.Run()</code> function:<pre>app.Use(async (context, next) =&gt;{
    await context.Response.WriteAsync("===");
    await next();
    await context.Response.WriteAsync("===");
});
app.Use(async (context, next) =&gt;
{
    await context.Response.WriteAsync("&gt;&gt;&gt;&gt;&gt;&gt; ");
    await next();
    await context.Response.WriteAsync(" &lt;&lt;&lt;&lt;&lt;&lt;");
});
app.Run(async context =&gt;
{
    await context.Response.WriteAsync("Hello World!");
});</pre><p>These two <a id="_idIndexMarker107"/>calls of <code>app.Use()</code> also create two lambda middlewares, but this time, in addition to dealing with specific requests, the middleware components are calling their successors: each middleware component knows which middleware component should follow it, and so calls it. The call of <code>app.Run()</code> replaces the call of <code>app.MapGet()</code>, but it does basically the same thing, except that <code>app.Run()</code> directly writes to the response stream. The lambda middlewares created with <code>app.Use()</code> write to the response stream before and after the next middleware is called. Before the next middleware is called, the actual request is handled, and after the next middleware is called, the response (echo) is handled. This should demonstrate how the pipeline works.</p></li>
				<li>If you now run the application (using <code>dotnet run</code>) and open the displayed URL in the browser, you should see a plain text result like this:<pre>===&gt;&gt;&gt;&gt;&gt;&gt; Hello World! &lt;&lt;&lt;&lt;&lt;&lt;===</pre></li>
			</ol>
			<p>Does this <a id="_idIndexMarker108"/>make sense to you? If yes, let's move on and see how to use this concept to add some additional functionality to the request pipeli<a id="_idTextAnchor129"/><a id="_idTextAnchor130"/>ne.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor131"/>Writing custom middleware</h1>
			<p>ASP.NET Core is based on middleware. All the logic that gets executed during a request is based <a id="_idIndexMarker109"/>on middleware. So, we can use this to add custom functionality to the web. In the following process, we want to find out the execution time of every request that goes through the request pipeline:</p>
			<ol>
				<li value="1">We can do this by creating and starting a stopwatch before the next middleware is called, and stop measuring the execution time after the next middleware is called, like so:<pre>app.Use(async (context, next) =&gt;
{
    var s = new Stopwatch();
    s.Start();
    // execute the rest of the pipeline
    await next();
    s.Stop(); //stop measuring
    var result = s.ElapsedMilliseconds;
    // write out the milliseconds needed
    await context.Response.WriteAsync($" Time needed: 
      {result} milliseconds");
});</pre><p>You might need to add a <code>using</code> statement for <code>System.Diagnostics</code>.</p><p>After that, we return the elapsed milliseconds to the response stream.</p></li>
				<li>If you <a id="_idIndexMarker110"/>write some more middleware components, the configuration in <code>Program.cs</code> gets pretty messy. This is why most middleware components are written as separate classes. This could look like this:<pre>using System.Diagnostics;
public class StopwatchMiddleware
{
    private readonly RequestDelegate _next;
    public StopwatchMiddleware(RequestDelegate next)
    {
        _next = next;
    }
    public async Task Invoke(HttpContext context)
    {
        var s = new Stopwatch();
        s.Start();
        // execute the rest of the pipeline
        await _next(context);
        s.Stop(); //stop measuring
        var result = s.ElapsedMilliseconds;
        // write out the milliseconds needed
        await context.Response.WriteAsync($" Time 
          needed: {result} milliseconds");
    }
}</pre><p>This way, we <a id="_idIndexMarker111"/>get the next middleware component to execute via the constructor and the current context in the <code>Invoke()</code> method.</p><p class="callout-heading">Note</p><p class="callout">The middleware is initialized at the start of the application and the constructor runs only once during the application lifetime. On the other hand, the <code>Invoke()</code> method is called once per request.</p></li>
				<li>To use this middleware, there is a generic <code>UseMiddleware()</code> method available that you can use:<pre>app.UseMiddleware&lt;StopwatchMiddleware&gt;();</pre></li>
				<li>However, the more elegant way is to create an <code>extension</code> method that encapsulates this call:<pre>public static class StopwatchMiddlewareExtension
{
    public static IApplicationBuilder 
      UseStopwatch(this IApplicationBuilder app)
    {
        app.UseMiddleware&lt;StopwatchMiddleware&gt;();
        return app;
    }
}</pre></li>
				<li>Now, you can simply call it like this:<pre>app.UseStopwatch();</pre></li>
			</ol>
			<p>This way, you can provide additional functionality to an ASP.NET Core application through the <a id="_idIndexMarker112"/>request pipeline. You have the entire <code>HttpContext</code> available in your middleware. With this, you can manipulate the request or even the response using middleware.</p>
			<p>For example, <code>AuthenticationMiddleware</code> tries to collect user information from the request. If it doesn't find any, it will ask for the information by sending a specific response back to the client. If it finds some information, it will add it to the request context and make it available to the entire application th<a id="_idTextAnchor132"/><a id="_idTextAnchor133"/>is way.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor134"/>Exploring the potential of middleware</h1>
			<p>There are <a id="_idIndexMarker113"/>many other things you can do with middleware. For example, did you know that you can split the request pipeline into two or more pipelines? We'll look at how to do that and several other things in this section.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor135"/>Branching the pipeline with /map</h2>
			<p>The next <a id="_idIndexMarker114"/>code snippet shows how to create branches of the request pipeline based on specific paths:</p>
			<pre>app.Map("/map1", app1 =&gt;
{
    // some more Middleware
    app1.Run(async context =&gt;
    {
        await context.Response.WriteAsync("Map Test 1");
    });
});
app.Map("/map2", app2 =&gt;
{
    // some more Middleware
    app2.Run(async context =&gt;
    {
        await context.Response.WriteAsync("Map Test 2");
    });
});
// some more Middleware</pre>
			<p>The <code>/map1</code> path is <a id="_idIndexMarker115"/>a specific branch that continues the request pipeline inside – this is the same with the <code>/map2</code> path. Both maps have their own middleware configurations inside. All other unspecified paths will follow the main branch.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor136"/>Branching the pipeline with MapWhen()</h2>
			<p>There is <a id="_idIndexMarker116"/>also a <code>MapWhen()</code> method to branch the pipeline based on a condition, instead of a branch based on a path:</p>
			<pre>public void Configure(IApplicationBuilder app)
{
    app.MapWhen(
        context =&gt; 
          context.Request.Query.ContainsKey("branch"),
        app1 =&gt;
        {
            // some more Middleware
            app1.Run(async context =&gt;
            {
                await context.Response.WriteAsync(
                    "MapBranch Test");
            });
    });
    // some more Middleware
    app.Run(async context =&gt;
    {
        await context.Response.WriteAsync(
            "Hello from non-Map delegate.");
    });
}</pre>
			<p>Next, we'll <a id="_idIndexMarker117"/>look at using middleware to create conditions.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor137"/>Creating conditions with middleware</h2>
			<p>You can create conditions based on configuration values or, as shown here, based on properties <a id="_idIndexMarker118"/>of the request context. In the previous example, a query string property was used. You can use HTTP headers, form properties, or any other property of the request context.</p>
			<p>You are also able to nest the maps to create child and grandchild branches if needed.</p>
			<p>We can use <code>Map()</code> or <code>MapWhen()</code> to provide a special API or resource based on a specific path or a specific condition, respectively. The ASP.NET Core <code>HealthCheck</code> API works like this: first, it uses <code>MapWhen()</code> to specify the port to use, and then, it uses <code>Map()</code> to set the path for the <code>HealthCheck</code> API (or, it uses <code>Map()</code> if no port is specified). In the end, <code>HealthCheckMiddleware</code> is used. The following code is just an example to show what this looks like:</p>
			<pre>private static void UseHealthChecksCore(IApplicationBuilder 
  app, PathString path, int? port, object[] args)
{
    if (port == null)
    {
        app.Map(path, 
            b =&gt; 
             b.UseMiddleware&lt;HealthCheckMiddleware&gt;(args));
    }
    else
    {
        app.MapWhen(
            c =&gt; c.Connection.LocalPort == port,
            b0 =&gt; b0.Map(path, 
            b1 =&gt; 
              b1.UseMiddleware&lt;HealthCheckMiddleware&gt;(args)
            )
        );
    };
}</pre>
			<p>Next, let's <a id="_idIndexMarker119"/>see how you should use terminating middleware components in newer versions of ASP.NET Core.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor138"/>Using middleware in ASP.NET Core 3.0 and later</h1>
			<p>In ASP.NET <a id="_idIndexMarker120"/>Core 3.0 and later, there are two <a id="_idIndexMarker121"/>new kinds <a id="_idIndexMarker122"/>of middleware element, and they are called <code>UseRouting</code> and <code>UseEndpoints</code>:</p>
			<pre>public void Configure(IApplicationBuilder app, 
  IWebHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    app.UseRouting();
    app.UseEndpoints(endpoints =&gt;
    {
        endpoints.MapGet("/", async context =&gt;
        {
           await context.Response.WriteAsync("Hello 
                                              World!");
  <a id="_idTextAnchor139"/>      });
    });
}</pre>
			<p>The first <a id="_idIndexMarker123"/>one is a middleware component that uses routing and the other one uses endpoints. So, what exactly are we looking at?</p>
			<p>This is <a id="_idIndexMarker124"/>the new <strong class="bold">endpoint routing</strong>. Previously, routing was part of MVC, and it only worked with MVC, web APIs, and frameworks that are based on the MVC framework. In ASP.NET Core 3.0 and later, however, routing is no longer in the MVC framework. Now, MVC and the other frameworks are mapped to a specific route or endpoint. There are different kinds of endpoint definitions available.</p>
			<p>In the preceding code snippet, a <code>GET</code> request is mapped to the page root URL. In the next code snippet, MVC is <a id="_idIndexMarker125"/>mapped to a route pattern, and <strong class="bold">Razor Pages</strong> are mapped to the Razor Pages-specific file structure-based routes:</p>
			<pre>app.UseEndpoints(endpoints =&gt;
{
    endpoints.MapControllerRoute(
        name: "default",
        pattern: "{controller=Home}/{action=Index}/{id?}");
    endpoints.MapRazorPages();
});</pre>
			<p>There is no <code>UseMvc()</code> method anymore, even if it still exists and works on the <code>IApplicationBuilder</code> object level, to prevent the existing code from breaking. Now, there are new methods to activate ASP.NET Core features more granularly.</p>
			<p>These are <a id="_idIndexMarker126"/>the most commonly used new <code>Map</code> methods for ASP.NET Core 5.0 or later:</p>
			<ul>
				<li><code>endpoints.MapAreaControllerRoute(...);</code></li>
				<li><code>endpoints.MapControllerRoute(...);</code></li>
				<li><code>endpoints.MapBlazorHub(...);</code></li>
				<li><code>endpoints.MapHub(...);</code></li>
				<li><code>endpoints.MapRazorPages(...);</code></li>
				<li><code>endpoints.MapHealthChecks(...);</code></li>
			</ul>
			<p>There are many more methods to define fallback endpoints, to map routes and HTTP methods to delegates, and for middleware components.</p>
			<p>If you <a id="_idIndexMarker127"/>want to create middleware that works on all requests, such as <code>StopWatchMiddleware</code>, this will work as before on <code>IApplicationBuilder</code>. If you would like to write middleware to work on a specific path or route, you will need to create a <code>Map</code> method for it to map it to that route.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">It is no longer recommended to handle the route inside the middleware. Instead, you should use the new endpoint routing. With this approach, the middleware is a lot more generic, and it will work on multiple routes with a single configuration.</p>
			<p>I recently wrote middleware to provide a <strong class="bold">GraphQL</strong> endpoint in an ASP.NET Core application. However, I had to rewrite it to follow the new ASP.NET Core routing. The old way would still have worked, but it would have handled the paths and routes separately from the new ASP.NET Core routing. Let's look at how to deal with those situations.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor140"/>Rewriting terminating middleware to meet the current standards</h2>
			<p>If you <a id="_idIndexMarker128"/>have existing middleware that provides a different endpoint, you should change it to use the new endpoint routing:</p>
			<ol>
				<li value="1">As an example, let's create small, dummy middleware that writes an application status to a specific route. In this example, there is no custom route handling:<pre>namespace MiddlewaresSample;
public class AppStatusMiddleware
{
    private readonly RequestDelegate _next;
    private readonly string _status;
    public AppStatusMiddleware(
        RequestDelegate next, string status)
    {
        _next = next;
        _status = status;
    }
    public async Task Invoke(HttpContext context)
    {
        await context.Response.WriteAsync(
            $"Hello {_status}!");
    }
}</pre><p>The first thing we need to do is write an <code>extension</code> method on the <code>IEndpointRouteBuilder</code> object. This method has a route pattern as an optional argument <a id="_idIndexMarker129"/>and returns an <code>IEndpointConventionBuilder</code> object to enable <strong class="bold">cross-origin resource sharing</strong> (<strong class="bold">CORS</strong>), authentication, or other conditions to the route.</p></li>
				<li>Now, we <a id="_idIndexMarker130"/>should add an extension method to make it easier to use the middleware:<pre>public static class MapAppStatusMiddlewareExtension
{
    public static IEndpointConventionBuilder 
      MapAppStatus(
        this IEndpointRouteBuilder routes,
        string pattern = "/", 
        string name = "World")
    {
        var pipeline = routes
            .CreateApplicationBuilder()
            .UseMiddleware&lt;AppStatusMiddleware&gt;(name)
            .Build();
        return routes.Map(pattern, pipeline)
            .WithDisplayName("AppStatusMiddleware");
    }
}</pre></li>
				<li>Once that is complete, we can use the <code>MapAppStatus</code> method to map it to a specific route:<pre>app.UseRouting();
app.UseEndpoints(endpoints =&gt;
{
    endpoints.MapGet("/", () =&gt; "Hello World!");
    endpoints.MapAppStatus("/status", "Status");
});</pre></li>
				<li>We can <a id="_idIndexMarker131"/>now call the route in the browser by entering the following address: <code>http://localhost:5000/status</code>.</li>
			</ol>
			<p>We will learn more about endpoint routing and how to customize it in <a href="B17996_09_ePub.xhtml#_idTextAnchor143"><em class="italic">Chapter 9</em></a>, <em class="italic">Working with Endpoint Routing</em>. For now, let's recap what we've<a id="_idTextAnchor141"/> learned about middleware.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor142"/>Summary</h1>
			<p>Most of the ASP.NET Core features are based on middleware and in this chapter, you learned how middleware works and how to create your own middleware components to extend the ASP.NET framework. You also learned how to use the new routing to add routes to your own custom terminating middleware components.</p>
			<p>In the next chapter, we will have a look at the new endpoint routing in ASP.NET Core, which allows you to create your own hosted endpoints in an easy and flexible way.</p>
		</div>
	</body></html>