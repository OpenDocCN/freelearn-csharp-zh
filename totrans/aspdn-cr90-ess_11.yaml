- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud-Native Development with ASP.NET Core 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern applications are designed to operate in cloud environments and take advantage
    of the various features provided, such as agility, scalability, availability,
    and resilience. ASP.NET Core 9 provides us with a set of powerful tools that allow
    us to develop high-quality solutions. However, it is important to be aware of
    the patterns and best practices related to the cloud-native development model.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about important aspects related to applications
    hosted in cloud environments, exploring patterns, best practices, the mindset
    required for cloud-native application development, the principles of the twelve-factor
    app, and architectural design principles so that you can get the most out of your
    cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a cloud-native mindset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with cloud-native tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The principles of the twelve-factor app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding cloud architecture principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code examples used in this chapter can be found in the book’s GitHub repository:
    [https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter11](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter11)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for you to take advantage of all the examples proposed in this chapter,
    it is important that you fork the book repository. Forking is a feature available
    on GitHub that copies a repository so that it can be managed by a Git user. You
    can learn how to fork a repository using the following URL: [https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/fork-a-repo](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/fork-a-repo)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a cloud-native mindset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every year brings new innovations in cloud computing: there are always new
    features that bring new possibilities and companies that want new ways to deliver
    value to users in an increasingly demanding market.'
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we learned about various tools, patterns, and best practices
    and interacted with cloud resources. But even in a scenario where applications
    are built with best practices and standards in mind, are they able to benefit
    from all the features that a cloud environment can provide?
  prefs: []
  type: TYPE_NORMAL
- en: Even today, there are many organizations that run applications in private environments
    (on-premises), which brings several benefits. Consequently, applications developed
    in these environments have limited scalability and deal with high costs for purchasing
    servers and qualified professionals to maintain them.. In this solution model,
    computing resources are limited, but at the same time, it brings benefits of greater
    control, compliance, and security for companies.
  prefs: []
  type: TYPE_NORMAL
- en: The cloud appears is an alternative to this model that enhances computing power
    for organizations, but at the same time, several other challenges arise, including
    in the development model and process.
  prefs: []
  type: TYPE_NORMAL
- en: To use the cloud model, we need to understand how it works, its service layers,
    the necessary investments, and how we can adapt our applications to a cloud-native
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by looking at the service layers offered in cloud environments.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the service layers in a cloud environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Maybe you’ve already heard about **CapEx** and **OpEx** and how important these
    two words are in the corporate world:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Capital expenditure** ( **CapEx** ): CapEx is not a term exclusive to the
    IT area but is a financial term related to expenses or investments in assets.
    The calculation is simple: if there is a need for more servers to support user
    demand, CAPex comes into play and is related to the cost of investment in servers,
    physical location for installing the servers, electricity, UPS, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operating expenditure** ( **OpEx** ): OpEx refers to the ongoing costs of
    running daily operations. This includes expenses for services, utilities, rent,
    software licensing, and other operational activities such as staff salaries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observing these concepts, every organization needs to reflect on its investments,
    costs, and professionals to remain competitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'When moving to an approach involving cloud computing, the transition from CapEx
    to OpEx takes place. This change has several implications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduced upfront costs** : Adopting cloud services reduces the need for large
    upfront investments in physical hardware and infrastructure. Instead, organizations
    pay for the cloud services they use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalable costs** : Cloud services offer a pay-as-you-go model, allowing organizations
    to scale their usage and expenses according to demand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operational flexibility** : Ability to quickly adapt to changes in business
    needs without dependence on investments in hardware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintenance and updates** : Cloud providers such as Azure provide infrastructure
    maintenance, updates, and security services, reducing the operational burden on
    an organization’s IT team and allowing them to focus on strategic initiatives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, having services running in the cloud does not mean that there will
    be less cost as there is a pay-as-you-go model. As with any tool or strategy,
    if not used correctly, the cloud can cause major problems for organizations.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud providers such as Azure take care of the entire infrastructure for providing
    computing services; however, there is shared management with the organizations
    that use the services. This service model is very important to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the cloud computing model, organizations focus their efforts on their products
    and services, benefiting from shared management with cloud providers. Organizations
    basically have three options to choose from when deciding what service model they
    want:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Cloud computing services offer](img/B21788_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Cloud computing services offer
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 11* *.1* , we have the following types of service layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Infrastructure as a Service (IaaS)** : Provides virtualized computing resources,
    where the company dynamically provisions virtual machines, storage, and networking.
    It is a common adoption model in on-premises migration strategies to the cloud.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform as a Service (PaaS)** : Provides a platform that abstracts infrastructure,
    allowing organizations and development teams to focus on solutions and data. We
    used a PaaS resource in [*Chapter 10*](B21788_10.xhtml#_idTextAnchor162) when
    publishing an Azure App Service application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software as a Service (SaaS)** : Provides software applications on a subscription
    basis, such as streaming applications and Microsoft 365 applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud services are essential components of cloud-native development, helping
    to define migration strategies, cost optimization, scalability, resiliency, security,
    and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: So that we can understand how we should adapt our tools and development processes
    and benefit from the power of cloud computing, it is important to start with best
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native development best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft provides extensive documentation and powerful services in Azure, where
    it is possible to host applications using different technologies and, of course,
    solutions developed in ASP.NET Core 9.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to documenting the resources available in Azure, it is very important
    that development teams know about the **Cloud Adoption Framework** ( **CAF** )
    and the **Well-Architected Framework** ( **WAF** ). These two resources have different
    use cases and help teams deal with various challenges posed by cloud environments.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s briefly learn about each of these features.
  prefs: []
  type: TYPE_NORMAL
- en: The CAF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microsoft’s CAF has an excellent collection of documentation, implementation
    guidance, best practices, and tools designed to help organizations plan and execute
    their cloud adoption strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CAF basically consists of seven phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strategy** : Define business outcomes, establish a cloud adoption plan, and
    prioritize workloads for migration.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Plan** : Assess your current digital estate, create a cloud adoption plan,
    and identify gaps in required skills and resources.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Ready** : Prepare the environment for cloud adoption by configuring a landing
    zone that includes governance, security, and management tools.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Migrate** : Migrate workloads to the cloud, using tools and methodologies
    to ensure a smooth transition.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Innovate** : Develop new cloud-native applications or modernize existing
    applications to make the most of cloud capabilities.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Govern** : Implement governance best practices to ensure compliance, manage
    risk, and establish security controls.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Manage** : Operate and manage the cloud environment, using monitoring and
    management tools to ensure performance, reliability, and cost efficiency.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CAF
  prefs: []
  type: TYPE_NORMAL
- en: CAF has extensive documentation and resources that should be part of a software
    engineer’s daily life. To learn more, visit [https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/](https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The CAF aims to help organizations adopt a cloud-native mindset, emphasizing
    the importance of planning, governance, and continuous improvement, ensuring that
    cloud adoption aligns with business objectives.
  prefs: []
  type: TYPE_NORMAL
- en: The CAF is an excellent source of knowledge, and generally, the focus is not
    exactly on one application (or workload, as they are commonly called) but on structuring
    the entire environment in general. However, it can be used as an excellent source
    of knowledge and planning for new workloads, as it involves business teams, development,
    infrastructure, and the entire continuous delivery flow.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the CAF, there is another very important resource that must be
    taken into consideration when defining application architectural models for your
    cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: The WAF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The WAF is a set of capabilities offered by Microsoft that contains best practices,
    principles, and architectural guidance for designing, building, and operating
    secure, high-performance, resilient, and efficient infrastructures for your cloud
    applications. The WAF is subdivided into five pillars:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operational excellence** : This pillar focuses on operational processes that
    keep applications running smoothly and efficiently. This includes monitoring,
    automation, and incident response.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Security** : This pillar ensures that applications and data are protected
    from threats. It covers identity management, infrastructure protection, data encryption,
    and threat detection.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Reliability** : This pillar ensures that applications can recover from failures
    and continue to function as expected. This includes disaster recovery strategies,
    fault tolerance, and data backup.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Performance efficiency** : This pillar ensures that applications use resources
    efficiently and can scale to meet demand. It covers capacity planning, resource
    optimization, and performance monitoring.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Cost optimization** : This pillar focuses on effectively managing costs while
    delivering optimal performance and value. This includes cost monitoring, usage
    analysis, and implementing cost reduction strategies.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Learn more about the WAF
  prefs: []
  type: TYPE_NORMAL
- en: The WAF not only provides great documentation containing strategies and best
    practices in relation to each of the five pillars, but it also provides tools,
    such as **Assessment** , where it is possible to analyze your existing cloud workloads
    to improve them, checklists, and many other resources. To learn more about the
    WAF, visit [https://learn.microsoft.com/en-us/azure/well-architected/](https://learn.microsoft.com/en-us/azure/well-architected/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Each of the pillars presented previously supports a cloud-native mindset, providing
    clear and practical guidelines for each workload. This allows teams to not only
    analyze solutions from different perspectives but also make the best of the cloud
    environment through high-quality solutions that meet organizational objectives,
    such as cost optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Going beyond code development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To achieve a cloud-native solutions mindset, as software engineers, we must
    be prepared to go beyond the boundaries of code development.
  prefs: []
  type: TYPE_NORMAL
- en: The DevOps culture brings a collaboration model that is not just restricted
    to different teams communicating effectively but extends to sharing knowledge,
    standards, and best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Operations teams have adapted to the code development model by using technology
    such as Infrastructure as Code, GitHub repositories, and even pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, it is important that we learn concepts related to networking, infrastructure,
    security, and data. This will make all the difference in the architectural design
    and development of solutions that make the best of cloud environments and will
    help create a cloud-native mindset.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an insight into the challenges associated with cloud computing,
    it’s time to learn about cloud-native tools.
  prefs: []
  type: TYPE_NORMAL
- en: Working with cloud-native tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an increasingly competitive market, being agile and delivering solutions
    quickly has become synonymous with success.
  prefs: []
  type: TYPE_NORMAL
- en: The cloud-native approach is associated with agility and speed, allowing teams
    to create solutions, and adding layers of services and functionalities with loose
    coupling, resilience, management, and observability.
  prefs: []
  type: TYPE_NORMAL
- en: However, we must understand the relationship between agility and speed when
    it comes to developing cloud-native applications. Being agile is not being fast,
    and being fast does not necessarily mean being agile. That completely changes
    the way we think about a solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say your team received a request to create an API that aims to provide
    data on products available for sale in an online store, as shown in *Figure 11*
    *.2* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Online store consuming a Product API](img/B21788_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Online store consuming a Product API
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example shown in *Figure 11* *.12* , the Product API would be an application
    in ASP.NET Core 9, containing good layer and package separation practices – let’s
    say it’s hosted in Microsoft Azure. From an application perspective, all expected
    API features have most likely been implemented according to functional and non-functional
    requirements. It is also expected that the quality process has been carried out
    satisfactorily, as shown in *Figure 11* *.3* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Development and publishing flow](img/B21788_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Development and publishing flow
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11* *.3* shows a common scenario of a software development process,
    involving task management, requirements, coding, deployment, and application maintenance.'
  prefs: []
  type: TYPE_NORMAL
- en: The main objective is to quickly meet market needs, that is, reducing the lead
    time for delivering value.
  prefs: []
  type: TYPE_NORMAL
- en: The shorter the lead time, the better. For teams and organizations to be able
    to strike a good balance between agility and speed, it is very important to understand
    the factors in each of the process steps shown in *Figure 11* *.3* .
  prefs: []
  type: TYPE_NORMAL
- en: An application developed and delivered in an environment is not necessarily
    a cloud-native solution. As software engineers, we must go beyond the artifact
    generated after compiling a code, and, prepare applications to be able to take
    full advantage of cloud environments and handle growing user demand., we must
    be prepared to act in different areas of knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, cloud-native solutions must be based on factors such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modern design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers and orchestrators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These factors can be represented graphically as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Cloud-native factors](img/B21788_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Cloud-native factors
  prefs: []
  type: TYPE_NORMAL
- en: These factors form the basis for the development of cloud-native solutions and
    must be worked on continuously, since changes, both in service requirements and
    market needs, are constant.
  prefs: []
  type: TYPE_NORMAL
- en: Another important factor that we can notice in *Figure 11* *.4* is that there
    is no relationship between the factors and a specific cloud provider, such as
    Azure, AWS, or GCP. On the contrary, the cloud-native model is a vendor-agnostic
    paradigm, and therefore, contrary to what generally happens with hyped-up technologies,
    there are a range of adoption patterns, definitions, and good practices, maintained
    by the **Cloud Native Computing** **Foundation** ( **CNCF** ).
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know CNCF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CNCF is a consortium created in 2015 within the scope of the Linux Foundation.
    It involves more than 400 companies that aim to create a common language between
    technologies, standards, and best practices, independent of the supplier. CNCF
    aims to build sustainable solution ecosystems for cloud-native software by bringing
    together communities of developers, end users, and vendors.
  prefs: []
  type: TYPE_NORMAL
- en: CNCF promotes cloud-native technologies, supporting and maintaining projects
    that enable the adoption of practices such as containerization, microservices,
    and dynamic orchestration, promoting open standards and best practices, and allowing
    cloud-native applications to work in an interoperable manner. Additionally, CNCF
    supports innovation by nurturing a community of contributors and maintaining a
    neutral ground for the development of cutting-edge cloud-native tools and projects.
  prefs: []
  type: TYPE_NORMAL
- en: One of the important resources of CNCF is the technology landscape, which is
    a visual representation and interactive guide that maps the cloud-native ecosystem
    in a categorized way, displaying a wide range of tools, projects, and technologies
    that are part of or related to the mission of CNCF.
  prefs: []
  type: TYPE_NORMAL
- en: The CNCF landscape
  prefs: []
  type: TYPE_NORMAL
- en: 'The CNCF landscape is an excellent resource for organizations and professionals,
    helping you to understand the technology and tool options available, their relationships,
    and their roles in the cloud-native ecosystem. To learn more about the CNCF landscape,
    visit the following URL: [https://landscape.cncf.io](https://landscape.cncf.io)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: To understand how we could use CNCF to our advantage, let’s look at a development
    scenario for an ASP.NET Core 9 solution hosted on Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Working with CNCF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '*You are developing a web application using ASP.NET Core 9 and the application
    is hosted in Azure. You want to ensure that your application is developed using
    cloud-native principles and that it leverages the best tools available for deployment,
    monitoring,* *and management.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how the use of CNCF can support us in the architectural definition
    and development of the application in the scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Containerization strategy** : Based on the knowledge acquired in the previous
    chapter, you choose to use Docker and containerize your ASP.NET Core 9 application.
    To recap, Docker, a project formed by CNCF, allows you to package your application
    and its dependencies in a container, ensuring consistency in different environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the benefits:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensures application consistency across development, testing, and production
    environments
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifies dependency management and isolation
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container orchestration** : For this application to be hosted, you decide
    to use Kubernetes, which is another CNCF graduate project, for container orchestration.
    **Azure Kubernetes Service** ( **AKS** ) provides a managed Kubernetes environment
    in Azure, making it easy to deploy, manage, and scale your containerized applications.
    AKS uses the same standards defined by the CNCF in relation to Kubernetes but
    abstracts the complexity of creating a cluster and offers several other services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the benefits:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Manages the container lifecycle, scaling, and load balancing
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensures high availability and resilience
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automation** : You decide to use CI/CD tools such as Jenkins or GitHub Actions
    to automate your build, test, and deployment processes. These tools ensure that
    your code changes are continually integrated and deployed, improving your development
    workflow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the benefits:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Automates the deployment process, ensuring consistency and reducing the risk
    of human error
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Accelerates the development cycle, enabling continuous integration and deployment
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring and logging** : Completing development, performing continuous
    integration, and achieving continuous deployment are just the first steps to working
    on a project as a cloud-native solutions software engineer. It’s important to
    incorporate observability tools such as **Prometheus** and **Grafana** , both
    incubating CNCF projects, to monitor the performance and health of your application.
    Prometheus collects metrics and Grafana visualizes them, providing insights into
    your application’s behavior. Azure Monitor is also an observability tool featured
    in the CNCF landscape. Furthermore, other types of tools such as **OpenTelemetry**
    , also incubated by CNCF, would be a great option for applications to have a vendor-agnostic
    collector, which reduces the dependence on proprietary libraries in applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the benefits:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides real-time monitoring and alerts for your application
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Helps you quickly diagnose and resolve performance issues
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging CNCF and its landscape provides numerous tools and best practices
    for developing, deploying, and managing cloud-native applications. By adopting
    these tools, a software engineer working on an ASP.NET Core 9 application hosted
    in Azure can ensure that their application is scalable, resilient, and maintainable.
    Containerization with Docker, orchestration with Kubernetes, observability with
    Prometheus and Grafana, and automated CI/CD pipelines with Jenkins or GitHub Actions
    are just a few examples of how CNCF projects can enhance your cloud-native development
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: However, the scenario mentioned previously provides an Azure-agnostic solution
    model, making it possible to be hosted on different cloud providers, as each of
    the tools mentioned follows the standards established by CNCF for cloud-provider-agnostic
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to regularly visit the CNCF website to be aware of news
    and changes in cloud models and analyze the tools available in the CNCF landscape
    for the needs of your solutions. These resources will help you create increasingly
    powerful solutions that adapt to the different needs of your organization and
    the market.
  prefs: []
  type: TYPE_NORMAL
- en: We know that CNCF is an important resource that sets the standard for cloud-native
    solutions and should be added to any software engineer’s toolbox. Additionally,
    there are other principles that, in a practical way, guide us in the process of
    developing cloud-native solutions. ASP.NET Core 9 can help us implement these
    principles, such as the **twelve-factor app methodology** . We will discuss these
    principles in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The twelve-factor app principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The twelve-factor app methodology ( [https://12factor.net](https://12factor.net)
    ) is a set of best practices designed to help developers build modern, scalable,
    and maintainable cloud-native applications. It was created by Heroku developers
    to provide a framework for developing applications that can be deployed and managed
    in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku
  prefs: []
  type: TYPE_NORMAL
- en: According to the website’s own definition, Heroku is a cloud platform that allows
    companies to create, deliver, monitor, and scale applications.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku is a cloud PaaS offering, founded in 2007, that allows developers to
    build, run, and operate applications entirely in the cloud in a simplified way.
    To learn more, visit [https://www.heroku.com/home](https://www.heroku.com/home)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The twelve-factor app methodology, as the name suggests, has twelve factors
    or principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code base** : Use a code base tracked in version control.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dependencies** : Explicitly declare and isolate dependencies.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Config** : Store the configuration in the environment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Backing services** : Treat supporting services as attached resources.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Build, release, run** : Strictly separate the build and run stages.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Processes** : Run the application as one or more stateless processes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Port binding** : Export services via port binding.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Concurrency** : Expansion through the process model.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Disposability** : Maximize robustness with fast startup and smooth shutdown.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dev/prod parity** : Keep development, staging, and production as similar
    as possible.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Logs** : Treat logs as streams of events.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Administrative processes** : Perform administrative/management tasks as single
    processes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s get into more detail about each of the factors mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: Code base
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the solution development cycle, you should maintain the source code in
    a remote repository, such as a Git-based repository.
  prefs: []
  type: TYPE_NORMAL
- en: The code base factor entails that there should be a code base for each application
    context, allowing the correct separation of responsibilities and improving code
    management.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11* *.5* illustrates the management of the different contexts of an
    application, such as configurations, source code, and infrastructure scripts.
    Each of these contexts can be distributed in different environments, at different
    times in the development flow.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Code base management](img/B21788_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Code base management
  prefs: []
  type: TYPE_NORMAL
- en: Despite being a principle considered natural during the application development
    flow, its importance goes beyond source code management on remote servers. Development
    teams must take ownership of the end-to-end solution, defining source code management
    processes such as the use of branches, development standards, code review, quality
    processes, and documentation.
  prefs: []
  type: TYPE_NORMAL
- en: In cloud environments, it is common to have one repository for managing application
    code and another repository specifically for storing infrastructure code. The
    contextualization and separation of contexts in repositories allow for constant
    collaboration and management between the development and operations teams.
  prefs: []
  type: TYPE_NORMAL
- en: The code base principle is the basis for all other principles. Next, we will
    learn about dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dependencies are part of application development, as we have already seen in
    some examples in the book when using NuGet packages. Using packages brings benefits
    such as reusability and, together with package management mechanisms, allows for
    easy package updates. Most programming languages currently provide extensibility
    mechanisms based on package management.
  prefs: []
  type: TYPE_NORMAL
- en: The dependencies principle defines that dependencies must be managed in a manifest
    file and a package management tool must be used.
  prefs: []
  type: TYPE_NORMAL
- en: For example, ASP.NET Core 9 applications have the NuGet package manager, and
    all dependencies are managed through the **<ProjectName>.csproj** file, which
    contains the references and versions of the packages used in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Through this feature, we can benefit from the interoperability of the .NET platform,
    and in conjunction with the .NET CLI tool, we are able to obtain dependencies
    in a simple way, executing the **dotnet restore** command and allowing us to build
    and generate deployment packages without running the risk of human error.
  prefs: []
  type: TYPE_NORMAL
- en: Using package management avoids managing dependency files manually.
  prefs: []
  type: TYPE_NORMAL
- en: Just as dependencies are necessary in an application, configurations are important.
    Let’s understand how the config factor helps in configuration management.
  prefs: []
  type: TYPE_NORMAL
- en: Config
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All applications have some type of configuration file, which can include sensitive
    information such as encryption keys and connection strings. Keeping settings in
    configuration files is an excellent practice and avoids having to change the source
    code if there is a configuration change.
  prefs: []
  type: TYPE_NORMAL
- en: In the cloud, applications generally have different environments to ensure that
    with each update, the quality of the solution remains high. Furthermore, production
    environments have access restrictions for security reasons; application configurations
    in production environments should not be accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The config factor says that configurations must be kept separate from code,
    making it easier to manage different environments. *Figure 11* *.6* illustrates
    the approach proposed by the config factor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Configuration server and environments](img/B21788_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Configuration server and environments
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 11* *.6* , the development flow uses an automation
    pipeline, CI, and CD, and when the artifact is obtained, it will be published
    in different environments.
  prefs: []
  type: TYPE_NORMAL
- en: The application then obtains its respective configurations based on the execution
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B21788_10.xhtml#_idTextAnchor162) , we learned how to manage
    application configurations and behaviors using Azure App Configuration. This way,
    we can abstract the management of developers’ configurations and define access
    to sensitive configurations, and the application can be dynamically deployed in
    different environments.
  prefs: []
  type: TYPE_NORMAL
- en: Configurations are very important in the context of any application, as are
    the integrations that are made. The next factor suggests a best practice that
    directly influences the architectural definitions of a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Backing services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most applications have some dependency on external resources or, in this case,
    backing services. These resources can be databases, email servers, and storage
    servers, among other services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applications must be prepared to isolate such dependencies and, at the same
    time, be able to use these services independently of the execution environment,
    without any changes to the code. Backing services must be exposed through a URL
    and respective credentials, depending on the resource. Resources must be maintained
    and made available in isolation and applications must reference them. Let’s look
    at *Figure 11* *.7* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Interaction between an application and backing services](img/B21788_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Interaction between an application and backing services
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 11* *.7* , the application’s architectural model proposes
    isolation between services that are consumed externally, such as database, message
    broker, and storage services. When reflecting on architectural approaches at the
    source code level, the use of **hexagonal architecture** or **Onion Architecture**
    can help in this context of service isolation.
  prefs: []
  type: TYPE_NORMAL
- en: Hexagonal architecture and Onion Architecture
  prefs: []
  type: TYPE_NORMAL
- en: Hexagonal architecture (or ports-and-adapters architecture) is a design pattern
    that aims to create a clear separation between core business logic and external
    elements, such as user interfaces, databases, and other services. In this architecture,
    the core application logic is in the center, surrounded by several ports, which
    define interfaces for different functionalities. Adapters are the specific implementation
    of the interfaces for interacting with some external resource.
  prefs: []
  type: TYPE_NORMAL
- en: The Onion Architecture, also a design pattern, emphasizes the separation of
    concerns within an application. It places the core domain in the center, surrounded
    by layers that contain infrastructure and presentation concerns. The innermost
    layer represents the domain model and business logic, which are independent of
    external concerns. Surrounding this core are layers for application services,
    followed by infrastructure and user interfaces in the outermost layer. Dependencies
    flow inward, which means that external layers can depend on internal layers, but
    not vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the hexagonal architecture and the Onion Architecture, visit
    [https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/)
    and [https://jeffreypalermo.com/blog/the-onion-architecture-part-1/](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The backing services factor, if analyzed further, allows us to reflect on other
    architectural aspects that are important in a cloud environment, such as resilience
    and availability. As applications depend on other services, certain questions
    arise, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '*How should the application behave if the database or cache is* *not working?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What if the email service is* *not working?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The answers to these questions allow us to expand our horizons beyond source
    code, moving us toward cloud-native thinking.
  prefs: []
  type: TYPE_NORMAL
- en: The isolation proposed by the backing services factor allows automation approaches
    to be used in the value delivery flow.
  prefs: []
  type: TYPE_NORMAL
- en: Build, release, run
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B21788_10.xhtml#_idTextAnchor162) , we learned about the importance
    of DevOps and automated processes, in the *Understanding the DevOps approach with*
    *CI/CD* section.
  prefs: []
  type: TYPE_NORMAL
- en: Automation is exactly the concept defined by the build, release, run factor.
  prefs: []
  type: TYPE_NORMAL
- en: The CI process is associated with the moment of building the artifact, where
    processes such as downloading dependencies and building and executing quality
    and security flows are carried out, in addition to making the artifact available
    to be consumed by another process, such as CD.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11* *.8* demonstrates the CI process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – CI and the pull-request approach](img/B21788_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – CI and the pull-request approach
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the CI process, we have CD, whose objective is to deploy the
    artifact in different environments.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11* *.9* demonstrates the CD process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – CD with the rollback approach](img/B21788_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – CD with the rollback approach
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Figure 11* *.9* , the use of automated processes brings great benefits
    to the CD flow. CD is executed after CI, and if there is any inconsistency in
    any environment, or even in the production environment, rollback processes can
    be executed quickly to publish the latest stable version of the application again.
    Furthermore, other techniques can be used in this process, such as feature toggles,
    as discussed in [*Chapter 10*](B21788_10.xhtml#_idTextAnchor162) .
  prefs: []
  type: TYPE_NORMAL
- en: The next factor is very important for cloud-native environments.
  prefs: []
  type: TYPE_NORMAL
- en: Processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The processes factor defines that an application should be executed in an environment,
    independently and without the state. If state storage is required, it must be
    stored through external support services. Stateless processes are easily sized
    and replaced without losing the state, improving reliability and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11* *.10* shows a high-level view of an application running in different
    processes and interacting with a database-based state persistence model.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – Managing application states with a database](img/B21788_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – Managing application states with a database
  prefs: []
  type: TYPE_NORMAL
- en: Web APIs developed in ASP.NET Core are an example of stateless applications,
    where there is no state management through sessions in memory. Each request has
    the context of the information that needs to be processed by the API, as we learned
    in [*Chapter 6*](B21788_06.xhtml#_idTextAnchor093) , where we implement authentication
    and authorization. For each request, the user information is sent in the request
    header as a token. Then, the API, using ASP.NET Core 9 middleware, contextualizes
    the request with the user’s information, allowing, or not, an action to be performed.
    Each request is independent, and the state is obtained during the request cycle
    of the request.
  prefs: []
  type: TYPE_NORMAL
- en: This is an important feature that allows applications to be ableto scale dynamically
    , such as the execution of multiple instances of the same application in a Docker
    container.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the example shown in *Figure 11* *.11* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – Stateless application](img/B21788_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – Stateless application
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram presented in *Figure 11* *.11* illustrates how an application performs
    several stateless processes (using container instances) to deal with requests.
    The following is a brief description of each component of the diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User** : The user makes an API request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API Gateway** : The API gateway receives the request and acts as a load balancer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load Balancer** : The load balancer distributes API requests to various instances
    of the container application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container Instances** : Several container instances process requests independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database** : Each container instance interacts with a shared database to
    process the request and recover or store the necessary data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Response Flow** : After requesting the request, each container instance sends
    the response back through the API gateway, which returns the final response to
    the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the processes factor, it is essential to understand the concept
    of port binding.
  prefs: []
  type: TYPE_NORMAL
- en: Port binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like the previous factor, here, each application should be mapped and made available
    at a specific address and via a specific port.
  prefs: []
  type: TYPE_NORMAL
- en: 'If each server has an address and URL, each server can be responsible for responding
    to multiple applications at the same time. To differentiate which application
    will respond to a particular request, you must map the port. Thus, **Service A**
    can be hosted on a server through port 4040, **Service B** through port 3030,
    and **Service C** through port 8080, as in *Figure 11* *.12* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Port binding](img/B21788_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – Port binding
  prefs: []
  type: TYPE_NORMAL
- en: When performing the applications developed in this book using the **dotnet run**
    command, we observed that a URL is provided in the format **http:// localhost:<port>**
    . The door may vary from environment to environment, and the application may define
    which door will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern even applies when adopting the container strategy using Docker,
    where we map the host and container doors, as shown in *Figure 11* *.13* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – Port binding for containers](img/B21788_11_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – Port binding for containers
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 11* *.13* , there are three instances of the same application, responding
    to different ports through the host. Despite being the same application, each
    container is performed in an isolated process. Having different instances of a
    container is a common scenario in applications that require scalability for the
    needs of competing requests from users, which is the theme of the next factor.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The cloud environment allows applications to deal with different needs in a
    dynamic way. The characteristic of elasticity not only enables software engineers
    to keep their applications working properly according to user needs but also allows
    insights that help optimize applications.
  prefs: []
  type: TYPE_NORMAL
- en: Each application hosted in an environment needs resources to run, whether memory,
    CPU, or storage. These metrics are of paramount importance to define the limits
    of the applications and determine when it is necessary to scale.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, the use of techniques with cargo and monitoring tests should
    be a constant part of this continuous application flow, directing decisions that
    are based on concrete data.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is a need for scalability, we must define whether the strategy will
    be horizontal or vertical, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – Vertical and horizontal scalability](img/B21788_11_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – Vertical and horizontal scalability
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, there are two types of scalability:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertical scalability** : This is applied when adding more features to a server,
    such as memory, CPU, or storage, to support application processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Horizontal scalability** : Horizontal scalability involves the creation of
    new instances of servers, such as clusters. In this approach, processing is staggered
    between servers to support load demand through a load balancer. Horizontal scalability
    is a strategy widely used by orchestrators such as Kubernetes to create different
    instances of an application container to support constant user requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the points mentioned, each application, in its context, may depend
    on different types of simultaneous processing, which can be divided into background
    processes. Perhaps your application includes the asynchronous processing of an
    HTTP request and at the same time information is generated that must be processed
    in the background because it is a long-term execution. Therefore, its architecture
    can provide a web application for HTTP processing and another application that
    works with a worker, capable of processing long-term requests in the background.
    In conjunction with this strategy, the web application and the processes in the
    background, following the characteristics of the twelve-factor application, can
    be scaled vertically and/or horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will understand disposability.
  prefs: []
  type: TYPE_NORMAL
- en: Disposability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The principle of disposability emphasizes the importance of maximizing the robustness
    of an application, including fast startup and graceful closure, allowing the application
    to deal with rapid changes of scale, deployment, and code with no impact on user
    experience or system stability.
  prefs: []
  type: TYPE_NORMAL
- en: Fast startup times enable quick outages and recoveries, while graceful shutdowns
    ensure that ongoing requests are completed and resources are released correctly
    before application interruption.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B21788_10.xhtml#_idTextAnchor162) , when learning about the
    principles of Docker, we used a multi-stage build, with the aim of generating
    an optimized container image, which supports the rapid boot of the container if
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the principle of disposability helps maintain system resilience and
    reliability, allowing applications to better resist hardware failures, producing
    dynamic cloud environments where instances can be created and destroyed frequently.
  prefs: []
  type: TYPE_NORMAL
- en: 'See *Figure 11* *.15* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15 – Disposability example](img/B21788_11_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.15 – Disposability example
  prefs: []
  type: TYPE_NORMAL
- en: The diagram presented shows how applications should deal with quick startup
    and graceful startup processes to maintain robustness and reliability in a native
    cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following points, we can see the details of each item mentioned in the
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User** : The user makes a request for load balancing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load Balancer** : The load balancer distributes input requests to the available
    container instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scaling** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**New Container Instance - Starting Up** : Upon scaleout, a new container instance
    is created. The application starts up quickly, making the instance ready to handle
    requests in minimal time.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The load balancer begins to distribute requests to this new instance once it
    is ready.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shutdown** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Old Container Instance** : When scaling in or deploying a new version, the
    load balancer stops sending new requests to the old container instance.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graceful Shutdown** : The old instance completes any in-progress requests
    before shutting down, ensuring no request is abruptly terminated.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terminated** **Instance** : After completing all requests and releasing resources,
    the old instance is terminated.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In ASP.NET Core 9, you can implement graceful shutdown by setting up the hosting
    and handling of cancellation tokens to ensure that continuous requests are completed
    before application shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of code in a **Program.cs** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, the **app.Services.GetService<IHostApplicationLifetime>()**
    service was configured to deal with application stop events.
  prefs: []
  type: TYPE_NORMAL
- en: The **host.ApplicationStopping.Register** method allows you to register a callback
    that will be invoked when the application is stops.
  prefs: []
  type: TYPE_NORMAL
- en: In a registered call return, you can perform the necessary cleaning tasks, such
    as registration shutdown events, release of resources, and filling in ongoing
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: By following this approach, you can ensure that your app is gracefully stopped,
    keeping robustness and reliability. In addition, it is also important that we
    have consistency at the level of applications and environments, as we will understand
    when looking at the next factor, dev/prod parity.
  prefs: []
  type: TYPE_NORMAL
- en: Dev/prod parity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For years one of the most quoted phrases by developers was:'
  prefs: []
  type: TYPE_NORMAL
- en: It works on my machine!
  prefs: []
  type: TYPE_NORMAL
- en: In a way, this statement is true. Applications may behave differently in different
    execution environments. There are numerous variables that can contribute to malfunctions,
    such as the amount of CPU, memory, storage, or even access permissions to resources
    and dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: To minimize problems related to the environment, there must be as much compatibility
    as possible between each server.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why it’s important for teams to work with technologies for creating infrastructure
    as code, such as Terraform and Bicep, which, in addition to providing agility,
    improve management, governance, compliance, and security.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11* *.16* demonstrates this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16 – Dev/prod parity](img/B21788_11_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.16 – Dev/prod parity
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11* *.16* demonstrates a flow in a development process that involves
    the delivery of applications in an automated manner and the automation of the
    creation of infrastructure environments through an IaC approach, ensuring that
    all environments are similar.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to infrastructure, as we have already learned, the container strategy
    also allows containerized applications to run in different types of environments.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s talk about the logs factor, which goes beyond just recording application
    events in a file.
  prefs: []
  type: TYPE_NORMAL
- en: Logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a long time, logs were treated purely as records of events during the application
    execution flow, being recorded, in most cases, in text files, which were only
    accessed when there was a need to correct issues.
  prefs: []
  type: TYPE_NORMAL
- en: However, in a cloud environment, writing logs to files can pose some challenges
    for teams working on applications that are constantly changing.
  prefs: []
  type: TYPE_NORMAL
- en: The logs factor determines that this type of information should be treated as
    streams of events, not managed by files but maintained by specific monitoring-related
    environments, such as **Elasticsearch** , **Logstash** , **Azure Monitor** , and
    **Datadog** , or open source solutions such as **Prometheus** and **Grafana**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Thus, each flow of events generated through applications can provide important
    information about the execution flow of a given request, generate trend graphs,
    or even monitor in real time how the application behaves in relation to demand.
  prefs: []
  type: TYPE_NORMAL
- en: The data generated by log collection plays a fundamental role in decision-making,
    allowing teams to act proactively, optimize resources, define limits for automatic
    scaling, and, of course, support issue corrections.
  prefs: []
  type: TYPE_NORMAL
- en: There are several solutions on the market that support the event streaming management
    model, including paid and open source solutions. Many of these solutions are referenced
    in the CNCF landscape.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing the logs factor in our applications, we must take into account
    that telemetry and log information must be collected in a transparent manner;
    however, managing this information is not part of the application context.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, each logging and metrics solution has different collection methods,
    which creates a dependency on SDKs in the applications that are necessary to connect
    to the collection tools. This dependency can be a disadvantage if there is any
    need to change the log instrumentation tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to isolate mechanisms and dependencies. To help with this task,
    there are options such as **OpenTelemetry** , which offers a vendor-independent
    approach and allows collaboration and delivery of logs and metrics to be distributed
    across several monitoring services, avoiding greater coupling between applications,
    as shown in *Figure 11* *.17* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17 – Isolating a log collector mechanism with OpenTelemetry](img/B21788_11_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.17 – Isolating a log collector mechanism with OpenTelemetry
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about OpenTelemetry
  prefs: []
  type: TYPE_NORMAL
- en: OpenTelemetry is an open source observability framework for cloud-native software
    maintained by CNCF that provides a standardized way to collect, process, and export
    telemetry data such as traces, metrics, and logs from applications. OpenTelemetry
    provides some SDKs that abstract the collection of data from the application and
    distribute them into different log management tools. For more details, visit [https://opentelemetry.io/docs/](https://opentelemetry.io/docs/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Log collection is an important and strategic task in cloud-native applications
    and, as mentioned previously, allows teams to gain insights into the execution
    flow of application processes and supports bug fixes in applications. Associated
    with the logs strategy, strategies for sending alerts for nonconformities, exceptions,
    and the misbehavior of applications can be included, giving teams the possibility
    to act proactively.
  prefs: []
  type: TYPE_NORMAL
- en: Logs are also essential in architecture strategies based on events and microservices
    where there is the distributed processing of information. Through logs, it is
    possible to map the entire execution flow, if there is a need for auditing, optimization,
    and bug fixing.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that when working with cloud-native solutions, we isolate responsibilities,
    ensuring that each part of a solution is decoupled, giving teams flexibility,
    improved maintenance, and better security, among other aspects. The admin process
    factor also plays into this.
  prefs: []
  type: TYPE_NORMAL
- en: Admin process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When talking about the twelve factors, we most often mention the contextualization
    of the application domain, ensuring that it is built and delivered independently,
    with as little coupling as possible.
  prefs: []
  type: TYPE_NORMAL
- en: However, even in this scenario, the complexity of the application implies interactions
    with administrative tasks, such as performing database migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Although the database is part of the solution that makes up the application,
    tasks such as migrations and scripts for seeding basic information, among other
    types of administrative tasks, are not the responsibility of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The admin process factor suggests that administrative tasks must be carried
    out in isolation from applications, in a single process, and that it must be possible
    to monitor such changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Processes such as CI/CD run outside the scope of the application. Thus, during
    the execution of a pipeline and CI, the execution of tasks, such as generating
    database migration scripts, for example, can be performed, and these scripts are
    shared with CD pipelines, which may have different tasks required to apply the
    changes, as shown in *Figure 11* *.18* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18 – Example of the admin process implementation](img/B21788_11_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.18 – Example of the admin process implementation
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11* *.18* demonstrates a pipeline flow whereby, through the CD process,
    two distinct tasks are executed so that the application can be prepared for its
    correct execution in an environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Performing one-time administrative processes helps maintain the application
    state and ensures that any changes made during these tasks are immediately reflected
    in the live environment, reducing discrepancies and potential errors.
  prefs: []
  type: TYPE_NORMAL
- en: The admin process factor plays an important role in the application life cycle,
    as do the other factors proposed in the twelve-factor app methodology.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of the twelve-factor app methodology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed in previous topics, the principles described in the twelve-factor
    app methodology were designed to help developers create modern, scalable, and
    maintainable applications, reinforcing the cloud-native mindset necessary for
    applications that deliver constant value.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the principles are already present in the software engineer’s daily
    life; others open our minds to different perspectives and possibilities. However,
    we can note that the 12 principles are connected and, furthermore, are closely
    aligned with the main characteristics of cloud-native computing, such as microservices
    architecture, containerization, and CI/CD.
  prefs: []
  type: TYPE_NORMAL
- en: Using the methodology proposed by the twelve-factor app methodology, together
    with the other approaches presented in this chapter, such as the CAF, WAF, and
    projects available at CNCF, is a great model of best practices for any software
    engineer.
  prefs: []
  type: TYPE_NORMAL
- en: The concepts and capabilities provided by ASP.NET Core 9 easily allow such principles
    to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about concepts related to cloud architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding cloud architecture principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern cloud architectures are the foundation of scalable, resilient, and highly
    available applications. In this chapter, we have learned about several principles
    and tools necessary for software engineers to combine the development of solutions
    in ASP.NET Core 9 and fully leverage the benefits of cloud environments such as
    Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: The availability of resources in a cloud environment is not enough to deliver
    the quality and experience needed by users in such a demanding market today.
  prefs: []
  type: TYPE_NORMAL
- en: Each stage of the development flow helps organizations provide applications
    and services that meet users’ needs, in addition to enhancing companies’ return
    on investment and, of course, making users increasingly loyal to the solutions
    developed.
  prefs: []
  type: TYPE_NORMAL
- en: In this context, we must go beyond the boundaries of source code and layered
    definitions, and think about strategies that allow applications to deal with users’
    demands and needs. Therefore, it is important to adapt to the architectural concepts
    available in cloud-native applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s understand some of these architectural principles and how they can enhance
    applications developed in ASP.NET Core 9.
  prefs: []
  type: TYPE_NORMAL
- en: Working with modern design architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As software engineers, we are used to dealing with the implementation of code
    that is based on best practices and architectural styles such as Clean Code, hexagonal
    architecture, and design patterns, among other approaches.
  prefs: []
  type: TYPE_NORMAL
- en: By developing using a cloud-native approach, we not only add great possibilities
    to applications but also add other challenges, such as those mentioned in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Software engineers must go beyond writing code and explore a world of different
    variables and approaches, such as DevOps, infrastructure, network, resilience,
    availability, agility, security, cost, and other aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Organizations have shifted their focus to emphasize not only the importance
    of user interfaces such as forms and screens in business contexts and strategies
    but also the critical need for processing large volumes of data, providing services
    such as APIs, implementing artificial intelligence, and facilitating seamless
    integrations between diverse systems.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with large demands for data requests, ingestion, and analysis is an
    important feature for organizations to consider.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, some modern architectural styles allow organizations to get the
    best out of cloud environments and at the same time bring great robustness to
    the business.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine what an online store application would be like during a promotional
    event such as Black Friday that did not have the ability to adapt to user demands
    and deal with growing purchase requests to a payment gateway. If there were a
    bug in that virtual store application’s payment flow, what would be the company’s
    loss if the system was inactive for five minutes?
  prefs: []
  type: TYPE_NORMAL
- en: Certainly, the consequences would be bad. Therefore, there is a need to have
    the ability to deal with asynchronous processing and work with event-based architectural
    styles.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven architectures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Event-driven architectures allow applications to process information asynchronously,
    enabling real-time reactions based on events or state changes. They also enable
    better consistency for the processing of important business flows, such as payment
    processing for an online store. Another powerful feature of event-driven architecture
    is the ability to decouple components, generating independence and improving the
    maintenance and evolution of applications. ASP.NET Core 9 can be integrated with
    event-driven systems to create scalable and resilient applications. Let’s look
    at the example illustrated in *Figure 11* *.19* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.19 – Event-driven architecture example](img/B21788_11_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.19 – Event-driven architecture example
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the following flow is executed as an event-driven architecture
    implementation approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event Producer** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Order Service** : The order service acts as the event producer. When an order
    is created, it publishes an order-created event.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event Broker** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Event Grid** : Azure Event Grid acts as the event broker. It receives
    the event from the order service and distributes it to the subscribed consumers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event Consumers** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inventory Service** : The inventory service consumes the order-created event
    and updates the inventory accordingly.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Notification Service** : The notification service consumes the event to send
    a notification to the user about the order creation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Billing Service** : The billing service consumes the event to process the
    billing for the order.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The example of architecture, combined with other techniques such as scalability,
    further improves the quality of solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some event-driven architecture strategies must be considered according to the
    application requirements, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event source** : The event source works like a trace, capturing all state
    changes as they are executed sequentially. This approach favors the complete traceability
    of the entire execution chain, in addition to providing replay of executed events.
    ASP.NET Core 9 easily integrates with technologies such as Azure Event Hubs and
    Apache Kafka to implement event sourcing, as in the example shown in *Figure 11*
    *.20* :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.20 – Event source example](img/B21788_11_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.20 – Event source example
  prefs: []
  type: TYPE_NORMAL
- en: '**Command Query Responsibility Segregation (CQRS)** : CQRS separates the read
    and write operations of an application. This approach is very powerful in contexts
    where the flow of persistence or writing of information, called commands (writes),
    is independent of the flow of queries (reads) . *Figure 11* *.21* illustrates
    the use of CQRS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.21 – CQRS in ASP.NET Core 9](img/B21788_11_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.21 – CQRS in ASP.NET Core 9
  prefs: []
  type: TYPE_NORMAL
- en: '**Message brokers** : Message brokers facilitate communication between decoupled
    services by sending and receiving messages. They ensure that messages are delivered
    reliably and allow services to scale independently. A great example of this approach
    is payment processing in an online store. Upon receiving a payment request, the
    application delivers a message to a broker. This message is handled by one or
    more applications with the aim of communicating with payment gateways, among other
    services. If there is a problem with the broker on the server, the messages are
    persisted in a queue called a dead-letter queue. Therefore, when the broker resource
    re-establishes its operation, unprocessed messages will re-enter the queue, ensuring
    that applications can process them. ASP.NET Core 9 applications can integrate
    with message brokers such as Azure Service Bus or RabbitMQ to handle asynchronous
    processing and inter-service communication, as in *Figure 11* *.22* :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.22 – Message broker with a dead-letter queue](img/B21788_11_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.22 – Message broker with a dead-letter queue
  prefs: []
  type: TYPE_NORMAL
- en: Dead-Letter queue
  prefs: []
  type: TYPE_NORMAL
- en: 'A **dead-letter queue** ( **DLQ** ) is a specialized message queue used to
    store messages that cannot be processed due to some server or broker failure.
    Messages are kept isolated in the DLQ and retrieved for reprocessing after server
    problems are resolved. For more information, you can visit the Azure Service Bus
    DLQ documentation: [https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dead-letter-queues](https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dead-letter-queues)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and applying Event-Driven architecture approaches is essential
    for creating cloud-native solutions, prepared to deal with different types of
    user demands.
  prefs: []
  type: TYPE_NORMAL
- en: Based on event-driven architecture principles, another crucial architectural
    paradigm for cloud-native development is microservices, further enhancing application
    modularity and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices are an architectural style that fully supports the development
    of cloud-native solutions and, in essence, applies the best practices mentioned
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservices offer an approach that means an application has the following
    characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: It has a bounded implementation context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is autonomous and can therefore be deployed independently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is independent and scalable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not depend on a specific language, so there can be different microservices
    with different technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your process runs independently and can benefit from different types of communication
    protocols, such as HTTP/HTTPS and gRPC and message queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, microservices manage their own data independently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 11* *.23* illustrates a comparison between microservices and monoliths:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.23 – Monolithic versus microservices](img/B21788_11_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.23 – Monolithic versus microservices
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to keep in mind that microservices are not there to replace
    monolithic applications. Each approach has its respective advantages, disadvantages,
    and challenges. The choice of one approach over another will depend on the context
    and application requirements.
  prefs: []
  type: TYPE_NORMAL
- en: When analyzing *Figure 11* *.23* , we can see that in the monolithic approach,
    the application layer is responsible for managing all associated processes, represented
    by symbols, in addition to sharing access with all application states in the same
    database.
  prefs: []
  type: TYPE_NORMAL
- en: In the microservices approach, each service is contextualized in an independent
    application, managing the state in isolation, independently, but delivering the
    same business flow as in the monolithic approach.
  prefs: []
  type: TYPE_NORMAL
- en: There are several challenges associated with microservices, such as communication,
    transaction management, scalability, granularity, teams, distributed data, consistency,
    availability, reliability, and resilience.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices can even be developed using a container strategy in conjunction
    with ASP.NET Core 9, which provides a powerful and performant platform, bringing
    several benefits to software engineers.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, in addition to the development process, regardless of the architectural
    strategy used, at some point we must deliver solutions in a cloud environment.
    This process is very important and must cause as little impact as possible to
    users, which requires deployment strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Considering deployment strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deployment strategies are essential in cloud-native development, enabling applications
    to be delivered with the least possible impact on users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cloud environments and other technologies support different deployment strategies.
    The following points mention the most common strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blue-green deployment** : Blue-green deployment is based on the use of two
    identical environments: blue (current production) and green (new version). New
    versions of an application are deployed in the green environment and, after carrying
    out validations, a swap is performed; that is, the traffic goes from blue to green.
    In Azure, this strategy can be implemented by configuring separate slots in Azure
    App Service. Through deployment slots, it is possible to carry out deployments
    in a secure manner, and if the new version has any errors, even after validation,
    you can simply run the swap again for the previous version to be made available.
    Azure App Service implements load balancing and directs user requests to avoid
    losses, as demonstrated in *Figure 11* *.24* :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.24 – Blue-green deployment with Azure App Service](img/B21788_11_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.24 – Blue-green deployment with Azure App Service
  prefs: []
  type: TYPE_NORMAL
- en: '**Canary deployment** : Canary deployment is a variation of blue-green deployment
    that gradually introduces the new version to a small subset of users before rolling
    it out to the entire user base. Microsoft Azure provides traffic management tools,
    such as Azure Traffic Manager, to direct some traffic to the new version while
    monitoring its performance, as illustrated in *Figure 11* *.25* :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.25 – Canary deployment with Azure Traffic Manager](img/B21788_11_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.25 – Canary deployment with Azure Traffic Manager
  prefs: []
  type: TYPE_NORMAL
- en: The blue-green and canary deployment strategies significantly improve the reliability,
    flexibility, and security of the deployment process, minimizing impacts to users,
    in addition to allowing the restoration of the last stable environment in an agile
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: The combination of these strategies, tools, and modern architectural models
    strengthens the mindset needed for cloud-native solutions.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 9 is a platform that is prepared for different contexts and challenges
    and offers powerful solutions in a cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: As a software engineer, it is important to consider the approaches and techniques
    mentioned in this book to take your solutions to a higher level.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed various resources, tools, strategies, and architectural
    approaches with the aim of developing a mindset focused on cloud-native solutions.
    We learned about the different layers of services offered by cloud environments,
    and we learned about CNCF and the CNCF landscape, which details excellent open
    source projects that implement cloud concepts and best practices. We also learned
    about the principles of the twelve-factor app, the CAF, and the WAF, and we discussed
    the principles of modern cloud architectures and value delivery strategies. The
    combination of all the content available in this chapter, together with the ASP.NET
    Core 9 platform, will enable any software engineer to go beyond code and deliver
    high-value solutions. It all starts with *Hello World* .
  prefs: []
  type: TYPE_NORMAL
