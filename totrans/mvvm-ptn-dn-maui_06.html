<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer053">
<h1 class="chapter-number" id="_idParaDest-100"><a id="_idTextAnchor100"/>6</h1>
<h1 id="_idParaDest-101"><a id="_idTextAnchor101"/>Working with Collections</h1>
<p>Collections<a id="_idIndexMarker417"/> are a fundamental part of nearly every application, allowing us to manage and organize groups of related objects. In this chapter, we’ll explore the power of collections in the context of the MVVM design pattern, offering you the tools and knowledge to efficiently work with data in your .NET <span class="No-Break">MAUI applications.</span></p>
<p>Up until now, our focus has primarily been on binding single values, such as titles, ratings, and commands. However, with the introduction of collections, we can take our applications to the next level. Collections empower us to represent groups of items, whether it be a collection of recipes, lists of ingredients, or arrays of user ratings. By harnessing the capabilities of collections, we can create dynamic, data-driven UIs that provide enhanced <span class="No-Break">user experiences.</span></p>
<p>This chapter is structured into three <span class="No-Break">key sections:</span></p>
<ul>
<li><span class="No-Break">Using </span><span class="No-Break"><strong class="source-inline">BindableLayout</strong></span></li>
<li>The <span class="No-Break"><strong class="source-inline">ICollectionChanged</strong></span><span class="No-Break"> interface</span></li>
<li>Working <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">CollectionView</strong></span></li>
</ul>
<p>By the end of this chapter, you will have a strong understanding of working with collections in .NET MAUI, significantly expanding your capabilities in building rich, data-centric applications such as our <em class="italic">Recipes!</em> app. Let’s <span class="No-Break">dive in!</span></p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/>Technical requirements</h1>
<p>Throughout this chapter, we will be enhancing the functionality of the <em class="italic">Recipes!</em> app. The code base for this chapter and all the assets, including the additional classes and code required to cover the topics in this chapter effectively, can be found on GitHub at<a id="_idTextAnchor103"/><a id="_idTextAnchor104"/> <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter06">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter06</a>. The starting point for this chapter is provided in the <strong class="source-inline">Start</strong> folder, which includes the necessary classes and code that have been added specifically for this chapter. The code in the <strong class="source-inline">Start</strong> folder serves as the starting point to follow along with this chapter’s content, building upon the foundation we established in the previous chapters. The completed code, which includes all the code we have written throughout this chapter, can be found in the <strong class="source-inline">Finish</strong> folder for reference <span class="No-Break">and comparison.</span></p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor105"/>Using BindableLayout</h1>
<p>The <strong class="source-inline">BindableLayout</strong> class<a id="_idIndexMarker418"/> is a static class that provides <em class="italic">attached properties</em> for binding collections to layout containers. An attached property is a concept that allows you to attach additional properties to existing elements or controls. These properties are not defined within the element itself but are provided by an external class. They enable you to extend the behavior and functionality of elements without modifying their underlying code. <strong class="source-inline">Grid.Row</strong> is probably one of the most commonly used attached properties in .NET MAUI. It can be applied to any UI element, allowing you to define the row position within a <strong class="source-inline">Grid</strong> layout. It is not a property of the UI element itself; instead, it is an attached property that enhances the flexibility and power of the <strong class="source-inline">Grid</strong> layout. As such, <strong class="source-inline">BindableLayout</strong> provides a set of attached properties that can be used to bind collections of data to layout containers, such as <strong class="source-inline">VerticalStackLayout</strong> or <strong class="source-inline">Grid</strong>. You can leverage its attached properties to effortlessly bind and display dynamic collections <span class="No-Break">of data.</span></p>
<p>Although the <strong class="source-inline">BindableLayout</strong> class’s attached properties can be added to any layout that derives from the <strong class="source-inline">Layout</strong> class, it is commonly used with layouts such as <strong class="source-inline">VerticalStackLayout</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">HorizontalStackLayout</strong></span><span class="No-Break">.</span></p>
<p class="callout-heading">Note</p>
<p class="callout"><strong class="source-inline">BindableLayout</strong> is a <a id="_idIndexMarker419"/>lightweight and straightforward solution for displaying collections of data. It works great for scenarios with a limited number of items, offering simplicity and ease <span class="No-Break">of use.</span></p>
<p class="callout">However, it’s important to consider that <strong class="source-inline">BindableLayout</strong> generates UI elements for each item in the collection without built-in features such as virtualization or view recycling. This means that for large collections with many items, there may be performance implications and increased <span class="No-Break">memory usage.</span></p>
<p>Let’s have a look at how we can use <strong class="source-inline">BindableLayout</strong> to show a collection of data inside <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">VerticalStackLayout</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor106"/>What to show and how to show it</h2>
<p>Two essential attached <a id="_idIndexMarker420"/>properties of <strong class="source-inline">BindableLayout</strong> are <strong class="source-inline">ItemsSource</strong> and <strong class="source-inline">ItemTemplate</strong>. These two properties play a crucial role in defining what collection of data needs to be shown and how each data item should be visualized. The <strong class="source-inline">ItemsSource</strong> property is used to bind a collection of data, while the <strong class="source-inline">ItemTemplate</strong> property is used to define<a id="_idIndexMarker421"/> the <strong class="source-inline">DataTemplate</strong> for each item in <span class="No-Break">the collection.</span></p>
<p>Since a recipe is nothing without its list of ingredients, in the first example, we are going to display the list of ingredients on <strong class="source-inline">RecipeDetailPage</strong>. However, before we dive into how to effectively use <strong class="source-inline">BindableLayout</strong>, let’s first discuss <strong class="source-inline">RecipeIngredientViewModel</strong>, which is used to hold the information <span class="No-Break">of ingredients.</span></p>
<h3>Defining ingredients</h3>
<p>The <strong class="source-inline">RecipeIngredientViewModel</strong> class<a id="_idIndexMarker422"/> represents an ingredient within <span class="No-Break">a recipe.</span></p>
<p>It contains the name of the ingredient and information about the required quantity of the ingredient for a specific number of servings. The purpose of the <strong class="source-inline">DisplayAmount</strong> property is to dynamically adjust and display the appropriate quantity of ingredients for the desired number of servings. It allows the user to see the adjusted amount that aligns with their selected serving size, providing accurate ingredient measurements for their recipe preparation. Let’s have a look at its <span class="No-Break"><strong class="source-inline">UpdateServings</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
public void UpdateServings(int servings)
{
    var factor = servings / (double)baseServings;
    DisplayAmount = factor * baseAmount;
}</pre> <p>This <a id="_idIndexMarker423"/>method updates the <strong class="source-inline">DisplayAmount</strong> property based on the desired number of servings, allowing the user to see the appropriate quantity of the ingredient for their selected serving size. As the setter of the <strong class="source-inline">DisplayAmount</strong> property calls the <strong class="source-inline">PropertyChanged</strong> event when its value changes, we can bind this property to a UI element in our view to dynamically display the adjusted ingredient amount based on the selected number <span class="No-Break">of servings.</span></p>
<p>We can extend <strong class="source-inline">IngredientsListViewModel</strong> with an additional property: <strong class="source-inline">Ingredients</strong>. This property is a list of <strong class="source-inline">RecipeIngredientViewModel</strong> objects that, for demo purposes, is assigned a hard-coded list of ingredients needed for making a <span class="No-Break">Caesar salad.</span></p>
<p>Finally, the <strong class="source-inline">NumberOfServings</strong> property is updated. The following code block shows how the <strong class="source-inline">UpdateServings</strong> method on each of the ingredients is called when the value of the <strong class="source-inline">NumberOfServings</strong> property <span class="No-Break">is changed:</span></p>
<pre class="source-code">
public int NumberOfServings
{
    get =&gt; _numberOfServings;
    set
    {
        if (SetProperty(ref _numberOfServings, value))
        {
            Ingredients.ForEach(
                i =&gt; i.UpdateServings(value));
        }
    }
}</pre> <p>When updating <strong class="source-inline">NumberOfServings</strong>, the <strong class="source-inline">DisplayAmount</strong> property of each ingredient is updated as well, by calling the <span class="No-Break"><strong class="source-inline">UpdateServings</strong></span><span class="No-Break"> method.</span></p>
<p>With all <a id="_idIndexMarker424"/>of this in place, we can finally move over to XAML and see how we can bind this collection of <strong class="source-inline">RecipeIngredientViewModels</strong> to a <strong class="source-inline">VerticalStackLayout</strong> while using the attached properties <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">BindableLayout</strong></span><span class="No-Break">.</span></p>
<h3>Showing ingredients on the screen</h3>
<p>In the following steps, we’ll go <a id="_idIndexMarker425"/>through the process of setting up the XAML code to display the ingredients in a visually appealing manner. Note that everything we are about to do in XAML can also be done <span class="No-Break">in code:</span></p>
<ol>
<li>On <strong class="source-inline">RecipeDetailPage</strong>, right below the <strong class="source-inline">HorizontalStackLayout</strong>, which holds the <strong class="source-inline">Stepper</strong> property that controls the number of servings, we can add a new <strong class="source-inline">VerticalStackLayout</strong>. As shown in the following code block, we can use the <strong class="source-inline">ItemsSource</strong> property of the <strong class="source-inline">BindableLayout</strong> class to bind to the list <span class="No-Break">of ingredients:</span><pre class="source-code">
&lt;VerticalStackLayout
    Margin="0,10" Spacing="10"
    <strong class="bold">BindableLayout.ItemsSource="{Binding</strong>
<strong class="bold">      </strong><strong class="bold">IngredientsList.Ingredients}"</strong>&gt;
&lt;/VerticalStackLayout&gt;</pre></li> <li>Now, we need to define the UI elements that need to be rendered for each of the items in the bound collection. We can define this using the <strong class="source-inline">ItemTemplate</strong> property. This property needs a value of the <strong class="source-inline">DataTemplate</strong> class. It can be defined <span class="No-Break">like this:</span><pre class="source-code">
&lt;VerticalStackLayout ... &gt;
    <strong class="bold">&lt;BindableLayout.ItemTemplate&gt;</strong>
<strong class="bold">        &lt;DataTemplate x:DataType=</strong>
<strong class="bold">          "vms:RecipeIngredientViewModel" &gt;</strong>
<strong class="bold">        &lt;/DataTemplate&gt;</strong>
<strong class="bold">    &lt;/BindableLayout.ItemTemplate&gt;</strong>
&lt;/VerticalStackLayout&gt;</pre><p class="list-inset">Notice that on a <strong class="source-inline">DataTemplate</strong>, we can define <strong class="source-inline">x:DataType</strong> if we want to leverage compiled bindings, as we saw in <a href="B20941_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Data Binding in .</em><span class="No-Break"><em class="italic">NET MAUI</em></span><span class="No-Break">.</span></p></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">It’s very important to realize that the <strong class="source-inline">BindingContext</strong> of a <strong class="source-inline">DataTemplate</strong> is set to an individual item of the bound collection. Because the template is repeated for each item in the collection, UI elements named with <strong class="source-inline">x:Name</strong> in <strong class="source-inline">DataTemplate</strong> are inaccessible in the code behind. Their name is confined to that template’s scope. However, the name can still be used for element binding within the <span class="No-Break">same </span><span class="No-Break"><strong class="source-inline">DataTemplate</strong></span><span class="No-Break">.</span></p>
<ol>
<li value="3">The <a id="_idIndexMarker426"/>following code snippet shows how we can define a <strong class="source-inline">DataTemplate</strong> for the ingredients. This is how we define how each of the ingredients needs to <span class="No-Break">be visualized:</span><pre class="source-code">
&lt;DataTemplate x:DataType=
  "vms:RecipeIngredientViewModel"&gt;
    <strong class="bold">&lt;HorizontalStackLayout Spacing="5"&gt;</strong>
<strong class="bold">        &lt;Label</strong>
<strong class="bold">            FontAttributes="Bold" FontSize="16"</strong>
<strong class="bold">            Text="{Binding IngredientName,</strong>
<strong class="bold">              StringFormat='{0}:', Mode=OneTime}"</strong>
<strong class="bold">            VerticalOptions="Center" /&gt;</strong>
<strong class="bold">        &lt;Label Text="{Binding DisplayAmount,</strong>
<strong class="bold">          </strong><strong class="bold">Mode=OneWay}" VerticalOptions="Center" /&gt;</strong>
<strong class="bold">        &lt;Label</strong>
<strong class="bold">            Text="{Binding Measurement, Mode=OneTime}"</strong>
<strong class="bold">            VerticalOptions="Center" /&gt;</strong>
<strong class="bold">    &lt;/HorizontalStackLayout&gt;</strong>
&lt;/DataTemplate&gt;</pre></li> </ol>
<p>For each <a id="_idIndexMarker427"/>ingredient, we want to render a <strong class="source-inline">HorizontalStackLayout</strong> containing a label showing the ingredient’s name, a label showing the <strong class="source-inline">DisplayAmount</strong>, and finally, a label showing the <strong class="source-inline">Measurement</strong>. <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.1</em> shows what it <span class="No-Break">looks like:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<img alt="Figure 6.1: The Ingredients list" height="444" src="image/B20941_06_01.jpg" width="387"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1: The Ingredients list</p>
<p>Notice that <strong class="source-inline">DisplayAmount</strong> is bound <strong class="source-inline">OneWay</strong>, meaning that when the <strong class="source-inline">PropertyChanged</strong> event for this property is triggered, the label’s <strong class="source-inline">Text</strong> property is updated accordingly. All the other properties can be bound <strong class="source-inline">OneTime</strong> as their values won’t change once <span class="No-Break">they’re displayed.</span></p>
<p class="callout-heading">Tip</p>
<p class="callout">In terms of performance, it’s worth noting that <strong class="source-inline">OneTime</strong> binding mode is generally more efficient than <strong class="source-inline">OneWay</strong> data binding. This is especially important when binding collections of data! <strong class="source-inline">OneTime</strong> binding establishes the binding once and does not track subsequent changes to the source property. Therefore, it’s advisable to use <strong class="source-inline">OneTime</strong> binding wherever possible to optimize performance and reduce unnecessary <span class="No-Break">UI updates.</span></p>
<p>A <strong class="source-inline">DataTemplate </strong>can also<a id="_idIndexMarker428"/> be defined in a resource dictionary. This allows <strong class="source-inline">DataTemplate</strong>s to be reused, which can be especially convenient when showing the same kind of data in different parts of your app. By defining the template once in <strong class="source-inline">Application.Resources</strong> (in <strong class="source-inline">App.xaml</strong>), for example, it can be reused throughout the app. Then, we can use the <strong class="source-inline">StaticResource</strong> markup extension to bind a particular <strong class="source-inline">DataTemplate</strong> to the <strong class="source-inline">BindableLayout</strong> <strong class="source-inline">ItemTemplate</strong> property using the key that was defined in the resource dictionary. The following code block shows how to add a <strong class="source-inline">DataTemplate</strong> to the page’s resources and use it later on as the <strong class="source-inline">ItemTemplate</strong> of the <strong class="source-inline">VerticalStackLayout</strong> showing <span class="No-Break">the ingredients:</span></p>
<pre class="source-code">
<strong class="bold">&lt;ContentPage.Resources&gt;</strong>
    <strong class="bold">&lt;DataTemplate x:Key="recipeIngredientTemplate"</strong>
<strong class="bold">              x:DataType="vms:RecipeIngredientViewModel"&gt;</strong>
        ...
    <strong class="bold">&lt;/DataTemplate&gt;</strong>
<strong class="bold">&lt;/ContentPage.Resources&gt;</strong>
...
    &lt;VerticalStackLayout
        Margin="0,10"
        BindableLayout.ItemsSource="{Binding IngredientsList.Ingredients}"
        <strong class="bold">BindableLayout.ItemTemplate="{StaticResource</strong>
<strong class="bold">          recipeIngredientTemplate}"</strong>
        Spacing="10"/&gt;</pre> <p>In the previous code snippet, a <strong class="source-inline">DataTemplate</strong> is defined within the <strong class="source-inline">ContentPage.Resources</strong> section and is assigned the <strong class="source-inline">"recipeIngredientTemplate"</strong> key. Later, this template is used in the <strong class="source-inline">VerticalStackLayout</strong> by us referencing it through the <strong class="source-inline">StaticResource</strong> markup extension, using the <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">recipeIngredientTemplate"</strong></span><span class="No-Break"> key.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">In .NET MAUI, if you bind a collection without assigning a specific <strong class="source-inline">DataTemplate</strong>, the framework automatically invokes the <strong class="source-inline">ToString</strong> method of each object in the collection. The returned string value is what will be displayed on <span class="No-Break">the screen.</span></p>
<p>With all of this <a id="_idIndexMarker429"/>in place, our app now shows a list of ingredients on the recipe’s detail page, where each ingredient is rendered using the <span class="No-Break">defined </span><span class="No-Break"><strong class="source-inline">ItemTemplate</strong></span><span class="No-Break">.</span></p>
<p>But what if not all items in a particular collection should be rendered the same way? Let’s see how we can choose a <strong class="source-inline">DataTemplate</strong> dynamically <span class="No-Break">at runtime.</span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor107"/>Dynamically choosing a DataTemplate at runtime</h2>
<p>While ingredients are <a id="_idIndexMarker430"/>essential to a recipe app, not much can be done with the ingredients without a comprehensive set of cooking instructions. So, let’s bring these instructions to life within our app! In addition to the essential steps, a list of instructions may also include valuable cooking tips and additional information to enhance the cooking experience. Let’s explore how we can incorporate these cooking instructions, along with any accompanying notes, into our <span class="No-Break"><em class="italic">Recipes!</em></span><span class="No-Break"> app.</span></p>
<h3>Defining cooking instructions and notes</h3>
<p>In our app, we <a id="_idIndexMarker431"/>use <strong class="source-inline">InstructionViewModel</strong> and <strong class="source-inline">NoteViewModel</strong> for cooking instructions and notes, respectively. <strong class="source-inline">InstructionViewModel</strong> has <strong class="source-inline">Index</strong> and <strong class="source-inline">Description</strong> properties, while <strong class="source-inline">NoteViewModel</strong> has just a <strong class="source-inline">Note</strong> property. Both are grouped under a common parent, <strong class="source-inline">InstructionBaseViewModel</strong>, and stored in a list called <strong class="source-inline">Instructions</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">RecipeDetailViewModel</strong></span><span class="No-Break">.</span></p>
<p>For now, this list is initialized with some cooking instructions and a tip for creating a <span class="No-Break">Caesar salad.</span></p>
<p>If we want to<a id="_idIndexMarker432"/> show this list, which contains both instructions and notes, on the screen, we would need a mechanism that would allow us to use a different <strong class="source-inline">ItemTemplate</strong>, depending on the type. Let’s see how a <strong class="source-inline">DataTemplateSelector</strong> can <span class="No-Break">achieve this!</span></p>
<h3>Creating a DataTemplateSelector</h3>
<p>With a <strong class="source-inline">DataTemplateSelector</strong>, we can<a id="_idIndexMarker433"/> write code that determines what <strong class="source-inline">DataTemplate</strong> to use at runtime. Writing a <strong class="source-inline">DataTemplateSelector</strong> is pretty straightforward. Let’s have a look at how we can <span class="No-Break">build one:</span></p>
<ol>
<li>In the <strong class="bold">Solution Explorer</strong>, add a folder called <strong class="source-inline">TemplateSelectors</strong> by right-clicking the <strong class="bold">Recipes.Mobile</strong> project and selecting <strong class="bold">Add</strong> | <span class="No-Break"><strong class="bold">New Folder</strong></span><span class="No-Break">.</span></li>
<li>Next, right-click this newly added folder, select <strong class="bold">Add</strong> | <strong class="bold">Class…</strong>, and enter <strong class="source-inline">InstructionsDataTemplateSelector</strong> as <span class="No-Break">the name.</span></li>
<li>For our class to function as a <strong class="source-inline">DataTemplateSelector</strong>, it needs to inherit from <strong class="source-inline">Microsoft.Maui.Controls.DataTemplateSelector</strong>, as shown in the <span class="No-Break">following snippet:</span><pre class="source-code">
public class InstructionsDataTemplateSelector <strong class="bold">:</strong>
<strong class="bold">  DataTemplateSelector</strong>
{
    <strong class="bold">protected override DataTemplate</strong>
<strong class="bold">      OnSelectTemplate(object item, BindableObject</strong>
<strong class="bold">        container)</strong> { }
}</pre></li> </ol>
<p>Inheriting from the <strong class="source-inline">DataTemplateSelector</strong> class requires overriding the abstract <strong class="source-inline">OnSelectTemplate</strong> method. This method is invoked at runtime to select the appropriate <strong class="source-inline">DataTemplate</strong> and takes <span class="No-Break">two parameters:</span></p>
<ul>
<li><strong class="source-inline">item</strong> (of type <strong class="source-inline">object</strong>) is the object we want to display, such as a <strong class="source-inline">NoteViewModel</strong> or <strong class="source-inline">InstructionViewModel</strong> item in <span class="No-Break">our app</span></li>
<li><strong class="source-inline">container</strong> (of type <strong class="source-inline">BindableObject</strong>) refers to the layout element that holds the collection, such as <strong class="source-inline">VerticalStackLayout</strong> in <span class="No-Break">our example</span></li>
</ul>
<p>Using these parameters, the <strong class="source-inline">OnSelectTemplate</strong> method in a <strong class="source-inline">DataTemplateSelector</strong> assists you in selecting the appropriate <strong class="source-inline">DataTemplate</strong> for a given item. In our specific scenario, the method will determine the template based solely on the type of the <span class="No-Break">passed-in item.</span></p>
<p>Let’s introduce two properties to <strong class="source-inline">InstructionsDataTemplateSelector</strong>. These two properties, <strong class="source-inline">NoteTemplate</strong> and <strong class="source-inline">InstructionTemplate</strong>, dictate which <strong class="source-inline">DataTemplate</strong> the <strong class="source-inline">DataTemplateSelector</strong> should return based on the type of the passed-in item parameter. Specifically, if it is a <strong class="source-inline">NoteViewModel</strong>, the <strong class="source-inline">OnSelectTemplate</strong> method should return <strong class="source-inline">NoteTemplate</strong>. Conversely, if it’s an <strong class="source-inline">InstructionViewModel</strong>, <strong class="source-inline">InstructionTemplate</strong> will be returned. Let’s explore how to <span class="No-Break">accomplish this:</span></p>
<ol>
<li>Add the following properties <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">InstructionsDataTemplateSelector</strong></span><span class="No-Break">:</span><pre class="source-code">
public DataTemplate NoteTemplate { get; set; }
public DataTemplate InstructionTemplate { get; set; }</pre></li> <li>The following code block shows how we can implement the <strong class="source-inline">OnSelectTemplate</strong> method so that it checks the type of the given item and returns the<a id="_idIndexMarker434"/> <span class="No-Break">appropriate </span><span class="No-Break"><strong class="source-inline">DataTemplate</strong></span><span class="No-Break">:</span><pre class="source-code">
protected override DataTemplate OnSelectTemplate
  (object item, BindableObject container)
{
    if (item is InstructionViewModel)
        return InstructionTemplate;
    else if(item is NoteViewModel)
        return NoteTemplate;
    return null;
}</pre><p class="list-inset">If the given item isn’t an <strong class="source-inline">InstructionViewModel</strong> or <strong class="source-inline">NoteViewModel</strong> item, <strong class="source-inline">null</strong> is returned. As a result, the value returned by the object’s <strong class="source-inline">ToString</strong> method will be rendered, which is the same behavior when not providing <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">DataTemplateSelector</strong></span><span class="No-Break">.</span></p></li> </ol>
<p>That’s it <a id="_idIndexMarker435"/>for <strong class="source-inline">InstructionsDataTemplateSelector</strong>. Let’s see how we can use this <strong class="source-inline">DataTemplateSelector</strong> to show both instructions and notes in <span class="No-Break">the app.</span></p>
<h3>Showing instructions and notes on the screen</h3>
<p>Now that the <a id="_idIndexMarker436"/>data is in place as well as the <strong class="source-inline">DataTemplateSelector</strong> that we want to use, we need to do a few things in XAML to display the recipe’s instructions <span class="No-Break">and notes:</span></p>
<ol>
<li>Let’s start by thinking about how we want to represent a <strong class="source-inline">InstructionViewModel</strong> in the app. Here’s a template that we could add to the <strong class="source-inline">RecipeDetailPage’s</strong> resources for that <span class="No-Break">data type:</span><pre class="source-code">
&lt;ContentPage.Resources&gt;
...
    &lt;DataTemplate <strong class="bold">x:Key="instructionTemplate"</strong>
      x:DataType="vms:InstructionViewModel"&gt;
        &lt;VerticalStackLayout Spacing="10"&gt;
            &lt;Label FontSize="20" Text="{Binding Index,
             StringFormat='{0:D2}.', Mode=OneTime}" /&gt;
            &lt;Label Margin="10,0" Text="{Binding
              Description, Mode=OneTime}" /&gt;
        &lt;/VerticalStackLayout&gt;
    &lt;/DataTemplate&gt;
&lt;/ContentPage.Resources&gt;</pre><p class="list-inset">The <strong class="source-inline">DataTemplate</strong> for an <strong class="source-inline">InstructionViewModel</strong> defines how we want to visualize this type of item: showing the <strong class="source-inline">Index</strong> property with the <strong class="source-inline">Description</strong> <span class="No-Break">below it.</span></p><p class="list-inset">Note that we’ve given the <strong class="source-inline">DataTemplate</strong> a key (<strong class="source-inline">instructionTemplate</strong>) that we can use later on to reference this <span class="No-Break">specific template.</span></p></li> <li>Let’s add a <strong class="source-inline">DataTemplate</strong> for the <strong class="source-inline">NoteViewModel</strong> items as well. The following<a id="_idIndexMarker437"/> code block shows a <strong class="source-inline">DataTemplate</strong> for visualizing <span class="No-Break">such items:</span><pre class="source-code">
&lt;DataTemplate <strong class="bold">x:Key="noteTemplate"</strong> x:DataType=
  "vms:NoteViewModel"&gt;
    &lt;Grid Margin="20,0" ColumnDefinitions="35,*"&gt;
        &lt;Label
            FontFamily="MaterialIconsRegular"
            FontSize="20" Text="&amp;#xe873;"
            TextColor="LightSlateGray" /&gt;
        &lt;Label
            Grid.Column="1" FontAttributes="Italic"
            Text="{Binding Note, Mode=OneTime}"
            TextColor="LightSlateGray" /&gt;
    &lt;/Grid&gt;
&lt;/DataTemplate&gt;</pre><p class="list-inset">By using this <strong class="source-inline">DataTemplate</strong>, we can visualize notes by showing an icon –  for which we use the <strong class="source-inline">MaterialIconsRegular</strong> font – followed by the note itself. Both are in a specific color so that there is a clear distinction between notes and instructions. As before, we’ve given the <strong class="source-inline">DataTemplate</strong> a specific key (<strong class="source-inline">noteTemplate</strong>) so that we can reference it <span class="No-Break">later on.</span></p></li> <li>Next, let’s add an <strong class="source-inline">InstructionsDataTemplateSelector</strong> to <strong class="source-inline">RecipeDetailPage</strong>. Start by adding said <strong class="source-inline">DataTemplateSelector</strong>’s namespace as an XML namespace to the page, as <span class="No-Break">shown here:</span><pre class="source-code">
xmlns:selectors="clr-namespace:Recipes
  .Mobile.TemplateSelectors"</pre><p class="list-inset">Once this is in place, we can add an instance of the <strong class="source-inline">InstructionsDataTemplateSelector</strong> class to the page’s <strong class="source-inline">Resources</strong>, as <a id="_idIndexMarker438"/>shown in the <span class="No-Break">following snippet:</span></p><pre class="source-code">&lt;selectors:InstructionsDataTemplateSelector
    x:Key="instructionDataTemplateSelector"
    InstructionTemplate="{StaticResource
      instructionTemplate}"
    NoteTemplate="{StaticResource noteTemplate}" /&gt;</pre><p class="list-inset">The <strong class="source-inline">StaticResource</strong> markup extension is used to reference the two <strong class="source-inline">DataTemplate</strong>s that we created earlier to assign them to the respective properties of this <strong class="source-inline">InstructionsDataTemplateSelector</strong>. Just like we did with the individual <strong class="source-inline">DataTemplate</strong>, we’ve given this instance of the <strong class="source-inline">InstructionsDataTemplateSelector</strong> a key (<strong class="source-inline">instructionDataTemplateSelector</strong>) that we can use later on to <span class="No-Break">reference it.</span></p></li> <li>To display the list of instructions, we can add a <strong class="source-inline">VerticalStackLayout</strong> near the bottom of <strong class="source-inline">RecipeDetailPage</strong>. The following code snippet demonstrates <span class="No-Break">this setup:</span><pre class="source-code">
&lt;VerticalStackLayout Padding="10"&gt;
    &lt;Label FontAttributes="Italic,Bold"
        FontSize="16" Text="Instructions" /&gt;
    &lt;VerticalStackLayout
        Margin="0,10" Spacing="10"
<strong class="bold">        </strong><strong class="bold">BindableLayout.ItemsSource="{Binding</strong>
<strong class="bold">          Instructions}"</strong>
<strong class="bold">        BindableLayout.ItemTemplateSelector=</strong>
<strong class="bold">          "{StaticResource instruction</strong>
<strong class="bold">            DataTemplateSelector}"</strong>/&gt;
&lt;/VerticalStackLayout&gt;</pre><p class="list-inset">In this code snippet, we bound the <strong class="source-inline">Instructions</strong> property of our ViewModel to the <strong class="source-inline">BindableLayout</strong> <strong class="source-inline">ItemsSource</strong> property. Additionally, by<a id="_idIndexMarker439"/> using the <strong class="source-inline">StaticResource</strong> markup extension and the key we used in the resource dictionary for our <strong class="source-inline">DataTemplateSelector</strong>, we set the <strong class="source-inline">ItemTemplateSelector</strong> property. The result is shown in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer049">
<img alt="Figure 6.2: Showing instructions and notes" height="521" src="image/B20941_06_02.jpg" width="397"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2: Showing instructions and notes</p>
<p>With that, we’ve<a id="_idIndexMarker440"/> explored how to leverage <strong class="source-inline">DataTemplate</strong>s and a <strong class="source-inline">DataTemplateSelector</strong> to visualize instructions and notes within our <em class="italic">Recipes!</em> app. By defining separate <strong class="source-inline">DataTemplate</strong>s and using a <strong class="source-inline">DataTemplateSelector</strong>, we can dynamically choose the appropriate template for each item in the collection, providing a customized and intuitive display of cooking instructions and <span class="No-Break">additional notes.</span></p>
<p>Now that we have successfully implemented the visualization of instructions and notes, let’s move on to handling <span class="No-Break">empty collections.</span></p>
<h3>Handling empty collections</h3>
<p>Besides<a id="_idIndexMarker441"/> the <strong class="source-inline">ItemsSource</strong> and <strong class="source-inline">ItemTemplate</strong> properties, <strong class="source-inline">BindableLayout</strong> also has <strong class="source-inline">EmptyView</strong> and <strong class="source-inline">EmptyViewTemplate</strong> properties. These properties allow us to define what to show if the provided <strong class="source-inline">ItemsSource</strong> is empty <span class="No-Break">or null.</span></p>
<p>The <strong class="source-inline">EmptyView</strong> property can be a string value or a <strong class="source-inline">View</strong>. So, in its simplest form, we could add the following to a <strong class="source-inline">VerticalStackLayout</strong> to show the <span class="No-Break">shopping list:</span></p>
<pre class="source-code">
&lt;VerticalStackLayout
    <strong class="bold">BindableLayout.EmptyView="Nothing to see here"</strong>
    ... &gt;</pre> <p><strong class="source-inline">"Nothing to see here"</strong> is shown on the screen when the bound <strong class="source-inline">ItemSource</strong> contains <span class="No-Break">no items.</span></p>
<p>Or, if we want to have <a id="_idIndexMarker442"/>more control over the appearance of what is shown when the collection is empty, we could also do <span class="No-Break">the following:</span></p>
<pre class="source-code">
&lt;VerticalStackLayout
    ...&gt;
        <strong class="bold">&lt;BindableLayout.EmptyView&gt;</strong>
<strong class="bold">            &lt;Label Text="Nothing to see here"</strong>
<strong class="bold">                FontAttributes="Bold" /&gt;</strong>
<strong class="bold">        &lt;/BindableLayout.EmptyView&gt;</strong></pre> <p>Alternatively, with <strong class="source-inline">EmptyViewTemplate</strong>, we can specify a <strong class="source-inline">DataTemplate</strong> that needs to be shown when the bound collection is empty or null. This means that in this template, you can bind to values on the parent UI element or any other accessible context within the UI hierarchy. This flexibility enables you to create dynamic and context-aware empty views that can display relevant information or provide interactive elements based on the available <span class="No-Break">data context.</span></p>
<p>As we saw earlier, data binding and the <strong class="source-inline">INotifyPropertyChanged</strong> interface allow the UI to stay in sync with the data on ViewModels, ensuring automatic updates. However, when it comes to dynamically adding or removing items from collections, the binding engine alone will not automatically reflect these changes in the UI. To achieve this kind of behavior, we need to explore the <span class="No-Break"><strong class="source-inline">ICollectionChanged</strong></span><span class="No-Break"> interface.</span></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor108"/>The ICollectionChanged interface</h1>
<p>The <strong class="source-inline">ICollectionChanged</strong> interface<a id="_idIndexMarker443"/> provides a powerful mechanism for notifying the UI about changes in a collection itself, rather than on individual items within the collection. By implementing this interface, a collection can raise events that inform the binding engine and UI elements about structural changes, such as additions, removals, or modifications to the <span class="No-Break">collection itself.</span></p>
<p>While it is possible to assign an updated list of items to a property on your ViewModel and trigger the <strong class="source-inline">PropertyChanged</strong> event, dynamically changing a collection requires a more optimal approach. By utilizing a collection that implements the <strong class="source-inline">INotifyCollectionChanged</strong> interface, we can achieve more efficient rendering of the UI. Instead of needing to re-render the entire collection on the UI, the binding engine can perform updates in a more optimized manner, resulting in improved performance <span class="No-Break">and responsiveness.</span></p>
<p>The <strong class="source-inline">ICollectionChanged</strong> interface defines the <strong class="source-inline">CollectionChanged</strong> event, which is raised whenever the collection undergoes a structural change. This event provides detailed information about the type of change that occurred, such as whether an item was added, removed, or modified, and the position at which the change occurred. Let’s see what this means in terms of <span class="No-Break">binding modes.</span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor109"/>The ICollectionChanged interface and binding modes</h2>
<p>To use this interface as efficiently as possible, it’s very important to understand how different binding modes affect <span class="No-Break">this behavior.</span></p>
<h3>OneTime binding</h3>
<p>When using <strong class="source-inline">OneTime</strong> binding, the<a id="_idIndexMarker444"/> UI will perfectly update when items inside the collection change. However, there’s a caveat: if a new instance is assigned to the property holding the collection, this change won’t reflect in the UI. In such cases, instead of assigning a new instance, we need to clear the existing collection and add the new items to it. Importantly, the property setter should not trigger the <strong class="source-inline">NotifyPropertyChanged</strong> event as it’s unnecessary for <span class="No-Break"><strong class="source-inline">OneTime</strong></span><span class="No-Break"> binding.</span></p>
<h3>OneWay binding</h3>
<p><strong class="source-inline">OneWay</strong> binding<a id="_idIndexMarker445"/> might offer more flexibility, allowing you to replace the collection with a new instance and reflect this in the UI. In this mode, make sure the property setter calls the <strong class="source-inline">NotifyPropertyChanged</strong> event to update the UI. While <strong class="source-inline">OneWay</strong> binding allows for greater flexibility, replacing an entire collection can be resource-intensive, requiring the UI to re-render the collection. This is especially important to consider when dealing with large datasets. If only a few items change, modifying the existing collection is often more efficient than <span class="No-Break">replacing it.</span></p>
<p>By understanding these subtleties, you can make more informed decisions on what data binding mode <span class="No-Break">to use.</span></p>
<p>Let’s put this into action and add some functionality to the <em class="italic">Recipes!</em> app by leveraging the <span class="No-Break"><strong class="source-inline">ObservableCollection</strong></span><span class="No-Break"> class.</span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor110"/>Using the ObservableCollection</h2>
<p>The <strong class="source-inline">ObservableCollection</strong> class is a <a id="_idIndexMarker446"/>specialized collection class provided by .NET that implements the <strong class="source-inline">ICollectionChanged</strong> interface out of <span class="No-Break">the box.</span></p>
<p>Let’s enhance the functionality of our <em class="italic">Recipes!</em> app by introducing a <strong class="source-inline">Shopping List</strong> feature. We want to provide users with the ability to add ingredients from the list of recipe ingredients to a separate <strong class="source-inline">Shopping List</strong>. To achieve this, we will associate a button with each ingredient in the list. When the user taps the button, the corresponding ingredient will be added to an <strong class="source-inline">ObservableCollection</strong> named <strong class="source-inline">ShoppingList</strong>. As a result, the UI will be automatically updated each time an ingredient is added or removed from <span class="No-Break">the list:</span></p>
<ol>
<li>Let’s start by adding an additional property, <strong class="source-inline">ShoppingList</strong>, of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">Observable</strong></span><strong class="source-inline">
Collection&lt;RecipeIngredientViewModel&gt;</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">RecipeDetailViewModel</strong></span><span class="No-Break">:</span><pre class="source-code">
public ObservableCollection&lt;RecipeIngredientViewModel&gt;
ShoppingList { get; } = new();</pre><p class="list-inset">We are automatically assigning a new instance to this property, which makes perfect sense: the instance of this property will not change as we will be adding and removing items from the collection. As <strong class="source-inline">ObservableCollection</strong> implements the <strong class="source-inline">IObservableCollection</strong> interface, the UI will remain in sync as the <strong class="source-inline">CollectionChanged</strong> event will be triggered when we manipulate <span class="No-Break">the collection.</span></p></li> <li>Currently, we<a id="_idIndexMarker447"/> don’t have functionality for managing items in the <strong class="source-inline">ShoppingList</strong> collection. So, let’s add the following <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">RecipeDetailViewModel</strong></span><span class="No-Break">:</span><pre class="source-code">
public IRelayCommand AddToShoppingListCommand { get; }
public IRelayCommand RemoveFromShoppingListCommand 
{ get; }
private void AddToShoppingList(
  RecipeIngredientViewModel viewModel)
{
    if (ShoppingList.Contains(viewModel))
        return;
    ShoppingList.Add(viewModel);
}
private void RemoveFromShoppingList
  (RecipeIngredientViewModel viewModel)
{
    if (ShoppingList.Contains(viewModel))
        ShoppingList.Remove(viewModel);
}</pre><p class="list-inset">The <strong class="source-inline">AddToShoppingList</strong> method will be <a id="_idIndexMarker448"/>responsible for adding an instance of <strong class="source-inline">RecipeIngredientViewModel</strong> to the <strong class="source-inline">ShoppingList</strong> collection if the given ViewModel isn’t already in there. The <strong class="source-inline">RemoveFromShoppingList</strong> method, on the other hand, will remove the item <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">ShoppingList</strong></span><span class="No-Break">.</span></p><p class="list-inset">For both <a id="_idIndexMarker449"/>methods, we’ve also created two corresponding commands, which we need to instantiate in the constructor of <strong class="source-inline">RecipeDetailViewModel</strong>, as <span class="No-Break">shown here:</span></p><pre class="source-code">public RecipeDetailViewModel()
{
    ...
    AddToShoppingListCommand = new RelayCommand
      &lt;RecipeIngredientViewModel&gt;(AddToShoppingList);
    RemoveFromShoppingListCommand = new RelayCommand
      &lt;RecipeIngredientViewModel&gt;
         (RemoveFromShoppingList);
}</pre></li> <li>Next, add the following XAML to the <strong class="source-inline">VerticalStackLayout</strong> that shows the ingredients of <span class="No-Break">the recipe:</span><pre class="source-code">
&lt;VerticalStackLayout Padding="10"&gt;
    &lt;Label ...
        Text="Ingredients list" /&gt;
    ...
    &lt;VerticalStackLayout Margin="10,0" Padding="10"&gt;
        &lt;Label
            FontAttributes="Italic,Bold"
            FontSize="16" Text="Shopping list" /&gt;
        &lt;VerticalStackLayout
            Margin="0,10" Spacing="10"
            <strong class="bold">BindableLayout.ItemsSource="{Binding</strong>
<strong class="bold">              </strong><strong class="bold">ShoppingList, Mode=OneTime}"</strong>
<strong class="bold">            BindableLayout.EmptyView="Nothing added"</strong>&gt;
        &lt;/VerticalStackLayout&gt;
    &lt;/VerticalStackLayout&gt;
&lt;/VerticalStackLayout&gt;</pre><p class="list-inset">Below the list <a id="_idIndexMarker450"/>of ingredients, we’ve added a label with the text <strong class="source-inline">"Shopping list"</strong>, followed by another <strong class="source-inline">VerticalStackLayout</strong>. The <strong class="source-inline">ShoppingList</strong> property is bound to the <strong class="source-inline">BindableLayout.ItemsSource</strong> property. We’ve added an <strong class="source-inline">EmptyView</strong> property that will be shown when no items are on <span class="No-Break">the list.</span></p><p class="list-inset">The <strong class="source-inline">ItemTemplate</strong>, which will be rendered for each item in <strong class="source-inline">ShoppingList</strong>, will be added in a <span class="No-Break">few steps.</span></p></li> <li>Let’s add a <strong class="source-inline">Button</strong> to the <strong class="source-inline">ItemTemplate</strong> of the <strong class="source-inline">VerticalStackLayout</strong> showing the ingredients. The <strong class="source-inline">Button</strong>’s <strong class="source-inline">Command</strong> should be bound to the <strong class="source-inline">AddToShoppingListCommand</strong> on the <strong class="source-inline">RecipeDetailViewModel</strong> as <span class="No-Break">shown here:</span><pre class="source-code">
&lt;HorizontalStackLayout Spacing="5"&gt;
    <strong class="bold">&lt;Button</strong>
<strong class="bold">        Command="{Binding AddToShoppingListCommand,</strong>
<strong class="bold">          Source={RelativeSource AncestorType={x:Type</strong>
<strong class="bold">            vms:RecipeDetailViewModel}}}"</strong>
<strong class="bold">    CommandParameter="{Binding}"</strong>
<strong class="bold">    FontFamily="MaterialIconsRegular"</strong>
<strong class="bold">    Text="&amp;#xe854;" /&gt;</strong>
    &lt;Label
        FontAttributes="Bold"
        FontSize="16" VerticalOptions="Center"
        Text="{Binding IngredientName,
          StringFormat='{0}:'}" /&gt;
    ...
&lt;/HorizontalStackLayout&gt;</pre><p class="list-inset">The <strong class="source-inline">Button</strong>’s <strong class="source-inline">Command</strong> property is bound to the <strong class="source-inline">AddToShoppingListCommand</strong> on the <strong class="source-inline">RecipeDetailViewModel</strong>. As the <strong class="source-inline">Button</strong>’s <strong class="source-inline">BindingContext</strong> is the current <strong class="source-inline">RecipeIngredientViewModel</strong>, we need to use relative binding to point to the <strong class="source-inline">RecipeDetailViewModel</strong>. <strong class="source-inline">CommandParameter</strong> is data bound by just defining <strong class="source-inline">{ Binding }</strong>. This will bind it to the binding context of the UI element itself, which is the current <strong class="source-inline">RecipeIngredientViewModel</strong>. As a result, the <strong class="source-inline">RecipeIngredientViewModel</strong> instance is passed to the <strong class="source-inline">AddShoppingList</strong> method, allowing us to add it to the <span class="No-Break"><strong class="source-inline">ShoppingList</strong></span><span class="No-Break"> collection.</span></p></li> <li>Finally, we can <a id="_idIndexMarker451"/>define the <strong class="source-inline">ItemTemplate</strong> of the <strong class="source-inline">ShoppingList</strong> items. We can copy the <strong class="source-inline">DataTemplate</strong> of the <strong class="source-inline">"Ingredients list"</strong>. However, we need to update the <strong class="source-inline">Button</strong> <span class="No-Break">to this:</span><pre class="source-code">
<strong class="bold">&lt;Button</strong>
<strong class="bold">    Command="{Binding RemoveFromShoppingListCommand,</strong>
<strong class="bold">      Source={RelativeSource AncestorType={x:Type</strong>
<strong class="bold">        vms:RecipeDetailViewModel}}}"</strong>
<strong class="bold">    CommandParameter="{Binding}"</strong>
<strong class="bold">    FontFamily="MaterialIconsRegular"</strong>
<strong class="bold">    Text="&amp;#xe928;" /&gt;</strong></pre><p class="list-inset">This <strong class="source-inline">Button</strong> has a different icon and has its <strong class="source-inline">Command</strong> bound to <strong class="source-inline">RemoveFromShoppingListCommand</strong>, allowing the user to remove an ingredient again from <span class="No-Break">the list.</span></p></li> </ol>
<p>With everything in place, users <a id="_idIndexMarker452"/>can now add ingredients from <strong class="source-inline">"Ingredients list"</strong> to <strong class="source-inline">"Shopping list"</strong>, from which items can also be removed again. Here’s what it <span class="No-Break">looks like:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<img alt="Figure 6.3: Shopping list" height="340" src="image/B20941_06_03.jpg" width="379"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3: Shopping list</p>
<p>By using <strong class="source-inline">ObservableCollection</strong> – or any collection that implements <strong class="source-inline">IObservableCollection</strong> – it becomes very easy and efficient to keep a list of objects in sync with <span class="No-Break">the UI.</span></p>
<p class="callout-heading">Don’t overuse ObservableCollection</p>
<p class="callout">It is important to use <strong class="source-inline">ObservableCollection</strong> judiciously in your application. This specialized collection should be utilized when the collection itself dynamically changes, such as when items are added or removed, and the UI needs to reflect those changes. However, if the collection is fixed or assigned to a property in its entirety, there is no need to <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">ObservableCollection</strong></span><span class="No-Break">.</span></p>
<p>As we mentioned <a id="_idIndexMarker453"/>earlier, using <strong class="source-inline">BindableLayout</strong> is very easy to use and is perfect for showing small collections. For more advanced scenarios, there is <strong class="source-inline">CollectionView</strong>. Let’s have a look <span class="No-Break">at it!</span></p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor111"/>Working with CollectionView</h1>
<p><strong class="source-inline">CollectionView</strong> is an <a id="_idIndexMarker454"/>advanced control specifically designed for efficiently displaying large amounts of data. It offers all the properties available in <strong class="source-inline">BindableLayout</strong>, such as <strong class="source-inline">ItemsSource</strong>, <strong class="source-inline">ItemTemplate</strong>, <strong class="source-inline">ItemTemplateSelector</strong>, <strong class="source-inline">EmptyView</strong>, and <strong class="source-inline">EmptyViewTemplate</strong>. Additionally, <strong class="source-inline">CollectionView</strong> provides a wealth of powerful features, including item grouping, header and footer support, item selection and highlighting, item virtualization, and incremental loading of data as the user scrolls. These features enable you to create highly interactive and engaging user interfaces while efficiently managing and presenting your data. Item virtualization ensures that only the visible items are rendered, optimizing performance and memory usage, especially for <span class="No-Break">large collections.</span></p>
<p class="callout-heading">Other specialized controls</p>
<p class="callout">Aside from <strong class="source-inline">CollectionView</strong>, there are other specialized controls, such as <strong class="source-inline">CarouselView</strong> and <strong class="source-inline">ListView</strong>, for displaying collections in .NET MAUI. These controls also support <strong class="source-inline">ItemsSource</strong> binding and allow you to define an <strong class="source-inline">ItemTemplate</strong> or <strong class="source-inline">DataTemplateSelector</strong>. Each comes with a unique set of features and use cases, but the basic principles of data binding <span class="No-Break">remain similar.</span></p>
<p>Now, let’s explore a simple example of using <strong class="source-inline">CollectionView</strong>. In our <strong class="source-inline">RecipesOverviewViewModel</strong>, we expose an <strong class="source-inline">ObservableCollection</strong> of <strong class="source-inline">RecipeListItemViewModel</strong>s called <strong class="source-inline">Recipes</strong>. Each <strong class="source-inline">RecipeListItemViewModel</strong> represents a recipe and contains a subset of properties relevant to displaying it on an overview page, such as the recipe’s ID, title, image, and favorite status. While the recipe’s ID may not be necessary for direct display on the screen, it is valuable for identifying the selected item for navigation purposes or implementing features such as “favoriting” an item from the list. For our app to start on <strong class="source-inline">RecipesOverviewPage</strong>, we need to update the <strong class="source-inline">AppShell.xaml</strong> file, as shown in the <span class="No-Break">following snippet:</span></p>
<pre class="source-code">
&lt;ShellContent <strong class="bold">ContentTemplate="{DataTemplate local:RecipesOverviewPage}"</strong> /&gt;</pre> <p>We haven’t touched on navigation just yet; that’s still to come in <a href="B20941_08.xhtml#_idTextAnchor132"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Navigation in MVVM</em>. So, for now, just update the <strong class="source-inline">AppShell.xaml</strong> file, as shown earlier, and don’t worry <span class="No-Break">about it.</span></p>
<p>To display the recipes in <strong class="source-inline">RecipesOverviewPage</strong>, we can use <strong class="source-inline">CollectionView</strong>. The <strong class="source-inline">ItemsSource</strong> property of <strong class="source-inline">CollectionView</strong> is bound to the <strong class="source-inline">Recipes</strong> property of the <strong class="source-inline">RecipesOverviewViewModel</strong> class, which serves as the page’s <strong class="source-inline">BindingContext</strong>. Similar to <strong class="source-inline">BindableLayout</strong>, we define the <strong class="source-inline">ItemTemplate</strong> property to specify how each item in the collection should be rendered. The following code snippet demonstrates <span class="No-Break">this setup:</span></p>
<pre class="source-code">
&lt;CollectionView
    ItemsSource="{Binding Recipes}"&gt;
    &lt;CollectionView.ItemTemplate&gt;
        &lt;DataTemplate&gt;
            ...
        &lt;/DataTemplate&gt;
    &lt;/CollectionView.ItemTemplate&gt;
&lt;/CollectionView&gt;</pre> <p>The usage of <strong class="source-inline">CollectionView</strong> should feel familiar if you have worked with <strong class="source-inline">BindableLayout</strong> before. You can copy the <strong class="source-inline">DataTemplate</strong> class from <strong class="source-inline">BindableLayout</strong> and it will show up <span class="No-Break">the same.</span></p>
<p>Now, let’s leverage one of <a id="_idIndexMarker455"/>the more powerful features of <strong class="source-inline">CollectionView</strong>: data grouping. Let’s explore how to effectively display <span class="No-Break">grouped data.</span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor112"/>Displaying grouped data</h2>
<p>Grouping data in a collection is a <a id="_idIndexMarker456"/>powerful way to organize and present information in a meaningful and structured manner. By grouping related items, you can provide intuitive navigation and enhance the user experience. <strong class="source-inline">CollectionView</strong> allows us to easily display grouped data and provides both <strong class="source-inline">GroupHeaderTemplate</strong> and <strong class="source-inline">GroupFooterTemplate</strong> properties. These templates allow us to define what’s being displayed above and below a group of items. <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.4</em> illustrates how a list of grouped items is rendered with group headers <span class="No-Break">and footers:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<img alt="Figure 6.4: Group headers and footers" height="511" src="image/B20941_06_04.jpg" width="427"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4: Group headers and footers</p>
<p><strong class="source-inline">RecipeRatingDetailPage</strong>, which <a id="_idIndexMarker457"/>can be accessed by tapping on the rating information on <strong class="source-inline">RecipeDetailPage</strong>, should show all the ratings of a recipe grouped by the number of stars. Let’s walk through the steps needed to set <span class="No-Break">this up:</span></p>
<ol>
<li>While <strong class="source-inline">RecipeRatingsDetailViewModel</strong> already contains a list of all the reviews of a recipe, it doesn’t group the data yet. First, let’s create a class for holding a group of ratings. In the <strong class="bold">Solution Explorer</strong>, right-click the <strong class="bold">ViewModels</strong> folder in the <strong class="bold">Recipes.Client.Core</strong> project and select <strong class="bold">Add</strong> | <strong class="bold">Class…</strong>. Enter <strong class="source-inline">RatingGroup</strong> as <span class="No-Break">its name.</span></li>
<li>The <strong class="source-inline">RatingGroup</strong> class inherits from <strong class="source-inline">List&lt;UserReviewModel&gt;</strong> and has an additional property called <strong class="source-inline">Key</strong>. Here’s what it <span class="No-Break">looks like:</span><pre class="source-code">
public class RatingGroup : List&lt;UserReviewViewModel&gt;
{
    public string Key { get; private set; }
    public RatingGroup(string key,
        List&lt;UserReviewViewModel&gt; reviews) :
          base(reviews)
    {
        Key = key;
    }
}</pre><p class="list-inset">This class serves as a specialized list for holding <strong class="source-inline">UserReviewViewModel</strong> objects. It inherits from <strong class="source-inline">List&lt;UserReviewViewModel&gt;</strong>, meaning it can do anything a regular list can do, such as holding multiple <strong class="source-inline">UserReviewViewModel</strong> items. In addition to that, the class includes an extra property called <strong class="source-inline">Key</strong>. This property is used to group the user reviews by some criteria, such as a rating or <span class="No-Break">a category.</span></p></li> <li>Next, add a <strong class="source-inline">GroupedReviews</strong> property to <strong class="source-inline">RecipeRatingsDetailViewModel</strong>. This property is of type <strong class="source-inline">List&lt;RatingGroup&gt;</strong>. It holds groups of reviews that are organized based on the number of stars. Each <strong class="source-inline">RatingGroup</strong> in the list will contain reviews that share<a id="_idIndexMarker458"/> the same number of stars, which is represented by the <strong class="source-inline">Key</strong> property. The following snippet shows this newly added property and how it gets initialized in <span class="No-Break">the constructor:</span><pre class="source-code">
List&lt;RatingGroup&gt; _groupedReviews = new();
public List&lt;RatingGroup&gt; GroupedReviews
{
    get =&gt; _groupedReviews;
    private set =&gt; SetProperty(ref _groupedReviews,
      value);
}
public RecipeRatingsDetailViewModel(...)
{
   ...
    Reviews = new() { ... };
    GroupedReviews = Reviews.GroupBy(r =&gt;
      Math.Round(r.Rating / .5) * .5)
        .OrderByDescending(g =&gt; g.Key)
        .Select(g =&gt; new RatingGroup(g.Key.ToString(),
          g.ToList()))
        .ToList();
}</pre><p class="list-inset">In the constructor, we <a id="_idIndexMarker459"/>have grouped all the reviews by their rating, rounded to 0.5. We use this grouping to create a list of <strong class="source-inline">RatingGroups</strong> items that we assign to the <span class="No-Break"><strong class="source-inline">GroupedReviews</strong></span><span class="No-Break"> property.</span></p></li> <li>Now, we can bind the <strong class="source-inline">GroupedReviews</strong> property to the <strong class="source-inline">CollectionView</strong> on <strong class="source-inline">RecipeRatingDetailPage</strong>. When binding a grouped collection, we also need to make sure the <strong class="source-inline">IsGrouped</strong> property of <strong class="source-inline">CollectionView</strong> is set to true, as the following <span class="No-Break">snippet shows:</span><pre class="source-code">
&lt;CollectionView
        IsGrouped="True"
        ItemsSource="{Binding GroupedReviews}"&gt;
...
&lt;/CollectionView&gt;</pre></li> <li>As we did previously, we<a id="_idIndexMarker460"/> should be defining an <strong class="source-inline">ItemTemplate</strong> to declare how each item should be rendered. Once that is in place, <strong class="source-inline">CollectionView</strong> renders all the items but there isn’t a clear distinction between the different <span class="No-Break">groups yet.</span></li>
<li>So, let's add <strong class="source-inline">GroupHeaderTemplate</strong> and <strong class="source-inline">GroupFooterTemplate</strong> to clearly distinguish the different groups. The following code block demonstrates how this can <span class="No-Break">be done:</span><pre class="source-code">
&lt;CollectionView.GroupHeaderTemplate&gt;
    &lt;DataTemplate x:DataType="{x:Type
      vms:RatingGroup}"&gt;
        &lt;Label
            Margin="0,25,0,0" FontSize="16"
            Text="{Binding Key, StringFormat='{0}
              stars Reviews'}" /&gt;
    &lt;/DataTemplate&gt;
&lt;/CollectionView.GroupHeaderTemplate&gt;
&lt;CollectionView.GroupFooterTemplate&gt;
    &lt;DataTemplate x:DataType="{x:Type
      vms:RatingGroup}"&gt;
        &lt;Label FontSize="12" Text="{Binding Count,
          StringFormat='{0} reviews'}" /&gt;
    &lt;/DataTemplate&gt;
&lt;/CollectionView.GroupFooterTemplate&gt;</pre><p class="list-inset">The <strong class="source-inline">BindingContext</strong> of these templates is an instance of <strong class="source-inline">RatingGroup</strong>, allowing us to bind to its properties, such as <strong class="source-inline">Key</strong> and <strong class="source-inline">Count</strong>. With this, we can make the groupings visually clear to <span class="No-Break">the user.</span></p></li> </ol>
<p>Grouping <a id="_idIndexMarker461"/>data in <strong class="source-inline">CollectionView</strong> allows for a more organized and structured presentation of information, as shown in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<img alt="Figure 6.5: Grouping data" height="495" src="image/B20941_06_05.jpg" width="435"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5: Grouping data</p>
<p>By leveraging the <strong class="source-inline">GroupHeaderTemplate</strong> and <strong class="source-inline">GroupFooterTemplate</strong> properties, you can enhance the user experience and provide intuitive navigation within <span class="No-Break">your app.</span></p>
<p>Not only can <strong class="source-inline">CollectionView</strong> render your data, it also offers various interactive features to engage users with your app. From selecting items to incrementally loading data and other common functionalities, let’s discover how to get the most out of this powerful control, by keeping MVVM principles <span class="No-Break">in mind.</span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor113"/>Selecting items</h2>
<p>When working<a id="_idIndexMarker462"/> with <strong class="source-inline">CollectionView</strong>, you have various options for selecting items and managing the selection state. By binding the <strong class="source-inline">SelectedItem</strong> property, you can easily track the currently selected item in your ViewModel. Additionally, you can bind the <strong class="source-inline">SelectedItems</strong> property to a collection in your ViewModel to track multiple selected items. The <strong class="source-inline">SelectionMode</strong> property allows you to define whether single or multiple items can be selected or whether or not selecting items is disabled. You can use the <strong class="source-inline">SelectionChangedCommand</strong> property to bind a command in your ViewModel that will be executed when the selection changes or handle the <strong class="source-inline">SelectionChanged</strong> event, allowing you to implement flexible and interactive item selection behavior in <span class="No-Break">your app.</span></p>
<p>Let’s see how we can <a id="_idIndexMarker463"/>allow the user to select one or more reviews, allowing the user to report inappropriate reviews, <span class="No-Break">for example:</span></p>
<ol>
<li>Add the following property <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">RecipeRatingsDetailViewModel</strong></span><span class="No-Break">:</span><pre class="source-code">
public ObservableCollection&lt;object&gt; SelectedReviews 
{ get; } = new();</pre><p class="list-inset">This property will hold the items that the user has selected on the <strong class="source-inline">CollectionView</strong>. Note that this <strong class="source-inline">ObservableCollection</strong> uses <strong class="source-inline">object</strong> as its type parameter, rather than a more specific type. Though it’s not explicitly documented, using <strong class="source-inline">object</strong> appears to be the only way to successfully bind multiple selections <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">CollectionView</strong></span><span class="No-Break">.</span></p></li> <li>Now, let’s add a command called <strong class="source-inline">ReportReviewsCommand</strong> that can only be executed when one or more reviews are selected, as <span class="No-Break">shown here:</span><pre class="source-code">
public RelayCommand ReportReviewsCommand { get; }
public RecipeRatingsDetailViewModel()
{
    ...
    ReportReviewsCommand = new
        RelayCommand(ReportReviews,
        () =&gt; SelectedReviews.Any());
}
private void ReportReviews()
{
    var selectedReviews = SelectedReviews
        .Cast&lt;UserReviewViewModel&gt;().ToList();
    //do reporting
    SelectedReviews.Clear();
}</pre></li> <li>As the <strong class="source-inline">SelectedReviews</strong> property is an <strong class="source-inline">ObservableCollection</strong>, we can listen to the <strong class="source-inline">CollectionChangedEvent</strong> and call the <strong class="source-inline">ReportReviewsCommand</strong>’s <strong class="source-inline">NotifyCanExecuteChanged</strong> method. That way the <strong class="source-inline">ReportReviewsCommand</strong>’s <strong class="source-inline">CanExecute</strong> method gets re-evaluated. The following snippet<a id="_idIndexMarker464"/> shows how to <span class="No-Break">implement this:</span><pre class="source-code">
public RecipeRatingsDetailViewModel()
{
.   ...
    SelectedReviews.CollectionChanged +=
        SelectedReviews_CollectionChanged;
}
private void SelectedReviews_CollectionChanged(object?
  sender, NotifyCollectionChangedEventArgs e)
=&gt; ReportReviewsCommand.NotifyCanExecuteChanged();</pre></li> <li>Update the <strong class="source-inline">CollectionView</strong> on <strong class="source-inline">RecipeRatingDetailPage</strong> so that its <strong class="source-inline">SelectedItems</strong> property is bound to the <strong class="source-inline">SelectedReviews</strong> property. We also need to set the<a id="_idIndexMarker465"/> appropriate <strong class="source-inline">SelectionMode</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">
&lt;CollectionView
    IsGrouped="True"
    ItemsSource="{Binding GroupedReviews}"
    <strong class="bold">SelectedItems="{Binding SelectedReviews}"</strong>
    <strong class="bold">SelectionMode="Multiple"</strong>&gt;</pre></li> </ol>
<p>By adding this code, the items the user selects on the UI will be added to the <strong class="source-inline">SelectedReviews</strong> list, while selected items that the user de-selects will be removed from it. The <strong class="bold">Report review(s)</strong> button is enabled as soon as the user selects one or more reviews from the list. In the <strong class="source-inline">ReportReviews</strong> method, we can easily access the <strong class="source-inline">SelectedReviews</strong> property to see what items have <span class="No-Break">been selected.</span></p>
<p>As a final example, let’s look at how we can bind the <strong class="source-inline">SelectedItem</strong> and <strong class="source-inline">SelectionChangedCommand</strong> properties to trigger something such as navigation. Let’s take a look at how to implement this <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">RecipesOverviewPage</strong></span><span class="No-Break">:</span></p>
<ol>
<li>On <strong class="source-inline">RecipesOverviewPage</strong>, update the <strong class="source-inline">CollectionView</strong> and bind its <strong class="source-inline">SelectedItem</strong> and <strong class="source-inline">SelectionChangedCommand</strong> properties, <span class="No-Break">like this:</span><pre class="source-code">
&lt;CollectionView
    ...
    SelectedItem="{Binding SelectedRecipe,
      Mode=TwoWay}"
    SelectionChangedCommand="{Binding
      NavigateToSelectedDetailCommand}"
    SelectionMode="Single"&gt;</pre><p class="list-inset">The <strong class="source-inline">SelectedItem</strong> property is bound <strong class="source-inline">TwoWay</strong> to the <strong class="source-inline">SelectedRecipe</strong> property and <strong class="source-inline">SelectionChangedCommand</strong> is bound to <strong class="source-inline">NavigateToSelectedDetailCommand</strong>. Both properties will be added shortly. Also, the <strong class="source-inline">SelectionMode</strong> property is set to <strong class="source-inline">"Single"</strong>, allowing the user to select one item in <span class="No-Break">the list.</span></p></li> <li>Now, let’s add the<a id="_idIndexMarker466"/> two properties mentioned earlier to <strong class="source-inline">RecipeOverviewViewModel</strong>. Here’s what they <span class="No-Break">look like:</span><pre class="source-code">
RecipeListItemViewModel? _selectedRecipe;
public RecipeListItemViewModel? SelectedRecipe
{
    get =&gt; _selectedRecipe;
    set =&gt; SetProperty(ref _selectedRecipe, value);
}
public AsyncRelayCommand NavigateTo
  SelectedDetailCommand { get; }</pre></li> <li>The following snippet shows how the command is instantiated in the constructor of <span class="No-Break">the ViewModel:</span><pre class="source-code">
public RecipesOverviewViewModel()
{
...
    NavigateToSelectedDetailCommand = new
      AsyncRelayCommand(NavigateToSelectedDetail);
}</pre><p class="list-inset">Because this command is bound to the <strong class="source-inline">SelectionChangedCommand</strong> of the <strong class="source-inline">CollectionView</strong>, it will get triggered when an item is selected <span class="No-Break">or de-selected.</span></p></li> <li>The following code <a id="_idIndexMarker467"/>block shows the <span class="No-Break"><strong class="source-inline">NavigateToSelectedDetail</strong></span><span class="No-Break"> method:</span><pre class="source-code">
private Task NavigateToSelectedDetail()
{
    if (SelectedRecipe is not null)
    {
        //ToDo navigate to selected item
        SelectedRecipe = null;
    }
    return Task.CompletedTask;
}</pre></li> </ol>
<p>When the user selects an item in <strong class="source-inline">CollectionView</strong>, the <strong class="source-inline">SelectedRecipe</strong> property on the ViewModel will be updated. Next, <strong class="source-inline">NavigateToSelectedDetailCommand</strong> will be executed, which will call the <strong class="source-inline">NavigateToSelectedDetail</strong> method. In this method, we can access the <strong class="source-inline">SelectedRecipe</strong> property and act upon it, such as navigating to its detail page, for example. Finally, we set the <strong class="source-inline">SelectedRecipe</strong> property to null. As this property is bound <strong class="source-inline">TwoWay</strong>, the item will get de-selected in <strong class="source-inline">CollectionView</strong>. As a result, if we navigate back from <strong class="source-inline">RecipeDetailPage</strong>, no item will be selected on the overview and then we can immediately<a id="_idIndexMarker468"/> select <span class="No-Break">another one.</span></p>
<p>Now, let’s have a look at how we can load data incrementally while the user scrolls through a <span class="No-Break">large dataset.</span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor114"/>Incrementally loading data</h2>
<p>As the user scrolls through <a id="_idIndexMarker469"/>large datasets in <strong class="source-inline">CollectionView</strong>, providing a seamless and interactive user experience is crucial. The <strong class="source-inline">RemainingItemsThreshold</strong> and <strong class="source-inline">RemainingItemsThresholdReachedCommand</strong> properties allow you to effortlessly load additional items. By specifying a threshold value for the remaining items, new data is dynamically fetched and seamlessly loaded, ensuring a smooth and continuous experience. Let’s explore how to implement this interactive functionality in just a few <span class="No-Break">simple steps:</span></p>
<ol>
<li>Add the following method <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">RecipesOverviewViewModel</strong></span><span class="No-Break">:</span><pre class="source-code">
private async Task TryLoadMoreItems()
{
    //Dummy implementation
    if (Recipes.Count &lt; TotalNumberOfRecipes)
    {
        await Task.Delay(250);
        foreach (var item in items)
        {
            Recipes.Add(item);
        }
    }
}</pre><p class="list-inset">This method adds items to the <strong class="source-inline">Recipes</strong> <strong class="source-inline">ObservableCollection</strong> class as it has fewer items than what’s defined in the <strong class="source-inline">TotalNumberOfRecipes</strong> property. It’s a pretty dumb implementation, but it should get the point across. In a real-life<a id="_idIndexMarker470"/> scenario, we would fetch this data from an API or something. We’ll look at this in <a href="B20941_10.xhtml#_idTextAnchor165"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Working with </em><span class="No-Break"><em class="italic">Remote Data</em></span><span class="No-Break">.</span></p></li> <li>Next, let’s add a command called <strong class="source-inline">TryLoadMoreItemsCommand</strong>. This is the command that should be invoked when we want to load more items. We want to instantiate it in the constructor of <strong class="source-inline">RecipesOverviewViewModel</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">
<strong class="bold">public AsyncRelayCommand TryLoadMoreItemsCommand </strong>
<strong class="bold">{ get; }</strong>
public RecipesOverviewViewModel()
{
    Recipes = new ObservableCollection
      &lt;RecipeListItemViewModel&gt;(items);
    <strong class="bold">TryLoadMoreItemsCommand = new AsyncRelayCommand</strong>
<strong class="bold">      (TryLoadMoreItems);</strong>
}</pre></li> <li>Now, we can update the <strong class="source-inline">CollectionView</strong> and add both <strong class="source-inline">RemainingItemsThreshold</strong> and <strong class="source-inline">RemainingItemsThresholdReachedCommand</strong>, as shown in the following <a id="_idIndexMarker471"/><span class="No-Break">code block:</span><pre class="source-code">
&lt;CollectionView
    ItemsSource="{Binding Recipes}"
    <strong class="bold">RemainingItemsThreshold="5"</strong>
    <strong class="bold">RemainingItemsThresholdReachedCommand="{Binding</strong>
<strong class="bold">      TryLoadMoreItemsCommand}"</strong>
    ...&gt;</pre><p class="list-inset">With this code in place, <strong class="source-inline">TryLoadMoreItemsCommand</strong> will be invoked as soon as the user scrolls and the number of remaining items reaches the specified threshold of five or less. The <strong class="source-inline">TryLoadMoreItems</strong> method will then add items to the <strong class="source-inline">Recipes</strong> <strong class="source-inline">ObservableCollection</strong>. Because this method implements the <strong class="source-inline">ICollectionChanged</strong> interface, the added items will be automatically added <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">CollectionView</strong></span><span class="No-Break">.</span></p></li> </ol>
<p>Incrementally loading data is a good idea when dealing with very large datasets and <strong class="source-inline">CollectionView</strong> makes it extremely convenient<a id="_idIndexMarker472"/> to implement using the <strong class="source-inline">RemainingItemsThreshold</strong> and <span class="No-Break"><strong class="source-inline">RemainingItemsThresholdReachedCommand</strong></span><span class="No-Break"> properties.</span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor115"/>Other common interactions</h2>
<p>In addition to the<a id="_idIndexMarker473"/> features we’ve discussed, it’s worth mentioning that common interactions such as pull-to-refresh and item context menus are also available in .NET MAUI. These interactions allow users to refresh the data that’s displayed in the collection and access additional actions or information specific to each item. While they are used on collections very often, it’s important to note that these features are not exclusive to <strong class="source-inline">CollectionView</strong> and can be implemented anywhere in <span class="No-Break">your application.</span></p>
<p><strong class="source-inline">SwipeView</strong> is a<a id="_idIndexMarker474"/> versatile control that allows you to add swipe gestures to individual items in a collection. It enables users to perform actions by swiping horizontally or vertically on an item, such as deleting an item or revealing <span class="No-Break">additional options.</span></p>
<p><strong class="source-inline">RefreshView</strong>, on<a id="_idIndexMarker475"/> the other hand, is a control that provides a standard pull-to-refresh functionality. It allows users to refresh the data that’s displayed in a collection by pulling down on the screen. When triggered, <strong class="source-inline">RefreshView</strong> executes a command to update the collection with <span class="No-Break">fresh data.</span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor116"/>Summary</h1>
<p>In this chapter, we explored the powerful features and capabilities of collections in .NET MAUI. We learned how to effectively bind collections to UI elements using <strong class="source-inline">BindableLayout</strong> and <strong class="source-inline">CollectionView</strong>, enabling dynamic and efficient rendering of data. We covered topics such as data templating, item selection, grouping, and incremental loading. <strong class="source-inline">CollectionView</strong> proved to be a versatile control, offering advanced functionality such as item virtualization and seamless <span class="No-Break">data loading.</span></p>
<p>As we continue our journey in building robust and scalable apps, in the next chapter, we will delve into the important concepts of dependency injection, services, and messaging. These fundamental aspects of app development will empower us to create modular and maintainable code, enhance code reusability, and enable effective communication between different parts of <span class="No-Break">our application.</span></p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor117"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the <span class="No-Break">following resources:</span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline">BindableLayout</strong></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/bindablelayout"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/bindablelayout</span></a></li>
<li><span class="No-Break"><strong class="source-inline">CollectionView</strong></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/dotnet/maui/user-interface/controls/collectionview"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/user-interface/controls/collectionview</span></a></li>
<li><span class="No-Break"><strong class="source-inline">ListView</strong></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/dotnet/maui/user-interface/controls/listview"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/user-interface/controls/listview</span></a></li>
<li><span class="No-Break"><strong class="source-inline">CarouselView</strong></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/dotnet/maui/user-interface/controls/carouselview"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/user-interface/controls/carouselview</span></a></li>
<li><span class="No-Break"><strong class="source-inline">SwipeView</strong></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/dotnet/maui/user-interface/controls/swipeview"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/user-interface/controls/swipeview</span></a></li>
<li><span class="No-Break"><strong class="source-inline">RefreshView</strong></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/dotnet/maui/user-interface/controls/refreshview"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/user-interface/controls/refreshview</span></a></li>
</ul>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer054">
<h1 id="_idParaDest-116" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor118"/>Part 2: Building a .NET MAUI App Using MVVM</h1>
<p>In this part, we focus on equipping you with the essential tools and techniques needed to craft a genuine .NET MAUI application that leverages the MVVM pattern. We will dive into the core mechanisms such as dependency injection, services, and messaging, which form the backbone of any robust app. We will help you master MVVM-based navigation in .NET MAUI with or without Shell, refine user interactions with precise input and validation, and connect seamlessly with remote <span class="No-Break">data sources.</span></p>
<p>This part has the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B20941_07.xhtml#_idTextAnchor119"><em class="italic">Chapter 7</em></a>, <em class="italic">Dependency Injection, Services, and Messaging</em></li>
<li><a href="B20941_08.xhtml#_idTextAnchor132"><em class="italic">Chapter 8</em></a>, <em class="italic">.NET MAUI Shell and Navigation</em></li>
<li><a href="B20941_09.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a>, <em class="italic">Handling User Input and Validation</em></li>
<li><a href="B20941_10.xhtml#_idTextAnchor165"><em class="italic">Chapter 10</em></a>, <em class="italic">Working with Remote Data</em></li>
</ul>
</div>
<div>
<div id="_idContainer055">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer056">
</div>
</div>
</div></body></html>