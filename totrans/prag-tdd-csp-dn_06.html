<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-130"><a id="_idTextAnchor140"/>6</h1>
<h1 id="_idParaDest-131"><a id="_idTextAnchor141"/>The FIRSTHAND Guidelines of TDD</h1>
<p>TDD is more than a test-first unit testing or a Red-Green-Refactor approach. TDD includes best practices and guidelines that steer the way you work with unit testing.</p>
<p>I wanted to make a memorable list, from my experience, of the most useful guidelines on unit testing and TDD. So, here are nine proven best practices that I’ve abbreviated as <strong class="bold">FIRSTHAND</strong>. FIRSTHAND stands for:</p>
<ul>
<li><em class="italic">F</em>irst</li>
<li><em class="italic">I</em>ntention</li>
<li><em class="italic">R</em>eadability</li>
<li><em class="italic">S</em>ingle-Behavior</li>
<li><em class="italic">T</em>horoughness</li>
<li><em class="italic">H</em>igh-Performance</li>
<li><em class="italic">A</em>utomation</li>
<li><em class="italic">N</em>o Interdependency</li>
<li><em class="italic">D</em>eterministic</li>
</ul>
<p>In this chapter, we will go through each of these nine guidelines and support them with relevant practical examples. By the end of the chapter, you should have a fair understanding of the ecosystem of TDD and its guidelines.</p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor142"/>Technical requirements</h1>
<p>The code for this chapter can be found in the following GitHub repository: </p>
<p><a href="https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch06">https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch06</a><a href="https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-.NET/tree/main/ch06%0D"/></p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor143"/>The First guideline</h1>
<p>Unit tests should be <a id="_idIndexMarker424"/>written first. This might seem odd or unintuitive at the beginning, but there are valid reasons for this choice.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor144"/>Later means never</h2>
<p>How many times have you heard, <em class="italic">we’ll test it later</em>? I have never seen a team finishing a project and releasing it to<a id="_idIndexMarker425"/> production and then allocating time to unit test their code.</p>
<p>Moreover, adding unit tests at the end will require code refactoring, which might break the product, and it is hard to justify to a non-technical person that a working system was broken because the team was adding unit tests. Actually, the statement <em class="italic">we broke production because we were adding unit tests</em> sounds ironic. Yes, you can refactor a working system while covered by other types of tests, such as Sintegration and acceptance tests, but it would be difficult to imagine that a team that didn’t have time to unit test previously had the time to build other tests that would fully cover the system.</p>
<p><em class="italic">Testing first ensures that unit tests and features are developed hand in hand and tests are not omitted.</em></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor145"/>Being dependency injection ready</h2>
<p>When you get used to the <a id="_idIndexMarker426"/>modern software development style of creating a service and then injecting it, you will never look back. Software frameworks have evolved to make DI a first-class citizen. Here are a few examples:</p>
<ul>
<li><strong class="bold">Angular Web Framework</strong>: You can<a id="_idIndexMarker427"/> only obtain services in Angular via DI and you would struggle to do it in other ways.</li>
<li><strong class="bold">Microsoft MAUI</strong>: MAUI is a<a id="_idIndexMarker428"/> revamp of Xamarin.Forms and one of the major changes from Xamarin is having DI as a first-class citizen.</li>
<li><strong class="bold">.NET Core Console</strong>: classical .NET<a id="_idIndexMarker429"/> Framework console applications did not support DI, but this is now natively supported in Core, which paved the way to have other libraries, built on top of console applications, to support DI, for example ASP.NET Core.</li>
<li><strong class="bold">ASP.NET Core</strong>: One major difference<a id="_idIndexMarker430"/> between classical ASP.NET and ASP.NET Core is having DI as a first-class citizen.</li>
</ul>
<p>These are all strong signals to tell you that there is no escape from using DI. Having your software implemented and then adding DI later is going to require a major refactoring and rethinking everything.</p>
<p><em class="italic">Starting with unit testing will enforce DI from the first moment.</em></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor146"/>Designing from the client’s perspective</h2>
<p>TDD encourages you to think <a id="_idIndexMarker431"/>from the client’s (the caller) needs rather than getting bogged down with the implementation details. You are encouraged to think of the OOP design such as class name, abstractions, deciding the method signature and return type before thinking of the implementation details like the method body.</p>
<p>If you have a public interface (a combination of classes and methods) used by other systems or libraries, it is harder to change that interface as it is probably in-use by the other system, compared to changing the implementation of your code, say for optimization purposes.</p>
<p><em class="italic">TDD enforces designing the code from the client’s perspective.</em></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor147"/>Promoting behavior testing</h2>
<p>A unit test should care about <em class="italic">what</em> a <strong class="bold">System Under Test</strong> (<strong class="bold">SUT</strong>) does, <em class="italic">not how</em> it does it. In a unit test, you <a id="_idIndexMarker432"/>want to push a certain input, check how the <a id="_idIndexMarker433"/>dependencies are affected, and check the output. What you should not check is how the SUT worked internally to do all that.</p>
<p>If you decide to check the internals of the SUT, your unit tests will become tightly coupled to the implementation details. This means every change in the method will have a rippling effect on the associated unit tests. This will lead to more unit tests and brittle tests. It is worth iterating here that <em class="italic">tests are an asset and a liability</em>. Having more tests, which are often unnecessary, means more maintenance.</p>
<p>Testing first makes you naturally think about the inputs, outputs, and side effects, not about the details of the SUT implementation. Testing after implementation leads to what I refer to as <em class="italic">cheating</em>, where the developers look at the SUT implementation code and write their tests accordingly. This might inadvertently lead to testing implementation details.</p>
<p><em class="italic">TDD promotes the unit testing mantra: Test behavior, not implementation details. </em></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor148"/>Eliminating false positives</h2>
<p>A false positive is when <a id="_idIndexMarker434"/>a test passes for the wrong reason. This doesn’t happen frequently, but when it does happen, it is hard to catch.</p>
<p><em class="italic">TDD uses the red-green approach to eliminate false positives.</em></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor149"/>Eradication of speculative code</h2>
<p>We have all written<a id="_idIndexMarker435"/> code thinking, <em class="italic">perhaps we will need it in the future</em>, or <em class="italic">let me leave it here as other </em><em class="italic">colleagues will find it useful</em>. The drawback of this approach is this code may never be used but will be maintained. Even worse, if it is used in the future, it may give the illusion that it has been tested, while, in fact, it has been waiting for a future developer to test it.</p>
<p><em class="italic">TDD eradicates speculative code by writing production-only code.</em></p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor150"/>The Intention guideline</h1>
<p>When your system grows, it drives more unit tests that will naturally cover system behavior and documentation. And with more tests comes greater responsibility: <strong class="bold">readability</strong> and <strong class="bold">maintenance</strong>.</p>
<p>The tests will grow in <a id="_idIndexMarker436"/>quantity to an extent where the team will not remember the reason for writing them. You will be looking at a failing test and scratching your head for clues about the intention of the test.</p>
<p>Your unit tests should be understood with the least possible time and effort; otherwise, they will be more of a liability than an asset. An agile software team should be prepared in advance for such test failure scenarios. Intention can be demonstrated by having a clear method signature and a well-structured method body.</p>
<p>Starting with the method signature, here are two popular conventions that should clarify the unit test’s intention.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor151"/>Method_Condition_Expectation</h2>
<p>I have been using this<a id="_idIndexMarker437"/> convention in naming the <a id="_idIndexMarker438"/>unit test methods across the book: <code>Method_</code><code>Condition_Expectation</code>. This is a succinct naming convention that doesn’t allow innovative method names and, in my opinion, spares innovation for other tasks. It results in a more boring but standard method name. The following is an example:</p>
<p><code>LoginUser_UsernameDoesntExist_ThrowsInvalidOperationException</code></p>
<p>This is still not a precise convention, but it is good enough. For example, some developers may argue against using the word <code>Throws</code> as it is obvious because the word <code>Exception</code> is used.</p>
<p>What is important here is establishing, in a short amount of time, from the three parts seen in the preceding method name, the intention of this test.</p>
<p class="callout-heading">Note</p>
<p class="callout">I have seen teams omitting the <code>Method</code> part and just using <code>Condition_Expectation</code>, especially if the whole unit test class targets one method only.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor152"/>Method_Should_When</h2>
<p>Another popular convention<a id="_idIndexMarker439"/> that allows more natural language is using the <code>Method_Should_When</code>. This convention is more akin to fluent coding, where the code flows like an English<a id="_idIndexMarker440"/> sentence. The following is an example:</p>
<p><code>LoginUser_Should_Throw_InvalidOperationException_When_UsernameDoesntExist</code></p>
<p>Sometimes, advocates of this <a id="_idIndexMarker441"/>convention like to also use <strong class="bold">fluent assertions</strong> for asserting:</p>
<pre class="source-code">// Assert
IsSaved.Should().BeTrue();</pre>
<p>As you might have noticed, the previous<a id="_idIndexMarker442"/> code is different from the xUnit style used in the book:</p>
<pre class="source-code">// Assert
Assert(true, IsSaved);</pre>
<p>If you are interested in using fluent assertions, you can have a look at a .NET library called <strong class="bold">Shouldly</strong> (<a href="https://github.com/shouldly/shouldly">https://github.com/shouldly/shouldly</a>). In <a href="B18370_14.xhtml#_idTextAnchor315"><em class="italic">Appendix 1</em></a>, <em class="italic">Commonly Used Libraries with Unit Tests</em>, we discuss <a id="_idIndexMarker443"/>a similar library called <em class="italic">Fluent Assertions</em>.</p>
<p>The next part for clarifying the intention is clarifying the method body.</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor153"/>Unit test structure</h2>
<p>The dominant method for<a id="_idIndexMarker444"/> structuring a <a id="_idIndexMarker445"/>unit test body is the popular <strong class="bold">Arrange-Act-Assert</strong> (<strong class="bold">AAA</strong>). Let’s shed more light on the intention <a id="_idIndexMarker446"/>of what each section should do.</p>
<h3>Arrange</h3>
<p><code>Arrange</code> is meant to achieve<a id="_idIndexMarker447"/> two objectives:</p>
<ul>
<li>Initializing variables</li>
<li>Creating a SUT state</li>
</ul>
<p>The <code>Arrange</code> section might <a id="_idIndexMarker448"/>be shared with the constructor of the unit test class as the constructor might be doing some preparations to reduce the <code>Arrange</code> code across each unit test. In other words, there might be some <em class="italic">arrangements</em> happening outside this section. We will see examples of this in <em class="italic">Part 2</em>, <em class="italic">Building an Application with TDD</em>, of the book.</p>
<p>Initializing the objects and initializing expectations happen in the <code>Arrange</code> section, and that is the obvious part. The not-so-obvious part is that this section sets a <em class="italic">state</em>. Here is an example to clarify what a state means:</p>
<p><code>LoginUser_UsernameDoesntExist_ThrowsInvalidOperationException</code></p>
<p><code>Arrange</code> will create a state where the user doesn’t exist in the system, and in most cases, that code will be tightly related to the <code>Condition</code> in <code>Method_Condition_Expectation</code>. In this case, the arrangement should be linked to <code>UsernameDoesntExist</code>.</p>
<h3>Act</h3>
<p><code>Act</code> is mostly a single line of<a id="_idIndexMarker449"/> code that calls the same method specified in the first part <a id="_idIndexMarker450"/>of the method name. In the previous example, I expect the act to look like this:</p>
<pre class="source-code">// Act
var exception = Record.Exception(() =&gt; <strong class="bold">sut.LoginUser(…)</strong>);</pre>
<p>This method reiterates the intention specified in the method’s signature and provides clean code.</p>
<h3>Assert</h3>
<p><code>Assert</code> is asserting the <a id="_idIndexMarker451"/>conditions in the last section of the method signature: <code>Expectation</code>.</p>
<p>The signature convention<a id="_idIndexMarker452"/> and the body structure work together to provide clear intentions. Keep in mind that no matter what convention you’ve used, the key is consistency and clarity. </p>
<p><em class="italic">Clear-intention unit tests would promote easier maintenance and more accurate documentation.</em></p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor154"/>The Readability guideline</h1>
<p>Is this method readable? Do<a id="_idIndexMarker453"/> you need to run it and start debugging to understand what it does? Does the <code>Arrange</code> section make your eyes bleed? This might be violating the readability principle.</p>
<p>Having the Intention guideline established is fabulous, but it is not enough. You will have at least 10x more lines of code in your unit tests compared to your production code. All this needs to be maintained and grow with the rest of your system.</p>
<p>Tidying up the unit test for readability follows the same practices as the production code. However, there are some scenarios that are more dominant in unit tests, which we are going to address here.</p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor155"/>SUT constructor initialization</h2>
<p>Initializing your SUT will <a id="_idIndexMarker454"/>require that you prepare all the dependencies and pass them to the SUT, something like this:</p>
<pre class="source-code">// Arrange
const double NEXT_T = 3.3;
const double DAY5_T = 7.7;
var today = new DateTime(2022, 1, 1);
var realWeatherTemps = new[] 
    {2, NEXT_T, 4, 5.5, 6, DAY5_T, 8};
var loggerMock = 
    Substitute.For&lt;ILogger&lt;WeatherController&gt;&gt;();
var nowWrapperMock = Substitute.For&lt;INowWrapper&gt;();
var randomWrapperMock = Substitute.For&lt;IRandomWrapper&gt;();
var clientMock = Substitute.For&lt;IClient&gt;();
clientMock.OneCallAsync(Arg.Any&lt;decimal&gt;(), Arg.Any&lt;decimal&gt;(), 
    Arg.Any&lt;IEnumerable&lt;Excludes&gt;&gt;(), Arg.Any&lt;Units&gt;())
    .Returns(x =&gt; 
    {
        const int DAYS = 7;
        OneCallResponse res = new OneCallResponse();
        res.Daily = new Daily[DAYS];
        for (int i = 0; i &lt; DAYS; i++)
        {
            res.Daily[i] = new Daily();
            res.Daily[i].Dt = today.AddDays(i);
            res.Daily[i].Temp = new Temp();
            res.Daily[i].Temp.Day = 
                realWeatherTemps.ElementAt(i);
        }
        return Task.FromResult(res);
    });
var controller = new WeatherController(loggerMock, 
    clientMock, nowWrapperMock, randomWrapperMock);
…</pre>
<p>Now we have done all the coding preparation, we can initialize the SUT (the controller, in our case) and pass to it the right parameters. This will be repeated in most of your same-SUT tests, which will make it a read nightmare. This code can easily go to the constructor of the unit test class and become something like this:</p>
<pre class="source-code">private const double NEXT_T = 3.3;
private const double DAY5_T = 7.7;
private readonly DateTime _today = new(2022, 1, 1);
private readonly double[] _realWeatherTemps = new[]
    { 2, NEXT_T, 4, 5.5, 6, DAY5_T, 8 };
private readonly ILogger&lt;WeatherForecastController&gt; _loggerMock 
  = Substitute.For&lt;ILogger&lt;WeatherForecastController&gt;&gt;();
private readonly INowWrapper _nowWrapperMock = 
    Substitute.For&lt;INowWrapper&gt;();
private readonly IRandomWrapper _randomWrapperMock = 
    Substitute.For&lt;IRandomWrapper&gt;();
private readonly IClient _clientMock = 
    Substitute.For&lt;IClient&gt;();
private readonly WeatherForecastController _sut;
public WeatherTests()
{
   _sut = new WeatherForecastController(_loggerMock,
       _clientMock,_nowWrapperMock, _randomWrapperMock);
}</pre>
<p>The beauty of the previous<a id="_idIndexMarker455"/> code is that it is reusable by all unit tests in the same class. The code in your unit test becomes something like this:</p>
<pre class="source-code">// Arrange
_clientMock.OneCallAsync(Arg.Any&lt;decimal&gt;(), 
    Arg.Any&lt;decimal&gt;(),
    Arg.Any&lt;IEnumerable&lt;Excludes&gt;&gt;(), Arg.Any&lt;Units&gt;())
    .Returns(x =&gt;
    {
        const int DAYS = 7;
        OneCallResponse res = new OneCallResponse();
        res.Daily = new Daily[DAYS];
        for (int i = 0; i &lt; DAYS; i++)
        {
            res.Daily[i] = new Daily();
            res.Daily[i].Dt = _today.AddDays(i);
            res.Daily[i].Temp = new Temp();
            res.Daily[i].Temp.Day = 
                _realWeatherTemps.ElementAt(i);
        }
        return Task.FromResult(res);
    });
…</pre>
<p>The <code>Arrange</code> size in your unit tests in this class has gone down. Remember, you are looking here at one unit test<a id="_idIndexMarker456"/> method, but you might have several unit tests for the same SUT. </p>
<p>You might argue that while we have cleared some of the repeated code in our <code>Arrange</code>, it is still busy. Let’s get the builder design pattern to the rescue.</p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor156"/>The builder pattern</h2>
<p>For the same SUT, every unit test’s arrangement <a id="_idIndexMarker457"/>varies slightly from others. The <strong class="bold">builder design pattern</strong> is useful when creating an object with lots of<a id="_idIndexMarker458"/> possible configuration options, which comes in handy for this scenario.</p>
<p class="callout-heading">Note</p>
<p class="callout">This is different <a id="_idIndexMarker459"/>from the <strong class="bold">Gang of Four</strong> (<strong class="bold">GoF</strong>) Builder design pattern.</p>
<p>The builder class, for the previous example, looks like this:</p>
<pre class="source-code">public class OneCallResponseBuilder
{
    private int _days = 7;
    private DateTime _today = new (2022, 1, 1);
    private double[] _temps = {2, 3.3, 4, 5.5, 6, 7.7, 8};
    public OneCallResponseBuilder SetDays(int days)
    {
        _days = days;
        return this;
    }
    public OneCallResponseBuilder SetToday(DateTime today)
    {
        _today = today;
        return this;
    }
    public OneCallResponseBuilder SetTemps(double[] temps)
    {
        _temps = temps;
        return this;
    }
    public OneCallResponse Build()
    {
        var res = new OneCallResponse();
        res.Daily = new Daily[_days];
        for (int i = 0; i &lt; _days; i++)
        {
            res.Daily[i] = new Daily();
            res.Daily[i].Dt = _today.AddDays(i);
            res.Daily[i].Temp = new Temp();
            res.Daily[i].Temp.Day = _temps.ElementAt(i);
        }
        return res;
    }
}</pre>
<p>What is notable in this <a id="_idIndexMarker460"/>class is that:</p>
<ol>
<li>Every method returns the class instance. This helps to chain methods like this:<pre>OneCallResponse res = new OneCallResponseBuilder()
    .SetDays(7)
    .SetTemps(new []{ 0, 3.3, 0, 0, 0, 0, 0 })
    .Build();</pre></li>
<li>The <code>Build()</code> method will combine all the configurations together to return a usable object.</li>
</ol>
<p>The refactored <code>Arrange</code> of the previous unit test looks like this:</p>
<pre class="source-code">// Arrange
OneCallResponse res = new OneCallResponseBuilder()
    .SetTemps(new []{ 0, 3.3, 0, 0, 0, 0, 0 })
    .Build();
_clientMock.OneCallAsync(Arg.Any&lt;decimal&gt;(),  
    Arg.Any&lt;decimal&gt;(), Arg.Any&lt;IEnumerable&lt;Excludes&gt;&gt;(),
    Arg.Any&lt;Units&gt;())
    .Returns(res);</pre>
<p>The preceding code takes advantage of the builder class that we created earlier. You can see the code clearly setting the next day’s temperature as 3.3 degrees.</p>
<p>Using SUT constructor<a id="_idIndexMarker461"/> initialization and the builder pattern are just a few examples of making your unit tests readable.</p>
<p>You can find the refactored class in <code>WeatherForecastTestsReadable.cs</code> and the original in <code>WeatherForecastTestsLessReadable.cs</code> in the companion source code.</p>
<p><em class="italic">Readability promotes the healthy growth of your unit test’s codebase. Keep it in check from day one.</em></p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor157"/>The Single-Behavior guideline</h1>
<p>Every unit test <a id="_idIndexMarker462"/>should test one and only one behavior. Throughout this book, this concept has been enforced naturally by:</p>
<ul>
<li>The naming of the unit test method’s signature, which reflects one condition with one expectation</li>
<li>A single AAA structure that enforced a single <code>Act</code> </li>
</ul>
<p>Before digging further, I would like to define the word <em class="italic">behavior</em>.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor158"/>What is behavior?</h2>
<p>The definition of <a id="_idIndexMarker463"/>behavior varies in the industry, so it is important to set an accurate one for the context of this book. Each SUT is supposed to do something. A SUT does this <em class="italic">thing</em> by:</p>
<ul>
<li><strong class="bold">Communicating with dependencies</strong>: Communication can be by calling a method on a dependency or setting a field or a property – this is referred to as <em class="italic">external behavior</em>.</li>
<li><code>Exception</code> or the return value (if a method is not a <code>void</code> or a <code>Task</code> method) – this is also referred to as <em class="italic">external behavior</em>.</li>
<li><strong class="bold">Plumbing all together</strong>: Doing various commands in preparation to receive the input, in preparation for the output (the return value), or in preparation for communicating with a dependency – this is referred to as the <em class="italic">internals</em> of the SUT, or <em class="italic">internal behavior</em>.</li>
</ul>
<p>External behavior <a id="_idIndexMarker464"/>propagates across the system, as it is touching other dependencies, while internal behavior is encapsulated in the SUT and not shown to the outside world.</p>
<p>When we use the word <em class="italic">behavior</em> on its own, we mean <em class="italic">external behavior</em>, so the Single-Behavior guideline refers to single external behavior. As usual, definitions seem more complicated than they are, so let’s fortify this definition with an example.</p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor159"/>Example of behavior</h2>
<p>Let’s take this code<a id="_idIndexMarker465"/> from the <strong class="bold">Weather Forecasting App</strong> (<strong class="bold">WFA</strong>) that was<a id="_idIndexMarker466"/> introduced in <a href="B18370_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding Dependency Injection by Example</em>:</p>
<pre class="source-code">public async Task&lt;IEnumerable&lt;WeatherForecast&gt;&gt; GetReal()
{
    const decimal GREENWICH_LAT = 51.4810m;
    const decimal GREENWICH_LON = 0.0052m;
    OneCallResponse res = <strong class="bold">await _client.OneCallAsync</strong>
     <strong class="bold">(GREENWICH_LAT, GREENWICH_LON, new[]{Excludes.Current,   </strong>
     <strong class="bold">Excludes.Minutely, Excludes.Hourly, Excludes.Alerts},</strong>
     <strong class="bold">Units.Metric);</strong>
    WeatherForecast[] wfs = new 
        WeatherForecast[FORECAST_DAYS];
    for (int i = 0; i &lt; wfs.Length; i++)
    {
        var wf = wfs[i] = new WeatherForecast();
        wf.Date = res.Daily[i + 1].Dt;
        double forecastedTemp = res.Daily[i + 1].Temp.Day;
        wf.TemperatureC = (int)Math.Round(forecastedTemp);
        wf.Summary = MapFeelToTemp(wf.TemperatureC);
    }
    <strong class="bold">return wfs;</strong>
}
private string MapFeelToTemp(int temperatureC)
{
    …
}</pre>
<p>In the preceding code, the external behaviors are all in the <code>_client.OneCallAsync</code> call and in the <code>return</code> statement. The rest of the code is all internal. You can think of the internal code’s role as preparing to trigger the <code>_client</code> dependency and to return a value. </p>
<p>The internal behaviors are<a id="_idIndexMarker467"/> no longer relevant once these two external behaviors are triggered; they are executed and forgotten, while the external behaviors propagate to other services.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor160"/>Testing external behavior only</h2>
<p>If the role of internals is to<a id="_idIndexMarker468"/> prepare for external behavior only, then testing external behavior will cover testing the whole code. You can think of it as the internal code being tested is a by-product of testing the external behavior.</p>
<p>Here are some examples of unit testing the behavior (external behavior). These examples are fully implemented <a id="_idIndexMarker469"/>in the source code in <a href="B18370_03.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>, <em class="italic">Getting Started with Unit Testing</em> (<strong class="bold">WF</strong> stands for <strong class="bold">Weather Forecasting</strong>):</p>
<pre class="source-code">GetReal_NotInterestedInTodayWeather_WFStartsFromNextDay
GetReal_5DaysForecastStartingNextDay_
    WF5ThDayIsRealWeather6ThDay
GetReal_ForecastingFor5DaysOnly_WFHas5Days
GetReal_WFDoesntConsiderDecimal_RealWeatherTempRoundedProperly
GetReal_TodayWeatherAnd6DaysForecastReceived_
    RealDateMatchesLastDay
GetReal_TodayWeatherAnd6DaysForecastReceived_
    RealDateMatchesNextDay
GetReal_RequestsToOpenWeather_MetricUnitIsUsed
GetReal_Summary_MatchesTemp(string summary, double temp)</pre>
<p>After executing these tests that are targeting external behavior only, a code coverage tool will show that all the code<a id="_idIndexMarker470"/> that was demonstrated in the previous example is covered by our test. This includes the code in the <code>GetReal()</code> public method and the code in the <code>MapFeelToTemp()</code> private method. Let’s have a look at an example of code coverage:</p>
<div><div><img alt="Figure 5.1 – Lines covered by behavior tests " height="969" src="img/Figure_6.1_B18370.jpg" width="1380"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Lines covered by behavior tests</p>
<p>In the preceding figure, I have <a id="_idIndexMarker471"/>used a VS plugin called <strong class="bold">Fine Code Coverage</strong> (<strong class="bold">FCC</strong>) to show the lines that are <a id="_idIndexMarker472"/>covered by the selected tests to the right. It shows that all the code lines in the SUT were covered by these tests. We will discuss coverage and this plugin tool in more detail in <em class="italic">The Thoroughness guideline</em> section.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor161"/>Why not test internals?</h2>
<p>One common mistake<a id="_idIndexMarker473"/> in unit testing is when developers try to test the internals of a SUT. Here are a few problems with testing internals:</p>
<ul>
<li>The SUT is already covered when testing external behavior, so there’s no need to increase the number of unit tests, which will increase maintenance (liability).</li>
<li>Testing the internals will create tight coupling between the SUT and the tests, which will create brittle tests that will have to change often.</li>
<li>Internals are usually hidden behind non-public methods; to test them, the code needs to change to public, which violates OOP’s encapsulation.</li>
</ul>
<h2 id="_idParaDest-152"><a id="_idTextAnchor162"/>A single behavior per test</h2>
<p>Now that the definition of<a id="_idIndexMarker474"/> behavior is clear, we can clarify what testing a single behavior means. Testing a single behavior works alongside the Intention guideline. If we are targeting a single behavior, our test will promote a better intention and more readability, and when it fails, we are supposed to pinpoint the reason promptly.</p>
<p>Single-behavior testing is made up of a SUT, a single condition, a single expectation, and minimal assertions. The unit test signatures in the previous list (section: <em class="italic">Testing external behavior only</em>) are examples of targeting a single behavior. Also, all the examples in this book follow the same guidelines.</p>
<p><em class="italic">A unit test method should test a single behavior and never test internals.</em></p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor163"/>The Thoroughness guideline</h1>
<p>When unit testing some naturally<a id="_idIndexMarker475"/> occurring questions are as follows: </p>
<ul>
<li>How many tests are enough?</li>
<li>Do we have a test coverage metric?</li>
<li>Should we test third-party components?</li>
<li>What system components should we unit test and what should we leave?</li>
</ul>
<p>The Thoroughness guideline attempts to set the answers to these questions.</p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor164"/>Unit tests for dependency testing</h2>
<p>When you encounter a<a id="_idIndexMarker476"/> dependency, whether this dependency is part of your system or a third-party dependency, you create a test double for it and isolate it in order to test your SUT.</p>
<p>In unit tests, you do not directly call a third-party dependency; otherwise, your code will be an integration test and with that, you lose all the benefits of unit tests. For example, in unit tests, you do not call this:</p>
<p><code>_someZipLibrary.Zip(fileSource, fileDestination);</code></p>
<p>For testing this, you create a test double for the <code>.zip</code> library to avoid calling the real thing.</p>
<p>This is an area that unit tests do not and should not cover, which leaves us with a coverage issue as some areas of the code are not unit-testable.</p>
<p>To test the interaction with dependencies and solve the previous problem of not being able to unit test some code, other types of tests can be employed, such as Sintegration, integration, and acceptance tests.</p>
<p>We started to speak about <em class="italic">coverage</em>; now we can dig deeper into the topic.</p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor165"/>What is code coverage?</h2>
<p>The first step in understanding <a id="_idIndexMarker477"/>thoroughness is understanding <a id="_idIndexMarker478"/>code coverage. <strong class="bold">Code coverage</strong> is the percentage of the system code lines executed by your tests (unit, Sintegration, integration, and so on) from the total system lines. Let’s assume we have a method that returns if an integer is even:</p>
<pre class="source-code">public bool IsEven(int number)
{
    if(number % 2 == 0) return true;
    else return false;
}</pre>
<p>Let’s have a unit test that tests if a number is even:</p>
<p><code>public void IsEven_EvenNumber_ReturnsTrue() {…}</code></p>
<p>This unit test would have covered the <code>if</code> line but it wouldn’t have executed the <code>else</code> line. This constitutes 50% <a id="_idIndexMarker479"/>code coverage. Obviously, having another test to test an odd number would have led to 100% coverage.</p>
<p>It is important to realize that <a id="_idIndexMarker480"/>code coverage is not necessarily the unit test coverage only, but it might be a combination of unit tests, Sintegration tests, and integration tests. However, out of all tests, unit tests usually cover the biggest chunk of the code, as they are easier to write than other tests. Also, when using the TDD style, you get high coverage as soon as the feature is implemented, as all relevant unit tests are already supplied.</p>
<h3>Coverage measurement tools</h3>
<p>To measure how much of your code is <a id="_idIndexMarker481"/>covered by your tests, usually, you <a id="_idIndexMarker482"/>measure it in the <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) pipeline (which will be discussed in <a href="B18370_11.xhtml#_idTextAnchor265"><em class="italic">Chapter 11</em></a>, <em class="italic">Implementing Continuous Integration with GitHub Actions</em>, of the book) and/or on the development machine. There are plenty of commercial options for running test coverage and a limited number of free options. Here are a few examples:</p>
<ul>
<li>NCover – commercial</li>
<li>dotCover – commercial</li>
<li>NCrunch – commercial</li>
<li>VS Enterprise code coverage – commercial</li>
<li>SonarQube – commercial and community</li>
<li>AltCover – free</li>
<li>FCC – free plugin for VS</li>
</ul>
<p>If you want to see how code <a id="_idIndexMarker483"/>coverage works, you can install FCC by following these steps:</p>
<ol>
<li value="1">From the menu, select <strong class="bold">Extensions</strong> | <strong class="bold">Manage Extensions</strong> and the <strong class="bold">Manage Extensions</strong> dialog will open.</li>
<li>Select <strong class="bold">Online</strong> | <strong class="bold">Visual Studio Marketplace</strong>.</li>
<li>Search for <code>Fine Code Coverage</code> and then select <strong class="bold">Download</strong>.</li>
</ol>
<div><div><img alt="Figure 5.2 – Installing FCC dialog " height="750" src="img/Figure_6.2_B18370.jpg" width="1378"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Installing FCC dialog</p>
<ol>
<li value="4">Restart VS.</li>
</ol>
<p>After installation, you can open the project from <a href="B18370_03.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>, <em class="italic">Getting Started with Unit Testing</em> and execute all your unit tests (<strong class="bold">Test</strong> | <strong class="bold">Run All Tests</strong>). This tool will be triggered automatically after several seconds of executing the tests. To see the results, a panel like the following one<a id="_idIndexMarker484"/> will appear at the bottom of VS to show you the results:</p>
<div><div><img alt="Figure 5.3 – FCC analysis results " height="638" src="img/Figure_6.3_B18370.jpg" width="1581"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – FCC analysis results</p>
<p>If you can’t see this panel, you might need to go, from the menu, to <strong class="bold">View</strong> | <strong class="bold">Other Windows</strong> | <strong class="bold">Fine Code Coverage</strong>.</p>
<p>I am only interested in the production code cover, which is <code>Uqs.Weather</code> in this example. I can see that my total coverage is 55.2%.</p>
<p>We will speak further about the previous code coverage results in the next few sections.</p>
<h3>Unit test coverage spectrum</h3>
<p>Unit tests are excellent for <a id="_idIndexMarker485"/>testing the<a id="_idIndexMarker486"/> following:</p>
<ul>
<li>Business logic</li>
<li>Validation logic</li>
<li>Algorithms</li>
<li>Interaction between components (not to be confused with integration between components)</li>
</ul>
<p>On the other hand, unit tests are not optimal for testing the following:</p>
<ul>
<li>Integration between components – the call from component A passing through to component B, such as getting info from the database and analyzing the data</li>
<li>Service booting components – such as <code>Program.cs</code></li>
<li>Direct call to<a id="_idIndexMarker487"/> dependencies (dependency testing, as discussed earlier)</li>
<li>Wrappers <a id="_idIndexMarker488"/>wrapping real components – such as <code>RandomWrapper</code> in the following example:<pre>public interface IRandomWrapper
{
    int Next(int minValue, int maxValue);
}
public class RandomWrapper : IRandomWrapper
{
    private readonly Random _random = Random.Shared;
    public int Next(int minValue, int maxValue)
    {
        return <strong class="bold">_random.Next(minValue, maxValue);</strong>
    }
}</pre></li>
</ul>
<p>Unit tests should have no interest in testing anything in this class, as this is wrapping the real components directly.</p>
<p>Now, if we go back to the results of the code coverage, it is clear why we have 0% coverage for <code>Program.cs</code>, <code>NowWrapper.cs</code>, and <code>RandomWrapper.cs</code>. It is best that the code in these files is not tested by unit tests and we haven’t done that.</p>
<p><code>WeatherForecastController</code> is 80% covered. You can open the file to see what FCC highlights.</p>
<div><div><img alt="Figure 5.4 – Highlights from FCC " height="770" src="img/Figure_6.4_B18370.jpg" width="1381"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Highlights from FCC</p>
<p>It looks like not even a single line in <code>GetRandom</code> is tested as all are <em class="italic">red</em>. I might have not targeted this<a id="_idIndexMarker489"/> method in any of my tests. Obviously, having a complete method that is not tested would not have happened if I were<a id="_idIndexMarker490"/> using TDD; however, this is a method that comes with the VS sample code for the ASP.NET project.</p>
<p>Now that we understand what code coverage is and what can be covered, we can describe what being <em class="italic">thorough</em> in testing is.</p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor166"/>Being thorough</h2>
<p>Clearly, the best coverage<a id="_idIndexMarker491"/> level is 100%; or at least this should be the intention, but it is not easily achievable and sometimes, it isn’t worth the cost and effort to achieve it.</p>
<p>First, as discussed, unit tests are not meant to provide 100% coverage, so they need to be backed up by other categories of tests. If we want to achieve 100% coverage using unit tests, we will shoehorn unit tests to test things that are not best suited for unit tests.</p>
<p>Being thorough is doing <a id="_idIndexMarker492"/>a combination of unit testing, Sintegration testing, integration testing, and user acceptance testing.</p>
<h3>The cost, time, and quality triangle</h3>
<p>This is probably not the first <a id="_idIndexMarker493"/>time you’ve heard of this concept. It is a project management one and is not specific to software engineering. Here is the popular triangle: </p>
<div><div><img alt="Figure 5.5 – The cost, time, and quality triangle " height="594" src="img/Figure_6.5_B18370.jpg" width="992"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – The cost, time, and quality triangle</p>
<p><strong class="bold">Quality</strong> in our triangle represents how thorough we want to be. It is clearly a function of <strong class="bold">Time</strong> and <strong class="bold">Cost</strong>.</p>
<p>Testing, in general, is a time-consuming process and unit testing takes as much time, if not more, as writing production code. Unit tests are written by the same developers as the production code and they are not usually things that are done in parallel; they are done in series. The red-green-refactor process of TDD is done by the same individual or the team writing the code, not by a separate tester doing this in parallel.</p>
<h3>How thorough?</h3>
<p>Aiming for over 80% coverage is good. 95% coverage is the max you would be able to have with reasonable effort. This is only the case for the combination of unit testing with Sintegration or unit testing with integration. Acceptance testing does not usually count toward your coverage.</p>
<p>Being more thorough and aiming for higher coverage is a matter of more time and cost. So, the question of how much coverage is a question for project management and your team.</p>
<p><em class="italic">Being thorough is aiming for high coverage using a combination of unit tests with Sintegration tests or unit tests with integration tests. This is taking into consideration the time, money, and quality triangle.</em></p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor167"/>The High-Performance guideline</h1>
<p>Your unit tests should not take, in today’s hardware, over 5 seconds to run, ideally no more than a couple of seconds after the tests are loaded. But why all this fuss? Can’t we just let them take <a id="_idIndexMarker494"/>whatever time is needed to run without sweating over it?</p>
<p>First, your unit tests will have to run many times throughout the day. TDD is about running a chunk of your unit tests or all of them with every change; therefore, you don’t want to spend your time waiting and lose valuable time that could be spent more productively.</p>
<p>Second, your unit tests need to provide fast feedback to your CI pipeline. You want your source control branches to be green all the time, so that other developers are pulling green code at any given time and, of course, it is ready to ship to production. This is even more important for larger teams.</p>
<p>So, how do you keep your unit tests performing as fast as possible? We will attempt to answer this question in the next sections.</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor168"/>Integration as disguised units</h2>
<p>I have seen this in many <a id="_idIndexMarker495"/>projects, where developers call their integration tests unit tests just because they are executed by NUnit or xUnit. </p>
<p>Integration tests are slow by nature as they are doing IO operations, such as writing or reading from the disk, going to the database, and going over the network. These operations consume time<a id="_idIndexMarker496"/> and result in tests that take minutes or more to run.</p>
<p>Unit tests use test doubles and rely on memory and CPU to run. Running 10K unit tests should take seconds after project load, so <em class="italic">make sure you are not executing integration tests</em>.</p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor169"/>CPU- and memory-intensive unit tests</h2>
<p>You might be doing<a id="_idIndexMarker497"/> unit tests that rely on math libraries<a id="_idIndexMarker498"/> that are not treated as test doubles or you might have code that involves sophisticated logic.</p>
<p>You can have multiple categories of unit tests that can be executed at different times. xUnit calls this feature a <strong class="bold">trait</strong>. You can have a trait to indicate slow tests.</p>
<p><em class="italic">You can execute faster tests during your TDD and all tests before pushing to</em><em class="italic"> the codebase (source control).</em></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor170"/>Having too many tests</h2>
<p>Let’s assume that<a id="_idIndexMarker499"/> after becoming a TDD guru and reaching 100K tests, you start having tests that are taking over 5 seconds.</p>
<p>I would directly ask:</p>
<ul>
<li><em class="italic">Do you have a bloated monolith type of project?</em> </li>
<li><em class="italic">What is your problem: slow tests or a project that should be divided into microservices?</em></li>
</ul>
<p>A temporary solution for this issue is having multiple VS solutions and figuring out how to divide related projects into various solutions.</p>
<p><em class="italic">Having too many tests is a sign of weak architecture</em>. Employing an alternative architecture, such as microservices, can be considered and the unit tests problem may be sorted out automatically.</p>
<p><em class="italic">High-performance unit tests are something you strive for from day one and keep in check while building your project.</em></p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor171"/>The Automation guideline</h1>
<p>When we say <a id="_idIndexMarker500"/>automation, we mean CI. CI has a dedicated chapter in this book, <a href="B18370_11.xhtml#_idTextAnchor265"><em class="italic">Chapter 11</em></a>, <em class="italic">Implementing Continuous Integration with GitHub Actions</em>, so we won’t go into the details here.</p>
<p>This guideline is about realizing that the unit tests will run on other platforms than your local development machine. So, how do you make sure your unit tests are ready for automation?</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor172"/>CI automation from day 1</h2>
<p>Agile teams dedicate the<a id="_idIndexMarker501"/> first sprint to setting up the environment, including the CI pipeline. This is usually called sprint or iteration zero. If CI is set up from day 1 to listen to source control, there is less chance it is omitted or a CI-incompatible test is introduced.</p>
<p><em class="italic">Implement CI from the start of the project.</em></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor173"/>Platform-independent</h2>
<p>.NET is multi-platform and the trend nowadays is to use Linux servers to run CI pipelines. Also, the developer dev machine can be Windows, macOS, or Linux.</p>
<p><em class="italic">Make sure your code does not rely on any OS-specific features</em>, if not really needed, so that you can have a free choice of which OS to use for the CI pipeline.</p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor174"/>High performance on CI</h2>
<p>CI pipelines, nowadays, are <a id="_idIndexMarker502"/>leased services from CI providers such as Azure DevOps or GitHub Actions. These leased services are low in resources (CPU and memory) and are shared between multiple projects.</p>
<p>It is fair to say that tests will take double the time, if not more, to run on a CI pipeline in comparison to your local machine, assuming that you have a decent dev machine and you are not paying a fortune for your CI resources.</p>
<p>This reiterates the fact that having high-performing tests is necessary.</p>
<p><em class="italic">Make sure whatever test you write on your dev machine is ready to run on CI</em>.</p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor175"/>The No Interdependency guideline</h1>
<p>First, I would like to <a id="_idIndexMarker503"/>elevate this from a guideline to a principle. This principle ensures that the unit test does not alter a state permanently; or, in other words, executing a unit test should not persist data. Based on this principle, we have the following rules:</p>
<ul>
<li>Test A shouldn’t affect test B.</li>
<li>It doesn’t matter whether test A runs before test B.</li>
<li>It doesn’t matter whether we run test A and test B in parallel.</li>
</ul>
<p>If you think about it, a unit test is creating test doubles and doing its operations in memory, and as soon as it finishes execution, all the changes are lost, except the test report. Nothing is saved in the database, in a file, or anywhere, because these dependencies were all provided as test doubles.</p>
<p>Having this principle in place also ensures that the test runner, such as Test Explorer, can run the tests in parallel and use multi-threading if needed.</p>
<p>Ensuring this principle is a shared responsibility between the unit testing framework and the developer.</p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor176"/>Unit testing framework responsibility</h2>
<p>The unit testing framework<a id="_idIndexMarker504"/> should make sure that the unit test class is re-initialized after executing each unit test method. A unit test class should not maintain the state in the same way that a normal class maintains the state. Let me demonstrate with an example:</p>
<pre class="source-code">public class SampleTests 
{
    private int _instanceField = 0;
    [Fact]
    public void UnitTest1()
    {
        _instanceField += 1;
        Assert.Equal(<strong class="bold">1</strong>, _instanceField);
    }
    [Fact]
    public void UnitTest2()
    {
        _instanceField += 5;
        Assert.Equal(<strong class="bold">5</strong>, _instanceField);
    }
}</pre>
<p>When a unit testing framework runs <code>UnitTest1</code> and <code>UnitTest2</code>, it should not run them from the same object; it creates a new object for each method run. This means that they do not share instance fields. Otherwise, if <code>UnitTest1</code> runs before <code>UnitTest2</code>, then we<a id="_idIndexMarker505"/> should be asserting for <code>6</code>.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">Modifying an instance field in a method, then asserting it in the same method, is not a good unit testing practice, but it has been done for demonstration purposes.</p>
<p>xUnit does follow this principle of making sure the state is not shared. However, it can be instructed otherwise by using a static member.</p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor177"/>Developer’s responsibility</h2>
<p>As a developer, you<a id="_idIndexMarker506"/> know that you should not persist data during a unit test. Otherwise, this is, by definition, not a unit test.</p>
<p>If a developer is using test doubles to replace the database, the network, and other dependencies, they are respecting this rule by virtue. However, the problem arises if the developer decides to use static fields. Static fields will preserve the state between independent method calls. Let’s take this example:</p>
<pre class="source-code">public class SampleTests 
{
    private static int _staticField = 0;
    [Fact]
    public void UnitTest1()
    {
        _staticField += 1;
        Assert.Equal(<strong class="bold">1</strong>, _staticField);
    }
    [Fact]
    public void UnitTest2()
    {
        _staticField += 5;
        Assert.Equal(<strong class="bold">6</strong>, _staticField);
    }
}</pre>
<p>The previous code fails this rule, as running <code>UnitTest2</code> before <code>UnitTest1</code> will fail the test. Actually, there is no guarantee that the second method will run after the first one based on their order in the class.</p>
<p>There are instances<a id="_idIndexMarker507"/> where using static fields would promote better performance. Say we have an in-memory read-only database that we need to use in all tests. Also assume that this is taking a long time to initialize, such as 100 ms:</p>
<pre class="source-code">private readonly static InMemoryTerritoriesDB = 
   GetTerritories();</pre>
<p>The field is read-only and the content of the class is also read-only, such as <code>readonly record</code>. Although, for this scenario, I argue if you need all the territories, or can you create a cutdown version suitable for unit testing? This might speed up loading and can remove the need for a static field.</p>
<p>As a developer, you should be careful not to create a state between multiple unit tests. This is easy to miss if you are new to the unit testing field.</p>
<p><em class="italic">No interdependency leads to easier-to-maintain code and reduces bugs in unit tests.</em></p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor178"/>The Deterministic guideline</h1>
<p>A unit test should <a id="_idIndexMarker508"/>have a deterministic behavior and should lead to the same result. This should be the case regardless of the following:</p>
<ul>
<li><strong class="bold">Time</strong>: This includes changes in time zone and testing at different times.</li>
<li><strong class="bold">Environment</strong>: Such as the local machine or CI/CD server.</li>
</ul>
<p>Let’s discuss some cases where we risk making non-deterministic unit tests.</p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor179"/>Non-deterministic cases</h2>
<p>There are cases that can <a id="_idIndexMarker509"/>lead to non-deterministic unit tests. Here are a few of them:</p>
<ul>
<li>Having interdependent unit tests, such as a test that writes to a static field.</li>
<li>Loading a file with an absolute path as the file location on the development machine will not match that on the automation machine.</li>
<li>Accessing a resource that requires higher privileges. This can work, for example, when running VS as an admin but may fail when running from a CI pipeline.</li>
<li>Using randomization methods without treating them as dependencies.</li>
<li>Depending on the system’s time without treating it as a dependency.</li>
</ul>
<p>Next, we will see a case of not depending on varying time, to make our unit test deterministic.</p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor180"/>Example of freezing time</h2>
<p>If your test relies on time, you<a id="_idIndexMarker510"/> should be using a test double to freeze the time to ensure a deterministic test. Here is an example:</p>
<pre class="source-code">public interface INowWrapper
{
    DateTime Now { get; }
}
public class NowWrapper : INowWrapper
{
    public DateTime Now =&gt; DateTime.Now;
}</pre>
<p>This is a wrapper to allow injecting the current time as a dependency. To register the wrapper in <code>Program.cs</code>:</p>
<pre class="source-code">builder.Services.AddSingleton&lt;INowWrapper&gt;(_ =&gt; new 
    NowWrapper());</pre>
<p>Your service can look like this:</p>
<pre class="source-code">private readonly INowWrapper _nowWrapper;
public MyService(INowWrapper nowWrapper) 
{
    _nowWrapper = nowWrapper;
}    
public DateTime GetTomorrow() =&gt;
    _nowWrapper.Now.AddDays(1).Date;</pre>
<p>The calculation in the <a id="_idIndexMarker511"/>preceding code is for demo purposes and does not take into account daylight saving. To inject the current time from the unit tests:</p>
<pre class="source-code">public void GetTomorrow_NormalDay_TomorrowIsRight()
{
    // Arrange
    <code>var today = new DateTime(2022, 1, 1);</code>
    var expected = new DateTime(2022, 1, 2);
    var nowWrapper = Substitute.For&lt;INowWrapper&gt;();
    nowWrapper.Now.Returns(today);
    var myService = new MyService(nowWrapper);
    // Act
    var actual = myService.GetTomorrow();
    // Assert
    Assert.Equal(expected, actual);
}</pre>
<p>The previous unit test has frozen the current time to a specified value. This made the code independent from the OS’s clock and thus made it deterministic.</p>
<p><em class="italic">Running a unit test should always yield the same results, regardless of time or environmental factors.</em></p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor181"/>Summary</h1>
<p>FIRSTHAND accumulates valuable guidelines and best practices in the industry. I trust this chapter topped up the learnings of the previous chapters to help you understand TDD and its ecosystem. I also hope that it made these guidelines memorable as TDD comes up often in developer discussions and it is certainly likely to be an interview topic.</p>
<p>This chapter marks the end of this section, where we looked at dependency injection, unit testing, and TDD. This section was only an introduction to TDD, with scattered small and mid-size examples. If you’ve made it to this point, then hats off, you have covered the basics of TDD. </p>
<p>The next section will take all the basics and apply them to more lifelike scenarios. To make sure that you are ready for this application and to mimic a realistic application that uses TDD, our next chapter will be about <strong class="bold">domain-driven design</strong> (<strong class="bold">DDD</strong>) as you will be using the DDD concepts in later chapters. </p>
</div>
</div>


<div><div><h1 id="_idParaDest-172"><a id="_idTextAnchor182"/>Part 2: Building an Application with TDD</h1>
<p>TDD is usually combined with a <strong class="bold">Domain-Driven Design</strong> (<strong class="bold">DDD</strong>) architecture. In this part, we will take what we’ve learned in <em class="italic">Part 1</em> and use it to build a complete application using TDD and DDD; in one instance, we will use a relational DB (<a href="B18370_09.xhtml#_idTextAnchor226"><em class="italic">Chapter 9</em></a>), and in another, a document DB (<a href="B18370_10.xhtml#_idTextAnchor245"><em class="italic">Chapter 10</em></a>) to show how this would affect our unit test implementation. </p>
<p>By the end of this part, you should be able to build an application using TDD and DDD from scratch. The following chapters are included in this part:</p>
<ul>
<li><a href="B18370_07.xhtml#_idTextAnchor183"><em class="italic">Chapter 7</em></a>, <em class="italic"> A Pragmatic View of Domain-Driven Desig</em></li>
<li><a href="B18370_08_RN.xhtml#_idTextAnchor209"><em class="italic">Chapter 8</em></a>, <em class="italic">Designing an Appointment Booking App</em></li>
<li><a href="B18370_09.xhtml#_idTextAnchor226"><em class="italic">Chapter 9</em></a>, <em class="italic">Building an Appointment Booking App with Entity Framework and Relational DB</em></li>
<li><a href="B18370_10.xhtml#_idTextAnchor245"><em class="italic">Chapter 10</em></a>, <em class="italic">Building an App with Repositories and Document DB</em></li>
</ul>
</div>
<div><div></div>
</div>
</div>
</body></html>