- en: Testing and Deploying – The Let's Chat Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we developed the authentication module of our Let''s
    Chat web application. In this chapter, we will develop the Chat hub module using
    SignalR and wrap up the coding of our web application. After that, we will have
    a demonstration of how it works, and learn to test and deploy it. We will learn
    about Docker containers and how they may be helpful. Finally, we will develop
    an ASP.NET Core-based Chatbot and integrate it with the Let''s Chat application
    and Facebook. The motivation behind this chapter is to understand the testing
    deployment model of .NET Core applications, the Live Unit Testing feature of Visual
    Studio 2017, and containers, and get a sneak peek into developing a simple Bot,
    based on the Microsoft Bot Framework. In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Chat hub module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bot 101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chat hub module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the authentication module in place, a user can log in to our
    Let's Chat web application using Facebook. We still need to develop the Chat module
    so that the user can see their friends online and chat with them. In this section,
    we will develop the Chat hub module using SignalR. We have already developed a
    Tic-Tac-Toe game using SignalR. Hence, we are already familiar with how to develop
    a SignalR hub and get the communication going back and forth between clients and
    server, so this should be relatively easier for us. On the client side, we will
    make use of Razor pages. ASP.NET Core 2.0 introduced a new feature called Razor
    pages, which makes the coding of page-focused scenarios much easier. If you have
    worked on earlier versions of ASP.NET, you will have seen or heard about ASP.NET
    Web forms (`.aspx`) applications, which had web forms at the heart of development.
    This is more or less on the same lines in the MVC world and makes it really productive
    to develop quick demos and **proof of concepts** (**PoCs**). We will quickly do
    a detour through Razor, views, and Razor pages, and then jump into the coding
    of the Chat hub module.
  prefs: []
  type: TYPE_NORMAL
- en: View, in a **Model-View-Controller** (**MVC**) pattern, handles the application
    data presentation and user interaction. Specifically, in the context of ASP.NET
    MVC, View is just an HTML template with Razor markup. Razor markup... huh!  Let's
    have a look at the Razor primer, before we understand View.
  prefs: []
  type: TYPE_NORMAL
- en: Razor primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Razor is a markup syntax for embedding server-based code in a web page. Developers
    familiar with PHP will find themselves at home while working with Razor, as the
    syntax is very similar. Razor syntax consists of Razor markup, C#, and HTML. Since
    it contains C# as well as HTML, files containing Razor syntax generally have a
    `.cshtml` extension. The `@` symbol is of great importance in Razor syntax and
    it is used to transition from HTML to C#. OK! But how does Razor work?  A `.cshtml`
    file can have Razor, C#, and HTML. The server first runs the Razor markup and
    C#, which ultimately would translate into HTML that the browser can understand
    and render. This HTML is then combined with the remaining HTML content and sent
    back to the browser. The following are reserved keywords in Razor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`functions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inherits`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`model`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`section`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Language-specific keywords (for C# in `.cshtml` and VB in `.vbhtml`) remain
    as-is in Razor code blocks, and hence are not given special mention. It must be
    noted that when an `@` symbol is followed by a Razor reserved keyword, it gets
    translated into Razor-specific markup; otherwise, it transitions into plain C#.
     Let''s have a quick look at the Razor syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Point to learn** | **Example** | **Remarks** |'
  prefs: []
  type: TYPE_TB
- en: '| `@` with Razor reserved keyword | `@model``@page` | When an `@` symbol is
    followed by a Razor reserved keyword, it transitions into Razor-specific markup.
    Otherwise, it transitions into plain C#. |'
  prefs: []
  type: TYPE_TB
- en: '| Escape `@` character | `<span>@@Name</span>` is rendered in HTML as `<span>@Name</span>`
    | The HTML attributes and content containing email addresses don''t treat `@` as
    a transition character. To escape an `@` symbol in Razor markup, use a second `@` symbol.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Implicit Razor expression | `<p>@DateTime.Now</p>` | `@` followed by C# code.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Spaces not allowed | `@DateTime.Now - TimeSpan.FromDays(2)` | Rendered as
    `29/12/2017 – TimeSpan.FromDays(2)` as there are spaces between. |'
  prefs: []
  type: TYPE_TB
- en: '| Generics are *not* supported | `<p>@SomeMethod<int>()</p>` | `<>` would be
    interpreted as an HTML tag, hence not supported in implicit expression. |'
  prefs: []
  type: TYPE_TB
- en: '| Explicit Razor syntax | `@(DateTime.Now.AddDays(1))` | Any content inside
    `@()` brackets is evaluated and rendered to output. |'
  prefs: []
  type: TYPE_TB
- en: '| Expression encoding | `@("<span>Hello DotNet 2.0 By Example</span>")` | Renders
    the HTML as `&lt;span&gt;Hello DotNet 2.0 By Example&lt;/span&gt;`, which is shown
    in the browser as `<span>Hello DotNet 2.0 By Example</span>`. |'
  prefs: []
  type: TYPE_TB
- en: '| Without expression encoding | `@Html.Raw("<span> Hello .NET Core 2.0 </span>")`is
    rendered as `<span>Hello .NET Core 2.0</span>` | This results in security vulnerabilities
    such as malicious user input and cross site scripting and hence must be used with
    the utmost care. Make a rule of thumb to avoid using `@Html.Raw` unless you are
    110% sure that it can under no circumstances compromise on security and would
    never be user input. |'
  prefs: []
  type: TYPE_TB
- en: '| Razor code blocks | `@{``ViewData["Title"] = "Let''s Chat";``}` | Razor code
    blocks start with `@` and are enclosed by` {}`. Unlike expressions, C# code inside
    code blocks isn''t rendered.  |'
  prefs: []
  type: TYPE_TB
- en: '| Explicit line transition | `@:Name: @User.Name`would render as `Name: <<Value
    of User.Name>>` | To render the rest of an entire line as HTML inside a code block,
    use the` @:` syntax. |'
  prefs: []
  type: TYPE_TB
- en: '| `@If-else if-else` | `@if (condition){``}else if (some condition) {``} else
    { }` | `@` is needed only before starting `if`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@switch` | `@switch(value)``{ case 1:break;default:break;}` | Simple syntax
    for `switch` case. |'
  prefs: []
  type: TYPE_TB
- en: '| `@for` | `@for (var i = 0; i < array.Length; i++){}` | Use `@for`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@foreach` | `@foreach (var item in array) {}` | Use `@foreach`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@while` | `@{var i=0;}``@while (i < array.Length) {}` | Use `@while`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@do while` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '| Use `@do...while`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@using` | `@using (Html.BeginForm()) {``@* Entire form content *@}@using
    System.Linq` | Used to create HTML helpers that contain additional content. The
    example renders a form tag.Can also be used as a `using` directive and it adds
    the C# `using` directive to the generated view.  |'
  prefs: []
  type: TYPE_TB
- en: '| `@try`, `catch`, `finally` | `@try{}``catch(Exception ex){}``finally{}` |
    use `@try` and similar to C# syntax. |'
  prefs: []
  type: TYPE_TB
- en: '| `@lock` | `@lock(syncLock)``{// DO critical work here}` | Same as C#, to
    protect the critical region. Use `@lock.` |'
  prefs: []
  type: TYPE_TB
- en: '| Comments |'
  prefs: []
  type: TYPE_TB
- en: '`<!-- HTML Comment-->`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/* C# Comment */// C# comment`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@* Razor multiline comment *@`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Razor supports both HTML and C# comments. |'
  prefs: []
  type: TYPE_TB
- en: '| `@model` | `@model HomeViewModel` | The `@model `directive specifies the
    type of the model passed to a view and is used extensively in strongly typed views.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@inherits` | `@inherits BaseRazorPage`Now the view will have access to all
    the protected and public properties, fields and methods of the `BaseRazorPage`
    class | `@inherits` directive provides full control of the class the view inherits.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@inject` | `@inject IHtmlLocalizer` | The `@inject` directive enables the
    Razor page to inject a service from the service container into a view. |'
  prefs: []
  type: TYPE_TB
- en: '| `@functions` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`<div> Current Time : @GetTime()</div>` | The `@functions` directive enables
    a Razor page to add function-level content to a view. |'
  prefs: []
  type: TYPE_NORMAL
- en: '| `@section` | `@section Scripts { <script type="text/javascript" src="img/main.js"></script>
    }` | The `@section` directive is used in conjunction with the layout page to enable
    views to render contents in different parts of the HTML page such as  header,
    footer, body, and so on. |'
  prefs: []
  type: TYPE_TB
- en: Tag Helpers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tag Helpers are a new feature introduced in ASP.NET Core that enables server-side
    code to participate in creating and rendering HTML elements in Razor files. Tag
    Helpers are C# classes that participate in view generation by manipulating HTML
    elements. By using Tag Helpers, we can add additional attributes to HTML elements,
    change the content, or replace them entirely. In simple terms, Tag Helper''s code
    that helps us to build our `.cshtml` forms without needing to write Razor syntax.
    For example, if we were to write an anchor tag in Razor we would write it like:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Html.ActionLink("Read my book", "Read", "Book") `'
  prefs: []
  type: TYPE_NORMAL
- en: 'where `Read` is the action in `Book` controller and the text between anchor
    tag would be `"Read my book"`. Using Tag Helper, it becomes very easy to write
    the same anchor tag as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is both very easy to write as well as easy to understand, and looks more
    neat and easily maintainable as well, as it looks like HTML. Visual Studio has
    great tooling support for Tag Helpers and it highlights all the HTML elements
    that use Tag Helpers, thus making it easier to identify them and also provide
    rich intellisense to explore and use them as needed. Notice that all the Tag Helper
    attributes start with `asp-` and their naming is self-explanatory. There are a
    number of inbuilt Tag Helpers that come with the framework and writing a new one
    is also pretty straightforward. Let''s have a quick look at a few inbuilt Tag
    Helpers and then we will conclude this discussion by creating one custom Tag Helper
    as well. The following table lists a few of the inbuilt Tag Helpers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tag Helper** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| Anchor | `<a asp-action="Index" asp-controller="Home">Back to Home</a>` anchor
    Tag Helper has few other properties that could be set, such as `asp-fragment`,
    `asp-route`, `asp-path`. This defines the anchor tag.  |'
  prefs: []
  type: TYPE_TB
- en: '| Label | `<label asp-for="Name"></label>` defines a label for a control. |'
  prefs: []
  type: TYPE_TB
- en: '| Input | `<input type="text" asp-for="Name"/>`Earlier we used to have multiple
    Razor helpers for different types of input (`checkbox`, `select`, `radio`, `text`).
    Now we have just two helper attributes `asp-for` and `asp-format`. |'
  prefs: []
  type: TYPE_TB
- en: '| Form | `<form asp-action="Create" asp-anti-forgery="true" asp-controller="Person"></form>``action`
    and `controller` are defined, as well as the `ValidateAntiForgeryToken` is taken
    care of ! Wonderful! |'
  prefs: []
  type: TYPE_TB
- en: '| Text area | `<textarea asp-for="Description"></textarea>`. |'
  prefs: []
  type: TYPE_TB
- en: '| Select | `<select asp-for="SelectedBook" asp-items="Model.Books"></select>`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Image | `<img src="img/image.png" alt="profile image" asp-append-version="true"/>`Used
    for cache-busting the image as the Tag Helper appends the hash of the image as
    the query string parameter such as `<img src="img/image.png?v=Z6p6D366_nQ2fQqUso0F24gWy2ZekXjHz83WvYbaiOOk"
    alt="profile image"/>`. |'
  prefs: []
  type: TYPE_TB
- en: '| Cache | `<cache expires-after="@TimeSpan.FromMinutes(5)"></cache> `The content
    inside the `cache` tag is cached in server memory unless explicitly disabled.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Link and Script | These are the most interesting Tag Helpers of the lot as
    they have cache busting as well as fallback mechanisms implemented in them, such
    as  `<link rel="stylesheet" href="//ajax.aspnetcdn.com/ajax/bootstrap/3.0.0/css/bootstrap.min.css"
    asp-fallback-href="~/lib/bootstrap/css/bootstrap.min.css" asp-fallback-test-class="hidden"
    asp-fallback-test-property="visibility" asp-fallback-test-value="hidden" />`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Validation | `<span asp-validation-for="Description"></span>`. |'
  prefs: []
  type: TYPE_TB
- en: '| Environment | `<environment names="Staging,Production"></environment>`.This
    is a special helper as contents of helper gets rendered only if the deployed environment
    name matches the names property of the Environment tag.  |'
  prefs: []
  type: TYPE_TB
- en: 'As we can see, Tag Helpers provide a great boost in productivity while coding `.cshtml`
    files. The Visual Studio tooling with IntelliSense makes this experience even
    more efficient. In ASP.NET Core 2.0, Application Insights is also enabled by using
    a Tag Helper in the background. Next let''s create a custom Tag Helper. Creating
    a custom Tag Helper needs these steps to be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a custom class which derives from the `Microsoft.AspNet.Razor.TagHelper.TagHelper`
    class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the properties in the class to hold the attribute values
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restrict the Tag Helper to be applicable only to a certain type of HTML element
    by decorating the class with the `HtmlTargetElement` attribute
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `ProcessAsync` method and set the attributes as needed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a line to `_ViewImports.cshtml` for the Razor views to recognize the Tag
    Helpers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we are not using Tag Helpers right now, we will not go into details, but
    as we can see, it's quite straightforward and easy. Now that we have visited the
    fundamentals of Razor syntax and Tag Helpers, we will quickly recap views.
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the MVC pattern, a View is meant to display the application data to the
    user and handle user interaction. View helps us to implement the separation of
    concern design principle in MVC applications, by separating the user interface
    from business logic. It is an HTML page with additional Razor markup apart from
    the HTML markup, as we have seen earlier in this chapter. The `.cshtml` files
    are Views and treated as web pages. For example, if we create a simple MVC application,
    it creates a View under the `Views` folder and each View is associated with a
    controller. In the following example, `HomeController` is calling three Views—`Index`,
    `About`, and `Contact` . Inside the `Views` folder, we have a sub-folder with
    the controller name (`Home`) and this folder contains all views used in `HomeController`.
    This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f98c1128-2b21-400b-aee0-c185593b741d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The most commonly used components of Views are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Layouts**: These are like the master page and are used to maintain consistency
    among all web pages. For example, we see common content used in all the pages
    such as header, footer, menu, and so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Partial views**: Partial Views are useful for re-usability. If we have some
    content which needs to be displayed in more than one screen, or if we have a page
    which doesn''t have any logic or code to execute and has only content to display,
    we can have them as partial Views.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**View Components**: These are similar to partial Views and help us to reuse
    the code, but the difference is that a partial View only binds the model, and
    View components can interact with data and business logic, as they have a mini
    controller. A common example of a View component is the shopping cart of any e-commerce
    website. It renders content using database interaction.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will look into a new feature introduced in ASP.NET Core 2.0 called
    Razor pages.
  prefs: []
  type: TYPE_NORMAL
- en: Razor pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Razor pages are lightweight pages with the added functionality of handling
    requests directly without a controller. This makes them extremely useful to create
    a quick application, or a proof of concept or for presenting cool demonstrations
    to an audience. To make a View page into a Razor page, we need to add the `@page`
    directive. It should be the first directive on the page. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Razor pages are useful when we need a View with small logic. For smaller logic,
    the return on investment would be better for Razor pages than that for creating
    a controller, actions, and view. In Razor pages, we can add logic inside the page
    or we can simply create code behind `page.cshtml.cs`, to write code. The question
    that came to my mind is: *Are we moving forward, or moving back to the web form
    code-behind world?*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a Razor page is very simple. Right-click on the project and click
    Add | New Item and select Razor Page, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4e2acfa-8214-4f03-9c82-392698964287.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, the `DemoRazorPage.cshtml` has `DemoRazorPage.cshtml.cs` and
    `DemoRazorPageModel` associated with it. We can go ahead and write code as needed,
    without needing to worry about creating a controller, then its action methods,
    and finally adding a view in the specific location. Super productive!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92d9ff34-324d-4fea-bab5-9c08798c8f69.png)'
  prefs: []
  type: TYPE_IMG
- en: In the  image, `DemoRazorPage.cshtml` file is the Razor page, and `DemoRazorPage.cshtml.cs`
    is the code behind the file of the Razor page, which uses `DemoRazorPageModel`
    as the model.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have touched upon all the basic and most frequently used features
    of ASP.NET Core. We will now move on to code the Chat hub module.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Chat hub module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s code the Chat hub module for our Let''s Chat web application. We
    have already seen how to create a simple real-time web application using SignalR,
    while developing a Tic-Tac-Toe game, so we would not spend much time on things
    we have already seen. Recall that we already have authentication implemented using
    Facebook and we have user details, such as the display name and profile picture.
    We need to develop the following as part of our Chat hub module:'
  prefs: []
  type: TYPE_NORMAL
- en: List all online users connected to the Chat hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the online list of users, as and when someone joins or leaves the chat
    room
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any chat message sent in the room goes to all the connected users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Quite clearly, to meet these requirements, we would need to track the users,
    so that a connected user shows in the online list and disappears from the list
    when they leave the chat room. We would first create a class named `UserInformation`
    to hold the user details such as `name`, display picture URL (`imageURL`), and
    `connection identifier`, as defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create an interface named `IUserTracker` with three methods for
    user tracking:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Get all online users**: This would be used to display all the users that
    are connected to the chat'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Add user**: This would be used to add a user-to-user tracker data store and
    should be called when a user joins the chat room'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remove user**: This would be used to remove a user from the user tracker
    data store and should be called when a user leaves the chat room'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code is as shown here and the comments should make the code comprehensive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We created an interface so that we could leverage Dependency Injection to inject
    the user tracking component, wherever we need it. Though we have worked with SignalR
    already, we have not come across the `HubConnectionContext` class, which we have
    used in the interface. So, let''s have a quick look at it. The `HubConnectionContext`
    class resides in the `Microsoft.AspNetCore.SignalR.Core` assembly under the `Microsoft.AspNet.SignalR`
    namespace. It encapsulates all the information about a SignalR connection. The
    following code map diagram shows the `HubConnectionContext` class and its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10caa2c6-74e0-44c4-a67b-828e6bdf1b27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code is as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There would be an extension method to get the `HttpContext` from `HubConnectionContext`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `HubConnectionContext` class to keep track of the user and connection
    in our `UserTracker` class, which we will implement next. Let''s implement the
    `IUserTracker` interface in our `UserTracker` class, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, our user tracker component is created. It has a backup store (concurrent
    dictionary), where we will add the connection and user details when a user joins
    the chat room, and remove the entry from it when the user leaves the chat room.
    We can keep the concurrent dictionary as `static` as well, but we will use dependency
    registration to register our `UserTracker` class as a singleton, so we can be
    sure that the same instance of class would be used for all the user connections.
    To register our `UserTracker` as a singleton, we would write the following lines
    of code in the `ConfigureServices` method of the `Startup.cs` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will code the Chat hub, which will use the `UserTracker` class, and
    SignalR goodness to complete our chat room.  To do so, let''s create a class named
    `ChatHub` derived from the `Hub` class, with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There are important points to note here:'
  prefs: []
  type: TYPE_NORMAL
- en: The class `ChatHub` derives from the `Microsoft.AspNetCore.SignalR.Hub` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class `ChatHub` is decorated with the `[Authorize]` attribute, which means
    only an authenticated and authorized user can access the hub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constructor of `ChatHub` uses `IUserTracker` as a dependency, which would
    be injected through Dependency Injection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Microsoft.AspNetCore.SignalR.Hub` class has a property called `Context`
    of type `HubCallerContext`, which contains the SignalR connection identifier,
    user claim information, and `HubConnectionContext`. We can leverage the `Context`
    property to extract the user information from our Chat hub. To do so, we would
    need a helper/extension method, which takes in `HubCallerContext` and returns
    the `UserInformation` object that we created earlier. The following code snippet
    shows a helper class, which contains a method to translate the `HubCallerContext`
    to `UserInformation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With this structure, we are now in a position to track online users, as and
    when they join or leave our chat room, by overriding the `OnConnectedAsync` and
    `OnDiconnectedAsync` virtual methods, which are exposed by the `Microsoft.AspNetCore.SignalR.Hub`
    class. We would also need to add an additional method to fetch a list of all the
    connected users. We can do this easily by writing the following code in our `ChatHub`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is simple to understand. However, for the sake of clarity and completeness,
    we will do a quick walk-through of the preceding code. There are four methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetOnlineUsersAsync`: This method returns all the online users as stored in
    the `UserTracker` store. This method would be used to display online users in
    the chat room page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnConnectedAsync`: This method is fired when a user connects to the Chat hub,
    that is, joins the chat room. In this method, we first fetch the user information
    by calling the `Helper` class method, `GetUserInformationFromContext,` passing
    the `Context` property of hub, which contains information about the current connection.
    After getting the user information, we add the connection and user information
    in the `UserTracker` store. Next, we need to notify all connected clients that
    a new user is now available for chat, so we fire the `UsersJoined` method on all
    the clients. We will see this method in a short while. This method takes an array
    of `UserInformation` as a parameter. This way, we can display to all the connected
    clients that a new user has joined the chat room. Finally, we need to update the
    list displaying the online users, so we invoke the client method, `SetUsersOnline`,
    on all the connected clients, passing in the list of connected users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnDisconnectedAsync`: This method is the exact opposite of the `OnConnectedAsync`
    method and is fired when a user disconnects from the Chat hub, that is, leaves
    the chat room. In this method, we first fetch the user information by calling
    the `Helper` class method, `GetUserInformationFromContext`, passing the `Context`
    property of hub, which contains information about the current connection. After
    getting the user information, we need to notify all the connected clients that
    the user is no longer available for chat, so we fire the `UsersLeft` method on
    all the clients. We will see this method in a short while. This method takes an
    array of `UserInformation` as a parameter. This way, we can display to all the
    connected clients that a user has left the chat room. Next, we remove the connection
    and user information from the `UserTracker` store. Finally, we need to update
    the list displaying the online users, so we invoke the client method, `SetUsersOnline`,
    on all the connected clients, passing in a list of connected users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Send`: The last method that we see is called `Send`. As the name suggests,
    this method is used to send the message to all the connected clients, along with
    the username and image URL. In this method, we first get the user information
    from the `Context` like we did in the preceding methods, and then invoke the client
    method, `Send`, on all connected clients, passing in the username and image URL
    of the user who has typed the message. We will see the details of the `Send` method
    shortly, when we explore client-side methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will wrap our server-side coding of the Chat hub by configuring the HTTP
    pipeline to intercept and map any request having `chatHub` to our `ChatHub` class.
    To do so, we will write the following code in the `Configure` method of `Startup.cs`
    between `app.UseAuthentication` and `app.UseMvc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This wraps up our server-side coding. Next, we will look at the client-side
    coding that we will do in our View.  The user interface code is quite straightforward
    and so we will not go into details. The reader can browse the source code and
    see the user interface code and the used `.css` classes. We will look at the client-side
    JavaScript code that would be needed to complete the chat room experience. As
    a matter of best practice, all the JavaScript/jQuery coding should be done in
    a separate `.js` file and referenced in the View. For the sake of simplicity,
    I shall be showing the inline JavaScript in the View itself. So let''s code the
    client-side stuff:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by ensuring that the following references for CSS and JavaScript are
    present in the `_Layout.cshtml` file, so that they would be available in our View
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Index.cshtml` of our `HomeController` class, create a `<script>` node
    and initialize the SignalR hub connection in the bottom of the page as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to define the following methods that we saw previously, while
    doing the server side coding:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetUsersOnline`: This method displays connected users in the left panel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UsersJoined`: This method is fired when a user joins the chat room. This method
    displays information to the effect that the user has joined the room.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UsersLeft`: This method is fired when a user leaves the chat room. This method
    displays information to the effect that the user has left the room.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Send`: This method is called when a user types a message and clicks on the
    `Send` button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The pseudo code for the preceding methods is as follows. The detailed and complete
    code can be seen from the source code repository URL ([https://github.com/PacktPublishing/.NET-Core-2.0-By-Example](https://github.com/PacktPublishing/.NET-Core-2.0-By-Example))
    shared with the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: While doing any client-side development or any web page/View design using Bootstrap,
    you can make use of Bootstrap theme sites such as [https://bootswatch.com/default/](https://bootswatch.com/default/),
    which gives the preceding code as needed, and can be used with minimal changes.
    We can spin up a web page or a complete site in a matter of hours. Do try it out!
    It's very handy!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we are done with the user interface and client-side coding, our Let''s
    Chat application is ready to be used. Let''s run the application. This is what
    the user interface of the Let''s Chat application looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90af6620-da31-48e7-8ad8-3d3479e13857.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at it from top to bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: It recognizes the logged in user and hence is able to display Hello `{User Name}`
    (Rishabh Verma in the screenshot), so our authentication module is working fine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the left, it displays Online Users, which lists just one name, so it is able
    to track users that are connected to the chat room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Chat area, we can see Rishabh Verma joined the chat room, Neha Shrivastava
    joined the chat room, so our `IUserTracker` class is working fine in conjunction
    with the authentication module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Facebook profile pictures of users display with their message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It also displays text if a user leaves the chat room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, our Let's Chat application code is complete. Next, we will do unit
    testing to ensure that issues or bugs in the code are caught at the time of development
    itself, and we thus ship and deploy a quality product. In the process, we will
    also learn about testing with reference to ASP.NET Core 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Testing overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The famous Java programmer, Bruce Eckel, come up with a slogan which highlights
    the importance of testing software:'
  prefs: []
  type: TYPE_NORMAL
- en: If it ain't tested, it's broken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though a confident programmer may challenge this, it beautifully highlights
    the ability to determine that code works as expected over and over again, without
    any exception. How do we know that the code that we are shipping to the end user
    or customer is of good quality and all the user requirements would work? By testing?
    Yes, by testing, we can be confident that the software works as per customer requirements
    and specifications. If there are any discrepancies between expected and actual
    behavior, it is referred to as a bug/defect in the software. The earlier the discrepancies
    are caught, the more easily they can be fixed before the software is shipped;
    and the results is good quality. No wonder  software testers are also referred
    to as quality control analysts in various software firms. The mantra for a good
    software tester would be:'
  prefs: []
  type: TYPE_NORMAL
- en: In God we trust, the rest we test.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not go into types of testing in any depth, as that would make another
    chapter in itself. We will look at them briefly, and then write our unit tests,
    which every good developer should write after writing any software program. Software
    testing is conducted at various levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: While coding, the developer conducts tests on a unit of a
    program to validate that the code they have written is error-free. We will write
    a few unit tests shortly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration testing**: In a team where a number of developers are working,
    there may be different components that the developers are working on. Even if
    all developers perform unit testing and ensure that their units are working fine,
    there is still a need to ensure that, upon integration of these components, they
    work without any error. This is achieved through integration testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System testing**: The entire software product is tested as a whole. This
    is accomplished using one or more of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functionality testing**: Test all the functionality of the software against
    the business requirement document.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance testing**: To test how performant the software is. It tests the
    average time, resource utilization, and so on, taken by the software to complete
    a desired business use case. This is done by means of load testing and stress
    testing, where the software is put under high user and data load.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security testing**: Tests how secure the software is against common and well-known
    security threats.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accessibility testing**: Tests if the user interface is accessible and user-friendly
    to specially-abled people or not.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User acceptance testing**: When the software is ready to be handed over to
    the customer, it goes through a round of testing by the customer for user interaction
    and response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regression testing**: Whenever a piece of code is added/updated in the software
    to add a new functionality or fix an existing functionality, it is tested to detect
    if there are any side-effects from the newly added/updated code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of all these different types of testing (and many more not listed here), we
    would focus on unit testing, as that is done by the developer coding the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET Core has been designed with testability in mind. .NET Core 2.0 has unit
    test project templates for VB, F#, and C#. We can also pick the testing framework
    of our choice amongst xUnit, NUnit, and MSTest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit tests that test single programming parts are the most minimal-level tests.
    Unit tests should just test code inside the developer''s control, and ought to
    not test infrastructure concerns, for example databases, filesystems, or network
    resources. Unit tests might be composed utilizing **test-driven development**
    (**TDD**) or they can be added to existing code to affirm its accuracy. The naming
    convention of `Test` class names should end with `Test` and reside in the same
    namespace as the class being tested. For instance, the unit tests for the `Microsoft.Example.AspNetCore`
    class would be in the `Microsoft.Example.AspNetCoreTest` class in the test assembly.
    Also, unit test method names must be descriptive about *what is being tested*, *under
    what conditions*, and *what the expectations are*. A good unit test has three
    main parts to it in the following specified order:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrange
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Act
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We first arrange the code and then act on it and then do a series of asserts
    to check if the actual output matches the expected output. Let''s have a look
    at them in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange: **All the parameter building, and method invocations needed for
    making a call in the act section must be declared in the arrange section.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Act:** The act stage should be one statement and as simple as possible. This
    one statement should be a call to the method that we are trying to test.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Assert:** The only reason method invocation may fail is if the method itself
    throws an exception, else, there should always be some state change or output
    from any meaningful method invocation. When we write the act statement, we anticipate
    an output and then do assertions if the actual output is the same as expected.
    If the method under test should throw an exception under normal circumstances,
    we can do assertions on the type of exception and the error message that should
    be thrown.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should be watchful, while writing unit test cases, that we don't inject any
    dependencies on the infrastructure. Infrastructure dependencies should be taken
    care of in integration test cases, not in unit tests. We can maintain a strategic
    distance from these shrouded dependencies in our application code by following
    the Explicit Dependencies Principle and utilizing Dependency Injection to request
    our dependencies on the framework. We can likewise keep our unit tests in a different
    project from our integration tests and guarantee our unit test project doesn't
    have references to the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Testing using xUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section we will learn to write unit and integration tests for our controllers.
    There are a number of options available to us for choosing the test framework.
    We will use xUnit for all our unit tests and Moq for mocking objects. Let''s create
    a xUnit test project by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Let's Chat project in Visual Studio 2017
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named  `Test`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `Test` folder and click Add | New Project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select xUnit Test Project (.NET Core) under Visual C# project templates, as
    shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ecbd02c7-afd6-459a-a477-222ab220deb5.png)'
  prefs: []
  type: TYPE_IMG
- en: Delete the default test class that gets created with the template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a test class inside this project `AuthenticationControllerUnitTests`
    for the unit test
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to add some NuGet packages. Right-click the project in VS 2017 to edit
    the project file and add the references manually, or use the NuGet Package Manager
    to add these packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With this, we are now ready to write our unit tests. Let's start doing this,
    but before we do that, here's some quick theory about xUnit and Moq.
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation from the xUnit website and Wikipedia tells us that xUnit.net
    is a free, open source, community-focused unit testing tool for the .NET Framework.
    It is the latest technology for unit testing C#, F#, Visual Basic .NET, and other
    .NET languages. All xUnit frameworks share the following basic component architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test runner**: It is an executable program that runs tests implemented using
    an xUnit framework and reports the test results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test case**: It is the most elementary class. All unit tests are inherited
    from here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test fixtures:** Test fixures (also known as a test context) are the set
    of preconditions or state needed to run a test. The developer should set up a
    known good state before the tests, and return to the original state after the
    tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test suites:** It is a set of tests that all share the same fixture. The
    order of the tests shouldn''t matter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'xUnit.net includes support for two different major types of unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Facts**:Tests which are always true. They test invariant conditions, that
    is, data-independent tests.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Theories**: Tests which are only true for a particular set of data*.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Moq** is a mocking framework for C#/.NET. It is used in unit testing to isolate
    the class under test from its dependencies, and ensure that the proper methods
    on the dependent objects are being called.'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that in unit tests, we only test a unit or a layer/part of the software
    in isolation and hence do not bother about external dependencies, so we assume
    they work fine and just mock them using the mocking framework of our choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put this theory into action by writing a unit test for the following
    action in `AuthenticationController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The unit test code depends on how the method to be tested is written. To understand
    this, let''s write a unit test for a `SignIn` action. To test the `SignIn` method,
    we need to invoke the `SignIn` action in `AuthenticationController`. To do so,
    we need an instance of the `AuthenticationController` class, on which the `SignIn`
    action can be invoked. To create the instance of `AuthenticationController`, we
    need a logger object, as the `AuthenticationController` constructor expects it
    as a parameter. Since we are only testing the `SignIn` action, we do not bother
    about the logger and so we can mock it. Let''s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Reading the comments would explain the unit test code. The previous example
    shows how easy it is to write a unit test. Through depending upon the method to
    be tested, things can get complicated, but most of it would be around mocking
    the objects and, with some experience on the mocking framework and binging around,
    mocking should not be a difficult task. The unit test for the `SignOut` action
    would be a bit complicated in terms of mocking as it uses `HttpContext`. The unit
    test for the `SignOut` action is left to the reader as an exercise. Let's explore
    a new feature introduced in Visual Studio 2017 called Live Unit Testing.
  prefs: []
  type: TYPE_NORMAL
- en: Live Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may disappoint you but **Live Unit Testing** (**LUT**) is available only
    in the Visual Studio 2017 Enterprise edition and not in the Community edition.
    What is Live Unit Testing? It's a new productivity feature, introduced in the
    Visual Studio 2017 Enterprise edition, that provides real-time feedback directly
    in the Visual Studio editor on how code changes are impacting unit tests and code
    coverage. All this happens live, while you write the code and hence it is called
    Live Unit Testing. This will help in maintaining the quality by keeping tests
    passing as changes are made. It will also remind us when we need to write additional
    unit tests, as we are making bug fixes or adding features.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start Live Unit Testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Test menu item
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Live Unit Testing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click Start, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7fff37d1-b81e-4220-8dc7-74cd10389323.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On clicking this, your CPU usage may go higher as Visual Studio spawns the
    MSBuild and tests runner processes in the background. In a short while, the editor
    will display the code coverage of the individual lines of code that are covered
    by the unit test. The following image displays the lines of code in `AuthenticationController`
    that are covered by the unit test. On clicking the right icon, it displays the
    tests covering this line of code and also provides the option to run and debug
    the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e66530b5-25c2-41af-bb11-b5b9327bbbd0.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, if we open the test file, it will show the indicator there as well.
    Super cool, right!
  prefs: []
  type: TYPE_NORMAL
- en: 'If we navigate to Test|Live Unit Testing now, we would see the options to Stop
    and Pause. So, in case we wish to save  our resources after getting the data once,
    we can pause or stop Live Unit Testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24ba706b-894e-47a2-a1f0-0e6b2fa9501e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are numerous icons which indicates the code coverage status of individual
    lines of code. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Red cross**: Indicates that the line is covered by at least one failing test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/deaba7b9-0b62-4972-a9da-b408d0954e11.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Green check mark**: Indicates that the line is covered by only passing tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/9cc0d169-5bd9-4ed4-ba31-f6c14f26bfa0.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Blue dash**: Indicates that the line is not covered by any test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/2f63d887-8e5b-4df0-8760-8a49a140bfea.png)'
  prefs: []
  type: TYPE_IMG
- en: If you see a clock-like icon just below any of these icons, it indicates that
    the data is not up to date. With this productivity enhancing feature, we conclude
    our discussion on basic unit testing. Next we will learn about containers and
    how we can do the deployment and testing of our .NET Core 2.0 applications in
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Think of a container as just another process running in the machine; it''s
    just that they offer a lot more isolation than a normal process does. So, we define
    a container as an isolated process. A container can have its own filesystem, own
    network IP address, own hostname, own registry, own unique resources and so on.
    A question that would come to mind is: *Why Containers?* In the modern world,
    where new software comes in and changes overnight, there are numerous challenges
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Discovering the software**: There is no single point at which to find all
    software. A few are available as executables on the developer sites, a few in
    platform-specific application stores, a few as package managers, and so on and
    so forth.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Installing the software**: Software can be installed on specific OS, CPU
    architectures, OS versions, and build versions with the relevant prerequisites.
    Over a period of time, this becomes messy and confusing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Running the software**: We have all faced the issue where *I am unable to
    find that software that I  downloaded*. Applications that are installed and updated
    in the registry are easy to find but the ones that run as stand alone executables
    are more likely to missed. On top of that, we have licensing, upgrades, documentation,
    paths, and so on to take care of if we wish to run the software. On top of it,
    are we 100% sure that the executable that we are running is secure and would not
    cause a security breach if it''s run on the machine?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These slightly over exaggerated points highlight that there are challenges a
    plenty in discovering, installing, and running software. Containers are about
    software and relieve much of this pain. Just as shipping containers allow goods
    to be transported by ship, train, or truck regardless of the cargo inside, software
    containers act as a standard unit of software that can contain different code
    and dependencies. Containerizing software this way enables developers and IT professionals
    to deploy them across environments, with little or no modification. Containers
    also isolate applications from each other on a shared OS. Containerized applications
    run on top of a container host that in turn runs on the OS (Linux or Windows).
    Containers therefore have a significantly smaller footprint than **virtual machine**
    (**VM**) images. There is a myth that containers are replacements for VMs, which
    is incorrect. Containers require fewer resources than VMs, and hence a server
    can host more containers than VMs, making choice easier when there is a confusion.
    There are a number of containers available in the market today such as LXC, Docker,
    and so on. We will use Docker as our container, and will discuss it next.
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker is an open source project for automating the deployment of applications
    as portable, self-sufficient containers that can run on the cloud or on-premise.
    Docker is also a company that promotes and evolves this technology. Docker works
    in collaboration with cloud, Linux, and Windows vendors, including Microsoft.
    Docker image containers run natively on Linux and Windows. Windows images run
    only on Windows hosts and Linux images run only on Linux hosts. The host is a
    server or a VM. Docker containers package an application with everything it needs
    to run: code, runtime, system tools, system libraries—anything we would install on
    a server for the application to run.  A container is an isolated place where an
    application can run without affecting the rest of the system, and vice versa.
    This makes them an ideal way to package and run applications in production environments. 
    Additionally, as discussed previously, Docker containers are lightweight which
    enables scaling applications quickly by spinning up new instances.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we  deploy our Let''s Chat application in Docker, let''s get familiar
    with Docker terminology from Microsoft''s official documentation site, ([https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/container-docker-introduction/docker-terminology](https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/container-docker-introduction/docker-terminology)):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Container image**: It is a package with all the dependencies and information
    needed to create a container. An image includes all the dependencies such as frameworks,
    deployment, and the execution configuration to be used by a container at runtime.
    An image is immutable once it has been created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container**: An instance of a Docker image is called a container. It represents
    the execution of a single application, process, or service. It consists of the
    contents of a Docker image, an execution environment, and a standard set of instructions.
    When scaling a service, we create multiple instances of a container from the same
    image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tag**: A mark or label applied to images, so that different images or versions
    can be identified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dockerfile**: It is a text file that contains instructions to build a Docker
    image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build**: The action of building a container image, based on the information
    and context provided by its Docker file, and additional files in the folder where
    the image is built. We can build images with the Docker docker build command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repository**: A collection of related Docker images, labeled with a tag that
    indicates the image version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Registry**: A service that provides access to repositories. The default registry
    for most public images is the Docker Hub (owned by Docker as an organization).
    A registry usually contains repositories from multiple teams. Companies often
    have private registries to store and manage images they''ve created; the Azure
    Container Registry is another example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Hub**: A public registry to upload images and work with them. Docker
    Hub provides Docker image hosting, public or private registries, build triggers
    and web hooks, and integration with GitHub and Bitbucket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Container Registry**: A public resource for working with Docker images
    and its components in Azure. This provides a registry that is close to deployments
    in Azure and that gives control over access, making it possible to use Azure Active
    Directory groups and permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compose**: A command-line tool and YAML file format with metadata for defining
    and running multi-container applications. We define a single application based
    on multiple images with one or more `.yml` files that can override values depending
    on the environment. After creating the definitions, we can deploy the whole multi-container
    application with a single command (`docker-compose up`) that creates a container
    per image on the Docker host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is just a basic introduction to Docker to get us started. There is a lot
    to be learned, so much so that a complete book can be written on Docker itself.
    So, interested and curious readers should spend quality time in familiarizing
    themselves with Docker from the Docker documentation site, or Microsoft's documentation
    on Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have some context about Docker, let''s try and deploy our Let''s
    Chat application in a Docker container, using the tooling provided by Visual Studio
    2017\. To do so, we will follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If you have used Visual Studio 2017 and worked along with the chapters thus
    far, you already have Docker support enabled with the Visual Studio installation.
    If not, you would need to modify the Visual Studio 2017 installation and choose
    the .NET Core cross-platform development workload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will need to install Docker for Windows from [https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/).
    It's a simple installation in which you just need to do Next | OK | Finish stuff,
    so we will not discuss it here. As of writing this chapter, 17.12 is the latest
    version.[](https://docs.docker.com/docker-for-windows/install/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the installation is successful, we would see a dialog as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/08ae1984-ba70-4678-9a5c-9a92ecbdbcc0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we would need to share the drive in our local machine with Docker, where
    the images can be built and run. To do this, right-click on the Docker system
    tray icon and click Settings, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/646112c7-3269-45ad-98aa-d51b30394747.png)'
  prefs: []
  type: TYPE_IMG
- en: Share the drive where the images will run from in the Shared Drives tab of Settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, open the Let's Chat project in Visual Studio 2017.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on `LetsChat.csproj` and choose Add | Docker Support.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Visual Studio would do all the heavy lifting for us and add a Docker file amongst
    a few others as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4c387b17-31b0-466a-a4c9-c860364e9ac9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also see that the  Start  button in the command bar has changed to Docker,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7a3cde48-2eaa-4a2a-8937-6652f32d0366.png)'
  prefs: []
  type: TYPE_IMG
- en: With this, we are done with our steps. Just click on the Docker button (or press
    *F5*) and the application will run in the Docker container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will see in [Chapter 10](ch10.html), *Functional Programming with F#* how
    we can deploy the application in the cloud, as well as how we can deploy Docker
    containers in Azure. This wraps up our discussion on Docker containers. We will
    conclude this chapter by learning to develop a FAQ Bot using the Microsoft Bot
    Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Bot 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Chatbot, also known as talkbot, chatterbot, Bot, or IM bot, is a computer
    program which conducts a conversation through auditory or textual methods. Such
    programs are often designed to convincingly simulate how a human would behave
    as a conversational partner, thereby passing the Turing test. Chatbots are typically
    used in dialog systems for various practical purposes, including customer service
    or information acquisition. You would have noticed that various sites offer live
    chat with agents as it helps them gain better customer experience and business.
    In this section, we will see how we can quickly create a simple Chatbot to answer
    the basic questions. This section is completely informational and just provides
    a basic 100-level awareness of how a simple Chatbot can be created and the related
    technology. Curious and enthusiastic readers can explore other avenues from this
    basic knowledge. Let''s learn to develop a simple FAQ Bot, which will answer simple
    queries like:'
  prefs: []
  type: TYPE_NORMAL
- en: How do I use Let's Chat?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are you?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hello!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bye!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The more you train the Bot and the more questions you put in its knowledge
    base, the better it will be, so let''s get started. First of all, we need to create
    a page that can be accessed anonymously, as this is **frequently asked questions**
    (**FAQ** ), and hence the user should not be required to be logged in to the system
    to access this page. To do so, let''s create a new controller called `FaqController`
    in our `LetsChat.csproj`. It will be a very simple class with just one action
    called `Index`, which will display the FAQ page. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we have used the `[AllowAnonymous]` attribute, so that  this controller
    can be accessed even if the user is not logged in. The corresponding `.cshtml`
    is also very simple. In the solution explore, right-click on the Views folder
    under the `LetsChat` project and create a folder named `Faq` and then add an `Index.cshtml`
    file in that folder. The markup of the `Index.cshtml` would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Nothing much here apart from the welcome message. The message displays the username
    if the user is authenticated, else it displays `Guest`. Now, we need to integrate
    the Chatbot stuff in this page. To do so, let's browse to [http://qnamaker.ai](http://qnamaker.ai).
    This is Microsoft's QnA (as in questions and answers) maker site which a free,
    easy-to-use, REST API and web-based service that trains **artificial intelligence**
    (**AI**) to respond to user questions in a more natural, conversational way. Compatible
    across development platforms, hosting services, and channels, QnA Maker is the
    only question and answer service with a graphical user interface—meaning you don’t
    need to be a developer to train, manage, and use it for a wide range of solutions.
    And that is what makes it incredibly easy to use. You would need to log in to
    this site with your Microsoft account (`@microsoft`/`@live`/`@outlook`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t have one, you should create one and log in. On the very first
    login, the site would display a dialog seeking permission to access your email
    address and profile information. Click Yes and grant permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/379293d3-5aea-441f-8dc5-381bb76224d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You would then be presented with the service terms. Accept that as well. Then
    navigate to the Create New Service tab. A form will appear as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db61900f-1dd1-4017-a5f1-439bae9bd77a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The form is easy to fill in and provides the option to extract the question/answer
    pairs from a site or `.tsv`, `.docx`, `.pdf`, and `.xlsx` files. We don''t have
    questions handy and so we will type them; so do not bother about these fields.
    Just enter the service name and click the Create button. The service should be
    created successfully and the knowledge base screen should be displayed. We will
    enter probable questions and answers in this knowledge base. If the user types
    a question that resembles the question in the knowledge base, it will respond
    with the answer in the knowledge base. Hence, the more questions and answers we
    type, the better it will perform. So, enter all the questions and answers that
    you wish to enter, test it in the local Chatbot setup, and, once you are happy
    with it, click on Publish. This would publish the knowledge bank and share the
    sample URL to make the HTTP request. Note it down in a notepad. It contains the
    knowledge base identifier guide, hostname, and subscription key. With this, our
    questions and answers are ready and deployed. We need to display a chat interface,
    pass the user-entered text to this service, and display the response from this
    service to the user in the chat user interface. To do so, we will make use of
    the Microsoft Bot Builder SDK for .NET and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the `Bot Application` project template from [http://aka.ms/bf-bc-vstemplate.](http://aka.ms/bf-bc-vstemplate)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the `Bot Controller` item template from [http://aka.ms/bf-bc-vscontrollertemplate.](http://aka.ms/bf-bc-vscontrollertemplate)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the `Bot Dialog` item template from [http://aka.ms/bf-bc-vsdialogtemplate.](http://aka.ms/bf-bc-vsdialogtemplate)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, identify the project template and item template directory for Visual Studio
    2017\. The project template directory is located at `%USERPROFILE%\Documents\Visual
    Studio 2017\Templates\ProjectTemplates\Visual C#\` and the item template directory
    is located at `%USERPROFILE%\Documents\Visual Studio 2017\Templates\ItemTemplates\Visual
    C#\`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `Bot Application` project template to the project template directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `Bot Controller` ZIP and `Bot Dialog` ZIP to the item template directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the solution explorer of the `LetsChat` project, right-click on the solution
    and add a new project. Under Visual C#, we should now start seeing a `Bot Application`
    template as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/97f782e4-e57f-4cba-8d7e-0e0dad251975.png)'
  prefs: []
  type: TYPE_IMG
- en: Name the project `FaqBot` and click OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new project will be created in the solution, which looks similar to the MVC
    project template. Build the project, so that all the dependencies are resolved
    and packages are restored. If you run the project, it is already a working Bot,
    which can be tested by the Microsoft Bot Framework emulator. Download the BotFramework-Emulator
    setup executable from [https://github.com/Microsoft/BotFramework-Emulator/releases/.](https://github.com/Microsoft/BotFramework-Emulator/releases/tag/v3.5.34)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run the Bot project by hitting *F5*. It will display a page pointing
    to the default URL of `http://localhost:3979`. Now, open the Bot framework emulator
    and navigate to the preceding URL and append `api/messages`; to it, that is, browse
    to `http://localhost:3979/api/messages` and click Connect. On successful connection
    to the Bot, a chat-like interface will be displayed in which you can type the
    message. The following screenshot displays this step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9001ba6a-df8a-4b4f-a3aa-e31e8ca3fe45.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have a working Bot in place which just returns the text along with its length.
    We need to modify this Bot, to pass the user input to our QnA Maker service and
    display the response returned from our service. To do so, we will need to check
    the code of `MessagesController` in the `Controllers` folder. We notice that it
    has just one method called `Post`, which checks the activity type, does specific
    processing for the activity type, creates a response, and returns it. The calculation
    happens in the `Dialogs.RootDialog` class, which is where we need to make the
    modification to wire up our QnA service. The modified code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The code is pretty straightforward. First, we add the QnA Maker service subscription
    key, host URL, and knowledge base ID in the `appSettings` section of `Web.config`.
    Next, we read these app settings into static variables so that they are available
    always. Next, we modify the `MessageReceivedAsync` method of the dialog to pass
    the user input to the QnA service and return the response of the service back
    to the user. The `QnAResult` class can be seen from the source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be tested in the emulator by typing in any of the questions that we
    have stored in our knowledge base, and we will get the appropriate response, as
    shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9df01620-17e1-4d87-9b4c-829bba6e86ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Deploying it in our Let's Chat application would need a basic knowledge of Azure,
    which we have not touched on yet. We will continue deploying and integrating this
    Chatbot in our Let's Chat application later in [Chapter 10](https://cdp.packtpub.com/_net_core_2_0_by_example/wp-admin/post.php?post=174&action=edit#post_376), *Functional
    Programming with F#*, when we discuss and learn Azure fundamentals and will be
    deploying ASP.NET Core 2.0 applications in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our awareness discussion on developing a basic Chatbot using
    the Microsoft Bot Framework, the QnA Maker service, and ASP.NET Core 2.0\. The
    Bot can be deployed in Azure and can be integrated to work with a variety of channels
    such as Skype, Facebook, web chat, and so on. With this, we conclude our chapter
    as well. In the next chapter, we would look into a new term that has sprung up
    over the last few years called microservices, with respect to ASP.NET Core 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learnt about Razor syntax, Views, Razor pages, and Tag Helpers.
    We then coded the Chat hub module of our Let's Chat application. We also learnt
    the importance of testing and how we can write unit tests using Moq and xUnit.
    We saw a new productivity-enhancing feature introduced in Visual Studio 2017 Enterprise
    edition called Live Unit Testing and how it helps us write better-quality code.
    We also learnt about containers and how we can deploy our application in Docker
    from Visual Studio itself. We concluded the chapter by learning about developing
    a FAQ Bot using the Microsoft Bot Framework and ASP.NET Core 2.0\. We have not
    deployed our application in the cloud yet, which we will do in [Chapter 10](https://cdp.packtpub.com/_net_core_2_0_by_example/wp-admin/post.php?post=174&action=edit#post_376), *Functional
    Programming with F#*. In the next couple of chapters, we will delve into the new
    world of microservices.
  prefs: []
  type: TYPE_NORMAL
